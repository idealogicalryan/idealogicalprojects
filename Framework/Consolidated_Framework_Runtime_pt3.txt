# CONSOLIDATED: Framework.Runtime
# GENERATED: 2025-11-17 11:55:11
# PART: 3
# FILE COUNT (part): 127
# LINE ENDINGS: LF
# ENCODING: UTF-8 (no BOM)
# INDEX BEGIN
# SYSTEM: com_ldx_frameworkSystem (127 files)
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedSoftJointLimit.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedSoftJointLimitSpring.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/AutoHandPlayer.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/AutoHandPlayerForceArea.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/BodyPhysicsFollower.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Climbable.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/HeadCameraSmoothing.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/HeadPhysicsFollower.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/IgnoreHandPlayerCollision.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolatedTransform.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolatedTransformUpdater.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolationController.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/PlayerPlatform.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Pushable.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Teleporter.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPoint.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPointAnimation.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPointSoundEffects.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/GrabbableEventDebugger.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandEventDebugger.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandEventTemplate.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandTouchEventDebugger.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/PlacePointEventDebugger.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/PlacePointEventTemplate.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/AutoHandSettings.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/AutoInputModule.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionIgnores.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionSound.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionTracker.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/HandCanvasPointer.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/MagneticBody.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/MagneticSource.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/PhysicsFollower.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Smash.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Smasher.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stabbable.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stabber.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stickable.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Sticky.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/BlankUser.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/BoxColliderGenerator.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/CapsuleColliderGenerator.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ComplexSurfaceGenerator.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/EdgeColliderGenerator.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ISampleModifier.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/LengthCalculator.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/MeshGenerator.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Node.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectBender.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerCustomRuleBase.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerSineRule.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerSpiralRule.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ParticleController.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/PathGenerator.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/PolygonColliderGenerator.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/ColorModifier.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/FollowerSpeedModifier.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/MeshScaleModifier.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/OffsetModifier.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/RotationModifier.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/SizeModifier.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/SplineSampleModifier.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineComputer.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineFollower.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMesh.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMeshChannel.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMorph.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplinePositioner.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineProjector.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineRenderer.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineTracer.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineUser.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SurfaceGenerator.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/TubeGenerator.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/WaveformGenerator.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/CSV.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/SplineParser.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/SVG.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/ObjectSequence.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Capsule.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Ellipse.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Line.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Ngon.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Rectangle.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/RoundedRectangle.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Spiral.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/SplinePrimitive.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Star.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SampleCollection.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Spline.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplinePoint.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplinePrefs.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineSample.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineThreading.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineTrigger.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineUtility.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/TransformModule.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/AudioVisualization/SpectrumVisualizer.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Following/Scripts/CameraSmoothRotation.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Following/Scripts/URLButton.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/JunctionSwitch.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/TrainCamera.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/TrainEngine.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/Wagon.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/LengthEvents/SetMaterialColor.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/AddForceAlongPath.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/BallCamera.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/LapCounter.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/RollerCoaster/Scripts/CameraLook.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/RollerCoaster/Scripts/RollerCoaster.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/ArrayUtility.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/AsyncJobSystem.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/DMath.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/DuplicateUtility.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/LinearAlgebraUtility.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/MeshUtility.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/PrivateSingleton.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Randomizer.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/SceneUtility.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/ScriptableObjectUtility.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Singleton.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TransformUtility.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Bounds.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Mesh.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Transform.cs
#   Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Utilities.cs
# INDEX END
#
# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedSoftJointLimit.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f37852b160323da458da84a978e07a54
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;

[System.Serializable]
public class SerializedSoftJointLimit {
    private SoftJointLimit struc = new SoftJointLimit();
    public static implicit operator SoftJointLimit(SerializedSoftJointLimit c) {
        return new SoftJointLimit() { limit = c._limit, bounciness = c._bounciness, contactDistance = c._contactDistance };
    }
    public static explicit operator SerializedSoftJointLimit(SoftJointLimit c) {
        return new SerializedSoftJointLimit(c);
    }
    public SerializedSoftJointLimit() { }
    private SerializedSoftJointLimit(SoftJointLimit _data) {
        this.limit = _data.limit;
        this.bounciness = _data.bounciness;
        this.contactDistance = _data.contactDistance;
    }
    [SerializeField]
    private float _limit = 0;
    [SerializeField]
    private float _bounciness = 0;
    [SerializeField]
    private float _contactDistance = 0;

    public float limit { get { return struc.limit; } set { _limit = struc.limit = value; } }
    public float bounciness { get { return struc.bounciness; } set { _bounciness = struc.bounciness = value; } }
    public float contactDistance { get { return struc.contactDistance; } set { _contactDistance = struc.contactDistance = value; } }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedSoftJointLimit.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedSoftJointLimitSpring.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cdbdf138596bf63448e3b8cca5e3640d
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;

[System.Serializable]
public class SerializedSoftJointLimitSpring {
    private SoftJointLimitSpring struc = new SoftJointLimitSpring();

    public static implicit operator SoftJointLimitSpring(SerializedSoftJointLimitSpring c) {
        return new SoftJointLimitSpring() { spring = c._spring, damper = c._damper };
    }
    public static explicit operator SerializedSoftJointLimitSpring(SoftJointLimitSpring c) {
        return new SerializedSoftJointLimitSpring(c);
    }

    public SerializedSoftJointLimitSpring() { }
    private SerializedSoftJointLimitSpring(SoftJointLimitSpring _data) {
        this.damper = _data.damper;
        this.spring = _data.spring;
    }

    [SerializeField]
    private float _spring = 0;
    [SerializeField]
    private float _damper = 0;

    public float damper { get { return struc.damper; } set { _damper = struc.damper = value; } }
    public float spring { get { return struc.spring; } set { _spring = struc.spring = value; } }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedSoftJointLimitSpring.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/AutoHandPlayer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d8a35128610d1b34892726ec96e587d0
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Autohand.Demo;
using System;
using NaughtyAttributes;
using UnityEngine.Serialization;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Autohand {
    public enum RotationType {
        snap,
        smooth
    }

    public delegate void AutoHandPlayerEvent(AutoHandPlayer player);

    [RequireComponent(typeof(Rigidbody)), RequireComponent(typeof(CapsuleCollider)), DefaultExecutionOrder(1)]
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand-3.1/auto-hand-player")]
    public class AutoHandPlayer : MonoBehaviour {

        static bool notFound = false;
        public static AutoHandPlayer _Instance;
        public static AutoHandPlayer Instance {
            get {
                if(_Instance == null && !notFound)
                    _Instance = AutoHandExtensions.CanFindObjectOfType<AutoHandPlayer>();

                if(_Instance == null)
                    notFound = true;

                return _Instance;
            }
        }



        [AutoHeader("Auto Hand Player")]
        public bool ignoreMe;



        [Tooltip("The tracked headCamera object")]
        public Camera headCamera;
        [Tooltip("The object that represents the forward direction movement, usually should be set as the camera or a tracked controller")]
        public Transform forwardFollow;
        [Tooltip("This should NOT be a child of this body. This should be a GameObject that contains all the tracked objects (head/controllers)")]
        public Transform trackingContainer;
        public Hand handRight;
        public Hand handLeft;



        [AutoToggleHeader("Movement")]
        public bool useMovement = true;
        [EnableIf("useMovement"), FormerlySerializedAs("moveSpeed")]
        [Tooltip("Movement speed when isGrounded")]
        public float maxMoveSpeed = 2.3f;
        [EnableIf("useMovement")]
        [Tooltip("Movement acceleration when isGrounded")]
        public float moveAcceleration = 100000f;
        [EnableIf("useMovement")]
        [Tooltip("Whether or not to use snap turning or smooth turning"), Min(0)]
        public RotationType rotationType =  RotationType.snap;
        [Tooltip("turn speed when not using snap turning - if snap turning, represents angle per snap")]
        public float snapTurnAngle = 30f;
        public float smoothTurnSpeed = 180f;
        public bool bodyFollowsHead = true;
        public float maxHeadDistance = 0.5f;
        public bool useSmoothStep = false;
        [ShowIf("useSmoothStep")]
        [Tooltip("How quickly to smooth step up/down when stepping onto a surface.")]
        public float stepSmoothSpeed = 6f;



        [AutoToggleHeader("Height")]
        public bool showHeight = true;
        [ShowIf("showHeight"), Tooltip("Smooths camera upward movement when stepping up")]
        public float heightSmoothSpeed = 10f;
        [ShowIf("showHeight")]
        public float heightOffset = 0f;
        [ShowIf("showHeight")]
        public bool crouching = false;
        [ShowIf("showHeight")]
        public float crouchHeight = 0.6f;
        [ShowIf("showHeight")]
        [Tooltip("Whether or not the capsule height should be adjusted to match the headCamera height")]
        public bool autoAdjustColliderHeight = true;
        [ShowIf("showHeight")]
        [Tooltip("Minimum and maximum auto adjusted height, to adjust height without auto adjustment change capsule collider height instead")]
        public Vector2 minMaxHeight = new Vector2(0.5f, 2.5f);
        [ShowIf("showHeight")]
        public bool useHeadCollision = true;
        [ShowIf("showHeight")]
        public float headRadius = 0.15f;




        [AutoToggleHeader("Use Grounding")]
        public bool useGrounding = true;
        [EnableIf("useGrounding"), Tooltip("Maximum height that the body can step up onto"), Min(0)]
        public float maxStepHeight = 0.3f;
        [Tooltip("The space between the bottom of the body and the spherecast the checks for the ground and steps")]
        public float groundingPenetrationOffset = 0.1f;
        [EnableIf("useGrounding"), Tooltip("Maximum angle the player can walk on"), Min(0)]
        public float maxStepAngle = 45f;
        [EnableIf("useGrounding"), Tooltip("The layers that count as ground")]
        public LayerMask groundLayerMask;
        [EnableIf("useGrounding"), Tooltip("Movement acceleration when isGrounded")]
        public float groundedDrag = 10000f;
        [Tooltip("Movement acceleration when grounding is disabled")]
        public float flyingDrag = 4f;



        [AutoToggleHeader("Enable Climbing")]
        [Tooltip("Whether or not the player can use Climbable objects  (Objects with the Climbable component)")]
        public bool allowClimbing = true;
        [Tooltip("Whether or not the player move while climbing")]
        [ShowIf("allowClimbing")]
        public bool allowClimbingMovement = true;
        [Tooltip("How quickly the player can climb")]
        [ShowIf("allowClimbing")]
        public Vector3 climbingStrength = new Vector3(20f, 20f, 20f);
        public float climbingAcceleration = 30f;
        public float climbingDrag = 5f;
        [Tooltip("Inscreases the step height while climbing up to make it easier to step up onto a surface")]
        public float climbUpStepHeightMultiplier = 3f;



        [AutoToggleHeader("Enable Pushing")]
        [Tooltip("Whether or not the player can use Pushable objects (Objects with the Pushable component)")]
        public bool allowBodyPushing = true;
        [Tooltip("How quickly the player can climb")]
        [EnableIf("allowBodyPushing")]
        public Vector3 pushingStrength = new Vector3(10f, 10f, 10f);
        public float pushingAcceleration = 10f;
        public float pushingDrag = 1f;
        [Tooltip("Inscreases the step height while pushing up to make it easier to step up onto a surface")]
        public float pushUpStepHeightMultiplier = 3f;



        [AutoToggleHeader("Enable Platforming")]
        [Tooltip("Platforms will move the player with them. A platform is an object with the Transform component on it")]
        public bool allowPlatforms = true;
        [EnableIf("useGrounding"), Tooltip("The layers that platforming will be enabled on, will not work with layers that the HandPlayer can't collide with")]
        public LayerMask platformingLayerMask = ~0;


        public AutoHandPlayerEvent OnSnapTurn;
        public AutoHandPlayerEvent OnSmoothTurn;
        public AutoHandPlayerEvent OnTeleported;


        [HideInInspector]
        /// <summary>Amount of input required to trigger movement, some vr controllers will return > 0.1 input when not touching the thumbsticks so using a deadzone to prevent movement drift</summary>
        public float movementDeadzone = 0.2f;
        [HideInInspector]
        /// <summary>Amount of input required to trigger a turn, some vr controllers will return > 0.1 input when not touching the thumbsticks so using a deadzone of 0.35 or higher is important</summary>
        public float turnDeadzone = 0.4f;
        [HideInInspector]
        /// <summary>Amount of input required to reset the turn state for snap turning</summary>
        public float turnResetzone = 0.3f;


        //How many times the head will attempt to move the body to the head and depenetrate it from colliders in a single frame,
        //this value uses nested loop so the actual iterations will be 2^bodySyncMaxIterations. Recommended value of 2-4
        const int bodySyncMaxIterations = 2;
        //How many times the head will attempt to depenetrate from colliders in a single frame. Recommended value of 3-8
        const int headCollisionMaxIterations = 4;

        public const string HandPlayerLayer = "HandPlayer";

        public CapsuleCollider bodyCollider { get { return bodyCapsule; } }

        public Rigidbody body { get; protected set; }

        public RaycastHit lastGroundHit { get; protected set; }









        protected HeadPhysicsFollower headPhysicsFollower;
        protected Vector3 moveDirection;
        protected float turningAxis;

        protected Vector3 climbAxis;
        protected Dictionary<Hand, Climbable> climbing = new Dictionary<Hand, Climbable>();

        protected Vector3 pushAxis;
        protected Dictionary<Pushable, Hand> pushRight = new Dictionary<Pushable, Hand>();
        protected Dictionary<Pushable, int> pushRightCount = new Dictionary<Pushable, int>();
        protected Dictionary<Pushable, Hand> pushLeft = new Dictionary<Pushable, Hand>();
        protected Dictionary<Pushable, int> pushLeftCount = new Dictionary<Pushable, int>();

        protected CapsuleCollider bodyCapsule;
        protected Hand lastRightHand;
        protected Hand lastLeftHand;
        protected Collider[] colliderNonAlloc = new Collider[128];

        protected bool trackingStarted = false;
        protected bool isGrounded = false;
        protected bool axisReset = true;
        protected bool tempDisableGrounding = false;
        protected bool lastCrouching;
        protected float lastCrouchingHeight;
        protected float playerHeight;
        protected Vector3 lastUpdatePosition;
        protected Vector3 lastHeadPos;

        protected Vector3 targetTrackedPos;
        protected Vector3 targetPosOffset;
        Vector3 lastPlatformPosition;
        Quaternion lastPlatformRotation;
        public RaycastHit lastPlatformingHit { get; protected set; }

        float headHeightOffset;
        float highestPoint;

        /// <summary>
        /// The layermask the player can collide with
        /// </summary>
        public int handPlayerMask { get; private set; }

        public virtual void Awake() {
            if(_Instance == null) {
                _Instance = this;
                notFound = false;
            }

            lastUpdatePosition = transform.position;

            gameObject.layer = LayerMask.NameToLayer(HandPlayerLayer);

            bodyCapsule = GetComponent<CapsuleCollider>();
            bodyCapsule.material = Resources.Load<PhysicsMaterial>("NoFriction");

            body = GetComponent<Rigidbody>();
            body.interpolation = RigidbodyInterpolation.None;
            body.freezeRotation = true;
            if(body.collisionDetectionMode == CollisionDetectionMode.Discrete)
                body.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;

            if(forwardFollow == null)
                forwardFollow = headCamera.transform;

            targetTrackedPos = trackingContainer.position;
            if(useHeadCollision)
                CreateHeadFollower();
        }


        public virtual void Start() {
            StartCoroutine(WaitFlagForTrackingStart());

            handPlayerMask = AutoHandExtensions.GetPhysicsLayerMask(gameObject.layer);
#if UNITY_EDITOR
                if (Selection.activeGameObject == gameObject)
                {
                    Selection.activeGameObject = null;
                    Debug.Log("Auto Hand: highlighting hand component in the inspector can cause lag and quality reduction at runtime in VR. (Automatically deselecting at runtime) Remove this code at any time.", this);
                    Application.quitting += () => { if (Selection.activeGameObject == null) Selection.activeGameObject = gameObject; };
                }

#endif
        }

        protected virtual void OnEnable() {
            EnableHand(handRight);
            EnableHand(handLeft);
        }

        protected virtual void OnDisable() {
            DisableHand(handRight);
            DisableHand(handLeft);
        }

        IEnumerator WaitFlagForTrackingStart() {
            yield return new WaitForEndOfFrame();
            yield return new WaitForFixedUpdate();
            lastHeadPos = headCamera.transform.position;
            while(!trackingStarted) {
                if(headCamera.transform.position != lastHeadPos)
                    trackingStarted = true;
                lastHeadPos = headCamera.transform.position;
                yield return new WaitForEndOfFrame();
            }
        }

        void CreateHeadFollower() {
            if(headPhysicsFollower == null) {
                var headFollower = new GameObject().transform;
                headFollower.transform.position = headCamera.transform.position;
                headFollower.name = "Head Follower";
                headFollower.parent = transform.parent;

                var col = headFollower.gameObject.AddComponent<SphereCollider>();
                col.material = bodyCapsule.material;
                col.radius = headRadius;

                var headBody = headFollower.gameObject.AddComponent<Rigidbody>();
                headBody.linearDamping = 5;
                headBody.angularDamping = 5;
                headBody.freezeRotation = false;
                headBody.useGravity = false;
                headBody.mass = body.mass / 3f;

                headPhysicsFollower = headFollower.gameObject.AddComponent<HeadPhysicsFollower>();
                headPhysicsFollower.headCamera = headCamera;
                headPhysicsFollower.followBody = transform;
                headPhysicsFollower.trackingContainer = trackingContainer;
                headPhysicsFollower.maxBodyDistance = maxHeadDistance;
                headPhysicsFollower.Init();
            }
        }



        void CheckHands() {
            if(lastLeftHand != handLeft) {
                DisableHand(lastLeftHand);
                EnableHand(handLeft);
                lastLeftHand = handLeft;
            }

            if(lastRightHand != handRight) {
                DisableHand(lastRightHand);
                EnableHand(handRight);
                lastRightHand = handRight;
            }
        }


        void EnableHand(Hand hand) {
            if(hand == null)
                return;

            hand.OnGrabbed += OnHandGrab;
            hand.OnReleased += OnHandRelease;


            if(allowClimbing) {
                hand.OnGrabbed += StartClimb;
                hand.OnReleased += EndClimb;
            }

            if(allowBodyPushing) {
                hand.OnGrabbed += StartGrabPush;
                hand.OnReleased += EndGrabPush;
                hand.OnHandCollisionStart += StartPush;
                hand.OnHandCollisionStop += StopPush;
            }
        }

        void DisableHand(Hand hand) {
            if(hand == null)
                return;

            hand.OnGrabbed -= OnHandGrab;
            hand.OnReleased -= OnHandRelease;

            if(allowClimbing) {
                hand.OnGrabbed -= StartClimb;
                hand.OnReleased -= EndClimb;
                if(climbing.ContainsKey(hand))
                    climbing.Remove(hand);
            }

            if(allowBodyPushing) {
                hand.OnGrabbed -= StartGrabPush;
                hand.OnReleased -= EndGrabPush;
                hand.OnHandCollisionStart -= StartPush;
                hand.OnHandCollisionStop -= StopPush;
                if(hand.left) {
                    pushLeft.Clear();
                    pushLeftCount.Clear();
                }
                else {
                    pushRight.Clear();
                    pushRightCount.Clear();
                }
            }
        }

        protected virtual void OnHandGrab(Hand hand, Grabbable grab) {
            grab.IgnoreColliders(bodyCapsule);
            if(headPhysicsFollower != null)
                grab.IgnoreColliders(headPhysicsFollower.headCollider);
        }

        protected virtual void OnHandRelease(Hand hand, Grabbable grab) {
            if(grab != null && grab.HeldCount() == 0) {
                grab.IgnoreColliders(bodyCapsule, false);
                if(headPhysicsFollower != null)
                    grab.IgnoreColliders(headPhysicsFollower.headCollider, false);

                if(grab && grab.parentOnGrab && grab.body != null && !grab.body.isKinematic)
                    grab.body.linearVelocity += body.linearVelocity / 2f;
            } 
        }

        public void IgnoreCollider(Collider col, bool ignore) {
            Physics.IgnoreCollision(bodyCapsule, col, ignore);
            Physics.IgnoreCollision(headPhysicsFollower.headCollider, col, ignore);
        }


        /// <summary>Sets move direction for this fixedupdate</summary>
        public virtual void Move(Vector2 axis, bool useDeadzone = true, bool useRelativeDirection = false) {
            moveDirection.x = (!useDeadzone || Mathf.Abs(axis.x) > movementDeadzone) ? axis.x : 0;
            moveDirection.z = (!useDeadzone || Mathf.Abs(axis.y) > movementDeadzone) ? axis.y : 0;
            if(useRelativeDirection)
                moveDirection = transform.rotation * moveDirection;
        }

        public virtual void Turn(float turnAxis) {
            turnAxis = (Mathf.Abs(turnAxis) > turnDeadzone) ? turnAxis : 0;
            turningAxis = turnAxis;
        }

        protected virtual void LateUpdate() {
            if(useMovement) {
                UpdateTrackedObjects();
                UpdateTurn(Time.deltaTime);
            }
        }

        protected virtual void FixedUpdate() {
            CheckHands();
            UpdatePlayerHeight();

            if(useMovement) {
                ApplyPushingForce();
                ApplyClimbingForce();
                UpdateRigidbody();
                UpdatePlatform();
                Ground();
            }
        }


        protected virtual void UpdateRigidbody() {
            var move = AlterDirection(moveDirection);
            var yVel = body.linearVelocity.y;

            //1. Moves velocity towards desired push direction
            if (pushAxis != Vector3.zero) {
                body.linearVelocity = Vector3.MoveTowards(body.linearVelocity, pushAxis, pushingAcceleration * Time.fixedDeltaTime);
                body.linearVelocity *= Mathf.Clamp01(1 - pushingDrag * Time.fixedDeltaTime);
            }

            //2. Moves velocity towards desired climb direction
            if(climbAxis != Vector3.zero) {
                body.linearVelocity = Vector3.MoveTowards(body.linearVelocity, climbAxis, climbingAcceleration * Time.fixedDeltaTime);
                body.linearVelocity *= Mathf.Clamp01(1 - climbingDrag * Time.fixedDeltaTime);
            }

            //3. Moves velocity towards desired movement direction
            if(move != Vector3.zero && CanInputMove()) {

                var newVel = Vector3.MoveTowards(body.linearVelocity, move * maxMoveSpeed, moveAcceleration * Time.fixedDeltaTime);
                if(newVel.magnitude > maxMoveSpeed)
                    newVel = newVel.normalized * maxMoveSpeed;
                body.linearVelocity = newVel;
            }

            //5. Checks if gravity should be turned off
            if (IsClimbing() || pushAxis.y > 0)
                body.useGravity = false;


            //4. This creates extra drag when grounded to simulate foot strength, or if flying greats drag in every direction when not moving
            if (move.magnitude <= movementDeadzone && isGrounded)
                body.linearVelocity *= (Mathf.Clamp01(1 - groundedDrag * Time.fixedDeltaTime));
            else if(!useGrounding)
                body.linearVelocity *= (Mathf.Clamp01(1 - flyingDrag * Time.fixedDeltaTime));

            //6. This will keep velocity if consistent when moving while falling
            if(body.useGravity)
                body.linearVelocity = new Vector3(body.linearVelocity.x, yVel, body.linearVelocity.z);

            //7. This will move the body to track the head in tracking space without overlapping colliders
            if(bodyFollowsHead) {
                SyncBodyHead();
                PreventHeadOverlap();
            }
        }


        protected virtual void UpdateTrackedObjects() {

            var startRightHandPos = handRight.transform.position;
            var startLeftHandPos = handLeft.transform.position;

            //Moves the tracked objects based on the physics bodys delta movement
            targetTrackedPos += (transform.position - lastUpdatePosition);
            trackingContainer.position = new Vector3(targetTrackedPos.x, trackingContainer.position.y, targetTrackedPos.z);


            //This slow moves the head + controllers on the Y-axis so it doesn't jump when stepping up
            if(isGrounded)
                trackingContainer.position = Vector3.MoveTowards(trackingContainer.position, targetTrackedPos + Vector3.up * heightOffset, (Mathf.Abs(trackingContainer.position.y - targetTrackedPos.y) + 0.1f) * Time.deltaTime * heightSmoothSpeed);
            else
                trackingContainer.position = targetTrackedPos + Vector3.up * heightOffset;


            //This code will move the tracking objects to match the body collider position when moving
            var targetPos = transform.position - headCamera.transform.position; targetPos.y = 0;
            targetPosOffset = Vector3.MoveTowards(targetPosOffset, targetPos, body.linearVelocity.magnitude * Time.deltaTime);
            trackingContainer.position += targetPosOffset;


            //This helps prevent the hands from clipping
            var deltaHandPos = handRight.transform.position - startRightHandPos;
            if(pushRight.Count > 0)
                handRight.transform.position -= deltaHandPos;
            else 
               PreventHandClipping(handRight, startRightHandPos);
            
            
            deltaHandPos = handLeft.transform.position - startLeftHandPos;
            if(pushLeft.Count > 0)
                handLeft.transform.position -= deltaHandPos;
            else 
                PreventHandClipping(handLeft, startLeftHandPos);
            

            lastUpdatePosition = transform.position;
        }



        void PreventHandClipping(Hand hand, Vector3 startPosition) {
            var deltaHandPos = hand.transform.position - startPosition;
            if (deltaHandPos.magnitude < Physics.defaultContactOffset)
                return;

            var center = hand.handEncapsulationBox.transform.TransformPoint(hand.handEncapsulationBox.center) - deltaHandPos;
            var halfExtents = hand.handEncapsulationBox.transform.TransformVector(hand.handEncapsulationBox.size) / 2f;
            var hits = Physics.BoxCastAll(center, halfExtents, deltaHandPos, hand.handEncapsulationBox.transform.rotation, deltaHandPos.magnitude*1.5f, handPlayerMask);
            for(int i = 0; i < hits.Length; i++) {
                var hit = hits[i];
                if(hit.collider.isTrigger)
                    continue;

                if(hand.holdingObj == null || hit.collider.attachedRigidbody == null || (hit.collider.attachedRigidbody != hand.holdingObj.body && !hand.holdingObj.jointedBodies.Contains(hit.collider.attachedRigidbody))) {
                    var deltaHitPos = hit.point - hand.transform.position;
                    hand.transform.position = Vector3.MoveTowards(hand.transform.position, startPosition, deltaHitPos.magnitude);
                    
                    break;
                }

            }
        }

        /// <summary>This function is responsible for keeping the body matching the head position when moving the head within the tracking space</summary>
        protected virtual void SyncBodyHead() {
            for(int i = 0; i < bodySyncMaxIterations; i++) {
                float minDistanceOffset = Physics.defaultContactOffset*1.5f;
                Vector3 currentPosition = transform.position;
                Vector3 flatHeadPos = headCamera.transform.position;
                Vector3 flatBodyPos = currentPosition;
                flatHeadPos.y = flatBodyPos.y = 0;

                //If the body is too far away from the head, move the body closer to the head
                if(Vector3.Distance(flatHeadPos, flatBodyPos) >  minDistanceOffset) {
                    Vector3 direction = Vector3.ClampMagnitude(flatHeadPos - flatBodyPos, bodyCapsule.radius/2f);

                    //Check if the body is going to collide with something
                    GetCapsuleEndPoints(bodyCollider, out var capsuleTop, out var capsuleBottom, out var scaledRadius);

                    capsuleBottom.y += maxStepHeight;
                    if(capsuleBottom.y > capsuleTop.y)
                        capsuleTop.y = capsuleBottom.y;

                    int overlapCount = Physics.OverlapCapsuleNonAlloc(
                        capsuleBottom + direction,
                        capsuleTop + direction,
                        scaledRadius,
                        colliderNonAlloc,
                        handPlayerMask,
                        QueryTriggerInteraction.Ignore
                    );

                    int attempts = 0;
                    //If the body is going to collide with something, move the body to the closest point that doesn't collide using Physics.ComputePenetration
                    if(overlapCount > 0) {
                        while(overlapCount > 0 && attempts < bodySyncMaxIterations) {
                            Vector3 averageDepentration = Vector3.zero;
                            for(int j = 0; j < overlapCount; j++) {
                                Collider otherCollider = colliderNonAlloc[j];
                                var preColliderHeight = bodyCapsule.height;

                                if((handLeft.IsHolding() && handLeft.holdingObj.grabColliders.Contains(otherCollider)) ||
                                    (handRight.IsHolding() && handRight.holdingObj.grabColliders.Contains(otherCollider)))
                                    continue;
                                //Temporarily increase the height of the capsule to prevent the depenetration from using the Y-axis
                                //This should prevent bugs in most cases, but it might cause some issues with some very specific edge cases (E.G a giant inverted sphere shapped mesh collider)
                                bodyCapsule.height = preColliderHeight * 1000f;

                                if(Physics.ComputePenetration(otherCollider, otherCollider.transform.position, otherCollider.transform.rotation, bodyCapsule, direction + currentPosition, transform.rotation, out var closestDepentrationDirection, out var closestDepenetrationDistance)) {
                                    //Adding the 1.05f multiplier to the depenetration direction will make the body move a bit further away from the collider helping to prevent the body from getting stuck
                                    averageDepentration += (closestDepentrationDirection * closestDepenetrationDistance) * 1.05f; averageDepentration.y = 0;
                                }

                                bodyCapsule.height = preColliderHeight;
                            }

                            overlapCount = Physics.OverlapCapsuleNonAlloc(
                                capsuleBottom + direction - averageDepentration,
                                capsuleTop + direction - averageDepentration,
                                scaledRadius,
                                colliderNonAlloc,
                                handPlayerMask,
                                QueryTriggerInteraction.Ignore
                            );

                            if(overlapCount == 0) {
                                currentPosition += direction - averageDepentration;
                                transform.position += direction - averageDepentration;
                                targetTrackedPos -= direction - averageDepentration;
                                body.position = transform.position;
                            }
                            attempts++;
                        }
                    }
                    //If the body is not going to collide with anything, move the body towards the target position
                    else {
                        transform.position += direction;
                        targetTrackedPos -= direction;
                        body.position = transform.position;
                    }
                }
            }

            void GetCapsuleEndPoints(CapsuleCollider collider, out Vector3 top, out Vector3 bottom, out float radius) {
                Transform transform = collider.transform;
                Vector3 capsuleCenter = transform.TransformPoint(collider.center);
                float actualHeight = collider.height * 0.5f - collider.radius;
                float scaledHeight = actualHeight * Vector3.Scale(transform.lossyScale, Vector3.up).magnitude;
                radius = collider.radius * Mathf.Max(transform.lossyScale.x, transform.lossyScale.y, transform.lossyScale.z);

                top = capsuleCenter + Vector3.up * scaledHeight;
                bottom = capsuleCenter - Vector3.up * scaledHeight;
            }
        }


        /// <summary>This function is responsible for keeping the body matching the head position when moving the head within the tracking space</summary>
        protected virtual void PreventHeadOverlap() {
            //By using moveTowards with a radius * 0.95f, we can prevent the spheres from ever clipping through objects
            //because it will always depenetrate to the correct direction from the last depenetrated position
            Vector3 currentHeadPosition = headCamera.transform.position;
            Vector3 cameraHeadPosition = Vector3.MoveTowards(lastHeadPos, currentHeadPosition, headRadius*0.95f);

            int overlapCount = Physics.OverlapSphereNonAlloc(
                cameraHeadPosition,
                headRadius,
                colliderNonAlloc,
                handPlayerMask,
                QueryTriggerInteraction.Ignore
            );

            //Prevents held objects from being considered for depenetration
            if(handLeft.IsHolding() || handRight.IsHolding()) {
                for(int j = overlapCount - 1; j >= 0; j--) {
                    Collider otherCollider = colliderNonAlloc[j];

                    if(handLeft.IsHolding() && handLeft.holdingObj.grabColliders.Contains(otherCollider)
                        || handRight.IsHolding() && handRight.holdingObj.grabColliders.Contains(otherCollider))
                            overlapCount--;
                }
            }

            //If the head is overlapping with something, move the head/body away from the overlapped objects
            if(overlapCount > 0) {
                int attempts = 0;
                while(overlapCount > 0 && attempts < headCollisionMaxIterations) {
                    Vector3 averageDepentration = Vector3.zero;
                    for(int j = 0; j < overlapCount; j++) {
                        Collider otherCollider = colliderNonAlloc[j];
                        if(Physics.ComputePenetration(otherCollider, otherCollider.transform.position, otherCollider.transform.rotation, headPhysicsFollower.headCollider, cameraHeadPosition, transform.rotation, out var closestDepentrationDirection, out var closestDepenetrationDistance)) {
                            averageDepentration += (closestDepentrationDirection * closestDepenetrationDistance);
                        }
                    }

                    //Offsets the head on the Y-axis, but push the body away on the X/Z-axis
                    headHeightOffset -= averageDepentration.y;
                    targetTrackedPos -= Vector3.up * averageDepentration.y;
                    cameraHeadPosition.y -= averageDepentration.y;
                    currentHeadPosition -= averageDepentration;
                    averageDepentration.y = 0f;

                    transform.position -= averageDepentration;
                    cameraHeadPosition -= averageDepentration;
                    body.position = transform.position; 
                    
                    cameraHeadPosition = Vector3.MoveTowards(cameraHeadPosition, currentHeadPosition, headRadius*0.95f);

                    overlapCount = Physics.OverlapSphereNonAlloc(
                        cameraHeadPosition,
                        headRadius,
                        colliderNonAlloc,
                        handPlayerMask,
                        QueryTriggerInteraction.Ignore
                    );


                    attempts++;
                }
            }
            //If there is height debt to pay, pay it
            else if(headHeightOffset != 0) {
                Vector3 castDirection = (headHeightOffset > 0) ? -Vector3.up : Vector3.up;
                float castDistance = Mathf.Abs(headHeightOffset);
                Vector3 startPosition = cameraHeadPosition + Vector3.up * Mathf.Sign(headHeightOffset) * 0.001f;

                //Check if there is space to move the head to pay of the height debt
                //Using a 0.001f buffer to prevent the sphere cast from ignoring the collider if perfectly flush
                if(Physics.SphereCast(startPosition, headRadius, castDirection, out var hit, castDistance, handPlayerMask, QueryTriggerInteraction.Ignore) && hit.distance > 0.001f) {
                    var adjustment = headHeightOffset - Mathf.MoveTowards(headHeightOffset, 0, hit.distance - 0.001f);
                    headHeightOffset -= adjustment;
                    cameraHeadPosition.y -= adjustment;
                    targetTrackedPos -= Vector3.up * adjustment;
                }
                //If there is no space to move the head to pay of the height debt, just move the body
                else {
                    targetTrackedPos -= Vector3.up * headHeightOffset;
                    cameraHeadPosition.y -= headHeightOffset;
                    headHeightOffset = 0;
                }
            }

            if(trackingStarted)
                lastHeadPos = cameraHeadPosition;
        }
        
        protected virtual bool CanInputMove() {
            return (allowClimbingMovement || !IsClimbing());
        }




        protected virtual void UpdateTurn(float deltaTime) {

            //Snap turning
            if(rotationType == RotationType.snap) {
                if(Mathf.Abs(turningAxis) > turnDeadzone && axisReset) {
                    var angle = turningAxis > turnDeadzone ? snapTurnAngle : -snapTurnAngle;

                    var targetPos = transform.position - headCamera.transform.position; targetPos.y = 0;

                    trackingContainer.position += targetPos;
                    if(headPhysicsFollower != null) {
                        headPhysicsFollower.transform.position += targetPos;
                        headPhysicsFollower.body.position = headPhysicsFollower.transform.position;
                    }

                    lastUpdatePosition = new Vector3(transform.position.x, lastUpdatePosition.y, transform.position.z);
                    var handRightStartPos = handRight.transform.position;
                    var handLeftStartPos = handLeft.transform.position;

                    trackingContainer.RotateAround(transform.position, Vector3.up, angle);
                    targetPosOffset = Vector3.zero;
                    targetTrackedPos = new Vector3(trackingContainer.position.x, targetTrackedPos.y, trackingContainer.position.z);

                    if(handRight.holdingObj != null && !handRight.IsGrabbing()) {
                        handRight.body.position = handRight.handGrabPoint.position;
                        handRight.body.rotation = handRight.handGrabPoint.rotation;
                    }
                    else {
                        handRight.body.position = handRight.transform.position;
                        handRight.body.rotation = handRight.transform.rotation;

                    }

                    handRight.handFollow.AverageSetMoveTo();
                    handLeft.handFollow.AverageSetMoveTo();

                    PreventHandClipping(handRight, handRightStartPos);
                    PreventHandClipping(handLeft, handLeftStartPos);
                    Physics.SyncTransforms();

                    OnSnapTurn?.Invoke(this);
                    axisReset = false;
                }
            }
            else if(Mathf.Abs(turningAxis) > turnDeadzone) {
                
                lastUpdatePosition = new Vector3(transform.position.x, lastUpdatePosition.y, transform.position.z);
                trackingContainer.RotateAround(transform.position, Vector3.up, smoothTurnSpeed * (Mathf.MoveTowards(turningAxis, 0, turnDeadzone)) * deltaTime);

                targetPosOffset = Vector3.zero;
                targetTrackedPos = new Vector3(trackingContainer.position.x, targetTrackedPos.y, trackingContainer.position.z);

                handRight.handFollow.AverageSetMoveTo();
                handLeft.handFollow.AverageSetMoveTo();
                Physics.SyncTransforms();

                OnSmoothTurn?.Invoke(this);
                axisReset = false;
            }

            if(Mathf.Abs(turningAxis) < turnResetzone)
                axisReset = true;
        }

        RaycastHit[] hitsNonAlloc = new RaycastHit[128];
        protected virtual void Ground() {
            isGrounded = false;
            lastGroundHit = new RaycastHit();

            if(!tempDisableGrounding && useGrounding && !IsClimbing() && !(pushAxis.y > 0)) {
                highestPoint = -1;

                float stepAngle;
                float dist;
                float scale = transform.lossyScale.x > transform.lossyScale.z ? transform.lossyScale.x : transform.lossyScale.z;

                var maxStepHeight = this.maxStepHeight;
                maxStepHeight *= climbAxis.y > 0 ? climbUpStepHeightMultiplier : 1;
                maxStepHeight *= pushAxis.y > 0 ? pushUpStepHeightMultiplier : 1;
                maxStepHeight *= scale;

                var point1 = scale * bodyCapsule.center + transform.position + scale * bodyCapsule.height / 2f * -Vector3.up + (maxStepHeight + scale * bodyCapsule.radius * 2) * Vector3.up;
                var point2 = scale * bodyCapsule.center + transform.position + (scale * bodyCapsule.height / 2f + groundingPenetrationOffset) * -Vector3.up;

                var radius = scale * bodyCapsule.radius * 2 + Physics.defaultContactOffset * 2;
                int hitCount = Physics.SphereCastNonAlloc(point1, radius, -Vector3.up, hitsNonAlloc, Vector3.Distance(point1, point2) + scale * bodyCapsule.radius * 4, groundLayerMask, QueryTriggerInteraction.Ignore);

                // Initial Grounding Check includes the body and the area right around it
                CheckGroundHits();

                if(!isGrounded && hitCount > 0) {
                    // If it's hitting something but not valid ground, check the smaller area just below the feet.
                    // This specifically fixes a bug where a mesh collider won't return a valid grounding hit when standing against a vertical step just above the max step height
                    // This is because SphereCast will only return the first highest valid hit per collider
                    radius = scale * bodyCapsule.radius;
                    hitCount = Physics.SphereCastNonAlloc(point1, radius, -Vector3.up, hitsNonAlloc, Vector3.Distance(point1, point2) + scale * bodyCapsule.radius * 4, groundLayerMask, QueryTriggerInteraction.Ignore);

                    CheckGroundHits();
                }

                void CheckGroundHits() {
                    for(int i = 0; i < hitCount; i++) {
                        var hit = hitsNonAlloc[i];

                        if(hit.collider != bodyCapsule) {
                            if(hit.point.y >= point2.y && hit.point.y <= point2.y + maxStepHeight + groundingPenetrationOffset) {
                                stepAngle = Vector3.Angle(hit.normal, Vector3.up);
                                dist = hit.point.y - transform.position.y;

                                if(stepAngle < maxStepAngle && dist > highestPoint) {
                                    isGrounded = true;
                                    highestPoint = dist;
                                    lastGroundHit = hit;
                                }
                            }
                        }
                    }
                }

                if(isGrounded) {
                    // Zero out vertical velocity since we're grounded.
                    body.linearVelocity = new Vector3(body.linearVelocity.x, 0, body.linearVelocity.z);

                    // If smooth stepping is enabled, interpolate the Y-position.
                    if(useSmoothStep) {
                        float currentY = body.position.y;
                        float targetY = lastGroundHit.point.y;
                        float newY = Mathf.Lerp(currentY, targetY, Time.fixedDeltaTime * stepSmoothSpeed);
                        body.position = new Vector3(body.position.x, newY, body.position.z);
                    }
                    else {
                        // Otherwise, instantly snap to the step height.
                        body.position = new Vector3(body.position.x, lastGroundHit.point.y, body.position.z);
                    }
                    transform.position = body.position;
                }

                body.useGravity = !isGrounded;
            }
        }

        public bool IsGrounded() {
            return isGrounded;
        }

        public void ToggleFlying() {
            useGrounding = !useGrounding;
            body.useGravity = useGrounding;
        }

        protected virtual void UpdatePlayerHeight() {
            if(crouching != lastCrouching) {
                if(lastCrouching)
                    heightOffset += lastCrouchingHeight;
                if(!lastCrouching)
                    heightOffset -= crouchHeight;

                lastCrouching = crouching;
                lastCrouchingHeight = crouchHeight;
            }

            if(autoAdjustColliderHeight) {
                playerHeight = Mathf.Clamp(headCamera.transform.position.y - transform.position.y, minMaxHeight.x, minMaxHeight.y);
                bodyCapsule.height = playerHeight;
                var centerHeight = playerHeight / 2f > bodyCapsule.radius ? playerHeight / 2f : bodyCapsule.radius;
                bodyCapsule.center = new Vector3(0, centerHeight, 0);
            }
        }


        protected void UpdatePlatform(){
            if (isGrounded && lastGroundHit.transform != null && (platformingLayerMask == (platformingLayerMask | (1 << lastGroundHit.collider.gameObject.layer)))) {
                if (!lastGroundHit.transform.Equals(lastPlatformingHit.transform)) {
                    lastPlatformingHit = lastGroundHit;
                    lastPlatformPosition = lastPlatformingHit.transform.position;
                    lastPlatformRotation = lastPlatformingHit.transform.rotation;
                }
                else if(lastGroundHit.transform.Equals(lastPlatformingHit.transform))
                {
                    if (lastPlatformingHit.transform.position != lastPlatformPosition || lastPlatformingHit.transform.rotation.eulerAngles != lastPlatformRotation.eulerAngles) {
                        lastPlatformingHit = lastGroundHit;
                        Transform ruler = AutoHandExtensions.transformRuler;
                        ruler.position = transform.position;
                        ruler.rotation = transform.rotation;
                        ruler.position += lastPlatformingHit.transform.position - lastPlatformPosition;

                        var deltaPos = ruler.transform.position - transform.position;
                        var deltaRot = (lastPlatformingHit.transform.rotation * Quaternion.Inverse(lastPlatformRotation));

                        ruler.transform.RotateAround(lastPlatformingHit.transform.position, Vector3.up, deltaRot.eulerAngles.y);
                        trackingContainer.RotateAround(headCamera.transform.position, Vector3.up, deltaRot.eulerAngles.y);

                        transform.position += deltaPos;
                        body.position = transform.position;

                        trackingContainer.position += deltaPos;

                        lastUpdatePosition = transform.position;

                        targetPosOffset = Vector3.zero;

                        targetTrackedPos = new Vector3(trackingContainer.position.x, targetTrackedPos.y + deltaPos.y, trackingContainer.position.z);
                        lastPlatformPosition = lastPlatformingHit.transform.position;
                        lastPlatformRotation = lastPlatformingHit.transform.rotation;
                    }
                }
            }
        }


        public void Jump(float jumpPower = 1) {
            if(isGrounded) {
                DisableGrounding(0.1f);
                body.useGravity = true;
                body.AddForce(Vector3.up * jumpPower, ForceMode.VelocityChange);
            }
        }


        public void DisableGrounding(float seconds) {
            if(disableGroundingRoutine != null)
                StopCoroutine(disableGroundingRoutine);
            disableGroundingRoutine = StartCoroutine(DisableGroundingSecondsRoutine(seconds));
        }

        Coroutine disableGroundingRoutine;
        IEnumerator DisableGroundingSecondsRoutine(float seconds) {
            tempDisableGrounding = true;
            isGrounded = false;
            yield return new WaitForSeconds(seconds);
            tempDisableGrounding = false;

        }

        /// <summary>Legacy function, use body.addfoce instead</summary>
        public void AddVelocity(Vector3 force, ForceMode mode = ForceMode.Acceleration) {
            body.AddForce(force, mode);
        }

        protected virtual void StartPush(Hand hand, GameObject other) {
            if(!allowBodyPushing || IsClimbing())
                return;

            if(other.CanGetComponent(out Pushable push) && push.enabled) {
                if(hand.left) {
                    if(!pushLeft.ContainsKey(push)) {
                        pushLeft.Add(push, hand);
                        pushLeftCount.Add(push, 1);
                    }
                    else {
                        pushLeftCount[push]++;
                    }
                }

                if(!hand.left && !pushRight.ContainsKey(push)) {
                    if(!pushRight.ContainsKey(push)) {
                        pushRight.Add(push, hand);
                        pushRightCount.Add(push, 1);
                    }
                    else {
                        pushRightCount[push]++;
                    }
                }
            }
        }

        protected virtual void StopPush(Hand hand, GameObject other) {
            if(!allowBodyPushing)
                return;

            if(other.CanGetComponent(out Pushable push)) {
                if(hand.left && pushLeft.ContainsKey(push)) {
                    var count = --pushLeftCount[push];
                    if(count == 0) {
                        pushLeft.Remove(push);
                        pushLeftCount.Remove(push);
                    }
                }
                if(!hand.left && pushRight.ContainsKey(push)) {
                    var count = --pushRightCount[push];
                    if(count == 0) {
                        pushRight.Remove(push);
                        pushRightCount.Remove(push);
                    }
                }
            }
        }

        protected virtual void StartGrabPush(Hand hand, Grabbable grab) {
            if(!allowBodyPushing)
                return;

            if(grab.CanGetComponent(out Pushable push) && push.enabled) {
                if(hand.left && !pushLeft.ContainsKey(push)) {
                    pushLeft.Add(push, hand);
                    pushLeftCount.Add(push, 1);
                }

                if(!hand.left && !pushRight.ContainsKey(push)) {
                    pushRight.Add(push, hand);
                    pushRightCount.Add(push, 1);
                }
            }
        }

        protected virtual void EndGrabPush(Hand hand, Grabbable grab) {
            if(grab != null && grab.CanGetComponent(out Pushable push)) {
                if(hand.left && pushLeft.ContainsKey(push)) {
                    pushLeft.Remove(push);
                    pushLeftCount.Remove(push);
                }
                else if(!hand.left && pushRight.ContainsKey(push)) {
                    pushRight.Remove(push);
                    pushRightCount.Remove(push);
                }

            }
        }

        protected virtual void ApplyPushingForce() {
            pushAxis = Vector3.zero;
            if(allowBodyPushing) {

                foreach(var push in pushRight) {
                    if(push.Key.enabled && !push.Value.IsGrabbing()) {
                        Vector3 offset = Vector3.zero;
                        var distance = Vector3.Distance(push.Value.body.position, push.Value.moveTo.position);
                        if(distance > 0)
                            offset = Vector3.Scale((push.Value.body.position - push.Value.moveTo.position), push.Key.strengthScale);

                        offset = Vector3.Scale(offset, pushingStrength);
                        pushAxis += offset / 2f;
                    }
                }

                foreach(var push in pushLeft) {
                    if(push.Key.enabled && !push.Value.IsGrabbing()) {
                        Vector3 offset = Vector3.zero;
                        var distance = Vector3.Distance(push.Value.body.position, push.Value.moveTo.position);
                        if(distance > 0)
                            offset = Vector3.Scale((push.Value.body.position - push.Value.moveTo.position), push.Key.strengthScale);

                        offset = Vector3.Scale(offset, pushingStrength);
                        pushAxis += offset / 2f;
                    }
                }
            }
        }

        public bool IsPushing() {
            foreach(var push in pushRight)
                if(push.Key.enabled)
                    return true;
            foreach(var push in pushLeft)
                if(push.Key.enabled)
                    return true;

            return false;
        }
        public bool IsPushingUp() {
            return pushAxis.y > 0;
        }




        protected virtual void StartClimb(Hand hand, Grabbable grab) {
            if(!allowClimbing)
                return;

            if(!climbing.ContainsKey(hand) && grab != null && grab.CanGetComponent(out Climbable climbbable) && climbbable.enabled) {
                if(climbing.Count == 0) {
                    pushRight.Clear();
                    pushRightCount.Clear();
                    pushLeft.Clear();
                    pushLeftCount.Clear();
                }

                if(climbing.Count == 0)
                    body.linearVelocity /= 4f;

                climbing.Add(hand, climbbable);
            }
        }

        protected virtual void EndClimb(Hand hand, Grabbable grab) {
            if(!allowClimbing)
                return;

            if(climbing.ContainsKey(hand))
                climbing.Remove(hand);

            foreach(var climb in climbing)
                climb.Key.ResetGrabOffset();
        }

        protected virtual void ApplyClimbingForce() {
            climbAxis = Vector3.zero;
            if(allowClimbing && climbing.Count > 0) {
                foreach(var hand in climbing) {
                    if(hand.Value.enabled) {
                        var offset = Vector3.Scale(hand.Key.body.position - hand.Key.moveTo.position, hand.Value.axis);
                        offset = Vector3.Scale(offset, climbingStrength);
                        climbAxis += offset / climbing.Count;
                    }
                }
            }
        }

        public bool IsClimbing() {
            foreach(var climb in climbing)
                if(climb.Value.enabled)
                    return true;
            return false;
        }



        public virtual void SetPosition(Vector3 position) {
            SetPosition(position, headCamera.transform.rotation);
        }

        public virtual void SetPosition(Vector3 position, Quaternion rotation) {
            // Calculate and apply the positional delta.
            Vector3 deltaPos = position - transform.position;
            transform.position += deltaPos;

            // Adjust the tracking container's position.
            var targetPos = transform.position - headCamera.transform.position;
            targetPos.y = deltaPos.y;
            trackingContainer.position += targetPos;

            // Update tracking positions.
            lastUpdatePosition = transform.position;
            targetTrackedPos = new Vector3(
                trackingContainer.position.x,
                targetTrackedPos.y + deltaPos.y,
                trackingContainer.position.z
            );

            targetPosOffset = Vector3.zero;
            body.position = transform.position;

            // Update head physics follower if it exists.
            if(headPhysicsFollower != null) {
                headPhysicsFollower.transform.position += targetPos;
                headPhysicsFollower.body.position = headPhysicsFollower.transform.position;
            }

            lastHeadPos = headCamera.transform.position;

            SafeMoveHandToPosition(handRight, transform, handRight.transform.position);
            SafeMoveHandToPosition(handLeft, transform, handLeft.transform.position);

            AddRotation(rotation * Quaternion.Inverse(headCamera.transform.rotation));

            OnTeleported?.Invoke(this);
        }





        public virtual void SetRotation(Quaternion rotation) {
            var targetPos = transform.position - headCamera.transform.position; targetPos.y = 0;

            trackingContainer.position += targetPos;
            if(headPhysicsFollower != null) {
                headPhysicsFollower.transform.position += targetPos;
                headPhysicsFollower.body.position = headPhysicsFollower.transform.position;
            }
            lastUpdatePosition = transform.position;

            var deltaRot = rotation * Quaternion.Inverse(headCamera.transform.rotation);
            trackingContainer.RotateAround(headCamera.transform.position, Vector3.up, deltaRot.eulerAngles.y);

            targetPosOffset = Vector3.zero;
            targetTrackedPos = new Vector3(trackingContainer.position.x, targetTrackedPos.y, trackingContainer.position.z);

            SafeMoveHandToPosition(handRight, transform, handRight.transform.position);
            SafeMoveHandToPosition(handLeft, transform, handLeft.transform.position);

            if(deltaRot.eulerAngles.magnitude > 10f)
                OnTeleported?.Invoke(this);


        }

        public virtual void AddRotation(Quaternion addRotation) {
            var targetPos = transform.position - headCamera.transform.position; targetPos.y = 0;

            trackingContainer.position += targetPos;
            if(headPhysicsFollower != null) {
                headPhysicsFollower.transform.position += targetPos;
                headPhysicsFollower.body.position = headPhysicsFollower.transform.position;
            }
            lastUpdatePosition = transform.position;

            trackingContainer.RotateAround(headCamera.transform.position, Vector3.up, addRotation.eulerAngles.y);

            targetPosOffset = Vector3.zero;
            targetTrackedPos = new Vector3(trackingContainer.position.x, targetTrackedPos.y, trackingContainer.position.z);

            SafeMoveHandToPosition(handRight, transform, handRight.transform.position);
            SafeMoveHandToPosition(handLeft, transform, handLeft.transform.position);

            if(addRotation.eulerAngles.magnitude > 10f)
                OnTeleported?.Invoke(this);
        }



        protected void SafeMoveHandToPosition(Hand hand, Transform playerTransform, Vector3 desiredHandPosition) {
            var handBody = hand.body;
            Vector3 bodyXZCenter = new Vector3(
                playerTransform.position.x,
                handBody.position.y,
                playerTransform.position.z
            );

            handBody.position = bodyXZCenter;
            handBody.transform.position = bodyXZCenter;

            Vector3 offset = desiredHandPosition - bodyXZCenter;
            float distance = offset.magnitude;
            if(distance < 0.0001f)
                return;

            Vector3 direction = offset.normalized;

            if(handBody.SweepTest(direction, out var hit, distance))
                hand.handFollow.SetHandLocation(bodyXZCenter + direction * hit.distance);
            else
                hand.handFollow.SetHandLocation(desiredHandPosition);

        }

        public virtual void Recenter() {
            var targetPos = transform.position - headCamera.transform.position; targetPos.y = 0;

            trackingContainer.position += targetPos;
            if(headPhysicsFollower != null) {
                headPhysicsFollower.transform.position += targetPos;
                headPhysicsFollower.body.position = headPhysicsFollower.transform.position;
            }
            lastUpdatePosition = transform.position;

            targetPosOffset = Vector3.zero;
            targetTrackedPos = new Vector3(trackingContainer.position.x, targetTrackedPos.y, trackingContainer.position.z);
        }

        public bool IsHolding(Grabbable grab) {
            return handRight.GetHeld() == grab || handLeft.GetHeld() == grab;
        }

        protected virtual Vector3 AlterDirection(Vector3 moveAxis) {
            if(useGrounding)
                return Quaternion.AngleAxis(forwardFollow.eulerAngles.y, Vector3.up) * (new Vector3(moveAxis.x, moveAxis.y, moveAxis.z));
            else
                return forwardFollow.rotation * (new Vector3(moveAxis.x, moveAxis.y, moveAxis.z));
        }


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/AutoHandPlayer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/AutoHandPlayerForceArea.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bc9301e05ec9df54e938f861887b8b93
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Autohand {
    public class AutoHandPlayerForceArea : MonoBehaviour
    {
        public AutoHandPlayer player;
        public float force = 1;
        public ForceMode forceMode = ForceMode.Force;
        public LayerMask layers = ~0;
        Collider[] colliders = new Collider[30];

        private void FixedUpdate()
        {
            var direction = new Vector3 { [player.bodyCollider.direction] = 1 };
            var offset = player.bodyCollider.height / 2 - player.bodyCollider.radius;
            var localPoint0 = player.bodyCollider.center - direction * offset;
            var localPoint1 = player.bodyCollider.center + direction * offset;
            var point0 = transform.TransformPoint(localPoint0);
            var point1 = transform.TransformPoint(localPoint1); 
            var r = transform.TransformVector(player.bodyCollider.radius, player.bodyCollider.radius, player.bodyCollider.radius);
            var radius = Enumerable.Range(0, 3).Select(xyz => xyz == player.bodyCollider.direction ? 0 : r[xyz])
                .Select(Mathf.Abs).Max();

            var overlaps = Physics.OverlapCapsuleNonAlloc(point0, point1, radius, colliders, layers);
            for (int i = 0; i < overlaps; i++)
            {
                if (colliders[i].attachedRigidbody != null)
                {
                    if (colliders[i].attachedRigidbody != player.body && colliders[i].attachedRigidbody != player.handRight.body && colliders[i].attachedRigidbody != player.handLeft.body)
                    {
                        var adjustedForce = (colliders[i].transform.position - player.transform.position).normalized * force;
                        adjustedForce.y /= 10f;
                        colliders[i].attachedRigidbody.AddForce(adjustedForce, forceMode);
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/AutoHandPlayerForceArea.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/BodyPhysicsFollower.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 49e0f95e9f8843d4b8c39421649bc8eb
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BodyPhysicsFollower : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/BodyPhysicsFollower.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Climbable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1e1e358c1b681e8448d2f168014855c7
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;

namespace Autohand {
    [RequireComponent(typeof(Grabbable)), HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/auto-hand-player#climbing")]
    public class Climbable : MonoBehaviour{
        public Vector3 axis = Vector3.one;
        public Stabber stabber;

        private void Start() {
            if(stabber != null) {
                stabber.StartStabEvent += (hand, grab) => {
                    enabled = true;
                };
                stabber.EndStabEvent += (hand, grab) => {
                    enabled = false;
                };
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Climbable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/HeadCameraSmoothing.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 43f45130b60269b47b8e86db114a6478
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class HeadCameraSmoothing : MonoBehaviour
{
    public Vector3 lastPos;
    public Quaternion lastRot;



    public void LateUpdate() {


        lastPos = transform.position;
        lastRot = transform.rotation;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/HeadCameraSmoothing.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/HeadPhysicsFollower.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 62d72f32b05f0d64bae54ab684c65e3b
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    [RequireComponent(typeof(Rigidbody))]
    public class HeadPhysicsFollower : MonoBehaviour{

        [Header("References")]
        public Camera headCamera;
        public Transform trackingContainer;
        public Transform followBody;

        [Header("Follow Settings")]
        public float followStrength = 50f;
        [Tooltip("The maximum allowed distance from the body for the headCamera to still move")]
        public float maxBodyDistance = 1f;

        internal SphereCollider headCollider;
        Vector3 startHeadPos;
        bool started;
        float lastUpdateTime;

        Transform _moveTo = null;
        Transform moveTo {
            get {
                if(!gameObject.activeInHierarchy)
                    return null;
                if(_moveTo == null) {
                    _moveTo = new GameObject().transform;
                    _moveTo.transform.rotation = transform.rotation;
                    _moveTo.rotation = transform.rotation;
                    _moveTo.name = "HEAD FOLLOW POINT";
                    _moveTo.parent = AutoHandExtensions.transformParent;
                }

                return _moveTo;
            }
        }
        public Rigidbody body;
        CollisionTracker collisionTracker = null;


        internal void Init() {
            if(collisionTracker == null) {
                collisionTracker = gameObject.AddComponent<CollisionTracker>();
                collisionTracker.disableTriggersTracking = true;
            }
            body = GetComponent<Rigidbody>();
            body.useGravity = false;
            gameObject.layer = LayerMask.NameToLayer(AutoHandPlayer.HandPlayerLayer);
            
            transform.position = headCamera.transform.position;
            transform.rotation = headCamera.transform.rotation;
            headCollider = GetComponent<SphereCollider>();
            //headCollider.isTrigger = true;
            startHeadPos = headCamera.transform.position;
        }

        protected void FixedUpdate() {
            moveTo.position = headCamera.transform.position;

            if(startHeadPos.y != headCamera.transform.position.y && !started) {
                started = true;
                body.position = headCamera.transform.position;
            }

            if(!started)
                return;
            
            MoveTo();
        }

        public bool Started() {
            return started;
        }
        
        internal virtual void MoveTo() {
            Vector3 currentPosition = transform.position;
            Vector3 currentHeadPosition = headCamera.transform.position;
            moveTo.position = Vector3.MoveTowards(currentPosition, currentHeadPosition, maxBodyDistance);
            body.linearVelocity = (moveTo.position - currentPosition) * followStrength;
            lastUpdateTime = Time.realtimeSinceStartup;

            var deltaTime = (Time.realtimeSinceStartup - lastUpdateTime);
            transform.position = Vector3.MoveTowards(transform.position, moveTo.position, body.linearVelocity.magnitude * deltaTime);
            body.linearVelocity = Vector3.MoveTowards(body.linearVelocity, Vector3.zero, body.linearVelocity.magnitude * deltaTime);
            body.position = transform.position;
        }

        protected virtual void Update() {
            if(moveTo != null && !body.isKinematic) 
                MoveTo();

            lastUpdateTime = Time.realtimeSinceStartup;
        }


        public int CollisionCount() {
            return collisionTracker.collisionCount;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/HeadPhysicsFollower.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/IgnoreHandPlayerCollision.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a70859c512807c2408f79d08adb4d8c2
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class IgnoreHandPlayerCollision : MonoBehaviour {
        public List<Collider> colliders;

        void Start() {
            ActivateIgnoreCollision();
        }

        public void ActivateIgnoreCollision() {
            foreach(var col in colliders)
                AutoHandPlayer.Instance.IgnoreCollider(col, true);
        }
        public void DeactivateIgnoreCollision() {
            foreach(var col in colliders)
                AutoHandPlayer.Instance.IgnoreCollider(col, false);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/IgnoreHandPlayerCollision.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolatedTransform.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7bb8c5e6a9f6c504ba21222eea8af7ad
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using System.Collections;

namespace Autohand {
    [DefaultExecutionOrder(-50)]
    [RequireComponent(typeof(InterpolatedTransformUpdater))]
    public class InterpolatedTransform : MonoBehaviour {
        private TransformData[] m_lastTransforms;
        private int m_newTransformIndex;

        bool run = true;


        void OnEnable() {

            ForgetPreviousTransforms();
        }

        public void ForgetPreviousTransforms() {
            m_lastTransforms = new TransformData[2];
            TransformData t = new TransformData(
                                    transform.localPosition,
                                    transform.localRotation,
                                    transform.localScale);
            m_lastTransforms[0] = t;
            m_lastTransforms[1] = t;
            m_newTransformIndex = 0;
        }

        void FixedUpdate() {
            if(run) {
                TransformData newestTransform = m_lastTransforms[m_newTransformIndex];
                transform.localPosition = newestTransform.position;
                transform.localRotation = newestTransform.rotation;
                transform.localScale = newestTransform.scale;
            }
        }

        public void LateFixedUpdate() {
            m_newTransformIndex = OldTransformIndex();
            m_lastTransforms[m_newTransformIndex] = new TransformData(
                                                        transform.localPosition,
                                                        transform.localRotation,
                                                        transform.localScale);
        }

        void Update() {
            TransformData newestTransform = m_lastTransforms[m_newTransformIndex];
            TransformData olderTransform = m_lastTransforms[OldTransformIndex()];

            if(run) {
                transform.localPosition = Vector3.Lerp(
                                            olderTransform.position,
                                            newestTransform.position,
                                            InterpolationController.InterpolationFactor);
                transform.localRotation = Quaternion.Slerp(
                                            olderTransform.rotation,
                                            newestTransform.rotation,
                                            InterpolationController.InterpolationFactor);
                transform.localScale = Vector3.Lerp(
                                            olderTransform.scale,
                                            newestTransform.scale,
                                            InterpolationController.InterpolationFactor);
            }
        }

        public void DisableForSeconds(float time) {
            if(disableForTime != null) {
                StopCoroutine(disableForTime);
                disableForTime = null;
            }
            if(gameObject.activeInHierarchy)
                disableForTime = StartCoroutine(Disable(time));
        }

        Coroutine disableForTime;
        IEnumerator Disable(float time) {
            run = false;
            yield return new WaitForSeconds(time);
            run = true;
        }

        private int OldTransformIndex() {
            return (m_newTransformIndex == 0 ? 1 : 0);
        }

        private struct TransformData {
            public Vector3 position;
            public Quaternion rotation;
            public Vector3 scale;

            public TransformData(Vector3 position, Quaternion rotation, Vector3 scale) {
                this.position = position;
                this.rotation = rotation;
                this.scale = scale;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolatedTransform.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolatedTransformUpdater.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 097d5c968a806bf43979b2a0b971ecf3
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using System.Collections;

namespace Autohand {
    [DefaultExecutionOrder(100)]
    public class InterpolatedTransformUpdater : MonoBehaviour {

        private InterpolatedTransform _interpolatedTransform;
        private InterpolatedTransform interpolatedTransform {
            get {
                if(_interpolatedTransform == null)
                    _interpolatedTransform = GetComponent<InterpolatedTransform>();

                return _interpolatedTransform;
            }
        }

        void FixedUpdate() {
            interpolatedTransform?.LateFixedUpdate();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolatedTransformUpdater.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolationController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 449b545543ad6594d8d1de432caf00e0
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using System.Collections;

namespace Autohand {
    [DefaultExecutionOrder(-100)]
    public class InterpolationController : MonoBehaviour {
        private float[] m_lastFixedUpdateTimes;
        private int m_newTimeIndex;

        private static float m_interpolationFactor;
        public static float InterpolationFactor {
            get { return m_interpolationFactor; }
        }

        public static InterpolationController _Instance;
        public static InterpolationController Instance {
            get {
                if(_Instance == null && !AutoHandExtensions.CanFindObjectOfType<InterpolationController>()) {
                    _Instance = new GameObject() { name = "InterpolationTracker" }.AddComponent<InterpolationController>();
                    _Instance.transform.parent = AutoHandExtensions.transformParent;
                }

                return _Instance;
            }
        }

        public void Start() {
            m_lastFixedUpdateTimes = new float[2];
            m_newTimeIndex = 0;
        }

        public void FixedUpdate() {
            m_newTimeIndex = OldTimeIndex();
            m_lastFixedUpdateTimes[m_newTimeIndex] = Time.fixedTime;
        }

        public void Update() {
            float newerTime = m_lastFixedUpdateTimes[m_newTimeIndex];
            float olderTime = m_lastFixedUpdateTimes[OldTimeIndex()];

            if(newerTime != olderTime) {
                m_interpolationFactor = (Time.time - newerTime) / (newerTime - olderTime);
            }
            else {
                m_interpolationFactor = 1;
            }
        }

        private int OldTimeIndex() {
            return (m_newTimeIndex == 0 ? 1 : 0);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolationController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/PlayerPlatform.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7877ec4db1c9f2d4c9cd30c6e9ebbf77
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
namespace Autohand{
    public class PlayerPlatform : MonoBehaviour{
        
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/PlayerPlatform.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Pushable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8aaeb61b4f025df4aa1d1be1032bedc7
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/auto-hand-player#pushing")]
    public class Pushable : MonoBehaviour {
        public Vector3 strengthScale = Vector3.one;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Pushable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Teleporter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 02e7dadae3689a64bb9a24e46177ce9d
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
// Include the demo namespace to access TeleportPoint.
using Autohand.Demo;

namespace Autohand {
    [DefaultExecutionOrder(10000)]
    public class Teleporter : MonoBehaviour {
        [Header("Teleport")]
        public GameObject teleportObject;
        public Transform[] additionalTeleports;

        [Header("Aim Settings")]
        public bool onlyUseTeleportPoints;
        public bool preventCapsuleOverlap = true;
        public Transform aimer;
        public float aimerSmoothingSpeed = 5f;
        public LayerMask layer;
        public float maxSurfaceAngle = 45f;
        [Min(0)]
        public float distanceMultiplyer = 1f;
        [Min(0)]
        public float curveStrength = 1f;

        [Header("Line Settings")]
        public LineRenderer line;
        public int lineSegments = 50;
        public Gradient canTeleportColor;
        public Gradient cantTeleportColor;

        [Tooltip("Shown at the aim-hit point for non-TeleportPoint surfaces")]
        public GameObject indicator;

        [Header("Unity Events")]
        public UnityEvent OnStartTeleport;
        public UnityEvent OnStopTeleport;
        public UnityEvent OnTeleport;

        // ---------------- Internal state ----------------
        private Vector3[] lineArr;
        private bool aiming;
        private bool hitting;   // True if we found a valid teleport target this frame
        private RaycastHit aimHit;
        private AutoHandPlayer playerBody;
        private RaycastHit[] hitNonAlloc;
        private TeleportPoint currentTeleportPoint;

        private Vector3 currentTeleportSmoothForward;
        private Vector3 currentTeleportForward;
        private Vector3 currentTeleportPosition;

        private TeleportPoint[] teleportPoints;
        private const float arcTimeDivisor = 60f;

        private void Awake() {
            line.enabled = false;
            hitNonAlloc = new RaycastHit[10];
        }

        private void Start() {
            playerBody = AutoHandExtensions.CanFindObjectOfType<AutoHandPlayer>();

            // If the "teleportObject" is actually the player's root, null it to avoid double-moving
            if(playerBody != null && playerBody.transform.gameObject == teleportObject) {
                teleportObject = null;
            }

            lineArr = new Vector3[lineSegments];

            // Grab all TeleportPoints in scene, disable them initially
            teleportPoints = AutoHandExtensions.CanFindObjectsOfType<TeleportPoint>();
            ToggleTeleportPoints(false);
        }

        void ToggleTeleportPoints(bool enabled) {
            if(teleportPoints == null)
                return;

            foreach(var tp in teleportPoints) {
                // If TeleportPoint has "alwaysShow" = true, only disable if enabling == false
                if(!tp.alwaysShow || enabled) {
                    tp.gameObject.SetActive(enabled);
                }
            }
        }

        private void LateUpdate() {
            SmoothTargetValues();

            if(aiming) {
                CalculateTeleportPoint();
            }
            else {
                // Turn off line if not aiming
                line.positionCount = 0;
            }

            DrawIndicator();
        }

        void SmoothTargetValues() {
            currentTeleportForward = aimer.forward;
            currentTeleportPosition = aimer.position;
            currentTeleportSmoothForward = Vector3.Lerp(
                currentTeleportSmoothForward,
                currentTeleportForward,
                Time.deltaTime * aimerSmoothingSpeed
            );
        }

        /// <summary>
        /// Core arc logic + collisions checking for a valid teleport point.
        /// </summary>
        void CalculateTeleportPoint() {
            hitting = false;
            line.colorGradient = cantTeleportColor;



            var lineList = new List<Vector3>();
            TeleportPoint foundTP = null;
            bool foundTeleport = false;

            for(int i = 0; i < lineSegments; i++) {
                float time = i / arcTimeDivisor;

                // Parabolic arc
                lineArr[i] = currentTeleportPosition
                    + (currentTeleportSmoothForward * time * distanceMultiplyer * 15f)
                    + Vector3.up * (curveStrength * (time - Mathf.Pow(9.8f * 0.5f * time, 2)));

                lineList.Add(lineArr[i]);

                // Skip first segment, no line to cast
                if(i == 0)
                    continue;

                Vector3 segmentStart = lineArr[i - 1];
                Vector3 segmentDir = lineArr[i] - segmentStart;
                float segmentDist = segmentDir.magnitude;

                int hitCount = Physics.RaycastNonAlloc(
                    segmentStart,
                    segmentDir.normalized,
                    hitNonAlloc,
                    segmentDist,
                    layer,
                    QueryTriggerInteraction.Collide
                );

                if(hitCount > 0) {
                    bool teleporterHit = false;
                    bool solidHitFound = false;
                    RaycastHit bestSolidHit = default;

                    // Examine each hit in the segment
                    for(int h = 0; h < hitCount; h++) {
                        var tempHit = hitNonAlloc[h];

                        // If it's a TeleportPoint (trigger or not)
                        if(tempHit.collider.TryGetComponent<TeleportPoint>(out TeleportPoint tp)) {
                            foundTP = tp;
                            aimHit = tempHit;
                            teleporterHit = true;
                            // We choose the earliest TeleportPoint in the path, so break
                            break;
                        }
                        else if(!tempHit.collider.isTrigger) {
                            // This is an actual physical collider.
                            float angle = Vector3.Angle(tempHit.normal, Vector3.up);
                            if(angle <= maxSurfaceAngle) {
                                // The first valid flat surface we see on this segment
                                if(!solidHitFound) {
                                    solidHitFound = true;
                                    bestSolidHit = tempHit;
                                }
                            }
                            else {
                                // It's too steep => discard and break out
                                break;
                            }
                        }
                    }

                    // If we got either a teleporter or a valid solid, do overlap checks if needed
                    bool capsuleOverlapInvalid = false;
                    if(playerBody != null && preventCapsuleOverlap) {
                        bool arcValid = (teleporterHit || solidHitFound);

                        // If the user only wants TeleportPoints, disallow solids
                        if(!teleporterHit && onlyUseTeleportPoints)
                            arcValid = false;

                        if(arcValid) {
                            // The actual point we aim to stand on:
                            Vector3 checkPoint;
                            if(teleporterHit) {
                                checkPoint = foundTP.teleportPoint.position;
                            }
                            else {
                                checkPoint = bestSolidHit.point;
                            }

                            CapsuleCollider playerCapsule = playerBody.bodyCollider;
                            Vector3 capsuleBottom = checkPoint + Vector3.up * (playerCapsule.radius) + Vector3.up * 0.15f;
                            Vector3 capsuleTop = checkPoint + Vector3.up * (playerCapsule.height - playerCapsule.radius);

                            Collider[] overlaps = Physics.OverlapCapsule(
                                capsuleBottom,
                                capsuleTop,
                                playerCapsule.radius,
                                playerBody.handPlayerMask,
                                QueryTriggerInteraction.Ignore
                            );

                            foreach(Collider col in overlaps) {
                                if(col.gameObject == playerBody.gameObject)
                                    continue;

                                capsuleOverlapInvalid = true;
                                Debug.Log("Capsule overlap detected on: " + col.name);
                                break;
                            }

                            // Debug line to visualize overlap check
                            Debug.DrawLine(capsuleBottom, capsuleTop, capsuleOverlapInvalid ? Color.red : Color.green);
                        }
                    }

                    // If overlap is invalid, we end the arc here as "no"
                    if(capsuleOverlapInvalid) {
                        hitting = false;
                        line.colorGradient = cantTeleportColor;

                        // End line here for clarity
                        lineList[lineList.Count - 1] = lineArr[i];

                        // If we had a highlighted TeleportPoint from last frame, clear it now
                        if(currentTeleportPoint != null) {
                            currentTeleportPoint.StopHighlighting(this);
                            currentTeleportPoint = null;
                        }

                        break;
                    }
                    else {
                        // Overlap is fine => use teleporter or solid
                        if(teleporterHit) {
                            hitting = true;
                            if(currentTeleportPoint == null || currentTeleportPoint != foundTP)
                                foundTP.StartHighlighting(this);

                            currentTeleportPoint = foundTP;

                            // End line right at the TeleportPoint's collision point
                            lineList[lineList.Count - 1] = aimHit.point;
                            line.colorGradient = canTeleportColor;
                            break;
                        }
                        else if(solidHitFound) {
                            // Non-teleport surface, but valid
                            hitting = true;
                            aimHit = bestSolidHit;

                            // If we had an old teleport point, stop highlighting
                            if(currentTeleportPoint != null) {
                                currentTeleportPoint.StopHighlighting(this);
                                currentTeleportPoint = null;
                            }

                            lineList[lineList.Count - 1] = aimHit.point;
                            line.colorGradient = canTeleportColor;
                            foundTeleport = true;
                            break;
                        }
                        else {
                            foundTeleport = true;
                            break;
                        }
                    }
                }
            }

            // Final update to line renderer
            line.enabled = true;
            line.positionCount = lineList.Count;
            line.SetPositions(lineList.ToArray());

            // If we never found anything valid, be sure to clear any leftover highlight
            if(!hitting && currentTeleportPoint != null) {
                currentTeleportPoint.StopHighlighting(this);
                currentTeleportPoint = null;
            }
        }

        /// <summary>
        /// Places the indicator where we hit (if hitting) and if not a TeleportPoint.
        /// </summary>
        void DrawIndicator() {
            if(indicator == null)
                return;

            if(hitting) {
                if(currentTeleportPoint == null && onlyUseTeleportPoints) {
                    indicator.SetActive(false);
                    line.colorGradient = cantTeleportColor;
                }
                else if(currentTeleportPoint != null) {
                    indicator.SetActive(false);
                }
                else {
                    // Show our generic ground indicator
                    indicator.SetActive(true);
                    indicator.transform.position = aimHit.point;
                    indicator.transform.up = aimHit.normal;
                }
            }
            else {
                indicator.SetActive(false);
            }
        }

        public void StartTeleport() {
            aiming = true;
            ToggleTeleportPoints(true);
            line.enabled = true;
            OnStartTeleport?.Invoke();
        }

        public void CancelTeleport() {
            aiming = false;
            hitting = false;
            line.positionCount = 0;
            line.enabled = false;
            ToggleTeleportPoints(false);

            if(currentTeleportPoint != null) {
                currentTeleportPoint.StopHighlighting(this);
                currentTeleportPoint = null;
            }
            indicator?.SetActive(false);

            OnStopTeleport?.Invoke();
        }

        /// <summary>
        /// Actually perform the teleport, either to a TeleportPoint or a generic location.
        /// </summary>
        public void Teleport() {
            // If we are on a TeleportPoint:
            if(currentTeleportPoint != null) {
                Vector3 finalPos = currentTeleportPoint.matchPoint
                    ? currentTeleportPoint.teleportPoint.position
                    : aimHit.point;

                Quaternion finalRot = currentTeleportPoint.matchDirection
                    ? currentTeleportPoint.teleportPoint.rotation
                    : playerBody ? playerBody.headCamera.transform.rotation : Quaternion.identity;

                // Move the designated object
                if(teleportObject != null) {
                    Vector3 offset = finalPos - teleportObject.transform.position;
                    teleportObject.transform.position = finalPos;
                    foreach(var extra in additionalTeleports) {
                        extra.position += offset;
                    }
                }
                // Move the player body
                if(playerBody != null) {
                    playerBody.SetPosition(finalPos, finalRot);
                }

                // Invoke the TeleportPoints own teleport logic
                currentTeleportPoint.Teleport(this);
                OnTeleport?.Invoke();
            }
            else if(!onlyUseTeleportPoints && hitting) {
                // Solid ground (nonteleport) is allowed, and we found a valid aimHit
                Vector3 finalPos = aimHit.point;

                if(teleportObject != null) {
                    Vector3 offset = finalPos - teleportObject.transform.position;
                    teleportObject.transform.position = finalPos;
                    foreach(var extra in additionalTeleports) {
                        extra.position += offset;
                    }
                }
                if(playerBody != null) {
                    // Just rotate so player faces the same direction, or up to you
                    playerBody.SetPosition(finalPos);
                }
                OnTeleport?.Invoke();
            }

            CancelTeleport();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Teleporter.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c847ed0f3ff34c24f900fe5219a64c6b
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand.Demo {

    public class TeleportPoint : MonoBehaviour {
        public Transform teleportPoint;
        public bool alwaysShow = false;
        public bool matchPoint = true;
        public bool matchDirection = true;

        public UnityEvent<TeleportPoint, Teleporter> StartHighlight;
        public UnityEvent<TeleportPoint, Teleporter> StopHighlight;
        public UnityEvent<TeleportPoint, Teleporter> OnTeleport;


        public void Awake() {
            if(teleportPoint == null)
                teleportPoint = transform;
        }


        public virtual void StartHighlighting(Teleporter raycaster) {
            StartHighlight.Invoke(this, raycaster);
        }

        public virtual void StopHighlighting(Teleporter raycaster) {
            StopHighlight.Invoke(this, raycaster);
        }

        public virtual void Teleport(Teleporter raycaster) {
            OnTeleport.Invoke(this, raycaster);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPointAnimation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3fcaf767645120d4fb8ca8b1fdeed5a3
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {
    [RequireComponent(typeof(TeleportPoint))]
    public class TeleportPointAnimation : InteractionAnimations {
        TeleportPoint teleportPoint;

        protected override void OnEnable() {
            base.OnEnable();
            teleportPoint = GetComponent<TeleportPoint>();
            teleportPoint.StartHighlight.AddListener(StartHighlight);
            teleportPoint.StopHighlight.AddListener(StopHighlight);
        }

        protected override void OnDisable() {
            base.OnDisable();
            teleportPoint.StartHighlight.RemoveListener(StartHighlight);
            teleportPoint.StopHighlight.RemoveListener(StopHighlight);
        }

        void StartHighlight(TeleportPoint teleportPoint, Teleporter teleporter) {
            highlightStartTime = Time.time;
            highlighting = true;
        }

        void StopHighlight(TeleportPoint teleportPoint, Teleporter teleporter) {
            highlightStopTime = Time.time;
            highlighting = false;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPointAnimation.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPointSoundEffects.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9f8ad05781f4e8e4ea6032116eb81d7b
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {
    public class TeleportPointSoundEffects : MonoBehaviour {
        public TeleportPoint teleportPoint;
        public float randomPitchRange = 0.1f;
        public AudioSource audioSource;
        public AudioClip startHighlightSound;
        public AudioClip stopHighlightSound;
        public AudioClip teleportSound;

        float startPitch;

        private void OnEnable() {
            if(audioSource == null)
                audioSource = GetComponent<AudioSource>();
            if(teleportPoint == null)
                teleportPoint = GetComponent<TeleportPoint>();

            teleportPoint.StartHighlight.AddListener(OnStartHighlight);
            teleportPoint.StopHighlight.AddListener(OnStopHighlight);
            teleportPoint.OnTeleport.AddListener(OnTeleport);
            startPitch = audioSource.pitch;
        }

        private void OnDisable() {
            teleportPoint.StartHighlight.RemoveListener(OnStartHighlight);
            teleportPoint.StopHighlight.RemoveListener(OnStopHighlight);
            teleportPoint.OnTeleport.RemoveListener(OnTeleport);
        }

        void OnStartHighlight(TeleportPoint point, Teleporter raycaster) {
            if(audioSource != null && startHighlightSound != null) {
                audioSource.pitch = startPitch + Random.Range(-randomPitchRange, randomPitchRange);
                audioSource.PlayOneShot(startHighlightSound);
            }
        }

        void OnStopHighlight(TeleportPoint point, Teleporter raycaster) {
            if(audioSource != null && stopHighlightSound != null) {
                audioSource.pitch = startPitch + Random.Range(-randomPitchRange, randomPitchRange);
                audioSource.PlayOneShot(stopHighlightSound);
            }
        }

        void OnTeleport(TeleportPoint point, Teleporter raycaster) {
            if(audioSource != null && teleportSound != null) {
                audioSource.pitch = startPitch + Random.Range(-randomPitchRange, randomPitchRange);
                audioSource.PlayOneShot(teleportSound);
            }
        }


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPointSoundEffects.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/GrabbableEventDebugger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 84b1fb89c46159949aa89dc678cd2a5f
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;


namespace Autohand.Demo {
    [RequireComponent(typeof(Grabbable))]public class GrabbableEventDebugger : MonoBehaviour
    {
        Grabbable grab;

        private void OnEnable(){
            grab = GetComponent<Grabbable>();
            grab.OnBeforeGrabEvent += OnBeforeGrabbed;
            grab.OnGrabEvent += OnGrabbed;
            grab.OnReleaseEvent += OnReleased;
            grab.OnJointBreakEvent += OnJointBreakEvent;
            grab.OnSqueezeEvent += OnSqueeze;
            grab.OnUnsqueezeEvent += OnUnsqueeze;
            grab.OnHighlightEvent += OnHighlightStart;
            grab.OnUnhighlightEvent += OnHighlightStop;
        }

        private void OnDisable(){
            grab.OnBeforeGrabEvent -= OnBeforeGrabbed;
            grab.OnGrabEvent -= OnGrabbed;
            grab.OnReleaseEvent -= OnReleased;
            grab.OnJointBreakEvent -= OnJointBreakEvent;
            grab.OnSqueezeEvent -= OnSqueeze;
            grab.OnUnsqueezeEvent -= OnUnsqueeze;
            grab.OnHighlightEvent -= OnHighlightStart;
            grab.OnUnhighlightEvent -= OnHighlightStop;
        }

        void OnBeforeGrabbed(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " BEFORE GRABBED");
        }

        void OnGrabbed(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " GRABBED");
        }

        void OnReleased(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " RELEASED");
        }

        void OnHighlightStart(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " HIGHLIGHTED");
        }

        void OnHighlightStop(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " UNHIGHLIGHTED");
        }

        void OnJointBreakEvent(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " JOINT BROKE");
        }

        void OnSqueeze(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " SQUEEZED");
        }

        void OnUnsqueeze(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " UNSQUEEZED");
        }
    }


[RequireComponent(typeof(Grabbable))]
public class GrabbableRigidbodyGrabEvents : MonoBehaviour {
    public bool setGravityWhenGrabbed = true;
    public bool setKinematicWhenGrabbed = false;
    public bool setGravityWhenReleased = false;
    public bool setKinematicWhenReleased = true;
    Grabbable grab;

    private void OnEnable() {
        grab = GetComponent<Grabbable>();
        grab.OnGrabEvent += OnGrabbed;
        grab.OnReleaseEvent += OnReleased;
    }

    private void OnDisable() {
        grab.OnGrabEvent -= OnGrabbed;
        grab.OnReleaseEvent -= OnReleased;
    }

    void OnGrabbed(Hand hand, Grabbable grabbable) {
        grabbable.body.useGravity = setGravityWhenGrabbed;
        grabbable.body.isKinematic = setKinematicWhenGrabbed;
    }

    void OnReleased(Hand hand, Grabbable grabbable) {
        grabbable.body.useGravity = setGravityWhenReleased;
        grabbable.body.isKinematic = setKinematicWhenReleased;
    }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/GrabbableEventDebugger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandEventDebugger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d1cfa7fca3c60d543beef7d0783d75f7
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;


namespace Autohand.Demo {
    [RequireComponent(typeof(Hand))]
    public class HandEventDebugger : MonoBehaviour
    {
        public bool showSqueezeEvents = true;
        public bool showHighlightEvents = true;

        private void OnEnable()
        {
            var hand1 = GetComponent<Hand>();
            hand1.OnBeforeGrabbed += (hand, grabbable) => { Debug.Log(hand.name + " BEFORE GRAB EVENT", this); };
            hand1.OnGrabbed += (hand, grabbable) => { Debug.Log(hand.name + " GRAB EVENT", this); };
            hand1.OnReleased += (hand, grabbable) => { Debug.Log(hand.name + " RELEASE EVENT", this); };
            hand1.OnGrabJointBreak += (hand, grabbable) => { Debug.Log(hand.name + " JOINT BREAK EVENT", this); };
            
            if(showSqueezeEvents) hand1.OnSqueezed += (hand, grabbable) => { Debug.Log(hand.name + " SQUEEZE EVENT", this); };
            if (showSqueezeEvents) hand1.OnUnsqueezed += (hand, grabbable) => { Debug.Log(hand.name + " UNSQUEEZE EVENT", this); };
            if (showHighlightEvents) hand1.highlighter.OnHighlight += (hand, grabbable) => { Debug.Log(hand.name + " HIGHLIGHT EVENT", this); };
            if (showHighlightEvents) hand1.highlighter.OnStopHighlight += (hand, grabbable) => { Debug.Log(hand.name + " UNHIGHLIGHT EVENT", this); };
        }

        private void OnDisable()
        {
            var hand1 = GetComponent<Hand>();
            hand1.OnBeforeGrabbed -= (hand, grabbable) => { Debug.Log(hand.name + " BEFORE GRAB EVENT", this); };
            hand1.OnGrabbed -= (hand, grabbable) => { Debug.Log(hand.name + " GRAB EVENT", this); };
            hand1.OnReleased -= (hand, grabbable) => { Debug.Log(hand.name + " RELEASE EVENT", this); };
            hand1.OnGrabJointBreak -= (hand, grabbable) => { Debug.Log(hand.name + " CONNECTION BREAK EVENT", this); };
            
            if (showSqueezeEvents) hand1.OnSqueezed -= (hand, grabbable) => { Debug.Log(hand.name + " SQUEEZE EVENT", this); };
            if (showSqueezeEvents) hand1.OnUnsqueezed -= (hand, grabbable) => { Debug.Log(hand.name + " UNSQUEEZE EVENT", this); };
            if (showHighlightEvents) hand1.highlighter.OnHighlight -= (hand, grabbable) => { Debug.Log(hand.name + " HIGHLIGHT EVENT", this); };
            if (showHighlightEvents) hand1.highlighter.OnStopHighlight -= (hand, grabbable) => { Debug.Log(hand.name + " UNHIGHLIGHT EVENT", this); };
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandEventDebugger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandEventTemplate.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 94d60b2b26a806841ae31afd9e936101
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using Autohand;

public class HandEventTemplate : MonoBehaviour{
    public Hand hand;

    void OnEnable() {
        hand.OnBeforeGrabbed += OnBeforeGrabbed;
        hand.OnGrabbed += OnGrabbed;
        hand.OnBeforeReleased += OnBeforeReleased;
        hand.OnReleased += OnReleased;
        hand.OnForcedRelease += OnForcedRelease;
        hand.OnGrabJointBreak += OnGrabJointBreak;

        hand.OnHandCollisionStart += OnHandCollisionStart;
        hand.OnHandCollisionStop += OnHandCollisionStop;
        hand.OnHandTriggerStart += OnHandTriggerStart;
        hand.OnHandTriggerStop += OnHandTriggerStop;

        hand.highlighter.OnHighlight += OnHighlight;
        hand.highlighter.OnStopHighlight += OnStopHighlight;

        hand.OnSqueezed += OnSqueezed;
        hand.OnUnsqueezed += OnUnsqueezed;

        hand.OnTriggerGrab += OnTriggerGrab;
        hand.OnTriggerRelease += OnTriggerRelease;
    }


    void OnDisable() {
        hand.OnBeforeGrabbed -= OnBeforeGrabbed;
        hand.OnGrabbed -= OnGrabbed;
        hand.OnBeforeReleased -= OnBeforeReleased;
        hand.OnReleased -= OnReleased;
        hand.OnForcedRelease -= OnForcedRelease;
        hand.OnGrabJointBreak -= OnGrabJointBreak;


        hand.highlighter.OnHighlight -= OnHighlight;
        hand.highlighter.OnStopHighlight -= OnStopHighlight;

        hand.OnSqueezed -= OnSqueezed;
        hand.OnUnsqueezed -= OnUnsqueezed;

        hand.OnTriggerGrab -= OnTriggerGrab;
        hand.OnTriggerRelease -= OnTriggerRelease;


        hand.OnHandCollisionStart -= OnHandCollisionStart;
        hand.OnHandCollisionStop -= OnHandCollisionStop;
        hand.OnHandTriggerStart -= OnHandTriggerStart;
        hand.OnHandTriggerStop -= OnHandTriggerStop;
    }

    void OnBeforeGrabbed(Hand hand, Grabbable grab) {
        //Called when an object is grabbed before anything else
    }

    void OnGrabbed(Hand hand, Grabbable grab) {
        //Called when an object is grabbed
    }

    void OnBeforeReleased(Hand hand, Grabbable grab) {
        //Called when a held object is released before anything else
    }

    void OnReleased(Hand hand, Grabbable grab) {
        //Called when a held object is released
    }

    void OnForcedRelease(Hand hand, Grabbable grab) {
        //Called when the force release functions is called

    }


    void OnGrabJointBreak(Hand hand, Grabbable grab) {
        //Called when the joint between the hand the grabbable breaks
    }


    void OnHighlight(Hand hand, Grabbable grab) {
        //Called when the hand grab targets a new object
    }
    
    void OnStopHighlight(Hand hand, Grabbable grab) {
        //Called when the hand grab stops targeting an object
    }



    void OnSqueezed(Hand hand, Grabbable grab) {
        //Called when the "Squeeze" event is called, this event is tied to a seconary controller input through the HandControllerLink component on the hand
    }
    void OnUnsqueezed(Hand hand, Grabbable grab) {
        //Called when the "Unsqueeze" event is called, this event is tied to a seconary controller input through the HandControllerLink component on the hand
    }



    void OnTriggerGrab(Hand hand, Grabbable grab) {
        //Called when the "Grab" event is called, regardless of whether something is being grabbed or not
    }
    void OnTriggerRelease(Hand hand, Grabbable grab) {
        //Called when the "Release" event is called, regardless of whether something is being held or released
    }



    void OnHandCollisionStart(Hand hand, GameObject other) {
        //Called when the hand hits an object for the first time and isn't already colliding
    }

    void OnHandCollisionStop(Hand hand, GameObject other) {
        //Called all the hand has zero collisions on the object

    }

    void OnHandTriggerStart(Hand hand, GameObject other) {
        //Called when the hand triggers an object for the first time and isn't already triggering
    }

    void OnHandTriggerStop(Hand hand, GameObject other) {
        //Called when the hand has zero colliders overlapping this trigger
    }


}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandEventTemplate.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandTouchEventDebugger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 57c04f334190d304395f0d844ffe1f04
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {
    public class HandTouchEventDebugger : MonoBehaviour {
        public HandTouchEvent touchEvent;

        private void OnEnable() {
            touchEvent.HandStartTouchEvent += StartTouch;
            touchEvent.HandStopTouchEvent += StopTouch;
        }

        private void OnDisable() {
            touchEvent.HandStartTouchEvent -= StartTouch;
            touchEvent.HandStopTouchEvent -= StopTouch;
        }

        void StartTouch(Hand hand) {
            Debug.Log("Start Touch: " + hand.name);
        }
        void StopTouch(Hand hand) {
            Debug.Log("Stop Touch: " + hand.name);
        }
    }

}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandTouchEventDebugger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/PlacePointEventDebugger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0561c58c7b0c54947b3ac20a3aa6d8ab
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(PlacePoint))]
public class PlacePointEventDebugger : MonoBehaviour
{
    PlacePoint placePoint;

    void OnEnable()
    {
        placePoint = GetComponent<PlacePoint>();
        placePoint.OnPlaceEvent += (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Place: " + Time.time); };
        placePoint.OnRemoveEvent += (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Remove: " + Time.time); };
        placePoint.OnHighlightEvent += (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Highlight: " + Time.time); };
        placePoint.OnStopHighlightEvent += (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Stop Highlight: " + Time.time); };
    }


    void OnDisable()
    {
        placePoint = GetComponent<PlacePoint>();
        placePoint.OnPlaceEvent -= (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Place: " + Time.time); };
        placePoint.OnRemoveEvent -= (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Remove: " + Time.time); };
        placePoint.OnHighlightEvent -= (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Highlight: " + Time.time); };
        placePoint.OnStopHighlightEvent -= (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Stop Highlight: " + Time.time); };
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/PlacePointEventDebugger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/PlacePointEventTemplate.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 68ca9f1f64514ea44b259d8683f56c5a
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using Autohand;

public class PlacePointEventTemplate : MonoBehaviour {
    public PlacePoint placePoint;

    void OnEnable() {
        placePoint.OnPlaceEvent += OnPlace;
        placePoint.OnRemoveEvent += OnPlace;
        placePoint.OnHighlightEvent += OnHighlight;
        placePoint.OnStopHighlightEvent += OnStopHighlight;
    }

    private void OnDisable() {
        placePoint.OnPlaceEvent -= OnPlace;
        placePoint.OnRemoveEvent -= OnPlace;
        placePoint.OnHighlightEvent -= OnHighlight;
        placePoint.OnStopHighlightEvent -= OnStopHighlight;

    }


    public void OnPlace(PlacePoint point, Grabbable grab) {
        //Stuff happens when placed
    }


    public void OnRemove(PlacePoint point, Grabbable grab) {
        //Stuff happens when placed was removed

    }
    public void OnHighlight(PlacePoint point, Grabbable grab) {
        //Stuff happens when placepoint was highlighted

    }

    public void OnStopHighlight(PlacePoint point, Grabbable grab) {
        //Stuff happens when placepoint was done highlighting
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/PlacePointEventTemplate.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/AutoHandSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0bda962a91c41024b9c86bcb7cb57d2f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class AutoHandSettings : ScriptableObject{
    [Tooltip("Whether the popup should be ignored on launch or not")]
    public bool ignoreSetup = false;
    public bool usingDynamicTimestep = true;
    public bool useAutomaticControllerOffset = true;
    [Tooltip("-1 is custom, 0 is low, 1 is medium, 2 is high")]
    public float quality = -1;

    public static void ClearSettings() {
        var _handSettings = Resources.Load<AutoHandSettings>("AutoHandSettings");
        _handSettings.ignoreSetup = false;
        _handSettings.usingDynamicTimestep = true;
        _handSettings.quality = -1;
#if UNITY_EDITOR
        UnityEditor.EditorUtility.SetDirty(_handSettings);
#endif
    }
    public static bool UsingDynamicTimestep() {
        var _handSettings = Resources.Load<AutoHandSettings>("AutoHandSettings");
        return _handSettings.usingDynamicTimestep;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/AutoHandSettings.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/AutoInputModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f3db25e7af68fae448be32ac1f37480f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine.EventSystems;
using UnityEngine;

namespace Autohand
{
    public class AutoInputModule : BaseInputModule
    {
        private List<HandCanvasPointer> pointers = new List<HandCanvasPointer>();
        private PointerEventData[] eventDatas;

        AutoInputModule _instance;
        private bool _isDestroyed = false;

        /// <summary>Returns the current pointer being checked when triggering input events, should only be used during built in UI input events</summary>
        public HandCanvasPointer currentPointer { get; private set; }

        public AutoInputModule Instance
        {
            get
            {
                if (_isDestroyed)
                    return null;

                if (_instance == null)
                {
                    if (!(_instance = AutoHandExtensions.CanFindObjectOfType<AutoInputModule>()))
                    {
                        _instance = new GameObject().AddComponent<AutoInputModule>();
                        _instance.transform.parent = AutoHandExtensions.transformParent;
                    }



                    EventSystem[] system = null;
                    BaseInputModule[] inputModule;

                    inputModule = AutoHandExtensions.CanFindObjectsOfType<BaseInputModule>();
                    if (inputModule.Length > 1)
                    {
                        for (int i = inputModule.Length - 1; i >= 0; i--)
                        {
                            if (!inputModule[i].gameObject.GetComponent<AutoInputModule>())
                                Destroy(inputModule[i]);
                            Debug.LogWarning("AUTO HAND:  REMOVING ADDITIONAL EVENT SYSTEMS FROM THE SCENE");
                        }
                    }

                    system = AutoHandExtensions.CanFindObjectsOfType<EventSystem>();
                    if (system.Length > 1)
                    {
                        for (int i = system.Length - 1; i >= 0; i--)
                        {
                            if (!system[i].gameObject.GetComponent<AutoInputModule>())
                                Destroy(system[i]);
                            Debug.LogWarning("AUTO HAND:  REMOVING ADDITIONAL EVENT SYSTEMS FROM THE SCENE");
                        }
                    }

                }

                return _instance;
            }
        }

        protected override void Awake()
        {
            base.Awake();
        }

        protected override void OnDestroy()
        {
            _isDestroyed = true;
        }

        public int AddPointer(HandCanvasPointer pointer)
        {
            if (!pointers.Contains(pointer))
            {
                pointers.Add(pointer);
                eventDatas = new PointerEventData[pointers.Count];

                for (int i = 0; i < eventDatas.Length; i++)
                {
                    eventDatas[i] = new PointerEventData(eventSystem);
                    eventDatas[i].delta = Vector2.zero;
                    eventDatas[i].position = new Vector2(Screen.width / 2, Screen.height / 2);
                }
            }

            return pointers.IndexOf(pointer);
        }

        public void RemovePointer(HandCanvasPointer pointer)
        {
            int pIndex = pointers.IndexOf(pointer);
            ProcessRelease(pIndex);
            ProcessExit(pIndex);

            if (pointers.Contains(pointer))
                pointers.Remove(pointer);
            foreach (var point in pointers)
            {
                point.SetIndex(pointers.IndexOf(point));
            }
            eventDatas = new PointerEventData[pointers.Count];
            for (int i = 0; i < eventDatas.Length; i++)
            {
                eventDatas[i] = new PointerEventData(eventSystem);
                eventDatas[i].delta = Vector2.zero;
                eventDatas[i].position = new Vector2(Screen.width / 2, Screen.height / 2);
            }
        }

        public override void Process()
        {
#pragma warning disable
            for (int index = 0; index < pointers.Count; index++)
            {
                try
                {
                    if (pointers[index] != null && pointers[index].enabled)
                    {
                        currentPointer = pointers[index];
                        pointers[index].Preprocess();
                        // Hooks in to Unity's event system to handle hovering
                        eventSystem.RaycastAll(eventDatas[index], m_RaycastResultCache);
                        eventDatas[index].pointerCurrentRaycast = FindFirstRaycast(m_RaycastResultCache);

                        HandlePointerExitAndEnter(eventDatas[index], eventDatas[index].pointerCurrentRaycast.gameObject);

                        ExecuteEvents.Execute(eventDatas[index].pointerDrag, eventDatas[index], ExecuteEvents.dragHandler);
                    }

                }
                catch { }
            }
#pragma warning restore
        }

        public void ProcessPress(int index)
        {
            pointers[index].Preprocess();
            // Hooks in to Unity's event system to process a release
            eventDatas[index].pointerPressRaycast = eventDatas[index].pointerCurrentRaycast;

            eventDatas[index].pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(eventDatas[index].pointerPressRaycast.gameObject);
            eventDatas[index].pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(eventDatas[index].pointerPressRaycast.gameObject);

            ExecuteEvents.Execute(eventDatas[index].pointerPress, eventDatas[index], ExecuteEvents.pointerDownHandler);
            ExecuteEvents.Execute(eventDatas[index].pointerDrag, eventDatas[index], ExecuteEvents.beginDragHandler);
        }

        public void ProcessRelease(int index)
        {
            pointers[index].Preprocess();
            // Hooks in to Unity's event system to process a press
            GameObject pointerRelease = ExecuteEvents.GetEventHandler<IPointerClickHandler>(eventDatas[index].pointerCurrentRaycast.gameObject);

            if (eventDatas[index].pointerPress == pointerRelease)
                ExecuteEvents.Execute(eventDatas[index].pointerPress, eventDatas[index], ExecuteEvents.pointerClickHandler);

            ExecuteEvents.Execute(eventDatas[index].pointerPress, eventDatas[index], ExecuteEvents.pointerUpHandler);
            ExecuteEvents.Execute(eventDatas[index].pointerDrag, eventDatas[index], ExecuteEvents.endDragHandler);

            eventDatas[index].pointerPress = null;
            eventDatas[index].pointerDrag = null;

            eventDatas[index].pointerCurrentRaycast.Clear();
        }

        public void ProcessExit(int index) {
            GameObject pointerRelease = ExecuteEvents.GetEventHandler<IPointerExitHandler>(eventDatas[index].pointerCurrentRaycast.gameObject);
            ExecuteEvents.Execute(pointerRelease, eventDatas[index], ExecuteEvents.pointerExitHandler);
        }

        public PointerEventData GetData(int index) { return eventDatas[index]; }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/AutoInputModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionIgnores.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fe6db899177c9e348ba7b46314349499
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CollisionIgnores : MonoBehaviour {
    public bool disableOnStart = true;
    public Collider[] cols1;
    public Collider[] cols2;

    void Start() {
        DisableCollisions();
    }

    public void EnableCollisions() {
        for(int i = 0; i < cols1.Length; i++)
            for(int j = 0; j < cols2.Length; j++)
                Physics.IgnoreCollision(cols1[i], cols2[j], false);
    }

    public void DisableCollisions() {
        for(int i = 0; i < cols1.Length; i++)
            for(int j = 0; j < cols2.Length; j++)
                Physics.IgnoreCollision(cols1[i], cols2[j], true);
    }


}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionIgnores.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionSound.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1c498b8ff53f43d43bb5f3b6001c2364
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/collision-sounds")]
public class CollisionSound : MonoBehaviour{
    [Tooltip("The layers that cause the sound to play")]
    public LayerMask collisionTriggers = ~0;
    [Tooltip("Source to play sound from")]
    public AudioSource source;
    [Tooltip("Source to play sound from")]
    public AudioClip clip;
    [Space]
    [Tooltip("Source to play sound from")]
    public AnimationCurve velocityVolumeCurve = AnimationCurve.Linear(0, 0, 1, 1);

    public float volumeAmp = 0.8f;
    public float velocityAmp = 0.5f;
    public float soundRepeatDelay = 0.2f;

    Rigidbody body;
    bool canPlaySound = true;
    Coroutine playSoundRoutine;

    private void Start() {
        body = GetComponent<Rigidbody>();

        //So the sound doesn't play when falling in place on start
        StartCoroutine(SoundPlayBuffer(1f));
    }

    private void OnDisable(){
        if (playSoundRoutine != null)
            StopCoroutine(playSoundRoutine);
    }

    void OnCollisionEnter(Collision collision) {
        if (body == null && !gameObject.CanGetComponent(out body))
            return;

        if(canPlaySound && collisionTriggers == (collisionTriggers | (1 << collision.gameObject.layer))) {
            if(source != null && source.enabled){
                if (collision.collider.attachedRigidbody == null || collision.collider.attachedRigidbody.mass > 0.0000001f){
                    if(clip != null || source.clip != null)
                        source.PlayOneShot(clip == null ? source.clip : clip, velocityVolumeCurve.Evaluate(collision.relativeVelocity.magnitude * velocityAmp) * volumeAmp);
                    if (playSoundRoutine != null)
                        StopCoroutine(playSoundRoutine);
                    playSoundRoutine = StartCoroutine(SoundPlayBuffer());
                }
            }
        }
    }

    IEnumerator SoundPlayBuffer() {
        canPlaySound = false;
        yield return new WaitForSeconds(soundRepeatDelay);
        canPlaySound = true;
        playSoundRoutine = null;
    }

    IEnumerator SoundPlayBuffer(float time) {
        canPlaySound = false;
        yield return new WaitForSeconds(time);
        canPlaySound = true;
        playSoundRoutine = null;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionSound.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 21360bf2f4ba84149856028de8de2c89
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public delegate void CollisionEvent(GameObject from);

    public class CollisionTracker : MonoBehaviour {

        public bool disableCollisionTracking = false;
        public bool disableTriggersTracking = false;

        public event CollisionEvent OnCollisionFirstEnter;
        public event CollisionEvent OnCollisionLastExit;
        public event CollisionEvent OnTriggerFirstEnter;

        public event CollisionEvent OnTriggerLastExit; // todo fix typo?

        public int collisionCount { get { return collisionObjects.Count; } }
        public int triggerCount { get { return triggerObjects.Count; } }

        const int MAX_COLLISIONS_TRACKED = 256;

        public List<GameObject> triggerObjects { get; protected set; } = new List<GameObject>(MAX_COLLISIONS_TRACKED);

        public List<GameObject> collisionObjects { get; protected set; } = new List<GameObject>(MAX_COLLISIONS_TRACKED);

        public List<GameObject> nextTriggerObjects { get; protected set; } = new List<GameObject>(MAX_COLLISIONS_TRACKED);

        public List<GameObject> nextCollisionObjects { get; protected set; } = new List<GameObject>(MAX_COLLISIONS_TRACKED);

        protected List<Collision> collisions { get; set; } = new List<Collision>(MAX_COLLISIONS_TRACKED);

        Coroutine lateFixedUpdate;

        public void CleanUp() {
            triggerObjects.Clear();
            nextTriggerObjects.Clear();
            collisionObjects.Clear();
            nextCollisionObjects.Clear();
            collisions.Clear();
        }

        protected virtual void OnEnable() {
            lateFixedUpdate = StartCoroutine(LateFixedUpdate());
        }

        protected virtual void OnDisable() {
            for(int i = 0; i < collisionObjects.Count; i++) {
                if(collisionObjects[i] && OnCollisionLastExit != null)
                    OnCollisionLastExit.Invoke(collisionObjects[i]);
            }
            for(int i = 0; i < triggerObjects.Count; i++) {
                if(triggerObjects[i] && OnTriggerLastExit != null)
                        OnTriggerLastExit.Invoke(triggerObjects[i]);
            }
            CleanUp();

            StopCoroutine(lateFixedUpdate);
        }

        WaitForFixedUpdate waitForFixed = new WaitForFixedUpdate();
        IEnumerator LateFixedUpdate() {
            // using late fixed update so the events get fired in the same cycle as the collision updates happened
            while(true) {
                yield return waitForFixed;

                CheckTrackedObjects();
            }
        }

        private void CheckTrackedObjects() {
            if(!disableCollisionTracking) {
                for(int i = 0; i < collisionObjects.Count; i++) {
                    if(!collisionObjects[i].activeInHierarchy ||
                        !nextCollisionObjects.Contains(collisionObjects[i])) {
                        if(OnCollisionLastExit != null)
                            OnCollisionLastExit.Invoke(collisionObjects[i]);
                    }
                }

                for(int i = 0; i < nextCollisionObjects.Count; i++) {
                    if(nextCollisionObjects[i] == null ||
                    !nextCollisionObjects[i].activeInHierarchy) {
                        nextCollisionObjects.RemoveAt(i);
                    }
                    else if(!collisionObjects.Contains(nextCollisionObjects[i])) {
                        if(OnCollisionFirstEnter != null)
                            OnCollisionFirstEnter.Invoke(nextCollisionObjects[i]);
                    }
                }

                collisionObjects.Clear();
                collisionObjects.AddRange(nextCollisionObjects);
                nextCollisionObjects.Clear();
                collisions.Clear();
            }

            if(!disableTriggersTracking) {
                for(int i = 0; i < triggerObjects.Count; i++) {
                    if(!triggerObjects[i].activeInHierarchy ||
                        !nextTriggerObjects.Contains(triggerObjects[i])) {
                        if(OnTriggerLastExit != null)
                            OnTriggerLastExit.Invoke(triggerObjects[i]);
                    }
                }

                for(int i = 0; i < nextTriggerObjects.Count; i++) {
                    if(nextTriggerObjects[i] == null ||
                    !nextTriggerObjects[i].activeInHierarchy) {
                        nextTriggerObjects.RemoveAt(i);
                    }
                    else if(!triggerObjects.Contains(nextTriggerObjects[i])) {
                        if(OnTriggerFirstEnter != null)
                            OnTriggerFirstEnter.Invoke(nextTriggerObjects[i]);
                    }
                }

                triggerObjects.Clear();
                triggerObjects.AddRange(nextTriggerObjects);
                nextTriggerObjects.Clear();
            }
        }

        protected virtual void OnCollisionStay(Collision collision) {
            if(!disableCollisionTracking) {
                collisions.Add(collision);

                if(!nextCollisionObjects.Contains(collision.collider.gameObject)) {
                    nextCollisionObjects.Add(collision.collider.gameObject);
                }
            }
        }

        protected virtual void OnTriggerStay(Collider other) {
            if(!disableTriggersTracking) {
                if(!nextTriggerObjects.Contains(other.gameObject)) {
                    nextTriggerObjects.Add(other.gameObject);
                }
            }
        }

//#if UNITY_EDITOR
//        private void OnDrawGizmos() {
//            foreach(var collision in collisions) {
//                foreach(var contactPoint in collision.contacts) {
//                    Gizmos.DrawSphere(contactPoint.point, 0.0025f);
//                }
//            }
//        }
//#endif
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionTracker.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/HandCanvasPointer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 596e2cdbad5de264abd332ce27c9e3e9
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

namespace Autohand
{
    [Serializable]
    public class UnityCanvasPointerEvent : UnityEvent<Vector3, GameObject> { }

    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/ui-interaction"), DefaultExecutionOrder(10000)]
    public class HandCanvasPointer : MonoBehaviour
    {
        [Header("References")]
        public GameObject hitPointMarker;
        private LineRenderer lineRenderer;
        public bool useSmoothing = true;
        public float forwardPointerSmoothing = 25f;


        [Header("Ray settings")]
        public float raycastLength = 8.0f;
        public bool autoShowTarget = true;
        public LayerMask UILayer;


        [Header("Events")]
        public UnityCanvasPointerEvent StartSelect;
        public UnityCanvasPointerEvent StopSelect;
        public UnityCanvasPointerEvent StartPoint;
        public UnityCanvasPointerEvent StopPoint;



        private GameObject _currTarget;
        public GameObject currTarget
        {
            get { return _currTarget; }
        }

        private float _currDistance;
        public float? CurrentDistance {
            get {
                return (_currTarget == null ? null : _currDistance);
            }
        }

        Vector3 currentSmoothForward;


        public RaycastHit lastHit { get; private set; }

        // Internal variables
        private bool hover = false;
        AutoInputModule inputModule = null;
        float lineSegements = 10f;

        bool beingDestroyed = false;
        static Camera cam = null;
        public static Camera UICamera
        {
            get
            {
                if (cam == null)
                {
                    cam = new GameObject("Camera Canvas Pointer (I AM CREATED AT RUNTIME FOR UI CANVAS INTERACTION, I AM NOT RENDERING ANYTHING, I AM NOT CREATING ADDITIONAL OVERHEAD)").AddComponent<Camera>();
                    cam.clearFlags = CameraClearFlags.Nothing;
                    cam.stereoTargetEye = StereoTargetEyeMask.None;
                    cam.orthographic = true;
                    cam.orthographicSize = 0.001f;
                    cam.cullingMask = 0;
                    cam.nearClipPlane = 0.001f;
                    cam.depth = 0f;
                    cam.allowHDR = false;
                    cam.enabled = false;
                    cam.fieldOfView = 0.00001f;
                    cam.transform.parent = AutoHandExtensions.transformParent;

#if (UNITY_2020_3_OR_NEWER)
                    var canvases = AutoHandExtensions.CanFindObjectsOfType<Canvas>(true);
#else
                    var canvases = FindObjectsOfType<Canvas>();
#endif
                    foreach(var canvas in canvases) {
                        if(canvas.renderMode == RenderMode.WorldSpace)
                            canvas.worldCamera = cam;
                    }

                }
                return cam;
            }
        }
        int pointerIndex;

        protected virtual void OnEnable()
        {

            if(lineRenderer != null)
                lineRenderer.positionCount = (int)lineSegements;
            if (inputModule.Instance != null)
                pointerIndex = inputModule.Instance.AddPointer(this);
            ShowRay(false);
        }

        protected virtual void OnDisable()
        {
            if(inputModule) inputModule.Instance?.RemovePointer(this);
        }

        protected virtual void OnDestroy() {
            beingDestroyed = true;
            if(cam != null)
                Destroy(cam.gameObject);
            cam = null;
        }

        public void SetIndex(int index)
        {
            pointerIndex = index;
        }

        protected internal virtual void Preprocess()
        {
            if(beingDestroyed) return;

            UICamera.farClipPlane = raycastLength;
            UICamera.transform.position = transform.position;
            UICamera.transform.forward = currentSmoothForward;
        }

        public virtual void Press() {
            // Handle the UI events
            if(inputModule) inputModule.ProcessPress(pointerIndex);

            // Show the ray when they attemp to press
            if(!autoShowTarget && hover) ShowRay(true);

            PointerEventData data = inputModule.GetData(pointerIndex);
            if(data != null && data.selectedObject != null) {
                StartSelect?.Invoke(data.pointerCurrentRaycast.worldPosition, data.selectedObject);
            }
        }

        public virtual void Release()
        {
            // Handle the UI events
            if(inputModule) inputModule.ProcessRelease(pointerIndex);

            PointerEventData data = inputModule.GetData(pointerIndex);
            var selectedObject = data.selectedObject;
            if(selectedObject != null) 
                StopSelect?.Invoke(data.pointerCurrentRaycast.worldPosition, selectedObject);
        }

        protected virtual void Awake()
        {
            if (lineRenderer == null)
                gameObject.CanGetComponent(out lineRenderer);

            if (inputModule == null)
            {
                if (gameObject.CanGetComponent<AutoInputModule>(out var inputMod))
                {
                    inputModule = inputMod;
                }
                else if (!(inputModule = AutoHandExtensions.CanFindObjectOfType<AutoInputModule>()))
                {
                    EventSystem system = AutoHandExtensions.CanFindObjectOfType<EventSystem>();
                    if(system == null) {
                        system = new GameObject().AddComponent<EventSystem>();
                        system.name = "UI Input Event System";
                    }
                    inputModule = system.gameObject.AddComponent<AutoInputModule>();
                    inputModule.transform.parent = AutoHandExtensions.transformParent;
                }
            }
        }

        protected virtual void LateUpdate()
        {
            if(useSmoothing) {
                var currentAngleDistance = Vector3.Angle(currentSmoothForward, transform.forward);
                currentSmoothForward = Vector3.RotateTowards(currentSmoothForward, transform.forward, Time.deltaTime * forwardPointerSmoothing + Time.deltaTime * forwardPointerSmoothing * currentAngleDistance, 1000f);
                currentSmoothForward.Normalize();
            }
            else
                currentSmoothForward = transform.forward;

            UpdateLine();
        }

        protected virtual void UpdateLine()
        {

            PointerEventData data = inputModule.GetData(pointerIndex);
            float targetLength = data.pointerCurrentRaycast.gameObject == null ? raycastLength : data.pointerCurrentRaycast.distance;

            if(targetLength > 0) {
                _currTarget = data.pointerCurrentRaycast.gameObject;
                _currDistance = targetLength;
            }
            else {
                _currTarget = null;
            }

            if (data.pointerCurrentRaycast.gameObject != null && !hover){
                lastHit = CreateRaycast(targetLength);
                Vector3 endPosition = transform.position + (currentSmoothForward * targetLength);
                if (lastHit.collider) endPosition = lastHit.point;


                if(lastHit.collider != null) {
                    currentSmoothForward = transform.forward;
                    StartPoint?.Invoke(lastHit.point, lastHit.transform.gameObject);
                }
                else {
                    currentSmoothForward = transform.forward;
                    StartPoint?.Invoke(endPosition, null);
                }


                // Show the ray if autoShowTarget is on when they enter the canvas
                if (autoShowTarget) ShowRay(true);

                hover = true;
            }
            else if (data.pointerCurrentRaycast.gameObject == null && hover){
                lastHit = CreateRaycast(targetLength);
                Vector3 endPosition = transform.position + (currentSmoothForward * targetLength);
                if (lastHit.collider) endPosition = lastHit.point;

                if (lastHit.collider != null)
                    StopPoint?.Invoke(lastHit.point, lastHit.transform.gameObject);
                else
                    StopPoint?.Invoke(endPosition, null);

                // Hide the ray when they leave the canvas
                ShowRay(false);
                hover = false;
            }

            if(hover) {
                lastHit = CreateRaycast(targetLength);

                Vector3 endPosition = transform.position + (currentSmoothForward * targetLength);

                //Handle the hitmarker
                hitPointMarker.transform.position = endPosition;
                hitPointMarker.transform.forward = data.pointerCurrentRaycast.worldNormal;

                if(lastHit.collider) {
                    endPosition = lastHit.point;
                    hitPointMarker.transform.forward = lastHit.collider.transform.forward;
                    hitPointMarker.transform.position = endPosition + hitPointMarker.transform.forward * 0.002f;
                }

                //Handle the line renderer
                for(int i = 0; i < lineSegements; i++) {
                    lineRenderer.SetPosition(i, Vector3.Lerp(transform.position, endPosition, i/ lineSegements));
                }
            }



        }

        protected virtual RaycastHit CreateRaycast(float dist){
            RaycastHit hit;
            Ray ray = new Ray(transform.position, currentSmoothForward);
            Physics.Raycast(ray, out hit, dist, UILayer);

            return hit;
        }

        protected virtual void ShowRay(bool show) {
            if(hitPointMarker != null)
                hitPointMarker.SetActive(show);
            if(lineRenderer != null)
                lineRenderer.enabled = show;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/HandCanvasPointer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/MagneticBody.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eacc0ab70f0b8b64b9bbcbbac3d66d1e
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using UnityEngine;

[ HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/magnetic-forces")]
public class MagneticBody : MonoBehaviour
{
    public Rigidbody body;
    public int magneticIndex = 0;
    public float strengthMultiplyer = 1f;
    public UnityMagneticEvent magneticEnter;
    public UnityMagneticEvent magneticExit;

    private void Start() {
        if(body == null)
            body = GetComponent<Rigidbody>();
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/MagneticBody.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/MagneticSource.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0e00af7538f45324194b5c1361e5c854
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand {
    public enum MagnetEffect {
        Attractive,
        Repulsive
    }

    [Serializable]
    public class UnityMagneticEvent : UnityEvent<MagneticSource, MagneticBody> { }

    [Serializable]
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/magnetic-forces")]
    public class MagneticSource : MonoBehaviour {
        public Rigidbody body;
        public MagnetEffect magneticEffect;
        public float strength = 10f;
        public float radius = 4f;
        public ForceMode forceMode = ForceMode.Force;
        public AnimationCurve forceDistanceCurce = AnimationCurve.Linear(0, 0, 1, 1);
        public int magneticIndex = 0;
        public UnityMagneticEvent magneticEnter;
        public UnityMagneticEvent magneticExit;

        List<MagneticBody> magneticBodies = new List<MagneticBody>();
        float radiusScale;
        private void Start() {
            if(body == null)
                body = GetComponent<Rigidbody>();
            radiusScale = transform.lossyScale.x < transform.lossyScale.y ? transform.lossyScale.x : transform.lossyScale.y;
            radiusScale = radiusScale < transform.lossyScale.z ? radiusScale : transform.lossyScale.z;
        }

        private void FixedUpdate() {
            foreach(var magneticBody in magneticBodies) {
                var position = transform.position;
                var otherPosition = magneticBody.transform.position;
                var distance = Vector3.Distance(position, otherPosition);
                if(distance < radius * radiusScale) {
                    var distanceValue = distance / (radius * radiusScale + 0.0001f);
                    var distanceMulti = forceDistanceCurce.Evaluate(distanceValue) * magneticBody.strengthMultiplyer * strength;
                    distanceMulti *= magneticEffect == MagnetEffect.Repulsive ? -1 : 1;
                    magneticBody.body.AddForce((position - otherPosition).normalized * distanceMulti, forceMode);
                }
            }
        }

        private void OnTriggerEnter(Collider other) {
            if(other.attachedRigidbody != null && other.CanGetComponent<MagneticBody>(out var magnetBody)) {
                if(!magneticBodies.Contains(magnetBody) && magnetBody.magneticIndex == magneticIndex) {
                    magneticBodies.Add(magnetBody);
                    magneticEnter?.Invoke(this, magnetBody);
                    magnetBody.magneticEnter?.Invoke(this, magnetBody);
                }

            }
        }

        private void OnTriggerExit(Collider other) {
            if(other.attachedRigidbody != null && other.CanGetComponent<MagneticBody>(out var magnetBody)) {
                if(magneticBodies.Contains(magnetBody)) {
                    magneticBodies.Remove(magnetBody);
                    magneticExit?.Invoke(this, magnetBody);
                    magnetBody.magneticExit?.Invoke(this, magnetBody);
                }
            }
        }


        private void OnDrawGizmosSelected() {
            Gizmos.color = Color.blue;
            var radiusScale = transform.lossyScale.x < transform.lossyScale.y ? transform.lossyScale.x : transform.lossyScale.y;
            radiusScale = radiusScale < transform.lossyScale.z ? radiusScale : transform.lossyScale.z;
            Gizmos.DrawWireSphere(transform.position, radius * radiusScale);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/MagneticSource.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/PhysicsFollower.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b6ef29e56e28a9341a4a527879bc24ae
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    [RequireComponent(typeof(Rigidbody)), DefaultExecutionOrder(-1)]
    public class PhysicsFollower : MonoBehaviour{
        [Header("Follow Settings"), Space]
        [Tooltip("Follow target, the hand will always try to match this transforms rotation and position with rigidbody movements")]
        public Transform follow;

        [Tooltip("Stops hand physics follow - to freeze from all forces change rigidbody to kinematic or change rigidbody constraints")]
        public bool freezePos = false;

        [Tooltip("Stops hand physics follow - to freeze from all forces change rigidbody to kinematic or change rigidbody constraints")]
        public bool freezeRot = false;
        
        [Tooltip("This will offset the position without offsetting the rotation pivot")]
        public Vector3 followPositionOffset;
        public Vector3 rotationOffset;

        [Tooltip("Follow target speed (This will cause jittering if turned too high)"), Min(0)]
        public float followPositionStrength = 30;

        [Tooltip("Follow target rotation speed (This will cause jittering if turned too high)"), Min(0)]
        public float followRotationStrength = 30;

        [Tooltip("The maximum allowed velocity of the hand"), Min(0)]
        public float maxVelocity = 5;
        
        
        internal Rigidbody body;
        Transform moveTo;
        
        public void Start() {
            Set();
        }

        public virtual void Set() {
            if(moveTo == null){
                moveTo = new GameObject().transform;
                moveTo.name = gameObject.name + " FOLLOW POINT";
                moveTo.parent = follow.parent;
                moveTo.position = follow.transform.position;
                moveTo.rotation = follow.transform.rotation;
                body = GetComponent<Rigidbody>();
            }
        }
        
        public void Update() {
            OnUpdate();
        }

        protected virtual void OnUpdate() {
            if(follow == null)
                return;

            //Sets [Move To] Object
            moveTo.position = follow.position + transform.rotation*followPositionOffset;
            moveTo.rotation = follow.rotation * Quaternion.Euler(rotationOffset);
        }


        public void FixedUpdate() {
            OnFixedUpdate();
        }

        protected virtual void OnFixedUpdate() {
            if(follow == null)
                return;
            
            //Sets [Move To] Object
            moveTo.position = follow.position + transform.rotation*followPositionOffset;
            moveTo.rotation = follow.rotation * Quaternion.Euler(rotationOffset);

            //Calls physics movements
            if(!freezePos) MoveTo();
            if(!freezeRot) TorqueTo();

        }


        /// <summary>Moves the hand to the controller position using physics movement</summary>
        internal virtual void MoveTo() {
            if(followPositionStrength <= 0)
                return;

            var movePos = moveTo.position;
            var distance = Vector3.Distance(movePos, transform.position);
            var velocityClamp = maxVelocity;
            
            
            //Sets velocity linearly based on distance from hand
            var vel = (movePos - transform.position).normalized * followPositionStrength * distance;
            vel.x = Mathf.Clamp(vel.x, -velocityClamp, velocityClamp);
            vel.y = Mathf.Clamp(vel.y, -velocityClamp, velocityClamp);
            vel.z = Mathf.Clamp(vel.z, -velocityClamp, velocityClamp);
            body.linearVelocity = vel;
        }


        /// <summary>Rotates the hand to the controller rotation using physics movement</summary>
        internal virtual void TorqueTo() {
            var toRot = moveTo.rotation;
            float angleDist = Quaternion.Angle(body.rotation, toRot);
            Quaternion desiredRotation = Quaternion.Lerp(body.rotation, toRot, Mathf.Clamp(angleDist, 0, 2) / 4f);

            var kp = 90f * followRotationStrength;
            var kd = 60f;
            Vector3 x;
            float xMag;
            Quaternion q = desiredRotation * Quaternion.Inverse(transform.rotation);
            q.ToAngleAxis(out xMag, out x);
            x.Normalize();
            x *= Mathf.Deg2Rad;
            Vector3 pidv = kp * x * xMag - kd * body.angularVelocity;
            Quaternion rotInertia2World = body.inertiaTensorRotation * transform.rotation;
            pidv = Quaternion.Inverse(rotInertia2World) * pidv;
            pidv.Scale(body.inertiaTensor);
            pidv = rotInertia2World * pidv;
            body.AddTorque(pidv);
        }

        private void OnDestroy() {
            Destroy(moveTo.gameObject);
        }
    }

  
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/PhysicsFollower.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Smash.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 07d975bb4661eb244a698f2a75d13fe3
# ASMDEF: AutoHandAssembly.dll
# ---
using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand.Demo{
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/smashing")]
    public class Smash : MonoBehaviour{
        [Header("Smash Options")]
        [Tooltip("Required velocity magnitude from Smasher to smash")]
        public float smashForce = 1;
        [Tooltip("Whether or not to destroy this object on smash")]
        public bool destroyOnSmash = false;
        [Tooltip("Whether or not to release this object on smash")]
        [HideIf("destroyOnSmash")]
        public bool releaseOnSmash = false;

        [Header("Particle Effect")]
        [Tooltip("Plays this effect on smash")]
        public ParticleSystem effect;
        [Tooltip("Whether or not to instantiates a new a particle system on smash")]
        public bool createNewEffect = true;
        [Tooltip("Whether or not to apply rigidbody velocity to particle velocity on smash")]
        public bool applyVelocityOnSmash = true;
        
        [Header("Sound Options")]
        public AudioClip smashSound;
        public float smashVolume = 1f;
        

        [Header("Event")]
        public UnityEvent OnSmash;
        
        //Progammer Events <3
        public SmashEvent OnSmashEvent;


        internal Grabbable grabbable;

        public void Start() {
            if(!(grabbable = GetComponent<Grabbable>())){
                GrabbableChild grabChild;
                if(grabChild = GetComponent<GrabbableChild>())
                    grabbable = grabChild.grabParent;
            }

            OnSmashEvent += (smasher, smashable) => { OnSmash?.Invoke(); };
        }


        public void DelayedSmash(float delay) {
            Invoke("DoSmash", delay);
        }


        public void DoSmash() {
            DoSmash(null);
        }


        public void DoSmash(Smasher smash){
            if(effect){
                ParticleSystem particles;
                if(createNewEffect)
                    particles = Instantiate(effect, grabbable.transform.position, grabbable.transform.rotation);
                else
                    particles = effect;

                particles.transform.parent = null;
                particles.Play();

                Rigidbody rb;
                if(applyVelocityOnSmash && ((rb = grabbable.body) || gameObject.CanGetComponent(out rb))){
                    ParticleSystem.VelocityOverLifetimeModule module = particles.velocityOverLifetime;
                    module.x = rb.linearVelocity.x;
                    module.y = rb.linearVelocity.y;
                    module.z = rb.linearVelocity.z;
                }
            }

            //Play the audio sound
            if(smashSound)
                AudioSource.PlayClipAtPoint(smashSound, transform.position, smashVolume);

            OnSmashEvent?.Invoke(smash, this);

            if((destroyOnSmash || releaseOnSmash) && grabbable)
                grabbable.ForceHandsRelease();

            if(destroyOnSmash)
                Destroy(gameObject);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Smash.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Smasher.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fad2f22fe18c2bf46b033941144afa2e
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using UnityEngine.Events;

namespace Autohand.Demo{
    public delegate void SmashEvent(Smasher smasher, Smash smashable);

    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/smashing")]
    public class Smasher : MonoBehaviour{
        public Rigidbody rb;
        [Header("Options")]
        public LayerMask smashableLayers;
        [Tooltip("How much to multiply the magnitude on smash")]
        public float forceMulti = 1;
        [Tooltip("Can be left empty - The center of mass point to calculate velocity magnitude - for example: the camera of the hammer is a better point vs the pivot center of the hammer object")]
        public Transform centerOfMassPoint;

        [Header("Event")]
        public UnityEvent OnSmash;

        //Progammer Events <3
        public SmashEvent OnSmashEvent;

        Vector3[] velocityOverTime = new Vector3[3];
        Vector3 lastPos;
    
        private void Start(){
            if(rb == null)
                rb = GetComponent<Rigidbody>();
            if(smashableLayers == 0)
                smashableLayers = LayerMask.GetMask(Hand.grabbableLayerNameDefault);

            OnSmashEvent += (smasher, smashable) => { OnSmash?.Invoke(); };
        }


        void FixedUpdate() {
            for(int i = 1; i < velocityOverTime.Length; i++) {
                velocityOverTime[i] = velocityOverTime[i-1];
            }
            velocityOverTime[0] = lastPos - (centerOfMassPoint ? centerOfMassPoint.position : rb.position);

            lastPos = centerOfMassPoint ? centerOfMassPoint.position : rb.position;
        }


        private void OnCollisionEnter(Collision collision) {
            Smash smash;
            if(collision.transform.CanGetComponent(out smash)){
                if(GetMagnitude() >= smash.smashForce){
                    smash.DoSmash();
                    OnSmashEvent?.Invoke(this, smash);
                }
            }
        }


        float GetMagnitude() {
            Vector3 velocity = Vector3.zero;
            for(int i = 0; i < velocityOverTime.Length; i++) {
                velocity += velocityOverTime[i];
            }

            return (velocity.magnitude/velocityOverTime.Length)*forceMulti*10;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Smasher.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stabbable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3049614f012dedc469207bf41aa8944c
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/stabbing")]
    public class Stabbable : MonoBehaviour{
        public Rigidbody body;
        public Grabbable grabbable;

        [Tooltip("The index that must match the stabbers index to allow stabbing")]
        public int stabIndex = 0;
        public int maxStabbers = 1;
        public float positionDamper = 1000;
        public float rotationDamper = 1000;
        public bool parentOnStab = true;

        [Header("Events")]
        public UnityEvent StartStab;
        public UnityEvent EndStab;
        
        //Progammer Events <3
        public StabEvent StartStabEvent;
        public StabEvent EndStabEvent;

        public List<Stabber> currentStabbers { get; private set; }
        public int currentStabs { get; private set; }

        Transform prereleaseParent;

        private void OnEnable() {
            currentStabbers = new List<Stabber>();
            if(!body && GetComponent<Rigidbody>())
                body = GetComponent<Rigidbody>();

            if(grabbable == null) {
                body.gameObject.HasGrabbable(out grabbable);
            }
        }

        public virtual void OnStab(Stabber stabber) {
            currentStabs++;
            currentStabbers.Add(stabber);

            if(parentOnStab && grabbable != null && stabber.grabbable != null) {
                grabbable.AddJointedBody(stabber.grabbable.body);
                for(int i = 0; i < stabber.stabbed.Count; i++) {
                    if(stabber.stabbed[i] != this) {
                        var stabbable = stabber.stabbed[i];
                        if(stabbable != this && stabbable.grabbable != null && stabbable.parentOnStab && stabbable.grabbable.parentOnGrab) {
                            if(grabbable.parentOnGrab)
                                grabbable.AddJointedBody(stabbable.grabbable.body);
                            stabbable.grabbable.AddJointedBody(grabbable.body);
                        }
                    }
                }
            }



            StartStab?.Invoke();
            StartStabEvent?.Invoke(stabber, this);
        }

        public virtual void OnEndStab(Stabber stabber) {
            currentStabs--;
            currentStabbers.Remove(stabber);
            if(parentOnStab && grabbable && stabber.grabbable) {
                grabbable.RemoveJointedBody(stabber.grabbable.body);

                for(int i = 0; i < stabber.stabbed.Count; i++) {
                    if(stabber.stabbed[i] != this) {
                        var stabbable = stabber.stabbed[i];
                        if(stabbable != this && stabbable.grabbable != null && stabbable.parentOnStab && stabbable.grabbable.parentOnGrab) {
                            grabbable.RemoveJointedBody(stabbable.grabbable.body);
                            stabbable.grabbable.RemoveJointedBody(grabbable.body);
                        }
                    }
                }
            }

            EndStab?.Invoke();
            EndStabEvent?.Invoke(stabber, this);
        }

        public virtual bool CanStab(Stabber stabber) {
            return currentStabs < maxStabbers && stabber.stabIndex == stabIndex;
        }

        public int StabbedCount() {
            return currentStabbers.Count;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stabbable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stabber.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 80a6c4b11bee64943899872d86aad925
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand {
    public delegate void StabEvent(Stabber stabber, Stabbable stab);

    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/stabbing")]
    public class Stabber : MonoBehaviour {
        [Tooltip("Can be left empty/null")]
        public Grabbable grabbable;
        [Header("Stab Settings")]
        public CapsuleCollider stabCapsule;
        [Tooltip("If left empty, will default to grabbable layers")]
        public LayerMask stabbableLayers;
        [Tooltip("The index that must match the stabbables index to allow stabbing")]
        public int stabIndex;
        public int maxStabs = 3;


        [Header("Joint Settings")]
        public Vector3 axis;
        public float limit = float.MaxValue;
        public ConfigurableJointMotion xMotion;
        public ConfigurableJointMotion yMotion;
        public ConfigurableJointMotion zMotion;
        public ConfigurableJointMotion angularXMotion;
        public ConfigurableJointMotion angularYMotion;
        public ConfigurableJointMotion angularZMotion;
        [Space]
        public float positionDampeningMultiplyer = 1;
        public float rotationDampeningMultiplyer = 1;

        [Header("Events")]
        public UnityEvent StartStab;
        public UnityEvent EndStab;

        //Progammer Events <3
        public StabEvent StartStabEvent;
        public StabEvent EndStabEvent;

        public List<Stabbable> stabbed { get; private set; }
        public List<ConfigurableJoint> stabbedJoints { get; private set; }



        /// <summary>Helps prevent stabbable from being triggered accidently from the wrong angle</summary>
        Dictionary<Stabbable, int> stabbedFrames;
        const int STABFRAMES = 2;
        int frames;

        Vector3 startPos;
        Quaternion startRot;

        Vector3 lastPos;
        Quaternion lastRot;
        Collider[] resultsNonAlloc;

        Transform prereleaseParent;

        void Start() {
            stabbedFrames = new Dictionary<Stabbable, int>();
            stabbed = new List<Stabbable>();
            stabbedJoints = new List<ConfigurableJoint>();
            resultsNonAlloc = new Collider[25];
            if(stabbableLayers == 0)
                stabbableLayers = LayerMask.GetMask(Hand.grabbableLayers);

            if(grabbable == null)
                gameObject.HasGrabbable(out grabbable);

            startPos = transform.position;
            startRot = transform.rotation;

            StartCoroutine(StartWait());
        }

        //This will keep the stabbables in place for the start stab
        IEnumerator StartWait() {
            for(int i = 0; i < STABFRAMES; i++) {
                transform.position = startPos;
                transform.rotation = startRot;
                yield return new WaitForFixedUpdate();
            }
        }

        private void FixedUpdate() {
            if(transform.position != lastPos || lastRot != transform.rotation) {
                frames = 0;
                lastPos = transform.position;
                lastRot = transform.rotation;
            }
            if(frames < STABFRAMES) {
                CheckStabArea();
                frames++;
            }
        }

        protected virtual void CheckStabArea() {
            Vector3 point1;
            Vector3 point2;
            Vector3 capsuleAxis;
            var height = stabCapsule.height;
            var radius = stabCapsule.radius;

            if(stabCapsule.direction == 0) {
                capsuleAxis = Vector3.right;
                height *= stabCapsule.transform.lossyScale.x;
                radius *= stabCapsule.transform.lossyScale.y > stabCapsule.transform.lossyScale.z ? stabCapsule.transform.lossyScale.y : stabCapsule.transform.lossyScale.z;
            }
            else if(stabCapsule.direction == 1) {
                capsuleAxis = Vector3.up;
                height *= stabCapsule.transform.lossyScale.y;
                radius *= stabCapsule.transform.lossyScale.z > stabCapsule.transform.lossyScale.x ? stabCapsule.transform.lossyScale.z : stabCapsule.transform.lossyScale.x;
            }
            else {
                capsuleAxis = Vector3.forward;
                height *= stabCapsule.transform.lossyScale.z;
                radius *= stabCapsule.transform.lossyScale.y > stabCapsule.transform.lossyScale.x ? stabCapsule.transform.lossyScale.y : stabCapsule.transform.lossyScale.x;
            }

            if(height / 2 <= radius) {
                height = 0;
            }
            else {
                height /= 2;
                height -= radius;
            }

            point1 = stabCapsule.bounds.center + stabCapsule.transform.rotation * capsuleAxis * (height);
            point2 = stabCapsule.bounds.center - stabCapsule.transform.rotation * capsuleAxis * (height);
            Physics.OverlapCapsuleNonAlloc(point1, point2, radius, resultsNonAlloc, stabbableLayers, QueryTriggerInteraction.Ignore);

            List<Stabbable> newStabbed = new List<Stabbable>();

            for(int i = 0; i < resultsNonAlloc.Length; i++) {
                Stabbable tempStab;
                if(resultsNonAlloc[i] != null) {
                    if(resultsNonAlloc[i].CanGetComponent(out tempStab))
                        if(tempStab.gameObject != gameObject)
                            newStabbed.Add(tempStab);
                }
            }

            for(int i = stabbed.Count - 1; i >= 0; i--)
                if(!newStabbed.Contains(stabbed[i]))
                    OnStabbableExit(stabbed[i]);

            if(stabbed.Count < maxStabs)
                for(int i = 0; i < newStabbed.Count; i++)
                    if(!stabbed.Contains(newStabbed[i]) && newStabbed[i].CanStab(this))
                        OnStabbableEnter(newStabbed[i]);

            for(int i = 0; i < resultsNonAlloc.Length; i++)
                resultsNonAlloc[i] = null;

            if(stabbedFrames.Count > 0) {
                var stabFrameKeys = new Stabbable[stabbedFrames.Count];
                stabbedFrames.Keys.CopyTo(stabFrameKeys, 0);
                foreach(var stabFrame in stabFrameKeys)
                    if(!stabbed.Contains(stabFrame) && !newStabbed.Contains(stabFrame))
                        stabbedFrames.Remove(stabFrame);
            }

            newStabbed.Clear();
        }

        protected virtual void OnStabbableEnter(Stabbable stab) {
            if(stabbedFrames.ContainsKey(stab))
                stabbedFrames[stab]++;
            else
                stabbedFrames.Add(stab, 1);

            if(stabbedFrames[stab] < STABFRAMES)
                return;

            stabbed.Add(stab);
            var joint = gameObject.AddComponent<ConfigurableJoint>();
            joint.secondaryAxis = axis;
            joint.connectedBody = stab.body;
            joint.xMotion = xMotion;
            joint.yMotion = yMotion;
            joint.zMotion = zMotion;
            joint.angularXMotion = angularXMotion;
            joint.angularYMotion = angularYMotion;
            joint.angularZMotion = angularZMotion;

            joint.linearLimit = new SoftJointLimit() { limit = this.limit };
            joint.linearLimitSpring = new SoftJointLimitSpring() { damper = stab.positionDamper * positionDampeningMultiplyer };
            joint.xDrive = new JointDrive() { positionDamper = stab.positionDamper * positionDampeningMultiplyer, maximumForce = float.MaxValue };
            joint.yDrive = new JointDrive() { positionDamper = stab.positionDamper * positionDampeningMultiplyer, maximumForce = float.MaxValue };
            joint.zDrive = new JointDrive() { positionDamper = stab.positionDamper * positionDampeningMultiplyer, maximumForce = float.MaxValue };
            joint.slerpDrive = new JointDrive() { positionDamper = stab.positionDamper * positionDampeningMultiplyer };

            joint.angularXLimitSpring = new SoftJointLimitSpring() { damper = stab.rotationDamper * rotationDampeningMultiplyer };
            joint.angularYZLimitSpring = new SoftJointLimitSpring() { damper = stab.rotationDamper * rotationDampeningMultiplyer };
            joint.angularXDrive = new JointDrive() { positionDamper = stab.rotationDamper * rotationDampeningMultiplyer, maximumForce = float.MaxValue };
            joint.angularYZDrive = new JointDrive() { positionDamper = stab.rotationDamper * rotationDampeningMultiplyer, maximumForce = float.MaxValue };
            joint.projectionDistance /= 4f;

            joint.enablePreprocessing = true;
            joint.enableCollision = false;

            Rigidbody jointBody;
            joint.CanGetComponent(out jointBody);

            //resets the joint / wakes the body
            jointBody.detectCollisions = false;
            jointBody.detectCollisions = true;
            stab.body.WakeUp();
            jointBody.WakeUp();

            if(stab.parentOnStab && grabbable) {
                grabbable.AddJointedBody(stab.body);
            }
            stabbedJoints.Add(joint);
            stab.OnStab(this);
            StartStabEvent?.Invoke(this, stab);
            StartStab?.Invoke();
        }

        protected virtual void OnStabbableExit(Stabbable stab) {
            var removeIndex = stabbed.IndexOf(stab);
            stabbed.Remove(stab);
            var joint = stabbedJoints[removeIndex];
            stabbedJoints.RemoveAt(removeIndex);
            Destroy(joint);
            if(stab.parentOnStab && grabbable) {
                grabbable.RemoveJointedBody(stab.body);
            }
            stab.OnEndStab(this);
            stabbedFrames.Remove(stab);
            EndStabEvent?.Invoke(this, stab);
            EndStab?.Invoke();
        }

        public List<Stabbable> GetStabbed() {
            return stabbed;
        }

        public int GetStabbedCount() {
            return stabbed.Count;
        }



        void OnDrawGizmosSelected() {
            Vector3 point1;
            Vector3 point2;
            Vector3 capsuleAxis;
            var height = stabCapsule.height;
            var radius = stabCapsule.radius;

            if(stabCapsule.direction == 0) {
                capsuleAxis = Vector3.right;
                height *= stabCapsule.transform.lossyScale.x;
                radius *= stabCapsule.transform.lossyScale.y > stabCapsule.transform.lossyScale.z ? stabCapsule.transform.lossyScale.y : stabCapsule.transform.lossyScale.z;
            }
            else if(stabCapsule.direction == 1) {
                capsuleAxis = Vector3.up;
                height *= stabCapsule.transform.lossyScale.y;
                radius *= stabCapsule.transform.lossyScale.z > stabCapsule.transform.lossyScale.x ? stabCapsule.transform.lossyScale.z : stabCapsule.transform.lossyScale.x;
            }
            else {
                capsuleAxis = Vector3.forward;
                height *= stabCapsule.transform.lossyScale.z;
                radius *= stabCapsule.transform.lossyScale.y > stabCapsule.transform.lossyScale.x ? stabCapsule.transform.lossyScale.y : stabCapsule.transform.lossyScale.x;
            }

            if(height / 2 <= radius) {
                height = 0;
            }
            else {
                height /= 2;
                height -= radius;
            }

            point1 = stabCapsule.bounds.center + stabCapsule.transform.rotation * capsuleAxis * (height);
            point2 = stabCapsule.bounds.center - stabCapsule.transform.rotation * capsuleAxis * (height);

            Gizmos.color = Color.blue;
            Gizmos.DrawSphere(point1, radius);
            Gizmos.DrawSphere(point2, radius);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stabber.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stickable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1e708524a006c484cbc36797af2c5b26
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand {
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/stickies")]
    public class Stickable : MonoBehaviour{
        [Header("Sticky Settings")]
        public Rigidbody body;
        [Tooltip("How strong the joint is between the stickable and this")]
        public float stickStrength = 1;
        [Tooltip("Multiplyer for required stick speed to activate")]
        public float stickSpeedMultiplyer = 1;
        [Tooltip("This index must match the sticky object to stick")]
        public int stickIndex = 0;


        [Header("Event")]
        public UnityEvent OnStick;
        public UnityEvent EndStick;

        Sticky stickSource;

        private void OnDrawGizmosSelected() {
            if(!body && GetComponent<Rigidbody>())
                body = GetComponent<Rigidbody>();
        }

        public void Stick(Sticky source) {
            stickSource = source;
            OnStick?.Invoke();
        }

        public void ForceReleaseStick() {
            stickSource?.ForceRelease(this);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stickable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Sticky.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 23e243e37b2899946b61644691f83e22
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    public class Sticky : MonoBehaviour{
        [Header("Sticky Settings")]
        public Rigidbody body;
        [Tooltip("How strong the joint is between the stickable and this")]
        public float stickStrength = 1;
        [Tooltip("Multiplyer for required stick speed to activate")]
        public float requiredStickSpeed = 1;
        [Tooltip("This index must match the stickable object to stick")]
        public int stickIndex = 0;

        [Header("Event")]
        public UnityEvent OnStick;

        List<Stickable> stickers;
        List<Joint> joints;

        private void Start() {
            if(body == null)
                body = GetComponent<Rigidbody>();
            stickers = new List<Stickable>();
            joints = new List<Joint>();
        }

        void OnCollisionEnter(Collision collision) {
            Stickable stick;
            if(collision.gameObject.CanGetComponent(out stick)) {
                CreateStick(stick);
            }   
        }

        void CreateStick(Stickable sticker) {
            if(stickers.Contains(sticker) || sticker.stickIndex != stickIndex)
                return;
            if(sticker.body.linearVelocity.sqrMagnitude*sticker.stickSpeedMultiplyer < requiredStickSpeed)
                return;

            var joint = gameObject.AddComponent<FixedJoint>();
            joint.connectedBody = sticker.body;
            joint.breakForce = 1000*stickStrength*sticker.stickStrength;
            joint.breakTorque = 1000*stickStrength*sticker.stickStrength;
                
            joint.connectedMassScale = 1;
            joint.massScale = 1;
            joint.enableCollision = false;
            joint.enablePreprocessing = true;

            sticker.Stick(this);
            OnStick?.Invoke();

            joints.Add(joint);
            stickers.Add(sticker);
        }

        public void ForceRelease(Stickable stuck) {
            var jointIndex = stickers.IndexOf(stuck);
            if(jointIndex == -1)
                return;

            if(!joints[jointIndex]) {
                joints.RemoveAt(jointIndex);
                stickers[jointIndex].EndStick?.Invoke();
                stickers.RemoveAt(jointIndex);
            }
            Destroy(joints[jointIndex]);
        }

        void OnJointBreak(float breakForce) {
            StartCoroutine(JointBreak());
        }

        IEnumerator JointBreak() {
            yield return new WaitForFixedUpdate();
            for(int i = joints.Count-1; i >= 0; i--) {
                if(!joints[i]) {
                    joints.RemoveAt(i);

                    stickers[i].EndStick?.Invoke();
                    stickers.RemoveAt(i);
                }
            }
        }
    
        private void OnDrawGizmosSelected() {
            if(!body && GetComponent<Rigidbody>())
                body = GetComponent<Rigidbody>();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Sticky.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/BlankUser.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 740f49ddb7ee0984b83bd6ab7514b564
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;

namespace Dreamteck.Splines
{
    //This is a blank SplineUser-derived class which you can use to build your custom SplineUser
    //You can safely delete any functions that you won't use
    //DO NOT ADD Update, LateUpdate or FixedUpdate, use Run, it is automatically called through one of these methods
    public class BlankUser : SplineUser
    {
        protected override void Awake()
        {
            base.Awake();
            //Awake is also called in the editor
        }

        void Start()
        {
            //Write initialization code here
        }

        protected override void LateRun()
        {
            base.LateRun();
            //Code to run every Update/FixedUpdate/LateUpdate
        }

        protected override void Build()
        {
            base.Build();
            //Build is called after the spline has been sampled. 
            //Use it for calculations (example: generate mesh geometry, calculate object positions)
        }

        protected override void PostBuild()
        {
            base.PostBuild();
            //Called on the main thread after Build has finished
            //Use it to apply the calculations from Build to GameObjects, Transforms, Meshes, etc.
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/BlankUser.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/BoxColliderGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1ca405288a4bb374aa05101b41667f31
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;

    public class BoxColliderGenerator : SplineUser, ISerializationCallbackReceiver
    {
        [SerializeField] private Vector2 _boxSize = Vector2.one;
        [SerializeField] private bool _debugDraw = false;
        [SerializeField] private Color _debugDrawColor = Color.white;


        [SerializeField]
        [HideInInspector]
        public ColliderObject[] _colliders = new ColliderObject[0];


        public Vector2 boxSize
        {
            get { return _boxSize; }
            set
            {
                if (value != _boxSize)
                {
                    _boxSize = value;
                    Rebuild();
                }
            }
        }

        private void DestroyCollider(ColliderObject collider)
        {
#if UNITY_EDITOR
            if (Application.isPlaying)
            {
                Destroy(collider.transform.gameObject);
            }
            else
            {
                DestroyImmediate(collider.transform.gameObject);
            }
#else
            Destroy(collider.transform.gameObject);
#endif
        }

        protected override void Build()
        {
            base.Build();

            if (sampleCount == 0)
            {
                for (int i = 0; i < _colliders.Length; i++)
                {
                    DestroyCollider(_colliders[i]);
                }
                _colliders = new ColliderObject[0];
                return;
            }

            int objectCount = sampleCount - 1;
            if (objectCount != _colliders.Length)
            {
                ColliderObject[] newColliders = new ColliderObject[objectCount];
                for (int i = 0; i < newColliders.Length; i++)
                {
                    if (i < _colliders.Length)
                    {
                        newColliders[i] = _colliders[i];
                    }
                    else
                    {
                        GameObject newObject = new GameObject("Collider " + i);
                        newObject.layer = gameObject.layer;
                        newObject.transform.parent = trs;
                        newColliders[i] = new ColliderObject(newObject.transform, newObject.AddComponent<BoxCollider>());
                    }
                }
                if (newColliders.Length < _colliders.Length)
                {
                    for (int i = newColliders.Length; i < _colliders.Length; i++)
                    {
                        DestroyCollider(_colliders[i]);
                    }
                }
                _colliders = newColliders;
            }

            SplineSample current = new SplineSample();
            SplineSample next = new SplineSample();
            Evaluate(0.0, ref current);

            for (int i = 0; i < objectCount; i++)
            {
                double nextPercent = (double)(i + 1) / (sampleCount - 1);
                Evaluate(nextPercent, ref next);
                _colliders[i].transform.position = Vector3.Lerp(current.position, next.position, 0.5f);
                _colliders[i].transform.rotation = Quaternion.LookRotation(next.position - current.position, Vector3.Slerp(current.up, next.up, 0.5f));
                float size = Mathf.Lerp(current.size, next.size, 0.5f);
                _colliders[i].collider.size = new Vector3(_boxSize.x * size, _boxSize.y * size, Vector3.Distance(current.position, next.position));
                current = next;
            }
        }

        public override void OnBeforeSerialize()
        {
            base.OnBeforeSerialize();
            Build();
        }

        private void OnDrawGizmos()
        {
            if (_debugDraw)
            {
                for (int i = 0; i < _colliders.Length; i++)
                {
                    Gizmos.matrix = _colliders[i].transform.localToWorldMatrix;
                    Gizmos.color = _debugDrawColor;
                    Gizmos.DrawCube(Vector3.zero, _colliders[i].collider.size);
                }
                Gizmos.matrix = Matrix4x4.identity;
            }
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            for (int i = 0; i < _colliders.Length; i++)
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                {
                    DestroyImmediate(_colliders[i].transform.gameObject);
                } else
                {
                    Destroy(_colliders[i].transform.gameObject);
                }
#else
                Destroy(_colliders[i].transform.gameObject);
#endif
            }
        }

        [System.Serializable]
        public class ColliderObject
        {
            public Transform transform;
            public BoxCollider collider;

            public ColliderObject(Transform transform, BoxCollider collider)
            {
                this.transform = transform;
                this.collider = collider;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/BoxColliderGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/CapsuleColliderGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 56dd191f9d7c9cd4d9c21559487036d6
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;

    public class CapsuleColliderGenerator : SplineUser, ISerializationCallbackReceiver
    {
        [SerializeField, HideInInspector, Min(0f)] private float _radius = 1f;
        [SerializeField, HideInInspector, Min(0f)] private float _height = 1f;
        [SerializeField, HideInInspector] private bool _overlapCaps = true;
        [SerializeField, HideInInspector] private CapsuleColliderZDirection _direction = CapsuleColliderZDirection.Z;
        [SerializeField, HideInInspector] private ColliderObject[] _colliders = new ColliderObject[0];

        public float radius
        {
            get { return _radius; }
            set
            {
                if (value != _radius)
                {
                    _radius = value;
                    Rebuild();
                }
            }
        }

        public float height
        {
            get { return _height; }
            set
            {
                if (value != _height)
                {
                    _height = value;
                    Rebuild();
                }
            }
        }

        public bool overlapCaps
        {
            get { return _overlapCaps; }
            set
            {
                if (value != _overlapCaps)
                {
                    _overlapCaps = value;
                    Rebuild();
                }
            }
        }

        public CapsuleColliderZDirection direction
        {
            get { return _direction; }
            set
            {
                if (value != _direction)
                {
                    _direction = value;
                    Rebuild();
                }
            }
        }

        private void DestroyCollider(ColliderObject collider)
        {
#if UNITY_EDITOR
            if (Application.isPlaying)
            {
                Destroy(collider.transform.gameObject);
            }
            else
            {
                DestroyImmediate(collider.transform.gameObject);
            }
#else
            Destroy(collider.transform.gameObject);
#endif
        }

        protected override void Build()
        {
            base.Build();

            if (sampleCount == 0)
            {
                for (int i = 0; i < _colliders.Length; i++)
                {
                    DestroyCollider(_colliders[i]);
                }
                _colliders = new ColliderObject[0];
                return;
            }

            int objectCount = sampleCount - 1;
            if (objectCount != _colliders.Length)
            {
                GenerateColliders(objectCount);
            }

            SplineSample current = new SplineSample();
            SplineSample next = new SplineSample();
            Evaluate(0.0, ref current);

            bool controlHeight = _direction == CapsuleColliderZDirection.Z;

            for (int i = 0; i < objectCount; i++)
            {
                double nextPercent = (double)(i + 1) / (sampleCount - 1);
                Evaluate(nextPercent, ref next);
                _colliders[i].transform.position = Vector3.Lerp(current.position, next.position, 0.5f);
                _colliders[i].transform.rotation = Quaternion.LookRotation(next.position - current.position, Vector3.Slerp(current.up, next.up, 0.5f));
                
                _colliders[i].collider.radius = _radius;
                _colliders[i].collider.direction = (int)_direction;

                var distance = Vector3.Distance(current.position, next.position);

                if (controlHeight)
                {
                    if (_overlapCaps)
                    {
                        _colliders[i].collider.height = distance + _radius * 2f;
                    } else
                    {
                        _colliders[i].collider.height = distance;
                    }
                    _colliders[i].collider.radius = _radius;
                }
                else
                {
                    _colliders[i].collider.height = _height;
                    _colliders[i].collider.radius = distance * 0.5f;
                }

                current = next;
            }
        }

        private void GenerateColliders(int count)
        {
            ColliderObject[] newColliders = new ColliderObject[count];
            for (int i = 0; i < newColliders.Length; i++)
            {
                if (i < _colliders.Length)
                {
                    newColliders[i] = _colliders[i];
                }
                else
                {
                    GameObject newObject = new GameObject("Collider " + i);
                    newObject.layer = gameObject.layer;
                    newObject.transform.parent = trs;
                    newColliders[i] = new ColliderObject(newObject.transform, newObject.AddComponent<CapsuleCollider>(), _direction, _height);
                }
            }
            if (newColliders.Length < _colliders.Length)
            {
                for (int i = newColliders.Length; i < _colliders.Length; i++)
                {
                    DestroyCollider(_colliders[i]);
                }
            }
            _colliders = newColliders;
        }

        public override void OnBeforeSerialize()
        {
            base.OnBeforeSerialize();
            Build();
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            for (int i = 0; i < _colliders.Length; i++)
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                {
                    DestroyImmediate(_colliders[i].transform.gameObject);
                }
                else
                {
                    Destroy(_colliders[i].transform.gameObject);
                }
#else
                Destroy(_colliders[i].transform.gameObject);
#endif
            }
        }

        [System.Serializable]
        public class ColliderObject
        {
            public Transform transform;
            public CapsuleCollider collider;

            public ColliderObject(Transform transform, CapsuleCollider collider, CapsuleColliderZDirection direction, float height)
            {
                this.transform = transform;
                this.collider = collider;
                this.collider.direction = (int)direction;
                this.collider.height = height;
            }
        }

        public enum CapsuleColliderZDirection
        {
            X = 0, Y = 1, Z = 2,
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/CapsuleColliderGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ComplexSurfaceGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 23c67ca6f2dc03d45be9d985a114a897
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;

    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Dreamteck/Splines/Complex Surface Generator")]
    public class ComplexSurfaceGenerator : MeshGenerator
    {
        public enum UVWrapMode { Clamp, UniformX, UniformY, Uniform }
        public enum SubdivisionMode { CatmullRom, BSpline, Linear }
        public UVWrapMode uvWrapMode
        {
            get { return _uvWrapMode; }
            set
            {
                if (value != _uvWrapMode)
                {
                    _uvWrapMode = value;
                    Rebuild();
                }
            }
        }

        public int subdivisions
        {
            get { return _subdivisions; }
            set
            {
                if (value != _subdivisions)
                {
                    _subdivisions = value;
                    Rebuild();
                }
            }
        }

        public SubdivisionMode subdivisionMode
        {
            get { return _subdivisionMode; }
            set
            {
                if (value != _subdivisionMode)
                {
                    _subdivisionMode = value;
                    Rebuild();
                }
            }
        }

        public bool automaticNormals
        {
            get { return _automaticNormals; }
            set
            {
                if (value != _automaticNormals)
                {
                    _automaticNormals = value;
                    Rebuild();
                }
            }
        }

        public bool separateMaterialIDs
        {
            get { return _separateMaterialIDs; }
            set
            {
                if (value != _separateMaterialIDs)
                {
                    _separateMaterialIDs = value;
                    Rebuild();
                }
            }
        }


        public SplineComputer[] otherComputers
        {
            get { return _otherComputers; }
            set
            {
                bool rebuild = false;
                if (value.Length != _otherComputers.Length)
                {
                    rebuild = true;
                    for (int i = 0; i < _otherComputers.Length; i++)
                    {
                        if (_otherComputers[i] != null)
                        {
                            _otherComputers[i].Unsubscribe(this);
                        }
                    }
                }
                else
                {
                    for (int i = 0; i < value.Length; i++)
                    {
                        if (_otherComputers[i] != null)
                        {
                            _otherComputers[i].Unsubscribe(this);
                        }
                        if (value[i] != _otherComputers[i])
                        {
                            rebuild = true;
                            break;
                        }
                    }
                }
                if (rebuild)
                {
                    _otherComputers = value;
                    for (int i = 0; i < _otherComputers.Length; i++)
                    {
                        if (_otherComputers[i] != null)
                        {
                            if (_otherComputers[i].subscriberCount == 0)
                            {
                                _otherComputers[i].name = "Surface Spline " + (i + 1);
                            }
                            _otherComputers[i].Subscribe(this);
                        }
                    }
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private UVWrapMode _uvWrapMode = UVWrapMode.Clamp;
        [SerializeField, HideInInspector, Min(1)]
        private int _subdivisions = 3;
        [SerializeField, HideInInspector]
        private SubdivisionMode _subdivisionMode;
        [SerializeField]
        [HideInInspector]
        private bool _automaticNormals = true;
        [SerializeField]
        [HideInInspector]
        private bool _separateMaterialIDs = false;
        [SerializeField]
        [HideInInspector]
        private SplineComputer[] _otherComputers = new SplineComputer[0];
        [SerializeField]
        [HideInInspector]
        private Spline[] _splines = new Spline[0];
        [SerializeField]
        [HideInInspector]
        private bool _initializedInEditor = false;

        private int iterations => _subdivisions * _otherComputers.Length;

        protected override void Awake()
        {
            base.Awake();

            _mesh.name = "multispline_surface";
            for (int i = 0; i < _otherComputers.Length; i++)
            {
                _otherComputers[i].onRebuild -= OnOtherRebuild;
                _otherComputers[i].onRebuild += OnOtherRebuild;
            }
        }

        void OnOtherRebuild()
        {
            RebuildImmediate();
        }

        protected override void Reset()
        {
            base.Reset();
        }

        private Spline.Type ModeToSplineType(SubdivisionMode mode)
        {
            switch (mode)
            {
                case SubdivisionMode.BSpline: return Spline.Type.BSpline; 
                case SubdivisionMode.Linear: return Spline.Type.Linear;
                default: return Spline.Type.CatmullRom;
            }
        }


        protected override void BuildMesh()
        {
            if (sampleCount == 0 || _otherComputers.Length == 0)
            {
                AllocateMesh(0, 0);
                return;
            }

            if (_splines.Length != sampleCount)
            {
                _splines = new Spline[sampleCount];
                for (int i = 0; i < _splines.Length; i++)
                {
                    _splines[i] = new Spline(ModeToSplineType(_subdivisionMode));
                }
            } else
            {
                for (int i = 0; i < _splines.Length; i++)
                {
                    _splines[i].type = ModeToSplineType(_subdivisionMode);
                }
            }

            base.BuildMesh();
            AllocateMesh(sampleCount * (iterations + 1), iterations * (sampleCount-1) * 6);
            _tsMesh.triangles = MeshUtility.GeneratePlaneTriangles(sampleCount - 1, iterations + 1, false);
            GenerateVertices();
            _tsMesh.subMeshes.Clear();

            if (_separateMaterialIDs)
            {
                for (int i = 0; i < _otherComputers.Length; i++)
                {
                    int[] newTris = MeshUtility.GeneratePlaneTriangles(sampleCount - 1, subdivisions + 1, false);
                    _tsMesh.subMeshes.Add(newTris);
                    for (int n = 0; n < _tsMesh.subMeshes[i].Length; n++)
                    {
                        _tsMesh.subMeshes[i][n] += i * (_subdivisions * sampleCount);
                    }
                }
            }
        }


        void GenerateVertices()
        {
            if (_otherComputers.Length == 0) return;

            ResetUVDistance();

            SplineSample sample = default;
            SplineSample sample2 = default;

            for (int i = 0; i < _otherComputers.Length + 1; i++)
            {
                SplineComputer splineComp = spline;
                if (i > 0)
                {
                    splineComp = _otherComputers[i - 1];
                }

                for (int j = 0; j < sampleCount; j++)
                {
                    if (_splines[j].points.Length != _otherComputers.Length + 1)
                    {
                        _splines[j].points = new SplinePoint[_otherComputers.Length + 1];
                    }
                    
                    double xPercent = DMath.Lerp(clipFrom, clipTo, (double)j / (sampleCount - 1));
                    if (i > 0)
                    {
                        splineComp.Evaluate(xPercent, ref sample);
                    }
                    else
                    {
                        GetSample(j, ref sample);
                    }

                    _splines[j].points[i].position = sample.position;
                    _splines[j].points[i].normal = sample.up;
                    _splines[j].points[i].color = sample.color;
                }
            }



            for (int x = 0; x < _splines.Length; x++)
            {
                if (uvMode == UVMode.UniformClamp || uvMode == UVMode.UniformClip)
                {
                    AddUVDistance(x);
                } else
                {
                    GetSample(x, ref sample2);
                }
                Vector3 lastPos = sample.position;
                float ydist = 0f;
                float xPercent = Mathf.Lerp((float)clipFrom, (float)clipTo, (float)x / (_splines.Length - 1));
                for (int y = 0; y < iterations + 1; y++)
                {
                    float yPercent = (float)y / iterations;
                    int index = x + y * _splines.Length;
                    _splines[x].Evaluate(yPercent, ref sample);
                    if (y > 0)
                    {
                        ydist += Vector3.Distance(lastPos, sample.position);
                    }
                    lastPos = sample.position;
                    if (uvMode == UVMode.UniformClamp )
                    {
                        __uvs.x = CalculateUVUniformClamp(_vDist);
                        __uvs.y = CalculateUVUniformClamp(ydist);
                    } else if(uvMode == UVMode.UniformClip)
                    {
                        __uvs.x = CalculateUVUniformClip(_vDist);
                        __uvs.y = CalculateUVUniformClip(ydist);
                    }
                    else
                    {
                        CalculateUVs(xPercent, yPercent);
                    }

                    _tsMesh.vertices[index] = sample.position;
                    _tsMesh.normals[index] = sample.up;
                    _tsMesh.colors[index] = sample.color;
                    _tsMesh.uv[index] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(uvRotation + 180f, Vector3.forward) * (Vector2.one * 0.5f - __uvs));
                }
            }
        }


        protected override void WriteMesh()
        {
            base.WriteMesh();
            if (_automaticNormals)
            {
                _mesh.RecalculateNormals();
            }
        }

        public static void DrawSpline(Spline spline, Color color, double from = 0.0, double to = 1.0)
        {
            double add = spline.moveStep;
            int iterations = spline.iterations;
            if (iterations <= 0) return;

            Vector3 prevPoint = spline.EvaluatePosition(from);
            for (int i = 1; i < iterations; i++)
            {
                double p = DMath.Lerp(from, to, (double)i / (iterations - 1));
                Debug.DrawLine(prevPoint, spline.EvaluatePosition(p), color, 1f);
                prevPoint = spline.EvaluatePosition(p);
            }
        }


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ComplexSurfaceGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/EdgeColliderGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d28d465ca9ef341488ba836962159676
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Threading;
namespace Dreamteck.Splines
{
    [AddComponentMenu("Dreamteck/Splines/Users/Edge Collider Generator")]
    [RequireComponent(typeof(EdgeCollider2D))]
    public class EdgeColliderGenerator : SplineUser
    {
        public float offset
        {
            get { return _offset; }
            set
            {
                if (value != _offset)
                {
                    _offset = value;
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private float _offset = 0f;
        [SerializeField]
        [HideInInspector]
        protected EdgeCollider2D edgeCollider;

        [SerializeField]
        [HideInInspector]
        protected Vector2[] vertices = new Vector2[0];

        [HideInInspector]
        public float updateRate = 0.1f;
        protected float lastUpdateTime = 0f;

        private bool updateCollider = false;

        protected override void Awake()
        {
            base.Awake();
            edgeCollider = GetComponent<EdgeCollider2D>();
        }


        protected override void Reset()
        {
            base.Reset();
        }

        protected override void OnEnable()
        {
            base.OnEnable();
        }

        protected override void OnDisable()
        {
            base.OnDisable();
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
        }

        protected override void LateRun()
        {
            base.LateRun();
            if (updateCollider)
            {
                if (edgeCollider != null)
                {
                    if (Time.time - lastUpdateTime >= updateRate)
                    {
                        lastUpdateTime = Time.time;
                        updateCollider = false;
                        edgeCollider.points = vertices;
                    }
                }
            }
        }

        protected override void Build()
        {
            base.Build();
            if (vertices.Length != sampleCount) vertices = new Vector2[sampleCount];
            bool hasOffset = offset != 0f;
            for (int i = 0; i < sampleCount; i++)
            {
                GetSample(i, ref evalResult);
                vertices[i] = evalResult.position;
                if (hasOffset)
                {
                    Vector2 right = new Vector2(-evalResult.forward.y, evalResult.forward.x).normalized * evalResult.size;
                    vertices[i] += right * offset;
                }
            }
        }

        protected override void PostBuild()
        {
            base.PostBuild();
            if (edgeCollider == null) return;
            for(int i = 0; i < vertices.Length; i++) vertices[i] = transform.InverseTransformPoint(vertices[i]);
            
#if UNITY_EDITOR
            if (!Application.isPlaying || updateRate <= 0f)
            {
                edgeCollider.points = vertices;
            } else updateCollider = true;
#else
            if(updateRate == 0f) edgeCollider.points = vertices;
            else updateCollider = true;
#endif
        }
    }

  
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/EdgeColliderGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ISampleModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6f878af9c27e51e4b9b42aee2e444837
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;

namespace Dreamteck.Splines
{
    public interface ISampleModifier
    {
        public void ApplySampleModifiers(ref SplineSample sample);

        public Vector3 GetModifiedSamplePosition(ref SplineSample sample);
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ISampleModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/LengthCalculator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 995701723b428a94c9305a2abf319ad6
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Reflection;
using UnityEngine.Events;

namespace Dreamteck.Splines
{
    [AddComponentMenu("Dreamteck/Splines/Users/Length Calculator")]
    public class LengthCalculator : SplineUser
    {
        [System.Serializable]
        public class LengthEvent
        {
            public bool enabled = true;
            public float targetLength = 0f;
            public UnityEvent onChange = new UnityEvent();
            public enum Type { Growing, Shrinking, Both}
            public Type type = Type.Both;

            public LengthEvent()
            {

            }

            public LengthEvent(Type t)
            {
                type = t;
            }

            public void Check(float fromLength, float toLength)
            {
                if (!enabled) return;
                bool condition = false;
                switch (type)
                {
                    case Type.Growing: condition = toLength >= targetLength && fromLength < targetLength; break;
                    case Type.Shrinking: condition = toLength <= targetLength && fromLength > targetLength; break;
                    case Type.Both: condition = toLength >= targetLength && fromLength < targetLength || toLength <= targetLength && fromLength > targetLength; break;
                }
                if (condition) onChange.Invoke();
            }
        }
        [HideInInspector]
        public LengthEvent[] lengthEvents = new LengthEvent[0];
        [HideInInspector]
        public float idealLength = 1f;
        private float _length = 0f;
        private float lastLength = 0f;
        public float length
        {
            get {
                return _length;
            }
        }

        protected override void Awake()
        {
            base.Awake();
            _length = CalculateLength();
            lastLength = _length;
            for (int i = 0; i < lengthEvents.Length; i++)
            {
                if (lengthEvents[i].targetLength == _length) lengthEvents[i].onChange.Invoke();
            }
        }

        protected override void Build()
        {
            base.Build();
            _length = CalculateLength();
            if (lastLength != _length)
            {
                for (int i = 0; i < lengthEvents.Length; i++)
                {
                    lengthEvents[i].Check(lastLength, _length);
                }
                lastLength = _length;
            }
        }

        public void AddEvent(LengthEvent lengthEvent)
        {
            LengthEvent[] newEvents = new LengthEvent[lengthEvents.Length + 1];
            lengthEvents.CopyTo(newEvents, 0);
            newEvents[newEvents.Length - 1] = lengthEvent;
            lengthEvents = newEvents;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/LengthCalculator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/MeshGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 49c9228d9868e1747b4763bc4cb1d86f
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Threading;
#if UNITY_EDITOR
using UnityEditor;
#endif 

namespace Dreamteck.Splines
{
    public class MeshGenerator : SplineUser
    {
        protected const int UNITY_16_VERTEX_LIMIT = 65535;

        public float size
        {
            get { return _size; }
            set
            {
                if (value != _size)
                {
                    _size = value;
                    Rebuild();
                } else _size = value;
            }
        }

        public Color color
        {
            get { return _color; }
            set
            {
                if (value != _color)
                {
                    _color = value;
                    Rebuild();
                }
            }
        }

        public Vector3 offset
        {
            get { return _offset; }
            set
            {
                if (value != _offset)
                {
                    _offset = value;
                    Rebuild();
                }
            }
        }

        public NormalMethod normalMethod
        {
            get { return _normalMethod; }
            set
            {
                if (value != _normalMethod)
                {
                    _normalMethod = value;
                    Rebuild();
                }
            }
        }

        public bool useSplineSize
        {
            get { return _useSplineSize; }
            set
            {
                if (value != _useSplineSize)
                {
                    _useSplineSize = value;
                    Rebuild();
                }
            }
        }

        public bool useSplineColor
        {
            get { return _useSplineColor; }
            set
            {
                if (value != _useSplineColor)
                {
                    _useSplineColor = value;
                    Rebuild();
                }
            }
        }

        public bool calculateTangents
        {
            get { return _calculateTangents; }
            set
            {
                if (value != _calculateTangents)
                {
                    _calculateTangents = value;
                    Rebuild();
                }
            }
        }

        public float rotation
        {
            get { return _rotation; }
            set
            {
                if (value != _rotation)
                {
                    _rotation = value;
                    Rebuild();
                }
            }
        }

        public bool flipFaces
        {
            get { return _flipFaces; }
            set
            {
                if (value != _flipFaces)
                {
                    _flipFaces = value;
                    Rebuild();
                }
            }
        }

        public bool doubleSided
        {
            get { return _doubleSided; }
            set
            {
                if (value != _doubleSided)
                {
                    _doubleSided = value;
                    Rebuild();
                }
            }
        }

        public UVMode uvMode
        {
            get { return _uvMode; }
            set
            {
                if (value != _uvMode)
                {
                    _uvMode = value;
                    Rebuild();
                }
            }
        }

        public Vector2 uvScale
        {
            get { return _uvScale; }
            set
            {
                if (value != _uvScale)
                {
                    _uvScale = value;
                    Rebuild();
                }
            }
        }

        public Vector2 uvOffset
        {
            get { return _uvOffset; }
            set
            {
                if (value != _uvOffset)
                {
                    _uvOffset = value;
                    Rebuild();
                }
            }
        }

        public float uvRotation
        {
            get { return _uvRotation; }
            set
            {
                if (value != _uvRotation)
                {
                    _uvRotation = value;
                    Rebuild();
                }
            }
        }

        public UnityEngine.Rendering.IndexFormat meshIndexFormat
        {
            get { return _meshIndexFormat; }
            set
            {
                if (value != _meshIndexFormat)
                {
                    _meshIndexFormat = value;
                    RefreshMesh();
                    Rebuild();
                }
            }
        }

        public bool baked
        {
            get
            {
                return _baked;
            }
        }

        public bool markDynamic
        {
            get { return _markDynamic; }
            set
            {
                if (value != _markDynamic)
                {
                    _markDynamic = value;
                    RefreshMesh();
                    Rebuild();
                }
            }
        }

        public enum UVMode { Clip, UniformClip, Clamp, UniformClamp }
        public enum NormalMethod { Recalculate, SplineNormals }
        [SerializeField]
        [HideInInspector]
        private bool _baked = false;
        [SerializeField]
        [HideInInspector]
        private bool _markDynamic = true;
        [SerializeField]
        [HideInInspector]
        private float _size = 1f;
        [SerializeField]
        [HideInInspector]
        private Color _color = Color.white;
        [SerializeField]
        [HideInInspector]
        private Vector3 _offset = Vector3.zero;
        [SerializeField]
        [HideInInspector]
        private NormalMethod _normalMethod = NormalMethod.SplineNormals;
        [SerializeField]
        [HideInInspector]
        private bool _calculateTangents = true;
        [SerializeField]
        [HideInInspector]
        private bool _useSplineSize = true;
        [SerializeField]
        [HideInInspector]
        private bool _useSplineColor = true;
        [SerializeField]
        [HideInInspector]
        [Range(-360f, 360f)]
        private float _rotation = 0f;
        [SerializeField]
        [HideInInspector]
        private bool _flipFaces = false;
        [SerializeField]
        [HideInInspector]
        private bool _doubleSided = false;
        [SerializeField]
        [HideInInspector]
        private UVMode _uvMode = UVMode.Clip;
        [SerializeField]
        [HideInInspector]
        private Vector2 _uvScale = Vector2.one;
        [SerializeField]
        [HideInInspector]
        private Vector2 _uvOffset = Vector2.zero;
        [SerializeField]
        [HideInInspector]
        private float _uvRotation = 0f;
        [SerializeField]
        [HideInInspector]
        private UnityEngine.Rendering.IndexFormat _meshIndexFormat = UnityEngine.Rendering.IndexFormat.UInt16;
        [SerializeField]
        [HideInInspector]
        private Mesh _bakedMesh;

        [HideInInspector]
        public float colliderUpdateRate = 0.2f;
        protected bool _updateCollider = false;
        protected float _lastUpdateTime = 0f;

        protected float _vDist = 0f;
        protected static Vector2 __uvs = Vector2.zero;

        protected virtual string meshName => "Mesh";
        protected TS_Mesh _tsMesh { get; private set; }
        protected Mesh _mesh;

        protected MeshFilter filter;
        protected MeshRenderer meshRenderer;
        protected MeshCollider meshCollider;

#if UNITY_EDITOR

        public void Bake(bool makeStatic, bool lightmapUV)
        {
            if (_mesh == null) return;
            gameObject.isStatic = false;
            UnityEditor.MeshUtility.Optimize(_mesh);
            if (spline != null)
            {
                spline.Unsubscribe(this);
            }
            filter = GetComponent<MeshFilter>();
            meshRenderer = GetComponent<MeshRenderer>();
            filter.hideFlags = meshRenderer.hideFlags = HideFlags.None;
            _bakedMesh = Instantiate(_mesh);
            _bakedMesh.name = meshName + " - Baked";
            if (lightmapUV)
            {
                Unwrapping.GenerateSecondaryUVSet(_bakedMesh);
            }
            filter.sharedMesh = _bakedMesh;
            _mesh = null;
            gameObject.isStatic = makeStatic; 
            _baked = true;
        }

        public void Unbake()
        {
            gameObject.isStatic = false; 
            _baked = false;
            DestroyImmediate(_bakedMesh);
            _bakedMesh = null;
            CreateMesh();
            spline.Subscribe(this);
            Rebuild();
        }

        public override void EditorAwake()
        {
            GetComponents();
            base.EditorAwake();
        }
#endif


        protected override void Awake()
        {
            GetComponents();
            base.Awake();
        }

        protected override void Reset()
        {
            base.Reset();
            GetComponents();
#if UNITY_EDITOR
            bool materialFound = false;
            for (int i = 0; i < meshRenderer.sharedMaterials.Length; i++)
            {
                if (meshRenderer.sharedMaterials[i] != null)
                {
                    materialFound = true;
                    break;
                }
            }
            if (!materialFound) meshRenderer.sharedMaterial = AssetDatabase.GetBuiltinExtraResource<Material>("Default-Diffuse.mat");
#endif
        }

        private void GetComponents()
        {
            filter = GetComponent<MeshFilter>();
            meshRenderer = GetComponent<MeshRenderer>();
            meshCollider = GetComponent<MeshCollider>();
        }

        public override void Rebuild()
        {
            if (_baked) return;
            base.Rebuild();
        }

        public override void RebuildImmediate()
        {
            if (_baked) return;
            base.RebuildImmediate();
        }

        protected override void OnEnable()
        {
            base.OnEnable();
        }

        protected override void OnDisable()
        {
            base.OnDisable();
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            MeshFilter filter = GetComponent<MeshFilter>();
            MeshRenderer rend = GetComponent<MeshRenderer>();
            if (filter != null)  filter.hideFlags = HideFlags.None;
            if (rend != null)  rend.hideFlags = HideFlags.None;
        }


        public void UpdateCollider()
        {
            meshCollider = GetComponent<MeshCollider>();
            if (meshCollider == null) meshCollider = gameObject.AddComponent<MeshCollider>();
            meshCollider.sharedMesh = filter.sharedMesh;
        }

        protected override void LateRun()
        {
            if (_baked) return;
            base.LateRun();
            if (_updateCollider)
            {
                if (meshCollider != null)
                {
                    if (Time.time - _lastUpdateTime >= colliderUpdateRate)
                    {
                        _lastUpdateTime = Time.time;
                        _updateCollider = false;
                        meshCollider.sharedMesh = filter.sharedMesh;
                    }
                }
            }
        }

        protected override void Build()
        {
            base.Build();
            if (_tsMesh == null || _mesh == null)
            {
                CreateMesh();
            }

            if (sampleCount > 1)
            {
                BuildMesh();
            } else
            {
                ClearMesh();
            }
        }

        protected override void PostBuild()
        {
            base.PostBuild();
            WriteMesh();
        }

        protected virtual void ClearMesh()
        {
            _tsMesh.Clear();
            _mesh.Clear();
        }

        protected virtual void BuildMesh()
        {
            //Logic for mesh generation, automatically called in the Build method
        }

        protected virtual void WriteMesh() 
        {
            MeshUtility.TransformMesh(_tsMesh, trs.worldToLocalMatrix);
            if (_doubleSided)
            {
                MeshUtility.MakeDoublesidedHalf(_tsMesh);
            }
            else if (_flipFaces)
            {
                MeshUtility.FlipFaces(_tsMesh);
            }

            if (_calculateTangents)
            {
                MeshUtility.CalculateTangents(_tsMesh);
            }

            if (_meshIndexFormat == UnityEngine.Rendering.IndexFormat.UInt16 && _tsMesh.vertexCount > UNITY_16_VERTEX_LIMIT)
            {
                Debug.LogError("WARNING: The generated mesh for " + name + " exceeds the maximum vertex count for standard meshes in Unity (" + UNITY_16_VERTEX_LIMIT + "). To create bigger meshes, set the Index Format inside the Vertices foldout to 32.");
            }

            _tsMesh.indexFormat = _meshIndexFormat;

            _tsMesh.WriteMesh(ref _mesh);

            if (_markDynamic)
            {
                _mesh.MarkDynamic();
            }

            if (_normalMethod == 0)
            {
                _mesh.RecalculateNormals();
            }

            if (filter != null)
            {
                filter.sharedMesh = _mesh;
            }
            _updateCollider = true;
        }

        protected virtual void AllocateMesh(int vertexCount, int trisCount)
        {
            if(trisCount < 0)
            {
                trisCount = 0;
            }
            if(vertexCount < 0)
            {
                vertexCount = 0;
            }
            if (_doubleSided)
            {
                vertexCount *= 2;
                trisCount *= 2;
            }
            if (_tsMesh.vertexCount != vertexCount)
            {
                _tsMesh.vertices = new Vector3[vertexCount];
                _tsMesh.normals = new Vector3[vertexCount];
                _tsMesh.tangents = new Vector4[vertexCount];
                _tsMesh.colors = new Color[vertexCount];
                _tsMesh.uv = new Vector2[vertexCount];
            }
            if (_tsMesh.triangles.Length != trisCount)
            {
                _tsMesh.triangles = new int[trisCount];
            }
        }

        protected void ResetUVDistance()
        {
            _vDist = 0f;
            if (uvMode == UVMode.UniformClip)
            {
                _vDist = spline.CalculateLength(0.0, GetSamplePercent(0));
            }
        }

        protected void AddUVDistance(int sampleIndex)
        {
            if (sampleIndex == 0) return;
            SplineSample current = new SplineSample();
            SplineSample last = new SplineSample();
            GetSampleRaw(sampleIndex, ref current);
            GetSampleRaw(sampleIndex - 1, ref last);
            _vDist += Vector3.Distance(current.position, last.position);
        }

        protected void CalculateUVs(double percent, float u)
        {
            __uvs.x = u * _uvScale.x - _uvOffset.x;
            switch (uvMode)
            {
                case UVMode.Clip:  __uvs.y = CalculateUVClip(percent); break;
                case UVMode.Clamp: __uvs.y = CalculateUVClamp(percent);  break;
                case UVMode.UniformClamp: __uvs.y = CalculateUVUniformClamp(_vDist); break;
                default: __uvs.y = CalculateUVUniformClip(_vDist); break;
            }
        }

        protected float CalculateUVUniformClamp(float distance)
        {
            return distance * _uvScale.y / (float)span - _uvOffset.y;
        }

        protected float CalculateUVUniformClip(float distance)
        {
            return distance * _uvScale.y - _uvOffset.y;
        }

        protected float CalculateUVClip(double percent)
        {
            return (float)percent * _uvScale.y - _uvOffset.y;
        }

        protected float CalculateUVClamp(double percent)
        {
            return (float)DMath.InverseLerp(clipFrom, clipTo, percent) * _uvScale.y - _uvOffset.y;
        }

        protected float GetBaseSize(SplineSample sample)
        {
            return _useSplineSize? sample.size: 1f;
        }

        protected Color GetBaseColor(SplineSample sample)
        {
            return _useSplineColor ? sample.color : Color.white;
        }

        protected virtual void CreateMesh()
        {
            _tsMesh = new TS_Mesh();
            _mesh = new Mesh();
            _mesh.name = meshName;
            _mesh.indexFormat = _meshIndexFormat;
            _tsMesh.indexFormat = _meshIndexFormat;
            if (_markDynamic)
            {
                _mesh.MarkDynamic();
            }
        }

        private void RefreshMesh()
        {
            if (!Application.isPlaying)
            {
                DestroyImmediate(_mesh);
            } 
            else
            {
                Destroy(_mesh);
            }
            _mesh = null;
            _tsMesh.Clear();
            _tsMesh = null;
            CreateMesh();
        }
    }

  
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/MeshGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Node.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a212c074803b6824cae48ffa7abb84cf
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;

namespace Dreamteck.Splines
{
    [ExecuteInEditMode]
    [AddComponentMenu("Dreamteck/Splines/Node Connector")]
    public class Node : MonoBehaviour
    {
        [System.Serializable]
        public class Connection
        {
            public SplineComputer spline
            {
                get { return _computer; }
            }

            public int pointIndex
            {
                get { return _pointIndex; }
            }

            public bool invertTangents = false;

            [SerializeField]
            private int _pointIndex = 0;
            [SerializeField]
            private SplineComputer _computer = null;
            [SerializeField]
            [HideInInspector]
            internal SplinePoint point;

            internal bool isValid
            {
                get
                {
                    if (_computer == null) return false;
                    if (_pointIndex >= _computer.pointCount) return false;
                    return true;
                }
            }

            internal Connection(SplineComputer comp, int index, SplinePoint inputPoint)
            {
                _pointIndex = index;
                _computer = comp;
                point = inputPoint;
            }
        }
        public enum Type { Smooth, Free }
        [HideInInspector]
        public Type type = Type.Smooth;

        public bool transformNormals
        {
            get { return _transformNormals; }
            set
            {
                if (value != _transformNormals)
                {
                    _transformNormals = value;
                    UpdatePoints();
                }
            }
        }

        public bool transformSize
        {
            get { return _transformSize; }
            set
            {
                if (value != _transformSize)
                {
                    _transformSize = value;
                    UpdatePoints();
                }
            }
        }

        public bool transformTangents
        {
            get { return _transformTangents; }
            set
            {
                if (value != _transformTangents)
                {
                    _transformTangents = value;
                    UpdatePoints();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        protected Connection[] connections = new Connection[0];
        [SerializeField]
        [HideInInspector]
        private bool _transformSize = true;
        [SerializeField]
        [HideInInspector]
        private bool _transformNormals = true;
        [SerializeField]
        [HideInInspector]
        private bool _transformTangents = true;

        private Vector3 _lastPosition, _lastScale;
        private Quaternion _lastRotation;
        private Transform _trs;

        private void Awake()
        {
            _trs = transform;
            SampleTransform();
        }


        void LateUpdate()
        {
            Run();
        }

        void Update()
        {
            Run();
        }

        bool TransformChanged()
        {
#if UNITY_EDITOR
            if(_trs == null) return _lastPosition != transform.position || _lastRotation != transform.rotation || _lastScale != transform.lossyScale;
#endif
            return _lastPosition != _trs.position || _lastRotation != _trs.rotation || _lastScale != _trs.lossyScale;
        }

        void SampleTransform() {
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                _lastPosition = transform.position;
                _lastScale = transform.lossyScale;
                _lastRotation = transform.rotation;
            } 
            else
            {
                _lastPosition = _trs.position;
                _lastScale = _trs.lossyScale;
                _lastRotation = _trs.rotation;
            }
            return;
#else
            _lastPosition = _trs.position;
            _lastScale = _trs.lossyScale;
            _lastRotation = _trs.rotation;
#endif
        }

        private void Run()
        {
            if (TransformChanged())
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                {
                    UnityEditor.EditorUtility.SetDirty(this);
                    for (int i = 0; i < connections.Length; i++)
                    {
                        UnityEditor.EditorUtility.SetDirty(connections[i].spline);
                    }
                }
#endif
                UpdateConnectedComputers();
                SampleTransform();
            }
        }

        public SplinePoint GetPoint(int connectionIndex, bool swapTangents)
        {
            SplinePoint point = PointToWorld(connections[connectionIndex].point);
            if (connections[connectionIndex].invertTangents && swapTangents)
            {
                Vector3 tempTan = point.tangent;
                point.tangent = point.tangent2;
                point.tangent2 = tempTan;
            }
            return point;
        }

        public void SetPoint(int connectionIndex, SplinePoint worldPoint, bool swappedTangents)
        {
            Connection connection = connections[connectionIndex];
            connection.point = PointToLocal(worldPoint);
            if (connection.invertTangents && swappedTangents)
            {
                Vector3 tempTan = connection.point.tangent;
                connection.point.tangent = connection.point.tangent2;
                connection.point.tangent2 = tempTan;
            }
            if (type == Type.Smooth)
            {
                if (connection.point.type == SplinePoint.Type.SmoothFree)
                {
                    for (int i = 0; i < connections.Length; i++)
                    {
                        if (i == connectionIndex) continue;
                        Vector3 tanDir = (connection.point.tangent - connection.point.position).normalized;
                        if (tanDir == Vector3.zero) tanDir = -(connection.point.tangent2 - connection.point.position).normalized;
                        float tan1Length = (connections[i].point.tangent - connections[i].point.position).magnitude;
                        float tan2Length = (connections[i].point.tangent2 - connections[i].point.position).magnitude;
                        connections[i].point = connection.point;
                        connections[i].point.tangent = connections[i].point.position + tanDir * tan1Length;
                        connections[i].point.tangent2 = connections[i].point.position - tanDir * tan2Length;
                    }
                }
                else
                {
                    for (int i = 0; i < connections.Length; i++)
                    {
                        if (i == connectionIndex) continue;
                        connections[i].point = connection.point;
                    }
                }
            }
        }

        void OnDestroy()
        {
            ClearConnections();
        }

        public void ClearConnections()
        {
            for (int i = connections.Length-1; i >= 0; i--)
            {
                if (connections[i].spline != null) connections[i].spline.DisconnectNode(connections[i].pointIndex);
            }
            connections = new Connection[0];
        }

        public void UpdateConnectedComputers(SplineComputer excludeComputer = null)
        {
            for (int i = connections.Length - 1; i >= 0; i--)
            {
                if (!connections[i].isValid)
                {
                    RemoveConnection(i);
                    continue;
                }

                if (connections[i].spline == excludeComputer) continue;

                if (type == Type.Smooth && i != 0)
                {
                    SetPoint(i, GetPoint(0, false), false);
                }
                SplinePoint point = GetPoint(i, true);
                if (!transformNormals)
                {
                    point.normal = connections[i].spline.GetPointNormal(connections[i].pointIndex);
                }
                if (!transformTangents)
                {
                    point.tangent = connections[i].spline.GetPointTangent(connections[i].pointIndex);
                    point.tangent2 = connections[i].spline.GetPointTangent2(connections[i].pointIndex);
                }
                if (!transformSize)
                {
                    point.size = connections[i].spline.GetPointSize(connections[i].pointIndex);
                }
                connections[i].spline.SetPoint(connections[i].pointIndex, point);
            }
        }

        public void UpdatePoint(SplineComputer computer, int pointIndex, SplinePoint point, bool updatePosition = true)
        {
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                transform.position = point.position;
            }
            else
            {
                _trs.position = point.position;
            }
#else
            _trs.position = point.position;
#endif
            for (int i = 0; i < connections.Length; i++)
            {
                if (connections[i].spline == computer && connections[i].pointIndex == pointIndex)
                {
                    SetPoint(i, point, true);
                }
            }
        }

        public void UpdatePoints()
        {
            for (int i = connections.Length - 1; i >= 0; i--)
            {
                if (!connections[i].isValid)
                {
                    RemoveConnection(i);
                    continue;
                }
                SplinePoint point = connections[i].spline.GetPoint(connections[i].pointIndex);
                point.SetPosition(transform.position);
                SetPoint(i, point, true);
            }
        }

#if UNITY_EDITOR
        //Use this to maintain the connections between computers in the editor
        public void EditorMaintainConnections()
        {
            RemoveInvalidConnections();
        }
#endif
        //Remove invalid connections
        protected void RemoveInvalidConnections()
        {
            for (int i = connections.Length - 1; i >= 0; i--)
            {
                if (connections[i] == null || !connections[i].isValid) RemoveConnection(i);
            }
        }

        public virtual void AddConnection(SplineComputer computer, int pointIndex)
        {
            RemoveInvalidConnections();
            Node connected = computer.GetNode(pointIndex);
            if (connected != null)
            {
                Debug.LogError(computer.name + " is already connected to node " + connected.name + " at point " + pointIndex);
                return;
            }
            SplinePoint point = computer.GetPoint(pointIndex);
            point.SetPosition(transform.position);
            ArrayUtility.Add(ref connections, new Connection(computer, pointIndex, PointToLocal(point)));
            if(connections.Length == 1) SetPoint(connections.Length - 1, point, true);
            UpdateConnectedComputers();
        }

        protected SplinePoint PointToLocal(SplinePoint worldPoint)
        {
            worldPoint.position = Vector3.zero;
            worldPoint.tangent = transform.InverseTransformPoint(worldPoint.tangent);
            worldPoint.tangent2 = transform.InverseTransformPoint(worldPoint.tangent2);
            worldPoint.normal = transform.InverseTransformDirection(worldPoint.normal);
            worldPoint.size /= (transform.localScale.x + transform.localScale.y + transform.localScale.z)/ 3f;
            return worldPoint;
        }

        protected SplinePoint PointToWorld(SplinePoint localPoint)
        {
            localPoint.position = transform.position;
            localPoint.tangent = transform.TransformPoint(localPoint.tangent);
            localPoint.tangent2 = transform.TransformPoint(localPoint.tangent2);
            localPoint.normal = transform.TransformDirection(localPoint.normal);
            localPoint.size *= (transform.localScale.x + transform.localScale.y + transform.localScale.z) / 3f;
            return localPoint;
        }

        public virtual void RemoveConnection(SplineComputer computer, int pointIndex)
        {
            int index = -1;
            for (int i = 0; i < connections.Length; i++)
            {
                if (connections[i].pointIndex == pointIndex && connections[i].spline == computer)
                {
                    index = i;
                    break;
                }
            }
            if (index < 0) return;
            RemoveConnection(index);
        }

        private void RemoveConnection(int index)
        {
            Connection[] newConnections = new Connection[connections.Length - 1];
            SplineComputer spline = connections[index].spline;
            int pointIndex = connections[index].pointIndex;
            for (int i = 0; i < connections.Length; i++)
            {
                if (i < index) newConnections[i] = connections[i];
                else if (i == index) continue;
                else newConnections[i - 1] = connections[i];
            }
            connections = newConnections;
        }

        public virtual bool HasConnection(SplineComputer computer, int pointIndex)
        {
            for (int i = connections.Length - 1; i >= 0; i--)
            {
                if (!connections[i].isValid)
                {
                    RemoveConnection(i);
                    continue;
                }
                if (connections[i].spline == computer && connections[i].pointIndex == pointIndex) return true;
            }
            return false;
        }

        public Connection[] GetConnections()
        {
            return connections;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Node.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectBender.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f64d070be79692d449ab6f792ee7fb57
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System.Collections;
using System.Collections.Generic;
using System.Threading;

namespace Dreamteck.Splines
{
    [AddComponentMenu("Dreamteck/Splines/Users/Object Bender")]
    public class ObjectBender : SplineUser
    {
        public enum Axis { X, Y, Z }
        public enum NormalMode { Spline, Auto, Custom }
        public enum ForwardMode { Spline, Custom }
        public bool bend
        {
            get { return _bend; }
            set
            {
               if(_bend != value)
                {
                    _bend = value;
                    if (value)
                    {
                        UpdateReferences();
                        Rebuild();
                    } else Revert();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private bool _bend = false;
        public Axis axis
        {
            get { return _axis; }
            set
            {
                if (spline != null && value != _axis)
                {
                    _axis = value;
                    UpdateReferences();
                    Rebuild();
                }
                else _axis = value;
            }
        }

        public NormalMode upMode
        {
            get { return _normalMode; }
            set
            {
                if (spline != null && value != _normalMode)
                {
                    _normalMode = value;
                    Rebuild();
                } else _normalMode = value;
            }
        }

        public Vector3 customNormal
        {
            get { return _customNormal; }
            set
            {
                if (spline != null && value != _customNormal)
                {
                    _customNormal = value;
                    Rebuild();
                }
                else _customNormal = value;
            }
        }

        public ForwardMode forwardMode
        {
            get { return _forwardMode; }
            set
            {
                if (spline != null && value != _forwardMode)
                {
                    _forwardMode = value;
                    Rebuild();
                } else _forwardMode = value;
            }
        }

        public Vector3 customForward
        {
            get { return _customForward; }
            set
            {
                if (spline != null && value != _customForward)
                {
                    _customForward = value;
                    Rebuild();
                }
                else _customForward = value;
            }
        }
        [HideInInspector]
        public BendProperty[] bendProperties = new BendProperty[0];
        [SerializeField]
        [HideInInspector]
        private bool _parentIsTheSpline = false;
        [SerializeField]
        [HideInInspector]
        private TS_Bounds bounds = null;

        [SerializeField]
        [HideInInspector]
        private Axis _axis = Axis.Z;
        [SerializeField]
        [HideInInspector]
        private NormalMode _normalMode = NormalMode.Auto;
        [SerializeField]
        [HideInInspector]
        private ForwardMode _forwardMode = ForwardMode.Spline;
        [SerializeField]
        [HideInInspector]
        [UnityEngine.Serialization.FormerlySerializedAs("_upVector")]
        private Vector3 _customNormal = Vector3.up;
        [SerializeField]
        [HideInInspector]
        private Vector3 _customForward = Vector3.forward;
        Matrix4x4 normalMatrix = new Matrix4x4();
        Quaternion bendRotation = Quaternion.identity;

        private void GetTransformsRecursively(Transform current, ref List<Transform> transformList)
        {
            transformList.Add(current);
            foreach (Transform child in current)
            {
                GetTransformsRecursively(child, ref transformList);
            }
        }

        private void GetObjects()
        {
            List<Transform> found = new List<Transform>();
            GetTransformsRecursively(transform, ref found);
            BendProperty[] newProperties = new BendProperty[found.Count];
            for (int i = 0; i < found.Count; i++)
            {
                CreateProperty(ref newProperties[i], found[i]);
            }
            bendProperties = newProperties;
            SplineComputer splineComponent = GetComponent<SplineComputer>();
            _parentIsTheSpline = splineComponent == spline;
        }

        public TS_Bounds GetBounds()
        {
            return new TS_Bounds(bounds.min, bounds.max, bounds.center);
        }

#if UNITY_EDITOR
        public void EditorGenerateLightmapUVs()
        {
            for (int i = 0; i < bendProperties.Length; i++)
            {
                if (bendProperties[i].bendMesh)
                {
                    if (bendProperties[i].filter == null) continue;
                    if (bendProperties[i].filter.sharedMesh == null) continue;
                    EditorUtility.DisplayProgressBar("Generating Lightmap UVS", bendProperties[i].filter.sharedMesh.name, (float)i / (bendProperties.Length - 1));
                    Unwrapping.GenerateSecondaryUVSet(bendProperties[i].filter.sharedMesh);
                }
            }
            EditorUtility.ClearProgressBar();
        }
#endif

        private void CreateProperty(ref BendProperty property, Transform t)
        {
            property = new BendProperty(t, t == transform); //Create a new bend property for each child
            for (int i = 0; i < bendProperties.Length; i++)
            {
                //Search for properties that have the same trasform and copy their settings
                if (bendProperties[i].transform.transform == t)
                {
                    property.enabled = bendProperties[i].enabled;
                    property.applyRotation = bendProperties[i].applyRotation;
                    property.applyScale = bendProperties[i].applyScale;
                    property.bendMesh = bendProperties[i].bendMesh;
                    property.bendCollider = bendProperties[i].bendCollider;
                    property.generateLightmapUVs = bendProperties[i].generateLightmapUVs;
                    property.colliderUpdateRate = bendProperties[i].colliderUpdateRate;
                    break;
                }
            }

            if (t.transform != trs)
            {
                property.originalPosition = trs.InverseTransformPoint(t.position);
                property.originalRotation = Quaternion.Inverse(trs.rotation) * t.rotation;
            }
        }

        private void CalculateBounds()
        {
            if (bounds == null) bounds = new TS_Bounds(Vector3.zero, Vector3.zero);
            bounds.min = bounds.max = Vector3.zero;
            for (int i = 0; i < bendProperties.Length; i++)
            {
                CalculatePropertyBounds(ref bendProperties[i]);
            }
            for (int i = 0; i < bendProperties.Length; i++)
            {
                CalculatePercents(bendProperties[i]);
            }
        }

        private void CalculatePropertyBounds(ref BendProperty property)
        {
            if (!property.enabled) return;
            if (property.isParent && _parentIsTheSpline) return;
            if (property.transform.transform == trs)
            {
                if (0f < bounds.min.x) bounds.min.x = 0f;
                if (0f < bounds.min.y) bounds.min.y = 0f;
                if (0f < bounds.min.z) bounds.min.z = 0f;
                if (0f > bounds.max.x) bounds.max.x = 0f;
                if (0f > bounds.max.y) bounds.max.y = 0f;
                if (0f > bounds.max.z) bounds.max.z = 0f;
            }
            else
            {
                if (property.originalPosition.x < bounds.min.x) bounds.min.x = property.originalPosition.x;
                if (property.originalPosition.y < bounds.min.y) bounds.min.y = property.originalPosition.y;
                if (property.originalPosition.z < bounds.min.z) bounds.min.z = property.originalPosition.z;
                if (property.originalPosition.x > bounds.max.x) bounds.max.x = property.originalPosition.x;
                if (property.originalPosition.y > bounds.max.y) bounds.max.y = property.originalPosition.y;
                if (property.originalPosition.z > bounds.max.z) bounds.max.z = property.originalPosition.z;
            }
            if (property.editMesh != null)
            {
                for (int n = 0; n < property.editMesh.vertices.Length; n++)
                {
                    Vector3 localPos = property.transform.TransformPoint(property.editMesh.vertices[n]);
                    localPos = trs.InverseTransformPoint(localPos);
                    if (localPos.x < bounds.min.x) bounds.min.x = localPos.x;
                    if (localPos.y < bounds.min.y) bounds.min.y = localPos.y;
                    if (localPos.z < bounds.min.z) bounds.min.z = localPos.z;
                    if (localPos.x > bounds.max.x) bounds.max.x = localPos.x;
                    if (localPos.y > bounds.max.y) bounds.max.y = localPos.y;
                    if (localPos.z > bounds.max.z) bounds.max.z = localPos.z;
                }
            }

            if (property.editColliderMesh != null)
            {
                for (int n = 0; n < property.editColliderMesh.vertices.Length; n++)
                {
                    Vector3 localPos = property.transform.TransformPoint(property.editColliderMesh.vertices[n]);
                    localPos = trs.InverseTransformPoint(localPos);
                    if (localPos.x < bounds.min.x) bounds.min.x = localPos.x;
                    if (localPos.y < bounds.min.y) bounds.min.y = localPos.y;
                    if (localPos.z < bounds.min.z) bounds.min.z = localPos.z;
                    if (localPos.x > bounds.max.x) bounds.max.x = localPos.x;
                    if (localPos.y > bounds.max.y) bounds.max.y = localPos.y;
                    if (localPos.z > bounds.max.z) bounds.max.z = localPos.z;
                }
            }

            if (property.originalSpline != null)
            {
                for (int n = 0; n < property.originalSpline.points.Length; n++)
                {
                    Vector3 localPos = trs.InverseTransformPoint(property.originalSpline.points[n].position);
                    if (localPos.x < bounds.min.x) bounds.min.x = localPos.x;
                    if (localPos.y < bounds.min.y) bounds.min.y = localPos.y;
                    if (localPos.z < bounds.min.z) bounds.min.z = localPos.z;
                    if (localPos.x > bounds.max.x) bounds.max.x = localPos.x;
                    if (localPos.y > bounds.max.y) bounds.max.y = localPos.y;
                    if (localPos.z > bounds.max.z) bounds.max.z = localPos.z;
                }
            }
            bounds.CreateFromMinMax(bounds.min, bounds.max);
        }

        public void CalculatePercents(BendProperty property)
        {
            if (property.transform.transform != trs) property.positionPercent = GetPercentage(trs.InverseTransformPoint(property.transform.position));
            else property.positionPercent = GetPercentage(Vector3.zero);
            if (property.editMesh != null)
            {
                if (property.vertexPercents.Length != property.editMesh.vertexCount) property.vertexPercents = new Vector3[property.editMesh.vertexCount];
                if (property.editColliderMesh != null)
                {
                    if (property.colliderVertexPercents.Length != property.editMesh.vertexCount) property.colliderVertexPercents = new Vector3[property.editColliderMesh.vertexCount];
                }
                for (int i = 0; i < property.editMesh.vertexCount; i++)
                {
                    Vector3 localVertex = property.transform.TransformPoint(property.editMesh.vertices[i]);
                    localVertex = trs.InverseTransformPoint(localVertex);
                    property.vertexPercents[i] = GetPercentage(localVertex);   
                }
                if (property.editColliderMesh != null)
                {
                    for (int i = 0; i < property.editColliderMesh.vertexCount; i++)
                    {
                        Vector3 localVertex = property.transform.TransformPoint(property.editColliderMesh.vertices[i]);
                        localVertex = trs.InverseTransformPoint(localVertex);
                        property.colliderVertexPercents[i] = GetPercentage(localVertex);
                    }
                }
            }
            if (property.splineComputer != null)
            {
                SplinePoint[] points = property.splineComputer.GetPoints();
                property.splinePointPercents = new Vector3[points.Length];
                property.primaryTangentPercents = new Vector3[points.Length];
                property.secondaryTangentPercents = new Vector3[points.Length];
                for (int i = 0; i < points.Length; i++)
                {
                    property.splinePointPercents[i] = GetPercentage(trs.InverseTransformPoint(points[i].position));
                    property.primaryTangentPercents[i] = GetPercentage(trs.InverseTransformPoint(points[i].tangent));
                    property.secondaryTangentPercents[i] = GetPercentage(trs.InverseTransformPoint(points[i].tangent2));
                }
            }
        }

        private void Revert()
        {
            for (int i = 0; i < bendProperties.Length; i++)
            {
                bendProperties[i].Revert();
            }
        }


        public void UpdateReferences()
        {
            if (!hasTransform)
            {
                CacheTransform();
            }
            if (_bend)
            {
                for (int i = 0; i < bendProperties.Length; i++) bendProperties[i].Revert();
            }
            GetObjects();
            CalculateBounds();
            if (_bend)
            {
                Bend();
                for (int i = 0; i < bendProperties.Length; i++)
                {
                    bendProperties[i].Apply(i > 0 || trs != spline.transform);
                    bendProperties[i].Update();
                }
            }
        }

        private void GetevalResult(Vector3 percentage)
        {
            switch (axis)
            {
                case Axis.X: Evaluate(percentage.x, ref evalResult); break;
                case Axis.Y: Evaluate(percentage.y, ref evalResult); break;
                case Axis.Z: Evaluate(percentage.z, ref evalResult); break;
            }
            switch (_normalMode)
            {
                case NormalMode.Auto: evalResult.up = Vector3.Cross(evalResult.forward, evalResult.right); break;
                case NormalMode.Custom: evalResult.up = _customNormal; break;
            }
            if (_forwardMode == ForwardMode.Custom) evalResult.forward = customForward;
            Vector3 right = evalResult.right;

            Quaternion axisRotation = Quaternion.identity;

            switch (axis)
            {
                case Axis.Z:
                    evalResult.position += right * Mathf.Lerp(bounds.min.x, bounds.max.x, percentage.x) * evalResult.size;
                    evalResult.position += evalResult.up * Mathf.Lerp(bounds.min.y, bounds.max.y, percentage.y) * evalResult.size;
                    break;
                case Axis.X:
                    axisRotation = Quaternion.Euler(0f, -90f, 0f);
                    evalResult.position += right * Mathf.Lerp(bounds.max.z, bounds.min.z, percentage.z) * evalResult.size;
                    evalResult.position += evalResult.up * Mathf.Lerp(bounds.min.y, bounds.max.y, percentage.y) * evalResult.size;
                    break;
                case Axis.Y:
                    axisRotation = Quaternion.Euler(90f, 0f, 0f);
                    evalResult.position += right * Mathf.Lerp(bounds.min.x, bounds.max.x, percentage.x) * evalResult.size;
                    evalResult.position += evalResult.up * Mathf.Lerp(bounds.min.z, bounds.max.z, percentage.z) * evalResult.size;
                    break;
            }

            bendRotation = evalResult.rotation * axisRotation;
            normalMatrix = Matrix4x4.TRS(evalResult.position, bendRotation, Vector3.one * evalResult.size).inverse.transpose;
        }

        private Vector3 GetPercentage(Vector3 point)
        {
            point.x = Mathf.InverseLerp(bounds.min.x, bounds.max.x, point.x);
            point.y = Mathf.InverseLerp(bounds.min.y, bounds.max.y, point.y);
            point.z = Mathf.InverseLerp(bounds.min.z, bounds.max.z, point.z);
            return point;
        }

        protected override void Build()
        {
            base.Build();
            if (_bend) Bend();
        }

        private void Bend()
        {
            if (sampleCount <= 1) return;
            if (bendProperties.Length == 0) return;
            for (int i = 0; i < bendProperties.Length; i++)
            {
                BendObject(bendProperties[i]);
            }
        }

        public void BendObject(BendProperty p)
        {
            if (!p.enabled) return;
            if (p.isParent && _parentIsTheSpline) return;
            GetevalResult(p.positionPercent);
            p.transform.position = evalResult.position;
            if (p.applyRotation)
            {
                //p.transform.rotation = evalResult.rotation * axisRotation * p.originalRotation;
                p.transform.rotation = bendRotation * (Quaternion.Inverse(p.parentRotation) * p.originalRotation);
            } else p.transform.rotation = p.originalRotation; 
            if (p.applyScale) p.transform.scale = p.originalScale * evalResult.size;

            Matrix4x4 toLocalMatrix = Matrix4x4.TRS(p.transform.position, p.transform.rotation, p.transform.scale).inverse;
            if (p.editMesh != null)
            {
                BendMesh(p.vertexPercents, p.normals, p.editMesh, toLocalMatrix);
                p.editMesh.hasUpdate = true;
            }

            if (p._editColliderMesh != null)
            {
                BendMesh(p.colliderVertexPercents, p.colliderNormals, p.editColliderMesh, toLocalMatrix);
                p.editColliderMesh.hasUpdate = true;
            }

            if (p.originalSpline != null && !p.isParent)
            {
                for (int n = 0; n < p.splinePointPercents.Length; n++)
                {
                    SplinePoint point = p.originalSpline.points[n];
                    GetevalResult(p.splinePointPercents[n]);
                    point.position = evalResult.position;
                    GetevalResult(p.primaryTangentPercents[n]);
                    point.tangent = evalResult.position;
                    GetevalResult(p.secondaryTangentPercents[n]);
                    point.tangent2 = evalResult.position;
                    switch (axis)
                    {
                        case Axis.X: point.normal = Quaternion.LookRotation(evalResult.forward, evalResult.up) * Quaternion.FromToRotation(Vector3.up, evalResult.up) * point.normal; break;
                        case Axis.Y: point.normal = Quaternion.LookRotation(evalResult.forward, evalResult.up) * Quaternion.FromToRotation(Vector3.up, evalResult.up) * point.normal; break;
                        case Axis.Z: point.normal = Quaternion.LookRotation(evalResult.forward, evalResult.up) * point.normal; break;
                    }
                    p.destinationSpline.points[n] = point;
                }
            }
        }

        void BendMesh(Vector3[] vertexPercents, Vector3[] originalNormals, TS_Mesh mesh, Matrix4x4 worldToLocalMatrix)
        {
            if(mesh.vertexCount != vertexPercents.Length)
            {
                Debug.LogError("Vertex count mismatch");
                return;
            }
            for (int i = 0; i < mesh.vertexCount; i++)
            {
                Vector3 percent = vertexPercents[i];
                if (axis == Axis.Y) percent.z = 1f - percent.z;
                GetevalResult(percent);
                mesh.vertices[i] = worldToLocalMatrix.MultiplyPoint3x4(evalResult.position);
                mesh.normals[i] = worldToLocalMatrix.MultiplyVector(normalMatrix.MultiplyVector(originalNormals[i]));
            }
        }

        protected override void PostBuild()
        {
            base.PostBuild();
            if (!_bend) return;
            for (int i = 0; i < bendProperties.Length; i++)
            {
                bendProperties[i].Apply(i > 0 || trs != spline.transform);
                bendProperties[i].Update();
            }
        }

        protected override void LateRun()
        {
            base.LateRun();
            for (int i = 0; i < bendProperties.Length; i++)
            {
                bendProperties[i].Update();
            }
        }


        [System.Serializable]
        public class BendProperty
        {
            public bool enabled = true;
            public bool isValid
            {
                get
                {
                    return transform != null && transform.transform != null;
                }
            }
            public TS_Transform transform;
            public bool applyRotation = true;
            public bool applyScale = true;
            public bool bendMesh
            {
                get { return _bendMesh; }
                set
                {
                    if (value != _bendMesh)
                    {
                        _bendMesh = value;
                        if (value)
                        {
                            if (filter != null && filter.sharedMesh != null)
                            {
                                normals = originalMesh.normals;
                                for (int i = 0; i < normals.Length; i++) normals[i] = transform.transform.TransformDirection(normals[i]);
                            }
                        } else RevertMesh();
                    }
                }
            }
            public bool generateLightmapUVs = false;
            public bool bendCollider
            {
                get { return _bendCollider; }
                set
                {
                    if (value != _bendCollider)
                    {
                        _bendCollider = value;
                        if (value)
                        {
                            if (collider != null && collider.sharedMesh != null && collider.sharedMesh != originalMesh) colliderNormals = originalColliderMesh.normals;
                        }
                        else RevertCollider();
                    }
                }
            }
            public bool bendSpline
            {
                get { return _bendSpline; }
                set
                {
                    _bendSpline = value;
                    if (value)
                    {

                    }
                }
            }
            [SerializeField]
            [HideInInspector]
            private bool _bendMesh = true;
            [SerializeField]
            [HideInInspector]
            private bool _bendSpline = true;
            [SerializeField]
            [HideInInspector]
            private bool _bendCollider = true;

            private float colliderUpdateDue = 0f;
            public float colliderUpdateRate = 0.2f;
            private bool updateCollider = false;

            public Vector3 originalPosition = Vector3.zero;
            public Vector3 originalScale = Vector3.one;
            public Quaternion originalRotation = Quaternion.identity;
            public Quaternion parentRotation = Quaternion.identity;
            public Vector3 positionPercent;

            public Vector3[] vertexPercents = new Vector3[0];
            public Vector3[] normals = new Vector3[0];
            public Vector3[] colliderVertexPercents = new Vector3[0];
            public Vector3[] colliderNormals = new Vector3[0];

            [SerializeField]
            [HideInInspector]
            private Mesh originalMesh = null;
            [SerializeField]
            [HideInInspector]
            private Mesh originalColliderMesh = null;
            private Spline _originalSpline;

            [SerializeField]
            [HideInInspector]
            private Mesh destinationMesh = null;
            [SerializeField]
            [HideInInspector]
            private Mesh destinationColliderMesh = null;
            public Spline destinationSpline;

            public TS_Mesh editMesh
            {
                get
                {
                    if (!bendMesh || originalMesh == null) _editMesh = null;
                    else if (_editMesh == null && originalMesh != null) _editMesh = new TS_Mesh(originalMesh);
                    return _editMesh;
                }
            }
            public TS_Mesh editColliderMesh
            {
                get
                {
                    if (!bendCollider || originalColliderMesh == null) _editColliderMesh = null;
                    else if (_editColliderMesh == null && originalColliderMesh != null && originalColliderMesh != originalMesh) _editColliderMesh = new TS_Mesh(originalColliderMesh);
                    return _editColliderMesh;
                }
            }
            public Spline originalSpline
            {
                get
                {
                    if (!bendSpline || splineComputer == null) _originalSpline = null;
                    else if (_originalSpline == null && splineComputer != null) {
                        _originalSpline = new Spline(splineComputer.type);
                        _originalSpline.points = splineComputer.GetPoints();
                    }
                    return _originalSpline;
                }
            }

            public TS_Mesh _editMesh = null;
            public TS_Mesh _editColliderMesh = null;

            public MeshFilter filter = null;
            public MeshCollider collider = null;
            public SplineComputer splineComputer = null;

            public Vector3[] splinePointPercents = new Vector3[0];
            public Vector3[] primaryTangentPercents = new Vector3[0];
            public Vector3[] secondaryTangentPercents = new Vector3[0];

            [SerializeField]
            [HideInInspector]
            private bool parent = false;

            public bool isParent {
                get { return parent;  }
            }


            public BendProperty(Transform t, bool parent = false)
            {
                this.parent = parent;
                transform = new TS_Transform(t);
                originalPosition = t.localPosition;
                originalScale = t.localScale;
                originalRotation = t.localRotation;
                parentRotation = t.transform.rotation;
                if (t.transform.parent != null) parentRotation = t.transform.parent.rotation;
                filter = t.GetComponent<MeshFilter>();
                collider = t.GetComponent<MeshCollider>();
                if (filter != null && filter.sharedMesh != null)
                {
                    originalMesh = filter.sharedMesh;
                    normals = originalMesh.normals;
                    for (int i = 0; i < normals.Length; i++) normals[i] = transform.transform.TransformDirection(normals[i]).normalized;
                }

                if (collider != null && collider.sharedMesh != null)
                {
                    originalColliderMesh = collider.sharedMesh;
                    colliderNormals = originalColliderMesh.normals;
                    for (int i = 0; i < colliderNormals.Length; i++) colliderNormals[i] = transform.transform.TransformDirection(colliderNormals[i]);
                }
                if (!parent) splineComputer = t.GetComponent<SplineComputer>();
                if (splineComputer != null)
                {
                    if (splineComputer.isClosed) originalSpline.Close();
                    destinationSpline = new Spline(originalSpline.type);
                    destinationSpline.points = new SplinePoint[originalSpline.points.Length];
                    destinationSpline.points = splineComputer.GetPoints();
                    if (splineComputer.isClosed) destinationSpline.Close();
                }
            }

            public void Revert()
            {
                if (!isValid) return;
                RevertTransform();
                RevertCollider();
                RevertMesh();
                if (splineComputer != null) splineComputer.SetPoints(_originalSpline.points);
            }

            private void RevertMesh()
            {
                if (filter != null) filter.sharedMesh = originalMesh;
                destinationMesh = null;
            }

            private void RevertTransform()
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                {
                    transform.transform.localPosition = originalPosition;
                    transform.transform.localRotation = originalRotation;
                }
                else
                {
                    transform.localPosition = originalPosition;
                    transform.localRotation = originalRotation;
                    transform.Update();
                }
#else
                transform.localPosition = originalPosition;
                transform.localRotation = originalRotation;
                transform.Update();
#endif
                transform.scale = originalScale;
                transform.Update();
            }

            private void RevertCollider()
            {
                if (collider != null) collider.sharedMesh = originalColliderMesh;
                destinationColliderMesh = null;
            }

            public void Apply(bool applyTransform)
            {
                if (!enabled) return;
                if (!isValid) return;
                if(applyTransform) transform.Update();
                if (editMesh != null && editMesh.hasUpdate)  ApplyMesh();
                if (bendCollider && collider != null)
                {
                    if (!updateCollider)
                    {
                        if((editColliderMesh == null && editMesh != null) || editColliderMesh != null)
                        {
                            updateCollider = true;
                            if(Application.isPlaying) colliderUpdateDue = Time.time + colliderUpdateRate;
                        }
                    }
                }
                if (splineComputer != null) ApplySpline();
            }

            public void Update()
            {
                if (Time.time >= colliderUpdateDue && updateCollider)
                {
                    updateCollider = false;
                    ApplyCollider();
                }
            }

            private void ApplyMesh()
            {
                if (filter == null) return;
                MeshUtility.CalculateTangents(editMesh);
                if (destinationMesh == null)
                {
                    destinationMesh = new Mesh();
                    destinationMesh.name = originalMesh.name;
                }

                editMesh.WriteMesh(ref destinationMesh);
                destinationMesh.RecalculateBounds();
                filter.sharedMesh = destinationMesh;
            }

            private void ApplyCollider()
            {
                if (collider == null) return;
                if (originalColliderMesh == originalMesh) collider.sharedMesh = filter.sharedMesh; //if the collider has the same mesh as the filter - just copy it
                else
                {
                    MeshUtility.CalculateTangents(editColliderMesh);
                    if (destinationColliderMesh == null)
                    {
                        destinationColliderMesh = new Mesh();
                        destinationColliderMesh.name = originalColliderMesh.name;
                    }
                    editColliderMesh.WriteMesh(ref destinationColliderMesh);
                    destinationColliderMesh.RecalculateBounds();
                    collider.sharedMesh = destinationColliderMesh;
                }
            }

            private void ApplySpline()
            {
                if (destinationSpline == null) return;
                splineComputer.SetPoints(destinationSpline.points);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectBender.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerCustomRuleBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a81cd2dca8dd58a46a1ff2451e09a21e
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;

    public class ObjectControllerCustomRuleBase : ScriptableObject
    {
        protected ObjectController currentController;
        protected SplineSample currentSample;
        protected int currentObjectIndex;
        protected int totalObjects;
        protected float currentObjectPercent
        {
            get { return (float)currentObjectIndex / (totalObjects - 1); }
        }

        public void SetContext(ObjectController context, SplineSample sample, int currentObject, int totalObjects)
        {
            currentController = context;
            currentSample = sample;
            this.currentObjectIndex = currentObject;
            this.totalObjects = totalObjects;
        }

        /// <summary>
        /// Implement this method to create custom positioning behaviors. The returned offset should be in local coordinates.
        /// </summary>
        /// <returns>Vector3 offset in local coordinates</returns>
        public virtual Vector3 GetOffset()
        {
            return currentSample.position;
        }

        /// <summary>
        /// Implement this method to create custom rotation behaviors. The returned rotation is in world space
        /// </summary>
        /// <returns>Quaternion rotation in world coordinates</returns>
        public virtual Quaternion GetRotation()
        {
            return currentSample.rotation;
        }

        /// <summary>
        /// Implement this method to create custom scaling behaviors.
        /// </summary>
        /// <returns>Vector3 scale</returns>
        public virtual Vector3 GetScale()
        {
            return Vector3.one * currentSample.size;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerCustomRuleBase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerSineRule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 34dc4bc87da1557438d48f8b38533bd8
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;

    //Use the CreateAssetMenu attribute to add the object to the Create Asset context menu
    //After that, go to Assets/Create/Dreamteck/Splines/... and create the scriptable object
    [CreateAssetMenu(menuName = "Dreamteck/Splines/Object Controller Rules/Sine Rule")]
    public class ObjectControllerSineRule : ObjectControllerCustomRuleBase
    {
        [SerializeField] private bool _useSplinePercent = false;
        [SerializeField] private float _frequency = 1f;
        [SerializeField] private float _amplitude = 1f;
        [SerializeField] private float _angle = 0f;
        [SerializeField] private float _minScale = 1f;
        [SerializeField] private float _maxScale = 1f;
        [SerializeField] [Range(0f, 1f)] private float _offset = 0f;

        public bool useSplinePercent
        {
            get { return _useSplinePercent; }
            set { _useSplinePercent = value; }
        }

        public float frequency
        {
            get { return _frequency; }
            set { _frequency = value; }
        }

        public float amplitude
        {
            get { return _amplitude; }
            set { _amplitude = value; }
        }

        public float angle
        {
            get { return _angle; }
            set { _angle = value; }
        }

        public float minScale
        {
            get { return _minScale; }
            set { _minScale = value; }
        }

        public float maxScale
        {
            get { return _maxScale; }
            set { _maxScale = value; }
        }

        public float offset
        {
            get { return _offset; }
            set { 
                _offset = value;
                if(_offset > 1)
                {
                    _offset -= Mathf.FloorToInt(_offset);
                }
                if(_offset < 0)
                {
                    _offset += Mathf.FloorToInt(-_offset);
                }
            }
        }

        //Override GetOffset, GetRotation and GetScale to implement custom behaviors
        //Use the information from currentSample, currentObjectIndex, totalObjects and currentObjectPercent

        public override Vector3 GetOffset()
        {
            float sin = GetSine();
            return Quaternion.AngleAxis(_angle, Vector3.forward) * Vector3.up * sin * _amplitude;
        }

        public override Vector3 GetScale()
        {
            return Vector3.Lerp(Vector3.one * _minScale, Vector3.one * _maxScale, GetSine());
        }

        private float GetSine()
        {
            float objectPercent = _useSplinePercent ? (float)currentSample.percent : currentObjectPercent;
            return Mathf.Sin((Mathf.PI * _offset) + objectPercent * Mathf.PI * _frequency);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerSineRule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerSpiralRule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: daebc70828e501444b23046e124e96f4
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;

    //Use the CreateAssetMenu attribute to add the object to the Create Asset context menu
    //After that, go to Assets/Create/Dreamteck/Splines/... and create the scriptable object
    [CreateAssetMenu(menuName = "Dreamteck/Splines/Object Controller Rules/Spiral Rule")]
    public class ObjectControllerSpiralRule : ObjectControllerCustomRuleBase
    {
        [SerializeField] private bool _useSplinePercent = false;
        [SerializeField] private float _revolve = 360f;
        [SerializeField] private Vector2 _startSize = Vector2.one;
        [SerializeField] private Vector2 _endSize = Vector2.one;        
        [SerializeField] [Range(0f, 1f)] private float _offset = 0f;

        public bool useSplinePercent
        {
            get { return _useSplinePercent; }
            set { _useSplinePercent = value; }
        }

        public float revolve
        {
            get { return _revolve; }
            set { _revolve = value; }
        }

        public Vector2 startSize
        {
            get { return _startSize; }
            set { _startSize = value; }
        }

        public Vector2 endSize
        {
            get { return _endSize; }
            set { _endSize = value; }
        }

        public float offset
        {
            get { return _offset; }
            set { 
                _offset = value;
                if(_offset > 1)
                {
                    _offset -= Mathf.FloorToInt(_offset);
                }
                if(_offset < 0)
                {
                    _offset += Mathf.FloorToInt(-_offset);
                }
            }
        }

        //Override GetOffset, GetRotation and GetScale to implement custom behaviors
        //Use the information from currentSample, currentObjectIndex, totalObjects and currentObjectPercent

        public override Vector3 GetOffset()
        {
            Vector3 offset = Quaternion.AngleAxis(_revolve * GetPercent(), Vector3.forward) * Vector3.up;
            Vector2 scale = Vector2.Lerp(_startSize, _endSize, GetPercent());
            offset.x *= scale.x;
            offset.y *= scale.y;
            return offset;
        }

        public override Quaternion GetRotation()
        {
            return currentSample.rotation * Quaternion.AngleAxis(_revolve * -GetPercent(), Vector3.forward);
        }

        private float GetPercent()
        {
            float percent = _useSplinePercent ? (float)currentSample.percent : currentObjectPercent + _offset;
            if (percent > 1)
            {
                percent -= Mathf.FloorToInt(percent);
            }
            if (percent < 0)
            {
                percent += Mathf.FloorToInt(-percent);
            }
            return percent;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerSpiralRule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: acb0592a986cebb4287d41702ab6ea22
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Dreamteck.Splines
{
    [AddComponentMenu("Dreamteck/Splines/Users/Object Controller")]
    public class ObjectController : SplineUser
    {
        [System.Serializable]
        internal class ObjectControl
        {
            public bool isNull
            {
                get
                {
                    return gameObject == null;
                }
            }
            public Transform transform
            {
                get {
                    if (gameObject == null) return null;
                    return gameObject.transform;  
                }
            }
            public GameObject gameObject;
            public Vector3 position = Vector3.zero;
            public Quaternion rotation = Quaternion.identity;
            public Vector3 scale = Vector3.one;
            public bool active = true;

            public Vector3 baseScale = Vector3.one;

            public ObjectControl(GameObject input)
            {
                gameObject = input;
                baseScale = gameObject.transform.localScale;
            }

            public void Destroy()
            {
                if (gameObject == null) return;
                GameObject.Destroy(gameObject);
            }

            public void DestroyImmediate()
            {
                if (gameObject == null) return;
                GameObject.DestroyImmediate(gameObject);
            }

            public void Apply()
            {
                if (gameObject == null) return;
                transform.position = position;
                transform.rotation = rotation;
                transform.localScale = scale;
                gameObject.SetActive(active);
            }

        }

        public enum SpawnMethod { Count, Points }
        public enum ObjectMethod { Instantiate, GetChildren }
        public enum Positioning { Stretch, Clip }
        public enum Iteration { Ordered, Random }

        [SerializeField]
        [HideInInspector]
        public GameObject[] objects = new GameObject[0];

        public ObjectMethod objectMethod
        {
            get { return _objectMethod; }
            set
            {
                if (value != _objectMethod)
                {
                    if (value == ObjectMethod.GetChildren)
                    {
                        _objectMethod = value;
                        Spawn();
                    }
                    else _objectMethod = value;
                }
            }
        }

        public SpawnMethod spawnMethod
        {
            get { return _spawnMethod; }
            set
            {
                if (value != _spawnMethod)
                {
                    _spawnMethod = value;
                    Rebuild();
                }
            }
        }

        public int spawnCount
        {
            get { return _spawnCount; }
            set
            {
                if (value != _spawnCount)
                {
                    if (value < 0) value = 0;
                    if (_objectMethod == ObjectMethod.Instantiate)
                    {
                        if (value < _spawnCount)
                        {
                            _spawnCount = value;
                            Remove();
                        }
                        else
                        {
                            _spawnCount = value;
                            Spawn();
                        }
                    }
                    else _spawnCount = value;
                }
            }
        }

        public Positioning objectPositioning
        {
            get { return _objectPositioning; }
            set
            {
                if (value != _objectPositioning)
                {
                    _objectPositioning = value;
                    Rebuild();
                }
            }
        }

        public Iteration iteration
        {
            get { return _iteration; }
            set
            {
                if (value != _iteration)
                {
                    _iteration = value;
                    Rebuild();
                }
            }
        }

#if UNITY_EDITOR
        public bool retainPrefabInstancesInEditor
        {
            get { return _retainPrefabInstancesInEditor; }
            set
            {
                if (value != _retainPrefabInstancesInEditor)
                {
                    _retainPrefabInstancesInEditor = value;
                    Clear();
                    Spawn();
                    Rebuild();
                }
            }
        }
#endif

        public int randomSeed
        {
            get { return _randomSeed; }
            set
            {
                if (value != _randomSeed)
                {
                    _randomSeed = value;
                    Rebuild();
                }
            }
        }

        public Vector3 minOffset
        {
            get { return _minOffset; }
            set
            {
                if (value != _minOffset)
                {
                    _minOffset = value;
                    Rebuild();
                }
            }
        }

        public Vector3 maxOffset
        {
            get { return _maxOffset; }
            set
            {
                if (value != _maxOffset)
                {
                    _maxOffset = value;
                    Rebuild();
                }
            }
        }

        public bool offsetUseWorldCoords
        {
            get { return _offsetUseWorldCoords; }
            set
            {
                if (value != _offsetUseWorldCoords)
                {
                    _offsetUseWorldCoords = value;
                    Rebuild();
                }
            }
        }

        public Vector3 minRotation
        {
            get { return _minRotation; }
            set
            {
                if (value != _minRotation)
                {
                    _minRotation = value;
                    Rebuild();
                }
            }
        }

        public Vector3 maxRotation
        {
            get { return _maxRotation; }
            set
            {
                if (value != _maxRotation)
                {
                    _maxRotation = value;
                    Rebuild();
                }
            }
        }

        public Vector3 rotationOffset
        {
            get { return (_maxRotation+_minRotation)/2f; }
            set
            {
                if (value != _minRotation || value != _maxRotation)
                {
                    _minRotation = _maxRotation = value;
                    Rebuild();
                }
            }
        }

        public Vector3 minScaleMultiplier
        {
            get { return _minScaleMultiplier; }
            set
            {
                if (value != _minScaleMultiplier)
                {
                    _minScaleMultiplier = value;
                    Rebuild();
                }
            }
        }

        public Vector3 maxScaleMultiplier
        {
            get { return _maxScaleMultiplier; }
            set
            {
                if (value != _maxScaleMultiplier)
                {
                    _maxScaleMultiplier = value;
                    Rebuild();
                }
            }
        }

        public bool uniformScaleLerp
        {
            get { return _uniformScaleLerp; }
            set
            {
                if(value != _uniformScaleLerp)
                {
                    _uniformScaleLerp = value;
                    Rebuild();
                }
            }
        }

        public bool shellOffset
        {
            get { return _shellOffset; }
            set
            {
                if (value != _shellOffset)
                {
                    _shellOffset = value;
                    Rebuild();
                }
            }
        }

        public bool applyRotation
        {
            get { return _applyRotation; }
            set
            {
                if (value != _applyRotation)
                {
                    _applyRotation = value;
                    Rebuild();
                }
            }
        }

        public bool rotateByOffset
        {
            get { return _rotateByOffset; }
            set
            {
                if (value != _rotateByOffset)
                {
                    _rotateByOffset = value;
                    Rebuild();
                }
            }
        }

        public bool applyScale
        {
            get { return _applyScale; }
            set
            {
                if (value != _applyScale)
                {
                    _applyScale = value;
                    Rebuild();
                }
            }
        }

        public float evaluateOffset
        {
            get { return _evaluateOffset; }
            set
            {
                if (value != _evaluateOffset)
                {
                    _evaluateOffset = value;
                    Rebuild();
                }
            }
        }

        public float minObjectDistance
        {
            get { return _minObjectDistance; }
            set
            {
                if (value != _minObjectDistance)
                {
                    _minObjectDistance = value;
                    Rebuild();
                }
            }
        }

        public float maxObjectDistance
        {
            get { return _maxObjectDistance; }
            set
            {
                if (value != _maxObjectDistance)
                {
                    _maxObjectDistance = value;
                    Rebuild();
                }
            }
        }

        public ObjectControllerCustomRuleBase customOffsetRule
        {
            get { return _customOffsetRule; }
            set
            {
                if (value != _customOffsetRule)
                {
                    _customOffsetRule = value;
                    Rebuild();
                }
            }
        }

        public ObjectControllerCustomRuleBase customRotationRule
        {
            get { return _customRotationRule; }
            set
            {
                if (value != _customRotationRule)
                {
                    _customRotationRule = value;
                    Rebuild();
                }
            }
        }

        public ObjectControllerCustomRuleBase customScaleRule
        {
            get { return _customScaleRule; }
            set
            {
                if (value != _customScaleRule)
                {
                    _customScaleRule = value;
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private float _evaluateOffset = 0f;
        [SerializeField]
        [HideInInspector]
        private SpawnMethod _spawnMethod = SpawnMethod.Count;
        [SerializeField]
        [HideInInspector]
        private int _spawnCount = 0;
#if UNITY_EDITOR
        [SerializeField]
        [HideInInspector]
        private bool _retainPrefabInstancesInEditor = true;
#endif
        [SerializeField]
        [HideInInspector]
        private Positioning _objectPositioning = Positioning.Stretch;
        [SerializeField]
        [HideInInspector]
        private Iteration _iteration = Iteration.Ordered;
        [SerializeField]
        [HideInInspector]
        private int _randomSeed = 1;
        [SerializeField]
        [HideInInspector]
        private Vector3 _minOffset = Vector3.zero;
        [SerializeField]
        [HideInInspector]
        private Vector3 _maxOffset = Vector3.zero;
        [SerializeField]
        [HideInInspector]
        private bool _offsetUseWorldCoords = false;
        [SerializeField]
        [HideInInspector]
        private Vector3 _minRotation = Vector3.zero;
        [SerializeField]
        [HideInInspector]
        private Vector3 _maxRotation = Vector3.zero;
        [SerializeField]
        [HideInInspector]
        private bool _uniformScaleLerp = true;
        [SerializeField]
        [HideInInspector]
        private Vector3 _minScaleMultiplier = Vector3.one;
        [SerializeField]
        [HideInInspector]
        private Vector3 _maxScaleMultiplier = Vector3.one;
        [SerializeField]
        [HideInInspector]
        private bool _shellOffset = false;
        [SerializeField]
        [HideInInspector]
        private bool _applyRotation = true;
        [SerializeField]
        [HideInInspector]
        private bool _rotateByOffset = false;
        [SerializeField]
        [HideInInspector]
        private bool _applyScale = false;
        [SerializeField]
        [HideInInspector]
        private ObjectMethod _objectMethod = ObjectMethod.Instantiate;
        [HideInInspector]
        public bool delayedSpawn = false;
        [HideInInspector]
        public float spawnDelay = 0.1f;
        [SerializeField]
        [HideInInspector]
        private int lastChildCount = 0;
        [SerializeField]
        [HideInInspector]
        private float lastPointCount = 0;
        [SerializeField]
        [HideInInspector]
        private ObjectControl[] spawned = new ObjectControl[0];
        [SerializeField]
        [HideInInspector]
        private bool _useCustomObjectDistance = false;
        [SerializeField]
        [HideInInspector]
        private float _minObjectDistance = 0f;
        [SerializeField]
        [HideInInspector]
        private float _maxObjectDistance = 0f;
        
        [SerializeField]
        [HideInInspector]
        private ObjectControllerCustomRuleBase _customOffsetRule;

        [SerializeField]
        [HideInInspector]
        private ObjectControllerCustomRuleBase _customRotationRule;

        [SerializeField]
        [HideInInspector]
        private ObjectControllerCustomRuleBase _customScaleRule;

        System.Random offsetRandomizer, shellRandomizer, rotationRandomizer, scaleRandomizer, distanceRandomizer;

        private int GetTargetCount()
        {
            switch (_spawnMethod)
            {
                case SpawnMethod.Points:
                    return spline.pointCount;
                case SpawnMethod.Count:
                default:
                    return spawnCount;
            }
        }

        public void Clear()
        {
            for (int i = 0; i < spawned.Length; i++)
            {
                if (spawned[i] == null || spawned[i].transform == null) continue;
                spawned[i].transform.localScale = spawned[i].baseScale;
                if (_objectMethod == ObjectMethod.GetChildren) spawned[i].gameObject.SetActive(false);
                else
                {
#if UNITY_EDITOR
                    if (!Application.isPlaying) spawned[i].DestroyImmediate();
                    else spawned[i].Destroy();
#else
                    spawned[i].Destroy();
#endif

                }
            }
            spawned = new ObjectControl[0];
        }

        private void OnValidate()
        {
            if (_spawnCount < 0) _spawnCount = 0;
        }

        private void Remove()
        {
            int targetCount = GetTargetCount();
            if (targetCount >= spawned.Length) return;
            for (int i = spawned.Length - 1; i >= targetCount; i--)
            {
                if (i >= spawned.Length) break;
                if (spawned[i] == null) continue;
                spawned[i].transform.localScale = spawned[i].baseScale;
                if (_objectMethod == ObjectMethod.GetChildren) spawned[i].gameObject.SetActive(false);
                else
                {
                    if (Application.isEditor) spawned[i].DestroyImmediate();
                    else spawned[i].Destroy();

                }
            }
            ObjectControl[] newSpawned = new ObjectControl[targetCount];
            for (int i = 0; i < newSpawned.Length; i++)
            {
                newSpawned[i] = spawned[i];
            }
            spawned = newSpawned;
            // For consistency, I rebuild immediately here too. That way,
            // the ObjectController behaves without glitching in all cases.
            RebuildImmediate();
        }

        public void GetAll()
        {
            ObjectControl[] newSpawned = new ObjectControl[transform.childCount];
            int index = 0;
            foreach (Transform child in transform)
            {
                if (newSpawned[index] == null)
                {
                    newSpawned[index++] = new ObjectControl(child.gameObject);
                    continue;
                }
                bool found = false;
                for (int i = 0; i < spawned.Length; i++)
                {
                    if (spawned[i].gameObject == child.gameObject)
                    {
                        newSpawned[index++] = spawned[i];
                        found = true;
                        break;
                    }
                }
                if (!found) newSpawned[index++] = new ObjectControl(child.gameObject);
            }
            spawned = newSpawned;
        }

        public void Spawn()
        {
            if (_objectMethod == ObjectMethod.Instantiate)
            {
                if (delayedSpawn && Application.isPlaying)
                {
                    StopCoroutine("InstantiateAllWithDelay");
                    StartCoroutine(InstantiateAllWithDelay());
                }
                else InstantiateAll();
            }
            else GetAll();
            Rebuild();
        }

        protected override void LateRun()
        {
            base.LateRun();
            if (_spawnMethod == SpawnMethod.Points && spline && lastPointCount != spline.pointCount)
            {
                if (_objectMethod != ObjectMethod.GetChildren) Remove();
                Spawn();
                lastPointCount = spline.pointCount;
            }
            if (_objectMethod == ObjectMethod.GetChildren && lastChildCount != transform.childCount)
            {
                Spawn();
                lastChildCount = transform.childCount;
            }
        }


        IEnumerator InstantiateAllWithDelay()
        {
            if (spline == null) yield break;
            if (objects.Length == 0) yield break;

            int targetCount = GetTargetCount();
            for (int i = spawned.Length; i < targetCount; i++)
            {
                InstantiateSingle();
                // Visual artifacts occur if not rebuilding immediately. Normally this can be solved
                // by calling RebuildImmediate on the spline after modifying it,
                // however, with delay this becomes difficult to control.
                // The first object would position correctly, but the rest would
                // have the wrong position for one frame, and the user would have to jump through
                // some hoops to rebuild the user in sync with spawning.
                RebuildImmediate();
                yield return new WaitForSeconds(spawnDelay);
            }
        }

        private void InstantiateAll()
        {
            if (spline == null) return;
            if (objects.Length == 0) return;

            int targetCount = GetTargetCount();
            for (int i = spawned.Length; i < targetCount; i++) InstantiateSingle();
            // For consistency, I rebuild immediately here too. That way, there is no need for the user
            // to figure out if the ObjectController has delay or not and keeps the usage simple.
            RebuildImmediate();
        }

        private void InstantiateSingle()
        {
            if (objects.Length == 0) return;
            int index = 0;
            if (_iteration == Iteration.Ordered)
            {
                index = spawned.Length - Mathf.FloorToInt(spawned.Length / objects.Length) * objects.Length;
            }
            else index = Random.Range(0, objects.Length);
            if (objects[index] == null) return;

            ObjectControl[] newSpawned = new ObjectControl[spawned.Length + 1];
            spawned.CopyTo(newSpawned, 0);
#if UNITY_EDITOR
            if (!Application.isPlaying && retainPrefabInstancesInEditor)
            {
                GameObject go = (GameObject)UnityEditor.PrefabUtility.InstantiatePrefab(objects[index]);
                go.transform.position = transform.position;
                go.transform.rotation = transform.rotation;
                newSpawned[newSpawned.Length - 1] = new ObjectControl(go);
            } else
            {
                newSpawned[newSpawned.Length - 1] = new ObjectControl((GameObject)Instantiate(objects[index], transform.position, transform.rotation));
            }
#else
            newSpawned[newSpawned.Length - 1] = new ObjectControl((GameObject)Instantiate(objects[index], transform.position, transform.rotation));
#endif
            newSpawned[newSpawned.Length - 1].transform.parent = transform;
            spawned = newSpawned;

#if UNITY_EDITOR
            // For prefabs, it is important that the spawned array gets marked as overridden.
            // Otherwise, the Object Controller will lose references to objects that were spawned
            // after prefab instantiation but before editor play/pause, causing it to leave behind
            // objects and instantiating extra ones.
            EditorUtility.SetDirty(this);
#endif
        }

        protected override void Build()
        {
            base.Build();
            offsetRandomizer = new System.Random(_randomSeed);
            if(_shellOffset) shellRandomizer = new System.Random(_randomSeed + 1);
            rotationRandomizer = new System.Random(_randomSeed + 2);
            scaleRandomizer = new System.Random(_randomSeed + 3);
            distanceRandomizer = new System.Random(_randomSeed + 4);

            bool hasCustomOffset = _customOffsetRule != null;
            bool hasCustomRotation = _customRotationRule != null;
            bool hasCustomScale = _customScaleRule != null;

            bool randomScaleMultiplier = _minScaleMultiplier != _maxScaleMultiplier;
            double distancePercentAccum = 0.0;
            for (int i = 0; i < spawned.Length; i++)
            {
                if (spawned[i] == null)
                {
                    Clear();
                    Spawn();
                    break;
                }
                float percent = 0f;
                if (spawned.Length > 1)
                {
                    if(!_useCustomObjectDistance)
                    {
                        if (spline.isClosed)
                        {
                            percent = (float)i / spawned.Length;
                        }
                        else
                        {
                            percent = (float)i / (spawned.Length - 1);
                        }
                    } else
                    {
                        percent = (float)distancePercentAccum;
                    }
                }

                percent += _evaluateOffset;
                if (percent > 1f)
                {
                    percent -= 1f;
                }
                else if (percent < 0f)
                {
                    percent += 1f;
                }
                
                if (objectPositioning == Positioning.Clip)
                {
                    spline.Evaluate(percent, ref evalResult);
                }
                else
                {
                    Evaluate(percent, ref evalResult);
                }

                spawned[i].position = evalResult.position;

                if (_applyScale)
                {
                    if (hasCustomScale)
                    {
                        _customScaleRule.SetContext(this, evalResult, i, spawned.Length);
                        spawned[i].scale = _customOffsetRule.GetScale();
                    } 
                    else
                    {
                        Vector3 scale = spawned[i].baseScale * evalResult.size;
                        Vector3 multiplier = _minScaleMultiplier;

                        if (randomScaleMultiplier)
                        {

                            if (_uniformScaleLerp)
                            {
                                multiplier = Vector3.Lerp(new Vector3(_minScaleMultiplier.x, _minScaleMultiplier.y, _minScaleMultiplier.z), new Vector3(_maxScaleMultiplier.x, _maxScaleMultiplier.y, _maxScaleMultiplier.z), (float)scaleRandomizer.NextDouble());
                            }
                            else
                            {
                                multiplier.x = Mathf.Lerp(_minScaleMultiplier.x, _maxScaleMultiplier.x, (float)scaleRandomizer.NextDouble());
                                multiplier.y = Mathf.Lerp(_minScaleMultiplier.y, _maxScaleMultiplier.y, (float)scaleRandomizer.NextDouble());
                                multiplier.z = Mathf.Lerp(_minScaleMultiplier.z, _maxScaleMultiplier.z, (float)scaleRandomizer.NextDouble());
                            }
                        }
                        scale.x *= multiplier.x;
                        scale.y *= multiplier.y;
                        scale.z *= multiplier.z;
                        spawned[i].scale = scale;
                    }
                }
                else
                {
                    spawned[i].scale = spawned[i].baseScale;
                }

                Vector3 right = Vector3.Cross(evalResult.forward, evalResult.up).normalized;

                Vector3 posOffset = _minOffset;
                if (hasCustomOffset)
                {
                    _customOffsetRule.SetContext(this, evalResult, i, spawned.Length);
                    posOffset = _customOffsetRule.GetOffset();
                } 
                else if (_minOffset != _maxOffset)
                {
                    if(_shellOffset)
                    {
                        float x = _maxOffset.x - _minOffset.x;
                        float y = _maxOffset.y - _minOffset.y;
                        float angleInRadians = (float)shellRandomizer.NextDouble() * 360f * Mathf.Deg2Rad;
                        posOffset = new Vector2(0.5f * Mathf.Cos(angleInRadians), 0.5f * Mathf.Sin(angleInRadians));
                        posOffset.x *= x;
                        posOffset.y *= y;
                    } else
                    {
                        float rnd = (float)offsetRandomizer.NextDouble();
                        posOffset.x = Mathf.Lerp(_minOffset.x, _maxOffset.x, rnd);
                        rnd = (float)offsetRandomizer.NextDouble();
                        posOffset.y = Mathf.Lerp(_minOffset.y, _maxOffset.y, rnd);
                        rnd = (float)offsetRandomizer.NextDouble();
                        posOffset.z = Mathf.Lerp(_minOffset.z, _maxOffset.z, rnd);
                    }
                }

                if (_offsetUseWorldCoords)
                {
                    spawned[i].position += posOffset;
                }
                else
                {
                    spawned[i].position += right * posOffset.x * evalResult.size + evalResult.up * posOffset.y * evalResult.size;
                }

                if (_applyRotation)
                {
                    if (hasCustomRotation)
                    {
                        _customRotationRule.SetContext(this, evalResult, i, spawned.Length);
                        spawned[i].rotation = _customRotationRule.GetRotation();
                    }
                    else
                    {
                        Quaternion offsetRot = Quaternion.Euler(Mathf.Lerp(_minRotation.x, _maxRotation.x, (float)rotationRandomizer.NextDouble()), Mathf.Lerp(_minRotation.y, _maxRotation.y, (float)rotationRandomizer.NextDouble()), Mathf.Lerp(_minRotation.z, _maxRotation.z, (float)rotationRandomizer.NextDouble()));
                        if (_rotateByOffset) spawned[i].rotation = Quaternion.LookRotation(evalResult.forward, spawned[i].position - evalResult.position) * offsetRot;
                        else spawned[i].rotation = evalResult.rotation * offsetRot;
                    }
                }

                if (_objectPositioning == Positioning.Clip)
                {
                    if (percent < clipFrom || percent > clipTo) spawned[i].active = false;
                    else spawned[i].active = true;
                }
                if (_useCustomObjectDistance)
                {
                    if (objectPositioning == Positioning.Clip)
                    {
                        distancePercentAccum = spline.Travel(distancePercentAccum, Mathf.Lerp(_minObjectDistance, _maxObjectDistance, (float)distanceRandomizer.NextDouble()));
                    }
                    else
                    {
                        distancePercentAccum = Travel(distancePercentAccum, Mathf.Lerp(_minObjectDistance, _maxObjectDistance, (float)distanceRandomizer.NextDouble()));
                    }
                }
            }
        }

        protected override void PostBuild()
        {
            base.PostBuild();
            for (int i = 0; i < spawned.Length; i++)
            {
                spawned[i].Apply();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ParticleController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 33cb05eb65206594b9076db71362bf8c
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;
    using System.Collections;
    using System.Collections.Generic;

    [ExecuteInEditMode]
    [AddComponentMenu("Dreamteck/Splines/Users/Particle Controller")]
    public class ParticleController : SplineUser
    {
        public ParticleSystem particleSystemComponent
        {
            get { return _particleSystem; }
            set {
                _particleSystem = value;
                _renderer = _particleSystem.GetComponent<ParticleSystemRenderer>();
            }
        }

        [SerializeField]
        [HideInInspector]
        private ParticleSystem _particleSystem;
        private ParticleSystemRenderer _renderer;
        public enum EmitPoint { Beginning, Ending, Random, Ordered }
        public enum MotionType { None, UseParticleSystem, FollowForward, FollowBackward, ByNormal, ByNormalRandomized }
        public enum Wrap { Default, Loop }

        [HideInInspector]
        public bool pauseWhenNotVisible = false;
        [HideInInspector]
        public Vector2 offset = Vector2.zero;
        [HideInInspector]
        public bool volumetric = false;
        [HideInInspector]
        public bool emitFromShell = false;
        [HideInInspector]
        public bool apply3DRotation = false;
        [HideInInspector]
        public Vector2 scale = Vector2.one;
        [HideInInspector]
        public EmitPoint emitPoint = EmitPoint.Beginning;
        [HideInInspector]
        public MotionType motionType = MotionType.UseParticleSystem;
        [HideInInspector]
        public Wrap wrapMode = Wrap.Default;
        [HideInInspector]
        public float minCycles = 1f;
        [HideInInspector]
        public float maxCycles = 1f;

        private ParticleSystem.Particle[] _particles = new ParticleSystem.Particle[0];
        private Particle[] _controllers = new Particle[0];
        private int _particleCount = 0;
        private int _birthIndex = 0;
        private List<Vector4> _customParticleData = new List<Vector4>();

        protected override void LateRun()
        {
            if (_particleSystem == null) return;
            if (pauseWhenNotVisible)
            {
                if (_renderer == null)
                {
                    _renderer = _particleSystem.GetComponent<ParticleSystemRenderer>();
                }
                if (!_renderer.isVisible) return;
            }

            int maxParticles = _particleSystem.main.maxParticles;
            if (_particles.Length != maxParticles)
            {
                _particles = new ParticleSystem.Particle[maxParticles];
                _customParticleData = new List<Vector4>(maxParticles);
                Particle[] newControllers = new Particle[maxParticles];
                for (int i = 0; i < newControllers.Length; i++)
                {
                    if (i >= _controllers.Length) break;
                    newControllers[i] = _controllers[i];
                }
                _controllers = newControllers;
            }
            _particleCount = _particleSystem.GetParticles(_particles);
            _particleSystem.GetCustomParticleData(_customParticleData, ParticleSystemCustomData.Custom1);

            bool isLocal = _particleSystem.main.simulationSpace == ParticleSystemSimulationSpace.Local;

            Transform particleSystemTransform = _particleSystem.transform;

            for (int i = 0; i < _particleCount; i++)
            {
                if (_controllers[i] == null)
                {
                    _controllers[i] = new Particle();
                }
                if (isLocal)
                {
                    TransformParticle(ref _particles[i], particleSystemTransform);
                }
                if (_customParticleData[i].w < 1f)
                {
                    OnParticleBorn(i);
                }
                HandleParticle(i);
                if (isLocal)
                {
                    InverseTransformParticle(ref _particles[i], particleSystemTransform);
                }
            }

            _particleSystem.SetCustomParticleData(_customParticleData, ParticleSystemCustomData.Custom1);
            _particleSystem.SetParticles(_particles, _particleCount);
        }

        void TransformParticle(ref ParticleSystem.Particle particle, Transform trs)
        {
            particle.position = trs.TransformPoint(particle.position);
            if (apply3DRotation)
            {

            }
            particle.velocity = trs.TransformDirection(particle.velocity);
        }

        void InverseTransformParticle(ref ParticleSystem.Particle particle, Transform trs)
        {
            particle.position = trs.InverseTransformPoint(particle.position);
            particle.velocity = trs.InverseTransformDirection(particle.velocity);
        }

        protected override void Reset()
        {
            base.Reset();
            updateMethod = UpdateMethod.LateUpdate;
            if (_particleSystem == null) _particleSystem = GetComponent<ParticleSystem>();
        }

        void HandleParticle(int index)
        {
            float lifePercent = _particles[index].remainingLifetime / _particles[index].startLifetime;
            if (motionType == MotionType.FollowBackward || motionType == MotionType.FollowForward || motionType == MotionType.None)
            {
                Evaluate(_controllers[index].GetSplinePercent(wrapMode, _particles[index], motionType), ref evalResult);
                Vector3 resultRight = evalResult.right;
                _particles[index].position = evalResult.position;
                if (apply3DRotation)
                {
                    _particles[index].rotation3D = evalResult.rotation.eulerAngles;
                }
                Vector2 finalOffset = offset;
                if (volumetric)
                {
                    if (motionType != MotionType.None)
                    {
                        finalOffset += Vector2.Lerp(_controllers[index].startOffset, _controllers[index].endOffset, 1f - lifePercent);
                        finalOffset.x *= scale.x;
                        finalOffset.y *= scale.y;
                    } else
                    {
                        finalOffset += _controllers[index].startOffset;
                    }
                }
                _particles[index].position += resultRight * (finalOffset.x * evalResult.size) + evalResult.up * (finalOffset.y * evalResult.size);
                _particles[index].velocity = evalResult.forward;
                _particles[index].startColor = _controllers[index].startColor * evalResult.color;
            }
        }

        private void OnParticleBorn(int index)
        {
            Vector4 custom = _customParticleData[index];
            custom.w = 1;
            _customParticleData[index] = custom;
            double percent = 0.0;
            float emissionRate = Mathf.Lerp(_particleSystem.emission.rateOverTime.constantMin, _particleSystem.emission.rateOverTime.constantMax, 0.5f);
            float expectedParticleCount = emissionRate * _particleSystem.main.startLifetime.constantMax;
            _birthIndex++;
            if (_birthIndex > expectedParticleCount)
            {
                _birthIndex = 0;
            }

            switch (emitPoint)
            {
                case EmitPoint.Beginning: percent = 0f; break;
                case EmitPoint.Ending: percent = 1f; break;
                case EmitPoint.Random: percent = Random.Range(0f, 1f); break;
                case EmitPoint.Ordered: percent = expectedParticleCount > 0 ? (float)_birthIndex / expectedParticleCount : 0f;  break;
            }
            Evaluate(percent, ref evalResult);
            _controllers[index].startColor = _particles[index].startColor;
            _controllers[index].startPercent = percent;

            _controllers[index].cycleSpeed = Random.Range(minCycles, maxCycles);
            Vector2 circle = Vector2.zero;
            if (volumetric)
            {
                if (emitFromShell) circle = Quaternion.AngleAxis(Random.Range(0f, 360f), Vector3.forward) * Vector2.right;
                else circle = Random.insideUnitCircle;
            }
            _controllers[index].startOffset = circle * 0.5f;
            _controllers[index].endOffset = Random.insideUnitCircle * 0.5f;


            Vector3 right = Vector3.Cross(evalResult.forward, evalResult.up);
            _particles[index].position = evalResult.position + right * _controllers[index].startOffset.x * evalResult.size * scale.x + evalResult.up * _controllers[index].startOffset.y * evalResult.size * scale.y;

            float forceX = _particleSystem.forceOverLifetime.x.constantMax;
            float forceY = _particleSystem.forceOverLifetime.y.constantMax;
            float forceZ = _particleSystem.forceOverLifetime.z.constantMax;
            if (_particleSystem.forceOverLifetime.randomized)
            {
                forceX = Random.Range(_particleSystem.forceOverLifetime.x.constantMin, _particleSystem.forceOverLifetime.x.constantMax);
                forceY = Random.Range(_particleSystem.forceOverLifetime.y.constantMin, _particleSystem.forceOverLifetime.y.constantMax);
                forceZ = Random.Range(_particleSystem.forceOverLifetime.z.constantMin, _particleSystem.forceOverLifetime.z.constantMax);
            }

            float time = _particles[index].startLifetime - _particles[index].remainingLifetime;
            Vector3 forceDistance = new Vector3(forceX, forceY, forceZ) * 0.5f * (time * time);

            float startSpeed = _particleSystem.main.startSpeed.constantMax;

            if (motionType == MotionType.ByNormal)
            {
                _particles[index].position += evalResult.up * startSpeed * (_particles[index].startLifetime - _particles[index].remainingLifetime);
                _particles[index].position += forceDistance;
                _particles[index].velocity = evalResult.up * startSpeed + new Vector3(forceX, forceY, forceZ) * time;
            }
            else if (motionType == MotionType.ByNormalRandomized)
            {
                Vector3 normal = Quaternion.AngleAxis(Random.Range(0f, 360f), evalResult.forward) * evalResult.up;
                _particles[index].position += normal * startSpeed * (_particles[index].startLifetime - _particles[index].remainingLifetime);
                _particles[index].position += forceDistance;
                _particles[index].velocity = normal * startSpeed + new Vector3(forceX, forceY, forceZ) * time;
            }
            HandleParticle(index);
        }

        public class Particle
        {
            internal Vector2 startOffset = Vector2.zero;
            internal Vector2 endOffset = Vector2.zero;
            internal float cycleSpeed = 0f;
            internal Color startColor = Color.white;
            internal double startPercent = 0.0;

            internal double GetSplinePercent(Wrap wrap, ParticleSystem.Particle particle, MotionType motionType)
            {
                float lifePercent = particle.remainingLifetime / particle.startLifetime;
                if(motionType == MotionType.FollowBackward)
                {
                    lifePercent = 1f - lifePercent;
                }
                switch (wrap)
                {
                    case Wrap.Default: return DMath.Clamp01(startPercent + (1f - lifePercent) * cycleSpeed);
                    case Wrap.Loop:
                        double loopPoint = startPercent + (1.0 - lifePercent) * cycleSpeed;
                        if(loopPoint > 1.0) loopPoint -= Mathf.FloorToInt((float)loopPoint);
                        return loopPoint;
                }
                return 0.0;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ParticleController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/PathGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2e1690bb01d509a439fc991a10f8278f
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Threading;

namespace Dreamteck.Splines
{
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Dreamteck/Splines/Users/Path Generator")]
    public class PathGenerator : MeshGenerator
    {
        public int slices
        {
            get { return _slices; }
            set
            {
                if (value != _slices)
                {
                    if (value < 1) value = 1;
                    _slices = value;
                    Rebuild();
                }
            }
        }

        public bool useShapeCurve
        {
            get { return _useShapeCurve; }
            set
            {
                if (value != _useShapeCurve)
                {
                    _useShapeCurve = value;
                    if (_useShapeCurve)
                    {
                        _shape = new AnimationCurve();
                        _shape.AddKey(new Keyframe(0, 0));
                        _shape.AddKey(new Keyframe(1, 0));
                    } else _shape = null;
                    Rebuild();
                }
            }
        }

        public bool compensateCorners
        {
            get { return _compensateCorners; }
            set
            {
                if (value != _compensateCorners)
                {
                    _compensateCorners = value;
                    Rebuild();
                }
            }
        }

        public float shapeExposure
        {
            get { return _shapeExposure; }
            set
            {
                if (spline != null && value != _shapeExposure)
                {
                    _shapeExposure = value;
                    Rebuild();
                }
            }
        }

        public AnimationCurve shape
        {
            get { return _shape; }
            set
            {
                if(_lastShape == null) _lastShape = new AnimationCurve();
                bool keyChange = false;
                if (value.keys.Length != _lastShape.keys.Length) keyChange = true;
                else
                {
                    for (int i = 0; i < value.keys.Length; i++)
                    {
                        if (value.keys[i].inTangent != _lastShape.keys[i].inTangent || value.keys[i].outTangent != _lastShape.keys[i].outTangent || value.keys[i].time != _lastShape.keys[i].time || value.keys[i].value != value.keys[i].value)
                        {
                            keyChange = true;
                            break;
                        }
                    }
                }
                if (keyChange) Rebuild();
                _lastShape.keys = new Keyframe[value.keys.Length];
                value.keys.CopyTo(_lastShape.keys, 0);
                _lastShape.preWrapMode = value.preWrapMode;
                _lastShape.postWrapMode = value.postWrapMode;
                _shape = value;

            }
        }

        protected override string meshName => "Path";

        [SerializeField]
        [HideInInspector]
        private int _slices = 1;
        [SerializeField]
        [HideInInspector]
        [Tooltip("This will inflate sample sizes based on the angle between two samples in order to preserve geometry width")]
        private bool _compensateCorners = false;
        [SerializeField]
        [HideInInspector]
        private bool _useShapeCurve = false;
        [SerializeField]
        [HideInInspector]
        private AnimationCurve _shape;
        [SerializeField]
        [HideInInspector]
        private AnimationCurve _lastShape;
        [SerializeField]
        [HideInInspector]
        private float _shapeExposure = 1f;


        protected override void Reset()
        {
            base.Reset();
        }


        protected override void BuildMesh()
        {
           base.BuildMesh();
           GenerateVertices();
           MeshUtility.GeneratePlaneTriangles(ref _tsMesh.triangles, _slices, sampleCount, false);
        }


        void GenerateVertices()
        {
            int vertexCount = (_slices + 1) * sampleCount;
            AllocateMesh(vertexCount, _slices * (sampleCount-1) * 6);
            int vertexIndex = 0;

            ResetUVDistance();

            bool hasOffset = offset != Vector3.zero;
            for (int i = 0; i < sampleCount; i++)
            {
                if (_compensateCorners)
                {
                    GetSampleWithAngleCompensation(i, ref evalResult);
                }
                else
                {
                    GetSample(i, ref evalResult);
                }

                Vector3 center = Vector3.zero;
                try
                {
                   center = evalResult.position;
                } catch (System.Exception ex) { Debug.Log(ex.Message + " for i = " + i); return; }
                Vector3 right = evalResult.right;
                float resultSize = GetBaseSize(evalResult);
                if (hasOffset)
                {
                    center += (offset.x * resultSize) * right + (offset.y * resultSize) * evalResult.up + (offset.z * resultSize) * evalResult.forward;
                }
                float fullSize = size * resultSize;
                Vector3 lastVertPos = Vector3.zero;
                Quaternion rot = Quaternion.AngleAxis(rotation, evalResult.forward);
                if (uvMode == UVMode.UniformClamp || uvMode == UVMode.UniformClip) AddUVDistance(i);
                Color vertexColor = GetBaseColor(evalResult) * color;
                for (int n = 0; n < _slices + 1; n++)
                {
                    float slicePercent = ((float)n / _slices);
                    float shapeEval = 0f;
                    if (_useShapeCurve) shapeEval = _shape.Evaluate(slicePercent);
                    _tsMesh.vertices[vertexIndex] = center + rot * right * (fullSize * 0.5f) - rot * right * (fullSize * slicePercent) + rot * evalResult.up * (shapeEval * _shapeExposure);
                    CalculateUVs(evalResult.percent, 1f - slicePercent);
                    _tsMesh.uv[vertexIndex] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(uvRotation + 180f, Vector3.forward) * (Vector2.one * 0.5f - __uvs));
                    if (_slices > 1)
                    {
                        if (n < _slices)
                        {
                            float forwardPercent = ((float)(n + 1) / _slices);
                            shapeEval = 0f;
                            if (_useShapeCurve) shapeEval = _shape.Evaluate(forwardPercent);
                            Vector3 nextVertPos = center + rot * right * fullSize * 0.5f - rot * right * fullSize * forwardPercent + rot * evalResult.up * shapeEval * _shapeExposure;
                            Vector3 cross1 = -Vector3.Cross(evalResult.forward, nextVertPos - _tsMesh.vertices[vertexIndex]).normalized;

                            if (n > 0)
                            {
                                Vector3 cross2 = -Vector3.Cross(evalResult.forward, _tsMesh.vertices[vertexIndex] - lastVertPos).normalized;
                                _tsMesh.normals[vertexIndex] = Vector3.Slerp(cross1, cross2, 0.5f);
                            } else _tsMesh.normals[vertexIndex] = cross1;
                        }
                        else   _tsMesh.normals[vertexIndex] = -Vector3.Cross(evalResult.forward, _tsMesh.vertices[vertexIndex] - lastVertPos).normalized;
                    }
                    else
                    {
                        _tsMesh.normals[vertexIndex] = evalResult.up;
                        if (rotation != 0f) _tsMesh.normals[vertexIndex] = rot * _tsMesh.normals[vertexIndex];
                    }
                    _tsMesh.colors[vertexIndex] = vertexColor;
                    lastVertPos = _tsMesh.vertices[vertexIndex];
                    vertexIndex++;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/PathGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/PolygonColliderGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a4c6eacf526b59e41ad6bb0134d023f7
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Threading;
namespace Dreamteck.Splines
{
    [AddComponentMenu("Dreamteck/Splines/Users/Polygon Collider Generator")]
    [RequireComponent(typeof(PolygonCollider2D))]
    public class PolygonColliderGenerator : SplineUser
    {
        public enum Type { Path, Shape }
        public Type type
        {
            get
            {
                return _type;
            }
            set
            {
                if (value != _type)
                {
                    _type = value;
                    Rebuild();
                }
            }
        }

        public float size
        {
            get { return _size; }
            set
            {
                if (value != _size)
                {
                    _size = value;
                    Rebuild();
                }
            }
        }

        public float offset
        {
            get { return _offset; }
            set
            {
                if (value != _offset)
                {
                    _offset = value;
                    Rebuild();
                }
            }
        }
        [SerializeField]
        [HideInInspector]
        private Type _type = Type.Path;
        [SerializeField]
        [HideInInspector]
        private float _size = 1f;
        [SerializeField]
        [HideInInspector]
        private float _offset = 0f;
        [SerializeField]
        [HideInInspector]
        protected PolygonCollider2D polygonCollider;

        [SerializeField]
        [HideInInspector]
        protected Vector2[] vertices = new Vector2[0];

        [HideInInspector]
        public float updateRate = 0.1f;
        protected float lastUpdateTime = 0f;

        private bool updateCollider = false;

        protected override void Awake()
        {
            base.Awake();
            polygonCollider = GetComponent<PolygonCollider2D>();
        }


        protected override void Reset()
        {
            base.Reset();
        }

        protected override void OnEnable()
        {
            base.OnEnable();
        }

        protected override void OnDisable()
        {
            base.OnDisable();
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
        }

        protected override void LateRun()
        {
            base.LateRun();
            if (updateCollider)
            {
                if (polygonCollider != null)
                {
                    if (Time.time - lastUpdateTime >= updateRate)
                    {
                        lastUpdateTime = Time.time;
                        updateCollider = false;
                        polygonCollider.SetPath(0, vertices);
                    }
                }
            }
        }

        protected override void Build()
        {
            base.Build();
            switch(type){
                case Type.Path:
                GeneratePath();
                break;
                case Type.Shape: GenerateShape(); break;
            }

        }

        protected override void PostBuild()
        {
            base.PostBuild();
            if (polygonCollider == null) return;
            for(int i = 0; i < vertices.Length; i++)
            {
                vertices[i] = transform.InverseTransformPoint(vertices[i]);
            }
#if UNITY_EDITOR
            if (!Application.isPlaying || updateRate <= 0f) polygonCollider.SetPath(0, vertices);
            else updateCollider = true;
#else
            if(updateRate == 0f) polygonCollider.SetPath(0, vertices);
            else updateCollider = true;
#endif
        }

        private void GeneratePath()
        {
            int vertexCount = sampleCount * 2;
            if (vertices.Length != vertexCount) vertices = new Vector2[vertexCount];
            for (int i = 0; i < sampleCount; i++)
            {
                GetSample(i, ref evalResult);
                Vector2 right = new Vector2(-evalResult.forward.y, evalResult.forward.x).normalized * evalResult.size;
                vertices[i] = new Vector2(evalResult.position.x, evalResult.position.y) + right * size * 0.5f + right * offset;
                vertices[sampleCount + (sampleCount - 1) - i] = new Vector2(evalResult.position.x, evalResult.position.y) - right * size * 0.5f + right * offset;
            }
        }

        private void GenerateShape()
        {
            if (vertices.Length != sampleCount) vertices = new Vector2[sampleCount];
            for (int i = 0; i < sampleCount; i++)
            {
                GetSample(i, ref evalResult);
                vertices[i] = evalResult.position;
                if (offset != 0f)
                {
                    Vector2 right = new Vector2(-evalResult.forward.y, evalResult.forward.x).normalized * evalResult.size;
                    vertices[i] += right * offset;
                }
            }
        }
    }

  
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/PolygonColliderGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/ColorModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 07c5bf379e882994f9828b66623ef12f
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    [System.Serializable]
    public class ColorModifier : SplineSampleModifier
    {
        [System.Serializable]
        public class ColorKey : Key
        {
            public enum BlendMode { Lerp, Multiply, Add, Subtract }
            public Color color = Color.white;
            public BlendMode blendMode = BlendMode.Lerp;

            public ColorKey(double f, double t) : base(f, t)
            {
            }

            public Color Blend(Color input, float percent)
            {
                switch (blendMode)
                {
                    case BlendMode.Lerp: return Color.Lerp(input, color, blend * percent);
                    case BlendMode.Add: return input + color * blend * percent;
                    case BlendMode.Subtract: return input - color * blend * percent;
                    case BlendMode.Multiply: return Color.Lerp(input, input * color, blend * percent);
                    default: return input;
                }
            }
        }

        public override bool hasKeys => keys.Length > 0;
        public ColorKey[] keys = new ColorKey[0];

        public ColorModifier()
        {
            keys = new ColorKey[0];
        }

        public override List<Key> GetKeys()
        {
            return new List<Key>(keys);
        }

        public override void SetKeys(List<Key> input)
        {
            keys = new ColorKey[input.Count];
            for (int i = 0; i < input.Count; i++)
            {
                keys[i] = (ColorKey)input[i];
            }
            base.SetKeys(input);
        }

        public void AddKey(double f, double t)
        {
            ArrayUtility.Add(ref keys, new ColorKey(f, t));
        }

        public override void Apply(ref SplineSample result)
        {
            if (keys.Length == 0) return;
            base.Apply(ref result);
            for (int i = 0; i < keys.Length; i++)
            {
                result.color = keys[i].Blend(result.color, keys[i].Evaluate(result.percent) * blend);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/ColorModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/FollowerSpeedModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8ef79d2db1fdbb54588b21a1643fabd2
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    [System.Serializable]
    public class FollowerSpeedModifier : SplineSampleModifier
    {
        [System.Serializable]
        public class SpeedKey : Key
        {
            public enum Mode { Add, Multiply }
            public float speed = 0f;
            public Mode mode = Mode.Add;

            public SpeedKey(double f, double t) : base(f, t)
            {
            }
        }

        public override bool hasKeys => keys.Count > 0;
        public List<SpeedKey> keys = new List<SpeedKey>();

        public FollowerSpeedModifier()
        {
            keys = new List<SpeedKey>();
        }

        public override List<Key> GetKeys()
        {
            List<Key> output = new List<Key>();
            for (int i = 0; i < keys.Count; i++)
            {
                output.Add(keys[i]);
            }
            return output;
        }

        public override void SetKeys(List<Key> input)
        {
            keys = new List<SpeedKey>();
            for (int i = 0; i < input.Count; i++)
            {
                //input[i]._modifier = this;
                keys.Add((SpeedKey)input[i]);
            }
        }

        public void AddKey(double f, double t)
        {
            keys.Add(new SpeedKey(f, t));
        }

        public override void Apply(ref SplineSample result)
        {
        }

        public float GetSpeed(float input, double percent)
        {
            for (int i = 0; i < keys.Count; i++)
            {
                float lerp = keys[i].Evaluate(percent);
                if(keys[i].mode == SpeedKey.Mode.Add)
                {
                    input += keys[i].speed * lerp;
                } else
                {
                    input *= Mathf.Lerp(1f, keys[i].speed, lerp);
                }
            }
            return input;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/FollowerSpeedModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/MeshScaleModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7be735bc80e43dc43984bdce01839e2e
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    [System.Serializable]
    public class MeshScaleModifier : SplineSampleModifier
    {
        [System.Serializable]
        public class ScaleKey : Key
        {
            public Vector3 scale = Vector3.one;

            public ScaleKey(double f, double t) : base(f, t)
            {
            }
        }

        public override bool hasKeys => keys.Count > 0;
        public List<ScaleKey> keys = new List<ScaleKey>();

        public MeshScaleModifier()
        {
            keys = new List<ScaleKey>();
        }

        public override List<Key> GetKeys()
        {
            List<Key> output = new List<Key>();
            for (int i = 0; i < keys.Count; i++)
            {
                output.Add(keys[i]);
            }
            return output;
        }

        public override void SetKeys(List<Key> input)
        {
            keys = new List<ScaleKey>();
            for (int i = 0; i < input.Count; i++)
            {
                keys.Add((ScaleKey)input[i]);
            }
        }

        public void AddKey(double f, double t)
        {
            keys.Add(new ScaleKey(f, t));
        }

        public override void Apply(ref SplineSample result)
        {
            if (keys.Count == 0)
            {
                return;
            }
            for (int i = 0; i < keys.Count; i++)
            {
                result.size += keys[i].Evaluate(result.percent) * keys[i].scale.magnitude * blend;
            }
        }

        public Vector3 GetScale(SplineSample sample)
        {
            Vector3 scale = Vector3.one;
            for (int i = 0; i < keys.Count; i++)
            {
                float lerp = keys[i].Evaluate(sample.percent);
                Vector3 scaleMultiplier = Vector3.Lerp(Vector3.one, keys[i].scale, lerp);
                scale.x *= scaleMultiplier.x;
                scale.y *= scaleMultiplier.y;
                scale.z *= scaleMultiplier.z;
            }
            return Vector3.Lerp(Vector3.one, scale, blend);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/MeshScaleModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/OffsetModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9d0cc7c794f1e3148acddeb3d008c597
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    [System.Serializable]
    public class OffsetModifier : SplineSampleModifier
    {
        [System.Serializable]
        public class OffsetKey : Key
        {
            public Vector2 offset = Vector2.zero;
            public OffsetKey(Vector2 o, double f, double t) : base(f, t)
            {
                offset = o;
            }
        }

        public override bool hasKeys => keys.Length > 0;
        public OffsetKey[] keys = new OffsetKey[0];

        public OffsetModifier()
        {
            keys = new OffsetKey[0];
        }

        public override List<Key> GetKeys()
        {
            return new List<Key>(keys);
        }

        public override void SetKeys(List<Key> input)
        {
            keys = new OffsetKey[input.Count];
            for (int i = 0; i < input.Count; i++)
            {
                keys[i] = (OffsetKey)input[i];
            }
            base.SetKeys(input);
        }

        public void AddKey(Vector2 offset, double f, double t)
        {
            ArrayUtility.Add(ref keys, new OffsetKey(offset, f, t));
        }

        public override void Apply(ref SplineSample result)
        {
            if (keys.Length == 0) return;
            base.Apply(ref result);
            Vector2 offset = Evaluate(result.percent);
            result.position += result.right * offset.x + result.up * offset.y;
        }

        public Vector2 Evaluate(double time)
        {
            if (keys.Length == 0) return Vector2.zero;
            Vector2 offset = Vector2.zero;
            for (int i = 0; i < keys.Length; i++)
            {
                offset += keys[i].offset * keys[i].Evaluate(time);
            }
            return offset * blend;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/OffsetModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/RotationModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0049066920c0f4549af72ec0044c71c6
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines
{
    [System.Serializable]
    public class RotationModifier : SplineSampleModifier
    {
        [System.Serializable]
        public class RotationKey : Key
        {
            public bool useLookTarget = false;
            public Transform target = null;
            public Vector3 rotation = Vector3.zero;

            public RotationKey(Vector3 rotation, double f, double t) : base(f, t)
            {
                this.rotation = rotation;
            }
        }

        public override bool hasKeys => keys.Length > 0;
        public RotationKey[] keys = new RotationKey[0];

        public RotationModifier()
        {
            keys = new RotationKey[0];
        }

        public override List<Key> GetKeys()
        {
            return new List<Key>(keys);
        }

        public override void SetKeys(List<Key> input)
        {
            keys = new RotationKey[input.Count];
            for (int i = 0; i < input.Count; i++)
            {
                keys[i] = (RotationKey)input[i];
            }
            base.SetKeys(input);
        }

        public void AddKey(Vector3 rotation, double f, double t)
        {
            ArrayUtility.Add(ref keys, new RotationKey(rotation, f, t));
        }

        public override void Apply(ref SplineSample result)
        {
            if (keys.Length == 0) return;
            base.Apply(ref result);

            Quaternion offset = Quaternion.identity, look = result.rotation;
            for (int i = 0; i < keys.Length; i++)
            {
                if (keys[i].useLookTarget && keys[i].target != null)
                {
                    Quaternion lookDir = Quaternion.LookRotation(keys[i].target.position - result.position);
                    look = Quaternion.Slerp(look, lookDir, keys[i].Evaluate(result.percent) * blend);
                }
                else
                {
                    Quaternion euler = Quaternion.Euler(keys[i].rotation.x, keys[i].rotation.y, keys[i].rotation.z);
                    offset = Quaternion.Slerp(offset, offset * euler, keys[i].Evaluate(result.percent) * blend);
                }
            }
            Quaternion rotation = look * offset;
            Vector3 invertedNormal = Quaternion.Inverse(result.rotation) * result.up;
            result.forward = rotation * Vector3.forward;
            result.up = rotation * invertedNormal;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/RotationModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/SizeModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 896008ffd57dfab499f9f0745f7dbb4f
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    [System.Serializable]
    public class SizeModifier : SplineSampleModifier
    {
        [System.Serializable]
        public class SizeKey : Key
        {
            public float size = 0f;

            public SizeKey(double f, double t) : base(f, t)
            {
            }
        }

        public override bool hasKeys => keys.Length > 0;
        public SizeKey[] keys = new SizeKey[0];

        public SizeModifier()
        {
            keys = new SizeKey[0];
        }

        public override List<Key> GetKeys()
        {
            return new List<Key>(keys);
        }

        public override void SetKeys(List<Key> input)
        {
            keys = new SizeKey[input.Count];
            for (int i = 0; i < input.Count; i++)
            {
                keys[i] = (SizeKey)input[i];
            }
            base.SetKeys(input);
        }

        public void AddKey(double f, double t)
        {
            ArrayUtility.Add(ref keys, new SizeKey(f, t));
        }

        public override void Apply(ref SplineSample result)
        {
            if (keys.Length == 0) return;
            base.Apply(ref result);
            for (int i = 0; i < keys.Length; i++)
            {
                result.size += keys[i].Evaluate(result.percent) * keys[i].size * blend;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/SizeModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/SplineSampleModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 26a8731450d83c541afa4dd71666f85d
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections.Generic;
    using UnityEngine;


    [System.Serializable]
    public class SplineSampleModifier
    {
        [Range(0f, 1f)]
        public float blend = 1f;
        public bool useClippedPercent = false;

        public virtual bool hasKeys => false;

        public virtual List<Key> GetKeys()
        {
            return new List<Key>();
        }

        public virtual void SetKeys(List<Key> input)
        {
        }

        public virtual void Apply(ref SplineSample result)
        {

        }

        public virtual void Apply(ref SplineSample source, ref SplineSample destination)
        {
            destination = source;
            Apply(ref destination);
        }

        [System.Serializable]
        public class Key
        {
            public double start
            {
                get { return _featherStart; }
                set {
                    if (value != _featherStart)
                    {
                        _featherStart = DMath.Clamp01(value);
                    }
                }
            }

            public double end
            {
                get { return _featherEnd; }
                set {
                    if (value != _featherEnd)
                    {
                        _featherEnd = DMath.Clamp01(value);
                    }
                }

            }

            public double centerStart
            {
                get { return _centerStart; }
                set {
                    if (value != _centerStart)
                    {
                        _centerStart = DMath.Clamp01(value);
                        if (_centerStart > _centerEnd) _centerStart = _centerEnd;
                    }
                }
            }

            public double centerEnd
            {
                get { return _centerEnd; }
                set {
                    if (value != _centerEnd)
                    {
                        _centerEnd = DMath.Clamp01(value);
                        if (_centerEnd < _centerStart) _centerEnd = _centerStart;
                    }
                }
            }


            public double globalCenterStart
            {
                get {
                    return LocalToGlobalPercent(centerStart);
                }
                set
                {
                    centerStart = DMath.Clamp01(GlobalToLocalPercent(value));
                }
            }

            public double globalCenterEnd
            {
                get
                {
                    return LocalToGlobalPercent(centerEnd);
                }
                set
                {
                    centerEnd = DMath.Clamp01(GlobalToLocalPercent(value));
                }
            }

            public double position
            {
                get
                {
                    double center = DMath.Lerp(_centerStart, _centerEnd, 0.5);
                    if (start > end)
                    {
                        double fromToEndDistance = 1.0 - _featherStart;
                        double centerDistance = center * (fromToEndDistance + _featherEnd);
                        double pos = _featherStart + centerDistance;
                        if (pos > 1.0) pos -= 1.0;
                        return pos;
                    }
                    else return DMath.Lerp(_featherStart, _featherEnd, center);

                }
                set
                {
                    double delta = value - position;
                    start += delta;
                    end += delta;
                }
            }

            [SerializeField] private double _featherStart = 0.0, _featherEnd = 0.0, _centerStart = 0.25, _centerEnd = 0.75;
            public AnimationCurve interpolation;
            public float blend = 1f;

            internal Key(double f, double t)
            {
                start = f;
                end = t;
                interpolation = AnimationCurve.Linear(0f, 0f, 1f, 1f);
            }

            private double GlobalToLocalPercent(double t)
            {
                if (_featherStart > _featherEnd)
                {
                    if (t > _featherStart) return DMath.InverseLerp(_featherStart, _featherStart + (1.0 - _featherStart) + _featherEnd, t);
                    else if (t < _featherEnd) return DMath.InverseLerp(-(1.0 - _featherStart), _featherEnd, t);
                    else return 0f;
                }
                return DMath.InverseLerp(_featherStart, _featherEnd, t);
            }

            private double LocalToGlobalPercent(double t)
            {
                if (_featherStart > _featherEnd)
                {
                    t = DMath.Lerp(_featherStart, _featherStart + (1.0 - _featherStart) + _featherEnd, t);
                    if (t > 1.0) t -= 1.0;
                    return t;
                }
                return DMath.Lerp(_featherStart, _featherEnd, t);
            }

            public float Evaluate(double t)
            {
                t = (float)GlobalToLocalPercent(t);
                if (t < _centerStart)
                {
                    return interpolation.Evaluate((float)(t / _centerStart)) * blend;
                }

                if (t > _centerEnd)
                {
                    return interpolation.Evaluate(1f - (float)DMath.InverseLerp(_centerEnd, 1.0, t)) * blend;
                }
                return interpolation.Evaluate(1f) * blend;
            }

            public virtual Key Duplicate()
            {
                Key newKey = new Key(start, end);
                newKey._centerStart = _centerStart;
                newKey._centerEnd = _centerEnd;
                newKey.blend = blend;
                newKey.interpolation = DuplicateUtility.DuplicateCurve(interpolation);
                return newKey;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/SplineSampleModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineComputer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 598e68924c9f6324bbfd049d3bae754c
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;
    using System.Collections.Generic;

    public delegate void EmptySplineHandler();
    //MonoBehaviour wrapper for the spline class. It transforms the spline using the object's transform and provides thread-safe methods for sampling
    [AddComponentMenu("Dreamteck/Splines/Spline Computer")]
    [ExecuteInEditMode]
    public partial class SplineComputer : MonoBehaviour
    {
#if UNITY_EDITOR
        public enum EditorUpdateMode { Default, OnMouseUp }
        [HideInInspector]
        public bool editorDrawPivot = true;
        [HideInInspector]
        public Color editorPathColor = Color.white;
        [HideInInspector]
        public bool editorAlwaysDraw = false;
        [HideInInspector]
        public bool editorDrawThickness = false;
        [HideInInspector]
        public bool editorBillboardThickness = true;
        private bool _editorIsPlaying = false;
        [HideInInspector]
        public bool isNewlyCreated = true;
        [HideInInspector]
        public EditorUpdateMode editorUpdateMode = EditorUpdateMode.Default;
#endif
        public enum Space { World, Local };
        public enum EvaluateMode { Cached, Calculate }
        public enum SampleMode { Default, Uniform, Optimized }
        public enum UpdateMode { Update, FixedUpdate, LateUpdate, AllUpdate, None }
        public Space space
        {
            get { return _space; }
            set
            {
                if (value != _space)
                {
                    SplinePoint[] worldPoints = GetPoints();
                    _space = value;
                    SetPoints(worldPoints);
                }
            }
        }
        public Spline.Type type
        {
            get
            {
                return _spline.type;
            }

            set
            {
                if (value != _spline.type)
                {
                    _spline.type = value;
                    Rebuild(true);
                }
            }
        }

        public float knotParametrization
        {
            get { return _spline.knotParametrization; }
            set
            {
                float last = _spline.knotParametrization;
                _spline.knotParametrization = value;
                if(last != _spline.knotParametrization)
                {
                    Rebuild(true);
                }
            }
        }

        public bool linearAverageDirection
        {
            get
            {
                return _spline.linearAverageDirection;
            }

            set
            {
                if (value != _spline.linearAverageDirection)
                {
                    _spline.linearAverageDirection = value;
                    Rebuild(true);
                }
            }
        }

        public bool is2D
        {
            get { return _is2D; }
            set
            {
                if (value != _is2D)
                {
                    _is2D = value;
                    SetPoints(GetPoints());
                }
            }
        }

        public int sampleRate
        {
            get { return _spline.sampleRate; }
            set
            {
                if (value != _spline.sampleRate)
                {
                    if (value < 2) value = 2;
                    _spline.sampleRate = value;
                    Rebuild(true);
                }
            }
        }

        public float optimizeAngleThreshold
        {
            get { return _optimizeAngleThreshold; }
            set
            {
                if (value != _optimizeAngleThreshold)
                {
                    if (value < 0.001f) value = 0.001f;
                    _optimizeAngleThreshold = value;
                    if (_sampleMode == SampleMode.Optimized)
                    {
                        Rebuild(true);
                    }
                }
            }
        }

        public SampleMode sampleMode
        {
            get { return _sampleMode; }
            set
            {
                if (value != _sampleMode)
                {
                    _sampleMode = value;
                    Rebuild(true);
                }
            }
        }
        [HideInInspector]
        public bool multithreaded = false;
        [HideInInspector]
        public UpdateMode updateMode = UpdateMode.Update;
        [HideInInspector]
        public TriggerGroup[] triggerGroups = new TriggerGroup[0];

        public AnimationCurve customValueInterpolation
        {
            get { return _spline.customValueInterpolation; }
            set
            {
                _spline.customValueInterpolation = value;
                Rebuild();
            }
        }

        public AnimationCurve customNormalInterpolation
        {
            get { return _spline.customNormalInterpolation; }
            set
            {
                _spline.customNormalInterpolation = value;
                Rebuild();
            }
        }

        public int iterations
        {
            get
            {
                return _spline.iterations;
            }
        }

        public double moveStep
        {
            get
            {
                return _spline.moveStep;
            }
        }

        public bool isClosed
        {
            get
            {
                return _spline.isClosed;
            }
        }

        public int pointCount
        {
            get
            {
                return _spline.points.Length;
            }
        }

        public int sampleCount
        {
            get { return _sampleCollection.length; }
        }

        /// <summary>
        /// Returns the sample at the index transformed by the object's matrix
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public SplineSample this [int index]
        {
            get
            {
                UpdateSampleCollection();
                return _sampleCollection.samples[index];
            }
        }

        /// <summary>
        /// The raw spline samples without transformation applied
        /// </summary>
        public SplineSample[] rawSamples
        {
            get { return _rawSamples; }
        }

        /// <summary>
        /// Thread-safe transform's position
        /// </summary>
        public Vector3 position
        {
            get {
#if UNITY_EDITOR
                if (!_editorIsPlaying) return transform.position;
#endif
                return _localToWorldMatrix.MultiplyPoint3x4(Vector3.zero);
            }
        }
        /// <summary>
        /// Thread-safe transform's rotation
        /// </summary>
        public Quaternion rotation
        {
            get {
#if UNITY_EDITOR
                if (!_editorIsPlaying) return transform.rotation;
#endif
                return _localToWorldMatrix.rotation;
            }
        }
        /// <summary>
        /// Thread-safe transform's scale
        /// </summary>
        public Vector3 scale
        {
            get {
#if UNITY_EDITOR
                if (!_editorIsPlaying) return transform.lossyScale;
#endif
                return _localToWorldMatrix.lossyScale;
            }
        }

        /// <summary>
        /// returns the number of subscribers this computer has
        /// </summary>
        public int subscriberCount
        {
            get
            {
                return _subscribers.Length;
            }
        }

        [HideInInspector]
        [SerializeField]
        [UnityEngine.Serialization.FormerlySerializedAs("spline")]
        private Spline _spline = new Spline(Spline.Type.CatmullRom);

        [HideInInspector]
        private SampleCollection _sampleCollection = new SampleCollection();

        [HideInInspector]
        [SerializeField]
        [UnityEngine.Serialization.FormerlySerializedAs("originalSamplePercents")]
        private double[] _originalSamplePercents = new double[0];
        [HideInInspector]
        [SerializeField]
        private bool _is2D = false;
        [HideInInspector]
        [SerializeField]
        private bool hasSamples = false;
        [HideInInspector]
        [SerializeField]
        [Range(0.001f, 45f)]
        private float _optimizeAngleThreshold = 0.5f;
        [HideInInspector]
        [SerializeField]
        private Space _space = Space.Local;
        [HideInInspector]
        [SerializeField]
        private SampleMode _sampleMode = SampleMode.Default;
        [HideInInspector]
        [SerializeField]
        private SplineUser[] _subscribers = new SplineUser[0];

        [HideInInspector]
        [SerializeField]
        private SplineSample[] _rawSamples = new SplineSample[0];

        private Matrix4x4 _localToWorldMatrix = Matrix4x4.identity;
        private Matrix4x4 _worldToLocalMatrix = Matrix4x4.identity;

        [HideInInspector]
        [SerializeField]
        [UnityEngine.Serialization.FormerlySerializedAs("nodes")]
        private NodeLink[] _nodes = new NodeLink[0];
        private bool _rebuildPending = false;
        private bool _trsCached = false;
        private Transform _trs = null;


        public Transform trs
        {
            get
            {
#if UNITY_EDITOR
                if (!_editorIsPlaying)
                {
                    return transform;
                }
#endif
                if (!_trsCached)
                {
                    _trs = transform;
                    _trsCached = true;
                }
                return _trs;
            }
        }

        private bool _queueResample = false, _queueRebuild = false;

        public event EmptySplineHandler onRebuild;

        private bool useMultithreading
        {
            get
            {
                return multithreaded
#if UNITY_EDITOR
                && _editorIsPlaying
#endif
                ;
            }
        }

#if UNITY_EDITOR
        /// <summary>
        /// Used by the editor - should not be called from the API
        /// </summary>
        public void EditorAwake()
        {
            UpdateConnectedNodes();
            RebuildImmediate(true, true);
        }

        /// <summary>
        /// Used by the editor - should not be called from the API
        /// </summary>
        public void EditorUpdateConnectedNodes()
        {
            UpdateConnectedNodes();
        }
#endif

        private void Awake()
        {
#if UNITY_EDITOR
            _editorIsPlaying = Application.isPlaying;
#endif
            ResampleTransform();
        }

        void FixedUpdate()
        {
            if (updateMode == UpdateMode.FixedUpdate || updateMode == UpdateMode.AllUpdate)
            {
                RunUpdate();
            }
        }

        void LateUpdate()
        {
            if (updateMode == UpdateMode.LateUpdate || updateMode == UpdateMode.AllUpdate)
            {
                RunUpdate();
            }
        }

        void Update()
        {
            if (updateMode == UpdateMode.Update || updateMode == UpdateMode.AllUpdate)
            {
                RunUpdate();
            }
        }

        private void RunUpdate(bool immediate = false)
        {
            bool transformChanged = ResampleTransformIfNeeded();
            if(_sampleCollection.samples.Length != _rawSamples.Length)
            {
                transformChanged = true;
            }

            if (useMultithreading)
            {
                //Rebuild users at the beginning of the next cycle if multithreaded
                if (_queueRebuild)
                {
                    RebuildUsers(immediate);
                }
            }

            if (_queueResample)
            {
                if (useMultithreading)
                {
                    if (transformChanged)
                    {
                        SplineThreading.Run(CalculateWithoutTransform);
                    } else
                    {
                        SplineThreading.Run(CalculateWithTransform);
                    }
                }
                else
                {
                    CalculateSamples(!transformChanged);
                }
            }

            if (transformChanged)
            {
                if (useMultithreading)
                {
                    SplineThreading.Run(TransformSamples);
                }
                else
                {
                    TransformSamples();
                }
            }

            if (!useMultithreading)
            {
                //If not multithreaded, rebuild users here
                if (_queueRebuild)
                {
                    RebuildUsers(immediate);
                }
            }

            void CalculateWithTransform()
            {
                CalculateSamples();
            }

            void CalculateWithoutTransform()
            {
                CalculateSamples(false);
            }
        }

#if UNITY_EDITOR
        private void Reset()
        {
            editorPathColor = SplinePrefs.defaultColor;
            editorDrawThickness = SplinePrefs.defaultShowThickness;
            is2D = SplinePrefs.default2D;
            editorAlwaysDraw = SplinePrefs.defaultAlwaysDraw;
            editorUpdateMode = SplinePrefs.defaultEditorUpdateMode;
            space = SplinePrefs.defaultComputerSpace;
            type = SplinePrefs.defaultType;
        }
#endif

        void OnEnable()
        {
            if (_rebuildPending)
            {
                _rebuildPending = false;
                Rebuild();
            }
        }

        public void GetSamples(SampleCollection collection)
        {
            UpdateSampleCollection();
            collection.samples = _sampleCollection.samples;
            collection.optimizedIndices = _sampleCollection.optimizedIndices;
            collection.sampleMode = _sampleMode;
        }

        private void UpdateSampleCollection()
        {
            if (_sampleCollection.samples.Length != _rawSamples.Length)
            {
                TransformSamples();
            }
        }

        private bool ResampleTransformIfNeeded()
        {
            bool changed = false;
            //This is used to skip comparing matrices on every frame during runtime
#if UNITY_EDITOR
            if (_editorIsPlaying)
            {
#endif
                if (!trs.hasChanged) return false;
                trs.hasChanged = false;
#if UNITY_EDITOR
            }
#endif

            if (_localToWorldMatrix != trs.localToWorldMatrix)
            {
                ResampleTransform();
                _queueRebuild = true;
                changed = true;
            }
            return changed;
        }

        /// <summary>
        /// Immediately sample the computer's transform (thread-unsafe). Call this before SetPoint(s) if the transform has been modified in the same frame
        /// </summary>
        public void ResampleTransform()
        {
            _localToWorldMatrix = trs.localToWorldMatrix;
            _worldToLocalMatrix = trs.worldToLocalMatrix;
        }

        /// <summary>
        /// Subscribe a SplineUser to this computer. This will rebuild the user automatically when there are changes.
        /// </summary>
        /// <param name="input">The SplineUser to subscribe</param>
        public void Subscribe(SplineUser input)
        {
            if (!IsSubscribed(input))
            {
                ArrayUtility.Add(ref _subscribers, input);
            }
        }

        /// <summary>
        /// Unsubscribe a SplineUser from this computer's updates
        /// </summary>
        /// <param name="input">The SplineUser to unsubscribe</param>
        public void Unsubscribe(SplineUser input)
        {
            for (int i = 0; i < _subscribers.Length; i++)
            {
                if (_subscribers[i] == input)
                {
                    ArrayUtility.RemoveAt(ref _subscribers, i);
                    return;
                }
            }
        }

        /// <summary>
        /// Checks if a user is subscribed to that computer
        /// </summary>
        /// <param name="user"></param>
        /// <returns></returns>
        public bool IsSubscribed(SplineUser user)
        {
            for (int i = 0; i < _subscribers.Length; i++)
            {
                if (_subscribers[i] == user)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Returns an array of subscribed users
        /// </summary>
        /// <returns></returns>
        public SplineUser[] GetSubscribers()
        {
            SplineUser[] subs = new SplineUser[_subscribers.Length];
            _subscribers.CopyTo(subs, 0);
            return subs;
        }

        /// <summary>
        /// Get the points from this computer's spline. All points are transformed in world coordinates.
        /// </summary>
        /// <returns></returns>
        public SplinePoint[] GetPoints(Space getSpace = Space.World)
        {
            SplinePoint[] points = new SplinePoint[_spline.points.Length];
            for (int i = 0; i < points.Length; i++)
            {
                points[i] = _spline.points[i];
                if (_space == Space.Local && getSpace == Space.World)
                {
                    points[i].position = TransformPoint(points[i].position);
                    points[i].tangent = TransformPoint(points[i].tangent);
                    points[i].tangent2 = TransformPoint(points[i].tangent2);
                    points[i].normal = TransformDirection(points[i].normal);
                }
            }
            return points;
        }

        /// <summary>
        /// Get a point from this computer's spline. The point is transformed in world coordinates.
        /// </summary>
        /// <param name="index">Point index</param>
        /// <returns></returns>
        public SplinePoint GetPoint(int index, Space getSpace = Space.World)
        {
            if (index < 0 || index >= _spline.points.Length) return new SplinePoint();
            if (_space == Space.Local && getSpace == Space.World)
            {
                ResampleTransformIfNeeded();
                SplinePoint point = _spline.points[index];
                point.position = TransformPoint(point.position);
                point.tangent = TransformPoint(point.tangent);
                point.tangent2 = TransformPoint(point.tangent2);
                point.normal = TransformDirection(point.normal);
                return point;
            }
            else
            {
                return _spline.points[index];
            }
        }

        public Vector3 GetPointPosition(int index, Space getSpace = Space.World)
        {
            if (_space == Space.Local && getSpace == Space.World)
            {
                ResampleTransformIfNeeded();
                return TransformPoint(_spline.points[index].position);
            }
            else return _spline.points[index].position;
        }

        public Vector3 GetPointNormal(int index, Space getSpace = Space.World)
        {
            if (_space == Space.Local && getSpace == Space.World)
            {
                ResampleTransformIfNeeded();
                return TransformDirection(_spline.points[index].normal).normalized;
            }
            else return _spline.points[index].normal;
        }

        public Vector3 GetPointTangent(int index, Space getSpace = Space.World)
        {
            if (_space == Space.Local && getSpace == Space.World)
            {
                ResampleTransformIfNeeded();
                return TransformPoint(_spline.points[index].tangent);
            }
            else return _spline.points[index].tangent;
        }

        public Vector3 GetPointTangent2(int index, Space getSpace = Space.World)
        {
            if (_space == Space.Local && getSpace == Space.World)
            {
                ResampleTransformIfNeeded();
                return TransformPoint(_spline.points[index].tangent2);
            }
            else return _spline.points[index].tangent2;
        }

        public float GetPointSize(int index, Space getSpace = Space.World)
        {
            return _spline.points[index].size;
        }

        public Color GetPointColor(int index, Space getSpace = Space.World)
        {
            return _spline.points[index].color;
        }

        private void Make2D(ref SplinePoint point)
        {
            point.Flatten(LinearAlgebraUtility.Axis.Z);
        }

        /// <summary>
        /// Set the points of this computer's spline.
        /// </summary>
        /// <param name="points">The points array</param>
        /// <param name="setSpace">Use world or local space</param>
        public void SetPoints(SplinePoint[] points, Space setSpace = Space.World)
        {
            ResampleTransformIfNeeded();
            bool rebuild = false;
            if (points.Length != _spline.points.Length)
            {
                rebuild = true;
                if (points.Length < 3)
                {
                    Break();
                }
                _spline.points = new SplinePoint[points.Length];
                SetAllDirty();
            }

            for (int i = 0; i < points.Length; i++)
            {
                SplinePoint newPoint = points[i];
                if(_spline.points.Length > i)
                {
                    newPoint.isDirty = _spline.points[i].isDirty;
                }
                if (_space == Space.Local && setSpace == Space.World)
                {
                    newPoint.position = InverseTransformPoint(points[i].position);
                    newPoint.tangent = InverseTransformPoint(points[i].tangent);
                    newPoint.tangent2 = InverseTransformPoint(points[i].tangent2);
                    newPoint.normal = InverseTransformDirection(points[i].normal);
                }

                if (_is2D)
                {
                    Make2D(ref newPoint);
                }

                if (newPoint != _spline.points[i])
                {
                    newPoint.isDirty = true;
                    rebuild = true;
                }

                _spline.points[i] = newPoint;

            }

            if (rebuild)
            {
                Rebuild();
                UpdateConnectedNodes(points);
            }
        }

        /// <summary>
        /// Set the position of a control point. This is faster than SetPoint
        /// </summary>
        /// <param name="index"></param>
        /// <param name="pos"></param>
        /// <param name="setSpace"></param>
        public void SetPointPosition(int index, Vector3 pos, Space setSpace = Space.World)
        {
            if (index < 0) return;
            ResampleTransformIfNeeded();
            if (index >= _spline.points.Length)
            {
                AppendPoints((index + 1) - _spline.points.Length);
            }
            Vector3 newPos = pos;
            if (_space == Space.Local && setSpace == Space.World) newPos = InverseTransformPoint(pos);
            if (newPos != _spline.points[index].position)
            {
                SetDirty(index);
                _spline.points[index].SetPosition(newPos);
                Rebuild();
                SetNodeForPoint(index, GetPoint(index));
            }
        }

        /// <summary>
        /// Set the tangents of a control point. This is faster than SetPoint
        /// </summary>
        /// <param name="index"></param>
        /// <param name="tan1"></param>
        /// <param name="tan2"></param>
        /// <param name="setSpace"></param>
        public void SetPointTangents(int index, Vector3 tan1, Vector3 tan2, Space setSpace = Space.World)
        {
            if (index < 0) return;
            ResampleTransformIfNeeded();
            if (index >= _spline.points.Length)
            {
                AppendPoints((index + 1) - _spline.points.Length);
            }
            Vector3 newTan1 = tan1;
            Vector3 newTan2 = tan2;
            if (_space == Space.Local && setSpace == Space.World)
            {
                newTan1 = InverseTransformPoint(tan1);
                newTan2 = InverseTransformPoint(tan2);
            }
            bool rebuild = false;
            if (newTan2 != _spline.points[index].tangent2)
            {
                rebuild = true;
                _spline.points[index].SetTangent2Position(newTan2);
            }
            if (newTan1 != _spline.points[index].tangent)
            {
                rebuild = true;
                _spline.points[index].SetTangentPosition(newTan1);
            }
            if (_is2D) Make2D(ref _spline.points[index]);

            if (rebuild)
            {
                SetDirty(index);
                Rebuild();
                SetNodeForPoint(index, GetPoint(index));
            }
        }

        /// <summary>
        /// Set the normal of a control point. This is faster than SetPoint
        /// </summary>
        /// <param name="index"></param>
        /// <param name="nrm"></param>
        /// <param name="setSpace"></param>
        public void SetPointNormal(int index, Vector3 nrm, Space setSpace = Space.World)
        {
            if (index < 0) return;
            ResampleTransformIfNeeded();
            if (index >= _spline.points.Length)
            {
                AppendPoints((index + 1) - _spline.points.Length);
            }
            Vector3 newNrm = nrm;
            if (_space == Space.Local && setSpace == Space.World) newNrm = InverseTransformDirection(nrm);
            if (newNrm != _spline.points[index].normal)
            {
                SetDirty(index);
                _spline.points[index].normal = newNrm;
                if (_is2D) Make2D(ref _spline.points[index]);
                Rebuild();
                SetNodeForPoint(index, GetPoint(index));
            }
        }

        /// <summary>
        /// Set the size of a control point. This is faster than SetPoint
        /// </summary>
        /// <param name="index"></param>
        /// <param name="size"></param>
        public void SetPointSize(int index, float size)
        {
            if (index < 0) return;
            if (index >= _spline.points.Length)
            {
                AppendPoints((index + 1) - _spline.points.Length);
            }
            if (size != _spline.points[index].size)
            {
                SetDirty(index);
                _spline.points[index].size = size;
                Rebuild();
                SetNodeForPoint(index, GetPoint(index));
            }
        }

        /// <summary>
        /// Set the color of a control point. THis is faster than SetPoint
        /// </summary>
        /// <param name="index"></param>
        /// <param name="color"></param>
        public void SetPointColor(int index, Color color)
        {
            if (index < 0) return;
            if (index >= _spline.points.Length)
            {
                AppendPoints((index + 1) - _spline.points.Length);
            }
            if (color != _spline.points[index].color)
            {
                SetDirty(index);
                _spline.points[index].color = color;
                Rebuild();
                SetNodeForPoint(index, GetPoint(index));
            }
        }

        /// <summary>
        /// Set a control point in world coordinates
        /// </summary>
        /// <param name="index"></param>
        /// <param name="point"></param>
        public void SetPoint(int index, SplinePoint point, Space setSpace = Space.World)
        {
            if (index < 0) return;
            ResampleTransformIfNeeded();
            if (index >= _spline.points.Length)
            {
                AppendPoints((index + 1) - _spline.points.Length);
            }
            SplinePoint newPoint = point;
            if (_space == Space.Local && setSpace == Space.World)
            {
                newPoint.position = InverseTransformPoint(point.position);
                newPoint.tangent = InverseTransformPoint(point.tangent);
                newPoint.tangent2 = InverseTransformPoint(point.tangent2);
                newPoint.normal = InverseTransformDirection(point.normal);
            }

            if (_is2D)
            {
                Make2D(ref newPoint);
            }

            if (newPoint != _spline.points[index])
            {
                newPoint.isDirty = true;
                _spline.points[index] = newPoint;
                Rebuild();
                SetNodeForPoint(index, point);
            }
        }

        private void AppendPoints(int count)
        {
            SplinePoint[] newPoints = new SplinePoint[_spline.points.Length + count];
            _spline.points.CopyTo(newPoints, 0);
            _spline.points = newPoints;
            Rebuild(true);
        }

        /// <summary>
        /// Converts a point index to spline percent
        /// </summary>
        /// <param name="pointIndex">The point index</param>
        /// <returns></returns>
        public double GetPointPercent(int pointIndex)
        {
            double percent = DMath.Clamp01((double)pointIndex / (_spline.points.Length - 1));
            if (_spline.isClosed)
            {
                percent = DMath.Clamp01((double)pointIndex / _spline.points.Length);
            }
            if (_sampleMode != SampleMode.Uniform) return percent;

            if (_originalSamplePercents.Length <= 1) return 0.0;
            for (int i = _originalSamplePercents.Length - 2; i >= 0; i--)
            {
                if (_originalSamplePercents[i] < percent)
                {
                    double inverseLerp = DMath.InverseLerp(_originalSamplePercents[i], _originalSamplePercents[i + 1], percent);
                    return DMath.Lerp(_rawSamples[i].percent, _rawSamples[i+1].percent, inverseLerp);
                }
            }
            return 0.0;
        }

        public int PercentToPointIndex(double percent, Spline.Direction direction = Spline.Direction.Forward)
        {
            int count = _spline.points.Length - 1;
            if (isClosed) count = _spline.points.Length;

            if (_sampleMode == SampleMode.Uniform)
            {
                int index;
                double lerp;
                GetSamplingValues(percent, out index, out lerp);
                if (lerp > 0.0 && index < _originalSamplePercents.Length - 1)
                {
                    lerp = DMath.Lerp(_originalSamplePercents[index], _originalSamplePercents[index + 1], lerp);
                    if (direction == Spline.Direction.Forward)
                    {
                        return DMath.FloorInt(lerp * count);
                    }
                    else
                    {
                        return DMath.CeilInt(lerp * count);
                    }
                }

                if (direction == Spline.Direction.Forward)
                {
                    return DMath.FloorInt(_originalSamplePercents[index] * count);
                }
                else
                {
                    return DMath.CeilInt(_originalSamplePercents[index] * count);
                }
            }

            int point = 0;
            if (direction == Spline.Direction.Forward)
            {
                point = DMath.FloorInt(percent * count);
            }
            else
            {
                point = DMath.CeilInt(percent * count);
            }
            if (point >= _spline.points.Length)
            {
                point = 0;
            }
            return point;
        }

        public Vector3 EvaluatePosition(double percent)
        {
            return EvaluatePosition(percent, EvaluateMode.Cached);
        }

        /// <summary>
        /// Same as Spline.EvaluatePosition but the result is transformed by the computer's transform
        /// </summary>
        /// <param name="percent">Evaluation percent</param>
        /// <param name="mode">Mode to use the method in. Cached uses the cached samples while Calculate is more accurate but heavier</param>
        /// <returns></returns>
        public Vector3 EvaluatePosition(double percent, EvaluateMode mode = EvaluateMode.Cached)
        {
            if (mode == EvaluateMode.Calculate) return TransformPoint(_spline.EvaluatePosition(percent));
            UpdateSampleCollection();
            return _sampleCollection.EvaluatePosition(percent);
        }

        public Vector3 EvaluatePosition(int pointIndex, EvaluateMode mode = EvaluateMode.Cached)
        {
            return EvaluatePosition(GetPointPercent(pointIndex), mode);
        }

        public SplineSample Evaluate(double percent)
        {
            return Evaluate(percent, EvaluateMode.Cached);
        }

        /// <summary>
        /// Same as Spline.Evaluate but the result is transformed by the computer's transform
        /// </summary>
        /// <param name="percent">Evaluation percent</param>
        /// <param name="mode">Mode to use the method in. Cached uses the cached samples while Calculate is more accurate but heavier</param>
        /// <returns></returns>
        public SplineSample Evaluate(double percent, EvaluateMode mode = EvaluateMode.Cached)
        {
            SplineSample result = new SplineSample();
            Evaluate(percent, ref result, mode);
            return result;
        }

        /// <summary>
        /// Evaluate the spline at the position of a given point and return a SplineSample
        /// </summary>
        /// <param name="pointIndex">Point index</param>
        /// <param name="mode">Mode to use the method in. Cached uses the cached samples while Calculate is more accurate but heavier</param>
        public SplineSample Evaluate(int pointIndex)
        {
            SplineSample result = new SplineSample();
            Evaluate(pointIndex, ref result);
            return result;
        }

        /// <summary>
        /// Evaluate the spline at the position of a given point and write in the SplineSample output
        /// </summary>
        /// <param name="pointIndex">Point index</param>
        public void Evaluate(int pointIndex, ref SplineSample result)
        {
            Evaluate(GetPointPercent(pointIndex), ref result);
        }

        public void Evaluate(double percent, ref SplineSample result)
        {
            Evaluate(percent, ref result, EvaluateMode.Cached);
        }
        /// <summary>
        /// Same as Spline.Evaluate but the result is transformed by the computer's transform
        /// </summary>
        /// <param name="result"></param>
        /// <param name="percent"></param>
        public void Evaluate(double percent, ref SplineSample result, EvaluateMode mode = EvaluateMode.Cached)
        {
            if (mode == EvaluateMode.Calculate)
            {
                _spline.Evaluate(percent, ref result);
                TransformSample(ref result);
            } else
            {
                UpdateSampleCollection();
                _sampleCollection.Evaluate(percent, ref result);
            }
        }

        /// <summary>
        /// Same as Spline.Evaluate but the results are transformed by the computer's transform
        /// </summary>
        /// <param name="from">Start position [0-1]</param>
        /// <param name="to">Target position [from-1]</param>
        /// <returns></returns>
        public void Evaluate(ref SplineSample[] results, double from = 0.0, double to = 1.0)
        {
            UpdateSampleCollection();
            _sampleCollection.Evaluate(ref results, from, to);
        }

        /// <summary>
        /// Same as Spline.EvaluatePositions but the results are transformed by the computer's transform
        /// </summary>
        /// <param name="from">Start position [0-1]</param>
        /// <param name="to">Target position [from-1]</param>
        /// <returns></returns>
        public void EvaluatePositions(ref Vector3[] positions, double from = 0.0, double to = 1.0)
        {
            UpdateSampleCollection();
            _sampleCollection.EvaluatePositions(ref positions, from, to);
        }

        /// <summary>
        /// Returns the percent from the spline at a given distance from the start point
        /// </summary>
        /// <param name="start">The start point</param>
        /// /// <param name="distance">The distance to travel</param>
        /// <param name="direction">The direction towards which to move</param>
        /// <returns></returns>
        public double Travel(double start, float distance, out float moved, Spline.Direction direction = Spline.Direction.Forward)
        {
            UpdateSampleCollection();
            return _sampleCollection.Travel(start, distance, direction, out moved);
        }

        public double Travel(double start, float distance, Spline.Direction direction = Spline.Direction.Forward)
        {
            float moved;
            return Travel(start, distance, out moved, direction);
        }


        [System.Obsolete("This project override is obsolete, please use Project(Vector3 position, ref SplineSample result, double from = 0.0, double to = 1.0, EvaluateMode mode = EvaluateMode.Cached, int subdivisions = 4) instead")]
        public void Project(ref SplineSample result, Vector3 position, double from = 0.0, double to = 1.0, EvaluateMode mode = EvaluateMode.Cached, int subdivisions = 4)
        {
            Project(position, ref result, from, to, mode, subdivisions);
        }

        /// <summary>
        /// Same as Spline.Project but the point is transformed by the computer's transform.
        /// </summary>
        /// <param name="worldPoint">Point in world space</param>
        /// <param name="subdivide">Subdivisions default: 4</param>
        /// <param name="from">Sample from [0-1] default: 0f</param>
        /// <param name="to">Sample to [0-1] default: 1f</param>
        /// <param name="mode">Mode to use the method in. Cached uses the cached samples while Calculate is more accurate but heavier</param>
        /// <param name="subdivisions">Subdivisions for the Calculate mode. Don't assign if not using Calculated mode.</param>
        /// <returns></returns>
        public void Project(Vector3 worldPoint, ref SplineSample result, double from = 0.0, double to = 1.0, EvaluateMode mode = EvaluateMode.Cached, int subdivisions = 4)
        {
            if (mode == EvaluateMode.Calculate)
            {
                worldPoint = InverseTransformPoint(worldPoint);
                double percent = _spline.Project(InverseTransformPoint(worldPoint), subdivisions, from, to);
                _spline.Evaluate(percent, ref result);
                TransformSample(ref result);
                return;
            }
            UpdateSampleCollection();
            _sampleCollection.Project(worldPoint, _spline.points.Length, ref result, from, to);
        }

        public SplineSample Project(Vector3 worldPoint, double from = 0.0, double to = 1.0)
        {
            SplineSample result = new SplineSample();
            Project(worldPoint, ref result, from, to);
            return result;
        }

        /// <summary>
        /// Same as Spline.CalculateLength but this takes the computer's transform into account when calculating the length.
        /// </summary>
        /// <param name="from">Calculate from [0-1] default: 0f</param>
        /// <param name="to">Calculate to [0-1] default: 1f</param>
        /// <param name="resolution">Resolution [0-1] default: 1f</param>
        /// <param name="address">Node address of junctions</param>
        /// <returns></returns>
        public float CalculateLength(double from = 0.0, double to = 1.0)
        {
            if (!hasSamples) return 0f;
            UpdateSampleCollection();
            return _sampleCollection.CalculateLength(from, to);
        }

        private void TransformSample(ref SplineSample result)
        {
            result.position = _localToWorldMatrix.MultiplyPoint3x4(result.position);
            result.forward = _localToWorldMatrix.MultiplyVector(result.forward);
            result.up = _localToWorldMatrix.MultiplyVector(result.up);
        }

        public void Rebuild(bool forceUpdateAll = false)
        {
            if (forceUpdateAll)
            {
                SetAllDirty();
            }

#if UNITY_EDITOR
            if (!_editorIsPlaying)
            {
                if (editorUpdateMode == EditorUpdateMode.Default)
                {
                    RebuildImmediate(true);
                }
                return;
            }
#endif

            _queueResample = updateMode != UpdateMode.None;
        }

        public void RebuildImmediate()
        {
            RebuildImmediate(true, true);
        }

        public void RebuildImmediate(bool calculateSamples = true, bool forceUpdateAll = false)
        {
            if (calculateSamples)
            {
                _queueResample = true;
                if (forceUpdateAll)
                {
                    SetAllDirty();
                }
            }
            else
            {
                _queueResample = false;
            }
            RunUpdate(true);
        }

        private void RebuildUsers(bool immediate = false)
        {
            for (int i = _subscribers.Length - 1; i >= 0; i--)
            {
                if (_subscribers[i] != null)
                {
                    if (immediate)
                    {
                        _subscribers[i].RebuildImmediate();
                    }
                    else
                    {
                        _subscribers[i].Rebuild();
                    }
                }
                else
                {
                    ArrayUtility.RemoveAt(ref _subscribers, i);
                }
            }

            if (onRebuild != null)
            {
                onRebuild();
            }
            _queueRebuild = false;
        }

        private void SetAllDirty()
        {
            for (int i = 0; i < _spline.points.Length; i++)
            {
                _spline.points[i].isDirty = true;
            }
        }

        private void SetDirty(int index)
        {
            if (sampleMode == SampleMode.Uniform)
            {
                SetAllDirty();
                return;
            }
            _spline.points[index].isDirty = true;
        }

        private void CalculateSamples(bool transformSamples = true)
        {
            _queueResample = false;
            _queueRebuild = true;
            if (_spline.points.Length == 0)
            {
                if (_rawSamples.Length != 0)
                {
                    _rawSamples = new SplineSample[0];
                    if (transformSamples)
                    {
                        TransformSamples();
                    }
                }
                return;
            }

            if (_spline.points.Length == 1)
            {
                if (_rawSamples.Length != 1)
                {
                    _rawSamples = new SplineSample[1];
                    if (transformSamples)
                    {
                        TransformSamples();
                    }
                }
                _spline.Evaluate(0.0, ref _rawSamples[0]);
                return;
            }

            if (_sampleMode == SampleMode.Uniform)
            {
                _spline.EvaluateUniform(ref _rawSamples, ref _originalSamplePercents);
                if (transformSamples)
                {
                    TransformSamples();
                }
            }
            else
            {
                if (_originalSamplePercents.Length > 0)
                {
                    _originalSamplePercents = new double[0];
                }

                if (_rawSamples.Length != _spline.iterations)
                {
                    _rawSamples = new SplineSample[_spline.iterations];
                    for (int i = 0; i < _rawSamples.Length; i++)
                    {
                        _rawSamples[i] = new SplineSample();
                    }
                }

                if (_sampleCollection.samples.Length != _rawSamples.Length)
                {
                    _sampleCollection.samples = new SplineSample[_rawSamples.Length];
                }

                for (int i = 0; i < _rawSamples.Length; i++)
                {
                    double percent = (double)i / (_rawSamples.Length - 1);
                    if (IsDirtySample(percent))
                    {
                        _spline.Evaluate(percent, ref _rawSamples[i]);
                        _sampleCollection.samples[i].FastCopy(ref _rawSamples[i]);
                        if (transformSamples && _space == Space.Local)
                        {
                            TransformSample(ref _sampleCollection.samples[i]);
                        }
                    }
                }

                if (_sampleMode == SampleMode.Optimized && _rawSamples.Length > 2)
                {
                    OptimizeSamples(space == Space.Local);
                }
                else
                {
                    if (_sampleCollection.optimizedIndices.Length > 0)
                    {
                        _sampleCollection.optimizedIndices = new int[0];
                    }
                }
            }

            _sampleCollection.sampleMode = _sampleMode;
            hasSamples = _sampleCollection.length > 0;

            for (int i = 0; i < _spline.points.Length; i++)
            {
                _spline.points[i].isDirty = false;
            }
        }

        private void OptimizeSamples(bool transformSamples)
        {
            if (_sampleCollection.optimizedIndices.Length != _rawSamples.Length)
            {
                _sampleCollection.optimizedIndices = new int[_rawSamples.Length];
            }

            Vector3 lastDirection = _rawSamples[0].forward;
            List<SplineSample> optimized = new List<SplineSample>();
            for (int i = 0; i < _rawSamples.Length; i++)
            {
                SplineSample sample = _rawSamples[i];
                if (transformSamples)
                {
                    TransformSample(ref sample);
                }
                Vector3 direction = sample.forward;
                if (i < _rawSamples.Length - 1)
                {
                    Vector3 pos = _rawSamples[i + 1].position;
                    if (transformSamples)
                    {
                        pos = _localToWorldMatrix.MultiplyPoint3x4(pos);
                    }
                    direction = pos - sample.position;
                }
                float angle = Vector3.Angle(lastDirection, direction);
                bool includeSample = angle >= _optimizeAngleThreshold || i == 0 || i == _rawSamples.Length - 1;

                if (includeSample)
                {


                    optimized.Add(sample);
                    lastDirection = direction;
                }

                _sampleCollection.optimizedIndices[i] = optimized.Count - 1;
            }

            _sampleCollection.samples = optimized.ToArray();
        }

        private void TransformSamples()
        {
            if (_sampleCollection.samples.Length != _rawSamples.Length)
            {
                _sampleCollection.samples = new SplineSample[_rawSamples.Length];
            }

            if (_sampleMode == SampleMode.Optimized && _rawSamples.Length > 2)
            {
                OptimizeSamples(_space == Space.Local);
            } else
            {
                for (int i = 0; i < _rawSamples.Length; i++)
                {
                    _sampleCollection.samples[i].FastCopy(ref _rawSamples[i]);
                    if (_space == Space.Local)
                    {
                        TransformSample(ref _sampleCollection.samples[i]);
                    }
                }
            }
        }

        bool IsDirtySample(double percent)
        {
            if (_sampleMode == SampleMode.Uniform) return true;

            int currentPoint = PercentToPointIndex(percent);

            int from = currentPoint - 1;
            int to = currentPoint + 2;

            if(_spline.type == Spline.Type.Bezier || _spline.type == Spline.Type.Linear)
            {
                from = currentPoint;
                to = currentPoint + 1;
            }

            int fromClamped = Mathf.Clamp(from, 0, _spline.points.Length - 1);
            int toClamped = Mathf.Clamp(to, 0, _spline.points.Length - 1);

            for (int i = fromClamped; i <= toClamped; i++)
            {
                if (_spline.points[i].isDirty)
                {
                    return true;
                }
            }

            if (_spline.isClosed)
            {
                if(from < 0)
                {
                    for (int i = from + _spline.points.Length; i < _spline.points.Length; i++)
                    {
                        if (_spline.points[i].isDirty)
                        {
                            return true;
                        }
                    }
                }

                if(to >= _spline.points.Length)
                {
                    for (int i = 0; i <= to - _spline.points.Length; i++)
                    {
                        if (_spline.points[i].isDirty)
                        {
                            return true;
                        }
                    }
                }
            }

            if (currentPoint > 0 && !_spline.points[currentPoint].isDirty)
            {
                int count = _spline.points.Length - 1;
                if (_spline.isClosed)
                {
                    count = _spline.points.Length;
                }
                double currentPointPercent = (double)currentPoint / count;

                if(Mathf.Abs((float)(currentPointPercent - percent)) <= 0.00001f)
                {
                    return _spline.points[currentPoint - 1].isDirty;
                }
            }

            return false;
        }

        /// <summary>
        /// Same as Spline.Break() but it will update all subscribed users
        /// </summary>
        public void Break()
        {
            Break(0);
        }

        /// <summary>
        /// Same as Spline.Break(at) but it will update all subscribed users
        /// </summary>
        /// <param name="at"></param>
        public void Break(int at)
        {
            if (_spline.isClosed)
            {
                _spline.Break(at);
                SetAllDirty();
                Rebuild();
            }
        }

        /// <summary>
        /// Same as Spline.Close() but it will update all subscribed users
        /// </summary>
        public void Close()
        {
            if (!_spline.isClosed)
            {
                if(_spline.points.Length >= 3)
                {
                    _spline.Close();
                    SetAllDirty();
                    Rebuild();
                } else
                {
                    Debug.LogError("Spline " + name + " needs at least 3 points before it can be closed. Current points: " + _spline.points.Length);
                }

            }
        }

        /// <summary>
        /// Same as Spline.HermiteToBezierTangents() but it will update all subscribed users
        /// </summary>
        public void CatToBezierTangents()
        {
            _spline.CatToBezierTangents();
            SetPoints(_spline.points, Space.Local);
        }

        /// <summary>
        /// Casts a ray along the transformed spline against all scene colliders.
        /// </summary>
        /// <param name="hit">Hit information</param>
        /// <param name="hitPercent">The percent of evaluation where the hit occured</param>
        /// <param name="layerMask">Layer mask for the raycast</param>
        /// <param name="resolution">Resolution multiplier for precision [0-1] default: 1f</param>
        /// <param name="from">Raycast from [0-1] default: 0f</param>
        /// <param name="to">Raycast to [0-1] default: 1f</param>
        /// <param name="hitTriggers">Should hit triggers? (not supported in 5.1)</param>
        /// <param name="address">Node address of junctions</param>
        /// <returns></returns>
        public bool Raycast(out RaycastHit hit, out double hitPercent, LayerMask layerMask, double resolution = 1.0, double from = 0.0, double to = 1.0 , QueryTriggerInteraction hitTriggers = QueryTriggerInteraction.UseGlobal)
        {
            resolution = DMath.Clamp01(resolution);
            Spline.FormatFromTo(ref from, ref to, false);
            double percent = from;
            Vector3 fromPos = EvaluatePosition(percent);
            hitPercent = 0f;
            while (true)
            {
                double prevPercent = percent;
                percent = DMath.Move(percent, to, moveStep / resolution);
                Vector3 toPos = EvaluatePosition(percent);
                if (Physics.Linecast(fromPos, toPos, out hit, layerMask, hitTriggers))
                {
                    double segmentPercent = (hit.point - fromPos).sqrMagnitude / (toPos - fromPos).sqrMagnitude;
                    hitPercent = DMath.Lerp(prevPercent, percent, segmentPercent);
                    return true;
                }
                fromPos = toPos;
                if (percent == to) break;
            }
            return false;
        }

        /// <summary>
        /// Casts a ray along the transformed spline against all scene colliders and returns all hits. Order is not guaranteed.
        /// </summary>
        /// <param name="hit">Hit information</param>
        /// <param name="hitPercent">The percents of evaluation where each hit occured</param>
        /// <param name="layerMask">Layer mask for the raycast</param>
        /// <param name="resolution">Resolution multiplier for precision [0-1] default: 1f</param>
        /// <param name="from">Raycast from [0-1] default: 0f</param>
        /// <param name="to">Raycast to [0-1] default: 1f</param>
        /// <param name="hitTriggers">Should hit triggers? (not supported in 5.1)</param>
        /// <param name="address">Node address of junctions</param>
        /// <returns></returns>
        public bool RaycastAll(out RaycastHit[] hits, out double[] hitPercents, LayerMask layerMask, double resolution = 1.0, double from = 0.0, double to = 1.0, QueryTriggerInteraction hitTriggers = QueryTriggerInteraction.UseGlobal)
        {
            resolution = DMath.Clamp01(resolution);
            Spline.FormatFromTo(ref from, ref to, false);
            double percent = from;
            Vector3 fromPos = EvaluatePosition(percent);
            List<RaycastHit> hitList = new List<RaycastHit>();
            List<double> percentList = new List<double>();
            bool hasHit = false;
            while (true)
            {
                double prevPercent = percent;
                percent = DMath.Move(percent, to, moveStep / resolution);
                Vector3 toPos = EvaluatePosition(percent);
                RaycastHit[] h = Physics.RaycastAll(fromPos, toPos - fromPos, Vector3.Distance(fromPos, toPos), layerMask, hitTriggers);
                for (int i = 0; i < h.Length; i++)
                {
                    hasHit = true;
                    double segmentPercent = (h[i].point - fromPos).sqrMagnitude / (toPos - fromPos).sqrMagnitude;
                    percentList.Add(DMath.Lerp(prevPercent, percent, segmentPercent));
                    hitList.Add(h[i]);
                }
                fromPos = toPos;
                if (percent == to) break;
            }
            hits = hitList.ToArray();
            hitPercents = percentList.ToArray();
            return hasHit;
        }

        public TriggerGroup AddTriggerGroup()
        {
            TriggerGroup newGroup = new TriggerGroup();
            ArrayUtility.Add(ref triggerGroups, newGroup);
            return newGroup;
        }

        public SplineTrigger AddTrigger(int triggerGroup, double position, SplineTrigger.Type type)
        {
            return AddTrigger(triggerGroup, position, type, "API Trigger", Color.white);
        }

        public SplineTrigger AddTrigger(int triggerGroup, double position, SplineTrigger.Type type, string name, Color color)
        {
            while (triggerGroups.Length <= triggerGroup)
            {
                AddTriggerGroup();
            }
            return triggerGroups[triggerGroup].AddTrigger(position, type, name, color);
        }

        public void RemoveTrigger(int triggerGroup, int triggerIndex)
        {
            if(triggerGroups.Length <= triggerGroup || triggerGroup < 0)
            {
                Debug.LogError("Cannot delete trigger - trigger group " + triggerIndex + " does not exist");
                return;
            }
            triggerGroups[triggerGroup].RemoveTrigger(triggerIndex);
        }

        public void CheckTriggers(double start, double end, SplineUser user = null)
        {
            for (int i = 0; i < triggerGroups.Length; i++)
            {
                triggerGroups[i].Check(start, end);
            }
        }

        public void CheckTriggers(int group, double start, double end)
        {
            if (group < 0 || group >= triggerGroups.Length)
            {
                Debug.LogError("Trigger group " + group + " does not exist");
                return;
            }
            triggerGroups[group].Check(start, end);
        }

        public void ResetTriggers()
        {
            for (int i = 0; i < triggerGroups.Length; i++) triggerGroups[i].Reset();
        }

        public void ResetTriggers(int group)
        {
            if (group < 0 || group >= triggerGroups.Length)
            {
                Debug.LogError("Trigger group " + group + " does not exist");
                return;
            }
            for (int i = 0; i < triggerGroups[group].triggers.Length; i++)
            {
                triggerGroups[group].triggers[i].Reset();
            }
        }

        /// <summary>
        /// Get the available junctions for the given point
        /// </summary>
        /// <param name="pointIndex"></param>
        /// <returns></returns>
        public List<Node.Connection> GetJunctions(int pointIndex)
        {
            for (int i = 0; i < _nodes.Length; i++)
            {
                if(_nodes[i].pointIndex == pointIndex) return _nodes[i].GetConnections(this);
            }
            return new List<Node.Connection>();
        }

        /// <summary>
        /// Get all junctions for all points in the given interval
        /// </summary>
        /// <param name="start"></param>
        /// <param name="direction"></param>
        /// <returns></returns>
        public Dictionary<int, List<Node.Connection>> GetJunctions(double start = 0.0, double end = 1.0)
        {
            int index;
            double lerp;
            UpdateSampleCollection();
            _sampleCollection.GetSamplingValues(start, out index, out lerp);
            Dictionary<int, List<Node.Connection>> junctions = new Dictionary<int, List<Node.Connection>>();
            float startValue = (_spline.points.Length - 1) * (float)start;
            float endValue = (_spline.points.Length - 1) * (float)end;
            for (int i = 0; i < _nodes.Length; i++)
            {
                bool add = false;
                if (end > start && _nodes[i].pointIndex > startValue && _nodes[i].pointIndex < endValue) add = true;
                else if (_nodes[i].pointIndex < startValue && _nodes[i].pointIndex > endValue) add = true;
                if (!add && Mathf.Abs(startValue - _nodes[i].pointIndex) <= 0.0001f) add = true;
                if (!add && Mathf.Abs(endValue - _nodes[i].pointIndex) <= 0.0001f) add = true;
                if (add) junctions.Add(_nodes[i].pointIndex, _nodes[i].GetConnections(this));
            }
            return junctions;
        }

        /// <summary>
        /// Call this to connect a node to a spline's point
        /// </summary>
        /// <param name="node"></param>
        /// <param name="pointIndex"></param>
        public void ConnectNode(Node node, int pointIndex)
        {
            if (node == null)
            {
                Debug.LogError("Missing Node");
                return;
            }

            if (pointIndex < 0 || pointIndex >= _spline.points.Length)
            {
                Debug.Log("Invalid point index " + pointIndex);
                return;
            }

            for (int i = 0; i < _nodes.Length; i++)
            {
                if (_nodes[i].node == null) continue;
                if (_nodes[i].pointIndex == pointIndex || _nodes[i].node == node)
                {
                    Node.Connection[] connections = _nodes[i].node.GetConnections();
                    for (int j = 0; j < connections.Length; j++)
                    {
                        if (connections[j].spline == this)
                        {
                            Debug.LogError("Node " + node.name + " is already connected to spline " + name + " at point " + _nodes[i].pointIndex);
                            return;
                        }
                    }
                    AddNodeLink(node, pointIndex);
                    Debug.Log("Node link already exists");
                    return;
                }
            }
            node.AddConnection(this, pointIndex);
            AddNodeLink(node, pointIndex);
        }

        public void DisconnectNode(int pointIndex)
        {
            for (int i = 0; i < _nodes.Length; i++)
            {
                if (_nodes[i].pointIndex == pointIndex)
                {
                    _nodes[i].node.RemoveConnection(this, pointIndex);
                    ArrayUtility.RemoveAt(ref _nodes, i);
                    return;
                }
            }
        }

        private void AddNodeLink(Node node, int pointIndex)
        {
            NodeLink newLink = new NodeLink();
            newLink.node = node;
            newLink.pointIndex = pointIndex;
            ArrayUtility.Add(ref _nodes, newLink);
            UpdateConnectedNodes();
        }

        public Dictionary<int, Node> GetNodes(double start = 0.0, double end = 1.0)
        {
            int index;
            double lerp;
            UpdateSampleCollection();
            _sampleCollection.GetSamplingValues(start, out index, out lerp);
            Dictionary<int, Node> nodeList = new Dictionary<int, Node>();
            float startValue = (_spline.points.Length - 1) * (float)start;
            float endValue = (_spline.points.Length - 1) * (float)end;
            for (int i = 0; i < _nodes.Length; i++)
            {
                bool add = false;
                if (end > start && _nodes[i].pointIndex > startValue && _nodes[i].pointIndex < endValue) add = true;
                else if (_nodes[i].pointIndex < startValue && _nodes[i].pointIndex > endValue) add = true;
                if (!add && Mathf.Abs(startValue - _nodes[i].pointIndex) <= 0.0001f) add = true;
                if (!add && Mathf.Abs(endValue - _nodes[i].pointIndex) <= 0.0001f) add = true;
                if (add) nodeList.Add(_nodes[i].pointIndex, _nodes[i].node);
            }
            return nodeList;
        }

        public Node GetNode(int pointIndex)
        {
            if (pointIndex < 0 || pointIndex >= _spline.points.Length) return null;
            for (int i = 0; i < _nodes.Length; i++)
            {
                if (_nodes[i].pointIndex == pointIndex) return _nodes[i].node;
            }
            return null;
        }

        public void TransferNode(int pointIndex, int newPointIndex)
        {
            if(newPointIndex < 0 || newPointIndex >= _spline.points.Length)
            {
                Debug.LogError("Invalid new point index " + newPointIndex);
                return;
            }
            if (GetNode(newPointIndex) != null)
            {
                Debug.LogError("Cannot move node to point " + newPointIndex + ". Point already connected to a node");
                return;
            }
            Node node = GetNode(pointIndex);
            if(node == null)
            {
                Debug.LogError("No node connected to point " + pointIndex);
                return;
            }
            DisconnectNode(pointIndex);
            SplineSample sample = Evaluate(newPointIndex);
            node.transform.position = sample.position;
            node.transform.rotation = sample.rotation;
            ConnectNode(node, newPointIndex);
        }

        public void ShiftNodes(int startIndex, int endIndex, int shift)
        {
            int from = endIndex;
            int to = startIndex;
            if(startIndex > endIndex)
            {
                from = startIndex;
                to = endIndex;
            }

            for (int i = from; i >= to; i--)
            {
                Node node = GetNode(i);
                if (node != null)
                {
                    TransferNode(i, i + shift);
                }
            }
        }

        /// <summary>
        /// Gets all connected computers along with the connected indices and connection indices
        /// </summary>
        /// <param name="computers">A list of the connected computers</param>
        /// <param name="connectionIndices">The point indices of this computer where the other computers are connected</param>
        /// <param name="connectedIndices">The point indices of the other computers where they are connected</param>
        /// <param name="percent"></param>
        /// <param name="direction"></param>
        /// <param name="includeEqual">Should point indices that are placed exactly at the percent be included?</param>
        public void GetConnectedComputers(List<SplineComputer> computers, List<int> connectionIndices, List<int> connectedIndices, double percent, Spline.Direction direction, bool includeEqual)
        {
            if (computers == null) computers = new List<SplineComputer>();
            if (connectionIndices == null) connectionIndices = new List<int>();
            if (connectedIndices == null) connectionIndices = new List<int>();
            computers.Clear();
            connectionIndices.Clear();
            connectedIndices.Clear();
            int pointValue = Mathf.FloorToInt((_spline.points.Length - 1) * (float)percent);
            for (int i = 0; i < _nodes.Length; i++)
            {
                bool condition = false;
                if (includeEqual)
                {
                    if (direction == Spline.Direction.Forward) condition = _nodes[i].pointIndex >= pointValue;
                    else condition = _nodes[i].pointIndex <= pointValue;
                } else
                {

                }
                if (condition)
                {
                    Node.Connection[] connections = _nodes[i].node.GetConnections();
                    for (int j = 0; j < connections.Length; j++)
                    {
                        if (connections[j].spline != this) {
                            computers.Add(connections[j].spline);
                            connectionIndices.Add(_nodes[i].pointIndex);
                            connectedIndices.Add(connections[j].pointIndex);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Returns a list of all connected computers. This includes the base computer too.
        /// </summary>
        /// <returns></returns>
        public List<SplineComputer> GetConnectedComputers()
        {
            List<SplineComputer> computers = new List<SplineComputer>();
            computers.Add(this);
            if (_nodes.Length == 0) return computers;
            GetConnectedComputers(ref computers);
            return computers;
        }

        public void GetSamplingValues(double percent, out int index, out double lerp)
        {
            UpdateSampleCollection();
            _sampleCollection.GetSamplingValues(percent, out index, out lerp);
        }

        private void GetConnectedComputers(ref List<SplineComputer> computers)
        {
            SplineComputer comp = computers[computers.Count - 1];
            if (comp == null) return;
            for (int i = 0; i < comp._nodes.Length; i++)
            {
                if (comp._nodes[i].node == null) continue;
                Node.Connection[] connections = comp._nodes[i].node.GetConnections();
                for (int n = 0; n < connections.Length; n++)
                {
                    bool found = false;
                    if (connections[n].spline == this) continue;
                    for (int x = 0; x < computers.Count; x++)
                    {
                        if (computers[x] == connections[n].spline)
                        {
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                    {
                        computers.Add(connections[n].spline);
                        GetConnectedComputers(ref computers);
                    }
                }
            }
        }

        private void RemoveNodeLinkAt(int index)
        {
            //Then remove the node link
            NodeLink[] newLinks = new NodeLink[_nodes.Length - 1];
            for (int i = 0; i < _nodes.Length; i++)
            {
                if (i == index) continue;
                else if (i < index) newLinks[i] = _nodes[i];
                else newLinks[i - 1] = _nodes[i];
            }
            _nodes = newLinks;
        }

        //This "magically" updates the Node's position and all other points, connected to it when a point, linked to a Node is changed.
        private void SetNodeForPoint(int index, SplinePoint worldPoint)
        {
            for (int i = 0; i < _nodes.Length; i++)
            {
                if (_nodes[i].pointIndex == index)
                {
                    _nodes[i].node.UpdatePoint(this, _nodes[i].pointIndex, worldPoint);
                    break;
                }
            }
        }

        private void UpdateConnectedNodes(SplinePoint[] worldPoints)
        {
            for (int i = 0; i < _nodes.Length; i++)
            {
                if (_nodes[i].node == null)
                {
                    RemoveNodeLinkAt(i);
                    i--;
                    Rebuild();
                    continue;
                }
                bool found = false;
                foreach(Node.Connection connection in _nodes[i].node.GetConnections())
                {
                    if(connection.spline == this)
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                {
                    RemoveNodeLinkAt(i);
                    i--;
                    Rebuild();
                    continue;
                }
                _nodes[i].node.UpdatePoint(this, _nodes[i].pointIndex, worldPoints[_nodes[i].pointIndex]);
                _nodes[i].node.UpdateConnectedComputers(this);
            }
        }

        private void UpdateConnectedNodes()
        {
            for (int i = 0; i < _nodes.Length; i++)
            {

                if (_nodes[i] == null || _nodes[i].node == null)
                {
                    RemoveNodeLinkAt(i);
                    Rebuild();
                    i--;
                    continue;
                }
                bool found = false;
                Node.Connection[] connections = _nodes[i].node.GetConnections();
                for (int j = 0; j < connections.Length; j++)
                {
                    if(connections[j].spline == this && connections[j].pointIndex == _nodes[i].pointIndex)
                    {
                        found = true;
                        break;
                    }
                }
                if (found)
                {
                    _nodes[i].node.UpdatePoint(this, _nodes[i].pointIndex, GetPoint(_nodes[i].pointIndex));
                } else
                {
                    RemoveNodeLinkAt(i);
                    Rebuild();
                    i--;
                    continue;
                }
            }
        }

        public Vector3 TransformPoint(Vector3 point)
        {
#if UNITY_EDITOR
            if (!_editorIsPlaying) return transform.TransformPoint(point);
#endif
            return _localToWorldMatrix.MultiplyPoint3x4(point);
        }

        public Vector3 InverseTransformPoint(Vector3 point)
        {
#if UNITY_EDITOR
            if (!_editorIsPlaying) return transform.InverseTransformPoint(point);
#endif
            return _worldToLocalMatrix.MultiplyPoint3x4(point);
        }

        public Vector3 TransformDirection(Vector3 direction)
        {
#if UNITY_EDITOR
            if (!_editorIsPlaying) return transform.TransformDirection(direction);
#endif
            return _localToWorldMatrix.MultiplyVector(direction);
        }

        public Vector3 InverseTransformDirection(Vector3 direction)
        {
#if UNITY_EDITOR
            if (!_editorIsPlaying) return transform.InverseTransformDirection(direction);
#endif
            return _worldToLocalMatrix.MultiplyVector(direction);
        }

#if UNITY_EDITOR
        public void EditorSetPointDirty(int index)
        {
            SetDirty(index);
        }

        public void EditorSetAllPointsDirty()
        {
            SetAllDirty();
        }

#endif

        [System.Serializable]
        internal class NodeLink
        {
            [SerializeField]
            internal Node node = null;
            [SerializeField]
            internal int pointIndex = 0;

            internal List<Node.Connection> GetConnections(SplineComputer exclude)
            {
                Node.Connection[] connections = node.GetConnections();
                List<Node.Connection> connectionList = new List<Node.Connection>();
                for (int i = 0; i < connections.Length; i++)
                {
                    if (connections[i].spline == exclude) continue;
                    connectionList.Add(connections[i]);
                }
                return connectionList;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineComputer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineFollower.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4ddc1a2536715a24095c464a2c394d5d
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using UnityEngine.Events;

namespace Dreamteck.Splines
{
    public delegate void SplineReachHandler();
    [AddComponentMenu("Dreamteck/Splines/Users/Spline Follower")]
    public class SplineFollower : SplineTracer
    {
        public enum FollowMode { Uniform, Time }
        public enum Wrap { Default, Loop, PingPong }
        [HideInInspector]
        public Wrap wrapMode = Wrap.Default;
        [HideInInspector]
        public FollowMode followMode = FollowMode.Uniform;

        [HideInInspector]
        public bool autoStartPosition = false;

        [SerializeField]
        [HideInInspector]
        [UnityEngine.Serialization.FormerlySerializedAs("follow")]
        private bool _follow = true;

        [SerializeField]
        [HideInInspector]
        [Range(0f, 1f)]
        private double _startPosition;

        /// <summary>
        /// If the follow mode is set to Uniform and there is an added offset in the motion panel, this will presserve the uniformity of the follow speed
        /// </summary>
        [HideInInspector]
        public bool preserveUniformSpeedWithOffset = false;

        /// <summary>
        /// Used when follow mode is set to Uniform. Defines the speed of the follower
        /// </summary>
        public float followSpeed
        {
            get { return _followSpeed; }
            set
            {
                if (_followSpeed != value)
                {
                    _followSpeed = value;
                    Spline.Direction lastDirection = _direction;
                    if (Mathf.Approximately(_followSpeed, 0f)) return;
                    if (_followSpeed < 0f)
                    {
                        direction = Spline.Direction.Backward;
                    }
                    if(_followSpeed > 0f)
                    {
                        direction = Spline.Direction.Forward;
                    }
                }
            }
        }

        public override Spline.Direction direction {
            get {
                return base.direction;
            }
            set {
                base.direction = value;
                if(_direction == Spline.Direction.Forward)
                {
                    if(_followSpeed < 0f)
                    {
                        _followSpeed = -_followSpeed;
                    }
                } else
                {
                    if (_followSpeed > 0f)
                    {
                        _followSpeed = -_followSpeed;
                    }
                }
            }
        }

        /// <summary>
        /// Used when follow mode is set to Time. Defines how much time it takes for the follower to travel through the path
        /// </summary>
        public float followDuration
        {
            get { return _followDuration; }
            set
            {
                if (_followDuration != value)
                {
                    if (value < 0f) value = 0f;
                    _followDuration = value;
                }
            }
        }

        public bool follow
        {
            get { return _follow; }
            set
            {
                if(_follow != value)
                {
                    if (autoStartPosition)
                    {
                        Project(GetTransform().position, ref evalResult);
                        SetPercent(evalResult.percent);
                    }
                    _follow = value;
                }
            }
        }

        public event System.Action<double> onEndReached;
        public event System.Action<double> onBeginningReached;

        public FollowerSpeedModifier speedModifier
        {
            get
            {
                return _speedModifier;
            }
        }

        [SerializeField]
        [HideInInspector]
        private float _followSpeed = 1f;
        [SerializeField]
        [HideInInspector]
        private float _followDuration = 1f;

        [SerializeField]
        [HideInInspector]
        private FollowerSpeedModifier _speedModifier = new FollowerSpeedModifier();

        [SerializeField]
        [HideInInspector]
        private FloatEvent _unityOnEndReached = null;
        [SerializeField]
        [HideInInspector]
        private FloatEvent _unityOnBeginningReached = null;

        private double lastClippedPercent = -1.0;

        protected override void Start()
        {
            base.Start();
            if (_follow && autoStartPosition)
            {
                SetPercent(spline.Project(GetTransform().position).percent);
            }
        }

        protected override void LateRun()
        {
            base.LateRun();
#if UNITY_EDITOR
            if (!Application.isPlaying) return;
#endif
            if (_follow)
            {
                Follow();
            }
        }

        protected override void PostBuild()
        {
            base.PostBuild();
            Evaluate(_result.percent, ref _result);
            if (sampleCount > 0)
            {
                if (_follow && !autoStartPosition) ApplyMotion();
            }
        }

        private void Follow()
        {
            switch (followMode)
            {
                case FollowMode.Uniform:
                    double percent = result.percent;
                    if (!_speedModifier.useClippedPercent)
                    {
                        UnclipPercent(ref percent);
                    }
                    float speed = _speedModifier.GetSpeed(Mathf.Abs(_followSpeed), percent);
                    Move(Time.deltaTime * speed); break;
                case FollowMode.Time:
                    if (_followDuration == 0.0) Move(0.0);
                    else Move((double)Time.deltaTime / _followDuration);
                    break;
            }
        }

        public void Restart(double startPosition = 0.0)
        {
            SetPercent(startPosition);
        }

        public override void SetPercent(double percent, bool checkTriggers = false, bool handleJunctions = false)
        {
            base.SetPercent(percent, checkTriggers, handleJunctions);
            lastClippedPercent = percent;

            if (!handleJunctions) return;

            InvokeNodes();
        }

        public override void SetDistance(float distance, bool checkTriggers = false, bool handleJunctions = false)
        {
            base.SetDistance(distance, checkTriggers, handleJunctions);
            lastClippedPercent = ClipPercent(_result.percent);
            if (samplesAreLooped && clipFrom == clipTo && distance > 0f && lastClippedPercent == 0.0) lastClippedPercent = 1.0;

            if (!handleJunctions) return;

            InvokeNodes();
        }

        public void Move(double percent)
        {
            if (percent == 0.0) return;
            if (sampleCount <= 1)
            {
                if (sampleCount == 1)
                {
                    GetSampleRaw(0, ref _result);
                    ApplyMotion();
                }
                return;
            }
            Evaluate(_result.percent, ref _result);
            double startPercent = _result.percent;
            if (wrapMode == Wrap.Default && lastClippedPercent >= 1.0 && startPercent == 0.0) startPercent = 1.0;
            double p = startPercent + (_direction == Spline.Direction.Forward ? percent : -percent);
            bool callOnEndReached = false, callOnBeginningReached = false;
            lastClippedPercent = p;
            if (_direction == Spline.Direction.Forward && p >= 1.0)
            {
                if (startPercent < 1.0)
                {
                    callOnEndReached = true;
                }
                switch (wrapMode)
                {
                    case Wrap.Default:
                        p = 1.0;
                        break;
                    case Wrap.Loop:
                        CheckTriggers(startPercent, 1.0);
                        CheckNodes(startPercent, 1.0);
                        while (p > 1.0) p -= 1.0;
                        startPercent = 0.0;
                        break;
                    case Wrap.PingPong:
                        p = DMath.Clamp01(1.0 - (p - 1.0));
                        startPercent = 1.0;
                        direction = Spline.Direction.Backward;
                        break;
                }
            }
            else if (_direction == Spline.Direction.Backward && p <= 0.0)
            {
                if (startPercent > 0.0)
                {
                    callOnBeginningReached = true;
                }
                switch (wrapMode)
                {
                    case Wrap.Default:
                        p = 0.0;
                        break;
                    case Wrap.Loop:
                        CheckTriggers(startPercent, 0.0);
                        CheckNodes(startPercent, 0.0);
                        while (p < 0.0) p += 1.0;
                        startPercent = 1.0;
                        break;
                    case Wrap.PingPong:
                        p = DMath.Clamp01(-p);
                        startPercent = 0.0;
                        direction = Spline.Direction.Forward;
                        break;
                }
            }
            CheckTriggers(startPercent, p);
            CheckNodes(startPercent, p);
            Evaluate(p, ref _result);
            ApplyMotion();
            if (callOnEndReached)
            {
                if (onEndReached != null)
                {
                    onEndReached(startPercent);
                }
                if (_unityOnEndReached != null)
                {
                    _unityOnEndReached.Invoke((float)startPercent);
                }
            }
            else if (callOnBeginningReached)
            {
                if (onBeginningReached != null)
                {
                    onBeginningReached(startPercent);
                }
                if (_unityOnBeginningReached != null)
                {
                    _unityOnBeginningReached.Invoke((float)startPercent);
                }
            }
            InvokeTriggers();
            InvokeNodes();
        }

        public void Move(float distance)
        {
            bool endReached = false, beginningReached = false;
            float moved = 0f;
            double startPercent = _result.percent;

            double travelPercent = DoTravel(_result.percent, distance, out moved);
            if (startPercent != travelPercent)
            {
                CheckTriggers(startPercent, travelPercent);
                CheckNodes(startPercent, travelPercent);
            }

            if (direction == Spline.Direction.Forward)
            {
                if (travelPercent >= 1.0)
                {
                    if (startPercent < 1.0)
                    {
                        endReached = true;
                    }
                    switch (wrapMode)
                    {
                        case Wrap.Loop:
                            travelPercent = DoTravel(0.0, Mathf.Abs(distance - moved), out moved);
                            CheckTriggers(0.0, travelPercent);
                            CheckNodes(0.0, travelPercent);
                            break;
                        case Wrap.PingPong:
                            direction = Spline.Direction.Backward;
                            travelPercent = DoTravel(1.0, distance - moved, out moved);
                            CheckTriggers(1.0, travelPercent);
                            CheckNodes(1.0, travelPercent);
                            break;
                    }
                }
            } else
            {
                if (travelPercent <= 0.0)
                {
                    if (startPercent > 0.0)
                    {
                        beginningReached = true;
                    }
                    switch (wrapMode)
                    {
                        case Wrap.Loop:
                            travelPercent = DoTravel(1.0, distance - moved, out moved);
                            CheckTriggers(1.0, travelPercent);
                            CheckNodes(1.0, travelPercent);
                            break;
                        case Wrap.PingPong:
                            direction = Spline.Direction.Forward;
                            travelPercent = DoTravel(0.0, Mathf.Abs(distance - moved), out moved);
                            CheckTriggers(0.0, travelPercent);
                            CheckNodes(0.0, travelPercent);
                            break;
                    }
                }
            }

            Evaluate(travelPercent, ref _result);
            ApplyMotion();
            if (endReached)
            {
                if (onEndReached != null)
                {
                    onEndReached(startPercent);
                }
                if (_unityOnEndReached != null)
                {
                    _unityOnEndReached.Invoke((float)startPercent);
                }
            }
            else if (beginningReached)
            {
                if (onBeginningReached != null)
                {
                    onBeginningReached(startPercent);
                }
                if (_unityOnBeginningReached != null)
                {
                    _unityOnBeginningReached.Invoke((float)startPercent);
                }
            }
            InvokeTriggers();
            InvokeNodes();
        }

        protected virtual double DoTravel(double start, float distance, out float moved)
        {
            moved = 0f;
            double result = 0.0;
            if (preserveUniformSpeedWithOffset && _motion.hasOffset)
            {
                result = TravelWithOffset(start, distance, _direction, _motion.offset, out moved);
            } else
            {
                result = Travel(start, distance, _direction, out moved);
            }
            return result;
        }

        [System.Serializable]
        public class FloatEvent : UnityEvent<float> { }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineFollower.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a8e405fbab136934590641eb781310b4
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Threading;

namespace Dreamteck.Splines
{
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Dreamteck/Splines/Users/Spline Mesh")]
    public partial class SplineMesh : MeshGenerator
    {
        //Mesh data
        [SerializeField]
        [HideInInspector, UnityEngine.Serialization.FormerlySerializedAs("channels")]
        private List<Channel> _channels = new List<Channel>();
        private bool _useLastResult = false;
        private List<TS_Mesh> _combineMeshes = new List<TS_Mesh>();

        protected override string meshName => "Custom Mesh";

        private Matrix4x4 _vertexMatrix = new Matrix4x4();
        private Matrix4x4 _normalMatrix = new Matrix4x4();
        private SplineSample _lastResult = new SplineSample();

        protected override void Awake()
        {
            base.Awake();
#if UNITY_EDITOR
            for (int i = 0; i < _channels.Count; i++)
            {
                for (int j = 0; j < _channels[i].GetMeshCount(); j++)
                {
                    _channels[i].GetMesh(j).Refresh();
                }
            }
#endif
        }

        protected override void Reset()
        {
            base.Reset();
            AddChannel("Channel 1");
        }

        public void RemoveChannel(int index)
        {
            _channels.RemoveAt(index);
            Rebuild();
        }

        public void SwapChannels(int a, int b)
        {
            if (a < 0 || a >= _channels.Count || b < 0 || b >= _channels.Count) return;
            Channel temp = _channels[b];
            _channels[b] = _channels[a];
            _channels[a] = temp;
            Rebuild();
        }

        public Channel AddChannel(Mesh inputMesh, string name)
        {
            Channel channel = new Channel(name, inputMesh, this);
            _channels.Add(channel);
            return channel;
        }

        public Channel AddChannel(string name)
        {
            Channel channel = new Channel(name, this);
            _channels.Add(channel);
            return channel;
        }

        public int GetChannelCount()
        {
            return _channels.Count;
        }

        public Channel GetChannel(int index)
        {
            return _channels[index];
        }


        protected override void BuildMesh()
        {
            base.BuildMesh();
            Generate();
        }

        private void Generate()
        {
            int meshCount = 0;
            for (int i = 0; i < _channels.Count; i++)
            {
                if (_channels[i].GetMeshCount() == 0) continue;

                if (_channels[i].autoCount)
                {
                    float avgBounds = 0f;
                    for (int j = 0; j < _channels[i].GetMeshCount(); j++)
                    {
                        avgBounds += _channels[i].GetMesh(j).bounds.size.z;
                    }

                    if (_channels[i].GetMeshCount() > 1)
                    {
                        avgBounds /= _channels[i].GetMeshCount();
                    }

                    if (avgBounds > 0f)
                    {
                        float length = CalculateLength(_channels[i].clipFrom, _channels[i].clipTo, false);
                        int newCount = Mathf.RoundToInt(length / avgBounds);
                        if (newCount < 1)
                        {
                            newCount = 1;
                        }
                        _channels[i].count = newCount;
                    }
                }

                meshCount += _channels[i].count;
            }

            if(meshCount == 0)
            {
                _tsMesh.Clear();
                return;
            }

            if (_combineMeshes.Count < meshCount)
            {
                _combineMeshes.AddRange(new TS_Mesh[meshCount - _combineMeshes.Count]);
            }
            else if (_combineMeshes.Count > meshCount)
            {
                _combineMeshes.RemoveRange((_combineMeshes.Count - 1) - (_combineMeshes.Count - meshCount), _combineMeshes.Count - meshCount);
            }

            int combineMeshIndex = 0;
            for (int i = 0; i < _channels.Count; i++)
            {
                if (_channels[i].GetMeshCount() == 0) continue;
                _channels[i].ResetIteration();
                _useLastResult = false;
                double step = 1.0 / _channels[i].count;
                double space = step * _channels[i].spacing * 0.5;
                
                switch (_channels[i].type)
                {
                    case Channel.Type.Extrude:
                        for (int j = 0; j < _channels[i].count; j++)
                        {
                            double from = DMath.Lerp(_channels[i].clipFrom, _channels[i].clipTo, j * step + space);
                            double to = DMath.Lerp(_channels[i].clipFrom, _channels[i].clipTo, j * step + step - space);
                            if (_combineMeshes[combineMeshIndex] == null)
                            {
                                _combineMeshes[combineMeshIndex] = new TS_Mesh();
                            }
                            Extrude(_channels[i], _combineMeshes[combineMeshIndex], from, to);
                            combineMeshIndex++;
                        }
                        if (space == 0f) _useLastResult = true;
                        break;
                    case Channel.Type.Place:
                        for (int j = 0; j < _channels[i].count; j++)
                        {
                            if (_combineMeshes[combineMeshIndex] == null)
                            {
                                _combineMeshes[combineMeshIndex] = new TS_Mesh();
                            }
                            Place(_channels[i], _combineMeshes[combineMeshIndex], DMath.Lerp(_channels[i].clipFrom, _channels[i].clipTo, (double)j / Mathf.Max(_channels[i].count - 1, 1)));
                            combineMeshIndex++;
                        }
                        break;
                   
                }
            }
            _tsMesh.Combine(_combineMeshes);
        }

        private void Place(Channel channel, TS_Mesh target, double percent)
        {
            Channel.MeshDefinition definition = channel.NextMesh();
            if (target == null) target = new TS_Mesh();
            definition.Write(target, channel.overrideMaterialID ? channel.targetMaterialID : -1);
            Vector2 channelOffset = channel.NextRandomOffset();
            Quaternion channelRotation = channel.NextRandomQuaternion();

            var customValues = channel.GetCustomPlaceValues(percent);

            Vector2 finalOffset = channelOffset + customValues.Item1 + new Vector2(offset.x, offset.y);
            Quaternion finalRotation = channelRotation * Quaternion.AngleAxis(rotation, Vector3.forward) * customValues.Item2;
            Vector3 finalScale = channel.NextPlaceScale();

            Evaluate(percent, ref evalResult);
            Vector3 originalNormal = evalResult.up;
            Vector3 originalRight = evalResult.right;
            Vector3 originalDirection = evalResult.forward;
            if (channel.overrideNormal)
            {
                evalResult.forward = Vector3.Cross(evalResult.right, channel.customNormal);
                evalResult.up = channel.customNormal;
            }

            if (!channel.scaleModifier.useClippedPercent)
            {
                UnclipPercent(ref evalResult.percent);
            }
            Vector3 scaleMod = channel.scaleModifier.GetScale(evalResult);
            finalScale.x *= customValues.Item3.x * scaleMod.x;
            finalScale.y *= customValues.Item3.y * scaleMod.y;
            finalScale.z *= customValues.Item3.z * scaleMod.z;

            if (!channel.scaleModifier.useClippedPercent)
            {
                ClipPercent(ref evalResult.percent);
            }

            float resultSize = GetBaseSize(evalResult);
            _vertexMatrix.SetTRS(evalResult.position + originalRight * (finalOffset.x * resultSize) + originalNormal * (finalOffset.y * resultSize) + originalDirection * offset.z, //Position
                evalResult.rotation * finalRotation, //Rotation
                finalScale * resultSize ); //Scale
            _normalMatrix = _vertexMatrix.inverse.transpose;

            for (int i = 0; i < target.vertexCount; i++)
            {
                target.vertices[i] = _vertexMatrix.MultiplyPoint3x4(definition.vertices[i]);
                target.normals[i] = _normalMatrix.MultiplyVector(definition.normals[i]);
            }
            for (int i = 0; i < Mathf.Min(target.colors.Length, definition.colors.Length); i++)
            {
                target.colors[i] = definition.colors[i] * evalResult.color * color;
            }
        }

        private void Extrude(Channel channel, TS_Mesh target, double from, double to)
        {
            Channel.MeshDefinition definition = channel.NextMesh();
            if (target == null) target = new TS_Mesh();
            definition.Write(target, channel.overrideMaterialID ? channel.targetMaterialID : -1);
            Vector2 uv = Vector2.zero;
            Vector3 trsVector = Vector3.zero;

            Vector3 channelOffset = channel.NextRandomOffset();
            Vector3 channelScale = channel.NextRandomScale();
            float channelRotation = channel.NextRandomAngle();

            for (int i = 0; i < definition.vertexGroups.Count; i++)
            {
                if (_useLastResult && i == definition.vertexGroups.Count)
                {
                    evalResult = _lastResult;
                }
                else
                {
                    Evaluate(DMath.Lerp(from, to, definition.vertexGroups[i].percent), ref evalResult);
                }

                Vector3 originalNormal = evalResult.up;
                Vector3 originalRight = evalResult.right;
                Vector3 originalDirection = evalResult.forward;
                if (channel.overrideNormal)
                {
                    evalResult.forward = Vector3.Cross(evalResult.right, channel.customNormal);
                    evalResult.up = channel.customNormal;
                }
                var customValues = channel.GetCustomExtrudeValues(evalResult.percent);
                Vector3 finalOffset = offset + channelOffset + (Vector3)customValues.Item1;
                float finalRotation = rotation + channelRotation + customValues.Item2;
                Vector3 finalScale = channelScale;
                if (!channel.scaleModifier.useClippedPercent)
                {
                    UnclipPercent(ref evalResult.percent);
                }
                Vector2 scaleMod = channel.scaleModifier.GetScale(evalResult);
                if (!channel.scaleModifier.useClippedPercent)
                {
                    ClipPercent(ref evalResult.percent);
                }
                finalScale.x *= customValues.Item3.x * scaleMod.x;
                finalScale.y *= customValues.Item3.y * scaleMod.y;
                finalScale.z = 1f;
                float resultSize = evalResult.size;
                _vertexMatrix.SetTRS(evalResult.position + originalRight * (finalOffset.x * resultSize) + originalNormal * (finalOffset.y * resultSize) + originalDirection * offset.z, //Position
                    evalResult.rotation * Quaternion.AngleAxis(finalRotation, Vector3.forward), //Rotation
                    finalScale * resultSize); //Scale
                _normalMatrix = _vertexMatrix.inverse.transpose;
                if (i == 0)
                {
                    _lastResult = evalResult;
                }

                for (int n = 0; n < definition.vertexGroups[i].ids.Length; n++)
                {
                    int index = definition.vertexGroups[i].ids[n];
                    trsVector = definition.vertices[index];
                    trsVector.z = 0f;
                    target.vertices[index] = _vertexMatrix.MultiplyPoint3x4(trsVector);
                    trsVector = definition.normals[index];
                    target.normals[index] = _normalMatrix.MultiplyVector(trsVector);
                    target.colors[index] = target.colors[index] * evalResult.color * color;
                    if (target.uv.Length > index)
                    {
                        uv = target.uv[index];
                        switch (channel.overrideUVs)
                        {
                            case Channel.UVOverride.ClampU: uv.x = (float)evalResult.percent; break;
                            case Channel.UVOverride.ClampV: uv.y = (float)evalResult.percent; break;
                            case Channel.UVOverride.UniformU: uv.x = CalculateLength(0.0, evalResult.percent); break;
                            case Channel.UVOverride.UniformV: uv.y = CalculateLength(0.0, evalResult.percent); break;
                        }
                        target.uv[index] = new Vector2(uv.x * uvScale.x * channel.uvScale.x, uv.y * uvScale.y * channel.uvScale.y);
                        target.uv[index] += uvOffset + channel.uvOffset;
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMesh.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMeshChannel.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 116eda7a4c26e224ab08142aea1ddf31
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections.Generic;

namespace Dreamteck.Splines
{
    public partial class SplineMesh : MeshGenerator
    {

        [System.Serializable]
        public class Channel
        {
            public delegate float FloatHandler(double percent);
            public delegate Vector2 Vector2Handler(double percent);
            public delegate Vector3 Vector3Handler(double percent);
            public delegate Quaternion QuaternionHandler(double percent);

            public string name = "Channel";
            public enum Type { Extrude, Place }
            public enum UVOverride { None, ClampU, ClampV, UniformU, UniformV }

            private System.Random iterationRandom;
            [SerializeField]
            [HideInInspector]
            private int _iterationSeed = 0;
            [SerializeField]
            [HideInInspector]
            private int _offsetSeed = 0;
            private System.Random _offsetRandom;
            private Vector2Handler _offsetHandler = null;
            [SerializeField]
            [HideInInspector]
            private int _rotationSeed = 0;
            private System.Random _rotationRandom;
            private QuaternionHandler _placeRotationHandler = null;
            private FloatHandler _extrudeRotationHandler = null;
            [SerializeField]
            [HideInInspector]
            private int _scaleSeed = 0;
            private System.Random _scaleRandom;
            private Vector3Handler _scaleHandler = null;

            [SerializeField]
            internal SplineMesh owner = null;

            [SerializeField]
            [HideInInspector]
            private List<MeshDefinition> meshes = new List<MeshDefinition>();


            [SerializeField]
            [HideInInspector]
            private double _clipFrom = 0.0;
            [SerializeField]
            [HideInInspector]
            private double _clipTo = 1.0;
            [SerializeField]
            [HideInInspector]
            private bool _randomOrder = false;
            [SerializeField]
            [HideInInspector]
            private UVOverride _overrideUVs = UVOverride.None;
            [SerializeField]
            [HideInInspector]
            private Vector2 _uvScale = Vector2.one;
            [SerializeField]
            [HideInInspector]
            private Vector2 _uvOffset = Vector2.zero;
            [SerializeField]
            [HideInInspector]
            private bool _overrideNormal = false;
            [SerializeField]
            [HideInInspector]
            private Vector3 _customNormal = Vector3.up;
            [SerializeField]
            [HideInInspector]
            private Type _type = Type.Extrude;

            [SerializeField]
            [HideInInspector]
            private int _count = 1;
            [SerializeField]
            [HideInInspector]
            private bool _autoCount = false;
            [SerializeField]
            [HideInInspector]
            private double _spacing = 0.0;
            [SerializeField]
            [HideInInspector]
            private bool _randomRotation = false;
            [SerializeField]
            [HideInInspector]
            private Vector3 _minRotation = Vector3.zero;
            [SerializeField]
            [HideInInspector]
            private Vector3 _maxRotation = Vector3.zero;
            [SerializeField]
            [HideInInspector]
            private bool _randomOffset = false;
            [SerializeField]
            [HideInInspector]
            private Vector2 _minOffset = Vector2.one;
            [SerializeField]
            [HideInInspector]
            private Vector2 _maxOffset = Vector2.one;
            [SerializeField]
            [HideInInspector]
            private bool _randomScale = false;
            [SerializeField]
            [HideInInspector]
            private bool _uniformRandomScale = false;
            [SerializeField]
            [HideInInspector]
            private Vector3 _minScale = Vector3.one;
            [SerializeField]
            [HideInInspector]
            private Vector3 _maxScale = Vector3.one;
            private int iterator = 0;
            [SerializeField]
            [HideInInspector]
            private bool _overrideMaterialID = false;
            [SerializeField]
            [HideInInspector]
            private int _targetMaterialID = 0;

            [SerializeField]
            [HideInInspector]
            protected MeshScaleModifier _scaleModifier = new MeshScaleModifier();

            public double clipFrom
            {
                get { return _clipFrom; }
                set
                {
                    if (value != _clipFrom)
                    {
                        _clipFrom = value;
                        Rebuild();
                    }
                }
            }

            public double clipTo
            {
                get { return _clipTo; }
                set
                {
                    if (value != _clipTo)
                    {
                        _clipTo = value;
                        Rebuild();
                    }
                }
            }

            public bool randomOffset
            {
                get { return _randomOffset; }
                set
                {
                    if (value != _randomOffset)
                    {
                        _randomOffset = value;
                        Rebuild();
                    }
                }
            }

            public Vector2Handler offsetHandler
            {
                get { return _offsetHandler; }
                set
                {
                    if (value != _offsetHandler)
                    {
                        _offsetHandler = value;
                        Rebuild();
                    }
                }
            }

            public bool overrideMaterialID
            {
                get { return _overrideMaterialID; }
                set
                {
                    if (value != _overrideMaterialID)
                    {
                        _overrideMaterialID = value;
                        Rebuild();
                    }
                }
            }

            public int targetMaterialID
            {
                get { return _targetMaterialID; }
                set
                {
                    if (value != _targetMaterialID)
                    {
                        _targetMaterialID = value;
                        Rebuild();
                    }
                }
            }

            public bool randomRotation
            {
                get { return _randomRotation; }
                set
                {
                    if (value != _randomRotation)
                    {
                        _randomRotation = value;
                        Rebuild();
                    }
                }
            }

            public QuaternionHandler placeRotationHandler
            {
                get { return _placeRotationHandler; }
                set
                {
                    if (value != _placeRotationHandler)
                    {
                        _placeRotationHandler = value;
                        Rebuild();
                    }
                }
            }

            public FloatHandler extrudeRotationHandler
            {
                get { return _extrudeRotationHandler; }
                set
                {
                    if (value != _extrudeRotationHandler)
                    {
                        _extrudeRotationHandler = value;
                        Rebuild();
                    }
                }
            }

            public bool randomScale
            {
                get { return _randomScale; }
                set
                {
                    if (value != _randomScale)
                    {
                        _randomScale = value;
                        Rebuild();
                    }
                }
            }

            public Vector3Handler scaleHandler
            {
                get { return _scaleHandler; }
                set
                {
                    if (value != _scaleHandler)
                    {
                        _scaleHandler = value;
                        Rebuild();
                    }
                }
            }

            public bool uniformRandomScale
            {
                get { return _uniformRandomScale; }
                set
                {
                    if (value != _uniformRandomScale)
                    {
                        _uniformRandomScale = value;
                        Rebuild();
                    }
                }
            }

            public int offsetSeed
            {
                get { return _offsetSeed; }
                set
                {
                    if (value != _offsetSeed)
                    {
                        _offsetSeed = value;
                        Rebuild();
                    }
                }
            }

            public int rotationSeed
            {
                get { return _rotationSeed; }
                set
                {
                    if (value != _rotationSeed)
                    {
                        _rotationSeed = value;
                        Rebuild();
                    }
                }
            }

            public int scaleSeed
            {
                get { return _scaleSeed; }
                set
                {
                    if (value != _scaleSeed)
                    {
                        _scaleSeed = value;
                        Rebuild();
                    }
                }
            }

            public double spacing
            {
                get { return _spacing; }
                set
                {
                    if (value != _spacing)
                    {
                        _spacing = value;
                        Rebuild();
                    }
                }
            }

            public Vector2 minOffset
            {
                get { return _minOffset; }
                set
                {
                    if (value != _minOffset)
                    {
                        _minOffset = value;
                        Rebuild();
                    }
                }
            }

            public Vector2 maxOffset
            {
                get { return _maxOffset; }
                set
                {
                    if (value != _maxOffset)
                    {
                        _maxOffset = value;
                        Rebuild();
                    }
                }
            }

            public Vector3 minRotation
            {
                get { return _minRotation; }
                set
                {
                    if (value != _minRotation)
                    {
                        _minRotation = value;
                        Rebuild();
                    }
                }
            }

            public Vector3 maxRotation
            {
                get { return _maxRotation; }
                set
                {
                    if (value != _maxRotation)
                    {
                        _maxRotation = value;
                        Rebuild();
                    }
                }
            }

            public Vector3 minScale
            {
                get { return _minScale; }
                set
                {
                    if (value != _minScale)
                    {
                        _minScale = value;
                        Rebuild();
                    }
                }
            }

            public Vector3 maxScale
            {
                get { return _maxScale; }
                set
                {
                    if (value != _maxScale)
                    {
                        _maxScale = value;
                        Rebuild();
                    }
                }
            }

            public Type type
            {
                get { return _type; }
                set
                {
                    if (value != _type)
                    {
                        _type = value;
                        Rebuild();
                    }
                }
            }

            public bool randomOrder
            {
                get { return _randomOrder; }
                set
                {
                    if (value != _randomOrder)
                    {
                        _randomOrder = value;
                        Rebuild();
                    }
                }
            }

            public int randomSeed
            {
                get { return _iterationSeed; }
                set
                {
                    if (value != _iterationSeed)
                    {
                        _iterationSeed = value;
                        if (_randomOrder) Rebuild();
                    }
                }
            }
            public int count
            {
                get { return _count; }
                set
                {
                    if (value != _count)
                    {
                        _count = value;
                        if (_count < 1) _count = 1;
                        Rebuild();
                    }
                }
            }

            public bool autoCount
            {
                get { return _autoCount; }
                set
                {
                    if (value != _autoCount)
                    {
                        _autoCount = value;
                        Rebuild();
                    }
                }
            }

            public UVOverride overrideUVs
            {
                get { return _overrideUVs; }
                set
                {
                    if (value != _overrideUVs)
                    {
                        _overrideUVs = value;
                        Rebuild();
                    }
                }
            }

            public Vector2 uvOffset
            {
                get { return _uvOffset; }
                set
                {
                    if (value != _uvOffset)
                    {
                        _uvOffset = value;
                        Rebuild();
                    }
                }
            }

            public Vector2 uvScale
            {
                get { return _uvScale; }
                set
                {
                    if (value != _uvScale)
                    {
                        _uvScale = value;
                        Rebuild();
                    }
                }
            }

            public bool overrideNormal
            {
                get { return _overrideNormal; }
                set
                {
                    if (value != _overrideNormal)
                    {
                        _overrideNormal = value;
                        Rebuild();
                    }
                }
            }

            public Vector3 customNormal
            {
                get { return _customNormal; }
                set
                {
                    if (value != _customNormal)
                    {
                        _customNormal = value;
                        Rebuild();
                    }
                }
            }

            public MeshScaleModifier scaleModifier
            {
                get
                {
                    return _scaleModifier;
                }
            }

            public Channel(string n, SplineMesh parent)
            {
                name = n;
                owner = parent;
                Init();
            }

            public Channel(string n, Mesh inputMesh, SplineMesh parent)
            {
                name = n;
                owner = parent;
                meshes.Add(new MeshDefinition(inputMesh));
                Init();
                Rebuild();
            }

            void Init()
            {
                _minScale = _maxScale = Vector3.one;
                _minOffset = _maxOffset = Vector3.zero;
                _minRotation = _maxRotation = Vector3.zero;
            }

            public void CopyTo(Channel target)
            {
                target.meshes.Clear();
                for (int i = 0; i < meshes.Count; i++) target.meshes.Add(meshes[i].Copy());
                target._clipFrom = _clipFrom;
                target._clipTo = _clipTo;
                target._customNormal = _customNormal;
                target._iterationSeed = _iterationSeed;
                target._minOffset = _minOffset;
                target._minRotation = _minRotation;
                target._minScale = _minScale;
                target._maxOffset = _maxOffset;
                target._maxRotation = _maxRotation;
                target._maxScale = _maxScale;
                target._randomOffset = _randomOffset;
                target._randomRotation = _randomRotation;
                target._randomScale = _randomScale;
                target._offsetSeed = _offsetSeed;
                target._offsetHandler = _offsetHandler;
                target._rotationSeed = _rotationSeed;
                target._placeRotationHandler = _placeRotationHandler;
                target._extrudeRotationHandler = _extrudeRotationHandler;
                target._scaleSeed = _scaleSeed;
                target._scaleHandler = _scaleHandler;
                target._iterationSeed = _iterationSeed;
                target._count = _count;
                target._spacing = _spacing;
                target._overrideUVs = _overrideUVs;
                target._type = _type;
                target._overrideMaterialID = _overrideMaterialID;
                target._targetMaterialID = _targetMaterialID;
                target._overrideNormal = _overrideNormal;
            }

            public int GetMeshCount()
            {
                return meshes.Count;
            }

            public void SwapMeshes(int a, int b)
            {
                if (a < 0 || a >= meshes.Count || b < 0 || b >= meshes.Count) return;
                MeshDefinition temp = meshes[b];
                meshes[b] = meshes[a];
                meshes[a] = temp;
                Rebuild();
            }

            public void DuplicateMesh(int index)
            {
                if (index < 0 || index >= meshes.Count) return;
                meshes.Add(meshes[index].Copy());
                Rebuild();
            }

            public MeshDefinition GetMesh(int index)
            {
                return meshes[index];
            }

            public void AddMesh(Mesh input)
            {
                meshes.Add(new MeshDefinition(input));
                Rebuild();
            }

            public void AddMesh(MeshDefinition meshDefinition)
            {
                if (!meshes.Contains(meshDefinition))
                {
                    meshes.Add(meshDefinition);
                    Rebuild();
                }
            }

            public void RemoveMesh(int index)
            {
                meshes.RemoveAt(index);
                Rebuild();
            }

            public void ResetIteration()
            {
                if (_randomOrder) iterationRandom = new System.Random(_iterationSeed);
                if (_randomOffset) _offsetRandom = new System.Random(_offsetSeed);
                if (_randomRotation) _rotationRandom = new System.Random(_rotationSeed);
                if (_randomScale) _scaleRandom = new System.Random(_scaleSeed);
                iterator = 0;
            }

            public (Vector2, Quaternion, Vector3) GetCustomPlaceValues(double percent)
            {
                (Vector2, Quaternion, Vector3) values = (Vector2.zero, Quaternion.identity, Vector3.one);
                if (_offsetHandler != null)
                {
                    values.Item1 = _offsetHandler(percent);
                }
                if (_placeRotationHandler != null)
                {
                    values.Item2 = _placeRotationHandler(percent);
                }
                if (_scaleHandler != null)
                {
                    values.Item3 = _scaleHandler(percent);
                }
                return values;
            }

            public (Vector2, float, Vector3) GetCustomExtrudeValues(double percent)
            {
                (Vector2, float, Vector3) values = (Vector2.zero, 0f, Vector3.one);
                if (_offsetHandler != null)
                {
                    values.Item1 = _offsetHandler(percent);
                }
                if (_extrudeRotationHandler != null)
                {
                    values.Item2 = _extrudeRotationHandler(percent);
                }
                if (_scaleHandler != null)
                {
                    values.Item3 = _scaleHandler(percent);
                }
                return values;
            }

            public Vector2 NextRandomOffset()
            {
                if (_randomOffset) return new Vector2(Mathf.Lerp(_minOffset.x, _maxOffset.x, (float)_offsetRandom.NextDouble()), Mathf.Lerp(_minOffset.y, _maxOffset.y, (float)_offsetRandom.NextDouble()));
                return _minOffset;
            }

            public Quaternion NextRandomQuaternion()
            {
                if (_randomRotation) return Quaternion.Euler(new Vector3(Mathf.Lerp(_minRotation.x, _maxRotation.x, (float)_rotationRandom.NextDouble()), Mathf.Lerp(_minRotation.y, _maxRotation.y, (float)_rotationRandom.NextDouble()), Mathf.Lerp(_minRotation.z, _maxRotation.z, (float)_rotationRandom.NextDouble())));
                return Quaternion.Euler(_minRotation);
            }

            public float NextRandomAngle()
            {
                if (_randomRotation) return Mathf.Lerp(_minRotation.z, _maxRotation.z, (float)_rotationRandom.NextDouble());
                return _minRotation.z;
            }

            public Vector3 NextRandomScale()
            {
                if (_randomScale)
                {
                    if (_uniformRandomScale) return Vector3.Lerp(new Vector3(_minScale.x, _minScale.y, 1f), new Vector3(_maxScale.x, _maxScale.y, 1f), (float)_scaleRandom.NextDouble());
                    return new Vector3(Mathf.Lerp(_minScale.x, _maxScale.x, (float)_scaleRandom.NextDouble()), Mathf.Lerp(_minScale.y, _maxScale.y, (float)_scaleRandom.NextDouble()), 1f);
                }
                return new Vector3(_minScale.x, _minScale.y, 1f);
            }

            public Vector3 NextPlaceScale()
            {
                if (_randomScale)
                {
                    if (_uniformRandomScale) return Vector3.Lerp(_minScale, _maxScale, (float)_scaleRandom.NextDouble());
                    return new Vector3(Mathf.Lerp(_minScale.x, _maxScale.x, (float)_scaleRandom.NextDouble()), Mathf.Lerp(_minScale.y, _maxScale.y, (float)_scaleRandom.NextDouble()), Mathf.Lerp(_minScale.z, _maxScale.z, (float)_scaleRandom.NextDouble()));
                }
                return _minScale;
            }

            public MeshDefinition NextMesh()
            {
                if (_randomOrder) return meshes[iterationRandom.Next(meshes.Count)];
                else
                {
                    if (iterator >= meshes.Count) iterator = 0;
                    return meshes[iterator++];
                }
            }

            internal void Rebuild()
            {
                if (owner != null) owner.Rebuild();
            }

            void Refresh()
            {
                for (int i = 0; i < meshes.Count; i++) meshes[i].Refresh();
                Rebuild();
            }

            [System.Serializable]
            public struct BoundsSpacing
            {
                public float front;
                public float back;
            }

            [System.Serializable]
            public class MeshDefinition
            {
                public enum MirrorMethod { None, X, Y, Z }
                [SerializeField]
                [HideInInspector]
                public Vector3[] vertices = new Vector3[0];
                [SerializeField]
                [HideInInspector]
                public Vector3[] normals = new Vector3[0];
                [SerializeField]
                [HideInInspector]
                public Vector4[] tangents = new Vector4[0];
                [SerializeField]
                [HideInInspector]
                public Color[] colors = new Color[0];
                [SerializeField]
                [HideInInspector]
                public Vector2[] uv = new Vector2[0];
                [SerializeField]
                [HideInInspector]
                public Vector2[] uv2 = new Vector2[0];
                [SerializeField]
                [HideInInspector]
                public Vector2[] uv3 = new Vector2[0];
                [SerializeField]
                [HideInInspector]
                public Vector2[] uv4 = new Vector2[0];
                [SerializeField]
                [HideInInspector]
                public int[] triangles = new int[0];
                [SerializeField]
                [HideInInspector]
                public List<Submesh> subMeshes = new List<Submesh>();
                [SerializeField]
                [HideInInspector]
                public TS_Bounds bounds = new TS_Bounds(Vector3.zero, Vector3.zero);
                [SerializeField]
                [HideInInspector]
                public List<VertexGroup> vertexGroups = new List<VertexGroup>();
                [SerializeField]
                [HideInInspector]
                private Mesh _mesh = null;
                [SerializeField]
                [HideInInspector]
                private Vector3 _rotation = Vector3.zero;
                [SerializeField]
                [HideInInspector]
                private Vector3 _offset = Vector3.zero;
                [SerializeField]
                [HideInInspector]
                private Vector3 _scale = Vector3.one;
                [SerializeField]
                [HideInInspector]
                private Vector2 _uvScale = Vector2.one;
                [SerializeField]
                [HideInInspector]
                private Vector2 _uvOffset = Vector2.zero;
                [SerializeField]
                [HideInInspector]
                private float _uvRotation = 0f;
                [SerializeField]
                [HideInInspector]
                private MirrorMethod _mirror = MirrorMethod.None;
                [SerializeField]
                [HideInInspector]
                public BoundsSpacing _spacing = new BoundsSpacing();

                [SerializeField]
                [HideInInspector]
                private float _vertexGroupingMargin = 0f;
                [SerializeField]
                [HideInInspector]
                private bool _removeInnerFaces = false;
                [SerializeField]
                [HideInInspector]
                private bool _flipFaces = false;
                [SerializeField]
                [HideInInspector]
                private bool _doubleSided = false;

                public Mesh mesh
                {
                    get
                    {
                        return _mesh;
                    }
                    set
                    {
                        if (_mesh != value)
                        {
                            _mesh = value;
                            Refresh();
                        }
                    }
                }

                public Vector3 rotation
                {
                    get
                    {
                        return _rotation;
                    }
                    set
                    {
                        if (rotation != value)
                        {
                            _rotation = value;
                            Refresh();
                        }
                    }
                }

                public Vector3 offset
                {
                    get
                    {
                        return _offset;
                    }
                    set
                    {
                        if (_offset != value)
                        {
                            _offset = value;
                            Refresh();
                        }
                    }
                }

                public Vector3 scale
                {
                    get
                    {
                        return _scale;
                    }
                    set
                    {
                        if (_scale != value)
                        {
                            _scale = value;
                            Refresh();
                        }
                    }
                }

                public BoundsSpacing spacing
                {
                    get
                    {
                        return _spacing;
                    }
                    set
                    {
                        if (_spacing.back != value.back || _spacing.front != value.front)
                        {
                            _spacing = value;
                            Refresh();
                        }
                    }
                }

                public Vector2 uvScale
                {
                    get
                    {
                        return _uvScale;
                    }
                    set
                    {
                        if (_uvScale != value)
                        {
                            _uvScale = value;
                            Refresh();
                        }
                    }
                }

                public Vector2 uvOffset
                {
                    get
                    {
                        return _uvOffset;
                    }
                    set
                    {
                        if (_uvOffset != value)
                        {
                            _uvOffset = value;
                            Refresh();
                        }
                    }
                }

                public float uvRotation
                {
                    get
                    {
                        return _uvRotation;
                    }
                    set
                    {
                        if (_uvRotation != value)
                        {
                            _uvRotation = value;
                            Refresh();
                        }
                    }
                }

                public float vertexGroupingMargin
                {
                    get
                    {
                        return _vertexGroupingMargin;
                    }
                    set
                    {
                        if (_vertexGroupingMargin != value)
                        {
                            _vertexGroupingMargin = value;
                            Refresh();
                        }
                    }
                }

                public MirrorMethod mirror
                {
                    get { return _mirror; }
                    set
                    {
                        if (_mirror != value)
                        {
                            _mirror = value;
                            Refresh();
                        }
                    }
                }

                public bool removeInnerFaces
                {
                    get { return _removeInnerFaces; }
                    set
                    {
                        if (_removeInnerFaces != value)
                        {
                            _removeInnerFaces = value;
                            Refresh();
                        }
                    }
                }

                public bool flipFaces
                {
                    get { return _flipFaces; }
                    set
                    {
                        if (_flipFaces != value)
                        {
                            _flipFaces = value;
                            Refresh();
                        }
                    }
                }

                public bool doubleSided
                {
                    get { return _doubleSided; }
                    set
                    {
                        if (_doubleSided != value)
                        {
                            _doubleSided = value;
                            Refresh();
                        }
                    }
                }

                internal MeshDefinition Copy()
                {
                    MeshDefinition target = new MeshDefinition(_mesh);
                    target.vertices = new Vector3[vertices.Length];
                    target.normals = new Vector3[normals.Length];
                    target.colors = new Color[colors.Length];
                    target.tangents = new Vector4[tangents.Length];
                    target.uv = new Vector2[uv.Length];
                    target.uv2 = new Vector2[uv2.Length];
                    target.uv3 = new Vector2[uv3.Length];
                    target.uv4 = new Vector2[uv4.Length];
                    target.triangles = new int[triangles.Length];

                    vertices.CopyTo(target.vertices, 0);
                    normals.CopyTo(target.normals, 0);
                    colors.CopyTo(target.colors, 0);
                    tangents.CopyTo(target.tangents, 0);
                    uv.CopyTo(target.uv, 0);
                    uv2.CopyTo(target.uv2, 0);
                    uv3.CopyTo(target.uv3, 0);
                    uv4.CopyTo(target.uv4, 0);
                    triangles.CopyTo(target.triangles, 0);

                    target.bounds = new TS_Bounds(bounds.min, bounds.max);
                    target.subMeshes = new List<Submesh>();
                    for (int i = 0; i < subMeshes.Count; i++)
                    {
                        target.subMeshes.Add(new Submesh(new int[subMeshes[i].triangles.Length]));
                        subMeshes[i].triangles.CopyTo(target.subMeshes[target.subMeshes.Count - 1].triangles, 0);
                    }

                    target._mirror = _mirror;
                    target._offset = _offset;
                    target._rotation = _rotation;
                    target._scale = _scale;
                    target._uvOffset = _uvOffset;
                    target._uvScale = _uvScale;
                    target._uvRotation = _uvRotation;
                    target._flipFaces = _flipFaces;
                    target._doubleSided = _doubleSided;
                    return target;
                }

                public MeshDefinition(Mesh input)
                {
                    _mesh = input;
                    Refresh();
                }

                public void Refresh()
                {
                    if (_mesh == null)
                    {
                        vertices = new Vector3[0];
                        normals = new Vector3[0];
                        colors = new Color[0];
                        uv = new Vector2[0];
                        uv2 = new Vector2[0];
                        uv3 = new Vector2[0];
                        uv4 = new Vector2[0];
                        tangents = new Vector4[0];
                        triangles = new int[0];
                        subMeshes = new List<Submesh>();
                        vertexGroups = new List<VertexGroup>();
                        return;
                    }
                    if (vertices.Length != _mesh.vertexCount) vertices = new Vector3[_mesh.vertexCount];
                    if (normals.Length != _mesh.normals.Length) normals = new Vector3[_mesh.normals.Length];
                    if (colors.Length != _mesh.colors.Length) colors = new Color[_mesh.colors.Length];
                    if (uv.Length != _mesh.uv.Length) uv = new Vector2[_mesh.uv.Length];
                    if (uv2.Length != _mesh.uv2.Length) uv2 = new Vector2[_mesh.uv2.Length];
                    if (uv3.Length != _mesh.uv3.Length) uv3 = new Vector2[_mesh.uv3.Length];
                    if (uv4.Length != _mesh.uv4.Length) uv4 = new Vector2[_mesh.uv4.Length];
                    if (tangents.Length != _mesh.tangents.Length) tangents = new Vector4[_mesh.tangents.Length];
                    if (triangles.Length != _mesh.triangles.Length) triangles = new int[_mesh.triangles.Length];

                    vertices = _mesh.vertices;
                    normals = _mesh.normals;
                    colors = _mesh.colors;
                    uv = _mesh.uv;
                    uv2 = _mesh.uv2;
                    uv3 = _mesh.uv3;
                    uv4 = _mesh.uv4;
                    tangents = _mesh.tangents;
                    triangles = _mesh.triangles;
                    colors = _mesh.colors;

                    while (subMeshes.Count > _mesh.subMeshCount) subMeshes.RemoveAt(0);
                    while (subMeshes.Count < _mesh.subMeshCount) subMeshes.Add(new Submesh(new int[0]));
                    for (int i = 0; i < subMeshes.Count; i++) subMeshes[i].triangles = _mesh.GetTriangles(i);


                    if (colors.Length != vertices.Length)
                    {
                        colors = new Color[vertices.Length];
                        for (int i = 0; i < colors.Length; i++) colors[i] = Color.white;
                    }
                    Mirror();
                    if (_doubleSided) DoubleSided();
                    else if (_flipFaces) FlipFaces();
                    TransformVertices();
                    CalculateBounds();
                    if (_removeInnerFaces) RemoveInnerFaces();
                    GroupVertices();

                    if (bounds.size.z < 0.002f || bounds.size.x < 0.002f || bounds.size.y < 0.002f)
                    {
                        Debug.LogWarning($"The size of [{_mesh.name}]'s bounds is too small! This could cause an issue if the [Auto Count] option is enabled!");
                    }
                }

                void RemoveInnerFaces()
                {
                    float min = float.MaxValue, max = 0f;
                    for (int i = 0; i < vertices.Length; i++)
                    {
                        if (vertices[i].z < min) min = vertices[i].z;
                        if (vertices[i].z > max) max = vertices[i].z;
                    }

                    for (int i = 0; i < subMeshes.Count; i++)
                    {
                        List<int> newTris = new List<int>();
                        for (int j = 0; j < subMeshes[i].triangles.Length; j += 3)
                        {
                            bool innerMax = true, innerMin = true;
                            for (int k = j; k < j + 3; k++)
                            {
                                int index = subMeshes[i].triangles[k];
                                if (!Mathf.Approximately(vertices[index].z, max)) innerMax = false;
                                if (!Mathf.Approximately(vertices[index].z, min)) innerMin = false;
                            }
                            if (!innerMax && !innerMin)
                            {
                                newTris.Add(subMeshes[i].triangles[j]);
                                newTris.Add(subMeshes[i].triangles[j + 1]);
                                newTris.Add(subMeshes[i].triangles[j + 2]);
                            }
                        }
                        subMeshes[i].triangles = newTris.ToArray();
                    }
                }

                void FlipFaces()
                {
                    TS_Mesh temp = new TS_Mesh();
                    temp.normals = normals;
                    temp.tangents = tangents;
                    temp.triangles = triangles;
                    for (int i = 0; i < subMeshes.Count; i++) temp.subMeshes.Add(subMeshes[i].triangles);
                    MeshUtility.FlipFaces(temp);
                }

                void DoubleSided()
                {
                    TS_Mesh temp = new TS_Mesh();
                    temp.vertices = vertices;
                    temp.normals = normals;
                    temp.tangents = tangents;
                    temp.colors = colors;
                    temp.uv = uv;
                    temp.uv2 = uv2;
                    temp.uv3 = uv3;
                    temp.uv4 = uv4;
                    temp.triangles = triangles;
                    for (int i = 0; i < subMeshes.Count; i++) temp.subMeshes.Add(subMeshes[i].triangles);
                    MeshUtility.MakeDoublesided(temp);
                    vertices = temp.vertices;
                    normals = temp.normals;
                    tangents = temp.tangents;
                    colors = temp.colors;
                    uv = temp.uv;
                    uv2 = temp.uv2;
                    uv3 = temp.uv3;
                    uv4 = temp.uv4;
                    triangles = temp.triangles;
                    for (int i = 0; i < subMeshes.Count; i++) subMeshes[i].triangles = temp.subMeshes[i];
                }

                public void Write(TS_Mesh target, int forceMaterialId = -1)
                {
                    if (target.vertices.Length != vertices.Length) target.vertices = new Vector3[vertices.Length];
                    if (target.normals.Length != normals.Length) target.normals = new Vector3[normals.Length];
                    if (target.colors.Length != colors.Length) target.colors = new Color[colors.Length];
                    if (target.uv.Length != uv.Length) target.uv = new Vector2[uv.Length];
                    if (target.uv2.Length != uv2.Length) target.uv2 = new Vector2[uv2.Length];
                    if (target.uv3.Length != uv3.Length) target.uv3 = new Vector2[uv3.Length];
                    if (target.uv4.Length != uv4.Length) target.uv4 = new Vector2[uv4.Length];
                    if (target.tangents.Length != tangents.Length) target.tangents = new Vector4[tangents.Length];
                    if (target.triangles.Length != triangles.Length) target.triangles = new int[triangles.Length];

                    vertices.CopyTo(target.vertices, 0);
                    normals.CopyTo(target.normals, 0);
                    colors.CopyTo(target.colors, 0);
                    uv.CopyTo(target.uv, 0);
                    uv2.CopyTo(target.uv2, 0);
                    uv3.CopyTo(target.uv3, 0);
                    uv4.CopyTo(target.uv4, 0);
                    tangents.CopyTo(target.tangents, 0);
                    triangles.CopyTo(target.triangles, 0);

                    if (target.subMeshes == null) target.subMeshes = new List<int[]>();

                    if (forceMaterialId >= 0)
                    {
                        while (target.subMeshes.Count > forceMaterialId + 1) target.subMeshes.RemoveAt(0);
                        while (target.subMeshes.Count < forceMaterialId + 1) target.subMeshes.Add(new int[0]);
                        for (int i = 0; i < target.subMeshes.Count; i++)
                        {
                            if (i != forceMaterialId)
                            {
                                if (target.subMeshes[i].Length > 0) target.subMeshes[i] = new int[0];
                            }
                            else
                            {
                                if (target.subMeshes[i].Length != triangles.Length) target.subMeshes[i] = new int[triangles.Length];
                                triangles.CopyTo(target.subMeshes[i], 0);
                            }
                        }
                    }
                    else
                    {
                        while (target.subMeshes.Count > subMeshes.Count) target.subMeshes.RemoveAt(0);
                        while (target.subMeshes.Count < subMeshes.Count) target.subMeshes.Add(new int[0]);
                        for (int i = 0; i < subMeshes.Count; i++)
                        {
                            if (subMeshes[i].triangles.Length != target.subMeshes[i].Length) target.subMeshes[i] = new int[subMeshes[i].triangles.Length];
                            subMeshes[i].triangles.CopyTo(target.subMeshes[i], 0);
                        }
                    }
                }

                void CalculateBounds()
                {
                    Vector3 min = Vector3.zero;
                    Vector3 max = Vector3.zero;
                    for (int i = 0; i < vertices.Length; i++)
                    {
                        if (vertices[i].x < min.x) min.x = vertices[i].x;
                        else if (vertices[i].x > max.x) max.x = vertices[i].x;
                        if (vertices[i].y < min.y) min.y = vertices[i].y;
                        else if (vertices[i].y > max.y) max.y = vertices[i].y;
                        if (vertices[i].z < min.z) min.z = vertices[i].z;
                        else if (vertices[i].z > max.z) max.z = vertices[i].z;
                    }

                    min.z -= spacing.back;
                    max.z += spacing.front;
                    bounds.CreateFromMinMax(min, max);
                }

                private void Mirror()
                {
                    if (_mirror == MirrorMethod.None) return;
                    switch (_mirror)
                    {
                        case MirrorMethod.X:
                            for (int i = 0; i < vertices.Length; i++)
                            {
                                vertices[i].x *= -1f;
                                normals[i].x = -normals[i].x;
                            }
                            break;
                        case MirrorMethod.Y:
                            for (int i = 0; i < vertices.Length; i++)
                            {
                                vertices[i].y *= -1f;
                                normals[i].y = -normals[i].y;
                            }
                            break;
                        case MirrorMethod.Z:
                            for (int i = 0; i < vertices.Length; i++)
                            {
                                vertices[i].z *= -1f;
                                normals[i].z = -normals[i].z;
                            }
                            break;
                    }
                    for (int i = 0; i < triangles.Length; i += 3)
                    {
                        int temp = triangles[i];
                        triangles[i] = triangles[i + 2];
                        triangles[i + 2] = temp;
                    }
                    for (int i = 0; i < subMeshes.Count; i++)
                    {
                        for (int j = 0; j < subMeshes[i].triangles.Length; j += 3)
                        {
                            int temp = subMeshes[i].triangles[j];
                            subMeshes[i].triangles[j] = subMeshes[i].triangles[j + 2];
                            subMeshes[i].triangles[j + 2] = temp;
                        }
                    }
                    CalculateTangents();
                }

                void TransformVertices()
                {
                    Matrix4x4 vertexMatrix = new Matrix4x4();
                    vertexMatrix.SetTRS(_offset, Quaternion.Euler(_rotation), _scale);
                    Matrix4x4 normalMatrix = vertexMatrix.inverse.transpose;
                    for (int i = 0; i < vertices.Length; i++)
                    {
                        vertices[i] = vertexMatrix.MultiplyPoint3x4(vertices[i]);
                        normals[i] = normalMatrix.MultiplyVector(normals[i]).normalized;
                    }
                    for (int i = 0; i < tangents.Length; i++) tangents[i] = normalMatrix.MultiplyVector(tangents[i]);
                    for (int i = 0; i < uv.Length; i++)
                    {
                        uv[i].x *= _uvScale.x;
                        uv[i].y *= _uvScale.y;
                        uv[i] += _uvOffset;
                        uv[i] = Quaternion.AngleAxis(uvRotation, Vector3.forward) * uv[i];
                    }
                }

                void GroupVertices()
                {
                    vertexGroups = new List<VertexGroup>();

                    for (int i = 0; i < vertices.Length; i++)
                    {
                        float value = vertices[i].z;
                        double percent = DMath.Clamp01(DMath.InverseLerp(bounds.min.z, bounds.max.z, value));
                        int index = FindInsertIndex(vertices[i], value);
                        if (index >= vertexGroups.Count) vertexGroups.Add(new VertexGroup(value, percent, new int[] { i }));
                        else
                        {
                            float valueDelta = Mathf.Abs(vertexGroups[index].value - value);
                            if (valueDelta < vertexGroupingMargin || Mathf.Approximately(valueDelta, vertexGroupingMargin)) vertexGroups[index].AddId(i);
                            else if (vertexGroups[index].value < value) vertexGroups.Insert(index, new VertexGroup(value, percent, new int[] { i }));
                            else
                            {
                                if (index < vertexGroups.Count - 1) vertexGroups.Insert(index + 1, new VertexGroup(value, percent, new int[] { i }));
                                else vertexGroups.Add(new VertexGroup(value, percent, new int[] { i }));
                            }
                        }
                    }
                }

                int FindInsertIndex(Vector3 pos, float value)
                {
                    int lower = 0;
                    int upper = vertexGroups.Count - 1;

                    while (lower <= upper)
                    {
                        int middle = lower + (upper - lower) / 2;
                        if (vertexGroups[middle].value == value) return middle;
                        else if (vertexGroups[middle].value < value) upper = middle - 1;
                        else lower = middle + 1;
                    }
                    return lower;
                }

                void CalculateTangents()
                {
                    if (vertices.Length == 0)
                    {
                        tangents = new Vector4[0];
                        return;
                    }
                    tangents = new Vector4[vertices.Length];
                    Vector3[] tan1 = new Vector3[vertices.Length];
                    Vector3[] tan2 = new Vector3[vertices.Length];
                    for (int i = 0; i < subMeshes.Count; i++)
                    {
                        for (int j = 0; j < subMeshes[i].triangles.Length; j += 3)
                        {
                            int i1 = subMeshes[i].triangles[j];
                            int i2 = subMeshes[i].triangles[j + 1];
                            int i3 = subMeshes[i].triangles[j + 2];
                            float x1 = vertices[i2].x - vertices[i1].x;
                            float x2 = vertices[i3].x - vertices[i1].x;
                            float y1 = vertices[i2].y - vertices[i1].y;
                            float y2 = vertices[i3].y - vertices[i1].y;
                            float z1 = vertices[i2].z - vertices[i1].z;
                            float z2 = vertices[i3].z - vertices[i1].z;
                            float s1 = uv[i2].x - uv[i1].x;
                            float s2 = uv[i3].x - uv[i1].x;
                            float t1 = uv[i2].y - uv[i1].y;
                            float t2 = uv[i3].y - uv[i1].y;
                            float div = s1 * t2 - s2 * t1;
                            float r = div == 0f ? 0f : 1f / div;
                            Vector3 sdir = new Vector3((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
                            Vector3 tdir = new Vector3((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
                            tan1[i1] += sdir;
                            tan1[i2] += sdir;
                            tan1[i3] += sdir;
                            tan2[i1] += tdir;
                            tan2[i2] += tdir;
                            tan2[i3] += tdir;
                        }
                    }
                    for (int i = 0; i < vertices.Length; i++)
                    {
                        Vector3 n = normals[i];
                        Vector3 t = tan1[i];
                        Vector3.OrthoNormalize(ref n, ref t);
                        tangents[i].x = t.x;
                        tangents[i].y = t.y;
                        tangents[i].z = t.z;
                        tangents[i].w = (Vector3.Dot(Vector3.Cross(n, t), tan2[i]) < 0.0f) ? -1.0f : 1.0f;
                    }
                }

                [System.Serializable]
                public class Submesh
                {
                    public int[] triangles = new int[0];

                    public Submesh()
                    {

                    }

                    public Submesh(int[] input)
                    {
                        triangles = new int[input.Length];
                        input.CopyTo(triangles, 0);
                    }
                }

                [System.Serializable]
                public class VertexGroup
                {
                    public float value = 0f;
                    public double percent = 0.0;
                    public int[] ids;

                    public VertexGroup(float val, double perc, int[] vertIds)
                    {
                        percent = perc;
                        value = val;
                        ids = vertIds;
                    }

                    public void AddId(int id)
                    {
                        int[] newIds = new int[ids.Length + 1];
                        ids.CopyTo(newIds, 0);
                        newIds[newIds.Length - 1] = id;
                        ids = newIds;
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMeshChannel.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMorph.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f3bc3656a791f444ca225a99f9333768
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;
    [AddComponentMenu("Dreamteck/Splines/Morph")]
    public class SplineMorph : MonoBehaviour
    {
        [HideInInspector]
        public SplineComputer.Space space = SplineComputer.Space.Local;
        [HideInInspector]
        public bool cycle = false;
        public enum CycleMode {Default, Loop, PingPong}
        public enum UpdateMode {Update, FixedUpdate, LateUpdate}
        [HideInInspector]
        public CycleMode cycleMode = CycleMode.Default;
        [HideInInspector]
        public UpdateMode cycleUpdateMode = UpdateMode.Update;
        [HideInInspector]
        public float cycleDuration = 1f;
        public SplineComputer spline
        {
            get { return _spline; }
            set
            {
                if (Application.isPlaying)
                {
                    if(channels.Length > 0 && value.pointCount != channels[0].points.Length)
                    {
                        value.SetPoints(channels[0].points, space);
                    }
                }
                _spline = value;
            }
        }

        [SerializeField]
        [HideInInspector]
        private SplineComputer _spline;
        private SplinePoint[] points = new SplinePoint[0];
        private float cycleValue = 0f;
        private short cycleDirection = 1;


        [System.Serializable]
        public class Channel
        {
            public enum Interpolation { Linear, Spherical }
            [SerializeField]
            internal SplinePoint[] points = new SplinePoint[0];
            [SerializeField]
            internal float percent = 1f;
            public string name = "";
            public AnimationCurve curve;
            public Interpolation interpolation = Interpolation.Linear;
        }
        [HideInInspector]
        [SerializeField]
        [UnityEngine.Serialization.FormerlySerializedAs("morphStates")]
        private Channel[] channels = new Channel[0];

        private void Reset()
        {
            spline = GetComponent<SplineComputer>();
        }

        private void Update()
        {
            if (cycleUpdateMode == UpdateMode.Update) RunUpdate();
        }

        private void FixedUpdate()
        {
            if (cycleUpdateMode == UpdateMode.FixedUpdate) RunUpdate();
        }

        private void LateUpdate()
        {
            if (cycleUpdateMode == UpdateMode.LateUpdate) RunUpdate();
        }

        void RunUpdate()
        {
            if (!cycle) return;
            if (cycleMode != CycleMode.PingPong) cycleDirection = 1;
            cycleValue += Time.deltaTime / cycleDuration * cycleDirection;
            switch (cycleMode)
            {
                case CycleMode.Default:
                    if (cycleValue > 1f) cycleValue = 1f;
                    break;
                case CycleMode.Loop:
                    if (cycleValue > 1f) cycleValue -= Mathf.Floor(cycleValue);
                    break;
                case CycleMode.PingPong:
                    if (cycleValue > 1f)
                    {
                        cycleValue = 1f - (cycleValue - Mathf.Floor(cycleValue));
                        cycleDirection = -1;
                    } else if (cycleValue < 0f)
                    {
                        cycleValue = -cycleValue - Mathf.Floor(-cycleValue);
                        cycleDirection = 1;
                    }
                    break;
            }
            SetWeight(cycleValue, cycleMode == CycleMode.Loop);
        }

        public void SetCycle(float value)
        {
            cycleValue = Mathf.Clamp01(value);
        }

        public void SetWeight(int index, float weight)
        {
            channels[index].percent = Mathf.Clamp01(weight);
            UpdateMorph();
        }

        public void SetWeight(string name, float weight)
        {
            int index = GetChannelIndex(name);
            channels[index].percent = Mathf.Clamp01(weight);
            UpdateMorph();
        }

        public void SetWeight(float percent, bool loop = false)
        {
            float channelValue = percent * (loop ? channels.Length : channels.Length - 1);
            for (int i = 0; i < channels.Length; i++)
            {
                float delta = Mathf.Abs(i - channelValue);
                if (delta > 1f)
                {
                    SetWeight(i, 0f);
                }
                else
                {
                    if (channelValue <= i)
                    {
                        SetWeight(i, 1f - (i - channelValue));
                    }
                    else
                    {
                        SetWeight(i, 1f - (channelValue - i));
                    }
                }
            }
            if (loop && channelValue >= channels.Length - 1)
            {
                SetWeight(0, channelValue - (channels.Length - 1));
            }
        }

        public void CaptureSnapshot(string name)
        {
            CaptureSnapshot(GetChannelIndex(name));
        }

        public void CaptureSnapshot(int index)
        {
            if (_spline == null) return;
            if ((channels.Length > 0 && _spline.pointCount != channels[0].points.Length && index != 0))
            {
                Debug.LogError("Point count must be the same as " + _spline.pointCount);
                return;
            }
            channels[index].points = _spline.GetPoints(space);
            UpdateMorph();
        }

        public void Clear()
        {
            channels = new Channel[0];
        }

        public SplinePoint[] GetSnapshot(int index)
        {
            return channels[index].points;
        }
        public void SetSnapshot(int index, SplinePoint[] points)
        {
            channels[index].points = points;
        }


        public SplinePoint[] GetSnapshot(string name)
        {
            int index = GetChannelIndex(name);
            return channels[index].points;
        }

        public float GetWeight(int index)
        {
            return channels[index].percent;
        }

        public float GetWeight(string name)
        {
            int index = GetChannelIndex(name);
            return channels[index].percent;
        }

        public void AddChannel(string name)
        {
            if (_spline == null) return;
            if (channels.Length > 0 && _spline.pointCount != channels[0].points.Length)
            {
                Debug.LogError("Point count must be the same as " + channels[0].points.Length);
                return;
            }
            Channel newMorph = new Channel();
            newMorph.points = _spline.GetPoints(space);
            newMorph.name = name;
            newMorph.curve = new AnimationCurve();
            newMorph.curve.AddKey(new Keyframe(0, 0, 0, 1));
            newMorph.curve.AddKey(new Keyframe(1, 1, 1, 0));
            ArrayUtility.Add(ref channels, newMorph);
            UpdateMorph();
        }

        public void RemoveChannel(string name)
        {
            int index = GetChannelIndex(name);
            RemoveChannel(index);
        }

        public void RemoveChannel(int index)
        {
            if (index < 0 || index >= channels.Length) return;
            Channel[] newStates = new Channel[channels.Length - 1];
            for (int i = 0; i < channels.Length; i++)
            {
                if (i == index) continue;
                else if (i < index) newStates[i] = channels[i];
                else if (i >= index) newStates[i - 1] = channels[i];
            }
            channels = newStates;
            UpdateMorph();
        }

        private int GetChannelIndex(string name)
        {
            for (int i = 0; i < channels.Length; i++)
            {
                if (channels[i].name == name)
                {
                    return i;
                }
            }
            Debug.Log("Channel not found " + name);
            return 0;
        }

        public int GetChannelCount()
        {
            if (channels == null) return 0;
            return channels.Length;
        }

        public Channel GetChannel(int index)
        {
            return channels[index];
        }

        public Channel GetChannel(string name)
        {
            return channels[GetChannelIndex(name)];
        }

        public void UpdateMorph()
        {
            if (_spline == null) return;
            if (channels.Length == 0) return;
            if(points.Length != channels[0].points.Length)
            {
                points = new SplinePoint[channels[0].points.Length];
            }

            for (int i = 0; i < channels.Length; i++)
            {
                for (int j = 0; j < points.Length; j++)
                {
                    if(i == 0)
                    {
                        points[j] = channels[0].points[j];
                        continue;
                    }

                    float percent = channels[i].curve.Evaluate(channels[i].percent);
                    if (channels[i].interpolation == Channel.Interpolation.Linear)
                    {
                        points[j].position += (channels[i].points[j].position - channels[0].points[j].position) * percent;
                        points[j].tangent += (channels[i].points[j].tangent - channels[0].points[j].tangent) * percent;
                        points[j].tangent2 += (channels[i].points[j].tangent2 - channels[0].points[j].tangent2) * percent;
                        points[j].normal += (channels[i].points[j].normal - channels[0].points[j].normal) * percent;
                    } else
                    {
                        points[j].position = Vector3.Slerp(points[j].position, points[j].position + (channels[i].points[j].position - channels[0].points[j].position), percent);
                        points[j].tangent = Vector3.Slerp(points[j].tangent, points[j].tangent + (channels[i].points[j].tangent - channels[0].points[j].tangent), percent);
                        points[j].tangent2 = Vector3.Slerp(points[j].tangent2, points[j].tangent2 + (channels[i].points[j].tangent2 - channels[0].points[j].tangent2), percent);
                        points[j].normal = Vector3.Slerp(points[j].normal, points[j].normal + (channels[i].points[j].normal - channels[0].points[j].normal), percent);
                    }

                    points[j].color += (channels[i].points[j].color - channels[0].points[j].color) * percent;
                    points[j].size += (channels[i].points[j].size - channels[0].points[j].size) * percent;

                    if(points[j].type == SplinePoint.Type.SmoothMirrored) points[j].type = channels[i].points[j].type;
                    else if(points[j].type == SplinePoint.Type.SmoothFree)
                    {
                        if (channels[i].points[j].type == SplinePoint.Type.Broken) points[j].type = SplinePoint.Type.Broken;
                    }
                }
            }

            for (int i = 0; i < points.Length; i++)
            {
                points[i].normal.Normalize();
            }
            _spline.SetPoints(points, space);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMorph.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplinePositioner.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0def5156137c6d14082064fa7b5d5247
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;

namespace Dreamteck.Splines
{
    [AddComponentMenu("Dreamteck/Splines/Users/Spline Positioner")]
    [ExecuteInEditMode]
    public class SplinePositioner : SplineTracer
    {
        public enum Mode { Percent, Distance }

        public GameObject targetObject
        {
            get
            {
                if (_targetObject == null) return gameObject;
                return _targetObject;
            }

            set
            {
                if (value != _targetObject)
                {
                    _targetObject = value;
                    RefreshTargets();
                    Rebuild();
                }
            }
        }

        public SplineTracer followTarget
        {
            get { return _followTarget; }
            set
            {
                if(value != _followTarget)
                {
                    if(_followTarget != null)
                    {
                        _followTarget.onMotionApplied -= OnFollowTargetMotionApplied;
                    }
                    if(value == this)
                    {
                        Debug.Log("You should not be assigning a self-reference to the followTarget field.");
                        return;
                    }
                    _followTarget = value;
                    if(_followTarget != null)
                    {
                        _followTarget.onMotionApplied += OnFollowTargetMotionApplied;
                        OnFollowTargetMotionApplied();
                    }
                }
            }
        }

        public float followTargetDistance
        {
            get { return _followTargetDistance;  }
            set
            {
                if(value != _followTargetDistance)
                {
                    _followTargetDistance = value;
                    if(followTarget != null)
                    {
                        OnFollowTargetMotionApplied();
                    }
                }
            }
        }

        public bool followLoop
        {
            get { return _followLoop; }
            set
            {
                if (value != _followLoop)
                {
                    _followLoop = value;
                    if (followTarget != null)
                    {
                        OnFollowTargetMotionApplied();
                    }
                }
            }
        }

        public Spline.Direction followTargetDirection
        {
            get { return _followTargetDirection; }
            set
            {
                if (value != _followTargetDirection)
                {
                    _followTargetDirection = value;
                    if (followTarget != null)
                    {
                        OnFollowTargetMotionApplied();
                    }
                }
            }
        }

        public double position
        {
            get
            {
                return _result.percent;
            }
            set
            {
                if (value != _position)
                {
                    _position = (float)value;
                    if (mode == Mode.Distance)
                    {
                        SetDistance(_position, true, true);
                    }
                    else
                    {
                        SetPercent(value, true, true);
                    }
                }
            }
        }

        public Mode mode
        {
            get { return _mode;  }
            set
            {
                if (value != _mode)
                {
                    _mode = value;
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private GameObject _targetObject;
        [SerializeField]
        [HideInInspector]
        private SplineTracer _followTarget;
        [SerializeField]
        [HideInInspector]
        private float _followTargetDistance;
        [SerializeField]
        [HideInInspector]
        private bool _followLoop;
        [SerializeField]
        [HideInInspector]
        private Spline.Direction _followTargetDirection = Spline.Direction.Backward;
        [SerializeField]
        [HideInInspector]
        private float _position = 0f;
        [SerializeField]
        [HideInInspector]
        private Mode _mode = Mode.Percent;
        private float _lastPosition = 0f;

        private void OnFollowTargetMotionApplied()
        {
            float moved;
            double percent = Travel(followTarget.result.percent, _followTargetDistance, _followTargetDirection, out moved);
            if (_followLoop)
            {
                if (_followTargetDistance - moved > 0.000001f)
                {
                    if (percent <= 0.000001)
                    {
                        percent = Travel(1.0, _followTargetDistance - moved, _followTargetDirection, out moved);
                    }
                    else if (percent >= 0.999999)
                    {
                        percent = Travel(0.0, _followTargetDistance - moved, _followTargetDirection, out moved);
                    }
                }
            }
            SetPercent(percent, true);
        }

        protected override void Awake()
        {
            base.Awake();
            if(_followTarget != null)
            {
                _followTarget.onMotionApplied += OnFollowTargetMotionApplied;
            }
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            if (_followTarget != null)
            {
                _followTarget.onMotionApplied -= OnFollowTargetMotionApplied;
            }
        }


        protected override void OnDidApplyAnimationProperties()
        {
            if (_lastPosition != _position)
            {
                _lastPosition = _position;
                if (mode == Mode.Distance)
                {
                    SetDistance(_position, true);
                }
                else
                {
                    SetPercent(_position, true);
                }
            }
            base.OnDidApplyAnimationProperties();
        }

        protected override Transform GetTransform()
        {
            return targetObject.transform;
        }

        protected override Rigidbody GetRigidbody()
        {
            return targetObject.GetComponent<Rigidbody>();
        }

        protected override Rigidbody2D GetRigidbody2D()
        {
            return targetObject.GetComponent<Rigidbody2D>();
        }

        protected override void PostBuild()
        {
            base.PostBuild();
            if (mode == Mode.Distance) SetDistance((float)_position, true);
            else SetPercent(_position, true);
        }

        public override void SetPercent(double percent, bool checkTriggers = false, bool handleJunctions = false)
        {
            base.SetPercent(percent, checkTriggers, handleJunctions);
            _position = (float)percent;

            if (!handleJunctions) return;

            InvokeNodes();
        }

        public override void SetDistance(float distance, bool checkTriggers = false, bool handleJunctions = false)
        {
            double lastPercent = _result.percent;
            double travel = Travel(0.0, distance, Spline.Direction.Forward);
            Evaluate(travel, ref _result);
            ApplyMotion();

            if (checkTriggers)
            {
                CheckTriggers(lastPercent, _result.percent);
                InvokeTriggers();
            }
            if (handleJunctions)
            {
                CheckNodes(lastPercent, _result.percent);
            }

            _position = mode == Mode.Distance ? distance : (float)travel;

            if (!handleJunctions) return;

            InvokeNodes();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplinePositioner.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineProjector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 453ef2bcc92003342b9fe6a327abc98c
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using UnityEngine.Events;
using System.Collections;
using UnityEngine.Serialization;

namespace Dreamteck.Splines
{
    [ExecuteInEditMode]
    [AddComponentMenu("Dreamteck/Splines/Users/Spline Projector")]
    public class SplineProjector : SplineTracer
    {
        public enum Mode {Accurate, Cached}
        public Mode mode
        {
            get { return _mode; }
            set
            {
                if(value != _mode)
                {
                    _mode = value;
                    Rebuild();
                }
            }
        }

        public bool autoProject
        {
            get { return _autoProject; }
            set
            {
                if(value != _autoProject)
                {
                    _autoProject = value;
                    if (_autoProject) Rebuild();
                }
            }
        }

        public int subdivide
        {
            get { return _subdivide; }
            set
            {
                if (value != _subdivide)
                {
                    _subdivide = value;
                    if (_mode == Mode.Accurate) Rebuild();
                }
            }
        }

        public Transform projectTarget
        {
            get {
                if (_projectTarget == null) return transform;
                return _projectTarget; 
            }
            set
            {
                if (value != _projectTarget)
                {
                    _projectTarget = value;
                    Rebuild();
                }
            }
        }

        public GameObject targetObject
        {
            get
            {
                if (_targetObject == null)
                {
                    if (applyTarget != null) //Temporary check to migrate SplineProjectors that use target
                    {
                        _targetObject = applyTarget.gameObject;
                        applyTarget = null;
                        return _targetObject;
                    }
                }
                return _targetObject;
            }

            set
            {
                if (value != _targetObject)
                {
                    _targetObject = value;
                    RefreshTargets();
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private Mode _mode = Mode.Cached;
        [SerializeField]
        [HideInInspector]
        private bool _autoProject = true;
        [SerializeField]
        [HideInInspector]
        [Range(3, 8)]
        private int _subdivide = 4;
        [SerializeField]
        [HideInInspector]
        private Transform _projectTarget;


        [SerializeField]
        [HideInInspector]
        private Transform applyTarget = null;
        [SerializeField]
        [HideInInspector]
        private GameObject _targetObject;

        [SerializeField]
        [HideInInspector]
        public Vector2 _offset;
        [SerializeField]
        [HideInInspector]
        public Vector3 _rotationOffset = Vector3.zero;

        public event SplineReachHandler onEndReached;
        public event SplineReachHandler onBeginningReached;

        [SerializeField]
        [HideInInspector]
        Vector3 lastPosition = Vector3.zero;

        protected override void Reset()
        {
            base.Reset();
            _projectTarget = transform;
        }

        protected override Transform GetTransform()
        {
            if (targetObject == null) return null;
            return targetObject.transform;
        }

        protected override Rigidbody GetRigidbody()
        {
            if (targetObject == null) return null;
            return targetObject.GetComponent<Rigidbody>();
        }

        protected override Rigidbody2D GetRigidbody2D()
        {
            if (targetObject == null) return null;
            return targetObject.GetComponent<Rigidbody2D>();
        }


        protected override void LateRun()
        {
            base.LateRun();
            if (autoProject)
            {
                if (projectTarget && lastPosition != projectTarget.position)
                {
                    lastPosition = projectTarget.position;
                    CalculateProjection();
                }
            }
         }

        protected override void PostBuild()
        {
            base.PostBuild();
            CalculateProjection();
        }

        protected override void OnSplineChanged()
        {
            if (spline != null)
            {
                if (_mode == Mode.Accurate)
                {
                    spline.Project(_projectTarget.position, ref _result, clipFrom, clipTo, SplineComputer.EvaluateMode.Calculate, subdivide);
                } 
                else
                {
                    spline.Project(_projectTarget.position, ref _result, clipFrom, clipTo);
                }
                _result.percent = ClipPercent(_result.percent);
            }
        }


        private void Project()
        {
            if (_mode == Mode.Accurate && spline != null)
            {
                spline.Project(_projectTarget.position, ref _result, clipFrom, clipTo, SplineComputer.EvaluateMode.Calculate, subdivide);
                _result.percent = ClipPercent(_result.percent);
            }
            else
            {
                Project(_projectTarget.position, ref _result);
            }
        }

        public void CalculateProjection()
        {
            if (_projectTarget == null) return;
            double lastPercent = _result.percent;
            Project();

            if (onBeginningReached != null && _result.percent <= clipFrom)
            {
                if (!Mathf.Approximately((float)lastPercent, (float)_result.percent))
                {
                    onBeginningReached();
                    if (samplesAreLooped)
                    {
                        CheckTriggers(lastPercent, 0.0);
                        CheckNodes(lastPercent, 0.0);
                        lastPercent = 1.0;
                    }
                }
            }
            else if (onEndReached != null && _result.percent >= clipTo)
            {
                if (!Mathf.Approximately((float)lastPercent, (float)_result.percent))
                {
                    onEndReached();
                    if (samplesAreLooped)
                    {
                        CheckTriggers(lastPercent, 1.0);
                        CheckNodes(lastPercent, 1.0);
                        lastPercent = 0.0;
                    }
                }
            }

            CheckTriggers(lastPercent, _result.percent);
            CheckNodes(lastPercent, _result.percent);
            

            if (targetObject != null)
            {
                ApplyMotion();
            }

            InvokeTriggers();
            InvokeNodes();
            lastPosition = projectTarget.position;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineProjector.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineRenderer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bf69cfa06c48dba428c5c4d626d57ab7
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using Dreamteck.Splines;

namespace Dreamteck.Splines
{
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Dreamteck/Splines/Users/Spline Renderer")]
    [ExecuteInEditMode]
    public class SplineRenderer : MeshGenerator
    {
        public int slices
        {
            get { return _slices; }
            set
            {
                if (value != _slices)
                {
                    if (value < 1) value = 1;
                    _slices = value;
                    Rebuild();
                }
            }
        }
        [HideInInspector]
        public bool autoOrient = true;
        [HideInInspector]
        public int updateFrameInterval = 0;
        [SerializeField]
        [HideInInspector]
        private int _slices = 1;

        private int _currentFrame = 0;
        private Vector3 _vertexDirection = Vector3.up;
        private bool _orthographic = false;
        private bool _init = false;

        void Start()
        {
            if (Camera.current != null)
            {
                _orthographic = Camera.current.orthographic;
            } 
            else if (Camera.main != null)
            {
                _orthographic = Camera.main.orthographic;
            }

            CreateMesh();
        }

        protected override void LateRun()
        {
            if (updateFrameInterval > 0)
            {
                _currentFrame++;
                if (_currentFrame > updateFrameInterval) _currentFrame = 0;
            }
        }

        protected override void BuildMesh()
        {
            base.BuildMesh();
            GenerateVertices(_vertexDirection, _orthographic);
            MeshUtility.GeneratePlaneTriangles(ref _tsMesh.triangles, _slices, sampleCount, false, 0, 0);
        }

        public void RenderWithCamera(Camera cam)
        {
            _orthographic = cam.orthographic;
            if (_orthographic)
            {
                _vertexDirection = -cam.transform.forward;
            }
            else
            {
                _vertexDirection = cam.transform.position;
            }
            BuildMesh();
            WriteMesh();
        }

        void OnWillRenderObject()
        {
            if (!autoOrient) return;
            if (updateFrameInterval > 0)
            {
                if (_currentFrame != 0) return;
            }

            if (!Application.isPlaying)
            {
                if (!_init)
                {
                    Awake();
                    _init = true;
                }
            }

            if (Camera.current != null)
            {
                RenderWithCamera(Camera.current);
            } 
            else if(Camera.main)
            {
                RenderWithCamera(Camera.main);
            }
        }

        public void GenerateVertices(Vector3 vertexDirection, bool orthoGraphic)
        {
            AllocateMesh((_slices + 1) * sampleCount, _slices * (sampleCount - 1) * 6);
            int vertexIndex = 0;
            ResetUVDistance();
            bool hasOffset = offset != Vector3.zero;
            for (int i = 0; i < sampleCount; i++)
            {
                GetSample(i, ref evalResult);
                Vector3 center = evalResult.position;
                if (hasOffset) center += offset.x * -Vector3.Cross(evalResult.forward, evalResult.up) + offset.y * evalResult.up + offset.z * evalResult.forward;
                Vector3 vertexNormal;
                if(orthoGraphic) vertexNormal = vertexDirection;
                else vertexNormal = (vertexDirection - center).normalized;
                Vector3 vertexRight = Vector3.Cross(evalResult.forward, vertexNormal).normalized;
                if (uvMode == UVMode.UniformClamp || uvMode == UVMode.UniformClip) AddUVDistance(i);
                Color vertexColor = evalResult.color * color;
                for (int n = 0; n < _slices + 1; n++)
                {
                    float slicePercent = ((float)n / _slices);
                    _tsMesh.vertices[vertexIndex] = center - vertexRight * evalResult.size * 0.5f * size + vertexRight * evalResult.size * slicePercent * size;
                    CalculateUVs(evalResult.percent, slicePercent);
                    _tsMesh.uv[vertexIndex] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(uvRotation + 180f, Vector3.forward) * (Vector2.one * 0.5f - __uvs));
                    _tsMesh.normals[vertexIndex] = vertexNormal;
                    _tsMesh.colors[vertexIndex] = vertexColor;
                    vertexIndex++;
                }
            }
        }


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineRenderer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineTracer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 868482a8001bf104dbe8c2415d018860
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines
{
    public class SplineTracer : SplineUser
    {
        public class NodeConnection
        {
            public Node node;
            public int point = 0;

            public NodeConnection(Node node, int point)
            {
                this.node = node;
                this.point = point;
            }
        }

        public enum PhysicsMode { Transform, Rigidbody, Rigidbody2D }
        public PhysicsMode physicsMode
        {
            get { return _physicsMode; }
            set
            {
                _physicsMode = value;
                RefreshTargets();
            }
        }

        public TransformModule motion
        {
            get
            {
                if (_motion == null) _motion = new TransformModule();
                return _motion;
            }
        }

        /// <summary>
        /// Returns the unmodified result from the evaluation
        /// </summary>
        public SplineSample result
        {
            get { return _result; }
        }

        public bool dontLerpDirection
        {
            get { return _dontLerpDirection; }
            set
            {
                if (value != _dontLerpDirection)
                {
                    _dontLerpDirection = value;
                    ApplyMotion();
                }
            }
        }

        public virtual Spline.Direction direction
        {
            get { return _direction; }
            set
            {
                if (value != _direction)
                {
                    _direction = value;
                    ApplyMotion();
                }
            }
        }

        [HideInInspector]
        public bool applyDirectionRotation = true;
        [HideInInspector]
        public bool useTriggers = false;
        [HideInInspector]
        public int triggerGroup = 0;
        [SerializeField]
        [HideInInspector]
        protected Spline.Direction _direction = Spline.Direction.Forward;

        [SerializeField]
        [HideInInspector]
        protected bool _dontLerpDirection = false;

        [SerializeField]
        [HideInInspector]
        protected PhysicsMode _physicsMode = PhysicsMode.Transform;
        [SerializeField]
        [HideInInspector]
        protected TransformModule _motion = null;


        [SerializeField]
        [HideInInspector]
        protected Rigidbody targetRigidbody = null;
        [SerializeField]
        [HideInInspector]
        protected Rigidbody2D targetRigidbody2D = null;
        [SerializeField]
        [HideInInspector]
        protected Transform targetTransform = null;
        [SerializeField]
        [HideInInspector]
        protected SplineSample _result = new SplineSample();

        public delegate void JunctionHandler(List<NodeConnection> passed);

        public event JunctionHandler onNode;
        public event EmptySplineHandler onMotionApplied;

        private SplineTrigger[] triggerInvokeQueue = new SplineTrigger[0];
        private List<NodeConnection> nodeConnectionQueue = new List<NodeConnection>();
        private int addTriggerIndex = 0;

        private const double MIN_DELTA = 0.000001;

#if UNITY_EDITOR
        public override void EditorAwake()
        {
            base.EditorAwake();
            RefreshTargets();
            ApplyMotion();
        }
#endif 

        protected override void Awake()
        {
            base.Awake();
            RefreshTargets();
        }

        protected virtual void Start()
        {

        }

        public virtual void SetPercent(double percent, bool checkTriggers = false, bool handleJunctions = false)
        {
            if (sampleCount == 0) return;
            double lastPercent = _result.percent;
            Evaluate(percent, ref _result);
            ApplyMotion();
            if (checkTriggers)
            {
                CheckTriggers(lastPercent, percent);
                InvokeTriggers();
            }
            if (handleJunctions)
            {
                CheckNodes(lastPercent, percent);
            }
        }

        public double GetPercent()
        {
            return _result.percent;
        }

        public virtual void SetDistance(float distance, bool checkTriggers = false, bool handleJunctions = false)
        {
            double lastPercent = _result.percent;
            Evaluate(Travel(0.0, distance, Spline.Direction.Forward), ref _result);
            ApplyMotion();
            if (checkTriggers)
            {
                CheckTriggers(lastPercent, _result.percent);
                InvokeTriggers();
            }
            if (handleJunctions)
            {
                CheckNodes(lastPercent, _result.percent);
            }
        }

        protected virtual Rigidbody GetRigidbody()
        {
            return GetComponent<Rigidbody>();
        }

        protected virtual Rigidbody2D GetRigidbody2D()
        {
            return GetComponent<Rigidbody2D>();
        }

        protected virtual Transform GetTransform()
        {
            return transform;
        }

        protected void ApplyMotion()
        {
            if (sampleCount == 0) return;
            if (_dontLerpDirection)
            {
                double unclippedPercent = UnclipPercent(_result.percent);
                int index;
                double lerp;
                spline.GetSamplingValues(unclippedPercent, out index, out lerp);
                _result.forward = spline[index].forward;
                _result.up = spline[index].up;
            }

            motion.targetUser = this;
            motion.splineResult = _result;
            if (applyDirectionRotation) motion.direction = _direction;
            else motion.direction = Spline.Direction.Forward;

            switch (_physicsMode)
            {
                case PhysicsMode.Transform:
                    if (targetTransform == null) RefreshTargets();
                    if (targetTransform == null) return;
                    motion.ApplyTransform(targetTransform);
                    if (onMotionApplied != null) onMotionApplied();
                    break;
                case PhysicsMode.Rigidbody:
                    if (targetRigidbody == null)
                    {
                        RefreshTargets();
                        if (targetRigidbody == null)  throw new MissingComponentException("There is no Rigidbody attached to " + name + " but the Physics mode is set to use one.");
                    }
                    motion.ApplyRigidbody(targetRigidbody);
                    if (onMotionApplied != null) onMotionApplied();
                    break;
                case PhysicsMode.Rigidbody2D:
                    if (targetRigidbody2D == null)
                    {
                        RefreshTargets();
                        if (targetRigidbody2D == null) throw new MissingComponentException("There is no Rigidbody2D attached to " + name + " but the Physics mode is set to use one.");
                    }
                    motion.ApplyRigidbody2D(targetRigidbody2D);
                    if (onMotionApplied != null) onMotionApplied();
                    break;
            }
        }

        protected void CheckNodes(double from, double to)
        {
#if UNITY_EDITOR
            if (!Application.isPlaying) return;
#endif
            if (onNode == null) return;
            if (from == to) return;
            UnclipPercent(ref from);
            UnclipPercent(ref to);
            Spline.FormatFromTo(ref from, ref to, true);
            int fromPoint, toPoint;
            fromPoint = spline.PercentToPointIndex(from, _direction);
            toPoint = spline.PercentToPointIndex(to, _direction);

            if (fromPoint != toPoint)
            {
                if (_direction == Spline.Direction.Forward)
                {
                    for (int i = fromPoint + 1; i <= toPoint; i++)
                    {
                        NodeConnection junction = GetJunction(i);
                        if (junction != null) nodeConnectionQueue.Add(junction);
                    }
                }
                else
                {
                    for (int i = toPoint - 1; i >= fromPoint; i--)
                    {
                        NodeConnection junction = GetJunction(i);
                        if (junction != null) nodeConnectionQueue.Add(junction);
                    }
                }
            }
            else if (from < MIN_DELTA && to > from)
            {
                NodeConnection junction = GetJunction(0);
                if (junction != null) nodeConnectionQueue.Add(junction);
            }
            else if (to > 1.0 - MIN_DELTA && from < to)
            {
                int pointCount = spline.pointCount - 1;
                if (spline.isClosed)
                {
                    pointCount = spline.pointCount;
                }
                NodeConnection junction = GetJunction(pointCount);
                if (junction != null) nodeConnectionQueue.Add(junction);
            }
        }

        protected void InvokeNodes()
        {
            if(nodeConnectionQueue.Count > 0)
            {
                onNode(nodeConnectionQueue);
                nodeConnectionQueue.Clear();
            }
        }

        protected void CheckTriggers(double from, double to)
        {
#if UNITY_EDITOR
            if (!Application.isPlaying) return;
#endif
            if (!useTriggers) return;
            if (from == to) return;
            UnclipPercent(ref from);
            UnclipPercent(ref to);
            if (triggerGroup < 0 || triggerGroup >= spline.triggerGroups.Length) return;
            for (int i = 0; i < spline.triggerGroups[triggerGroup].triggers.Length; i++)
            {
                if (spline.triggerGroups[triggerGroup].triggers[i] == null) continue;
                if (spline.triggerGroups[triggerGroup].triggers[i].Check(from, to)) AddTriggerToQueue(spline.triggerGroups[triggerGroup].triggers[i]);
            }
        }

        NodeConnection GetJunction(int pointIndex)
        {
            Node node = spline.GetNode(pointIndex);
            if (node == null) return null;
            return new NodeConnection(node, pointIndex);
        }

        protected void InvokeTriggers()
        {
#if UNITY_EDITOR
            if (!Application.isPlaying) return;
#endif
            for (int i = 0; i < addTriggerIndex; i++)
            {
                if (triggerInvokeQueue[i] != null)
                {
                    triggerInvokeQueue[i].Invoke(this);
                }
            }
            addTriggerIndex = 0;
        }

        protected void RefreshTargets()
        {
            switch (_physicsMode)
            {
                case PhysicsMode.Transform:
                    targetTransform = GetTransform();
                    break;
                case PhysicsMode.Rigidbody:
                    targetRigidbody = GetRigidbody();
                    break;
                case PhysicsMode.Rigidbody2D:
                    targetRigidbody2D = GetRigidbody2D();
                    break;
            }
        }

        private void AddTriggerToQueue(SplineTrigger trigger)
        {
            if (addTriggerIndex >= triggerInvokeQueue.Length)
            {
                SplineTrigger[] newQueue = new SplineTrigger[triggerInvokeQueue.Length + spline.triggerGroups[triggerGroup].triggers.Length];
                triggerInvokeQueue.CopyTo(newQueue, 0);
                triggerInvokeQueue = newQueue;
            }
            triggerInvokeQueue[addTriggerIndex] = trigger;
            addTriggerIndex++;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineTracer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineUser.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8abf799a17be8264daa9759d95e6de99
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;

namespace Dreamteck.Splines {
    [ExecuteInEditMode]
    public class SplineUser : MonoBehaviour, ISerializationCallbackReceiver, ISampleModifier
    {
        public enum UpdateMethod { Update, FixedUpdate, LateUpdate }
        [HideInInspector]
        public UpdateMethod updateMethod = UpdateMethod.Update;

        public SplineComputer spline
        {
            get {
                return _spline;
            }
            set
            {
                if (value != _spline)
                {
                    if (_spline != null)
                    {
                        _spline.Unsubscribe(this);
                    }
                    _spline = value;
                    if (_spline != null)
                    {
                        _spline.Subscribe(this);
                        Rebuild();
                    }
                    OnSplineChanged();
                }
            }
        }

        public double clipFrom
        {
            get
            {
                return _clipFrom;
            }
            set
            {
                if (value != _clipFrom)
                {
                    animClipFrom = (float)_clipFrom;
                    _clipFrom = DMath.Clamp01(value);
                    if (_clipFrom > _clipTo)
                    {
                        if (!_spline.isClosed) _clipTo = _clipFrom;
                    }
                    getSamples = true;
                    Rebuild();
                }
            }
        }

        public double clipTo
        {
            get
            {
                return _clipTo;
            }
            set
            {

                if (value != _clipTo)
                {
                    animClipTo = (float)_clipTo;
                    _clipTo = DMath.Clamp01(value);
                    if (_clipTo < _clipFrom)
                    {
                        if (!_spline.isClosed) _clipFrom = _clipTo;
                    }
                    getSamples = true;
                    Rebuild();
                }
            }
        }

        public bool autoUpdate
        {
            get
            {
                return _autoUpdate;
            }
            set
            {
                if (value != _autoUpdate)
                {
                    _autoUpdate = value;
                    if (value) Rebuild();
                }
            }
        }

        public bool loopSamples
        {
            get
            {
                return _loopSamples;
            }
            set
            {
                if (value != _loopSamples)
                {
                    _loopSamples = value;
                    if(!_loopSamples && _clipTo < _clipFrom)
                    {
                        double temp = _clipTo;
                        _clipTo = _clipFrom;
                        _clipFrom = temp;
                    }
                    Rebuild();
                }
            }
        }

        //The percent of the spline that we're traversing
        public double span
        {
            get
            {
                if (samplesAreLooped) return (1.0 - _clipFrom) + _clipTo;
                return _clipTo - _clipFrom;
            }
        }

        public bool samplesAreLooped
        {
            get
            {
                return _loopSamples && _clipFrom >= _clipTo;
            }
        }

        public RotationModifier rotationModifier
        {
            get
            {
                return _rotationModifier;
            }
        }

        public OffsetModifier offsetModifier
        {
            get
            {
                return _offsetModifier;
            }
        }

        public ColorModifier colorModifier
        {
            get
            {
                return _colorModifier;
            }
        }

        public SizeModifier sizeModifier
        {
            get
            {
                return _sizeModifier;
            }
        }

        //Serialized values
        [SerializeField]
        [HideInInspector]
        private SplineComputer _spline;
        [SerializeField]
        [HideInInspector]
        private bool _autoUpdate = true;
        [SerializeField]
        [HideInInspector]
        protected RotationModifier _rotationModifier = new RotationModifier();
        [SerializeField]
        [HideInInspector]
        protected OffsetModifier _offsetModifier = new OffsetModifier();
        [SerializeField]
        [HideInInspector]
        protected ColorModifier _colorModifier = new ColorModifier();
        [SerializeField]
        [HideInInspector]
        protected SizeModifier _sizeModifier = new SizeModifier();
        [SerializeField]
        [HideInInspector]
        private SplineSample _clipFromSample = new SplineSample(), _clipToSample = new SplineSample();

        [SerializeField]
        [HideInInspector]
        private bool _loopSamples = false;
        [SerializeField]
        [HideInInspector]
        private double _clipFrom = 0.0;
        [SerializeField]
        [HideInInspector]
        private double _clipTo = 1.0;

        //float values used for making animations
        [SerializeField]
        [HideInInspector]
        private float animClipFrom = 0f;
        [SerializeField]
        [HideInInspector]
        private float animClipTo = 1f;

        private SampleCollection _sampleCollection = new SampleCollection();
        private bool rebuild = false, getSamples = false, postBuild = false;
        private Transform _trs = null;
        private bool _hasTransform = false;
        private SplineSample _workSample = new SplineSample();
#if UNITY_EDITOR
        private bool _isPlaying = false;
        protected bool isPlaying => _isPlaying;
#endif

        protected Transform trs
        {
            get {  return _trs;  }
        }
        protected bool hasTransform
        {
            get { return _hasTransform; }
        }
        public int sampleCount
        {
            get { return _sampleCount; }
        }

        private int _sampleCount = 0, _startSampleIndex = 0;
        /// <summary>
        /// Use this to work with the Evaluate and Project methods
        /// </summary>
        protected SplineSample evalResult = new SplineSample();

        //Threading values
        [HideInInspector]
        public volatile bool multithreaded = false;
        [HideInInspector]
        public bool buildOnAwake = true;
        [HideInInspector]
        public bool buildOnEnable = false;

        public event EmptySplineHandler onPostBuild;

#if UNITY_EDITOR
        public virtual void EditorAwake()
        {

        }
#endif

        protected virtual void Awake() {
#if UNITY_EDITOR
            _isPlaying = Application.isPlaying;
            if (!_isPlaying)
            {
                if (spline != null)
                {
                    if (!_spline.IsSubscribed(this))
                    {
                        _spline.Subscribe(this);
                        UnityEditor.EditorUtility.SetDirty(spline);
                    }
                }
            }
#endif

            CacheTransform();
            if (buildOnAwake && Application.isPlaying)
            {
                RebuildImmediate();
            } else
            {
                GetSamples();
            }

#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                RebuildImmediate();
            }
#endif
        }

        protected void CacheTransform()
        {
            _trs = transform;
            _hasTransform = true;
        }

        protected virtual void Reset()
        {
#if UNITY_EDITOR
            spline = GetComponent<SplineComputer>();
            Awake();
#endif
        }

        protected virtual void OnEnable()
        {
#if UNITY_EDITOR
            if (!_isPlaying || buildOnEnable)
            {
                RebuildImmediate();
            }
#else
            if (buildOnEnable){
                RebuildImmediate();
            }
#endif
        }

        protected virtual void OnDisable()
        {
        }

        protected virtual void OnDestroy()
        {
#if UNITY_EDITOR
            if (!_isPlaying && spline != null)
            {
                _spline.Unsubscribe(this); //Unsubscribe if DestroyImmediate is called
            }
#endif
        }

        protected virtual void OnDidApplyAnimationProperties()
        {
            bool clip = false;
            if (_clipFrom != animClipFrom || _clipTo != animClipTo) clip = true;
            _clipFrom = animClipFrom;
            _clipTo = animClipTo;
            Rebuild();
            if (clip) GetSamples();
        }

        /// <summary>
        /// Gets the sample at the given index without modifications
        /// </summary>
        /// <param name="index">Sample index</param>
        /// <returns></returns>
        public void GetSampleRaw(int index, ref SplineSample sample)
        {
            if (index == 0)
            {
                sample.FastCopy(ref _clipFromSample);
                return;
            }
            if (index == _sampleCount - 1)
            {
                sample.FastCopy(ref _clipToSample);
                return;
            }

            ClampLoopSampleIndex(ref index);
            sample.FastCopy(ref _sampleCollection.samples[index]);
        }

        public double GetSamplePercent(int index)
        {
            if (index == 0)
            {
                return _clipFromSample.percent;
            }
            if (index == _sampleCount - 1)
            {
                return _clipToSample.percent;
            }

            ClampLoopSampleIndex(ref index);
            return _sampleCollection.samples[index].percent;
        }

        private void ClampLoopSampleIndex(ref int index)
        {
            if (index >= _sampleCount)
            {
                index = _sampleCount - 1;
            }

            if (samplesAreLooped)
            {
                int start;
                double lerp;
                _sampleCollection.GetSamplingValues(clipFrom, out start, out lerp);

                index = start + index;
                if (index >= _sampleCollection.length)
                {
                    index -= _sampleCollection.length;
                }
            }
            else
            {
                index = _startSampleIndex + index;
            }
        }


        /// <summary>
        /// Returns the sample at the given index with modifiers applied
        /// </summary>
        /// <param name="index">Sample index</param>
        /// <param name="target">Sample to write to</param>
        public void GetSample(int index, ref SplineSample target)
        {
            GetSampleRaw(index, ref target);
            ApplySampleModifiers(ref target);
        }

        /// <summary>
        /// Returns the sample at the given index with modifiers applied and
        /// applies compensation to the size parameter based on the angle between the samples
        /// </summary>
        public void GetSampleWithAngleCompensation(int index, ref SplineSample target)
        {
            GetSampleRaw(index, ref target);
            ApplySampleModifiers(ref target);
            if (index > 0 && index < sampleCount - 1)
            {
                GetSampleRaw(index - 1, ref _workSample);
                ApplySampleModifiers(ref target);
                Vector3 prev = target.position - _workSample.position;
                GetSampleRaw(index + 1, ref _workSample);
                ApplySampleModifiers(ref target);
                Vector3 next = _workSample.position - target.position;
                target.size *= 1 / Mathf.Sqrt(Vector3.Dot(prev.normalized, next.normalized) * 0.5f + 0.5f);
            }
        }


        /// <summary>
        /// Rebuild the SplineUser. This will cause Build and Build_MT to be called.
        /// </summary>
        /// <param name="sampleComputer">Should the SplineUser sample the SplineComputer</param>
        public virtual void Rebuild()
        {
#if UNITY_EDITOR
            if (!_hasTransform)
            {
                CacheTransform();
            }

            //If it's the editor and it's not playing, then rebuild immediate
            if (_isPlaying)
            {
                if (!autoUpdate) return;
                rebuild = getSamples = true;
            }
            else
            {
                RebuildImmediate();
            }
#else
             if (!autoUpdate) return;
             rebuild = getSamples = true;
#endif
        }

        /// <summary>
        /// Rebuild the SplineUser immediate. This method will call sample samples and call Build as soon as it's called even if the component is disabled.
        /// </summary>
        /// <param name="sampleComputer">Should the SplineUser sample the SplineComputer</param>
        public virtual void RebuildImmediate()
        {
#if UNITY_EDITOR
            if (!_hasTransform)
            {
                CacheTransform();
            }
#endif
            try
            {
                GetSamples();
                Build();
                PostBuild();
            }
            catch (System.Exception ex)
            {
                Debug.LogError(ex.Message);
            }
            rebuild = false;
            getSamples = false;
        }

        private void Update()
        {
            if (updateMethod == UpdateMethod.Update)
            {
                Run();
                RunUpdate();
                LateRun();
            }
        }

        private void LateUpdate()
        {
            if (updateMethod == UpdateMethod.LateUpdate)
            {
                Run();
                RunUpdate();
                LateRun();
            }
#if UNITY_EDITOR
            if(!_isPlaying && updateMethod == UpdateMethod.FixedUpdate)
            {
                Run();
                RunUpdate();
                LateRun();
            }
#endif
        }

        private void FixedUpdate()
        {
            if (updateMethod == UpdateMethod.FixedUpdate)
            {
                Run();
                RunUpdate();
                LateRun();
            }
        }

        //Update logic for handling threads and rebuilding
        private void RunUpdate()
        {
#if UNITY_EDITOR
            if (!_isPlaying) return;
#endif
            //Handle rebuilding
            if (rebuild)
            {
                if (multithreaded)
                {
                    if (getSamples) SplineThreading.Run(ResampleAndBuildThreaded);
                    else SplineThreading.Run(BuildThreaded);
                }
                else
                {
                    if (getSamples || _spline.sampleMode == SplineComputer.SampleMode.Optimized) GetSamples();
                    Build();
                    postBuild = true;
                }
                rebuild = false;
            }
            if (postBuild)
            {
                PostBuild();
                EmptySplineHandler postBuildHandler = onPostBuild;
                if(postBuildHandler != null)
                {
                    postBuildHandler();
                }
                postBuild = false;
            }
        }

        void BuildThreaded()
        {
            while (postBuild)
            {
                //Wait if the main thread is still running post build operations
            }
            Build();
            postBuild = true;
        }

        private void ResampleAndBuildThreaded()
        {
            while (postBuild)
            {
                //Wait if the main thread is still running post build operations
            }
            GetSamples();
            Build();
            postBuild = true;
        }

        /// Code to run every Update/FixedUpdate/LateUpdate before any building has taken place
        protected virtual void Run()
        {

        }

        /// Code to run every Update/FixedUpdate/LateUpdate after any rabuilding has taken place
        protected virtual void LateRun()
        {

        }

        //Used for calculations. Called on the main or the worker thread.
        protected virtual void Build()
        {
        }

        //Called on the Main thread only - used for applying the results from Build
        protected virtual void PostBuild()
        {
        }

        protected virtual void OnSplineChanged()
        {

        }

        /// <summary>
        /// Applies the SplineUser modifiers to the provided sample
        /// </summary>
        /// <param name="sample">The sample to modify</param>
        public void ApplySampleModifiers(ref SplineSample sample)
        {
            ApplyModifier(_offsetModifier, ref sample);
            ApplyModifier(_rotationModifier, ref sample);
            ApplyModifier(_colorModifier, ref sample);
            ApplyModifier(_sizeModifier, ref sample);
        }

        public Vector3 GetModifiedSamplePosition(ref SplineSample sample)
        {
            if (_offsetModifier.hasKeys)
            {
                Vector2 offset = _offsetModifier.Evaluate(sample.percent);
                return sample.position + sample.right * offset.x + sample.up * offset.y; ;
            }
            return sample.position;
        }

        private void ApplyModifier(SplineSampleModifier modifier, ref SplineSample sample)
        {
            if (!modifier.hasKeys) return;
            if (modifier.useClippedPercent)
            {
                ClipPercent(ref sample.percent);
            }

            modifier.Apply(ref sample);

            if (modifier.useClippedPercent)
            {
                UnclipPercent(ref sample.percent);
            }
        }

        /// <summary>
        /// Sets the clip range of the SplineUser. Same as setting clipFrom and clipTo
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        public void SetClipRange(double from, double to)
        {
            if (!_spline.isClosed && to < from) to = from;
            _clipFrom = DMath.Clamp01(from);
            _clipTo = DMath.Clamp01(to);
            GetSamples();
            Rebuild();
        }

        /// <summary>
        /// Gets the clipped samples defined by clipFrom and clipTo
        /// </summary>
        private void GetSamples()
        {
            getSamples = false;
            if (spline == null)
            {
                _sampleCollection.samples = new SplineSample[0];
                _sampleCount = 0;
                return;
            }

            _spline.GetSamples(_sampleCollection);

            if (_sampleCollection.length == 0)
            {
                _sampleCount = 0;
                return;
            }

            if (_clipFrom != 0.0)
            {
                _sampleCollection.Evaluate(clipFrom, ref _clipFromSample);
            } else
            {
                _clipFromSample = _sampleCollection.samples[0];
            }

            if(_clipTo != 1.0)
            {
                _sampleCollection.Evaluate(_clipTo, ref _clipToSample);
            } else
            {
                _clipToSample = _sampleCollection.samples[_sampleCollection.length - 1];
            }

            int start, end;
            _sampleCount = _sampleCollection.GetClippedSampleCount(_clipFrom, _clipTo, out start, out end);
            double lerp;
            _sampleCollection.GetSamplingValues(_clipFrom, out _startSampleIndex, out lerp);
        }

        /// <summary>
        /// Takes a regular 0-1 percent mapped to the start and end of the spline and maps it to the clipFrom and clipTo valies. Useful for working with clipped samples
        /// </summary>
        /// <param name="percent"></param>
        /// <returns></returns>
        public double ClipPercent(double percent)
        {
            ClipPercent(ref percent);
            return percent;
        }

        /// <summary>
        /// Takes a regular 0-1 percent mapped to the start and end of the spline and maps it to the clipFrom and clipTo valies. Useful for working with clipped samples
        /// </summary>
        /// <param name="percent"></param>
        /// <returns></returns>
        public void ClipPercent(ref double percent)
        {
            if (_sampleCollection.length == 0)
            {
                percent = 0.0;
                return;
            }

            if (samplesAreLooped)
            {
                if (percent >= clipFrom && percent <= 1.0) { percent = DMath.InverseLerp(clipFrom, clipFrom + span, percent); }//If in the range clipFrom - 1.0
                else if (percent <= clipTo) { percent = DMath.InverseLerp(clipTo - span, clipTo, percent); } //if in the range 0.0 - clipTo
                else
                {
                    //Find the nearest clip start
                    if (DMath.InverseLerp(clipTo, clipFrom, percent) < 0.5) percent = 1.0;
                    else percent = 0.0;
                }
            }
            else percent = DMath.InverseLerp(clipFrom, clipTo, percent);
        }

        public double UnclipPercent(double percent)
        {
            UnclipPercent(ref percent);
            return percent;
        }

        public void UnclipPercent(ref double percent)
        {
            if (samplesAreLooped)
            {
                if (span <= 0.00001)
                {
                    percent = clipFrom;
                    return;
                }
                double fromRatio = (1.0 - clipFrom) / span;
                if (percent < fromRatio)
                {
                    percent = DMath.Lerp(clipFrom, 1.0, percent / fromRatio);
                }
                else if (clipTo == 0.0)
                {
                    percent = 0.0;
                    return;
                }
                else percent = DMath.Lerp(0.0, clipTo, (percent - fromRatio) / (clipTo / span));
            }
            else
            {
                if (percent == 0.0)
                {
                    percent = clipFrom;
                    return;
                }
                else if (percent == 1.0)
                {
                    percent = clipTo;
                    return;
                }

                percent = DMath.Lerp(clipFrom, clipTo, percent);
            }
            percent = DMath.Clamp01(percent);
        }

        private int GetSampleIndex(double percent)
        {
            int index;
            double lerp;
            _sampleCollection.GetSamplingValues(UnclipPercent(percent), out index, out lerp);
            return index;
        }

        public Vector3 EvaluatePosition(double percent)
        {
            return _sampleCollection.EvaluatePosition(UnclipPercent(percent));
        }

        public void Evaluate(double percent, ref SplineSample result)
        {
            _sampleCollection.Evaluate(UnclipPercent(percent), ref result);
            result.percent = DMath.Clamp01(percent);
            ApplySampleModifiers(ref result);
        }

        public SplineSample Evaluate(double percent)
        {
            SplineSample result = new SplineSample();
            Evaluate(percent, ref result);
            result.percent = DMath.Clamp01(percent);
            ApplySampleModifiers(ref result);
            return result;
        }

        public void Evaluate(ref SplineSample[] results, double from = 0.0, double to = 1.0)
        {
            _sampleCollection.Evaluate(ref results, UnclipPercent(from), UnclipPercent(to));
            for (int i = 0; i < results.Length; i++)
            {
                ClipPercent(ref results[i].percent);
                ApplySampleModifiers(ref results[i]);
            }
        }

        public void EvaluatePositions(ref Vector3[] positions, double from = 0.0, double to = 1.0)
        {
            _sampleCollection.EvaluatePositions(ref positions, UnclipPercent(from), UnclipPercent(to));
        }

        public double Travel(double start, float distance, Spline.Direction direction, out float moved)
        {
            moved = 0f;
            if (direction == Spline.Direction.Forward && start >= 1.0)
            {
                return 1.0;
            }
            else if (direction == Spline.Direction.Backward && start <= 0.0)
            {
                return 0.0;
            }
            if (distance == 0f)
            {
                return DMath.Clamp01(start);
            }

            double result = _sampleCollection.Travel(UnclipPercent(start), distance, direction, out moved, clipFrom, clipTo);
            double clippedResult = ClipPercent(result);

            if (result > clipTo)
            {
                moved -= _sampleCollection.CalculateLength(clipTo, result);
            }
            else if (result < clipFrom)
            {
                moved -= _sampleCollection.CalculateLength(result, clipFrom);
            }

            return clippedResult;
        }

        public double Travel(double start, float distance, Spline.Direction direction = Spline.Direction.Forward)
        {
            float moved;
            return Travel(start, distance, direction, out moved);
        }

        public double TravelWithOffset(double start, float distance, Spline.Direction direction, Vector3 offset, out float moved)
        {
            moved = 0f;
            if (direction == Spline.Direction.Forward && start >= 1.0)
            {
                return 1.0;
            }
            else if (direction == Spline.Direction.Backward && start <= 0.0)
            {
                return 0.0;
            }
            if (distance == 0f)
            {
                return DMath.Clamp01(start);
            }
            double result = _sampleCollection.TravelWithOffset(UnclipPercent(start), distance, direction, offset, out moved, clipFrom, clipTo);
            return ClipPercent(result);
        }

        public virtual void Project(Vector3 position, ref SplineSample result, double from = 0.0, double to = 1.0)
        {
            if (_spline == null) return;
            _sampleCollection.Project(position, _spline.pointCount, ref result, UnclipPercent(from), UnclipPercent(to), this);
            ClipPercent(ref result.percent);
        }

        public float CalculateLength(double from = 0.0, double to = 1.0, bool preventInvert = true)
        {
            return _sampleCollection.CalculateLength(UnclipPercent(from), UnclipPercent(to), preventInvert);
        }

        public float CalculateLengthWithOffset(Vector3 offset, double from = 0.0, double to = 1.0)
        {
            return _sampleCollection.CalculateLengthWithOffset(offset, UnclipPercent(from), UnclipPercent(to));
        }

        public virtual void OnBeforeSerialize()
        {
        }

        public virtual void OnAfterDeserialize()
        {
        }

        /// <summary>
        /// Returns the offset transformed by the sample
        /// </summary>
        /// <param name="sample">Source sample</param>
        /// <param name="localOffset">Local offset to apply</param>
        /// <returns></returns>
        protected static Vector3 TransformOffset(SplineSample sample, Vector3 localOffset)
        {
            return (sample.right * localOffset.x + sample.up * localOffset.y + sample.forward * localOffset.z) * sample.size;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineUser.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SurfaceGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ff5f5220af00e574287547dab664b9ab
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;

namespace Dreamteck.Splines
{
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Dreamteck/Splines/Users/Surface Generator")]
    public class SurfaceGenerator : MeshGenerator
    {
        public float expand
        {
            get { return _expand; }
            set
            {
                if (value != _expand)
                {
                    _expand = value;
                    Rebuild();
                }
            }
        }

        public float extrude
        {
            get { return _extrude; }
            set
            {
                if (value != _extrude)
                {
                    _extrude = value;
                    Rebuild();
                }
            }
        }

        public double extrudeClipFrom
        {
            get { return _extrudeFrom; }
            set
            {
                if (value != _extrudeFrom)
                {
                    _extrudeFrom = value;
                    Rebuild();
                }
            }
        }

        public double extrudeClipTo
        {
            get { return _extrudeTo; }
            set
            {
                if (value != _extrudeTo)
                {
                    _extrudeTo = value;
                    Rebuild();
                }
            }
        }

        public Vector2 sideUvScale
        {
            get { return _sideUvScale; }
            set
            {
                if (value != _sideUvScale)
                {
                    _sideUvScale = value;
                    Rebuild();
                }
                else
                {
                    _sideUvScale = value;
                }
            }
        }

        public Vector2 sideUvOffset
        {
            get { return _sideUvOffset; }
            set
            {
                if (value != _sideUvOffset)
                {
                    _sideUvOffset = value;
                    Rebuild();
                }
                else
                {
                    _sideUvOffset = value;
                }
            }
        }

        public float sideUvRotation
        {
            get { return _sideUvRotation; }
            set
            {
                if (value != _sideUvRotation)
                {
                    _sideUvRotation = value;
                    Rebuild();
                }
                else
                {
                    _sideUvRotation = value;
                }
            }
        }

        public SplineComputer extrudeSpline
        {
            get { return _extrudeSpline; }
            set
            {
                if (value != _extrudeSpline)
                {
                    if (_extrudeSpline != null)
                    {
                        _extrudeSpline.Unsubscribe(this);
                    }
                    _extrudeSpline = value;
                    if (value != null)
                    {
                        _extrudeSpline.Subscribe(this);
                    }
                    Rebuild();
                }
            }
        }

        public Vector3 extrudeOffset
        {
            get { return _extrudeOffset; }
            set { 
                if(value != _extrudeOffset)
                {
                    _extrudeOffset = value;
                    Rebuild();
                } 
            }
        }

        public bool uniformUvs
        {
            get { return _uniformUvs; }
            set
            {
                if (value != _uniformUvs)
                {
                    _uniformUvs = value;
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private float _expand = 0f;
        [SerializeField]
        [HideInInspector]
        private float _extrude = 0f;
        [SerializeField]
        [HideInInspector]
        private Vector2 _sideUvScale = Vector2.one;
        [SerializeField]
        [HideInInspector]
        private Vector2 _sideUvOffset = Vector2.zero;
        [SerializeField]
        [HideInInspector]
        private float _sideUvRotation = 0f;
        [SerializeField]
        [HideInInspector]
        private SplineComputer _extrudeSpline;
        [SerializeField]
        [HideInInspector]
        private Vector3 _extrudeOffset = Vector3.zero;
        [SerializeField]
        [HideInInspector]
        private SplineSample[] extrudeResults = new SplineSample[0];
        [SerializeField]
        [HideInInspector]
        private Vector3[] identityVertices = new Vector3[0];
        [SerializeField]
        [HideInInspector]
        private Vector3[] identityNormals = new Vector3[0];
        [SerializeField]
        [HideInInspector]
        private Vector2[] projectedVerts = new Vector2[0];
        [SerializeField]
        [HideInInspector]
        private int[] surfaceTris = new int[0];
        [SerializeField]
        [HideInInspector]
        private int[] wallTris = new int[0];

        [SerializeField]
        [HideInInspector]
        private double _extrudeFrom = 0.0;
        [SerializeField]
        [HideInInspector]
        private double _extrudeTo = 1.0;
        [SerializeField]
        [HideInInspector]
        private bool _uniformUvs = false;

        private Vector3 _trsRight = Vector3.right;
        private Vector3 _trsUp = Vector3.up;
        private Vector3 _trsForward = Vector3.forward;

        protected override string meshName => "Surface";

        protected override void Awake()
        {
            base.Awake();
            _trsRight = trs.right;
            _trsUp = trs.up;
            _trsForward = trs.forward;
        }

        protected override void BuildMesh()
        {
            if (spline.pointCount == 0) return;
            base.BuildMesh();
            Generate();
        }

        private void LateUpdate()
        {
            if (multithreaded && trs.hasChanged)
            {
                _trsRight = trs.right;
                _trsUp = trs.up;
                _trsForward = trs.forward;
            }
        }

        public void Generate()
        {
            if (!multithreaded)
            {
                _trsRight = trs.right;
                _trsUp = trs.up;
                _trsForward = trs.forward;
            }
            int surfaceVertexCount = sampleCount;
            if (spline.isClosed) surfaceVertexCount--;
            int vertexCount = surfaceVertexCount;
            bool pathExtrude = false;
            if (_extrudeSpline != null)
            {
                _extrudeSpline.Evaluate(ref extrudeResults, _extrudeFrom, _extrudeTo);
                pathExtrude = extrudeResults.Length > 0;
            } else if(extrudeResults.Length > 0)
            {
                extrudeResults = new SplineSample[0];
            }

            bool simpleExtrude = !pathExtrude && _extrude != 0f;

            if (pathExtrude)
            {
                vertexCount *= 2;
                vertexCount += sampleCount * extrudeResults.Length;
            }
            else if (simpleExtrude)
            {
                vertexCount *= 4;
                vertexCount += 2;
            }
            
            Vector3 center, normal;
            GetProjectedVertices(surfaceVertexCount, out center, out normal);

            bool clockwise = IsClockwise(projectedVerts);
            bool flipCap = false;
            bool flipSide = false;
            if (!clockwise) flipSide = !flipSide;
            if (simpleExtrude && _extrude < 0f)
            {
                flipCap = !flipCap;
                flipSide = !flipSide;
            }

            GenerateSurfaceTris(flipCap);
            int totalTrisCount = surfaceTris.Length;
            if (simpleExtrude)
            {
                totalTrisCount *= 2;
                totalTrisCount += 2 * sampleCount * 2 * 3;
            } else
            {
                totalTrisCount *= 2;
                totalTrisCount += extrudeResults .Length * sampleCount * 2 * 3;
            }
            AllocateMesh(vertexCount, totalTrisCount);
            Vector3 off = _trsRight * offset.x + _trsUp * offset.y + _trsForward * offset.z;
            for (int i = 0; i < surfaceVertexCount; i++)
            {
                GetSample(i, ref evalResult);
                _tsMesh.vertices[i] = evalResult.position + off;
                _tsMesh.normals[i] = evalResult.up;
                _tsMesh.colors[i] = evalResult.color * color;
            }

            #region UVs
            Vector2 min = projectedVerts[0];
            Vector2 max = projectedVerts[0];
            for (int i = 1; i < projectedVerts.Length; i++)
            {
                if (min.x < projectedVerts[i].x) min.x = projectedVerts[i].x;
                if (min.y < projectedVerts[i].y) min.y = projectedVerts[i].y;
                if (max.x > projectedVerts[i].x) max.x = projectedVerts[i].x;
                if (max.y > projectedVerts[i].y) max.y = projectedVerts[i].y;
            }

            for (int i = 0; i < projectedVerts.Length; i++)
            {
                _tsMesh.uv[i].x = Mathf.InverseLerp(max.x, min.x, projectedVerts[i].x) * uvScale.x - uvScale.x * 0.5f + uvOffset.x + 0.5f;
                _tsMesh.uv[i].y = Mathf.InverseLerp(min.y, max.y, projectedVerts[i].y) * uvScale.y - uvScale.y * 0.5f + uvOffset.y + 0.5f;
                _tsMesh.uv[i] = Quaternion.AngleAxis(uvRotation, Vector3.forward) * _tsMesh.uv[i];
            }
            #endregion


            if (flipCap)
            {
                for (int i = 0; i < surfaceVertexCount; i++)
                {
                    _tsMesh.normals[i] *= -1f;
                }
            }

            if (_expand != 0f)
            {
                for (int i = 0; i < surfaceVertexCount; i++)
                {
                    GetSample(i, ref evalResult);
                    _tsMesh.vertices[i] += (clockwise ? -evalResult.right : evalResult.right) * _expand;
                }
            }

            if (pathExtrude)
            {
                GetIdentityVerts(center, normal, clockwise);
                //Generate cap vertices with flipped normals
                for (int i = 0; i < surfaceVertexCount; i++)
                {
                    Vector3 vertexOffset = TransformOffset(extrudeResults[0], _extrudeOffset);
                    _tsMesh.vertices[i + surfaceVertexCount] = extrudeResults[0].position + (extrudeResults[0].rotation * identityVertices[i] + off) + vertexOffset;
                    _tsMesh.normals[i + surfaceVertexCount] = -extrudeResults[0].forward;
                    _tsMesh.colors[i + surfaceVertexCount] = _tsMesh.colors[i] * extrudeResults[0].color;
                    _tsMesh.uv[i + surfaceVertexCount] = new Vector2(1f - _tsMesh.uv[i].x, _tsMesh.uv[i].y);

                    vertexOffset = TransformOffset(extrudeResults[extrudeResults.Length - 1], _extrudeOffset);
                    _tsMesh.vertices[i] = extrudeResults[extrudeResults.Length - 1].position + (extrudeResults[extrudeResults.Length - 1].rotation * identityVertices[i] + off) + vertexOffset;
                    _tsMesh.normals[i] = extrudeResults[extrudeResults.Length - 1].forward;
                    _tsMesh.colors[i] *= extrudeResults[extrudeResults.Length - 1].color;
                }
                //Add wall vertices
                float totalLength = 0f;
                for (int i = 0; i < extrudeResults.Length; i++)
                {
                    if (_uniformUvs && i > 0) totalLength += Vector3.Distance(extrudeResults[i].position, extrudeResults[i - 1].position);
                    int startIndex = surfaceVertexCount * 2 + i * sampleCount;
                    for (int n = 0; n < identityVertices.Length; n++)
                    {
                        Vector3 vertexOffset = TransformOffset(extrudeResults[i], _extrudeOffset);
                        _tsMesh.vertices[startIndex + n] = extrudeResults[i].position + (extrudeResults[i].rotation * identityVertices[n] + off) + vertexOffset;
                        _tsMesh.normals[startIndex + n] = extrudeResults[i].rotation * identityNormals[n];
                        if (_uniformUvs)
                        {
                            _tsMesh.uv[startIndex + n] = new Vector2((float)n / (identityVertices.Length - 1) * _sideUvScale.x + _sideUvOffset.x, totalLength * _sideUvScale.y + _sideUvOffset.y);
                        }
                        else
                        {
                            _tsMesh.uv[startIndex + n] = new Vector2((float)n / (identityVertices.Length - 1) * _sideUvScale.x + _sideUvOffset.x, (float)i / (extrudeResults.Length - 1) * _sideUvScale.y + _sideUvOffset.y);
                        }
                        if (_sideUvRotation != 0f)
                        {
                            _tsMesh.uv[startIndex + n] = Quaternion.AngleAxis(_sideUvRotation, Vector3.forward) * _tsMesh.uv[startIndex + n];
                        }

                        if (clockwise)
                        {
                            _tsMesh.uv[startIndex + n].x = 1f - _tsMesh.uv[startIndex + n].x;
                        }
                    }
                }
                int written = WriteTris(ref surfaceTris, ref _tsMesh.triangles, 0, 0, false);
                written = WriteTris(ref surfaceTris, ref _tsMesh.triangles, surfaceVertexCount, written, true);

                MeshUtility.GeneratePlaneTriangles(ref wallTris, sampleCount - 1, extrudeResults.Length, flipSide, 0, 0, true);
                WriteTris(ref wallTris, ref _tsMesh.triangles, surfaceVertexCount * 2, written, false);
            }
            else if (simpleExtrude)
            {
                //Duplicate cap vertices with flipped normals
                for (int i = 0; i < surfaceVertexCount; i++)
                {
                    _tsMesh.vertices[i + surfaceVertexCount] = _tsMesh.vertices[i];
                    _tsMesh.normals[i + surfaceVertexCount] = -_tsMesh.normals[i];
                    _tsMesh.colors[i + surfaceVertexCount] = _tsMesh.colors[i];
                    _tsMesh.uv[i + surfaceVertexCount] = new Vector2(1f - _tsMesh.uv[i].x, _tsMesh.uv[i].y);
                    _tsMesh.vertices[i] += normal * _extrude;
                }

                //Add wall vertices
                for (int i = 0; i < surfaceVertexCount + 1; i++)
                {
                    int index = i;
                    if (i >= surfaceVertexCount) index = i - surfaceVertexCount;
                    GetSample(index, ref evalResult);
                    _tsMesh.vertices[i + surfaceVertexCount * 2] = _tsMesh.vertices[index] - normal * _extrude;
                    _tsMesh.normals[i + surfaceVertexCount * 2] = clockwise ? -evalResult.right : evalResult.right;
                    _tsMesh.colors[i + surfaceVertexCount * 2] = _tsMesh.colors[index];
                    _tsMesh.uv[i + surfaceVertexCount * 2] = new Vector2((float)i / (surfaceVertexCount - 1) * _sideUvScale.x + _sideUvOffset.x, 0f + _sideUvOffset.y);
                    if (clockwise)
                    {
                        _tsMesh.uv[i + surfaceVertexCount * 2].x = 1f - _tsMesh.uv[i + surfaceVertexCount * 2].x;
                    }

                    int offsetIndex = i + surfaceVertexCount * 3 + 1;
                    _tsMesh.vertices[offsetIndex] = _tsMesh.vertices[index];
                    _tsMesh.normals[offsetIndex] = _tsMesh.normals[i + surfaceVertexCount * 2];
                    _tsMesh.colors[offsetIndex] = _tsMesh.colors[index];
                    if (_uniformUvs)
                    {
                        _tsMesh.uv[offsetIndex] = new Vector2((float)i / surfaceVertexCount * _sideUvScale.x + _sideUvOffset.x, _extrude * _sideUvScale.y + _sideUvOffset.y);
                    }
                    else
                    {
                        _tsMesh.uv[offsetIndex] = new Vector2((float)i / surfaceVertexCount * _sideUvScale.x + _sideUvOffset.x, 1f * _sideUvScale.y + _sideUvOffset.y);
                    }
                    if (_sideUvRotation != 0f)
                    {
                        _tsMesh.uv[offsetIndex] = Quaternion.AngleAxis(_sideUvRotation, Vector3.forward) * _tsMesh.uv[offsetIndex];
                    }
                    if (clockwise)
                    {
                        _tsMesh.uv[offsetIndex].x = 1f - _tsMesh.uv[offsetIndex].x;
                    }
                }
                int written = WriteTris(ref surfaceTris, ref _tsMesh.triangles, 0, 0, false);
                written = WriteTris(ref surfaceTris, ref _tsMesh.triangles, surfaceVertexCount, written, true);

                MeshUtility.GeneratePlaneTriangles(ref wallTris, sampleCount - 1, 2, flipSide, 0, 0, true);
                WriteTris(ref wallTris, ref _tsMesh.triangles, surfaceVertexCount * 2, written, false);
            }
            else
            {
                WriteTris(ref surfaceTris, ref _tsMesh.triangles, 0, 0, false);
            }
        }

        private void GenerateSurfaceTris(bool flip)
        {
            MeshUtility.Triangulate(projectedVerts, ref surfaceTris);
            if (flip) MeshUtility.FlipTriangles(ref surfaceTris);
        }

        private int WriteTris(ref int[] tris, ref int[] target, int vertexOffset, int trisOffset, bool flip)
        {
            for (int i = trisOffset; i < trisOffset + tris.Length; i += 3)
            {
                if (flip)
                {
                    target[i] = tris[i + 2 - trisOffset] + vertexOffset;
                    target[i + 1] = tris[i + 1 - trisOffset] + vertexOffset;
                    target[i + 2] = tris[i - trisOffset] + vertexOffset;
                }
                else
                {
                    target[i] = tris[i - trisOffset] + vertexOffset;
                    target[i + 1] = tris[i + 1 - trisOffset] + vertexOffset;
                    target[i + 2] = tris[i + 2 - trisOffset] + vertexOffset;
                }
            }
            return trisOffset + tris.Length;
        }

        bool IsClockwise(Vector2[] points2D)
        {
            float sum = 0f;
            for (int i = 1; i < points2D.Length; i++)
            {
                Vector2 v1 = points2D[i];
                Vector2 v2 = points2D[(i + 1) % points2D.Length];
                sum += (v2.x - v1.x) * (v2.y + v1.y);
            }
            sum += (points2D[0].x - points2D[points2D.Length - 1].x) * (points2D[0].y + points2D[points2D.Length - 1].y);
            return sum <= 0f;
        }

        void GetIdentityVerts(Vector3 center, Vector3 normal, bool clockwise)
        {
            Quaternion vertsRotation = Quaternion.Inverse(Quaternion.LookRotation(normal));
            if (identityVertices.Length != sampleCount)
            {
                identityVertices = new Vector3[sampleCount];
                identityNormals = new Vector3[sampleCount];
            }
            for (int i = 0; i < sampleCount; i++)
            {
                GetSampleRaw(i, ref evalResult);
                Vector3 right = evalResult.right;
                identityVertices[i] = vertsRotation * (evalResult.position - center + (clockwise ? -right : right) * _expand);
                identityNormals[i] = vertsRotation * (clockwise ? -right : right);
            }
        }

        void GetProjectedVertices(int count, out Vector3 center, out Vector3 normal)
        {
            center = Vector3.zero;
            normal = Vector3.zero;
            Vector3 off = _trsRight * offset.x + _trsUp * offset.y + _trsForward * offset.z;
            for (int i = 0; i < count; i++)
            {
                GetSampleRaw(i, ref evalResult);
                center += evalResult.position + off;
                normal += evalResult.up;
            }
            normal.Normalize();
            center /= count;

            Quaternion rot = Quaternion.LookRotation(normal, Vector3.up);
            Vector3 up = rot * Vector3.up;
            Vector3 right = rot * Vector3.right;
            if (projectedVerts.Length != count) projectedVerts = new Vector2[count];
            for (int i = 0; i < count; i++)
            {
                GetSampleRaw(i, ref evalResult);
                Vector3 point = evalResult.position + off - center;
                float projectionPointX = Vector3.Project(point, right).magnitude;
                if (Vector3.Dot(point, right) < 0.0f) projectionPointX *= -1f;
                float projectionPointY = Vector3.Project(point, up).magnitude;
                if (Vector3.Dot(point, up) < 0.0f) projectionPointY *= -1f;
                projectedVerts[i].x = projectionPointX;
                projectedVerts[i].y = projectionPointY;
            }
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SurfaceGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/TubeGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 77ab80dc0820f9d4a8cd9fddbbc89057
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Threading;

namespace Dreamteck.Splines
{
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Dreamteck/Splines/Users/Tube Generator")]
    public class TubeGenerator : MeshGenerator
    {
        public enum CapMethod { None, Flat, Round }

        public int sides
        {
            get { return _sides; }
            set
            {
                if (value != _sides)
                {
                    if (value < 3) value = 3;
                    _sides = value;
                    Rebuild();
                }
            }
        }

        public CapMethod capMode
        {
            get { return _capMode; }
            set
            {
                if (value != _capMode)
                {
                    _capMode = value;
                    Rebuild();
                }
            }
        }

        public int roundCapLatitude
        {
            get { return _roundCapLatitude; }
            set
            {
                if (value < 1) value = 1;
                if (value != _roundCapLatitude)
                {
                    _roundCapLatitude = value;
                    if(_capMode == CapMethod.Round) Rebuild();
                }
            }
        }

        public float revolve
        {
            get { return _revolve; }
            set
            {
                if (value != _revolve)
                {
                    _revolve = value;
                    Rebuild();
                }
            }
        }

        public float capUVScale
        {
            get { return _capUVScale; }
            set
            {
                if (value != _capUVScale)
                {
                    _capUVScale = value;
                    Rebuild();
                }
            }
        }

        public float uvTwist
        {
            get { return _uvTwist; }
            set
            {
                if (value != _uvTwist)
                {
                    _uvTwist = value;
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private int _sides = 12;
        [SerializeField]
        [HideInInspector]
        private int _roundCapLatitude = 6;
        [SerializeField]
        [HideInInspector]
        private CapMethod _capMode = CapMethod.None;
        [SerializeField]
        [HideInInspector]
        [Range(0f, 360f)]
        private float _revolve = 360f;
        [SerializeField]
        [HideInInspector]
        private float _capUVScale = 1f;
        [SerializeField]
        [HideInInspector]
        private float _uvTwist = 0f;

        private bool useCap
        {
            get
            {
                bool isCapSet = _capMode != CapMethod.None;
                if (spline != null) return isCapSet && (!spline.isClosed || span < 1f);
                return isCapSet;
            }
        }

        protected override string meshName => "Tube";

        private int bodyVertexCount = 0;
        private int bodyTrisCount = 0;
        private int capVertexCount = 0;
        private int capTrisCount = 0;

        protected override void Reset()
        {
            base.Reset();
        }

        protected override void BuildMesh()
        {
            if (_sides <= 2) return;
            base.BuildMesh();
            bodyVertexCount = (_sides + 1) * sampleCount;
            CapMethod _capModeFinal = _capMode;
            if (!useCap)
            {
                _capModeFinal = CapMethod.None;
            }
            switch (_capModeFinal)
            {
                case CapMethod.Flat: capVertexCount = _sides + 1; break;
                case CapMethod.Round: capVertexCount = _roundCapLatitude * (sides + 1); break;
                default: capVertexCount = 0; break;
            }
            int vertexCount = bodyVertexCount + capVertexCount * 2;

            bodyTrisCount = _sides * (sampleCount - 1) * 2 * 3;
            switch (_capModeFinal)
            {
                case CapMethod.Flat: capTrisCount = (_sides - 1) * 3 * 2; break;
                case CapMethod.Round: capTrisCount = _sides * _roundCapLatitude * 6; break;
                default: capTrisCount = 0; break;
            }
            AllocateMesh(vertexCount, bodyTrisCount + capTrisCount * 2);

            Generate();
            switch (_capModeFinal)
            {
                case CapMethod.Flat: GenerateFlatCaps(); break;
                case CapMethod.Round: GenerateRoundCaps(); break;
            }
        }

        void Generate()
        {
            int vertexIndex = 0;
            ResetUVDistance();
            bool hasOffset = offset != Vector3.zero;
            for (int i = 0; i < sampleCount; i++)
            {
                GetSample(i, ref evalResult);
                Vector3 center = evalResult.position;
                Vector3 right = evalResult.right;
                float resultSize = GetBaseSize(evalResult);
                if (hasOffset)
                {
                    center += (offset.x * resultSize) * right + (offset.y * resultSize) * evalResult.up + (offset.z * resultSize) * evalResult.forward;
                }
                if (uvMode == UVMode.UniformClamp || uvMode == UVMode.UniformClip)
                {
                    AddUVDistance(i);
                }
                Color vertexColor = GetBaseColor(evalResult) * color;
                for (int n = 0; n < _sides + 1; n++)
                {
                    float anglePercent = (float)(n) / _sides;
                    Quaternion rot = Quaternion.AngleAxis(_revolve * anglePercent + rotation + 180f, evalResult.forward);
                    _tsMesh.vertices[vertexIndex] = center + rot * right * (size * resultSize * 0.5f);
                    CalculateUVs(evalResult.percent, anglePercent);
                    _tsMesh.uv[vertexIndex] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(uvRotation + 180f, Vector3.forward) * (Vector2.one * 0.5f - (__uvs + Vector2.right * ((float)evalResult.percent * _uvTwist))));
                    _tsMesh.normals[vertexIndex] = Vector3.Normalize(_tsMesh.vertices[vertexIndex] - center);
                    _tsMesh.colors[vertexIndex] = vertexColor;
                    vertexIndex++;
                }
            }
            MeshUtility.GeneratePlaneTriangles(ref _tsMesh.triangles, _sides, sampleCount, false);
        }

        void GenerateFlatCaps()
        {
            //Start Cap

            GetSample(0, ref evalResult);
            for (int i = 0; i < _sides+1; i++)
            {
                int index = bodyVertexCount + i;
                _tsMesh.vertices[index] = _tsMesh.vertices[i];
                _tsMesh.normals[index] = -evalResult.forward;
                _tsMesh.colors[index] = _tsMesh.colors[i];
                _tsMesh.uv[index] = Quaternion.AngleAxis(_revolve * (((float)i) / (_sides - 1)), Vector3.forward) * Vector2.right * (0.5f * capUVScale) + Vector3.right * 0.5f + Vector3.up * 0.5f;
            }

            //End Cap
            GetSample(sampleCount - 1, ref evalResult);
            for (int i = 0; i < _sides + 1; i++)
            {
                int index = bodyVertexCount + (_sides + 1) + i;
                int bodyIndex = bodyVertexCount - (_sides + 1) + i;
                _tsMesh.vertices[index] = _tsMesh.vertices[bodyIndex];
                _tsMesh.normals[index] = evalResult.forward;
                _tsMesh.colors[index] = _tsMesh.colors[bodyIndex];
                _tsMesh.uv[index] = Quaternion.AngleAxis(_revolve * ((float)(bodyIndex) / (_sides - 1)), Vector3.forward) * Vector2.right * (0.5f * capUVScale) + Vector3.right * 0.5f + Vector3.up * 0.5f;
            }

            int t = bodyTrisCount;
            bool fullIntegrity = _revolve == 360f;
            int finalSides = fullIntegrity ? _sides - 1 : _sides;
            //Start cap
            for (int i = 0; i < finalSides - 1; i++)
            {
                _tsMesh.triangles[t++] = i + bodyVertexCount + 2;
                _tsMesh.triangles[t++] = i + +bodyVertexCount + 1;
                _tsMesh.triangles[t++] = bodyVertexCount;
            }

            //End cap
            for (int i = 0; i < finalSides - 1; i++)
            {
                _tsMesh.triangles[t++] = bodyVertexCount + (_sides + 1);
                _tsMesh.triangles[t++] = i + 1 + bodyVertexCount + (_sides + 1);
                _tsMesh.triangles[t++] = i + 2 + bodyVertexCount + (_sides + 1);
            }
        }

        void GenerateRoundCaps()
        {
            //Start Cap
            GetSample(0, ref evalResult);
            Vector3 center = evalResult.position;
            bool hasOffset = offset != Vector3.zero;
            float resultSize = GetBaseSize(evalResult);
            if (hasOffset)
            {
                center += (offset.x * resultSize) * evalResult.right + (offset.y * resultSize) * evalResult.up + (offset.z * resultSize) * evalResult.forward;
            }
            Quaternion lookRot = Quaternion.LookRotation(-evalResult.forward, evalResult.up);
            float startV = 0f;
                        float capLengthPercent = 0f;
            switch (uvMode)
            {
                case UVMode.Clip: startV = (float)evalResult.percent;
                    capLengthPercent = (size * 0.5f) / spline.CalculateLength(); break;
                case UVMode.UniformClip:
                    startV = spline.CalculateLength(0.0, evalResult.percent);
                    capLengthPercent = size * 0.5f; break;
                case UVMode.UniformClamp:
                    startV = 0f;
                    capLengthPercent = size * 0.5f / (float)span;
                    break;
                case UVMode.Clamp: capLengthPercent = (size * 0.5f) / spline.CalculateLength(clipFrom, clipTo); break;
            }

            Color vertexColor = GetBaseColor(evalResult) * color;
            for (int lat = 1; lat < _roundCapLatitude+1; lat++)
            {
                float latitudePercent = ((float)lat / _roundCapLatitude);
                float latAngle = 90f * latitudePercent;
                for (int lon = 0; lon <= sides; lon++)
                {
                    float anglePercent = (float)lon / sides;
                    int index = bodyVertexCount + lon + (lat-1) * (sides + 1);
                    Quaternion rot = Quaternion.AngleAxis(_revolve * anglePercent + rotation + 180f, -Vector3.forward) * Quaternion.AngleAxis(latAngle, Vector3.up);
                    _tsMesh.vertices[index] = center + lookRot * rot * -Vector3.right * (size * 0.5f * evalResult.size);
                    _tsMesh.colors[index] = vertexColor;
                    _tsMesh.normals[index] = (_tsMesh.vertices[index] - center).normalized;
                    float baseV = startV + capLengthPercent * latitudePercent;
                    Vector2 baseUV = new Vector2(anglePercent * uvScale.x - baseV * _uvTwist, baseV * uvScale.y) - uvOffset;
                    _tsMesh.uv[index] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(uvRotation + 180f, Vector3.forward) * (Vector2.one * 0.5f - baseUV));
                }
            }


            //Triangles
            int t = bodyTrisCount;
            for (int z = -1; z < _roundCapLatitude - 1; z++)
            {
                for (int x = 0; x < sides; x++)
                {
                    int current = bodyVertexCount + x + z * (sides + 1);
                    int next = current + (sides + 1);
                    if (z == -1)
                    {
                        current = x;
                        next = bodyVertexCount + x;
                    }
                    _tsMesh.triangles[t++] = next + 1;
                    _tsMesh.triangles[t++] = current + 1;
                    _tsMesh.triangles[t++] = current;
                    _tsMesh.triangles[t++] = next;
                    _tsMesh.triangles[t++] = next + 1;
                    _tsMesh.triangles[t++] = current;
                }
            }


            //End Cap
            GetSample(sampleCount - 1, ref evalResult);
            center = evalResult.position;
            resultSize = GetBaseSize(evalResult);
            if (hasOffset)
            {
                center += (offset.x * resultSize) * evalResult.right + (offset.y * resultSize) * evalResult.up + (offset.z * resultSize) * evalResult.forward;
            }
            lookRot = Quaternion.LookRotation(evalResult.forward, evalResult.up);
            switch (uvMode)
            {
                case UVMode.Clip: startV = (float)evalResult.percent; break;
                case UVMode.UniformClip: startV = spline.CalculateLength(0.0, evalResult.percent); break;
                case UVMode.Clamp: startV = 1f; break;
                case UVMode.UniformClamp: startV = spline.CalculateLength(); break;
            }

            vertexColor = GetBaseColor(evalResult) * color;
            for (int lat = 1; lat < _roundCapLatitude+1; lat++)
            {
                float latitudePercent = ((float)lat / _roundCapLatitude);
                float latAngle = 90f * latitudePercent;
                for (int lon = 0; lon <= sides; lon++)
                {
                    float anglePercent = (float)lon / sides;
                    int index = bodyVertexCount + capVertexCount + lon + (lat - 1) * (sides + 1);
                    Quaternion rot = Quaternion.AngleAxis(_revolve * anglePercent + rotation + 180f, Vector3.forward) * Quaternion.AngleAxis(latAngle, -Vector3.up);
                    _tsMesh.vertices[index] = center + lookRot * rot * Vector3.right * size * 0.5f * evalResult.size;
                    _tsMesh.normals[index] = (_tsMesh.vertices[index] - center).normalized;
                    _tsMesh.colors[index] = vertexColor;
                    float baseV = startV + capLengthPercent * latitudePercent;
                    Vector2 baseUV = new Vector2(anglePercent * uvScale.x + baseV * _uvTwist, baseV * uvScale.y) - uvOffset;
                    _tsMesh.uv[index] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(uvRotation + 180f, Vector3.forward) * (Vector2.one * 0.5f - baseUV));
                } 
            }

            //Triangles
            for (int z = -1; z < _roundCapLatitude - 1; z++)
            {
                for (int x = 0; x < sides; x++)
                {
                    int current = bodyVertexCount + capVertexCount + x + z * (sides + 1);
                    int next = current + (sides + 1);
                    if (z == -1)
                    {
                        current = bodyVertexCount - (_sides+1) + x;
                        next = bodyVertexCount + capVertexCount + x;
                    }

                    _tsMesh.triangles[t++] = current+1;
                    _tsMesh.triangles[t++] = next + 1;
                    _tsMesh.triangles[t++] = next;
                    _tsMesh.triangles[t++] = next;
                    _tsMesh.triangles[t++] = current;
                    _tsMesh.triangles[t++] = current + 1;
                }
            }
            
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/TubeGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/WaveformGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0082a2f973246db418d848df591b7667
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace Dreamteck.Splines
{
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Dreamteck/Splines/Users/Waveform Generator")]
    public class WaveformGenerator : MeshGenerator
    {
        public enum Axis { X, Y, Z }
        public enum Space { World, Local }
        public enum UVWrapMode { Clamp, UniformX, UniformY, Uniform }

        public Axis axis
        {
            get { return _axis; }
            set
            {
                if (value != _axis)
                {
                    _axis = value;
                    Rebuild();
                }
            }
        }

        public bool symmetry
        {
            get { return _symmetry; }
            set
            {
                if (value != _symmetry)
                {
                    _symmetry = value;
                    Rebuild();
                }
            }
        }

        public UVWrapMode uvWrapMode
        {
            get { return _uvWrapMode; }
            set
            {
                if (value != _uvWrapMode)
                {
                    _uvWrapMode = value;
                    Rebuild();
                }
            }
        }

        public int slices
        {
            get { return _slices; }
            set
            {
                if (value != _slices)
                {
                    if (value < 1) value = 1;
                    _slices = value;
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private Axis _axis = Axis.Y;
        [SerializeField]
        [HideInInspector]
        private bool _symmetry = false;
        [SerializeField]
        [HideInInspector]
        private UVWrapMode _uvWrapMode = UVWrapMode.Clamp;
        [SerializeField]
        [HideInInspector]
        private int _slices = 1;

        protected override string meshName => "Waveform";

        protected override void BuildMesh()
        {
            base.BuildMesh();
            Generate();
        }

        protected override void Build()
        {
            base.Build();
        }

        protected override void LateRun()
        {
            base.LateRun();
        }

        private void Generate()
        {
            int vertexCount = sampleCount * (_slices + 1);
            AllocateMesh(vertexCount, _slices * (sampleCount - 1) * 6);
            int vertIndex = 0;
            float avgTop = 0f;
            float totalLength = 0f;
            Vector3 computerPosition = spline.position;
            Vector3 normal = spline.TransformDirection(Vector3.right);
            switch (_axis)
            {
                case Axis.Y: normal = spline.TransformDirection(Vector3.up); break;
                case Axis.Z: normal = spline.TransformDirection(Vector3.forward); break;
            }

            Vector3 lastPosition = Vector3.zero;
            for (int i = 0; i < sampleCount; i++)
            {
                GetSample(i, ref evalResult);
                float resultSize = GetBaseSize(evalResult);
                Vector3 samplePosition = evalResult.position;
                Vector3 localSamplePosition = spline.InverseTransformPoint(samplePosition);
                Vector3 bottomPosition = localSamplePosition;
                Vector3 sampleDirection = evalResult.forward;
                Vector3 sampleNormal = evalResult.up;

                float heightPercent = 1f;
                if (_uvWrapMode == UVWrapMode.UniformX || _uvWrapMode == UVWrapMode.Uniform)
                {
                    if (i > 0)
                    {
                        totalLength += Vector3.Distance(evalResult.position, lastPosition);
                    }
                }
                switch (_axis)
                {
                    case Axis.X: bottomPosition.x = _symmetry ? -localSamplePosition.x : 0f;  heightPercent = uvScale.y * Mathf.Abs(localSamplePosition.x); avgTop += localSamplePosition.x; break;
                    case Axis.Y: bottomPosition.y = _symmetry ? -localSamplePosition.y : 0f;  heightPercent = uvScale.y * Mathf.Abs(localSamplePosition.y); avgTop += localSamplePosition.y; break;
                    case Axis.Z: bottomPosition.z = _symmetry ? -localSamplePosition.z : 0f;  heightPercent = uvScale.y * Mathf.Abs(localSamplePosition.z); avgTop += localSamplePosition.z; break;
                }
                bottomPosition = spline.TransformPoint(bottomPosition);
                Vector3 right = Vector3.Cross(normal, sampleDirection).normalized;
                Vector3 offsetRight = Vector3.Cross(sampleNormal, sampleDirection);
                
                for (int n = 0; n < _slices + 1; n++)
                {
                    float slicePercent = ((float)n / _slices);
                    _tsMesh.vertices[vertIndex] = Vector3.Lerp(bottomPosition, samplePosition, slicePercent) + normal * (offset.y * resultSize) + offsetRight * (offset.x * resultSize);
                    _tsMesh.normals[vertIndex] = right;
                    switch (_uvWrapMode)
                    {
                        case UVWrapMode.Clamp: _tsMesh.uv[vertIndex] = new Vector2((float)evalResult.percent * uvScale.x + uvOffset.x, slicePercent * uvScale.y + uvOffset.y); break;
                        case UVWrapMode.UniformX: _tsMesh.uv[vertIndex] = new Vector2(totalLength * uvScale.x + uvOffset.x, slicePercent * uvScale.y + uvOffset.y); break;
                        case UVWrapMode.UniformY: _tsMesh.uv[vertIndex] = new Vector2((float)evalResult.percent * uvScale.x + uvOffset.x, heightPercent * slicePercent * uvScale.y + uvOffset.y); break;
                        case UVWrapMode.Uniform: _tsMesh.uv[vertIndex] = new Vector2(totalLength * uvScale.x + uvOffset.x, heightPercent * slicePercent * uvScale.y + uvOffset.y); break;
                    }
                    _tsMesh.colors[vertIndex] = GetBaseColor(evalResult) * color;
                    vertIndex++;
                }
                lastPosition = evalResult.position;
            }
            if (sampleCount > 0) avgTop /= sampleCount;
            MeshUtility.GeneratePlaneTriangles(ref _tsMesh.triangles, _slices, sampleCount, avgTop < 0f);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/WaveformGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/CSV.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c2313af4c5f59614393edd640d06f36c
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;using System.Collections.Generic;using UnityEngine;using System.IO;using System.Text.RegularExpressions;namespace Dreamteck.Splines.IO{    public class CSV : SplineParser    {        public enum ColumnType { Position, Tangent, Tangent2, Normal, Size, Color }        public List<ColumnType> columns = new List<ColumnType>();        private System.Globalization.CultureInfo culture = new System.Globalization.CultureInfo("en-US");        private System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Any;        public CSV(SplineComputer computer)        {            Spline spline = new Spline(computer.type, computer.sampleRate);            spline.points = computer.GetPoints();            if (spline.type != Spline.Type.Bezier && spline.type != Spline.Type.Linear) spline.CatToBezierTangents();            if (computer.isClosed) spline.Close();            buffer = new SplineDefinition(computer.name, spline);            fileName = computer.name;            columns.Add(ColumnType.Position);            columns.Add(ColumnType.Tangent);            columns.Add(ColumnType.Tangent2);        }        public CSV(string filePath, List<ColumnType> customColumns = null)        {            if (File.Exists(filePath))            {                string ext = Path.GetExtension(filePath).ToLower();                fileName = Path.GetFileNameWithoutExtension(filePath);                if (ext != ".csv")                {                    Debug.LogError("CSV Parsing ERROR: Wrong format. Please use SVG or XML");                    return;                }                string[] lines = File.ReadAllLines(filePath);                if (customColumns == null)                {                    columns.Add(ColumnType.Position);                    columns.Add(ColumnType.Tangent);                    columns.Add(ColumnType.Tangent2);                    columns.Add(ColumnType.Normal);                    columns.Add(ColumnType.Size);                    columns.Add(ColumnType.Color);                } else columns = new List<ColumnType>(customColumns);                buffer = new SplineDefinition(fileName, Spline.Type.CatmullRom);                Read(lines);            }        }        void Read(string[] lines)        {            int expectedElementCount = 0;            foreach (ColumnType col in columns)            {                switch (col)                {                    case ColumnType.Position: expectedElementCount +=3; break;                    case ColumnType.Tangent: expectedElementCount += 3; break;                    case ColumnType.Tangent2: expectedElementCount += 3; break;                    case ColumnType.Normal: expectedElementCount += 3; break;                    case ColumnType.Size: expectedElementCount ++; break;                    case ColumnType.Color: expectedElementCount += 4; break;                }            }            for (int i = 1; i < lines.Length; i++)            {                lines[i] = Regex.Replace(lines[i], @"\s+", "");                string[] elements = lines[i].Split(',');                if(elements.Length != expectedElementCount)                {                    Debug.LogError("Unexpected element count on row " + i + ". Expected " + expectedElementCount +  " found " + elements.Length + " Please make sure that all values exist and the column order is correct.");                    continue;                }                float[] values = new float[elements.Length];                for (int j = 0; j < elements.Length; j++)                {                    float.TryParse(elements[j], style, culture, out values[j]);                }                int currentValue = 0;                foreach (ColumnType col in columns)                {                    switch (col)                    {                        case ColumnType.Position: buffer.position = new Vector3(values[currentValue++], values[currentValue++], values[currentValue++]); break;                        case ColumnType.Tangent: buffer.tangent = new Vector3(values[currentValue++], values[currentValue++], values[currentValue++]); break;                        case ColumnType.Tangent2: buffer.tangent2 = new Vector3(values[currentValue++], values[currentValue++], values[currentValue++]); break;                        case ColumnType.Normal: buffer.normal = new Vector3(values[currentValue++], values[currentValue++], values[currentValue++]); break;                        case ColumnType.Size: buffer.size = values[currentValue++]; break;                        case ColumnType.Color: buffer.color = new Color(values[currentValue++], values[currentValue++], values[currentValue++], values[currentValue++]); break;                    }                }                buffer.CreateSmooth();            }        }        public SplineComputer CreateSplineComputer(Vector3 position, Quaternion rotation)        {            return buffer.CreateSplineComputer(position, rotation);        }        public Spline CreateSpline()        {            return buffer.CreateSpline();        }        public void FlatX()        {            for (int i = 0; i < buffer.pointCount; i++)            {                buffer.points[i].Flatten(LinearAlgebraUtility.Axis.X);            }        }        public void FlatY()        {            for (int i = 0; i < buffer.pointCount; i++)            {                buffer.points[i].Flatten(LinearAlgebraUtility.Axis.Y);            }        }        public void FlatZ()        {            for (int i = 0; i < buffer.pointCount; i++)            {                buffer.points[i].Flatten(LinearAlgebraUtility.Axis.Z);            }        }        void AddTitle(ref string[] content, string title)        {            if (!string.IsNullOrEmpty(content[0])) content[0] += ",";            content[0] += title;        }        void AddVector3Title(ref string[] content, string prefix)        {            AddTitle(ref content, prefix + "X," + prefix + "Y," + prefix + "Z");        }        void AddColorTitle(ref string[] content, string prefix)        {            AddTitle(ref content, prefix + "R," + prefix + "G," + prefix + "B" + prefix + "A");        }        void AddVector3(ref string[] content, int index, Vector3 vector)        {            AddFloat(ref content, index, vector.x);            AddFloat(ref content, index, vector.y);            AddFloat(ref content, index, vector.z);        }        void AddColor(ref string[] content, int index, Color color)        {            AddFloat(ref content, index, color.r);            AddFloat(ref content, index, color.g);            AddFloat(ref content, index, color.b);            AddFloat(ref content, index, color.a);        }        void AddFloat(ref string[] content, int index, float value)        {            if (!string.IsNullOrEmpty(content[index])) content[index] += ",";            content[index] += value.ToString();        }        public void Write(string filePath)        {            if (!Directory.Exists(Path.GetDirectoryName(filePath)))  throw new DirectoryNotFoundException("The file is being saved to a non-existing directory.");            List<SplinePoint> csvPoints = buffer.points;            string[] content = new string[csvPoints.Count+1];            //Add the column titles            foreach(ColumnType col in columns)            {                switch (col)                {                    case ColumnType.Position: AddVector3Title(ref content, "Position"); break;                    case ColumnType.Tangent: AddVector3Title(ref content, "Tangent"); break;                    case ColumnType.Tangent2: AddVector3Title(ref content, "Tangent2"); break;                    case ColumnType.Normal: AddVector3Title(ref content, "Normal"); break;                    case ColumnType.Size: AddTitle(ref content, "Size"); break;                    case ColumnType.Color: AddColorTitle(ref content, "Color"); break;                }            }            //Add the content for each column            foreach (ColumnType col in columns)            {                for (int i = 1; i <= csvPoints.Count; i++)                {                    int index = i - 1;                    switch (col)                    {                        case ColumnType.Position: AddVector3(ref content, i, csvPoints[index].position); break;                        case ColumnType.Tangent: AddVector3(ref content, i, csvPoints[index].tangent); break;                        case ColumnType.Tangent2: AddVector3(ref content, i, csvPoints[index].tangent2); break;                        case ColumnType.Normal: AddVector3(ref content, i, csvPoints[index].normal); break;                        case ColumnType.Size: AddFloat(ref content, i, csvPoints[index].size); break;                        case ColumnType.Color: AddColor(ref content, i, csvPoints[index].color); break;                    }                }            }            File.WriteAllLines(filePath, content);        }    }}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/CSV.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/SplineParser.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 62e998669a36f6946b5d107a292616b0
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.IO
{
    public class SplineParser 
    {
        protected string fileName = "";
        public string name
        {
            get { return fileName; }
        }

        private System.Globalization.CultureInfo culture = new System.Globalization.CultureInfo("en-US");
        private System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Any;

        internal class Transformation
        {
            protected static Matrix4x4 matrix = new Matrix4x4();

            internal static void ResetMatrix()
            {
                matrix.SetTRS(Vector3.zero, Quaternion.identity, Vector3.one);
            }

            internal virtual void Push()
            {

            }

            internal static void Apply(SplinePoint[] points)
            {
                for (int i = 0; i < points.Length; i++)
                {
                    SplinePoint p = points[i];
                    p.position = matrix.MultiplyPoint(p.position);
                    p.tangent = matrix.MultiplyPoint(p.tangent);
                    p.tangent2 = matrix.MultiplyPoint(p.tangent2);
                    points[i] = p;
                }
            }
        }

        internal class Translate : Transformation
        {
            private Vector2 offset = Vector2.zero;
            public Translate(Vector2 o)
            {
                offset = o;
            }

            internal override void Push()
            {
                Matrix4x4 translate = new Matrix4x4();
                translate.SetTRS(new Vector2(offset.x, -offset.y), Quaternion.identity, Vector3.one);
                matrix = matrix * translate;
            }
        }

        internal class Rotate : Transformation
        {
            private float angle = 0f;
            public Rotate(float a)
            {
                angle = a;
            }

            internal override void Push()
            {
                Matrix4x4 rotate = new Matrix4x4();
                rotate.SetTRS(Vector3.zero, Quaternion.AngleAxis(angle, Vector3.back), Vector3.one);
                matrix = matrix * rotate;
            }
        }

        internal class Scale : Transformation
        {
            private Vector2 multiplier = Vector2.one;
            public Scale(Vector2 s)
            {
                multiplier = s;
            }

            internal override void Push()
            {
                Matrix4x4 scale = new Matrix4x4();
                scale.SetTRS(Vector3.zero, Quaternion.identity, multiplier);
                matrix = matrix * scale;
            }
        }

        internal class SkewX : Transformation
        {
            private float amount = 0f;
            public SkewX(float a)
            {
                amount = a;
            }

            internal override void Push()
            {
                Matrix4x4 skew = new Matrix4x4();
                skew[0, 0] = 1.0f;
                skew[1, 1] = 1.0f;
                skew[2, 2] = 1.0f;
                skew[3, 3] = 1.0f;
                skew[0, 1] = Mathf.Tan(-amount * Mathf.Deg2Rad);
                matrix = matrix * skew;
            }
        }

        internal class SkewY : Transformation
        {
            private float amount = 0f;
            public SkewY(float a)
            {
                amount = a;
            }

            internal override void Push()
            {
                Matrix4x4 skew = new Matrix4x4();
                skew[0, 0] = 1.0f;
                skew[1, 1] = 1.0f;
                skew[2, 2] = 1.0f;
                skew[3, 3] = 1.0f;
                skew[1, 0] = Mathf.Tan(-amount * Mathf.Deg2Rad);
                matrix = matrix *skew;
            }
        }

        internal class MatrixTransform : Transformation
        {
            private Matrix4x4 transformMatrix = new Matrix4x4();

            public MatrixTransform(float a, float b, float c, float d, float e, float f)
            { 
                transformMatrix.SetRow(0, new Vector4(a, c, 0f, e));
                transformMatrix.SetRow(1, new Vector4(b, d, 0f, -f));
                transformMatrix.SetRow(2, new Vector4(0f, 0f, 1f, 0f));
                transformMatrix.SetRow(3, new Vector4(0f, 0f, 0f, 1f));
            }

            internal override void Push()
            {
                matrix = matrix * transformMatrix;
            }
        }


        internal class SplineDefinition
        {
            internal string name = "";
            internal Spline.Type type = Spline.Type.Linear;
            internal List<SplinePoint> points = new List<SplinePoint>();
            internal bool closed = false;

            internal int pointCount
            {
                get { return points.Count; }
            }

            internal Vector3 position = Vector3.zero;
            internal Vector3 tangent = Vector3.zero;
            internal Vector3 tangent2 = Vector3.zero;
            internal Vector3 normal = Vector3.back;
            internal float size = 1f;
            internal Color color = Color.white;

            internal SplineDefinition(string n, Spline.Type t)
            {
                name = n;
                type = t;
            }

            internal SplineDefinition(string n, Spline spline)
            {
                name = n;
                type = spline.type;
                closed = spline.isClosed;
                points = new List<SplinePoint>(spline.points);
            }

            internal SplinePoint GetLastPoint()
            {
                if (points.Count == 0) return new SplinePoint();
                return points[points.Count - 1];
            }

            internal void SetLastPoint(SplinePoint point)
            {
                if (points.Count == 0) return;
                points[points.Count - 1] = point;
            }

            internal void CreateClosingPoint()
            {
                SplinePoint p = new SplinePoint(points[0]);
                points.Add(p);
            }

            internal void CreateSmooth()
            {
                points.Add(new SplinePoint(position, tangent, normal, size, color));
            }

            internal void CreateBroken()
            {
                SplinePoint point = new SplinePoint(new SplinePoint(position, tangent, normal, size, color));
                point.type = SplinePoint.Type.Broken;
                point.SetTangent2Position(point.position);
                point.normal = normal;
                point.color = color;
                point.size = size;
                points.Add(point);
            }

            internal void CreateLinear()
            {
                tangent = position;
                CreateSmooth();
            }

            internal SplineComputer CreateSplineComputer(Vector3 position, Quaternion rotation)
            {
                GameObject go = new GameObject(name);
                go.transform.position = position;
                go.transform.rotation = rotation;
                SplineComputer computer = go.AddComponent<SplineComputer>();
#if UNITY_EDITOR
                if(Application.isPlaying) computer.ResampleTransform();
#endif
                computer.type = type;
                if(closed)
                {
                    if (points[0].type == SplinePoint.Type.Broken) points[0].SetTangentPosition(GetLastPoint().tangent2);
                }
                computer.SetPoints(points.ToArray(), SplineComputer.Space.Local);
                if (closed) computer.Close();
                return computer;
            }

            internal Spline CreateSpline()
            {
                Spline spline = new Spline(type);
                spline.points = points.ToArray();
                if (closed) spline.Close();
                return spline;
            }

            internal void Transform(List<Transformation> trs)
            {
                SplinePoint[] p = points.ToArray();
                Transformation.ResetMatrix();
                foreach(Transformation t in trs) t.Push();
                Transformation.Apply(p);
                for (int i = 0; i < p.Length; i++) points[i] = p[i];
                SplinePoint[] debugPoints = new SplinePoint[1];
                debugPoints[0] = new SplinePoint();
                Transformation.Apply(debugPoints);
            }
        }

        internal SplineDefinition buffer = null;

        internal Vector2[] ParseVector2(string coord)
        {
            List<float> list = ParseFloatArray(coord.Substring(1));
            int count = list.Count / 2;
            if (count == 0)
            {
                Debug.Log("Error in " + coord);
                return new Vector2[] { Vector2.zero };
            }
            Vector2[] vectors = new Vector2[count];
            for (int i = 0; i < count; i++)
            {
                vectors[i] = new Vector2(list[0 + i * 2], -list[1 + i * 2]);
            }
            return vectors;
        }

        internal float[] ParseFloat(string coord)
        {
            List<float> list = ParseFloatArray(coord.Substring(1));
            if (list.Count < 1)
            {
                Debug.Log("Error in " + coord);
                return new float[] { 0f };
            }
            return list.ToArray();
        }

        internal List<float> ParseFloatArray(string content)
        {
            string accumulated = "";
            List<float> list = new List<float>();
            foreach (char c in content)
            {
                if (c == ',' || c == '-' || char.IsWhiteSpace(c) || (accumulated.Contains(".") && c == '.'))
                {
                    if (!IsWHiteSpace(accumulated))
                    {
                        float parsed = 0f;
                        float.TryParse(accumulated, style, culture, out parsed);
                        list.Add(parsed);
                        accumulated = "";
                        if (c == '-') accumulated = "-";
                        if (c == '.') accumulated = "0.";
                        continue;
                    }
                }
                if (!char.IsWhiteSpace(c)) accumulated += c;
            }
            if (!IsWHiteSpace(accumulated))
            {
                float p = 0f;
                float.TryParse(accumulated, style, culture, out p);
                list.Add(p);
            }
            return list;
        }

        public bool IsWHiteSpace(string s)
        {
            foreach (char c in s)
            {
                if (!char.IsWhiteSpace(c))
                {
                    return false;
                }
            }
            return true;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/SplineParser.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/SVG.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9b2394d649216f5479fddeb2b08a6628
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Text.RegularExpressions;
using System.Linq;
using Dreamteck.Splines.Primitives;
using System;

namespace Dreamteck.Splines.IO
{
    public class SVG : SplineParser
    {
        public enum Axis { X, Y, Z }
        internal class PathSegment 
        {
            internal Vector3 startTangent = Vector3.zero;
            internal Vector3 endTangent = Vector3.zero;
            internal Vector3 endPoint = Vector3.zero;
            internal enum Type { Cubic, CubicShort, Quadratic, QuadraticShort }

            internal PathSegment(Vector2 s, Vector2 e, Vector2 c)
            {
                startTangent = s;
                endTangent = e;
                endPoint = c;
            }

            internal PathSegment()
            {

            }
        }

        public enum Element { All, Path, Polygon, Ellipse, Rectangle, Line }
        private System.Globalization.CultureInfo culture = new System.Globalization.CultureInfo("en-US");
        private System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Any;
        List<SplineDefinition> paths = new List<SplineDefinition>();
        List<SplineDefinition> polygons = new List<SplineDefinition>();
        List<SplineDefinition> ellipses = new List<SplineDefinition>();
        List<SplineDefinition> rectangles = new List<SplineDefinition>();
        List<SplineDefinition> lines = new List<SplineDefinition>();

        List<Transformation> transformBuffer = new List<Transformation>();

        public SVG(string filePath)
        {
            if (File.Exists(filePath))
            {
                string ext = Path.GetExtension(filePath).ToLower();
                fileName = Path.GetFileNameWithoutExtension(filePath);
                if (ext != ".svg" && ext != ".xml")
                {
                    Debug.LogError("SVG Parsing ERROR: Wrong format. Please use SVG or XML");
                    return;
                }
                XmlDocument doc = new XmlDocument();
                doc.XmlResolver = null;
                try
                {
                    doc.Load(filePath);
                }
                catch (XmlException ex)
                {
                    Debug.LogError(ex.Message);
                    return;
                }
                Read(doc);
            }
        }

        public SVG(List<SplineComputer> computers)
        {
            paths = new List<SplineDefinition>(computers.Count);
            for (int i = 0; i < computers.Count; i++)
            {
                if (computers[i] == null) continue;
                Spline spline = new Spline(computers[i].type, computers[i].sampleRate);
                spline.points = computers[i].GetPoints();
                if (spline.type != Spline.Type.Bezier && spline.type != Spline.Type.Linear) spline.CatToBezierTangents();
                if (computers[i].isClosed) spline.Close();
                paths.Add(new SplineDefinition(computers[i].name, spline));
            }
        }

        public void Write(string filePath, Axis ax = Axis.Z)
        {
            XmlDocument doc = new XmlDocument();
            XmlElement svg = doc.CreateElement("svg");
            foreach (SplineDefinition path in paths)
            {
                string elementName = "path";
                string attributeName = "d";
                if (path.type == Spline.Type.Linear)
                {
                    attributeName = "points";
                    if (path.closed) elementName = "polygon";
                    else elementName = "polyline";
                }
                XmlElement splineNode = doc.CreateElement(elementName);
                XmlAttribute splineAttribute = doc.CreateAttribute("id");
                splineAttribute.Value = path.name;
                splineNode.Attributes.Append(splineAttribute);
                splineAttribute = doc.CreateAttribute(attributeName);
                if (path.type == Spline.Type.Linear) splineAttribute.Value = EncodePolygon(path, ax);
                else splineAttribute.Value = EncodePath(path, ax);
                splineNode.Attributes.Append(splineAttribute);
                splineAttribute = doc.CreateAttribute("stroke");
                splineAttribute.Value = "black";
                splineNode.Attributes.Append(splineAttribute);
                splineAttribute = doc.CreateAttribute("stroke-width");
                splineAttribute.Value = "3";
                splineNode.Attributes.Append(splineAttribute);
                splineAttribute = doc.CreateAttribute("fill");
                splineAttribute.Value = "none";
                splineNode.Attributes.Append(splineAttribute);
                svg.AppendChild(splineNode);
            }
            XmlAttribute svgAttribute = doc.CreateAttribute("version");
            svgAttribute.Value = "1.1";
            svg.Attributes.Append(svgAttribute);
            svgAttribute = doc.CreateAttribute("xmlns");
            svgAttribute.Value = "http://www.w3.org/2000/svg";
            svg.Attributes.Append(svgAttribute);
            doc.AppendChild(svg);
            doc.Save(filePath);
        }

        Vector2 MapPoint(Vector3 original, Axis ax)
        {
            switch (ax)
            {
                case Axis.X: return new Vector2(original.z, -original.y);
                case Axis.Y: return new Vector2(original.x, -original.z);
                case Axis.Z: return new Vector2(original.x, -original.y);
            }
            return original;
        }

        private void Read(XmlDocument doc)
        {
            transformBuffer.Clear();
            Traverse(doc.ChildNodes);
        }

        private void Traverse(XmlNodeList nodes)
        {
            foreach (XmlNode node in nodes)
            {
                int addedTransforms = 0;
                switch (node.Name)
                {
                    case "g": addedTransforms = ParseTransformation(node); break;
                    case "path": addedTransforms = ReadPath(node); break;
                    case "polygon": addedTransforms = ReadPolygon(node, true); break;
                    case "polyline": addedTransforms = ReadPolygon(node, false); break;
                    case "ellipse": addedTransforms = ReadEllipse(node); break;
                    case "circle": addedTransforms = ReadEllipse(node); break;
                    case "line": addedTransforms = ReadLine(node); break;
                    case "rect": addedTransforms = ReadRectangle(node); break;
                }
                Traverse(node.ChildNodes);
                if (addedTransforms > 0) transformBuffer.RemoveRange(transformBuffer.Count - addedTransforms, addedTransforms);
            }
        }

        public List<SplineComputer> CreateSplineComputers(Vector3 position, Quaternion rotation, Element elements = Element.All)
        {
            List<SplineComputer> computers = new List<SplineComputer>();
            if (elements == Element.All || elements == Element.Path)
            {
                foreach (SplineDefinition definition in paths) computers.Add(definition.CreateSplineComputer(position, rotation));
            }
            if (elements == Element.All || elements == Element.Polygon)
            {
                foreach (SplineDefinition definition in polygons) computers.Add(definition.CreateSplineComputer(position, rotation));
            }
            if (elements == Element.All || elements == Element.Ellipse)
            {
                foreach (SplineDefinition definition in ellipses) computers.Add(definition.CreateSplineComputer(position, rotation));
            }
            if (elements == Element.All || elements == Element.Rectangle)
            {
                foreach (SplineDefinition definition in rectangles) computers.Add(definition.CreateSplineComputer(position, rotation));
            }
            if (elements == Element.All || elements == Element.Line)
            {
                foreach (SplineDefinition definition in lines) computers.Add(definition.CreateSplineComputer(position, rotation));
            }
            return computers;
        }

        public List<Spline> CreateSplines(Element elements = Element.All)
        {
            List<Spline> splines = new List<Spline>();
            if (elements == Element.All || elements == Element.Path)
            {
                foreach (SplineDefinition definition in paths) splines.Add(definition.CreateSpline());
            }
            if (elements == Element.All || elements == Element.Polygon)
            {
                foreach (SplineDefinition definition in polygons) splines.Add(definition.CreateSpline());
            }
            if (elements == Element.All || elements == Element.Ellipse)
            {
                foreach (SplineDefinition definition in ellipses) splines.Add(definition.CreateSpline());
            }
            if (elements == Element.All || elements == Element.Rectangle)
            {
                foreach (SplineDefinition definition in rectangles) splines.Add(definition.CreateSpline());
            }
            if (elements == Element.All || elements == Element.Line)
            {
                foreach (SplineDefinition definition in lines) splines.Add(definition.CreateSpline());
            }
            return splines;
        }

        private int ReadRectangle(XmlNode rectNode)
        {
            float x = 0f, y = 0f, w = 0f, h = 0f, rx = -1f, ry = -1f;
            string attribute = GetAttributeContent(rectNode, "x");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out x);
            attribute = GetAttributeContent(rectNode, "y");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out y);
            attribute = GetAttributeContent(rectNode, "width");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out w);
            attribute = GetAttributeContent(rectNode, "height");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out h);
            attribute = GetAttributeContent(rectNode, "rx");
            if (attribute != "ERROR") float.TryParse(attribute, style, culture, out rx);
            attribute = GetAttributeContent(rectNode, "ry");
            if (attribute != "ERROR") float.TryParse(attribute, style, culture, out ry);
            else ry = rx;
            string elementName = GetAttributeContent(rectNode, "id");

            if (rx == -1f && ry == -1f)
            {
                Rectangle rect = new Rectangle();
                rect.offset = new Vector2(x + w / 2f, -y - h / 2f);
                rect.size = new Vector2(w, h);
                if (elementName == "ERROR") elementName = fileName + "_rectangle" + (rectangles.Count + 1);
                buffer = new SplineDefinition(elementName, rect.CreateSpline());
            }
            else
            {
                RoundedRectangle rect = new RoundedRectangle();
                rect.offset = new Vector2(x + w / 2f, -y - h / 2f);
                rect.size = new Vector2(w, h);
                rect.xRadius = rx;
                rect.yRadius = ry;
                if (elementName == "ERROR") elementName = fileName + "_roundedRectangle" + (rectangles.Count + 1);
                buffer = new SplineDefinition(elementName, rect.CreateSpline());
            }
            int addedTransforms = ParseTransformation(rectNode);
            WriteBufferTo(rectangles);
            return addedTransforms;
        }

        private int ReadLine(XmlNode lineNode)
        {
            float startX = 0f, startY = 0f, endX = 0f, endY = 0f;
            string attribute = GetAttributeContent(lineNode, "x1");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out startX);
            attribute = GetAttributeContent(lineNode, "y1");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out startY);
            attribute = GetAttributeContent(lineNode, "x2");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out endX);
            attribute = GetAttributeContent(lineNode, "y2");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out endY);
            string elementName = GetAttributeContent(lineNode, "id");
            if (elementName == "ERROR") elementName = fileName + "_line" + (ellipses.Count + 1);
            buffer = new SplineDefinition(elementName, Spline.Type.Linear);
            buffer.position = new Vector2(startX, -startY);
            buffer.CreateLinear();
            buffer.position = new Vector2(endX, -endY);
            buffer.CreateLinear();
            int addedTransforms = ParseTransformation(lineNode);
            WriteBufferTo(lines);
            return addedTransforms;
        }

        private int ReadEllipse(XmlNode ellipseNode)
        {
            float x = 0f, y = 0f, rx = 0f, ry = 0f;
            string attribute = GetAttributeContent(ellipseNode, "cx");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out x);
            attribute = GetAttributeContent(ellipseNode, "cy");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out y);
            attribute = GetAttributeContent(ellipseNode, "r");
            string shapeName = "circle";
            if (attribute == "ERROR") //It might be an ellipse
            {
                shapeName = "ellipse";
                attribute = GetAttributeContent(ellipseNode, "rx");
                if (attribute == "ERROR") return 0;
                float.TryParse(attribute, style, culture, out rx);
                attribute = GetAttributeContent(ellipseNode, "ry");
                if (attribute == "ERROR") return 0;
            }
            else //Nope, it's a circle
            {
                float.TryParse(attribute, style, culture, out rx);
                ry = rx;
            }
            float.TryParse(attribute, style, culture, out ry);
            Ellipse ellipse = new Ellipse();
            ellipse.offset = new Vector2(x, -y);
            ellipse.xRadius = rx;
            ellipse.yRadius = ry;

            string elementName = GetAttributeContent(ellipseNode, "id");
            if (elementName == "ERROR") elementName = fileName + "_" + shapeName + (ellipses.Count + 1);
            buffer = new SplineDefinition(elementName, ellipse.CreateSpline());
            int addedTransforms = ParseTransformation(ellipseNode);
            WriteBufferTo(ellipses);
            return addedTransforms;
        }

        private int ReadPolygon(XmlNode polyNode, bool closed)
        {
            string contents = GetAttributeContent(polyNode, "points");
            if (contents == "ERROR") return 0;
            List<float> coords = ParseFloatArray(contents);
            if (coords.Count % 2 != 0)
            {
                Debug.LogWarning("There is an error with one of the polygon shapes.");
                return 0;
            }
            string elementName = GetAttributeContent(polyNode, "id");
            if (elementName == "ERROR") elementName = fileName + (closed ? "_polygon " : "_polyline") + (polygons.Count + 1);
            buffer = new SplineDefinition(elementName, Spline.Type.Linear);
            int count = coords.Count / 2;
            for (int i = 0; i < count; i++)
            {
                buffer.position = new Vector2(coords[0 + 2 * i], -coords[1 + 2 * i]);
                buffer.CreateLinear();
            }
            if (closed)
            {
                buffer.CreateClosingPoint();
                buffer.closed = true;
            }
            int addedTransforms = ParseTransformation(polyNode);
            WriteBufferTo(polygons);
            return addedTransforms;
        }

        private int ParseTransformation(XmlNode node)
        {
            string transformAttribute = GetAttributeContent(node, "transform");
            if (transformAttribute == "ERROR") return 0;
            List<Transformation> trs = ParseTransformations(transformAttribute);
            transformBuffer.AddRange(trs);
            return trs.Count;
        }

        private List<Transformation> ParseTransformations(string transformContent)
        {
            List<Transformation> trs = new List<Transformation>();
            MatchCollection matches = Regex.Matches(transformContent.ToLower(), @"(?<function>translate|rotate|scale|skewx|skewy|matrix)\s*\((\s*(?<param>-?\s*\d+(\.\d+)?)\s*\,*\s*)+\)");
            foreach (Match match in matches)
            {
                if (match.Groups["function"].Success)
                {
                    CaptureCollection parameters = match.Groups["param"].Captures;
                    switch (match.Groups["function"].Value)
                    {
                        case "translate":
                            if (parameters.Count < 2) break;
                            trs.Add(new Translate(new Vector2(float.Parse(parameters[0].Value), float.Parse(parameters[1].Value))));
                            break;
                        case "rotate":
                            if (parameters.Count < 1) break;
                            trs.Add(new Rotate(float.Parse(parameters[0].Value)));
                            break;
                        case "scale":
                            if (parameters.Count < 2) break;
                            trs.Add(new Scale(new Vector2(float.Parse(parameters[0].Value), float.Parse(parameters[1].Value))));
                            break;
                        case "skewx":
                            if (parameters.Count < 1) break;
                            trs.Add(new SkewX(float.Parse(parameters[0].Value)));
                            break;
                        case "skewy":
                            if (parameters.Count < 1) break;
                            trs.Add(new SkewY(float.Parse(parameters[0].Value)));
                            break;
                        case "matrix":
                            if (parameters.Count < 6) break;
                            trs.Add(new MatrixTransform(float.Parse(parameters[0].Value), float.Parse(parameters[1].Value), float.Parse(parameters[2].Value), float.Parse(parameters[3].Value), float.Parse(parameters[4].Value), float.Parse(parameters[5].Value)));
                            break;
                    }
                }
            }
            return trs;
        }

        private int ReadPath(XmlNode pathNode)
        {
            string contents = GetAttributeContent(pathNode, "d");
            if (contents == "ERROR") return 0;
            string elementName = GetAttributeContent(pathNode, "id");
            if (elementName == "ERROR") elementName = fileName + "_path " + (paths.Count + 1);
            IEnumerable<string> tokens = Regex.Split(contents, @"(?=[A-Za-z])").Where(t => !string.IsNullOrEmpty(t));
            int numSplines = 0;
            foreach (string token in tokens)
            {
                char cmd = token.Substring(0, 1).Single();
                switch (cmd)
                {
                    case 'M':
                        PathStart(elementName, token, false);
                        ++numSplines;
                        break;
                    case 'm':
                        PathStart(elementName, token, true);
                        ++numSplines;
                        break;
                    case 'Z':
                        PathClose();
                        break;
                    case 'z':
                        PathClose();
                        break;
                    case 'L':
                        PathLineTo(token, false);
                        break;
                    case 'l':
                        PathLineTo(token, true);
                        break;
                    case 'H':
                        PathHorizontalLineTo(token, false);
                        break;
                    case 'h':
                        PathHorizontalLineTo(token, true);
                        break;
                    case 'V':
                        PathVerticalLineTo(token, false);
                        break;
                    case 'v':
                        PathVerticalLineTo(token, true);
                        break;
                    case 'C':
                        PathCurveTo(token, PathSegment.Type.Cubic, false);
                        break;
                    case 'c':
                        PathCurveTo(token, PathSegment.Type.Cubic, true);
                        break;
                    case 'S':
                        PathCurveTo(token, PathSegment.Type.CubicShort, false);
                        break;
                    case 's':
                        PathCurveTo(token, PathSegment.Type.CubicShort, true);
                        break;
                    case 'Q':
                        PathCurveTo(token, PathSegment.Type.Quadratic, false);
                        break;
                    case 'q':
                        PathCurveTo(token, PathSegment.Type.Quadratic, true);
                        break;
                    case 'T':
                        PathCurveTo(token, PathSegment.Type.QuadraticShort, false);
                        break;
                    case 't':
                        PathCurveTo(token, PathSegment.Type.QuadraticShort, true);
                        break;
                    case 'A':
                        PathArcTo(token, false);
                        break;
                    case 'a':
                        PathArcTo(token, true);
                        break;
                }
            }
            if (buffer != null) WriteBufferTo(paths);
            int addedTransforms = ParseTransformation(pathNode);
            for (int i = paths.Count - 1; i >= paths.Count - numSplines; --i) paths[i].Transform(transformBuffer);
            return addedTransforms;
        }

        private void PathStart(string name, string coords, bool relative)
        {
            if (buffer != null) WriteBufferTo(paths);
            buffer = new SplineDefinition(name, Spline.Type.Bezier);
            if (relative) buffer.position = paths.Last().GetLastPoint().position;
            Vector2[] vectors = ParseVector2(coords);
            foreach (Vector3 vector in vectors)
            {
                if (relative) buffer.position += vector;
                else buffer.position = vector;
                buffer.CreateLinear();
            }
        }

        private void PathClose()
        {
            buffer.CreateClosingPoint();
            buffer.closed = true;
        }

        private void PathLineTo(string coords, bool relative)
        {
            Vector2[] vectors = ParseVector2(coords);
            foreach (Vector3 vector in vectors)
            {
                if (relative) buffer.position += vector;
                else buffer.position = vector;
                buffer.CreateLinear();
            }
        }

        private void PathHorizontalLineTo(string coords, bool relative)
        {
            float[] floats = ParseFloat(coords);
            foreach (float f in floats)
            {
                if (relative) buffer.position.x += f;
                else buffer.position.x = f;
                buffer.CreateLinear();
            }
        }

        private void PathVerticalLineTo(string coords, bool relative)
        {
            float[] floats = ParseFloat(coords);
            foreach (float f in floats)
            {
                if (relative) buffer.position.y -= f;
                else buffer.position.y = -f;
                buffer.CreateLinear();
            }
        }

        private void PathCurveTo(string coords, PathSegment.Type type, bool relative)
        {
            PathSegment[] segment = ParsePathSegment(coords, type);
            for (int i = 0; i < segment.Length; i++)
            {
                SplinePoint p = buffer.GetLastPoint();
                p.type = SplinePoint.Type.Broken;

                //Get the control points
                Vector3 startPoint = p.position;
                Vector3 endPoint = segment[i].endPoint;
                Vector3 startTangent = segment[i].startTangent;
                Vector3 endTangent = segment[i].endTangent;

                switch (type)
                {
                    case PathSegment.Type.CubicShort: startTangent = startPoint - p.tangent; break;
                    case PathSegment.Type.Quadratic:
                        buffer.tangent = segment[i].startTangent;
                        startTangent = startPoint + 2f / 3f * (buffer.tangent - startPoint);
                        endTangent = endPoint + 2f / 3f * (buffer.tangent - endPoint);
                        break;
                    case PathSegment.Type.QuadraticShort:
                        Vector3 reflection = startPoint + (startPoint - buffer.tangent);
                        startTangent = startPoint + 2f / 3f * (reflection - startPoint);
                        endTangent = endPoint + 2f / 3f * (reflection - endPoint);
                        break;
                }

                if (type == PathSegment.Type.CubicShort || type == PathSegment.Type.QuadraticShort) p.type = SplinePoint.Type.SmoothMirrored; //Smooth the previous point
                else
                {
                    if (relative) p.SetTangent2Position(startPoint + startTangent);
                    else p.SetTangent2Position(startTangent);
                }
                buffer.SetLastPoint(p);
                if (relative)
                {
                    buffer.position += endPoint;
                    buffer.tangent = startPoint + endTangent;
                }
                else
                {
                    buffer.position = endPoint;
                    buffer.tangent = endTangent;
                }
                buffer.CreateBroken();
            }
        }

        private void PathArcTo(string coords, bool relative)
        {
            // Get Arc Arguments
            float[] floats = ParseFloat(coords);
            float rx = floats[0];
            float ry = floats[1];
            float rotation = floats[2] * Mathf.Deg2Rad;
            bool largeArc = floats[3] > 0.5f;
            bool sweep = floats[4] > 0.5f;
            float x = floats[5];
            float y = floats[6];

            // Set the last buffer point to broken
            SplinePoint p = buffer.GetLastPoint();
            p.type = SplinePoint.Type.Broken;

            // Get the start and end point. Note: Flip Y, as the Ellipse Parameters calculation assumes positive Y values
            Vector3 sp = p.position;
            sp.y *= -1;
            Vector3 ep = new Vector3(x, y, 0);
            if (relative) ep += sp;

            Vector2 c;
            float theta1;
            float sweepTheta;
            float adjustedRx;
            float adjustedRy;

            // Get the Ellipse Parameters
            CalculateEllipseParams(sp, ep, rotation, rx, ry, largeArc, sweep,
                out c, out theta1, out sweepTheta, out adjustedRx, out adjustedRy);

            // Flip the center Y back
            c.y *= -1;

            // Generate the ellipse primitive. Note: Rotated by -90 degrees and flipped, so first point starts at +X and goes clockwise
            Ellipse ellipse = new Ellipse();
            ellipse.offset = c;
            ellipse.rotation = new Vector3(0, 0, -90 - rotation * Mathf.Rad2Deg);
            ellipse.xRadius = adjustedRx;
            ellipse.yRadius = adjustedRy;
            var ellipseSpline = ellipse.CreateSpline();
            var esp = ellipseSpline.points;

            
            var tmpp = esp[1];
            esp[1] = esp[3];
            esp[3] = tmpp;
            for (int i = 0; i < esp.Length; i++)
            {
                FlipTangents(ref esp[i]);
            }

            // Find the percentages to sample the ellipse at
            var startP = theta1 / (Mathf.PI * 2);
            startP = ModP(startP, 1f);
            var sweepP = sweepTheta / (Mathf.PI * 2);
            var endP = startP + sweepP;

            var percentages = GetArcSegmentPercentages(startP, endP);

            // Sample the ellipse and add points to buffer
            for (int i = 1; i < percentages.Length; ++i)
            {
                double pp = percentages[i - 1];
                double pc = percentages[i];
                double pr = pc - pp;
                int sgn = Math.Sign(pr); // This sign indicates a reversed range if < 0; The sampled tangents need to be flipped if this is the case
                pr *= sgn;
                if (pr < 0.0001d) continue; // Sample error margin
                double d = 0.75d / pr;
                pc = ModP(pc, 1d);
                pp = ModP(pp, 1d);

                // New point in buffer
                Vector3 posc = Vector3.zero, tanc = Vector3.zero, tanp = Vector3.zero;
                ellipseSpline.EvaluatePosition(pc, ref posc);
                ellipseSpline.EvaluateTangent(pc, ref tanc);
                tanc *= sgn;
                tanc /= (float)d;
                buffer.position = posc;
                buffer.tangent = posc - tanc; 

                // Modify tangent2 of last point in buffer
                ellipseSpline.EvaluateTangent(pp, ref tanp);
                tanp *= sgn;
                tanp /= (float)d;
                p = buffer.GetLastPoint();
                p.type = SplinePoint.Type.Broken;
                p.SetTangent2Position(p.position + tanp);
                buffer.SetLastPoint(p);

                buffer.CreateBroken();
            }
        }

        private void FlipTangents(ref SplinePoint point)
        {
            var tmpt = point.tangent;
            point.tangent = point.tangent2;
            point.tangent2 = tmpt;
        }

        private void CalculateEllipseParams(Vector2 p0, Vector2 p1, float phi, float rx, float ry, bool fa, bool fs, out Vector2 c, out float theta1, out float sweepTheta, out float adjustedRx, out float adjustedRy)
        {
            // From https://observablehq.com/@toja/ellipse-and-elliptical-arc-conversion
            float sinPhi = Mathf.Sin(phi);
            float cosPhi = Mathf.Cos(phi);

            float x = cosPhi * (p0.x - p1.x) / 2 + sinPhi * (p0.y - p1.y) / 2;
            float y = -sinPhi * (p0.x - p1.x) / 2 + cosPhi * (p0.y - p1.y) / 2;

            float px = x * x, py = y * y, prx = rx * rx, pry = ry * ry;

            rx = Mathf.Abs(rx);
            ry = Mathf.Abs(ry);
            float l = px / prx + py / pry;
            if (l > 1)
            {
                float sqrtl = Mathf.Sqrt(l);
                rx = sqrtl * rx;
                ry = sqrtl * ry;
                prx = rx * rx;
                pry = ry * ry;
            }
            adjustedRx = rx;
            adjustedRy = ry;

            float sign = fa == fs ? -1 : 1;
            float m = Mathf.Sqrt((prx * pry - prx * py - pry * px) / (prx * py + pry * px)) * sign;

            float ccx = m * (rx * y) / ry;
            float ccy = m * (-ry * x) / rx;

            c = new Vector2(
                cosPhi * ccx - sinPhi * ccy + (p0.x + p1.x) / 2,
                sinPhi * ccx + cosPhi * ccy + (p0.y + p1.y) / 2
            );

            theta1 = VectorAngle(new Vector2(1, 0), new Vector2((x - ccx) / rx, (y - ccy) / ry));
            sweepTheta = VectorAngle(new Vector2((x - ccx) / rx, (y - ccy) / ry), new Vector2((-x - ccx) / rx, (-y - ccy) / ry));
            sweepTheta *= Mathf.Rad2Deg;
            sweepTheta %= 360;

            if (!fs && sweepTheta > 0) sweepTheta -= 360;
            if (fs && sweepTheta < 0) sweepTheta += 360;
            sweepTheta *= Mathf.Deg2Rad;
        }

        private double[] GetArcSegmentPercentages(double start, double end)
        {
            List<double> percentages = new List<double>();
            bool swap = start > end;
            if (swap) { double tmp = start; start = end; end = tmp; }

            percentages.Add(start);
            double rsM = Math.Ceiling(start * 4d) * 0.25d;
            if (rsM > end)
            {
                percentages.Add(end);
                return ReturnPercentage(swap, percentages);
            }
            else if (start < rsM)
            {
                percentages.Add(rsM);
            }

            double rem = rsM + 0.25d;
            for (; rem <= end; rem += 0.25d)
            {
                percentages.Add(rem);
            }
            rem -= 0.25d;
            if (rem < end)
            {
                percentages.Add(end);
            }

            return ReturnPercentage(swap, percentages);
        }

        private double[] ReturnPercentage(bool swap, List<double> percentages)
        {
            var ret = new double[percentages.Count];
            for (int i = 0; i < percentages.Count; ++i)
            {
                var r = swap ? percentages.Count - 1 - i : i;
                var p = percentages[r];
                ret[i] = p;
            }
            return ret;
        }

        private float VectorAngle(Vector2 u, Vector2 v)
        {
            float sign = u.x * v.y - u.y * v.x < 0 ? -1 : 1;
            float ua = Mathf.Sqrt(u.x * u.x + u.y * u.y);
            float va = Mathf.Sqrt(v.x * v.x + v.y * v.y);
            float dot = u.x * v.x + u.y * v.y;
            return sign * Mathf.Acos(dot / (ua * va));
        }

        private float ModP(float f, float div)
        {
            return ((f % div) + div) % div;
        }

        private double ModP(double d, double div)
        {
            return ((d % div) + div) % div;
        }

        private void WriteBufferTo(List<SplineDefinition> list)
        {
            buffer.Transform(transformBuffer);
            list.Add(buffer);
            buffer = null;
        }

        private PathSegment[] ParsePathSegment(string coord, PathSegment.Type type)
        {
            List<float> list = ParseFloatArray(coord.Substring(1));
            int count = 0;
            switch (type)
            {
                case PathSegment.Type.Cubic: count = list.Count / 6; break;
                case PathSegment.Type.Quadratic: count = list.Count / 4; break;
                case PathSegment.Type.CubicShort: count = list.Count / 4; break;
                case PathSegment.Type.QuadraticShort: count = list.Count / 2; break;
            }

            if (count == 0)
            {
                Debug.Log("Error in " + coord + " " + type);
                return new PathSegment[] { new PathSegment() };
            }
            PathSegment[] data = new PathSegment[count];
            for (int i = 0; i < count; i++)
            {
                switch (type)
                {
                    case PathSegment.Type.Cubic: data[i] = new PathSegment(new Vector2(list[0 + 6 * i], -list[1 + 6 * i]), new Vector2(list[2 + 6 * i], -list[3 + 6 * i]), new Vector2(list[4 + 6 * i], -list[5 + 6 * i])); break;
                    case PathSegment.Type.Quadratic: data[i] = new PathSegment(new Vector2(list[0 + 4 * i], -list[1 + 4 * i]), Vector2.zero, new Vector2(list[2 + 4 * i], -list[3 + 4 * i])); break;
                    case PathSegment.Type.CubicShort: data[i] = new PathSegment(Vector2.zero, new Vector2(list[0 + 4 * i], -list[1 + 4 * i]), new Vector2(list[2 + 4 * i], -list[3 + 4 * i])); break;
                    case PathSegment.Type.QuadraticShort: data[i] = new PathSegment(Vector2.zero, Vector2.zero, new Vector2(list[0 + 4 * i], -list[1 + 4 * i])); break;
                }
            }
            return data;
        }

        private string EncodePath(SplineDefinition definition, Axis ax)
        {
            string text = "M";
            for (int i = 0; i < definition.pointCount; i++)
            {
                SplinePoint p = definition.points[i];
                Vector3 tangent = MapPoint(p.tangent, ax);
                Vector3 position = MapPoint(p.position, ax);
                if (i == 0) text += position.x + "," + position.y;
                else
                {
                    SplinePoint lp = definition.points[i - 1];
                    Vector3 tangent2 = MapPoint(lp.tangent2, ax);
                    text += "C" + tangent2.x + "," + tangent2.y + "," + tangent.x + "," + tangent.y + "," + position.x + "," + position.y;
                }
            }
            if (definition.closed) text += "z";
            return text;
        }

        private string EncodePolygon(SplineDefinition definition, Axis ax)
        {
            string text = "";
            for (int i = 0; i < definition.pointCount; i++)
            {
                Vector3 position = MapPoint(definition.points[i].position, ax);
                if (text != "") text += ",";
                text += position.x + "," + position.y;
            }
            return text;
        }

        private string GetAttributeContent(XmlNode node, string attributeName)
        {
            for (int j = 0; j < node.Attributes.Count; j++)
            {
                if (node.Attributes[j].Name == attributeName) return node.Attributes[j].InnerText;
            }
            return "ERROR";
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/SVG.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/ObjectSequence.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 810a671b1d2fb20408afff3c04f7be70
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines
{
    [System.Serializable]
    public class ObjectSequence<T>
    {
        public T startObject;
        public T endObject;
        public T[] objects;
        public enum Iteration { Ordered, Random }
        public Iteration iteration = Iteration.Ordered;
        public int randomSeed
        {
            get { return _randomSeed; }
            set
            {
                if (value != _randomSeed)
                {
                    _randomSeed = value;
                    randomizer = new System.Random(_randomSeed);
                }
            }
        }
        [SerializeField]
        [HideInInspector]
        private int _randomSeed = 1;
        [SerializeField]
        [HideInInspector]
        private int index = 0;
        [SerializeField]
        [HideInInspector]
        System.Random randomizer;
        
        public ObjectSequence(){
            randomizer = new System.Random(_randomSeed);
        }

        public T GetFirst()
        {
            if (startObject != null) return startObject;
            else return Next();
        }

        public T GetLast()
        {
            if (endObject != null) return endObject;
            else return Next();
        }

        public T Next()
        {
            if (iteration == Iteration.Ordered)
            {
                if (index >= objects.Length) index = 0;
                return objects[index++];
            } else
            {
                int randomIndex = randomizer.Next(objects.Length-1);
                return objects[randomIndex];
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/ObjectSequence.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Capsule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e39006c982d03b3409b070eab24d0843
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives
{
    public class Capsule : SplinePrimitive
    {
        public float radius = 1f;
        public float height = 2f;

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Bezier;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = true;
            CreatePoints(6, SplinePoint.Type.SmoothMirrored);
            points[0].position = Vector3.right / 2f * radius + Vector3.up * height * 0.5f;
            points[0].SetTangentPosition(points[0].position + Vector3.down * 2 * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
            points[1].position = Vector3.up / 2f * radius + Vector3.up * height * 0.5f;
            points[1].SetTangentPosition(points[1].position + Vector3.right * 2 * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
            points[2].position = Vector3.left / 2f * radius + Vector3.up * height * 0.5f;
            points[2].SetTangentPosition(points[2].position + Vector3.up * 2 * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
            points[3].position = Vector3.left / 2f * radius + Vector3.down * height * 0.5f;
            points[3].SetTangentPosition(points[3].position + Vector3.up * 2 * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
            points[4].position = Vector3.down / 2f * radius + Vector3.down * height * 0.5f;
            points[4].SetTangentPosition(points[4].position + Vector3.left * 2 * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
            points[5].position = Vector3.right / 2f * radius + Vector3.down * height * 0.5f;
            points[5].SetTangentPosition(points[5].position + Vector3.down * 2 * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Capsule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Ellipse.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4ff5eb5b93412154ea3ec2e48ca9ca4d
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine; 

namespace Dreamteck.Splines.Primitives
{
    public class Ellipse : SplinePrimitive
    {
        public float xRadius = 1f;
        public float yRadius = 1f;

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Bezier;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = true;
            CreatePoints(4, SplinePoint.Type.SmoothMirrored);
            points[0].position = Vector3.up * yRadius;
            points[0].SetTangentPosition(points[0].position + Vector3.right * 2 * (Mathf.Sqrt(2f) - 1f) / 1.5f * xRadius);
            points[1].position = Vector3.left * xRadius;
            points[1].SetTangentPosition(points[1].position + Vector3.up * 2 * (Mathf.Sqrt(2f) - 1f) / 1.5f * yRadius);
            points[2].position = Vector3.down * yRadius;
            points[2].SetTangentPosition(points[2].position + Vector3.left * 2 * (Mathf.Sqrt(2f) - 1f) / 1.5f * xRadius);
            points[3].position = Vector3.right * xRadius;
            points[3].SetTangentPosition(points[3].position + Vector3.down * 2 * (Mathf.Sqrt(2f) - 1f) / 1.5f * yRadius);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Ellipse.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Line.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8c7d365eea2f73048be2306c775e3df4
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives
{
    public class Line : SplinePrimitive
    {
        public bool mirror = true;
        public float length = 1f;
        public int segments = 1;

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Linear;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = false;
            CreatePoints(segments + 1, SplinePoint.Type.SmoothMirrored);
            Vector3 origin = Vector3.zero;
            if (mirror) origin = -Vector3.up * length * 0.5f;
            for (int i = 0; i < points.Length; i++)
            {
                points[i].position = origin + Vector3.up * length * ((float)i / (points.Length - 1));
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Line.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Ngon.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 79792b94d3f3fc2489022f36d48a41d4
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives
{
    public class Ngon : SplinePrimitive
    {
        public float radius = 1f;
        public int sides = 3;

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Linear;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = true;
            CreatePoints(sides, SplinePoint.Type.SmoothMirrored);
            for (int i = 0; i < sides; i++)
            {
                float percent = (float)i / sides;
                Vector3 pos = Quaternion.AngleAxis(360f * percent, Vector3.forward) * Vector3.up * radius;
                points[i].SetPosition(pos);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Ngon.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Rectangle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e39c41817ed55504cbef2a470c95599d
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives
{
    public class Rectangle : SplinePrimitive
    {
        public Vector2 size = Vector2.one;

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Linear;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = true;
            CreatePoints(4, SplinePoint.Type.SmoothMirrored);
            points[0].position = points[0].tangent = Vector3.up / 2f * size.y + Vector3.left / 2f * size.x;
            points[1].position = points[1].tangent = Vector3.up / 2f * size.y + Vector3.right / 2f * size.x;
            points[2].position = points[2].tangent = Vector3.down / 2f * size.y + Vector3.right / 2f * size.x;
            points[3].position = points[3].tangent = Vector3.down / 2f * size.y + Vector3.left / 2f * size.x;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Rectangle.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/RoundedRectangle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a6ad8207cf520e94aa15dea4fae0027d
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives
{
    public class RoundedRectangle : SplinePrimitive
    {
        public Vector2 size = Vector2.one;
        public float xRadius = 0.25f;
        public float yRadius = 0.25f;

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Bezier;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = true;
            CreatePoints(8, SplinePoint.Type.Broken);
            Vector2 edgeSize = size - new Vector2(xRadius, yRadius) * 2f;
            points[0].SetPosition(Vector3.up / 2f * edgeSize.y + Vector3.left / 2f * size.x);
            points[1].SetPosition(Vector3.up / 2f * size.y + Vector3.left / 2f * edgeSize.x);
            points[2].SetPosition(Vector3.up / 2f * size.y + Vector3.right / 2f * edgeSize.x);
            points[3].SetPosition(Vector3.up / 2f * edgeSize.y + Vector3.right / 2f * size.x);
            points[4].SetPosition(Vector3.down / 2f * edgeSize.y + Vector3.right / 2f * size.x);
            points[5].SetPosition(Vector3.down / 2f * size.y + Vector3.right / 2f * edgeSize.x);
            points[6].SetPosition(Vector3.down / 2f * size.y + Vector3.left / 2f * edgeSize.x);
            points[7].SetPosition(Vector3.down / 2f * edgeSize.y + Vector3.left / 2f * size.x);

            float xRad = 2f * (Mathf.Sqrt(2f) - 1f) / 3f * xRadius * 2f;
            float yRad = 2f * (Mathf.Sqrt(2f) - 1f) / 3f * yRadius * 2f;
            points[0].SetTangent2Position(points[0].position + Vector3.up * yRad);
            points[1].SetTangentPosition(points[1].position + Vector3.left * xRad);
            points[2].SetTangent2Position(points[2].position + Vector3.right * xRad);
            points[3].SetTangentPosition(points[3].position + Vector3.up * yRad);
            points[4].SetTangent2Position(points[4].position + Vector3.down * yRad);
            points[5].SetTangentPosition(points[5].position + Vector3.right * xRad);
            points[6].SetTangent2Position(points[6].position + Vector3.left * xRad);
            points[7].SetTangentPosition(points[7].position + Vector3.down * yRad);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/RoundedRectangle.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Spiral.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d4c765265077e6a4d9bc4e5d2cc75f3c
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives
{
    public class Spiral : SplinePrimitive
    {
        public float startRadius = 1f;
        public float endRadius = 1f;
        public float stretch = 1f;
        public int iterations = 3;
        public bool clockwise = true;
        public AnimationCurve curve = new AnimationCurve();

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Bezier;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = false;
            CreatePoints(iterations * 4 + 1, SplinePoint.Type.SmoothMirrored);
            float radiusDelta = Mathf.Abs(endRadius - startRadius);
            float radiusDeltaPercent = radiusDelta / Mathf.Max(Mathf.Abs(endRadius), Mathf.Abs(startRadius));
            float multiplier = 1f;
            if (endRadius > startRadius) multiplier = -1;
            float angle = 0f;
            float str = 0f;
            float angleDirection = clockwise ? 1f : -1f;
            for (int i = 0; i <= iterations * 4; i++)
            {
                float percent = curve.Evaluate((float)i / (iterations * 4));
                float radius = Mathf.Lerp(startRadius, endRadius, percent);
                Quaternion rot = Quaternion.AngleAxis(angle, Vector3.up);
                points[i].position = rot * Vector3.forward / 2f * radius + Vector3.up * str;
                Quaternion tangentRot = Quaternion.identity;
                if (multiplier > 0) tangentRot = Quaternion.AngleAxis(Mathf.Lerp(0f, 90f * 0.16f * angleDirection, radiusDeltaPercent * percent), Vector3.up);
                else tangentRot = Quaternion.AngleAxis(Mathf.Lerp(0f, -90f * 0.16f * angleDirection, (1f - percent) * radiusDeltaPercent), Vector3.up);
                if (clockwise) points[i].tangent = points[i].position - (tangentRot * rot * Vector3.right * radius + Vector3.up * stretch / 4f) * 2 * (Mathf.Sqrt(2f) - 1f) / 3f;
                else points[i].tangent = points[i].position + (tangentRot * rot * Vector3.right * radius - Vector3.up * stretch / 4f) * 2 * (Mathf.Sqrt(2f) - 1f) / 3f;
                points[i].tangent2 = points[i].position - (points[i].tangent - points[i].position);
                str += stretch / 4f;
                angle += 90f * angleDirection;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Spiral.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/SplinePrimitive.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: acb225539fdaf0d479f2ca1a7694afcc
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives {
    public class SplinePrimitive
    {
        protected bool closed = false;
        protected SplinePoint[] points = new SplinePoint[0];

        public Vector3 offset = Vector3.zero;
        public Vector3 rotation = Vector3.zero;
        public bool is2D = false;

        public virtual void Calculate()
        {
            Generate();
            ApplyOffset();
        }

        protected virtual void Generate()
        {
        
        }

        public Spline CreateSpline()
        {
            Generate();
            ApplyOffset();
            Spline spline = new Spline(GetSplineType());
            spline.points = points;
            if (closed) spline.Close();
            return spline;
        }

        public void UpdateSpline(Spline spline)
        {
            Generate();
            ApplyOffset();
            spline.type = GetSplineType();
            spline.points = points;
            if (closed) spline.Close();
            else if (spline.isClosed) spline.Break();
        }

        public SplineComputer CreateSplineComputer(string name, Vector3 position, Quaternion rotation)
        {
            Generate();
            ApplyOffset();
            GameObject go = new GameObject(name);
            SplineComputer comp = go.AddComponent<SplineComputer>();
            comp.SetPoints(points, SplineComputer.Space.Local);
            if (closed) comp.Close();
            comp.transform.position = position;
            comp.transform.rotation = rotation;
            return comp;
        }

        public void UpdateSplineComputer(SplineComputer comp)
        {
            Generate();
            ApplyOffset();
            comp.type = GetSplineType();
            comp.SetPoints(points, SplineComputer.Space.Local);
            if (closed) comp.Close();
            else if (comp.isClosed) comp.Break();
        }

        public SplinePoint[] GetPoints()
        {
            return points;
        }

        public virtual Spline.Type GetSplineType()
        {
            return Spline.Type.CatmullRom;
        }

        public bool GetIsClosed()
        {
            return closed;
        }

        void ApplyOffset()
        {
            Quaternion freeRot = Quaternion.Euler(rotation);
            if (is2D) freeRot = Quaternion.AngleAxis(-rotation.z, Vector3.forward) * Quaternion.AngleAxis(90f, Vector3.right);
            for (int i = 0; i < points.Length; i++)
            {
                points[i].position = freeRot * points[i].position;
                points[i].tangent = freeRot *  points[i].tangent;
                points[i].tangent2 = freeRot * points[i].tangent2;
                points[i].normal = freeRot * points[i].normal;
            }
            for (int i = 0; i < points.Length; i++) points[i].SetPosition(points[i].position + offset);
        }

        protected void CreatePoints(int count, SplinePoint.Type type)
        {
            if (points.Length != count) points = new SplinePoint[count];
            for (int i = 0; i < points.Length; i++)
            {
                points[i].type = type;
                points[i].normal = Vector3.up;
                points[i].color = Color.white;
                points[i].size = 1f;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/SplinePrimitive.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Star.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 30808d4ccaa42844698780f3f2af4308
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives
{
    public class Star : SplinePrimitive
    {
        public float radius = 1f;
        public float depth = 0.5f;
        public int sides = 5;

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Linear;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = true;
            CreatePoints(sides * 2, SplinePoint.Type.SmoothMirrored);
            float innerRadius = radius * depth;
            for (int i = 0; i < sides * 2; i++)
            {
                float percent = (float)i / (float)(sides * 2);
                Vector3 pos = Quaternion.AngleAxis(180 + 360f * percent, Vector3.forward) * Vector3.up * ((float)i % 2f == 0 ? radius : innerRadius);
                points[i].SetPosition(pos);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Star.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SampleCollection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2ab72bc0d28ecbe4c8a42a5e1c8e2da5
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;

    [System.Serializable]
    public class SampleCollection
    {
        [HideInInspector]
        [UnityEngine.Serialization.FormerlySerializedAs("samples")]
        public SplineSample[] samples = new SplineSample[0];
        private static bool __useModifier = false;
        private static ISampleModifier __modifier = null;

        public int length
        {
            get { return samples.Length; }
        }
        public int[] optimizedIndices = new int[0];
        bool hasSamples
        {
            get { return samples.Length > 0; }
        }
        public SplineComputer.SampleMode sampleMode = SplineComputer.SampleMode.Default;
        private SplineSample _workSample = new SplineSample();

        public SampleCollection()
        {
        }

        public SampleCollection(SampleCollection input)
        {
            samples = input.samples;
            optimizedIndices = input.optimizedIndices;
            sampleMode = input.sampleMode;
        }

        public int GetClippedSampleCount(double clipFrom, double clipTo, out int startIndex, out int endIndex)
        {
            startIndex = endIndex = 0;
            if (sampleMode == SplineComputer.SampleMode.Default)
            {
                startIndex = DMath.FloorInt((samples.Length - 1) * clipFrom);
                endIndex = DMath.CeilInt((samples.Length - 1) * clipTo);
            }
            else
            {
                double clipFromLerp = 0.0, clipToLerp = 0.0;
                GetSamplingValues(clipFrom, out startIndex, out clipFromLerp);
                GetSamplingValues(clipTo, out endIndex, out clipToLerp);
                if (clipToLerp > 0.0 && endIndex < samples.Length - 1) endIndex++;
            }

            if (clipTo < clipFrom) //Handle looping segments
            {
                int toSamples = endIndex + 1;
                int fromSamples = samples.Length - startIndex;
                return toSamples + fromSamples;
            }
            return endIndex - startIndex + 1;
        }

        public void GetSamplingValues(double percent, out int sampleIndex, out double lerp)
        {
            lerp = 0.0;
            if (sampleMode == SplineComputer.SampleMode.Optimized)
            {
                double indexValue = percent * (optimizedIndices.Length - 1);
                int index = DMath.FloorInt(indexValue);
                sampleIndex = optimizedIndices[index];
                double lerpPercent = 0.0;
                if (index < optimizedIndices.Length - 1)
                {
                    //Percent 0-1 between the sampleIndex and the next sampleIndex
                    double indexLerp = indexValue - index;
                    double sampleIndexPercent = (double)index / (optimizedIndices.Length - 1);
                    double nextSampleIndexPercent = (double)(index + 1) / (optimizedIndices.Length - 1);
                    //Percent 0-1 of the sample between the sampleIndices' percents
                    lerpPercent = DMath.Lerp(sampleIndexPercent, nextSampleIndexPercent, indexLerp);
                }
                if (sampleIndex < samples.Length - 1)
                {
                    lerp = DMath.InverseLerp(samples[sampleIndex].percent, samples[sampleIndex + 1].percent, lerpPercent);
                }
                return;
            }

            sampleIndex = DMath.FloorInt(percent * (samples.Length - 1));
            lerp = (samples.Length - 1) * percent - sampleIndex;
        }

        /// <summary>
        /// Same as Spline.EvaluatePosition but the result is transformed by the computer's transform
        /// </summary>
        /// <param name="percent">Evaluation percent</param>
        /// <param name="mode">Mode to use the method in. Cached uses the cached samples while Calculate is more accurate but heavier</param>
        /// <returns></returns>
        public Vector3 EvaluatePosition(double percent)
        {
            if (!hasSamples) return Vector3.zero;
            int index;
            double lerp;
            GetSamplingValues(percent, out index, out lerp);
            if (lerp > 0.0)
            {
                return Vector3.Lerp(samples[index].position, samples[index + 1].position, (float)lerp);
            }
            return samples[index].position;
        }

        /// <summary>
        /// Same as Spline.Evaluate but the result is transformed by the computer's transform
        /// </summary>
        /// <param name="percent">Evaluation percent</param>
        /// <param name="mode">Mode to use the method in. Cached uses the cached samples while Calculate is more accurate but heavier</param>
        /// <returns></returns>
        public SplineSample Evaluate(double percent)
        {
            SplineSample result = new SplineSample();
            Evaluate(percent, ref result);
            return result;
        }

        /// <summary>
        /// Evaluates the sample collection and transforms the result by the <see cref="localToWorldMatrix"/>
        /// </summary>
        /// <param name="result"></param>
        /// <param name="percent"></param>
        public void Evaluate(double percent, ref SplineSample result)
        {
            if (!hasSamples)
            {
                result = new SplineSample();
                return;
            }
            int index;
            double lerp;
            GetSamplingValues(percent, out index, out lerp);
            if (lerp > 0.0)
            {
                SplineSample.Lerp(ref samples[index], ref samples[index + 1], lerp, ref result);
            }
            else
            {
                result.FastCopy(ref samples[index]);
            }
        }

        /// <summary>
        /// Evaluates the sample collection and transforms the results by the <see cref="localToWorldMatrix"/>
        /// </summary>
        /// <param name="from">Start position [0-1]</param>
        /// <param name="to">Target position [from-1]</param>
        /// <returns></returns>
        public void Evaluate(ref SplineSample[] results, double from = 0.0, double to = 1.0)
        {
            if (!hasSamples)
            {
                results = new SplineSample[0];
                return;
            }
            Spline.FormatFromTo(ref from, ref to);
            int fromIndex, toIndex;
            double lerp;
            GetSamplingValues(from, out fromIndex, out lerp);
            GetSamplingValues(to, out toIndex, out lerp);
            if (lerp > 0.0 && toIndex < samples.Length - 1)
            {
                toIndex++;
            }
            int clippedIterations = toIndex - fromIndex + 1;
            if (results == null)
            {
                results = new SplineSample[clippedIterations];
            }
            else if (results.Length != clippedIterations)
            {
                results = new SplineSample[clippedIterations];
            }

            results[0] = Evaluate(from);
            results[results.Length - 1] = Evaluate(to);
            for (int i = 1; i < results.Length - 1; i++)
            {
                results[i].FastCopy(ref samples[i + fromIndex]);
            }
        }

        /// <summary>
        /// Same as Spline.EvaluatePositions but the results are transformed by the computer's transform
        /// </summary>
        /// <param name="from">Start position [0-1]</param>
        /// <param name="to">Target position [from-1]</param>
        /// <returns></returns>
        public void EvaluatePositions(ref Vector3[] positions, double from = 0.0, double to = 1.0)
        {
            if (!hasSamples)
            {
                positions = new Vector3[0];
                return;
            }

            Spline.FormatFromTo(ref from, ref to);
            int fromIndex, toIndex;
            double lerp;
            GetSamplingValues(from, out fromIndex, out lerp);
            GetSamplingValues(to, out toIndex, out lerp);
            if (lerp > 0.0 && toIndex < samples.Length - 1)
            {
                toIndex++;
            }
            int clippedIterations = toIndex - fromIndex + 1;

            if (positions == null)
            {
                positions = new Vector3[clippedIterations];
            }
            else if (positions.Length != clippedIterations)
            {
                positions = new Vector3[clippedIterations];
            }

            positions[0] = EvaluatePosition(from);
            positions[positions.Length - 1] = EvaluatePosition(to);
            for (int i = 1; i < positions.Length - 1; i++)
            {
                positions[i] = samples[i + fromIndex].position;
            }
        }

        /// <summary>
        /// Returns the percent from the spline at a given distance from the start point
        /// </summary>
        /// <param name="start">The start point</param>
        /// <param name="distance">The distance to travel</param>
        /// <param name="direction">The direction towards which to move</param>
        /// <returns></returns>
        public double Travel(double start, float distance, Spline.Direction direction, out float moved, double clipFrom = 0.0, double clipTo = 1.0)
        {
            moved = 0f;
            if (!hasSamples) return 0.0;
            if (direction == Spline.Direction.Forward && start >= 1.0) return clipTo;
            else if (direction == Spline.Direction.Backward && start <= 0.0) return clipFrom;

            double lastPercent = start;
            if (distance == 0f) return lastPercent;
            Vector3 lastPos = EvaluatePosition(start);
            int sampleIndex;
            double lerp;
            GetSamplingValues(lastPercent, out sampleIndex, out lerp);
            if (direction == Spline.Direction.Forward && lerp > 0.0) sampleIndex++;
            float lastDistance = 0f;
            int minIndex = 0;
            int maxIndex = samples.Length - 1;

            bool samplesAreLooped = clipTo < clipFrom;

            if (samplesAreLooped)
            {
                GetSamplingValues(clipFrom, out minIndex, out lerp);
                GetSamplingValues(clipTo, out maxIndex, out lerp);
                if (lerp > 0.0) maxIndex++;
            }

            while (moved < distance)
            {
                Vector3 transformedPos = samples[sampleIndex].position;
                lastDistance = Vector3.Distance(transformedPos, lastPos);
                moved += lastDistance;
                if (moved >= distance) break;
                lastPos = transformedPos;
                lastPercent = samples[sampleIndex].percent;
                if (direction == Spline.Direction.Forward)
                {
                    if (sampleIndex == samples.Length - 1)
                    {
                        if (samplesAreLooped)
                        {
                            lastPos = samples[0].position;
                            lastPercent = samples[0].percent;
                            sampleIndex = 1;
                        }
                        else break;
                    }
                    if (samplesAreLooped && sampleIndex == maxIndex) break;
                    sampleIndex++;
                }
                else
                {
                    if (sampleIndex == 0)
                    {
                        if (samplesAreLooped)
                        {
                            lastPos = samples[samples.Length - 1].position;
                            lastPercent = samples[samples.Length - 1].percent;
                            sampleIndex = samples.Length - 2;
                        }
                        else break;
                    }
                    if (samplesAreLooped && sampleIndex == minIndex) break;
                    sampleIndex--;
                }
            }
            float moveExcess = 0f;
            if (moved > distance)
            {
                moveExcess = moved - distance;
            }


            double lerpPercent = 0.0;
            if(lastDistance > 0.0)
            {
                lerpPercent = moveExcess / lastDistance;
            }
            double p = DMath.Lerp(lastPercent, samples[sampleIndex].percent, 1f - lerpPercent);
            moved -= moveExcess;
            return p;
        }

        /// <summary>
        /// Returns the percent from the spline at a given distance from the start point while applying a local <paramref name="offset"/> to each sample
        /// The offset is multiplied by the sample sizes
        /// </summary>
        /// <param name="start">The start point</param>
        /// /// <param name="distance">The distance to travel</param>
        /// <param name="direction">The direction towards which to move</param>
        /// <returns></returns>
        public double TravelWithOffset(double start, float distance, Spline.Direction direction, Vector3 offset, out float moved, double clipFrom = 0.0, double clipTo = 1.0)
        {
            moved = 0f;
            if (!hasSamples) return 0.0;
            if (direction == Spline.Direction.Forward && start >= 1.0) return clipTo;
            else if (direction == Spline.Direction.Backward && start <= 0.0) return clipFrom;

            double lastPercent = start;
            if (distance == 0f) return lastPercent;

            Evaluate(start, ref _workSample);
            Vector3 lastPos = _workSample.position + _workSample.up * (offset.y * _workSample.size) + _workSample.right * (offset.x * _workSample.size) + _workSample.forward * (offset.z * _workSample.size);

            int sampleIndex;
            double lerp;
            GetSamplingValues(lastPercent, out sampleIndex, out lerp);
            if (direction == Spline.Direction.Forward && lerp > 0.0) sampleIndex++;
            float lastDistance = 0f;
            int minIndex = 0;
            int maxIndex = length - 1;

            bool samplesAreLooped = clipTo < clipFrom;

            if (samplesAreLooped)
            {
                GetSamplingValues(clipFrom, out minIndex, out lerp);
                GetSamplingValues(clipTo, out maxIndex, out lerp);
                if (lerp > 0.0) maxIndex++;
            }

            while (moved < distance)
            {
                Vector3 newPos = samples[sampleIndex].position +
                    samples[sampleIndex].up * (offset.y * samples[sampleIndex].size) +
                    samples[sampleIndex].right * (offset.x * samples[sampleIndex].size) +
                    samples[sampleIndex].forward * (offset.z * samples[sampleIndex].size);
                lastDistance = Vector3.Distance(newPos, lastPos);
                moved += lastDistance;
                if (moved >= distance)
                {
                    break;
                }
                lastPos = newPos;
                lastPercent = samples[sampleIndex].percent;
                if (direction == Spline.Direction.Forward)
                {
                    if (sampleIndex == length - 1)
                    {
                        if (samplesAreLooped)
                        {
                            lastPos = samples[0].position +
                                samples[0].up * (offset.y * samples[0].size) +
                                samples[0].right * (offset.x * samples[0].size) +
                                samples[0].forward * (offset.z * samples[0].size);
                            lastPercent = samples[0].percent;
                            sampleIndex = 1;
                        }
                        else break;
                    }
                    if (samplesAreLooped && sampleIndex == maxIndex) break;
                    sampleIndex++;
                }
                else
                {
                    if (sampleIndex == 0)
                    {
                        if (samplesAreLooped)
                        {
                            int lastIndex = samples.Length - 1;
                            lastPos = samples[lastIndex].position +
                                samples[lastIndex].up * (offset.y * samples[lastIndex].size) +
                                samples[lastIndex].right * (offset.x * samples[lastIndex].size) +
                                samples[lastIndex].forward * (offset.z * samples[lastIndex].size);
                            lastPercent = samples[lastIndex].percent;
                            sampleIndex = samples.Length - 2;
                        }
                        else break;
                    }
                    if (samplesAreLooped && sampleIndex == minIndex) break;
                    sampleIndex--;
                }
            }
            float moveExcess = 0f;
            if (moved > distance)
            {
                moveExcess = moved - distance;
            }

            double p = DMath.Lerp(lastPercent, samples[sampleIndex].percent, 1f - moveExcess / lastDistance);
            moved -= moveExcess;
            return p;
        }

        public double Travel(double start, float distance, Spline.Direction direction = Spline.Direction.Forward)
        {
            float moved;
            return Travel(start, distance, direction, out moved);
        }

        private Vector3 GetModifiedPosition(ref SplineSample sample)
        {
            if (!__useModifier) return sample.position;
            return __modifier.GetModifiedSamplePosition(ref sample);
        }

        /// <summary>
        /// Same as Spline.Project but the point is transformed by the computer's transform.
        /// </summary>
        /// <param name="position">Point in space</param>
        /// <param name="subdivide">Subdivisions default: 4</param>
        /// <param name="from">Sample from [0-1] default: 0f</param>
        /// <param name="to">Sample to [0-1] default: 1f</param>
        /// <param name="mode">Mode to use the method in. Cached uses the cached samples while Calculate is more accurate but heavier</param>
        /// <param name="subdivisions">Subdivisions for the Calculate mode. Don't assign if not using Calculated mode.</param>
        /// <returns></returns>
        public void Project(Vector3 position, int controlPointCount, ref SplineSample result, double from = 0.0, double to = 1.0, ISampleModifier modifier = null)
        {
            if (!hasSamples) return;
            if (samples.Length == 1)
            {
                result.FastCopy(ref samples[0]);
                return;
            }
            __useModifier = modifier != null;
            __modifier = modifier;
            Spline.FormatFromTo(ref from, ref to);
            //First make a very rough sample of the from-to region
            int steps = (controlPointCount - 1) * 4; //Sampling four points per segment is enough to find the closest point range
            int step = samples.Length / steps;
            if (step < 1) step = 1;

            float minDist = (position - GetModifiedPosition(ref samples[0])).sqrMagnitude;
            int fromIndex = 0;
            int toIndex = samples.Length - 1;
            double lerp;
            if (from != 0.0) GetSamplingValues(from, out fromIndex, out lerp);
            if (to != 1.0)
            {
                GetSamplingValues(to, out toIndex, out lerp);
                if (lerp > 0.0 && toIndex < samples.Length - 1) toIndex++;
            }
            int checkFrom = fromIndex;
            int checkTo = toIndex;

            //Find the closest point range which will be checked in detail later
            for (int i = fromIndex; i < toIndex; i += step)
            {
                if (i >= toIndex) i = toIndex-1;
                Vector3 pos1 = GetModifiedPosition(ref samples[i]);
                Vector3 pos2 = GetModifiedPosition(ref samples[Mathf.Min(i + step, toIndex)]);
                Vector3 projected = LinearAlgebraUtility.ProjectOnLine(pos1, pos2, position);
                float dist = (position - projected).sqrMagnitude;
                if (dist < minDist)
                {
                    minDist = dist;
                    checkFrom = Mathf.Max(i - step, 0);
                    checkTo = Mathf.Min(i + step, samples.Length - 1);
                }
                if (i == toIndex) break;
            }
            minDist = (position - samples[checkFrom].position).sqrMagnitude;

            int index = checkFrom;
            //Find the closest result within the range
            for (int i = checkFrom + 1; i <= checkTo; i++)
            {
                float dist = (position - GetModifiedPosition(ref samples[i])).sqrMagnitude;
                if (dist < minDist)
                {
                    minDist = dist;
                    index = i;
                }
            }
            //Project the point on the line between the two closest samples
            int backIndex = index - 1;
            if (backIndex < 0) backIndex = 0;
            int frontIndex = index + 1;
            if (frontIndex > samples.Length - 1) frontIndex = samples.Length - 1;

            Vector3 backPos = GetModifiedPosition(ref samples[backIndex]);
            Vector3 currentPos = GetModifiedPosition(ref samples[index]);
            Vector3 frontPos = GetModifiedPosition(ref samples[frontIndex]);

            Vector3 back = LinearAlgebraUtility.ProjectOnLine(backPos, currentPos, position);
            Vector3 front = LinearAlgebraUtility.ProjectOnLine(currentPos, frontPos, position);
            float backLength = (currentPos - backPos).magnitude;
            float frontLength = (currentPos - frontPos).magnitude;
            float backProjectDist = (back - backPos).magnitude;
            float frontProjectDist = (front - frontPos).magnitude;
            if (backIndex < index && index < frontIndex)
            {
                if ((position - back).sqrMagnitude < (position - front).sqrMagnitude)
                {
                    SplineSample.Lerp(ref samples[backIndex], ref samples[index], backProjectDist / backLength, ref result);
                    if (sampleMode == SplineComputer.SampleMode.Uniform) result.percent = DMath.Lerp(GetSamplePercent(backIndex), GetSamplePercent(index), backProjectDist / backLength);
                }
                else
                {
                    SplineSample.Lerp(ref samples[frontIndex], ref samples[index], frontProjectDist / frontLength, ref result);
                    if (sampleMode == SplineComputer.SampleMode.Uniform) result.percent = DMath.Lerp(GetSamplePercent(frontIndex), GetSamplePercent(index), frontProjectDist / frontLength);
                }
            }
            else if (backIndex < index)
            {
                SplineSample.Lerp(ref samples[backIndex], ref samples[index], backProjectDist / backLength, ref result);
                if (sampleMode == SplineComputer.SampleMode.Uniform) result.percent = DMath.Lerp(GetSamplePercent(backIndex), GetSamplePercent(index), backProjectDist / backLength);
            }
            else
            {
                SplineSample.Lerp(ref samples[frontIndex], ref samples[index], frontProjectDist / frontLength, ref result);
                if (sampleMode == SplineComputer.SampleMode.Uniform) result.percent = DMath.Lerp(GetSamplePercent(frontIndex), GetSamplePercent(index), frontProjectDist / frontLength);
            }

            if (from == 0.0 && to == 1.0 && result.percent < samples[1].percent) //Handle looped splines
            {
                Vector3 pos1 = GetModifiedPosition(ref samples[samples.Length - 1]);
                Vector3 pos2 = GetModifiedPosition(ref samples[samples.Length - 2]);

                Vector3 projected = LinearAlgebraUtility.ProjectOnLine(pos1, pos2, position);
                if ((position - projected).sqrMagnitude < (position - result.position).sqrMagnitude)
                {
                    double l = LinearAlgebraUtility.InverseLerp(pos1, pos2, projected);
                    SplineSample.Lerp(ref samples[samples.Length - 1], ref samples[samples.Length - 2], l, ref result);
                    if (sampleMode == SplineComputer.SampleMode.Uniform) result.percent = DMath.Lerp(GetSamplePercent(samples.Length - 1), GetSamplePercent(samples.Length - 2), l);
                }
            }

            if (__useModifier)
            {
                modifier.ApplySampleModifiers(ref result);
            }
        }

        private double GetSamplePercent(int sampleIndex)
        {
            if (sampleMode == SplineComputer.SampleMode.Optimized)
            {
                return samples[optimizedIndices[sampleIndex]].percent;
            }
            return (double)sampleIndex / (samples.Length - 1);
        }

        /// <summary>
        /// Same as Spline.CalculateLength but this takes the computer's transform into account when calculating the length.
        /// </summary>
        /// <param name="from">Calculate from [0-1] default: 0f</param>
        /// <param name="to">Calculate to [0-1] default: 1f</param>
        /// <param name="resolution">Resolution [0-1] default: 1f</param>
        /// <param name="address">Node address of junctions</param>
        /// <returns></returns>
        public float CalculateLength(double from = 0.0, double to = 1.0, bool preventInvert = true)
        {
            if (!hasSamples) return 0f;
            Spline.FormatFromTo(ref from, ref to, preventInvert);
            float length = 0f;
            Vector3 lastPos = EvaluatePosition(from);
            int fromIndex, toIndex;
            double lerp;
            GetSamplingValues(from, out fromIndex, out lerp);
            GetSamplingValues(to, out toIndex, out lerp);

            if (lerp > 0.0 && toIndex < this.length - 1)
            {
                toIndex++;
            }

            for (int i = fromIndex + 1; i < toIndex; i++)
            {
                Vector3 currentPos = samples[i].position;
                length += Vector3.Distance(currentPos, lastPos);
                lastPos = currentPos;
            }
            length += Vector3.Distance(EvaluatePosition(to), lastPos);

            return length;
        }

        /// <summary>
        /// Calculates the length between <paramref name="from"/> and <paramref name="to"/> with applied local offset to to the samples
        /// The offset is multiplied by the sample sizes
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="offset"></param>
        /// <returns></returns>
        public float CalculateLengthWithOffset(Vector3 offset, double from = 0.0, double to = 1.0)
        {
            if (!hasSamples) return 0f;
            Spline.FormatFromTo(ref from, ref to);
            float length = 0f;
            Evaluate(from, ref _workSample);
            Vector3 lastPos = _workSample.position + _workSample.up * (offset.y * _workSample.size) + _workSample.right * (offset.x * _workSample.size) + _workSample.forward * (offset.z * _workSample.size);
            int fromIndex, toIndex;
            double lerp;
            GetSamplingValues(from, out fromIndex, out lerp);
            GetSamplingValues(to, out toIndex, out lerp);

            if (lerp > 0.0 && toIndex < this.length - 1)
            {
                toIndex++;
            }

            for (int i = fromIndex + 1; i < toIndex; i++)
            {
                Vector3 newPos = samples[i].position + samples[i].up * (offset.y * samples[i].size) + samples[i].right * (offset.x * samples[i].size) + samples[i].forward * (offset.z * samples[i].size);
                length += Vector3.Distance(newPos, lastPos);
                lastPos = newPos;
            }

            Evaluate(to, ref _workSample);
            _workSample.position += _workSample.up * (offset.y * _workSample.size) + _workSample.right * (offset.x * _workSample.size) + _workSample.forward * (offset.z * _workSample.size);
            length += Vector3.Distance(_workSample.position, lastPos);
            return length;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SampleCollection.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Spline.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d8bb4e3c138e5124b9ea58db9d93e1f4
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Dreamteck;

namespace Dreamteck.Splines {
    //The Spline class defines a spline with world coordinates. It comes with various sampling methods
    [System.Serializable]
    public class Spline {
        public enum Direction { Forward = 1, Backward = -1 }
        public enum Type { CatmullRom, BSpline, Bezier, Linear };
        public SplinePoint[] points = new SplinePoint[0];
        public Type type = Type.Bezier;
        public bool linearAverageDirection = true;
        public AnimationCurve customValueInterpolation = null;
        public AnimationCurve customNormalInterpolation = null;
        public int sampleRate = 10;

        /// <summary>
        /// Returns true if the spline is closed
        /// </summary>
        public bool isClosed
        {
            get
            {
                return closed && points.Length >= 3;
            }
        }
        /// <summary>
        /// The step size of the percent incrementation when evaluating a spline (based on percision)
        /// </summary>
        public double moveStep
        {
            get {
                if (type == Type.Linear) return 1f / (points.Length-1);
                return 1f / (iterations-1);
            }
            set { }
        }
       /// <summary>
        /// The total count of samples for the spline (based on the sample rate)
       /// </summary>
       public int iterations
        {
            get {
                if (type == Type.Linear) return closed ? points.Length + 1 : points.Length;
                int segments = closed ? points.Length : points.Length - 1;
                return sampleRate * segments - segments + 1;
            }
        }

        public float knotParametrization
        {
            get { return _knotParametrization; }
            set
            {
                _knotParametrization = Mathf.Clamp01(value);
            }
        }

        private static Vector3[] P = new Vector3[4];
        private static Vector3 A1;
        private static Vector3 A2;
        private static Vector3 A3;
        private static Vector3 B1;
        private static Vector3 B2;
        private static float t1;
        private static float t2;
        private static float t3;

        [SerializeField]
        private bool closed = false;
        [SerializeField, Range(0f, 1f)]
        private float _knotParametrization;

        public Spline(Type type){
			this.type = type;
			points = new SplinePoint[0];
		}

        public Spline(Type type, int sampleRate)
        {
            this.type = type;
            this.sampleRate = sampleRate;
            points = new SplinePoint[0];
        }

        /// <summary>
        /// Calculate the length of the spline
        /// </summary>
        /// <param name="from">Calculate from [0-1] default: 0f</param>
        /// <param name="to">Calculate to [0-1] default: 1f</param>
        /// <param name="resolution">Resolution multiplier for precision [0-1] default: 1f</param>
        /// <returns></returns>
        public float CalculateLength(double from = 0.0, double to = 1.0, double resolution = 1.0)
        {
            if (points.Length == 0) return 0f;
            resolution = DMath.Clamp01(resolution);
            if (resolution == 0.0) return 0f;
            from = DMath.Clamp01(from);
            to = DMath.Clamp01(to);
            if (to < from) to = from;
            double percent = from;
            Vector3 lastPos = EvaluatePosition(percent);
            float sum = 0f;
            while (true)
            {
                percent = DMath.Move(percent, to, moveStep / resolution);
                Vector3 pos = EvaluatePosition(percent);
                sum += (pos - lastPos).magnitude;
                lastPos = pos;
                if (percent == to) break;
            }
            return sum;
        }

        /// <summary>
        /// Project point on the spline. Returns evaluation percent.
        /// </summary>
        /// <param name="position">3D Point</param>
        /// <param name="subdivide">Subdivisions default: 4</param>
        /// <param name="from">Sample from [0-1] default: 0f</param>
        /// <param name="to">Sample to [0-1] default: 1f</param>
        /// <returns></returns>
        public double Project(Vector3 position, int subdivide = 4, double from = 0.0, double to = 1.0)
        {
            if (points.Length == 0) return 0.0;
            if (closed && from == 0.0 && to == 1.0) //Handle looped splines
            {
                double closest = GetClosestPoint(subdivide, position, from, to, Mathf.RoundToInt(Mathf.Max(iterations / points.Length, 10)) * 5);
                if (closest < moveStep)
                {
                    double nextClosest = GetClosestPoint(subdivide, position, 0.5, to, Mathf.RoundToInt(Mathf.Max(iterations / points.Length, 10)) * 5);
                    if (Vector3.Distance(position, EvaluatePosition(nextClosest)) < Vector3.Distance(position, EvaluatePosition(closest))) return nextClosest;
                }
                return closest;
            }
            return GetClosestPoint(subdivide, position, from, to, Mathf.RoundToInt(Mathf.Max(iterations / points.Length, 10)) * 5);
        }

        /// <summary>
        /// Casts rays along the spline against all colliders in the scene
        /// </summary>
        /// <param name="hit">Hit information</param>
        /// <param name="hitPercent">The percent of evaluation where the hit occured</param>
        /// <param name="layerMask">Layer mask for the raycast</param>
        /// <param name="resolution">Resolution multiplier for precision [0-1] default: 1f</param>
        /// <param name="from">Raycast from [0-1] default: 0f</param>
        /// <param name="to">Raycast to [0-1] default: 1f</param>
        /// <param name="hitTriggers">Should hit triggers? (not supported in 5.1)</param>
        /// <returns></returns>
        public bool Raycast(out RaycastHit hit, out double hitPercent, LayerMask layerMask, double resolution = 1.0, double from = 0.0, double to = 1.0, QueryTriggerInteraction hitTriggers = QueryTriggerInteraction.UseGlobal
        )
        {
            resolution = DMath.Clamp01(resolution);
            from = DMath.Clamp01(from);
            to = DMath.Clamp01(to);
            double percent = from;
            Vector3 fromPos = EvaluatePosition(percent);
            hitPercent = 0f;
            if (resolution == 0f)
            {
                hit = new RaycastHit();
                hitPercent = 0f;
                return false;
            }
            while (true)
            {
                double prevPercent = percent;
                percent = DMath.Move(percent, to, moveStep / resolution);
                Vector3 toPos = EvaluatePosition(percent);
                if (Physics.Linecast(fromPos, toPos, out hit, layerMask, hitTriggers))
                {
                    double segmentPercent = (hit.point - fromPos).sqrMagnitude / (toPos - fromPos).sqrMagnitude;
                    hitPercent = DMath.Lerp(prevPercent, percent, segmentPercent);
                    return true;
                }
                fromPos = toPos;
                if (percent == to) break;
            }
            return false;
        }


        /// <summary>
        /// Casts rays along the spline against all colliders in the scene and returns all hits. Order is not guaranteed.
        /// </summary>
        /// <param name="hits">Hit information</param>
        /// <param name="hitPercents">The percents of evaluation where each hit occured</param>
        /// <param name="layerMask">Layer mask for the raycast</param>
        /// <param name="resolution">Resolution multiplier for precision [0-1] default: 1f</param>
        /// <param name="from">Raycast from [0-1] default: 0f</param>
        /// <param name="to">Raycast to [0-1] default: 1f</param>
        /// <param name="hitTriggers">Should hit triggers? (not supported in 5.1)</param>
        /// <returns></returns>
        public bool RaycastAll(out RaycastHit[] hits, out double[] hitPercents, LayerMask layerMask, double resolution = 1.0, double from = 0.0, double to = 1.0, QueryTriggerInteraction hitTriggers = QueryTriggerInteraction.UseGlobal
            )
        {
            resolution = DMath.Clamp01(resolution);
            from = DMath.Clamp01(from);
            to = DMath.Clamp01(to);
            double percent = from;
            Vector3 fromPos = EvaluatePosition(percent);
            List<RaycastHit> hitList = new List<RaycastHit>();
            List<double> percentList = new List<double>();
            if (resolution == 0f)
            {
                hits = new RaycastHit[0];
                hitPercents = new double[0];
                return false;
            }
            bool hasHit = false;
            while (true)
            {
                double prevPercent = percent;
                percent = DMath.Move(percent, to, moveStep / resolution);
                Vector3 toPos = EvaluatePosition(percent);
                RaycastHit[] h = Physics.RaycastAll(fromPos, toPos - fromPos, Vector3.Distance(fromPos, toPos), layerMask, hitTriggers);
                for (int i = 0; i < h.Length; i++)
                {
                    hasHit = true;
                    double segmentPercent = (h[i].point - fromPos).sqrMagnitude / (toPos - fromPos).sqrMagnitude;
                    percentList.Add(DMath.Lerp(prevPercent, percent, segmentPercent));
                    hitList.Add(h[i]);
                }
                fromPos = toPos;
                if (percent == to) break;
            }
            hits = hitList.ToArray();
            hitPercents = percentList.ToArray();
            return hasHit;
        } 

        /// <summary>
        /// Converts a point index to spline percent
        /// </summary>
        /// <param name="pointIndex">The point index</param>
        /// <returns></returns>
        public double GetPointPercent(int pointIndex)
        {
            if (closed)
            {
                return DMath.Clamp01((double)pointIndex / points.Length);
            }
            return DMath.Clamp01((double)pointIndex / (points.Length - 1));
        }

        /// <summary>
        /// Evaluate the spline and return position. This is simpler and faster than Evaluate.
        /// </summary>
        /// <param name="percent">Percent of evaluation [0-1]</param>
        public Vector3 EvaluatePosition(double percent)
        {
            if (points.Length == 0) return Vector3.zero;
            Vector3 position = new Vector3();
            EvaluatePosition(percent, ref position);
            return position;
        }

        /// <summary>
        /// Evaluate the spline at the given time and return a SplineSample
        /// </summary>
        /// <param name="percent">Percent of evaluation [0-1]</param>
        public SplineSample Evaluate(double percent)
        {
            SplineSample result = new SplineSample();
            Evaluate(percent, ref result);
            return result;
		}

        /// <summary>
        /// Evaluate the spline at the position of a given point and return a SplineSample
        /// </summary>
        /// <param name="pointIndex">Point index</param>
        public SplineSample Evaluate(int pointIndex)
        {
            SplineSample result = new SplineSample();
            Evaluate(GetPointPercent(pointIndex), ref result);
            return result;
        }

        /// <summary>
        /// Evaluate the splien at the given point and write the result to the "result" object
        /// </summary>
        /// <param name="result">The result output</param>
        /// <param name="pointIndex">Point index</param>
        public void Evaluate(int pointIndex, ref SplineSample result)
        {
            Evaluate(GetPointPercent(pointIndex), ref result);
        }

        /// <summary>
        /// Evaluate the splien at the given time and write the result to the "result" object
        /// </summary>
        /// <param name="sample">The result output</param>
        /// <param name="percent">Percent of evaluation [0-1]</param>
        public void Evaluate(double percent, ref SplineSample sample)
        {
            if (points.Length == 0)
            {
                sample = new SplineSample();
                return;
            }
            percent = DMath.Clamp01(percent);
            if (closed && points.Length <= 2)
            {
                closed = false;
            }
            if (points.Length == 1)
            {
                sample.position = points[0].position;
                sample.up = points[0].normal;
                sample.forward = Vector3.forward;
                sample.size = points[0].size;
                sample.color = points[0].color;
                sample.percent = percent;
                return;
            }

            double doubleIndex = (points.Length - 1) * percent;
            if (closed)
            {
                doubleIndex = points.Length * percent;
            }
            int fromIndex = DMath.FloorInt(doubleIndex);
            int toIndex = fromIndex + 1;
            if (closed)
            {
                if (fromIndex >= points.Length - 1)
                {
                    fromIndex = points.Length - 1;
                }
                if(toIndex > points.Length - 1)
                {
                    toIndex = 0;
                }
            } else
            {
                if(toIndex > points.Length-1)
                {
                    toIndex = points.Length - 1;
                }
            }
            double getPercent = doubleIndex - fromIndex;

            sample.percent = percent;

            float valueInterpolation = (float)getPercent;
            if (customValueInterpolation != null)
            {
                if (customValueInterpolation.length > 0)
                {
                    valueInterpolation = customValueInterpolation.Evaluate(valueInterpolation);
                }
            }
            float normalInterpolation = (float)getPercent;
            if (customNormalInterpolation != null)
            {
                if (customNormalInterpolation.length > 0)
                {
                    normalInterpolation = customNormalInterpolation.Evaluate(normalInterpolation);
                }
            }
            sample.size = Mathf.Lerp(points[fromIndex].size, points[toIndex].size, valueInterpolation);
            sample.color = Color.Lerp(points[fromIndex].color, points[toIndex].color, valueInterpolation);
            sample.up = Vector3.Slerp(points[fromIndex].normal, points[toIndex].normal, normalInterpolation);

            EvaluatePositionAndTangent(ref sample.position, ref sample.forward, percent);

            if (type == Type.BSpline)
            {
                double step = 1.0 / (iterations - 1);
                if (percent <= 1.0 - step && percent >= step)
                {
                    sample.forward = EvaluatePosition(percent + step) - EvaluatePosition(percent - step);
                }
                else
                {
                    Vector3 back = Vector3.zero, front = Vector3.zero;
                    if (closed)
                    {
                        if (percent < step) EvaluatePosition(1.0 - (step - percent), ref back);
                        else  EvaluatePosition(percent - step, ref back);
                        if (percent > 1.0 - step) EvaluatePosition(step - (1.0 - percent), ref front);
                        else EvaluatePosition(percent + step, ref front);
                        sample.forward = front - back;
                    }
                    else
                    {
                        EvaluatePosition(percent - step, ref back);
                        back = sample.position - back;
                        EvaluatePosition(percent + step, ref front);
                        front = front - sample.position;
                        sample.forward = Vector3.Slerp(front, back, back.magnitude / front.magnitude);
                    }
                }
            }
            
            sample.forward.Normalize();
        }

        [System.Obsolete("This override is obsolete. Use Evaluate(int pointIndex, ref SplineSample sample) instead")]
        public void Evaluate(ref SplineSample sample, int pointIndex)
        {
            Evaluate(pointIndex, ref sample);
        }

        [System.Obsolete("This override is obsolete. Use Evaluate(double percent, ref SplineSample sample) instead")]
        public void Evaluate(ref SplineSample sample, double percent)
        {
            Evaluate(percent, ref sample);
        }

        /// <summary>
        /// Evaluates the spline segment and writes the results to the array
        /// </summary>
        /// <param name="from">Start position [0-1]</param>
        /// <param name="to">Target position [from-1]</param>
        /// <returns></returns>
        public void Evaluate(ref SplineSample[] samples, double from = 0.0, double to = 1.0)
        {
            if (points.Length == 0) {
                samples = new SplineSample[0];
                return;
            }
            from = DMath.Clamp01(from);
            to = DMath.Clamp(to, from, 1.0);
            double fromValue = from * (iterations - 1);
            double toValue = to * (iterations - 1);
            int clippedIterations = DMath.CeilInt(toValue) - DMath.FloorInt(fromValue) + 1;
            if (samples == null) samples = new SplineSample[clippedIterations];
            else if (samples.Length != clippedIterations) samples = new SplineSample[clippedIterations];
            double percent = from;
            double ms = moveStep;
            int index = 0;
            while (true)
            {
                samples[index] = Evaluate(percent);
                index++;
                if (index >= samples.Length) break;
                percent = DMath.Move(percent, to, ms);
            }
        }

        /// <summary>
        /// Evaluates the spline segment and writes uniformly spaced results to the array
        /// </summary>
        /// <param name="from">Start position [0-1]</param>
        /// <param name="to">Target position [from-1]</param>
        /// <returns></returns>
        public void EvaluateUniform(ref SplineSample[] samples, ref double[] originalSamplePercents, double from = 0.0, double to = 1.0)
        {
            if (points.Length == 0)
            {
                samples = new SplineSample[0];
                return;
            }
            from = DMath.Clamp01(from);
            to = DMath.Clamp(to, from, 1.0);
            double fromValue = from * (iterations - 1);
            double toValue = to * (iterations - 1);
            int clippedIterations = DMath.CeilInt(toValue) - DMath.FloorInt(fromValue) + 1;
            if (samples == null || samples.Length != clippedIterations) samples = new SplineSample[clippedIterations];
            if (originalSamplePercents == null || originalSamplePercents.Length != clippedIterations)
            {
                originalSamplePercents = new double[clippedIterations];
            }
            float lengthStep = CalculateLength(from, to) / (iterations - 1);
            Evaluate(from, ref samples[0]);
            samples[0].percent = originalSamplePercents[0] = from;
            double lastPercent = from;
            float moved = 0f;
            for (int i = 1; i < samples.Length - 1; i++)
            {
                Evaluate(Travel(lastPercent, lengthStep, out moved, Direction.Forward), ref samples[i]);
                lastPercent = samples[i].percent;
                originalSamplePercents[i] = lastPercent;
                samples[i].percent = DMath.Lerp(from, to, (double)i/ (samples.Length - 1));
            }
            Evaluate(to, ref samples[samples.Length - 1]);
            samples[samples.Length - 1].percent = originalSamplePercents[originalSamplePercents.Length - 1] = to;
        }

        /// <summary>
        /// Evaluates the spline segment based on the spline's precision and returns only the position. 
        /// </summary>
        /// <param name="positions">The position buffer</param>
        /// <param name="from">Start position [0-1]</param>
        /// <param name="to">Target position [from-1]</param>
        /// <returns></returns>
        public void EvaluatePositions(ref Vector3[] positions, double from = 0.0, double to = 1.0)
        {
            if (points.Length == 0) {
                positions = new Vector3[0];
                return;
            }
            from = DMath.Clamp01(from);
            to = DMath.Clamp(to, from, 1.0);
            double fromValue = from * (iterations - 1);
            double toValue = to * (iterations - 1);
            int clippedIterations = DMath.CeilInt(toValue) - DMath.FloorInt(fromValue) + 1;
            if (positions.Length != clippedIterations) positions = new Vector3[clippedIterations];
            double percent = from;
            double ms = moveStep;
            int index = 0;
            while (true)
            {
                positions[index] = EvaluatePosition(percent);
                index++;
                if (index >= positions.Length) break;
                percent = DMath.Move(percent, to, ms);
            }
        }

        /// <summary>
        /// Returns the percent from the spline at a given distance from the start point
        /// </summary>
        /// <param name="start">The start point</param>
        /// /// <param name="distance">The distance to travel</param>
        /// <param name="direction">The direction towards which to move</param>
        /// <returns></returns>
        public double Travel(double start, float distance, out float moved, Direction direction)
        {
            moved = 0f;
            if (points.Length <= 1) return 0.0;
            if (direction == Direction.Forward && start >= 1.0) return 1.0;
            else if (direction == Direction.Backward && start <= 0.0) return 0.0; ;
            if (distance == 0f) return DMath.Clamp01(start);
            Vector3 pos = Vector3.zero;
            EvaluatePosition(start, ref pos);
            Vector3 lastPosition = pos;
            double lastPercent = start;
            int i = iterations - 1;
            int nextSampleIndex = direction == Spline.Direction.Forward ? DMath.CeilInt(start * i) : DMath.FloorInt(start * i);
            float lastDistance = 0f;
            double percent = start;
            while (true)
            {
                percent = (double)nextSampleIndex / i;
                pos = EvaluatePosition(percent);
                lastDistance = Vector3.Distance(pos, lastPosition);
                lastPosition = pos;
                moved += lastDistance;
                if (moved >= distance) break;
                lastPercent = percent;
                if (direction == Spline.Direction.Forward)
                {
                    if (nextSampleIndex == i) break;
                    nextSampleIndex++;
                }
                else
                {
                    if (nextSampleIndex == 0) break;
                    nextSampleIndex--;
                }
            }
            return DMath.Lerp(lastPercent, percent, 1f - (moved - distance) / lastDistance);
        }

        public double Travel(double start, float distance, Spline.Direction direction = Spline.Direction.Forward)
        {
            float moved;
            return Travel(start, distance, out moved, direction);
        }

        public void EvaluatePosition(double percent, ref Vector3 position)
        {
            if (points.Length == 0)
            {
                position = Vector3.zero;
                return;
            }

            if (points.Length == 1)
            {
                position = points[0].position;
                return;
            }

            percent = DMath.Clamp01(percent);
            double doubleIndex = (points.Length - 1) * percent;
            if (closed)
            {
                doubleIndex = points.Length * percent;
            }
            int pointIndex = DMath.FloorInt(doubleIndex);
            if (type == Type.Bezier)
            {
                pointIndex = Mathf.Clamp(pointIndex, 0, Mathf.Max(points.Length - 1, 0));
            }
            CalculatePosition(ref position, doubleIndex - pointIndex, pointIndex);
        }

        [System.Obsolete("This override is obsolete. Use EvaluatePosition(double percent, ref Vector3 position) instead")]

        public void EvaluatePosition(ref Vector3 position, double percent)
        {
            EvaluatePosition(percent, ref position);
        }

        public void EvaluateTangent(double percent, ref Vector3 tangent)
        {
            if (points.Length < 2)
            {
                tangent = Vector3.forward;
                return;
            }

            percent = DMath.Clamp01(percent);
            double doubleIndex = (points.Length - 1) * percent;
            if (closed)
            {
                doubleIndex = points.Length * percent;
            }
            int pointIndex = DMath.FloorInt(doubleIndex);
            if (type == Type.Bezier)
            {
                pointIndex = Mathf.Clamp(pointIndex, 0, Mathf.Max(points.Length - 1, 0));
            }
            CalculateTangent(ref tangent, doubleIndex - pointIndex, pointIndex);
        }

        public void EvaluatePositionAndTangent(ref Vector3 position, ref Vector3 tangent, double percent)
        {
            if (points.Length == 0)
            {
                position = Vector3.zero;
                tangent = Vector3.forward;
                return;
            }

            if (points.Length == 1)
            {
                position = points[0].position;
                tangent = Vector3.forward;
                return;
            }

            percent = DMath.Clamp01(percent);
            double doubleIndex = (points.Length - 1) * percent;
            if (closed)
            {
                doubleIndex = points.Length * percent;
            }
            int pointIndex = DMath.FloorInt(doubleIndex);
            if (type == Type.Bezier)
            {
                pointIndex = Mathf.Clamp(pointIndex, 0, Mathf.Max(points.Length - 1, 0));
            }
            CalculatePositionAndTangent(doubleIndex - pointIndex, pointIndex, ref position, ref tangent);
        }

        //Get closest point in spline segment. Used for projection
        private double GetClosestPoint(int iterations, Vector3 point, double start, double end, int slices)
        {
            if (iterations <= 0)
            {
                float startDist = (point - EvaluatePosition(start)).sqrMagnitude;
                float endDist = (point - EvaluatePosition(end)).sqrMagnitude;
                if (startDist < endDist) return start;
                else if (endDist < startDist) return end;
                else return (start + end) / 2;
            }
            double closestPercent = 0.0;
            float closestDistance = Mathf.Infinity;
            double tick = (end - start) / slices;
            double t = start;
            Vector3 pos = Vector3.zero;
            while (true)
            {
                EvaluatePosition(t, ref pos);
                float dist = (point - pos).sqrMagnitude;
                if (dist < closestDistance)
                {
                    closestDistance = dist;
                    closestPercent = t;
                }
                if (t == end) break;
                t = DMath.Move(t, end, tick);
            }
            double newStart = closestPercent - tick;
            if (newStart < start) newStart = start;
            double newEnd = closestPercent + tick;
            if (newEnd > end) newEnd = end;
            return GetClosestPoint(--iterations, point, newStart, newEnd, slices);
        }

        /// <summary>
        /// Break the closed spline
        /// </summary>
        public void Break()
        {
            Break(0);
        }

        /// <summary>
        /// Break the closed spline at given point
        /// </summary>
        /// <param name="at"></param>
        public void Break(int at)
        {
            if (!closed) return;
            if (at >= points.Length) return;
            if (at < 0) return;
            SplinePoint[] previousPoints = new SplinePoint[points.Length];
            points.CopyTo(previousPoints, 0);

            for (int i = at; i < previousPoints.Length; i++)
            {
                points[i - at] = previousPoints[i];
            }

            for (int i = 0; i < at; i++)
            {
                points[(points.Length - at) + i] = previousPoints[i];
            }

            closed = false;
        }

        /// <summary>
        /// Close the spline. This will cause the first and last points of the spline to merge
        /// </summary>
        public void Close()
        {
            if (points.Length < 3)
            {
                Debug.LogError("Points need to be at least 3 to close the spline");
                return;
            }
            closed = true;
        }

        /// <summary>
        /// Convert the spline to a Bezier path
        /// </summary>
        public void CatToBezierTangents()
        {
            switch (type)
            {
                case Type.Linear:
                    for (int i = 0; i < points.Length; i++)
                    {
                        points[i].type = SplinePoint.Type.Broken;
                        points[i].SetTangentPosition(points[i].position);
                        points[i].SetTangent2Position(points[i].position);
                    }
                    break;
                case Type.CatmullRom:
                    for (int i = 0; i < points.Length; i++)
                    {
                        points[i].type = SplinePoint.Type.SmoothMirrored;
                        double percent = GetPointPercent(i);
                        Vector3 tangent = Vector3.forward;
                        EvaluateTangent(percent, ref tangent);
                        if(_knotParametrization > 0f)
                        {
                            ComputeCatPoints(i);
                            points[i].SetTangent2Position(points[i].position + tangent.normalized * Vector3.Distance(P[0], P[2]) / 6f);
                        } else
                        {
                            points[i].SetTangent2Position(points[i].position + tangent / 3f);
                        }
                    }
                    break;
                case Type.BSpline:
                    //No BSPline support yet
                    break;
            }
            type = Type.Bezier;
        }

        /// <summary>
        /// Evaluates the position of the spline using one of the algorithms
        /// </summary>
        private void CalculatePosition(ref Vector3 position, double percent, int pointIndex)
        {
            switch (type)
            {
                case Type.CatmullRom:
                    ComputeCatPoints(pointIndex);
                    if (_knotParametrization < 0.000001f)
                    {
                        CalculateCatmullRomPositionFast(ref position, percent, pointIndex);
                    } else
                    {
                        CalculateCatmullRomComponents(percent);
                        CalculateCatmullRomPosition(percent, ref position);
                    }
                    break;
                case Type.Bezier: CalculateBezierPosition(ref position, percent, pointIndex); break;
                case Type.BSpline:
                    ComputeCatPoints(pointIndex);
                    CalculateBSplinePosition(ref position, percent, pointIndex); break;
                case Type.Linear:
                    ComputeCatPoints(pointIndex);
                    CalculateLinearPosition(ref position, percent, pointIndex); 
                    break;
            }
        }

        /// <summary>
        /// Evaluates the direction of the spline using one of the algorithms
        /// </summary>
        private void CalculateTangent(ref Vector3 tangent, double percent, int pointIndex)
        {
            switch (type)
            {
                case Type.CatmullRom:
                    ComputeCatPoints(pointIndex);
                    if (_knotParametrization < 0.000001f)
                    {
                        CalculateCatmullRomTangentFast(ref tangent, percent, pointIndex);
                    }
                    else
                    {
                        CalculateCatmullRomComponents(percent);
                        CalculateCatmullRomTangent(percent, ref tangent);
                    }
                    break;
                case Type.Bezier: 
                    CalculateBezierTangent(ref tangent, percent, pointIndex); 
                    break;
                case Type.Linear:
                    ComputeCatPoints(pointIndex);
                    CalculateLinearTangent(ref tangent, percent, pointIndex); 
                    break;
            }
        }

        /// <summary>
        /// Slightly faster than calling GetPoint and GetTangent separately
        /// </summary>
        private void CalculatePositionAndTangent(double percent, int pointIndex, ref Vector3 position, ref Vector3 tangent)
        {
            switch (type)
            {
                case Type.CatmullRom:
                    ComputeCatPoints(pointIndex);
                    if (_knotParametrization < 0.000001f)
                    {
                        CalculateCatmullRomPositionFast(ref position, percent, pointIndex);
                        CalculateCatmullRomTangentFast(ref tangent, percent, pointIndex);
                    }
                    else
                    {
                        CalculateCatmullRomComponents(percent);
                        CalculateCatmullRomPosition(percent, ref position);
                        CalculateCatmullRomTangent(percent, ref tangent);
                    }
                    break;
                case Type.Bezier: 
                    CalculateBezierPosition(ref position, percent, pointIndex);
                    CalculateBezierTangent(ref tangent, percent, pointIndex);
                    break;
                case Type.BSpline:
                    ComputeCatPoints(pointIndex);
                    CalculateBSplinePosition(ref position, percent, pointIndex); 
                    break;
                case Type.Linear:
                    ComputeCatPoints(pointIndex);
                    CalculateLinearPosition(ref position, percent, pointIndex);
                    CalculateLinearTangent(ref tangent, percent, pointIndex);
                    break;
            }
        }

        private void CalculateLinearPosition(ref Vector3 position, double t, int i)
        {
            if (points.Length == 0)
            {
                position = Vector3.zero;
                return;
            }

            position = Vector3.Lerp(P[1], P[2], (float)t);
        }

        private void CalculateLinearTangent(ref Vector3 tangent, double t, int i)
        {
            if (points.Length == 0)
            {
                tangent = Vector3.forward;
                return;
            }

            if (linearAverageDirection) tangent = Vector3.Slerp(P[1] - P[0], P[2] - P[1], 0.5f);
            else tangent = P[2] - P[1];
        }

        private void CalculateBSplinePosition(ref Vector3 position, double time, int i)
        {
            if (points.Length > 0) position = points[0].position;
            if (points.Length > 1)
            {
                float tf = (float)DMath.Clamp01(time);
                position = ((-P[0] + P[2]) / 2f 
                + tf * ((P[0] - 2f * P[1] + P[2]) / 2f 
                + tf * (-P[0] + 3f * P[1] - 3f * P[2] + P[3]) / 6f)) * tf 
                + (P[0] + 4f * P[1] + P[2]) / 6f;
            }
        }

        private void CalculateBezierPosition(ref Vector3 position, double t, int i)
        {
            if (points.Length > 0) position = points[0].position;
            else return;
            if (!closed && points.Length == 1) return;
            t = DMath.Clamp01(t);
            int it = i + 1;
            if (it >= points.Length)
            {
                it = 0;
            }

            float ft = (float)t;
            float nt = 1f - ft;
            position = nt * nt * nt * points[i].position + 
                3f * nt * nt * ft * points[i].tangent2 + 
                3f * nt * ft * ft * points[it].tangent + 
                ft * ft * ft * points[it].position;
        }

        private void CalculateBezierTangent(ref Vector3 tangent, double t, int i)
        {
            if (points.Length > 0) tangent = points[0].tangent;
            else return;
            if (!closed && points.Length == 1) return;
            t = DMath.Clamp01(t);
            int it = i + 1;
            if (it >= points.Length)
            {
                it = 0;
            }
            float ft = (float)t;
            float nt = 1f - ft;
            tangent = -3f * nt * nt * points[i].position + 
                3f * nt * nt * points[i].tangent2 - 
                6f * ft * nt * points[i].tangent2 - 
                3f * ft * ft * points[it].tangent + 
                6f * ft * nt * points[it].tangent + 
                3f * ft * ft * points[it].position;
           
        }

        private void CalculateCatmullRomComponents(double t)
        {
            const float t0 = 0f;
            t1 = GetInterval(P[0], P[1]);
            t2 = GetInterval(P[1], P[2]) + t1;
            t3 = GetInterval(P[2], P[3]) + t2;
            float tf = Mathf.LerpUnclamped(t1, t2, (float)t);

            A1 = (t1 - tf) / (t1 - t0) * P[0] + (tf - t0) / (t1 - t0) * P[1];
            A2 = (t2 - tf) / (t2 - t1) * P[1] + (tf - t1) / (t2 - t1) * P[2];
            A3 = (t3 - tf) / (t3 - t2) * P[2] + (tf - t2) / (t3 - t2) * P[3];

            B1 = (t2 - tf) / (t2 - t0) * A1 + (tf - t0) / (t2 - t0) * A2;
            B2 = (t3 - tf) / (t3 - t1) * A2 + (tf - t1) / (t3 - t1) * A3;
            

            float GetInterval(Vector3 a, Vector3 b)
            {
                return Mathf.Pow((a - b).sqrMagnitude, _knotParametrization * 0.5f);
            }
        }

        private void CalculateCatmullRomPosition(double t, ref Vector3 position)
        {
            float tf = Mathf.LerpUnclamped(t1, t2, (float)t);
            position = (t2 - tf) / (t2 - t1) * B1 + (tf - t1) / (t2 - t1) * B2;
        }

        private void CalculateCatmullRomTangent(double t, ref Vector3 tangent)
        {
            float tf = Mathf.LerpUnclamped(t1, t2, (float)t);
            Vector3 A1p = (P[1] - P[0]) / t1;
            Vector3 A2p = (P[2] - P[1]) / (t2 - t1);
            Vector3 A3p = (P[3] - P[2]) / (t3 - t2);

            Vector3 B1p = (A2 - A1) / t2  + (t2 - tf) / t2 * A1p + tf / t2  * A2p;
            Vector3 B2p = (A3 - A2) / (t3 - t1) + (t3 - tf) / (t3 - t1) * A2p + (tf - t1) / (t3 - t1) * A3p;

            tangent = (B2 - B1) / (t2 - t1) + (t2 - tf) / (t2 - t1) * B1p + (tf - t1) / (t2 - t1) * B2p;
        }

        private void CalculateCatmullRomPositionFast(ref Vector3 position, double t, int i)
        {
            float t1 = (float)t;
            float t2 = t1 * t1;
            float t3 = t2 * t1;
            if (points.Length > 0)
            {
                position = points[0].position;
            }

            if (!closed && i >= points.Length) return;

            if (points.Length > 1)
            {
                position = 0.5f * ((2f * P[1]) + (-P[0] + P[2]) * t1
                + (2f * P[0] - 5f * P[1] + 4f * P[2] - P[3]) * t2
                + (-P[0] + 3f * P[1] - 3f * P[2] + P[3]) * t3);
            }
        }

        private void CalculateCatmullRomTangentFast(ref Vector3 tangent, double t, int i)
        {
            float t1 = (float)t;
            float t2 = t1 * t1;
            if (!closed && i >= points.Length) return;
            if (points.Length > 1)
            {
                tangent = (6 * t2 - 6 * t1) * P[1]
                + (3 * t2 - 4 * t1 + 1) * (P[2] - P[0]) * 0.5f
                + (-6 * t2 + 6 * t1) * P[2]
                + (3 * t2 - 2 * t1) * (P[3] - P[1]) * 0.5f;
            }
        }

        private void ComputeCatPoints(int i)
        {
            int p1 = i - 1;
            int p2 = i;
            int p3 = i + 1;
            int p4 = i + 2;

            if (closed)
            {
                if(p1 < 0)
                {
                    p1 += points.Length;
                }
                if (p2 >= points.Length)
                {
                    p2 -= points.Length;
                }
                if (p3 >= points.Length)
                {
                    p3 -= points.Length;
                }
                if(p4 >= points.Length)
                {
                    p4 -= points.Length;
                }
                P[0] = points[p1].position;
                P[1] = points[p2].position;
                P[2] = points[p3].position;
                P[3] = points[p4].position;
            } else
            {
                if(p1 < 0)
                {
                    P[0] = points[0].position;
                    P[0] += (P[0] - points[1].position);
                } else 
                {
                    P[0] = points[p1].position;
                }

                P[1] = points[p2].position;

                if (p3 >= points.Length)
                {
                    P[2] = points[points.Length - 1].position;
                    Vector3 pos = P[2];
                    P[2] += P[2] - points[points.Length - 2].position;
                    P[3] = P[2] + (P[2] - pos);
                }
                else
                {
                    P[2] = points[p3].position;
                    if(p4 >= points.Length)
                    {
                        P[3] = P[2] + (P[2] - points[p3 - 1].position);
                    } 
                    else
                    {
                        P[3] = points[p4].position;
                    }
                }
            }
        }

        public static void FormatFromTo(ref double from, ref double to, bool preventInvert = true)
        {
            from = DMath.Clamp01(from);
            to = DMath.Clamp01(to);
            if (preventInvert && from > to)
            {
                double tmp = from;
                from = to;
                to = tmp;
            } else  to = DMath.Clamp(to, 0.0, 1.0);
        }
    }


}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Spline.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplinePoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 373843b4b8b230a4d83d3257cb163ae6
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using UnityEngine.Serialization;
using System;

namespace Dreamteck.Splines{
	[System.Serializable]
    //A control point used by the SplineClass
	public struct SplinePoint {
        public enum Type {SmoothMirrored, Broken, SmoothFree};
        public Type type
        {
            get { return _type; }
            set
            {
                isDirty = _type != value;
                _type = value;
                if (value == Type.SmoothMirrored)
                {
                    SmoothMirrorTangent2();
                }
            }
        }

        /// <summary>
        /// Getting the value of isDirty will set the point not dirty
        /// </summary>
        [NonSerialized]
        public bool isDirty;
       
        [FormerlySerializedAs("type")]
        [SerializeField]
        [HideInInspector]
        private Type _type;

        [HideInInspector]
        [FormerlySerializedAs("_position")]
        public Vector3 position;

        [HideInInspector]
        [FormerlySerializedAs("_color")]
        public Color color;

        [HideInInspector]
        [FormerlySerializedAs("_normal")]
        public Vector3 normal;

        [HideInInspector]
        [FormerlySerializedAs("_size")]
        public float size;

        [HideInInspector]
        [FormerlySerializedAs("_tangent")]
        public Vector3 tangent;

        [HideInInspector]
        [FormerlySerializedAs("_tangent2")]
        public Vector3 tangent2;

        public static SplinePoint Lerp(SplinePoint a, SplinePoint b, float t)
        {
            SplinePoint result = a;
            if (a.type == Type.Broken || b.type == Type.Broken) result.type = Type.Broken;
            else if (a.type == Type.SmoothFree || b.type == Type.SmoothFree) result.type = Type.SmoothFree;
            else result.type = Type.SmoothMirrored;
            result.position = Vector3.Lerp(a.position, b.position, t);
            GetInterpolatedTangents(a, b, t, ref result);
            result.color = Color.Lerp(a.color, b.color, t);
            result.size = Mathf.Lerp(a.size, b.size, t);
            result.normal = Vector3.Slerp(a.normal, b.normal, t);
            return result;
        }

        private static void GetInterpolatedTangents(SplinePoint a, SplinePoint b, float t, ref SplinePoint target)
        {
            Vector3 P0_1 = (1f - t) * a.position + t * a.tangent2;
            Vector3 P1_2 = (1f - t) * a.tangent2 + t * b.tangent;
            Vector3 P2_3 = (1f - t) * b.tangent + t * b.position;
            Vector3 P01_12 = (1 - t) * P0_1 + t * P1_2;
            Vector3 P12_23 = (1 - t) * P1_2 + t * P2_3;
            target.tangent = P01_12;
            target.tangent2 = P12_23;
        }

        public override bool Equals(object obj)
        {
            if(obj is SplinePoint)
            {
                return EqualsFast((SplinePoint)obj);
            }
            return false;
        }

        private bool EqualsFast(SplinePoint obj)
        {
            SplinePoint other = (SplinePoint)obj;
            if (position != other.position) return false;
            if (tangent != other.tangent) return false;
            if (tangent2 != other.tangent2) return false;
            if (normal != other.normal) return false;
            if (_type != other._type) return false;
            if (size != other.size) return false;
            if (color != other.color) return false;
            return true;
        }


        public static bool operator == (SplinePoint p1, SplinePoint p2)
        {
            return p1.EqualsFast(p2);
        }

        public static bool operator != (SplinePoint p1, SplinePoint p2)
        {
            return !p1.EqualsFast(p2);
        }

        public void SetPosition(Vector3 pos)
        {
            tangent -= position - pos;
            tangent2 -= position - pos;
            position = pos;
        }

        public void SetTangentPosition(Vector3 pos)
        {
            tangent = pos;
            switch (_type)
            {
                case Type.SmoothMirrored: SmoothMirrorTangent2(); break;
                case Type.SmoothFree: SmoothFreeTangent2(); break;
            }
        }

        public void SetTangent2Position(Vector3 pos)
        {
            tangent2 = pos;
            switch (_type)
            {
                case Type.SmoothMirrored: SmoothMirrorTangent(); break;
                case Type.SmoothFree: SmoothFreeTangent(); break;
            }
        }

        public SplinePoint(Vector3 p)
        {
            position = p;
            tangent = p;
            tangent2 = p;
            color = Color.white;
            normal = Vector3.up;
            size = 1f;
            _type = Type.SmoothMirrored;
            isDirty = false;
            SmoothMirrorTangent2();
        }
		
		public SplinePoint(Vector3 p, Vector3 t){
            position = p;
            tangent = t;
            tangent2 = p + (p - t);
            color = Color.white;
            normal = Vector3.up;
            size = 1f;
            _type = Type.SmoothMirrored;
            isDirty = false;
            SmoothMirrorTangent2();
        }	
		
		public SplinePoint(Vector3 pos, Vector3 tan, Vector3 nor, float s, Color col){
            position = pos;
            tangent = tan;
            tangent2 = pos + (pos - tan);
            normal = nor;
            size = s;
            color = col;
            _type = Type.SmoothMirrored;
            isDirty = false;
            SmoothMirrorTangent2();
        }

        public SplinePoint(Vector3 pos, Vector3 tan, Vector3 tan2, Vector3 nor, float s, Color col)
        {
            position = pos;
            tangent = tan;
            tangent2 = tan2;
            normal = nor;
            size = s;
            color = col;
            _type = Type.Broken;
            isDirty = false;
            switch (_type)
            {
                case Type.SmoothMirrored: SmoothMirrorTangent2(); break;
                case Type.SmoothFree: SmoothFreeTangent2(); break;
            }
        }

        public SplinePoint(SplinePoint source)
        {
            position = source.position;
            tangent = source.tangent;
            tangent2 = source.tangent2;
            color = source.color;
            normal = source.normal;
            size = source.size;
            _type = source.type;
            isDirty = false;
            switch (_type)
            {
                case Type.SmoothMirrored: SmoothMirrorTangent2(); break;
                case Type.SmoothFree: SmoothFreeTangent2(); break;
            }
        }

        public void Flatten(LinearAlgebraUtility.Axis axis, float flatValue = 0f)
        {
            position = LinearAlgebraUtility.FlattenVector(position, axis, flatValue);
            tangent = LinearAlgebraUtility.FlattenVector(tangent, axis, flatValue);
            tangent2 = LinearAlgebraUtility.FlattenVector(tangent2, axis, flatValue);
            switch (axis)
            {
                case LinearAlgebraUtility.Axis.X: normal = Vector3.right; break;
                case LinearAlgebraUtility.Axis.Y: normal = Vector3.up; break;
                case LinearAlgebraUtility.Axis.Z: normal = Vector3.forward; break;
            }
        }

        public void SetPositionX(float value)
        {
            if(position.x != value)
            {
                isDirty = true;
            }
            position.x = value;
        }

        public void SetPositionY(float value)
        {
            if(position.y != value)
            {
                isDirty = true;
            }
            position.y = value;
        }

        public void SetPositionZ(float value)
        {
            if(position.z != value)
            {
                isDirty = true;
            }
            position.z = value;
        }

        public void SetTangentX(float value)
        {
            if(tangent.x != value)
            {
                isDirty = true;
            }
            tangent.x = value;
        }

        public void SetTangentY(float value)
        {
            if (tangent.y != value)
            {
                isDirty = true;
            }
            tangent.y = value;
        }

        public void SetTangentZ(float value)
        {
            if(tangent.z != value)
            {
                isDirty = true;
            }
            tangent.z = value;
        }

        public void SetTangent2X(float value)
        {
            if (tangent2.x != value)
            {
                isDirty = true;
            }
            tangent2.x = value;
        }

        public void SetTangent2Y(float value)
        {
            if (tangent2.y != value)
            {
                isDirty = true;
            }
            tangent2.y = value;
        }

        public void SetTangent2Z(float value)
        {
            if (tangent2.z != value)
            {
                isDirty = true;
            }
            tangent2.z = value;
        }

        public void SetNormalX(float value)
        {
            if (normal.x != value)
            {
                isDirty = true;
            }
            normal.x = value;
        }

        public void SetNormalY(float value)
        {
            if (normal.y != value)
            {
                isDirty = true;
            }
            normal.y = value;
        }

        public void SetNormalZ(float value)
        {
            if(normal.z != value)
            {
                isDirty = true;
            }
            normal.z = value;
        }

        public void SetColorR(float value)
        {
            if (color.r != value)
            {
                isDirty = true;
            }
            color.r = value;
        }

        public void SetColorG(float value)
        {
            if (color.g != value)
            {
                isDirty = true;
            }
            color.g = value;
        }

        public void SetColorB(float value)
        {
            if(color.b != value)
            {
                isDirty = true;
            }
            color.b = value;
        }

        public void SetColorA(float value)
        {
            if (color.a != value)
            {
                isDirty = true;
            }
            color.a = value;
        }

        private void SmoothMirrorTangent2()
        {
            tangent2 = position + (position - tangent);
            isDirty = true;
        }

        private void SmoothMirrorTangent()
        {
            tangent = position + (position - tangent2);
            isDirty = true;
        }

        private void SmoothFreeTangent2()
        {
            tangent2 = position + (position - tangent).normalized * (tangent2 - position).magnitude;
            isDirty = true;
        }

        private void SmoothFreeTangent()
        {
            tangent = position + (position - tangent2).normalized * (tangent - position).magnitude;
            isDirty = true;
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hash = 17;
                hash *= hash * 23 + _type.GetHashCode();
                hash = hash * 23 + position.GetHashCode();
                hash = hash * 23 + normal.GetHashCode();
                hash = hash * 23 + tangent.GetHashCode();
                hash = hash * 23 + tangent2.GetHashCode();
                hash = hash * 23 + color.GetHashCode();
                hash = hash * 23 + size.GetHashCode();
                return hash;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplinePoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplinePrefs.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7baa0d1cc3b5f744aa07790170949167
# ASMDEF: Dreamteck.Splines.dll
# ---
#if UNITY_EDITOR
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;

namespace Dreamteck.Splines
{
    public static class SplinePrefs
    {
        private static bool loaded = false;
        public static Spline.Direction duplicationDirection = Spline.Direction.Forward;
        public static bool defaultAlwaysDraw = false;
        public static SplineComputer.EditorUpdateMode defaultEditorUpdateMode = SplineComputer.EditorUpdateMode.Default;
        public static bool defaultShowThickness = false;
        public static bool default2D = false;
        public static bool startInCreationMode = false;
        public static SplineComputer.Space pointEditSpace = SplineComputer.Space.Local;
        public static Color defaultColor = Color.white;
        public static Color highlightColor = Color.white;
        public static Color outlineColor = Color.black;
        public static Color highlightContentColor = new Color(1f, 1f, 1f, 0.95f);
        public static bool showPointNumbers = false;
        public static SplineComputer.Space defaultComputerSpace = SplineComputer.Space.Local;
        public static Spline.Type defaultType = Spline.Type.CatmullRom;
        public static float createPointSize = 1f;
        public static Color createPointColor = Color.white;

        static SplinePrefs()
        {
            LoadPrefs();
        }

#if UNITY_2019_1_OR_NEWER
        [SettingsProvider]
        public static SettingsProvider SplinesSettingsProvider()
        {
            SettingsProvider provider = new SettingsProvider("Dreamteck/Splines", SettingsScope.User)
            {
                label = "Splines",
                guiHandler = (searchContext) =>
                {
                    OnGUI();
                },
                keywords = new HashSet<string>(new[] { "Dreamteck", "Splines", "Path", "Curve"})
            };

            return provider;
        }
#else
        [PreferenceItem("DTK Splines")]
#endif
        public static void OnGUI()
        {
            if (!loaded) LoadPrefs();
            EditorGUILayout.LabelField("Newly created splines:", EditorStyles.boldLabel);
            startInCreationMode = EditorGUILayout.Toggle("Start in Creation Mode", startInCreationMode);
            defaultComputerSpace = (SplineComputer.Space)EditorGUILayout.EnumPopup("Space", defaultComputerSpace);
            defaultType = (Spline.Type)EditorGUILayout.EnumPopup("Type", defaultType);
            defaultAlwaysDraw = EditorGUILayout.Toggle("Always draw", defaultAlwaysDraw);
            defaultEditorUpdateMode = (SplineComputer.EditorUpdateMode)EditorGUILayout.EnumPopup("Default Editor Update Mode", defaultEditorUpdateMode);
            defaultShowThickness = EditorGUILayout.Toggle("Show thickness", defaultShowThickness);
            default2D = EditorGUILayout.Toggle("2D Mode", default2D);
            defaultColor = EditorGUILayout.ColorField("Spline color", defaultColor);
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Newly created points:", EditorStyles.boldLabel);
            createPointSize = EditorGUILayout.FloatField("Default Size", createPointSize);
            createPointColor = EditorGUILayout.ColorField("Default Color", createPointColor);
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Editor", EditorStyles.boldLabel);
            outlineColor = EditorGUILayout.ColorField("Outline color", outlineColor);
            highlightColor = EditorGUILayout.ColorField("Highlight color", highlightColor);
            highlightContentColor = EditorGUILayout.ColorField("Highlight content color", highlightContentColor);
            duplicationDirection = (Spline.Direction)EditorGUILayout.EnumPopup("Duplicate Direction", duplicationDirection);
            showPointNumbers = EditorGUILayout.Toggle("Show point numbers", showPointNumbers);

            if (GUILayout.Button("Use Defaults", GUILayout.Width(120)))
            {
                duplicationDirection = Spline.Direction.Forward;
                defaultAlwaysDraw = false;
                defaultEditorUpdateMode = SplineComputer.EditorUpdateMode.Default;
                defaultShowThickness = false;
                default2D = false;
                startInCreationMode = true;
                defaultColor = Color.white;
                highlightColor = new Color(0.0313f, 0.737f, 0.796f, 1f);
                outlineColor = Color.Lerp(defaultColor, Color.black, 0.65f);
                highlightContentColor = new Color(1f, 1f, 1f, 0.95f);
                showPointNumbers = false;
                defaultComputerSpace = SplineComputer.Space.Local;
                defaultType = Spline.Type.CatmullRom;
                createPointSize = 1f;
                createPointColor = Color.white;
                SavePrefs();
            }
            if (GUI.changed) SavePrefs();
        }

        public static void LoadPrefs()
        {
            defaultAlwaysDraw = EditorPrefs.GetBool("Dreamteck.Splines.defaultAlwaysDraw", false);
            defaultEditorUpdateMode = (SplineComputer.EditorUpdateMode) EditorPrefs.GetInt("Dreamteck.Splines.defaultEditorUpdateMode", 0);
            defaultShowThickness = EditorPrefs.GetBool("Dreamteck.Splines.defaultShowThickness", false);
            default2D = EditorPrefs.GetBool("Dreamteck.Splines.default2D", false);
            startInCreationMode = EditorPrefs.GetBool("Dreamteck.Splines.startInCreationMode", true);
            showPointNumbers = EditorPrefs.GetBool("Dreamteck.Splines.showPointNumbers", false);
            pointEditSpace = (SplineComputer.Space)EditorPrefs.GetInt("Dreamteck.Splines.pointEditSpace", 1);
            defaultColor = LoadColor("Dreamteck.Splines.defaultColor", Color.white);
            highlightColor = LoadColor("Dreamteck.Splines.highlightColor", new Color(0f, 0.564f, 1f, 1f));
            outlineColor = LoadColor("Dreamteck.Splines.outlineColor", Color.Lerp(defaultColor, Color.black, 0.65f));
            highlightContentColor = LoadColor("Dreamteck.Splines.highlightContentColor", new Color(1f, 1f, 1f, 0.95f));
            defaultComputerSpace = (SplineComputer.Space)EditorPrefs.GetInt("Dreamteck.Splines.defaultComputerSpace", 1);
            defaultType = (Spline.Type)EditorPrefs.GetInt("Dreamteck.Splines.defaultType", 0);
            duplicationDirection = (Spline.Direction)EditorPrefs.GetInt("Dreamteck.Splines.duplicationDirection", 0);
            createPointSize = EditorPrefs.GetFloat("Dreamteck.Splines.createPointSize", 1f);
            createPointColor = LoadColor("Dreamteck.Splines.createPointColor", Color.white);
            loaded = true;
        }

        private static Color LoadColor(string name, Color defaultValue)
        {
            Color col = Color.white;
            string colorString = EditorPrefs.GetString(name, defaultValue.r+":"+defaultValue.g+ ":" + defaultValue.b+ ":" + defaultValue.a);
            string[] elements = colorString.Split(':');
            if (elements.Length < 4) return col;
            float r = 0f, g = 0f, b = 0f, a = 0f;
            float.TryParse(elements[0], out r);
            float.TryParse(elements[1], out g);
            float.TryParse(elements[2], out b);
            float.TryParse(elements[3], out a);
            col = new Color(r, g, b, a);
            return col;
        }

        public static void SavePrefs()
        {
            EditorPrefs.SetBool("Dreamteck.Splines.startInCreationMode", startInCreationMode);
            EditorPrefs.SetBool("Dreamteck.Splines.defaultAlwaysDraw", defaultAlwaysDraw);
            EditorPrefs.SetInt("Dreamteck.Splines.defaultEditorUpdateMode", (int)defaultEditorUpdateMode);
            EditorPrefs.SetBool("Dreamteck.Splines.defaultShowThickness", defaultShowThickness);
            EditorPrefs.SetBool("Dreamteck.Splines.default2D", default2D);
            EditorPrefs.SetBool("Dreamteck.Splines.showPointNumbers", showPointNumbers);
            EditorPrefs.SetInt("Dreamteck.Splines.pointEditSpace", (int)pointEditSpace);
            EditorPrefs.SetString("Dreamteck.Splines.defaultColor", defaultColor.r+ ":" + defaultColor.g+ ":" + defaultColor.b+ ":" + defaultColor.a);
            EditorPrefs.SetString("Dreamteck.Splines.highlightColor", highlightColor.r + ":" + highlightColor.g + ":" + highlightColor.b + ":" + highlightColor.a);
            EditorPrefs.SetString("Dreamteck.Splines.outlineColor", outlineColor.r + ":" + outlineColor.g + ":" + outlineColor.b + ":" + outlineColor.a);
            EditorPrefs.SetString("Dreamteck.Splines.highlightContentColor", highlightContentColor.r + ":" + highlightContentColor.g + ":" + highlightContentColor.b + ":" + highlightContentColor.a);
            EditorPrefs.SetInt("Dreamteck.Splines.defaultComputerSpace", (int)defaultComputerSpace);
            EditorPrefs.SetInt("Dreamteck.Splines.defaultType", (int)defaultType);
            EditorPrefs.SetInt("Dreamteck.Splines.duplicationDirection", (int)duplicationDirection);
            EditorPrefs.SetFloat("Dreamteck.Splines.createPointSize", createPointSize);
            EditorPrefs.SetString("Dreamteck.Splines.createPointColor", createPointColor.r + ":" + createPointColor.g + ":" + createPointColor.b + ":" + createPointColor.a);
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplinePrefs.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineSample.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4dd959ac300a1db4da9527c1e10ac8e2
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using Dreamteck;

namespace Dreamteck.Splines{
    [System.Serializable]
	public struct SplineSample {
        public Vector3 position;
        public Vector3 up;
        public Vector3 forward;
        public Color color;
        public float size;
        public double percent;

        public void FastCopy(ref SplineSample sample)
        {
            position = sample.position;
            up = sample.up;
            forward = sample.forward;
            color = sample.color;
            size = sample.size;
            percent = sample.percent;
        }
         

        public Quaternion rotation
        {
            get {
                if (up == forward)
                {
                    if (up == Vector3.up) return Quaternion.LookRotation(Vector3.up, Vector3.back);
                    else return Quaternion.LookRotation(forward, Vector3.up);
                }
                return Quaternion.LookRotation(forward, up); }
        }

        public Vector3 right
        {
            get {
                if(up == forward)
                {
                    if (up == Vector3.up) return Vector3.right;
                    else return Vector3.Cross(Vector3.up, forward).normalized;
                }
                return Vector3.Cross(up, forward).normalized; }
        }


        public static SplineSample Lerp(ref SplineSample a, ref SplineSample b, float t)
        {
            SplineSample result = new SplineSample();
            Lerp(ref a, ref b, t, ref result);
            return result;
        }

        public static SplineSample Lerp(ref SplineSample a, ref SplineSample b, double t)
        {
            SplineSample result = new SplineSample();
            Lerp(ref a, ref b, t, ref result);
            return result;
        }

        public static void Lerp(ref SplineSample a, ref SplineSample b, double t, ref SplineSample target)
        {
            float ft = (float)t;
            DMath.LerpVector3NonAlloc(a.position, b.position, t, ref target.position);
            target.forward = Vector3.Slerp(a.forward, b.forward, ft);
            target.up = Vector3.Slerp(a.up, b.up, ft);
            target.color = Color.Lerp(a.color, b.color, ft);
            target.size = Mathf.Lerp(a.size, b.size, ft);
            target.percent = DMath.Lerp(a.percent, b.percent, t);
        }

        public static void Lerp(ref SplineSample a, ref SplineSample b, float t, ref SplineSample target)
        {
            DMath.LerpVector3NonAlloc(a.position, b.position, t, ref target.position);
            target.forward = Vector3.Slerp(a.forward, b.forward, t);
            target.up = Vector3.Slerp(a.up, b.up, t);
            target.color = Color.Lerp(a.color, b.color, t);
            target.size = Mathf.Lerp(a.size, b.size, t);
            target.percent = DMath.Lerp(a.percent, b.percent, t);
        }

        public void Lerp(ref SplineSample b, double t)
        {
            Lerp(ref this, ref b, t, ref this);
        }

        public void Lerp(ref SplineSample b, float t)
        {
            Lerp(ref this, ref b, t, ref this);
        }
		
        public SplineSample(Vector3 position, Vector3 up, Vector3 forward, Color color, float size, double percent)
        {
            this.position = position;
            this.up = up;
            this.forward = forward;
            this.color = color;
            this.size = size;
            this.percent = percent;
        }
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineSample.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineThreading.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3accda9a749b24c459cb983529284d01
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEngine.SceneManagement;
#if !UNITY_WSA
    using System.Threading;
#endif

    public static class SplineThreading
    {
        public delegate void EmptyHandler();
        public static int threadCount
        {
            get {
#if UNITY_WSA
                return 0;
#else
                return threads.Length;
#endif
            }
            set
            {
#if !UNITY_WSA
                if(value > threads.Length)
                {
                    while (threads.Length < value)
                    {
                        ThreadDef thread = new ThreadDef();
#if UNITY_EDITOR
                        if (Application.isPlaying)
                        {
                            thread.Restart();
                        }
#else
                        thread.Restart();
#endif
                        ArrayUtility.Add(ref threads, thread);
                    }
                }
#endif
            }
        }
#if !UNITY_WSA
        internal class ThreadDef
        {
            internal class Worker
            {
                internal bool computing = false;
                internal Queue<EmptyHandler> instructions = new Queue<EmptyHandler>();
            }
            internal delegate void BoolHandler(bool flag);
            private ParameterizedThreadStart start = null;
            internal Thread thread = null;
            private Worker worker = new Worker();
            internal bool isAlive
            {
                get { return thread != null && thread.IsAlive; }
            }
            internal bool computing
            {
                get
                {
                    return worker.computing;
                }
            }

            internal ThreadDef()
            {
                start = new ParameterizedThreadStart(RunThread);
            }

            internal void Queue(EmptyHandler handler)
            {
                worker.instructions.Enqueue(handler);
            }

            internal void Interrupt()
            {
                thread.Interrupt();
            }

            internal void Restart()
            {
                thread = new Thread(start);
                thread.Start(worker);
            }

            internal void Abort()
            {
                if (isAlive)
                {
                    thread.Abort();
                }
            }
        }
        internal static ThreadDef[] threads = new ThreadDef[2];
        internal static readonly object locker = new object();
        static SplineThreading()
        {
            Application.quitting += Quitting;
            for (int i = 0; i < threads.Length; i++)
            {
                threads[i] = new ThreadDef();
            }

#if UNITY_EDITOR
            PrewarmThreads();
            UnityEditor.EditorApplication.playModeStateChanged += OnPlayStateChanged;
#endif
        }

#if UNITY_EDITOR
        static void OnPlayStateChanged(UnityEditor.PlayModeStateChange state)
        {
            if (state == UnityEditor.PlayModeStateChange.ExitingPlayMode)
            {
                Quitting();
            }
        }
#endif

        static void Quitting()
        {
            Stop();
        }

        static void RunThread(object o)
        {
            ThreadDef.Worker work = (ThreadDef.Worker)o;
            while (true)
            {
                try
                {
                    work.computing = false;
                    Thread.Sleep(Timeout.Infinite);
                }
                catch (ThreadInterruptedException)
                {
                    work.computing = true;
                    lock (locker)
                    {
                        while (work.instructions.Count > 0)
                        {
                            EmptyHandler h = work.instructions.Dequeue();
                            if (h != null) h();
                        }
                    }
                }
                catch (System.Exception ex)
                {
                    if(ex.Message != "") Debug.LogError("THREAD EXCEPTION " + ex.Message);
                    break;
                }
            }
            Debug.Log("Thread stopped");
            work.computing = false;
        }
#endif

            public static void Run(EmptyHandler handler)
        {
#if !UNITY_WSA
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                handler();
                return;
            }
#endif
            for (int i = 0; i < threads.Length; i++)
            {
                if (!threads[i].isAlive) threads[i].Restart();
                if (!threads[i].computing || i == threads.Length - 1)
                {
                    threads[i].Queue(handler);
                    if(!threads[i].computing)threads[i].Interrupt();
                    break;
                }
            }
#endif
        }

        public static void PrewarmThreads()
        {
#if !UNITY_WSA
            for (int i = 0; i < threads.Length; i++)
            {
                if (!threads[i].isAlive)
                {
                    threads[i].Restart();
                }
            }
#endif
        }

        public static void Stop()
        {
#if !UNITY_WSA
            for (int i = 0; i < threads.Length; i++)
            {
                threads[i].Abort();
            }
#endif
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineThreading.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineTrigger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 49af47eda040af44b8003635251e89cc
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEngine.Events;

    [System.Serializable]
    public class TriggerGroup{
#if UNITY_EDITOR
        public bool open = false;
#endif

        public bool enabled = true;
        public string name = "";
        public Color color = Color.white;
        public SplineTrigger[] triggers = new SplineTrigger[0];

        public void Check(double start, double end, SplineUser user = null)
        {
            for (int i = 0; i < triggers.Length; i++)
            {
                if (triggers[i] == null)
                {
                    continue;
                }

                if (triggers[i].Check(start, end))
                {
                    triggers[i].Invoke(user);
                }
            }
        }

        public void Reset()
        {
            for (int i = 0; i < triggers.Length; i++) triggers[i].Reset();
        }

        /// <summary>
        /// Returns all triggers within the specified range
        /// </summary>
        public List<SplineTrigger> GetTriggers(double from, double to)
        {
            List<SplineTrigger> triggerList = new List<SplineTrigger>();
            for (int i = 0; i < triggers.Length; i++)
            {
                if (triggers[i] == null)
                {
                    continue;
                }
                if(triggers[i].position >= from  && triggers[i].position <= to)
                {
                    triggerList.Add(triggers[i]);
                }
            }
            return triggerList;
        }

        /// <summary>
        /// Creates a new trigger inside the group
        /// </summary>
        public SplineTrigger AddTrigger(double position, SplineTrigger.Type type)
        {
            return AddTrigger(position, type, "Trigger " + (triggers.Length + 1), Color.white);
        }

        /// <summary>
        /// Creates a new trigger inside the group
        /// </summary>
        public SplineTrigger AddTrigger(double position, SplineTrigger.Type type, string name, Color color)
        {
            SplineTrigger newTrigger = new SplineTrigger(type);
            newTrigger.position = position;
            newTrigger.color = color;
            newTrigger.name = name;
            ArrayUtility.Add(ref triggers, newTrigger);
            return newTrigger;
        }

        /// <summary>
        /// Removes the trigger at the given index from the group
        /// </summary>
        public void RemoveTrigger(int index)
        {
            ArrayUtility.RemoveAt(ref triggers, index);
        }
    }

    [System.Serializable]
    public class SplineTrigger
    {
        public string name = "Trigger";
        public enum Type { Double, Forward, Backward}
        [SerializeField]
        public Type type = Type.Double;
        public bool workOnce = false;
        private bool worked = false;
        [Range(0f, 1f)]
        public double position = 0.5;
        [SerializeField]
        public bool enabled = true;
        [SerializeField]
        public Color color = Color.white;
        [SerializeField]
        [HideInInspector]
        public TriggerEvent onCross = new TriggerEvent();

        public SplineTrigger(Type t)
        {
            type = t;
            enabled = true;
            onCross = new TriggerEvent();
        }

        /// <summary>
        /// Add a new UnityAction to the trigger
        /// </summary>
        /// <param name="action"></param>
        public void AddListener(UnityAction<SplineUser> action)
        {
            onCross.AddListener(action);
        }

        public void AddListener(UnityAction action)
        {
            UnityAction<SplineUser> addAction = new UnityAction<SplineUser>((user) => { action.Invoke(); });
            onCross.AddListener(addAction);
        }

        public void RemoveListener(UnityAction<SplineUser> action)
        {
            onCross.RemoveListener(action);
        }

        public void RemoveAllListeners()
        {
            onCross.RemoveAllListeners();
        }

        public void Reset()
        {
            worked = false;
        }

        public bool Check(double previousPercent, double currentPercent)
        {
            if (!enabled) return false;
            if (workOnce && worked) return false;
            bool passed = false;
            switch (type)
            {
                case Type.Double: passed = (previousPercent <= position && currentPercent >= position) || (currentPercent <= position && previousPercent >= position); break;
                case Type.Forward: passed = previousPercent <= position && currentPercent >= position; break;
                case Type.Backward: passed = currentPercent <= position && previousPercent >= position; break;
            }
            if (passed) worked = true;
            return passed;
        }

        public void Invoke(SplineUser user = null)
        {
#if UNITY_EDITOR
            if (!Application.isPlaying) return;
#endif
            onCross.Invoke(user);
        }

        [System.Serializable]
        public class TriggerEvent : UnityEvent<SplineUser>
        { 
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineTrigger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 74914877e76bc924eaa2e97157f84f95
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public static class SplineUtility
    {
        public enum MergeSide { Start, End }

        /// <summary>
        /// Merges two spline objects into one. The result will be merged into <paramref name="baseSpline"/>
        /// </summary>
        /// <param name="baseSpline">The base spline object that</param>
        /// <param name="addedSpline">The object that will be merged into the base spline</param>
        /// <param name="side">Which side of the base spline to append to - beginning or end?</param>
        /// <param name="mergeEndpoints">Should the end points of the splines be merged or should they be bridged?</param>
        /// <param name="destroyAddedSpline">If true, the added spline's game object will be destroyed after merge</param>
        public static void Merge(SplineComputer baseSpline, SplineComputer addedSpline, MergeSide side, bool mergeEndpoints = false, bool destroyAddedSpline = false)
        {
            SplinePoint[] mergedPoints = addedSpline.GetPoints();
            SplinePoint[] basePoints = baseSpline.GetPoints();
            List<SplinePoint> pointsList = new List<SplinePoint>();
            SplinePoint[] points;
            if (!mergeEndpoints) points = new SplinePoint[mergedPoints.Length + basePoints.Length];
            else points = new SplinePoint[mergedPoints.Length + basePoints.Length - 1];

            if (side == MergeSide.End)
            {
                if (side == MergeSide.Start)
                {
                    for (int i = 0; i < basePoints.Length; i++) pointsList.Add(basePoints[i]);
                    for (int i = mergeEndpoints ? 1 : 0; i < mergedPoints.Length; i++) pointsList.Add(mergedPoints[i]);
                }
                else
                {
                    for (int i = 0; i < basePoints.Length; i++) pointsList.Add(basePoints[i]);
                    for (int i = 0; i < mergedPoints.Length - (mergeEndpoints ? 1 : 0); i++) pointsList.Add(mergedPoints[(mergedPoints.Length - 1) - i]);
                }
            }
            else
            {
                if (side == MergeSide.Start)
                {
                    for (int i = 0; i < mergedPoints.Length - (mergeEndpoints ? 1 : 0); i++) pointsList.Add(mergedPoints[(mergedPoints.Length - 1) - i]);
                    for (int i = 0; i < basePoints.Length; i++) pointsList.Add(basePoints[i]);
                }
                else
                {
                    for (int i = mergeEndpoints ? 1 : 0; i < mergedPoints.Length; i++) pointsList.Add(mergedPoints[i]);
                    for (int i = 0; i < basePoints.Length; i++) pointsList.Add(basePoints[i]);
                }
            }
            points = pointsList.ToArray();
            double mergedPercent = (double)(mergedPoints.Length - 1) / (points.Length - 1);
            double from = 0.0;
            double to = 1.0;
            if (side == MergeSide.End)
            {
                from = 1.0 - mergedPercent;
                to = 1.0;
            }
            else
            {
                from = 0.0;
                to = mergedPercent;
            }


            List<Node> mergedNodes = new List<Node>();
            List<int> mergedIndices = new List<int>();

            for (int i = 0; i < addedSpline.pointCount; i++)
            {
                Node node = addedSpline.GetNode(i);
                if (node != null)
                {
                    mergedNodes.Add(node);
                    mergedIndices.Add(i);
                    addedSpline.DisconnectNode(i);
                    i--;
                }
            }

            SplineUser[] subs = addedSpline.GetSubscribers();
            for (int i = 0; i < subs.Length; i++)
            {
                addedSpline.Unsubscribe(subs[i]);
                subs[i].spline = baseSpline;
                subs[i].clipFrom = DMath.Lerp(from, to, subs[i].clipFrom);
                subs[i].clipTo = DMath.Lerp(from, to, subs[i].clipTo);
            }
            baseSpline.SetPoints(points);

            if (side == MergeSide.Start)
            {
                baseSpline.ShiftNodes(0, baseSpline.pointCount - 1, addedSpline.pointCount);
                for (int i = 0; i < mergedNodes.Count; i++)
                {
                    baseSpline.ConnectNode(mergedNodes[i], mergedIndices[i]);
                }
            }
            else
            {
                for (int i = 0; i < mergedNodes.Count; i++)
                {
                    int connectIndex = mergedIndices[i] + basePoints.Length;
                    if (mergeEndpoints) connectIndex--;
                    baseSpline.ConnectNode(mergedNodes[i], connectIndex);
                }
            }
            if (destroyAddedSpline)
            {
                Object.Destroy(addedSpline.gameObject);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/TransformModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b4d0258b139ab2142a6d1ba90331008a
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

namespace Dreamteck.Splines
{

    [System.Serializable]
    public class TransformModule : ISerializationCallbackReceiver
    {
        public Vector2 offset
        {
            get { return _offset; }
            set
            {
                if (value != _offset)
                {
                    _offset = value;
                    _hasOffset = _offset != Vector2.zero;
                    if (targetUser != null)
                    {
                        targetUser.Rebuild();
                    }
                }
            }
        }
        public Vector3 rotationOffset
        {
            get { return _rotationOffset; }
            set
            {
                if (value != _rotationOffset)
                {
                    _rotationOffset = value;
                    _hasRotationOffset = _rotationOffset != Vector3.zero;
                    if (targetUser != null)
                    {
                        targetUser.Rebuild();
                    }
                }
            }
        }

        public bool hasOffset
        {
            get { return _hasOffset; }
        }

        public bool hasRotationOffset
        {
            get { return _hasRotationOffset; }
        }

        public Vector3 baseScale
        {
            get { return _baseScale; }
            set
            {
                if (value != _baseScale)
                {
                    _baseScale = value;
                    if (targetUser != null)
                    {
                        targetUser.Rebuild();
                    }
                }
            }
        }

        public bool is2D
        {
            get { return _2dMode; }
            set
            {
                _2dMode = value;
            }
        }

        [SerializeField]
        [HideInInspector]
        private bool _hasOffset = false;
        [SerializeField]
        [HideInInspector]
        private bool _hasRotationOffset = false;

        [SerializeField]
        [HideInInspector]
        private Vector2 _offset;
        [SerializeField]
        [HideInInspector]
        private Vector3 _rotationOffset = Vector3.zero;
        [SerializeField]
        [HideInInspector]
        private Vector3 _baseScale = Vector3.one;
        [SerializeField]
        [HideInInspector]
        private bool _2dMode = false;
        public enum VelocityHandleMode { Zero, Preserve, Align, AlignRealistic }
        public VelocityHandleMode velocityHandleMode = VelocityHandleMode.Zero;
        public SplineSample splineResult
        {
            get
            {
                return _splineResult;
            }
            set
            {
                _splineResult = value;
            }
        }
        private SplineSample _splineResult;

        public bool applyPositionX = true;
        public bool applyPositionY = true;
        public bool applyPositionZ = true;
        public bool applyPosition2D = true;
        public bool retainLocalPosition = false;

        public Spline.Direction direction = Spline.Direction.Forward;
        public bool applyPosition
        {
            get
            {
                if (_2dMode)
                {
                    return applyPosition2D;
                }
                return applyPositionX || applyPositionY || applyPositionZ;
            }
            set
            {
                applyPositionX = applyPositionY = applyPositionZ = applyPosition2D = value;
            }
        }

        public bool applyRotationX = true;
        public bool applyRotationY = true;
        public bool applyRotationZ = true;
        public bool applyRotation2D = true;
        public bool retainLocalRotation = false;
        public bool applyRotation
        {
            get
            {
                if (_2dMode)
                {
                    return applyRotation2D;
                }
                return applyRotationX || applyRotationY || applyRotationZ;
            }
            set
            {
                applyRotationX = applyRotationY = applyRotationZ = applyRotation2D = value;
            }
        }

        public bool applyScaleX = false;
        public bool applyScaleY = false;
        public bool applyScaleZ = false;
        public bool applyScale
        {
            get
            {
                return applyScaleX || applyScaleY || applyScaleZ;
            }
            set
            {
                applyScaleX = applyScaleY = applyScaleZ = value;
            }
        }
        [HideInInspector]
        public SplineUser targetUser = null;

        //These are used to save allocations
        private static Vector3 position = Vector3.zero;
        private static Quaternion rotation = Quaternion.identity;

        public void ApplyTransform(Transform input)
        {
            input.position = GetPosition(input.position);
            input.rotation = GetRotation(input.rotation);
            input.localScale = GetScale(input.localScale);
        }

        public void ApplyRigidbody(Rigidbody input)
        {
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                ApplyTransform(input.transform);
                return;
            }
#endif
            input.transform.localScale = GetScale(input.transform.localScale);
            input.MovePosition(GetPosition(input.position));
            if (!input.isKinematic)
            {
#if UNITY_6000_0_OR_NEWER
                input.linearVelocity = HandleVelocity(input.linearVelocity);
#else
                input.velocity = HandleVelocity(input.velocity);
#endif
            }
            input.MoveRotation(GetRotation(input.rotation));
            Vector3 angularVelocity = input.angularVelocity;
            if (applyRotationX)
            {
                angularVelocity.x = 0f;
            }
            if (applyRotationY)
            {
                angularVelocity.y = 0f;
            }
            if (applyRotationZ || applyRotation2D)
            {
                angularVelocity.z = 0f;
            }
            input.angularVelocity = angularVelocity;
        }

        public void ApplyRigidbody2D(Rigidbody2D input)
        {
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                ApplyTransform(input.transform);
                input.transform.rotation = Quaternion.AngleAxis(GetRotation(Quaternion.Euler(0f, 0f, input.rotation)).eulerAngles.z, Vector3.forward);
                return;
            }
#endif
            input.transform.localScale = GetScale(input.transform.localScale);
            input.position = GetPosition(input.position);
            if (!input.isKinematic)
            {
#if UNITY_6000_OR_NEWER
            input.linearVelocity = HandleVelocity(input.linearVelocity);
#else
                input.linearVelocity = HandleVelocity(input.linearVelocity);
#endif
            }
            input.rotation = GetRotation(Quaternion.Euler(0f, 0f, input.rotation)).eulerAngles.z;
            if (applyRotationX)
            {
                input.angularVelocity = 0f;
            }
        }

        Vector3 HandleVelocity(Vector3 velocity)
        {
            Vector3 idealVelocity = Vector3.zero;
            Vector3 direction = Vector3.right;
            switch (velocityHandleMode)
            {
                case VelocityHandleMode.Preserve: idealVelocity = velocity; break;
                case VelocityHandleMode.Align:
                    direction = _splineResult.forward;
                    if (Vector3.Dot(velocity, direction) < 0f) direction *= -1f;
                    idealVelocity = direction * velocity.magnitude; break;
                case VelocityHandleMode.AlignRealistic:
                    direction = _splineResult.forward;
                    if (Vector3.Dot(velocity, direction) < 0f) direction *= -1f;
                    idealVelocity = direction * velocity.magnitude * Vector3.Dot(velocity.normalized, direction); break;
            }
            if (applyPositionX) velocity.x = idealVelocity.x;
            if (applyPositionY) velocity.y = idealVelocity.y;
            if (applyPositionZ) velocity.z = idealVelocity.z;
            return velocity;
        }

        private Vector3 GetPosition(Vector3 inputPosition)
        {
            position = _splineResult.position;
            Vector2 finalOffset = _offset;
            if (finalOffset != Vector2.zero)
            {
                position += _splineResult.right * finalOffset.x * _splineResult.size + _splineResult.up * finalOffset.y * _splineResult.size;
            }
            if (retainLocalPosition)
            {
                Matrix4x4 matrix = Matrix4x4.TRS(position, _splineResult.rotation, Vector3.one);
                Vector3 splineLocalPosition = matrix.inverse.MultiplyPoint3x4(targetUser.transform.position);
                splineLocalPosition.x = applyPositionX ? 0f : splineLocalPosition.x;
                splineLocalPosition.y = applyPositionY ? 0f : splineLocalPosition.y;
                splineLocalPosition.z = applyPositionZ ? 0f : splineLocalPosition.z;
                inputPosition = matrix.MultiplyPoint3x4(splineLocalPosition);
            } else
            {
                if (applyPositionX) inputPosition.x = position.x;
                if (applyPositionY) inputPosition.y = position.y;
                if (applyPositionZ) inputPosition.z = position.z;
            }
            return inputPosition;
        }

        private Quaternion GetRotation(Quaternion inputRotation)
        {
            rotation = Quaternion.LookRotation(_splineResult.forward * (direction == Spline.Direction.Forward ? 1f : -1f), _splineResult.up);
            if (_2dMode)
            {
                if (applyRotation2D)
                {
                    rotation *= Quaternion.Euler(90, -90, 0);
                    inputRotation = Quaternion.AngleAxis(rotation.eulerAngles.z + _rotationOffset.z, Vector3.forward);
                }
                return inputRotation;
            }
            else
            {
                if (_rotationOffset != Vector3.zero)
                {
                    rotation = rotation * Quaternion.Euler(_rotationOffset);
                }
            }

            if (retainLocalRotation)
            {
                Quaternion localRotation = Quaternion.Inverse(rotation) * inputRotation;
                Vector3 targetEuler = localRotation.eulerAngles;
                targetEuler.x = applyRotationX ? 0f : targetEuler.x;
                targetEuler.y = applyRotationY ? 0f : targetEuler.y;
                targetEuler.z = applyRotationZ ? 0f : targetEuler.z;
                inputRotation = rotation * Quaternion.Euler(targetEuler);
            } else
            {
                if (!applyRotationX || !applyRotationY || !applyRotationZ)
                {
                    Vector3 targetEuler = rotation.eulerAngles;
                    Vector3 sourceEuler = inputRotation.eulerAngles;
                    if (!applyRotationX) targetEuler.x = sourceEuler.x;
                    if (!applyRotationY) targetEuler.y = sourceEuler.y;
                    if (!applyRotationZ) targetEuler.z = sourceEuler.z;
                    inputRotation.eulerAngles = targetEuler;
                }
                else 
                {
                    inputRotation = rotation;
                }
            }

            return inputRotation;
        }

        private Vector3 GetScale(Vector3 inputScale)
        {
            if (applyScaleX) inputScale.x = _baseScale.x * _splineResult.size;
            if (applyScaleY) inputScale.y = _baseScale.y * _splineResult.size;
            if (applyScaleZ) inputScale.z = _baseScale.z * _splineResult.size;
            return inputScale;
        }

        public void OnBeforeSerialize()
        {
            
        }

        public void OnAfterDeserialize()
        {
            _hasRotationOffset = _rotationOffset != Vector3.zero;
            _hasOffset = _offset != Vector2.zero;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/TransformModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/AudioVisualization/SpectrumVisualizer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a96d0f6951e54f54aa61fa5b357652d0
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;


namespace Dreamteck.Splines.Examples
{
    public class SpectrumVisualizer : MonoBehaviour
    {
        public int samples = 1024;
        [Tooltip("The starting percent of the spectrum. 0 is 20Hz and 1 is 20KHz")]
        [Range(0f, 1f)]
        public float minSpectrumRange = 0f;
        [Tooltip("The ending percent of the spectrum. 0 is 20Hz and 1 is 20KHz")]
        [Range(0f, 1f)]
        public float maxSpectrumRange = 1f;
        public float increaseSpeed = 50f;
        public float decreaseSpeed = 10f;
        public float maxOffset = 10f;
        public AudioSource source;
        private SplineComputer computer;
        private Vector3[] positions;
        public AnimationCurve spectrumMultiply; //lower frequencies have bigger values, this is used to even the values
        private float[] spectrumLerp;


        
        // Use this for initialization
        void Start()
        {
            if(source == null) source = GetComponent<AudioSource>();
            computer = GetComponent<SplineComputer>();
            SplinePoint[] points = computer.GetPoints();
            positions = new Vector3[points.Length];
            for (int i = 0; i < points.Length; i++)
            {
                positions[i] = points[i].position;
            }
            spectrumLerp = new float[points.Length];
        }

        // Update is called once per frame
        void Update()
        {
            float[] left = new float[samples];
            float[] right = new float[samples];
            source.GetSpectrumData(left, 0, FFTWindow.Hanning);
            source.GetSpectrumData(right, 1, FFTWindow.Hanning);
            float[] spectrum = new float[left.Length];
            for (int i = 0; i < spectrum.Length; i++)
            {
                spectrum[i] = (left[i] + right[i])/2f;
            }
            SplinePoint[] points = computer.GetPoints();
            int samplesPerPoint = Mathf.FloorToInt((spectrum.Length / points.Length) * (maxSpectrumRange-minSpectrumRange));
            int spectrumIndexStart = Mathf.FloorToInt((spectrum.Length - 1) * minSpectrumRange);
            for (int i = 0; i < points.Length; i++)
            {
                float avg = 0f;
                for (int n = 0; n < samplesPerPoint ; n++) avg += spectrum[spectrumIndexStart + samplesPerPoint * i + n];
                avg /= samplesPerPoint;
                if (avg > spectrumLerp[i]) spectrumLerp[i] = Mathf.Lerp(spectrumLerp[i], avg, Time.deltaTime * increaseSpeed);
                else spectrumLerp[i] = Mathf.Lerp(spectrumLerp[i], avg, Time.deltaTime * decreaseSpeed);
               
                float percent = (float)i / (points.Length - 1);
                points[i].position = positions[i] + Vector3.up * maxOffset * spectrumLerp[i] * spectrumMultiply.Evaluate(percent);
            }
            computer.SetPoints(points);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/AudioVisualization/SpectrumVisualizer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Following/Scripts/CameraSmoothRotation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1db240e16ae54c34796776d2116027a0
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines.Examples
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class CameraSmoothRotation : MonoBehaviour
    {
        //Simple script to smooth out the rotation of the camera
        //Since getting the rotation directly from the spline might not look good 
        //When looking from first person perspective
        public float damp = 0f;
        SplineFollower follower;
        Transform trs;

        void Start()
        {
            trs = transform;
            follower = GetComponent<SplineFollower>();
        }

        void Update()
        {
            if(damp <= 0f)
            {
                //if no damp is used, then make the follower apply the rotation automatically
                follower.motion.applyRotation = true;
                return;
            }
            //if damp > 0 then handle rotation manually here
            follower.motion.applyRotation = false;
            trs.rotation = Quaternion.Slerp(trs.rotation, follower.result.rotation, Time.deltaTime / damp);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Following/Scripts/CameraSmoothRotation.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Following/Scripts/URLButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5ec15fe9037467446879410642c099da
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class URLButton : MonoBehaviour
{
    public string url = "";

    public void Click()
    {
        Application.OpenURL(url);
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Following/Scripts/URLButton.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/JunctionSwitch.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 785b8ec86cde0874bac4115ccaf2ad20
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines.Examples
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class JunctionSwitch : MonoBehaviour
    {
        [System.Serializable]
        public class Bridge
        {
            public enum Direction { Forward = 1, Backward = -1, None = 0 }
            public bool active = true;
            public int a;
            public Direction aDirection = Direction.None;
            public int b;
            public Direction bDirection = Direction.None;
        }

        public Bridge[] bridges;

        private void OnValidate()
        {
            Node node = GetComponent<Node>();
            Node.Connection[] connections = node.GetConnections();
            if (bridges == null) return;
            for (int i = 0; i < bridges.Length; i++)
            {
                if (bridges[i].a < 0) bridges[i].a = 0;
                if (bridges[i].b < 0) bridges[i].b = 0;
                if (bridges[i].a >= connections.Length) bridges[i].a = connections.Length - 1;
                if (bridges[i].b >= connections.Length) bridges[i].b = connections.Length - 1;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/JunctionSwitch.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/TrainCamera.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6e4c289b236b9d94891dcdf70b12b513
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TrainCamera : MonoBehaviour
{
    public Transform target;
    public Vector3 offset;
    public float speed = 1f;
    Transform trs;

    private void Awake()
    {
        trs = transform;
    }

    void LateUpdate()
    {
        Vector3 targetPos = target.position + target.right * offset.x + target.up * offset.y + target.forward * offset.z;
        Quaternion rotation = Quaternion.LookRotation(targetPos - trs.position);
        trs.rotation = Quaternion.Slerp(trs.rotation, rotation, Time.deltaTime * speed);
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/TrainCamera.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/TrainEngine.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0ba50a673a77e124fa87e009ea3055d6
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines.Examples
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using Dreamteck.Splines;
    using System;

    public class TrainEngine : MonoBehaviour
    {
        private SplineTracer _tracer = null;
        private double _lastPercent = 0.0;
        private Wagon _wagon;

        private void Awake()
        {
            _wagon = GetComponent<Wagon>();
        }

        void Start()
        {
            _tracer = GetComponent<SplineTracer>();
            //Subscribe to the onNode event to receive junction information automatically when a Node is passed
            _tracer.onNode += OnJunction;
            //Subscribe to the onMotionApplied event so that we can immediately update the wagons' positions once the engine's position is set
            _tracer.onMotionApplied += OnMotionApplied;

            //If the tracer is a SplineFollower (which should be the the case), subscribe to onEndReached and onOnBeginningReached
            if (_tracer is SplineFollower)
            {
                SplineFollower follower = (SplineFollower)_tracer;
                Debug.Log("Subscribing to follower");
                follower.onBeginningReached += FollowerOnBeginningReached;
                follower.onEndReached += FollowerOnEndReached;
            }
        }

        private void OnMotionApplied()
        {
            //Apply the wagon's offset (this will recursively apply the offsets to the rest of the wagons in the chain)
            _lastPercent = _tracer.result.percent;
            _wagon.UpdateOffset();
        }

        /// <summary>
        /// Gets the last follower percent before reaching the beginning and looping / ping-ponging
        /// </summary>
        private void FollowerOnBeginningReached(double lastPercent)
        {
            _lastPercent = lastPercent;
        }

        /// <summary>
        /// Gets the last follower percent before reaching the end and looping / ping-ponging
        /// </summary>
        private void FollowerOnEndReached(double lastPercent)
        {
            _lastPercent = lastPercent;
        }

        //Called when the tracer has passed a junction (a Node)
        private void OnJunction(List<SplineTracer.NodeConnection> passed)
        {
            Node node = passed[0].node; //Get the node of the junction
            JunctionSwitch junctionSwitch = node.GetComponent<JunctionSwitch>(); //Look for a JunctionSwitch component
            if (junctionSwitch == null) return; //No JunctionSwitch - ignore it - this isn't a real junction
            if (junctionSwitch.bridges.Length == 0) return; //The JunctionSwitch does not have bridge elements
            foreach (JunctionSwitch.Bridge bridge in junctionSwitch.bridges)
            {
                //Look for a suitable bridge element based on the spline we are currently traversing
                if (!bridge.active) continue;
                if (bridge.a == bridge.b) continue; //Skip bridge if it points to the same spline  
                int currentConnection = 0;
                Node.Connection[] connections = node.GetConnections();
                //get the connected splines and find the index of the tracer's current spline
                for (int i = 0; i < connections.Length; i++)
                {
                    if (connections[i].spline == _tracer.spline)
                    {
                        currentConnection = i;
                        break;
                    }
                }
                //Skip the bridge if we are not on one of the splines that the switch connects
                if (currentConnection != bridge.a && currentConnection != bridge.b) continue;
                if (currentConnection == bridge.a)
                {
                    if ((int)_tracer.direction != (int)bridge.bDirection) continue;
                    //This bridge is suitable and should use it
                    SwitchSpline(connections[bridge.a], connections[bridge.b]);
                    return;
                }
                else
                {
                    if ((int)_tracer.direction != (int)bridge.aDirection) continue;
                    //This bridge is suitable and should use it
                    SwitchSpline(connections[bridge.b], connections[bridge.a]);
                    return;
                }
            }
        }

        void SwitchSpline(Node.Connection from, Node.Connection to)
        {
            //See how much units we have travelled past that Node in the last frame
           
            float excessDistance = from.spline.CalculateLength(from.spline.GetPointPercent(from.pointIndex), _tracer.UnclipPercent(_lastPercent));
            //Set the spline to the tracer
            _tracer.spline = to.spline;
            _tracer.RebuildImmediate();
            //Get the location of the junction point in percent along the new spline
            double startpercent = _tracer.ClipPercent(to.spline.GetPointPercent(to.pointIndex));
            if (Vector3.Dot(from.spline.Evaluate(from.pointIndex).forward, to.spline.Evaluate(to.pointIndex).forward) < 0f)
            {
                if (_tracer.direction == Spline.Direction.Forward) _tracer.direction = Spline.Direction.Backward;
                else _tracer.direction = Spline.Direction.Forward;
            }
            //Position the tracer at the new location and travel excessDistance along the new spline
            _tracer.SetPercent(_tracer.Travel(startpercent, excessDistance, _tracer.direction));
            //Notify the wagon that we have entered a new spline segment
            _wagon.EnterSplineSegment(from.pointIndex, _tracer.spline, to.pointIndex, _tracer.direction);
            _wagon.UpdateOffset();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/TrainEngine.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/Wagon.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2c5b28aa5a478e44297c3dd32a5c35f1
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines.Examples
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class Wagon : MonoBehaviour
    {
        //A helper class which contains an information for a spline and the points 
        //between which the spline is traversed (start and end)
        //If one of the points is equal to -1 it means that there is no constraint
        public class SplineSegment
        {
            public SplineComputer spline;
            public int start = -1, end = -1;
            public Spline.Direction direction;

            public SplineSegment(SplineComputer spline, int entryPoint, Spline.Direction direction)
            {
                this.spline = spline;
                start = entryPoint;
                this.direction = direction;
            }

            public SplineSegment(SplineSegment input)
            {
                spline = input.spline;
                start = input.start;
                end = input.end;
                direction = input.direction;
            }

            public double Travel(double percent, float distance, Spline.Direction direction, out float moved, bool loop)
            {
                double max = direction == Spline.Direction.Forward ? 1.0 : 0.0;
                if (start >= 0) max = spline.GetPointPercent(start);
                return TravelClamped(percent, distance, direction, max, out moved, loop);
            }

            //Travel the spline segment by automatically starting at the segment's exit (end)
            public double Travel(float distance, Spline.Direction direction, out float moved, bool loop)
            {
                double startPercent = spline.GetPointPercent(end);
                double max = direction == Spline.Direction.Forward ? 1.0 : 0.0;
                if (start >= 0) max = spline.GetPointPercent(start);
                return TravelClamped(startPercent, distance, direction, max, out moved, loop);
            }

            //Travel the spline segment while not exceeding the "max" percent
            //It also supports looping splines unlike the standard Travel methods found in SplineComputer and SplineUser
            double TravelClamped(double percent, float distance, Spline.Direction direction, double max, out float moved, bool loop)
            {
                moved = 0f;
                float traveled = 0f;
                double result = spline.Travel(percent, distance, out traveled, direction);
                moved += traveled;
                if (loop && moved < distance) {
                    if (direction == Spline.Direction.Forward && Mathf.Approximately((float)result, 1f))
                    {
                        result = spline.Travel(0.0, distance - moved, out traveled, direction);
                    } else if (direction == Spline.Direction.Backward && Mathf.Approximately((float)result, 0f))
                    {
                        result = spline.Travel(1.0, distance - moved, out traveled, direction);
                    }
                    moved += traveled;
                }
                if (direction == Spline.Direction.Forward && percent <= max)
                {
                    if (result > max)
                    {
                        moved -= spline.CalculateLength(result, max);
                        result = max;
                    }
                }
                else if (direction == Spline.Direction.Backward && percent >= max)
                {
                    if (result < max)
                    {
                        moved -= spline.CalculateLength(max, result);
                        result = max;
                    }
                }
                return result;
            }
        }

        SplineTracer tracer;
        public bool isEngine = false;
        public Wagon back;
        public float offset = 0f;
        Wagon front;
        SplineSegment segment, tempSegment;

        private void Awake()
        {
            tracer = GetComponent<SplineTracer>();
            //Wagon compoenent that is attached to the train engine and is marked as "isEngine" will
            //run a recursive setup for the rest of the wagons
            if (isEngine) SetupRecursively(null, new SplineSegment(tracer.spline, -1, tracer.direction));
        }

        void SetupRecursively(Wagon frontWagon, SplineSegment inputSegment)
        {
            front = frontWagon;
            segment = inputSegment;
            if (back != null) back.SetupRecursively(this, segment);
        }

        public void UpdateOffset()
        {
            ApplyOffset();
            if (back != null) back.UpdateOffset();
        }

        Wagon GetRootWagon()
        {
            Wagon current = this;
            while (current.front != null) current = current.front;
            return current;
        }

        void ApplyOffset()
        {
            if (isEngine)
            {
                ResetSegments();
                return;
            }
            float totalMoved = 0f, moved = 0f;
            double start = front.tracer.UnclipPercent(front.tracer.result.percent);
            //Travel backwards along the front wagon's spline
            Spline.Direction inverseDirection = front.segment.direction;
            InvertDirection(ref inverseDirection);
            SplineComputer spline = front.segment.spline;
            double percent = front.segment.Travel(start, offset, inverseDirection, out moved, front.segment.spline.isClosed);
            totalMoved += moved;
            //Finalize if moved fully without reaching a spline end or a junction
            if (Mathf.Approximately(totalMoved, offset))
            {
                if (segment != front.segment)
                {
                    if (back != null) back.segment = segment;
                }
                if(segment != front.segment) segment = front.segment;
                ApplyTracer(spline, percent, front.tracer.direction);
                return;
            }

            //Otherwise, move along the current recorded spline segment
            if (segment != front.segment)
            {
                inverseDirection = segment.direction;
                InvertDirection(ref inverseDirection);
                spline = segment.spline;
                percent = segment.Travel(offset - totalMoved, inverseDirection, out moved, segment.spline.isClosed);
                totalMoved += moved;
            }
            ApplyTracer(spline, percent, segment.direction);
        }

        void ResetSegments()
        {
            Wagon current = back;
            bool same = true;
            while (current != null)
            {
                if(current.segment != segment)
                {
                    same = false;
                    break;
                }
                current = current.back;
            }
            //if all wagons are on the same segment, remove the segment entrance so that they can loop
            if(same) segment.start = -1; 
        }

        void ApplyTracer(SplineComputer spline, double percent, Spline.Direction direction)
        {
            bool rebuild = tracer.spline != spline;
            tracer.spline = spline;
            if (rebuild) tracer.RebuildImmediate();
            tracer.direction = direction;
            tracer.SetPercent(tracer.ClipPercent(percent));
        }

        public void EnterSplineSegment(int previousSplineExitPoint, SplineComputer spline, int entryPoint, Spline.Direction direction)
        {
            if (!isEngine) return;
            if (back != null)
            {
                segment.end = previousSplineExitPoint;
                back.segment = segment;
            }
            segment = new SplineSegment(spline, entryPoint, direction);
        }

        static void InvertDirection(ref Spline.Direction direction)
        {
            if (direction == Spline.Direction.Forward) direction = Spline.Direction.Backward;
            else direction = Spline.Direction.Forward;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/Wagon.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/LengthEvents/SetMaterialColor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ead07211d73ff3848bedef5c9a977eb0
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;

namespace Dreamteck.Splines.Examples
{
    public class SetMaterialColor : MonoBehaviour
    {
        public Color[] colors;
        SplineRenderer rend;

        private void Start()
        {
            rend = GetComponent<SplineRenderer>();
        }

        public void SetColor(int index)
        {
            if (!Application.isPlaying) return;
            rend.color = colors[index];
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/LengthEvents/SetMaterialColor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/AddForceAlongPath.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6238ae714f0e21c4d81ecfff7fa4e25f
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines.Examples
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class AddForceAlongPath : MonoBehaviour
    {
        public float force = 10f;
        Rigidbody rb;
        SplineProjector projector;

        void Start()
        {
            rb = GetComponent<Rigidbody>();
            projector = GetComponent<SplineProjector>();
        }

        void Update()
        {
            if (Input.GetKeyDown(KeyCode.Space))
            {
                rb.AddForce(projector.result.forward * force, ForceMode.Impulse);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/AddForceAlongPath.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/BallCamera.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ac3147ab308bce045b6fb97d983b610b
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines.Examples
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class BallCamera : MonoBehaviour
    {
        public Rigidbody rb;
        public SplineProjector projector;
        public float positionSpeed = 10f;
        public Vector3 offset = Vector3.zero;
        public float rotationSpeed = 0.5f;
        public Vector3 rotationOffset = Vector3.zero;

        Transform trs;

        private void Awake()
        {
            trs = transform;
            trs.position = rb.position + projector.result.rotation * offset;
            trs.rotation = projector.result.rotation * Quaternion.Euler(rotationOffset);
        }

        void FixedUpdate()
        {
            Vector3 idealPosition = rb.position + trs.rotation * offset;
            Quaternion idealRotation = projector.result.rotation * Quaternion.Euler(rotationOffset);
            trs.position = Vector3.Lerp(trs.position, idealPosition, Time.deltaTime * positionSpeed);
            trs.rotation = Quaternion.Slerp(trs.rotation, idealRotation, Time.deltaTime * rotationSpeed);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/BallCamera.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/LapCounter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a8386d58bfae1c049a2b1428bfff6b85
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines.Examples
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class LapCounter : MonoBehaviour
    {
        int currentLap;
        public TextMesh text;

        public void CountLap()
        {
            currentLap++;
            text.text = "LAP " + currentLap;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/LapCounter.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/RollerCoaster/Scripts/CameraLook.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7834d8d9fc100c3428eac25d2c967646
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;

namespace Dreamteck.Splines.Examples
{
    public class CameraLook : MonoBehaviour
    {
        public float sensitivity = 3f;
        public float dampSpeed = 0f;
        public float lookRange = 45f;
        private float x = 0f;
        private float y = 0f;

        private float xMove = 0f;
        private float yMove = 0f;

        private float crosshairZ = 5f;
        private float idealCrosshairZ = 3f;

        public Transform crosshairSphere;

        // Update is called once per frame
        void Update()
        {
            xMove = Mathf.MoveTowards(xMove, 0f, Time.deltaTime * dampSpeed);
            yMove = Mathf.MoveTowards(yMove, 0f, Time.deltaTime * dampSpeed);
            xMove += Input.GetAxis("Mouse X") / 10f;
            yMove -= Input.GetAxis("Mouse Y") / 10f;
            xMove = Mathf.Clamp(xMove, -1f, 1f);
            yMove = Mathf.Clamp(yMove, -1f, 1f);
            float halfLookRange = lookRange / 2f;
            x += xMove * Time.deltaTime * sensitivity;
            y += yMove * Time.deltaTime * sensitivity;

            if (x > halfLookRange)
            {
                x = halfLookRange;
                if (xMove > 0f) xMove = 0f;
            }
            else if (x < -halfLookRange)
            {
                x = -halfLookRange;
                if (xMove < 0f) xMove = 0f;
            }
            if (y > halfLookRange)
            {
                y = halfLookRange;
                if (yMove > 0f) yMove = 0f;
            }
            else if (y < -halfLookRange)
            {
                y = -halfLookRange;
                if (yMove < 0f) yMove = 0f;
            }
            if (crosshairSphere != null && crosshairSphere.gameObject.activeSelf)
            {
                idealCrosshairZ += Input.GetAxis("Mouse ScrollWheel") * 4f;
                idealCrosshairZ = Mathf.Clamp(idealCrosshairZ, 2f, 6f);
                crosshairZ = Mathf.MoveTowards(crosshairZ, idealCrosshairZ, Time.deltaTime * 8f);
                Vector3 localPos = crosshairSphere.localPosition;
                localPos.z = crosshairZ;
                crosshairSphere.localPosition = localPos;
            }
            this.transform.localRotation = Quaternion.AngleAxis(x, Vector3.up) * Quaternion.AngleAxis(y, Vector3.right);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/RollerCoaster/Scripts/CameraLook.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/RollerCoaster/Scripts/RollerCoaster.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 604a3d1981eee7543a0d98eb9bca640d
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace Dreamteck.Splines.Examples
{
    public class RollerCoaster : MonoBehaviour
    {
        [System.Serializable]
        public class CoasterSound
        {
            public float startPercent = 0f;
            public float endPercent = 1f;
            public AudioSource source;
            public float startPitch = 1f;
            public float endPitch = 1f;
        }

        public float speed = 10f;
        public float minSpeed = 1f;
        public float maxSpeed = 20f;
        public float frictionForce = 0.1f;
        public float gravityForce = 1f;
        public float slopeRange = 60f;
        SplineFollower follower;
        public AnimationCurve speedGain;
        public AnimationCurve speedLoss;
        public float brakeSpeed = 0f;
        public float brakeReleaseSpeed = 0f;

        private float brakeTime = 0f;
        private float brakeForce = 0f;
        private float addForce = 0f;

        public CoasterSound[] sounds;
        public AudioSource brakeSound;
        public AudioSource boostSound;
        public float soundFadeLength = 0.15f;


        // Use this for initialization
        void Start()
        {
            follower = GetComponent<SplineFollower>();
            follower.onEndReached += OnEndReached;
            Cursor.lockState = CursorLockMode.Locked;
        }

        void OnEndReached(double last)
        {
            //Detect when the wagon has reached the end of the spline
            List<SplineComputer> computers = new List<SplineComputer>();
            List<int> connections = new List<int>();
            List<int> connected = new List<int>();
            follower.spline.GetConnectedComputers(computers, connections, connected, 1.0, follower.direction, true); //Get the avaiable connected computers at the end of the spline
            if (computers.Count == 0) return;
            //Do not select computers that are not connected at the first point so that we don't reverse direction
            for (int i = 0; i < computers.Count; i++)
            {
                if(connected[i] != 0)
                {
                    computers.RemoveAt(i);
                    connections.RemoveAt(i);
                    connected.RemoveAt(i);
                    i--;
                    continue;
                }
            }
            float distance = follower.CalculateLength(0.0, follower.result.percent); //Get the excess distance after looping
            follower.spline = computers[Random.Range(0, computers.Count)]; //Change the spline computer to the new spline
            follower.SetDistance(distance); //Set the excess distance along the new spline
        }

        // Update is called once per frame
        void Update()
        {
            if (Input.GetKeyDown(KeyCode.Escape)) Cursor.lockState = CursorLockMode.None;
            float dot = Vector3.Dot(this.transform.forward, Vector3.down);
            float dotPercent = Mathf.Lerp(-slopeRange / 90f, slopeRange / 90f, (dot + 1f) / 2f);
            speed -= Time.deltaTime * frictionForce * (1f - brakeForce);
            float speedAdd = 0f;
            float speedPercent = Mathf.InverseLerp(minSpeed, maxSpeed, speed);
            if (dotPercent > 0f)
            {
                speedAdd = gravityForce * dotPercent * speedGain.Evaluate(speedPercent) * Time.deltaTime;
            }
            else
            {
                speedAdd = gravityForce * dotPercent * speedLoss.Evaluate(1f-speedPercent) * Time.deltaTime;
            }
            speed += speedAdd * (1f-brakeForce);
            speed = Mathf.Clamp(speed, minSpeed, maxSpeed);
            if (addForce > 0f) {
                float lastAdd = addForce;
                addForce = Mathf.MoveTowards(addForce, 0f, Time.deltaTime * 30f);
                speed += lastAdd - addForce;
             }
            follower.followSpeed = speed;
            follower.followSpeed *= (1f - brakeForce);
            if (brakeTime > Time.time) brakeForce = Mathf.MoveTowards(brakeForce, 1f, Time.deltaTime * brakeSpeed);
            else brakeForce = Mathf.MoveTowards(brakeForce, 0f, Time.deltaTime * brakeReleaseSpeed);

            speedPercent = Mathf.Clamp01(speed/maxSpeed)*(1f-brakeForce);
            for (int i = 0; i < sounds.Length; i++) {
                if (speedPercent < sounds[i].startPercent - soundFadeLength || speedPercent > sounds[i].endPercent + soundFadeLength)
                {
                    if (sounds[i].source.isPlaying) sounds[i].source.Pause();
                    continue;
                }
                else if (!sounds[i].source.isPlaying) sounds[i].source.UnPause();
                float volume = 1f;
                if (speedPercent < sounds[i].startPercent+soundFadeLength) volume = Mathf.InverseLerp(sounds[i].startPercent, sounds[i].startPercent+soundFadeLength, speedPercent);
                else if (speedPercent > sounds[i].endPercent) volume = Mathf.InverseLerp(sounds[i].endPercent + soundFadeLength, sounds[i].endPercent, speedPercent);
                float pitchPercent = Mathf.InverseLerp(sounds[i].startPercent, sounds[i].endPercent, speedPercent);
                sounds[i].source.volume = volume;
                sounds[i].source.pitch = Mathf.Lerp(sounds[i].startPitch, sounds[i].endPitch, pitchPercent);
            }

        }

        public void AddBrake(float time)
        {
            brakeTime = Time.time + time;
            brakeSound.Stop();
            brakeSound.Play();
        }

        public void RemoveBrake()
        {
            brakeTime = 0f;
        }

        public void AddForce(float amount)
        {
            addForce = amount;
            boostSound.Stop();
            boostSound.Play();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/RollerCoaster/Scripts/RollerCoaster.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/ArrayUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 82febc9d0aa4907478f53a8dd5e86318
# ASMDEF: Dreamteck.Utilities.dll
# ---
namespace Dreamteck
{
    using System;

    public static class ArrayUtility
    {
        public static void Add<T>(ref T[] array, T item)
        {
            T[] newArray = new T[array.Length + 1];
            array.CopyTo(newArray, 0);
            newArray[newArray.Length - 1] = item;
            array = newArray;
        }
        public static bool Contains<T>(T[] array, T item)
        {
            for (int i = 0; i < array.Length; i++)
            {
                try
                {
                    if (array[i].Equals(item)) return true;
                }
                catch
                {

                }
            }
            return false;
        }
        public static int IndexOf<T>(T[] array, T value)
        {
            for (int i = 0; i < array.Length; i++)
            {
                if (array[i].Equals(value)) return i;
            }
            return 0;
        }
        public static void Insert<T>(ref T[] array, int index, T item)
        {
            T[] newArray = new T[array.Length + 1];
            for (int i = 0; i < newArray.Length; i++)
            {
                if (i < index) newArray[i] = array[i];
                else if (i > index) newArray[i] = array[i - 1];
                else newArray[i] = item;
            }
            array = newArray;
        }


        public static void RemoveAt<T>(ref T[] array, int index)
        {
            if (array.Length == 0) return;
            T[] newArray = new T[array.Length - 1];
            for (int i = 0; i < array.Length; i++)
            {
                if (i < index) newArray[i] = array[i];
                else if (i > index) newArray[i-1] = array[i];
            }
            array = newArray;
        }

        public static void ForEach<T>(this T[] source, Action<T> onLoop)
        {
            foreach (var item in source)
            {
                onLoop(item);
            }
        }

        public static void SetLength<T>(ref T[] source, int newCount)
        {
            T[] newArray = new T[newCount];
            for (int i = 0; i < UnityEngine.Mathf.Min(newCount, source.Length); i++)
            {
                newArray[i] = source[i];
            }
            source = newArray;
        }

        public static void ShiftLeft<T>(this T[] source, int startIndex = 0, bool loop = true)
        {
            var startItem = source[startIndex];
            for (int i = startIndex; i < source.Length-1; i++)
            {
                source[i] = source[i + 1];
            }
            source[source.Length - 1] = loop ? startItem : default;
        }

        public static void ShiftRight<T>(this T[] source, int startIndex = 0, bool loop = true)
        {
            var startItem = source[source.Length - 1];
            for (int i = startIndex + 1; i < source.Length; i++)
            {
                source[i] = source[i - 1];
            }
            source[startIndex] = loop ? startItem : default;
        }

        public static TArray[] QuickSort<TArray,T> (this TArray[] array, Func<TArray,T> getProperty, int leftIndex, int rightIndex) where T : IComparable
        {
            
            var i = leftIndex;
            var j = rightIndex;
            var pivot = getProperty(array[leftIndex]);
            while (i <= j)
            {
                while (getProperty(array[i]).CompareTo(pivot) == -1)
                {
                    i++;
                }

                while (getProperty(array[j]).CompareTo(pivot) == 1)
                {
                    j--;
                }
                if (i <= j)
                {
                    var temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                    i++;
                    j--;
                }
            }

            if (leftIndex < j)
                QuickSort(array, getProperty, leftIndex, j);
            if (i < rightIndex)
                QuickSort(array,getProperty, i, rightIndex);
            return array;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/ArrayUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/AsyncJobSystem.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b5b5fc53001826741b2918682cb3c804
# ASMDEF: Dreamteck.Utilities.dll
# ---
using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Debug = UnityEngine.Debug;

namespace Dreamteck
{
    public class AsyncJobSystem : MonoBehaviour
    {
        private Queue<IJobData> _jobs = new Queue<IJobData>();

        private IJobData _currentJob = null;

        private bool _isWorking = false;

        public AsyncJobOperation ScheduleJob<T>(JobData<T> data)
        {
            _jobs.Enqueue(data);
            return new AsyncJobOperation(data);
        }

        private void Update()
        {
            if (_jobs.Count > 0 && !_isWorking)
            {
                StartCoroutine(JobCoroutine());
            }
        }

        private IEnumerator JobCoroutine()
        {
            _isWorking = true;
            
            while (_jobs.Count > 0)
            {
                _currentJob = _jobs.Dequeue();
                _currentJob.Initialize();

                while (!_currentJob.done)
                {
                    _currentJob.Next();
                    yield return null;
                }

                _currentJob.Complete();
                _currentJob = null;

                yield return null;
            }

            _isWorking = false;
        }


        public class AsyncJobOperation : CustomYieldInstruction
        {
            private IJobData _job;
            
            public AsyncJobOperation(IJobData job)
            {
                _job = job;
            }

            public override bool keepWaiting {
                get { return !_job.done; }
            }
        }

        public interface IJobData
        {
            bool done { get; }

            void Initialize();

            void Next();

            void Complete();
        }

        public class JobData<T> : IJobData
        {
            private int _index;

            private int _iterations = 0;

            private IEnumerable<T> _collection;

            private Action<JobData<T>> _onComplete;

            private Action<JobData<T>> _onIteration;

            private IEnumerator<T> _enumerator;

            public T current { get { return _enumerator.Current; } }

            public int index  { get  { return _index; } }

            public IEnumerable<T> collection { get { return _collection; } }

            public bool done { get; private set; }

            public JobData(IEnumerable<T> collection, int iterations, Action<JobData<T>> onIteration)
            {
                _collection = collection;
                _onIteration = onIteration;
                _iterations = iterations;
                done = false;
            }

            public JobData(IEnumerable<T> collection, int iterations, Action<JobData<T>> onIteration, Action<JobData<T>> onComplete) :
                this(collection, iterations, onIteration)
            {
                _onComplete = onComplete;
            }

            public void Initialize()
            {
                _enumerator = _collection.GetEnumerator();
                _index = -1;
                done = !_enumerator.MoveNext();
            }

            public void Complete()
            {
                _enumerator.Dispose();

                try
                {
                    if (_onComplete != null) {
                        _onComplete(this);
                    }
                }
                catch (Exception e)
                {
                    Debug.LogException(e);
                }
            }

            public void Next()
            {
                int counter = _iterations;

                if (done)
                {
                    return;
                }
                do
                {
                    _index++;

                    try
                    {
                        if(_onIteration != null)
                        {
                            _onIteration(this);
                        }
                    }
                    catch (Exception e)
                    {
                        Debug.LogException(e);
                    }
                    done = !_enumerator.MoveNext();
                }
                while (!done && --counter > 0);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/AsyncJobSystem.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/DMath.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 012b8f43a890d8248b810901033c66a3
# ASMDEF: Dreamteck.Utilities.dll
# ---
using UnityEngine;
using System.Collections;
using System;

namespace Dreamteck
{
    public static class DMath
    {
        public static double Sin(double a)
        {
            return Math.Sin(a);
        }

        public static double Cos(double a)
        {
            return Math.Cos(a);
        }

        public static double Tan(double a)
        {
            return Math.Tan(a);
        }

        public static double Pow(double x, double y)
        {
            return Math.Pow(x, y);
        }

        public static double Log(double a, double newBase)
        {
            return Math.Log(a, newBase);
        }

        public static double Log10(double a)
        {
            return Math.Log10(a);
        }

        public static double Clamp01(double a)
        {
            if (a > 1.0) return 1.0;
            if (a < 0.0) return 0.0;
            return a;
        }

        public static double Clamp(double a, double min, double max)
        {
            if (a > max) return max;
            if (a < min) return min;
            return a;
        }

        public static double Lerp(double a, double b, double t)
        {
            t = Clamp01(t);
            return a + (b - a) * t;
        }

        public static double InverseLerp(double a, double b, double t)
        {
            if (a == b) return 0.0;
            return Clamp01((t-a)/(b-a));
        }

        public static void LerpVector3NonAlloc(Vector3 a, Vector3 b, double t, ref Vector3 target)
        {
            t = Clamp01(t);
            Vector3 delta = (b - a);
            target.x = (float)(a.x + delta.x * t);
            target.y = (float)(a.y + delta.y * t);
            target.z = (float)(a.z + delta.z * t);
        }

        public static Vector3 LerpVector3(Vector3 a, Vector3 b, double t)
        {
            Vector3 result = Vector3.zero;
            LerpVector3NonAlloc(a, b, t, ref result);
            return result;
        }

        public static double Round(double a)
        {
            return Math.Round(a);
        }

        public static int RoundInt(double a)
        {
            return (int)Math.Round(a);
        }

        public static double Ceil(double a)
        {
            return Math.Ceiling(a);
        }

        public static int CeilInt(double a)
        {
            return (int)Math.Ceiling(a);
        }

        public static double Floor(double a)
        {
            return Math.Floor(a);
        }

        public static int FloorInt(double a)
        {
            return (int)Math.Floor(a);
        }

        public static double Move(double current, double target, double amount)
        {
            if (target > current)
            {
                current += amount;
                if (current > target) return target;
            }
            else
            {
                current -= amount;
                if (current < target) return target;
            }
            return current;
        }

        public static double Abs(double a)
        {
            if (a < 0.0) return a * -1.0;
            return a;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/DMath.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/DuplicateUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1a72578399b94604b8ad3f608ef130ea
# ASMDEF: Dreamteck.Utilities.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck
{
    public static class DuplicateUtility
    {
        public static AnimationCurve DuplicateCurve(AnimationCurve input)
        {
            AnimationCurve target = new AnimationCurve();
            target.postWrapMode = input.postWrapMode;
            target.preWrapMode = input.preWrapMode;
            for (int i = 0; i < input.keys.Length; i++) target.AddKey(input.keys[i]);
            return target;
        }

        public static Gradient DuplicateGradient(Gradient input)
        {
            //yet to implement
            return null;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/DuplicateUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/LinearAlgebraUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c9db18633d04e91409973e2ca7ab9c76
# ASMDEF: Dreamteck.Utilities.dll
# ---
using UnityEngine;
using System.Collections;
using System.IO;

namespace Dreamteck
{
    public static class LinearAlgebraUtility
    {
        public enum Axis
        {
            X = 0,
            Y = 1,
            Z = 2
        }

        public static Vector3 ProjectOnLine(Vector3 fromPoint, Vector3 toPoint, Vector3 project)
        {
            Vector3 projectedPoint = Vector3.Project((project - fromPoint), (toPoint - fromPoint)) + fromPoint;
            Vector3 dir = toPoint - fromPoint;
            Vector3 projectedDir = projectedPoint - fromPoint;
            float dot = Vector3.Dot(projectedDir, dir);
            if(dot > 0f)
            {
                if(projectedDir.sqrMagnitude <= dir.sqrMagnitude) return projectedPoint;
                else return toPoint;
            } else return fromPoint;
        }

        public static float InverseLerp(Vector3 a, Vector3 b, Vector3 value)
        {
            Vector3 ab = b - a;
            Vector3 av = value - a;
            return Vector3.Dot(av, ab) / Vector3.Dot(ab, ab);
        }

        public static float DistanceOnSphere(Vector3 from, Vector3 to, float radius)
        {
            float distance = 0;
            
            if (from == to)
            {
                distance = 0;
            }
            else if (from == -to)
            {
                distance = Mathf.PI * radius;
            }
            else
            {
                distance = Mathf.Sqrt(2) * radius * Mathf.Sqrt(1.0f - Vector3.Dot(from, to));
            }

            return distance;
        }

        public static Vector3 FlattenVector(Vector3 input, Axis axis, float flatValue = 0f)
        {
            switch (axis)
            {
                case Axis.X: input.x = flatValue; break;
                case Axis.Y: input.y = flatValue; break;
                case Axis.Z: input.z = flatValue; break;
            }
            return input;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/LinearAlgebraUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/MeshUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 81cc5b669f819ca42a81d2c18c654e23
# ASMDEF: Dreamteck.Utilities.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace Dreamteck
{
    public class MeshUtility
    {
        private static Vector3[] tan1 = new Vector3[0];
        private static Vector3[] tan2 = new Vector3[0];

        public static int[] GeneratePlaneTriangles(int x, int z, bool flip, int startTriangleIndex = 0, int startVertex = 0)
        {
            int nbFaces = x * (z - 1);
            int[] triangles = new int[nbFaces * 6];
            GeneratePlaneTriangles(ref triangles, x, z, flip);
            return triangles;
        }

        public static int[] GeneratePlaneTriangles(ref int[] triangles, int x, int z, bool flip, int startTriangleIndex = 0, int startVertex = 0, bool reallocateArray = false)
        {
            int nbFaces = x * (z - 1);
            if (reallocateArray && triangles.Length != nbFaces * 6)
            {
                if(startTriangleIndex > 0)
                {
                    int[] newTris = new int[startTriangleIndex + nbFaces * 6];
                    for(int i = 0; i < startTriangleIndex; i++) newTris[i] = triangles[i];
                    triangles = newTris;
                } else triangles = new int[nbFaces * 6];
            }
            int g = x + 1;
            int t = startTriangleIndex;
            for (int face = 0; face < nbFaces + z - 2; face++)
            {
                if ((float)(face + 1) % (float)g == 0f && face != 0) face++;
                if (flip)
                {
                    triangles[t++] = face + x + 1 + startVertex;
                    triangles[t++] = face + 1 + startVertex;
                    triangles[t++] = face + startVertex;

                    triangles[t++] = face + x + 1 + startVertex;
                    triangles[t++] = face + x + 2 + startVertex;
                    triangles[t++] = face + 1 + startVertex;
                }
                else
                {
                    triangles[t++] = face + startVertex;
                    triangles[t++] = face + 1 + startVertex;
                    triangles[t++] = face + x + 1 + startVertex;

                    triangles[t++] = face + 1 + startVertex;
                    triangles[t++] = face + x + 2 + startVertex;
                    triangles[t++] = face + x + 1 + startVertex;
                }
            } 
            return triangles;
        }

        public static void CalculateTangents(TS_Mesh mesh)
        {
            int triangleCount = mesh.triangles.Length / 3;
            if (mesh.tangents.Length != mesh.vertexCount)  mesh.tangents = new Vector4[mesh.vertexCount];
            if (tan1.Length != mesh.vertexCount)
            {
                tan1 = new Vector3[mesh.vertexCount];
                tan2 = new Vector3[mesh.vertexCount];
            }

            int tri = 0;
            for (int i = 0; i < triangleCount; i++)
            {
                int i1 = mesh.triangles[tri];
                int i2 = mesh.triangles[tri + 1];
                int i3 = mesh.triangles[tri + 2];

                float x1 = mesh.vertices[i2].x - mesh.vertices[i1].x;
                float x2 = mesh.vertices[i3].x - mesh.vertices[i1].x;
                float y1 = mesh.vertices[i2].y - mesh.vertices[i1].y;
                float y2 = mesh.vertices[i3].y - mesh.vertices[i1].y;
                float z1 = mesh.vertices[i2].z - mesh.vertices[i1].z;
                float z2 = mesh.vertices[i3].z - mesh.vertices[i1].z;

                float s1 = mesh.uv[i2].x - mesh.uv[i1].x;
                float s2 = mesh.uv[i3].x - mesh.uv[i1].x;
                float t1 = mesh.uv[i2].y - mesh.uv[i1].y;
                float t2 = mesh.uv[i3].y - mesh.uv[i1].y;

                float div = s1 * t2 - s2 * t1;
                float r = div == 0f ? 0f : 1f / div;

                Vector3 sdir = new Vector3((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
                Vector3 tdir = new Vector3((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);

                tan1[i1] += sdir;
                tan1[i2] += sdir;
                tan1[i3] += sdir;

                tan2[i1] += tdir;
                tan2[i2] += tdir;
                tan2[i3] += tdir;

                tri += 3;
            }

            for (int i = 0; i < mesh.vertexCount; i++)
            {
                Vector3 n = mesh.normals[i];
                Vector3 t = tan1[i];
                Vector3.OrthoNormalize(ref n, ref t);
                mesh.tangents[i].x = t.x;
                mesh.tangents[i].y = t.y;
                mesh.tangents[i].z = t.z;
                mesh.tangents[i].w = (Vector3.Dot(Vector3.Cross(n, t), tan2[i]) < 0.0f) ? -1.0f : 1.0f;
            }
        }

        public static void MakeDoublesided(Mesh input)
        {
            Vector3[] vertices = input.vertices;
            Vector3[] normals = input.normals;
            Vector2[] uvs = input.uv;
            Color[] colors = input.colors;
            int[] triangles = input.triangles;
            List<int[]> submeshes = new List<int[]>();
            for (int i = 0; i < input.subMeshCount; i++) submeshes.Add(input.GetTriangles(i));

            Vector3[] newVertices = new Vector3[vertices.Length * 2];
            Vector3[] newNormals = new Vector3[normals.Length * 2];
            Vector2[] newUvs = new Vector2[uvs.Length * 2];
            Color[] newColors = new Color[colors.Length * 2];
            int[] newTris = new int[triangles.Length * 2];
            List<int[]> newSubmeshes = new List<int[]>();
            for (int i = 0; i < submeshes.Count; i++)
            {
                newSubmeshes.Add(new int[submeshes[i].Length * 2]);
                submeshes[i].CopyTo(newSubmeshes[i], 0);
            }

            for (int i = 0; i < vertices.Length; i++)
            {
                newVertices[i] = vertices[i];
                newNormals[i] = normals[i];
                newUvs[i] = uvs[i];
                if (colors.Length > i) newColors[i] = colors[i];

                newVertices[i + vertices.Length] = vertices[i];
                newNormals[i + vertices.Length] = -normals[i];
                newUvs[i + vertices.Length] = uvs[i];
                if (colors.Length > i) newColors[i + vertices.Length] = colors[i];
            }

            for (int i = 0; i < triangles.Length; i += 3)
            {
                int index1 = triangles[i];
                int index2 = triangles[i + 1];
                int index3 = triangles[i + 2];
                newTris[i] = index1;
                newTris[i + 1] = index2;
                newTris[i + 2] = index3;

                newTris[i + triangles.Length] = index3 + vertices.Length;
                newTris[i + triangles.Length + 1] = index2 + vertices.Length;
                newTris[i + triangles.Length + 2] = index1 + vertices.Length;
            }

            for (int i = 0; i < submeshes.Count; i++)
            {
                for (int n = 0; n < submeshes[i].Length; n += 3)
                {
                    int index1 = submeshes[i][n];
                    int index2 = submeshes[i][n + 1];
                    int index3 = submeshes[i][n + 2];
                    newSubmeshes[i][n] = index1;
                    newSubmeshes[i][n + 1] = index2;
                    newSubmeshes[i][n + 2] = index3;

                    newSubmeshes[i][n + submeshes[i].Length] = index3 + vertices.Length;
                    newSubmeshes[i][n + submeshes[i].Length + 1] = index2 + vertices.Length;
                    newSubmeshes[i][n + submeshes[i].Length + 2] = index1 + vertices.Length;
                }
            }

            input.vertices = newVertices;
            input.normals = newNormals;
            input.uv = newUvs;
            input.colors = newColors;
            input.triangles = newTris;
            for (int i = 0; i < newSubmeshes.Count; i++) input.SetTriangles(newSubmeshes[i], i);
        }

        public static void MakeDoublesided(TS_Mesh input)
        {
            Vector3[] vertices = input.vertices;
            Vector3[] normals = input.normals;
            Vector2[] uvs = input.uv;
            Color[] colors = input.colors;
            int[] triangles = input.triangles;
            List<int[]> submeshes = input.subMeshes;

            Vector3[] newVertices = new Vector3[vertices.Length * 2];
            Vector3[] newNormals = new Vector3[normals.Length * 2];
            Vector2[] newUvs = new Vector2[uvs.Length * 2];
            Color[] newColors = new Color[colors.Length * 2];
            int[] newTris = new int[triangles.Length * 2];
            List<int[]> newSubmeshes = new List<int[]>();
            for(int i = 0; i < submeshes.Count; i++)
            {
                newSubmeshes.Add(new int[submeshes[i].Length * 2]);
                submeshes[i].CopyTo(newSubmeshes[i], 0);
            }

            for (int i = 0; i < vertices.Length; i++)
            {
                newVertices[i] = vertices[i];
                newNormals[i] = normals[i];
                newUvs[i] = uvs[i];
                if(colors.Length > i) newColors[i] = colors[i];

                newVertices[i + vertices.Length] = vertices[i];
                newNormals[i + vertices.Length] = -normals[i];
                newUvs[i + vertices.Length] = uvs[i];
                if (colors.Length > i) newColors[i + vertices.Length] = colors[i];
            }

            for (int i = 0; i < triangles.Length; i += 3)
            {
                int index1 = triangles[i];
                int index2 = triangles[i + 1];
                int index3 = triangles[i + 2];
                newTris[i] = index1;
                newTris[i + 1] = index2;
                newTris[i + 2] = index3;

                newTris[i + triangles.Length] = index3 + vertices.Length;
                newTris[i + triangles.Length + 1] = index2 + vertices.Length;
                newTris[i + triangles.Length + 2] = index1 + vertices.Length;
            }

            for(int i = 0; i < submeshes.Count; i++)
            {
                for(int n = 0; n < submeshes[i].Length; n+= 3)
                {
                    int index1 = submeshes[i][n];
                    int index2 = submeshes[i][n + 1];
                    int index3 = submeshes[i][n + 2];
                    newSubmeshes[i][n] = index1;
                    newSubmeshes[i][n + 1] = index2;
                    newSubmeshes[i][n + 2] = index3;

                    newSubmeshes[i][n + submeshes[i].Length] = index3 + vertices.Length;
                    newSubmeshes[i][n + submeshes[i].Length + 1] = index2 + vertices.Length;
                    newSubmeshes[i][n + submeshes[i].Length + 2] = index1 + vertices.Length;
                }
            }

            input.vertices = newVertices;
            input.normals = newNormals;
            input.uv = newUvs;
            input.colors = newColors;
            input.triangles = newTris;
            input.subMeshes = newSubmeshes;
        }

        public static void MakeDoublesidedHalf(TS_Mesh input)
        {
            int vertexHalf = input.vertices.Length / 2;
            int trisHalf = input.triangles.Length / 2;
            for (int i = 0; i < vertexHalf; i++)
            {
                input.vertices[i + vertexHalf] = input.vertices[i];
                if (input.normals.Length > i) input.normals[i + vertexHalf] = -input.normals[i];
                if (input.tangents.Length > i) input.tangents[i + vertexHalf] = input.tangents[i];
                if (input.uv.Length > i) input.uv[i + vertexHalf] = input.uv[i];
                if (input.uv2.Length > i) input.uv2[i + vertexHalf] = input.uv2[i];
                if (input.uv3.Length > i) input.uv3[i + vertexHalf] = input.uv3[i];
                if (input.uv4.Length > i) input.uv4[i + vertexHalf] = input.uv4[i];
                if (input.colors.Length > i) input.colors[i + vertexHalf] = input.colors[i];
            }

            for (int i = 0; i < trisHalf; i += 3)
            {
                input.triangles[i + trisHalf + 2] = input.triangles[i] + vertexHalf;
                input.triangles[i + trisHalf + 1] = input.triangles[i + 1] + vertexHalf;
                input.triangles[i + trisHalf] = input.triangles[i + 2] + vertexHalf;
            }

            for (int i = 0; i < input.subMeshes.Count; i++)
            {
                trisHalf = input.subMeshes[i].Length / 2;
                for (int n = 0; n < trisHalf; n += 3)
                {
                    input.subMeshes[i][n + trisHalf + 2] = input.subMeshes[i][n] + vertexHalf;
                    input.subMeshes[i][n + trisHalf + 1] = input.subMeshes[i][n + 1] + vertexHalf;
                    input.subMeshes[i][n + trisHalf] = input.subMeshes[i][n + 2] + vertexHalf;
                }
            }
        }

        public static void TransformMesh(TS_Mesh input, Matrix4x4 matrix)
        {
            if (input.vertices == null || input.normals == null) return;
            for (int i = 0; i < input.vertices.Length; i++)
            {
                input.vertices[i] = matrix.MultiplyPoint3x4(input.vertices[i]);
                input.normals[i] = matrix.MultiplyVector(input.normals[i]);
            }
        }

        public static void TransformMesh(Mesh input, Matrix4x4 matrix)
        {
            Vector3[] vertices = input.vertices;
            Vector3[] normals = input.vertices;
            if (input.vertices == null || input.normals == null) return;
            for (int i = 0; i < input.vertices.Length; i++)
            {
                vertices[i] = matrix.MultiplyPoint3x4(vertices[i]);
                normals[i] = matrix.MultiplyVector(normals[i]);
            }
            input.vertices = vertices;
            input.normals = normals;
        }


        public static void TransformVertices(Vector3[] vertices, Matrix4x4 matrix)
        {
            for (int i = 0; i < vertices.Length; i++)
            {
                vertices[i] = matrix.MultiplyPoint3x4(vertices[i]);
            }
        }

        public static void TransformNormals(Vector3[] normals, Matrix4x4 matrix)
        {
            for (int i = 0; i < normals.Length; i++)
            {
                normals[i] = matrix.MultiplyVector(normals[i]);
            }
        }

        public static string ToOBJString(Mesh mesh, Material[] materials)
        {
            int numVertices = 0;
            if (mesh == null)
            {
                return "####Error####";
            }

            StringBuilder sb = new StringBuilder();
            sb.Append("g " + mesh.name +"\n");
            foreach (Vector3 v in mesh.vertices)
            {
                numVertices++;
                sb.Append(string.Format("v {0} {1} {2}\n", -v.x, v.y, v.z));
            }
            sb.Append("\n");
            foreach (Vector3 n in mesh.normals)
            {
                sb.Append(string.Format("vn {0} {1} {2}\n", -n.x, n.y, n.z));
            }
            sb.Append("\n");
            foreach (Vector3 v in mesh.uv)
            {
                sb.Append(string.Format("vt {0} {1}\n", v.x, v.y));
            }
            sb.Append("\n");
            foreach (Vector2 v in mesh.uv2)
            {
                sb.Append(string.Format("vt2 {0} {1}\n", v.x, v.y));
            }
            sb.Append("\n");
            foreach (Vector2 v in mesh.uv3)
            {
                sb.Append(string.Format("vt2 {0} {1}\n", v.x, v.y));
            }
            sb.Append("\n");
            foreach (Color c in mesh.colors)
            {
                sb.Append(string.Format("vc {0} {1} {2} {3}\n", c.r, c.g, c.b, c.a));
            }
            for (int material = 0; material < mesh.subMeshCount; material++)
            {
                sb.Append("\n");
                sb.Append("usemtl ").Append(materials[material].name).Append("\n");
                sb.Append("usemap ").Append(materials[material].name).Append("\n");

                int[] triangles = mesh.GetTriangles(material);
                for (int i = 0; i < triangles.Length; i += 3)
                {
                    sb.Append(string.Format("f {2}/{2}/{2} {1}/{1}/{1} {0}/{0}/{0}\n",
                        triangles[i] + 1, triangles[i + 1] + 1, triangles[i + 2] + 1));
                }
            }
            return sb.ToString().Replace(',', '.');
        }

        public static Mesh Copy(Mesh input)
        {
            Mesh copy = new Mesh();
            copy.name = input.name;
            copy.vertices = input.vertices;
            copy.normals = input.normals;
            copy.colors = input.colors;
            copy.uv = input.uv;
            copy.uv2 = input.uv2;
            copy.uv3 = input.uv3;
            copy.uv4 = input.uv4;
            copy.tangents = input.tangents;
            copy.boneWeights = input.boneWeights;
            copy.bindposes = input.bindposes;
            copy.triangles = input.triangles;
            copy.subMeshCount = input.subMeshCount;
            for (int i = 0; i < input.subMeshCount; i++)
            {
                copy.SetTriangles(input.GetTriangles(i), i);
            }
            return copy;
        }

        public static void Triangulate(Vector2[] points, ref int[] output)
        {
            List<int> indices = new List<int>();
            int pointsLength = points.Length;
            if (pointsLength < 3)
            {
                output = new int[0];
                return;
            }

            int[] V = new int[pointsLength];
            if (Area(points, pointsLength) > 0)
            {
                for (int v = 0; v < pointsLength; v++)
                    V[v] = v;
            }
            else
            {
                for (int v = 0; v < pointsLength; v++)
                    V[v] = (pointsLength - 1) - v;
            }

            int nv = pointsLength;
            int count = 2 * nv;
            for (int m = 0, v = nv - 1; nv > 2;)
            {
                if ((count--) <= 0)
                {
                    if (output.Length != indices.Count) output = new int[indices.Count];
                    indices.CopyTo(output, 0);
                    return;
                }

                int u = v;
                if (nv <= u)
                    u = 0;
                v = u + 1;
                if (nv <= v)
                    v = 0;
                int w = v + 1;
                if (nv <= w)
                    w = 0;

                if (Snip(points, u, v, w, nv, V))
                {
                    int a, b, c, s, t;
                    a = V[u];
                    b = V[v];
                    c = V[w];
                    indices.Add(c);
                    indices.Add(b);
                    indices.Add(a);
                    m++;
                    for (s = v, t = v + 1; t < nv; s++, t++)
                        V[s] = V[t];
                    nv--;
                    count = 2 * nv;
                }
            }

            indices.Reverse();
            if (output.Length != indices.Count) output = new int[indices.Count];
            indices.CopyTo(output, 0);
        }

        public static void FlipTriangles(ref int[] triangles)
        {
            for (int i = 0; i < triangles.Length; i += 3)
            {
                int temp = triangles[i];
                triangles[i] = triangles[i + 2];
                triangles[i + 2] = temp;
            }
        }

        public static void FlipFaces(TS_Mesh input)
        {
            for (int i = 0; i < input.subMeshes.Count; i++)
            {
                int[] array = input.subMeshes[i];
                FlipTriangles(ref array);
            }
            FlipTriangles(ref input.triangles);
            for (int i = 0; i < input.normals.Length; i++)
            {
                input.normals[i] *= -1f;
            }
        }

        public static void BreakMesh(Mesh input, bool keepNormals = true)
        {
            Vector3[] newVertices = new Vector3[input.triangles.Length];
            Vector3[] newNormals = new Vector3[newVertices.Length];
            Vector2[] newUVs = new Vector2[newVertices.Length];
            Vector4[] newTangents = new Vector4[newVertices.Length];
            Color[] newColors = new Color[newVertices.Length];
            BoneWeight[] newBoneWeights = new BoneWeight[newVertices.Length];

            Vector3[] oldVertices = input.vertices;
            Vector2[] oldUvs = input.uv;
            Vector3[] oldNormals = input.normals;
            Vector4[] oldTangents = input.tangents;
            Color[] oldColors = input.colors;
            BoneWeight[] oldBoneWeights = input.boneWeights;

            if (oldColors.Length != oldVertices.Length)
            {
                oldColors = new Color[oldVertices.Length];
                for (int i = 0; i < oldColors.Length; i++) oldColors[i] = Color.white;
            }

            List<int[]> submeshList = new List<int[]>();
            int submeshes = input.subMeshCount;
            int vertIndex = 0;
            for (int i = 0; i < submeshes; i++)
            {
                int[] submesh = input.GetTriangles(i);
                for (int n = 0; n < submesh.Length; n += 3)
                {
                    newVertices[vertIndex] = oldVertices[submesh[n]];
                    newVertices[vertIndex + 1] = oldVertices[submesh[n + 1]];
                    newVertices[vertIndex + 2] = oldVertices[submesh[n + 2]];

                    if (oldNormals.Length > submesh[n + 2])
                    {
                        if (!keepNormals)
                        {
                            newNormals[vertIndex] = newNormals[vertIndex + 1] = newNormals[vertIndex + 2] = (oldNormals[submesh[n]] + oldNormals[submesh[n + 1]] + oldNormals[submesh[n + 2]]).normalized;
                        }
                        else
                        {
                            newNormals[vertIndex] = oldNormals[submesh[n]];
                            newNormals[vertIndex + 1] = oldNormals[submesh[n + 1]];
                            newNormals[vertIndex + 2] = oldNormals[submesh[n + 2]];
                        }

                    }

                    if (oldColors.Length > submesh[n + 2])
                        newColors[vertIndex] = newColors[vertIndex + 1] = newColors[vertIndex + 2] = (oldColors[submesh[n]] + oldColors[submesh[n + 1]] + oldColors[submesh[n + 2]]) / 3f;

                    if (oldUvs.Length > submesh[n + 2])
                    {
                        newUVs[vertIndex] = oldUvs[submesh[n]];
                        newUVs[vertIndex + 1] = oldUvs[submesh[n + 1]];
                        newUVs[vertIndex + 2] = oldUvs[submesh[n + 2]];
                    }

                    if (oldTangents.Length > submesh[n + 2])
                    {
                        newTangents[vertIndex] = oldTangents[submesh[n]];
                        newTangents[vertIndex + 1] = oldTangents[submesh[n + 1]];
                        newTangents[vertIndex + 2] = oldTangents[submesh[n + 2]];
                    }

                    if (oldBoneWeights.Length > submesh[n + 2])
                    {
                        newBoneWeights[vertIndex] = oldBoneWeights[submesh[n]];
                        newBoneWeights[vertIndex + 1] = oldBoneWeights[submesh[n + 1]];
                        newBoneWeights[vertIndex + 2] = oldBoneWeights[submesh[n + 2]];
                    }

                    submesh[n] = vertIndex;
                    submesh[n + 1] = vertIndex + 1;
                    submesh[n + 2] = vertIndex + 2;
                    vertIndex += 3;
                }
                submeshList.Add(submesh);
            }

            input.vertices = newVertices;
            input.normals = newNormals;
            input.colors = newColors;
            input.uv = newUVs;
            input.tangents = newTangents;
            input.subMeshCount = submeshList.Count;
            input.boneWeights = newBoneWeights;
            for (int i = 0; i < submeshList.Count; i++)
            {
                input.SetTriangles(submeshList[i], i);
            }
        }

        private static float Area(Vector2[] points, int maxCount)
        {
            float A = 0.0f;
            for (int p = maxCount - 1, q = 0; q < maxCount; p = q++)
            {
                Vector2 pval = points[p];
                Vector2 qval = points[q];
                A += pval.x * qval.y - qval.x * pval.y;
            }
            return (A * 0.5f);
        }

        private static bool Snip(Vector2[] points, int u, int v, int w, int n, int[] V)
        {
            int p;
            Vector2 A = points[V[u]];
            Vector2 B = points[V[v]];
            Vector2 C = points[V[w]];
            if (Mathf.Epsilon > (((B.x - A.x) * (C.y - A.y)) - ((B.y - A.y) * (C.x - A.x))))
                return false;
            for (p = 0; p < n; p++)
            {
                if ((p == u) || (p == v) || (p == w))
                    continue;
                Vector2 P = points[V[p]];
                if (InsideTriangle(A, B, C, P))
                    return false;
            }
            return true;
        }

        private static bool InsideTriangle(Vector2 A, Vector2 B, Vector2 C, Vector2 P)
        {
            float ax, ay, bx, by, cx, cy, apx, apy, bpx, bpy, cpx, cpy;
            float cCROSSap, bCROSScp, aCROSSbp;

            ax = C.x - B.x; ay = C.y - B.y;
            bx = A.x - C.x; by = A.y - C.y;
            cx = B.x - A.x; cy = B.y - A.y;
            apx = P.x - A.x; apy = P.y - A.y;
            bpx = P.x - B.x; bpy = P.y - B.y;
            cpx = P.x - C.x; cpy = P.y - C.y;

            aCROSSbp = ax * bpy - ay * bpx;
            cCROSSap = cx * apy - cy * apx;
            bCROSScp = bx * cpy - by * cpx;

            return ((aCROSSbp >= 0.0f) && (bCROSScp >= 0.0f) && (cCROSSap >= 0.0f));
        }

    }

}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/MeshUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/PrivateSingleton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fb49526ef2768364fb4acea66dc04ffd
# ASMDEF: Dreamteck.Utilities.dll
# ---
namespace Dreamteck
{
    using System.Linq;
    using UnityEngine;

    public class PrivateSingleton<T> : MonoBehaviour where T : Component
    {
        [SerializeField] protected bool _dontDestryOnLoad = true;
        [SerializeField] protected bool _overrideInstance = false;

        protected static T _instance;

        protected virtual void Awake()
        {
            if (_instance != null && _instance != this)
            {
                if (_overrideInstance)
                {
                    Destroy(_instance.gameObject);
                    _instance = this as T;
                    Init();
                }
                else
                {
                    Destroy(this.gameObject);
                }
            }
            else
            {
                _instance = this as T;

                if (_dontDestryOnLoad)
                {
                    DontDestroyOnLoad(gameObject);
                }
                Init();
            }
        }

        protected virtual void Init()
        {
        }

        protected virtual void OnDestroy()
        {
            if (_instance == this && !_overrideInstance)
            {
                _instance = null;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/PrivateSingleton.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Randomizer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6d76cd13905daa94587b47d8dc4d2ee5
# ASMDEF: Dreamteck.Utilities.dll
# ---
namespace Dreamteck.Utilities
{
    using UnityEngine;

    public class Randomizer
    {
        private int _seed;
        private System.Random _random;

        public System.Random random => _random;

        public Randomizer(int seed)
        {
            _seed = seed;
            _random = new System.Random(_seed);
        }

        public float Random01()
        {
            return (float)_random.NextDouble();
        }

        public float Random(float min, float max)
        {
            return (float)DMath.Lerp(min, max, _random.NextDouble());
        }

        public int Random(int min, int max)
        {
            return (int)DMath.Lerp(min, max, _random.NextDouble());
        }

        public Vector2 RandomVector2(float min, float max)
        {
            return new Vector2(Random(min, max), Random(min, max));
        }

        public Vector3 RandomVector3(float min, float max)
        {
            return new Vector3(Random(min, max), Random(min, max), Random(min, max));
        }

        public Vector3 OnUnitSphere()
        {
            return Quaternion.Euler(Random(0f, 360f), Random(0f, 360f), Random(0f, 360f)) * Vector3.forward;
        }

        public Vector3 OnUnitCircle()
        {
            return Quaternion.AngleAxis(Random(0f, 360f), Vector3.forward) * Vector3.up;
        }

        public Vector3 InsideUnitSphere()
        {
            return OnUnitSphere() * Random01();
        }

        public Vector3 InsideUnitCircle()
        {
            return OnUnitCircle() * Random01();
        }

        public void Reset()
        {
            _random = new System.Random(_seed);
        }

        public void Reset(int seed)
        {
            _random = new System.Random(seed);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Randomizer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/SceneUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b5c6af18f0a94e34b8500b13d07331d6
# ASMDEF: Dreamteck.Utilities.dll
# ---
namespace Dreamteck
{
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEngine.SceneManagement;

    public static class SceneUtility
    {
        public static List<Transform> childrenList = new List<Transform>();

        public static void GetChildrenRecursively(Transform current)
        {
            childrenList.Clear();
            GetChildrenRecursivelyInternal(current);
        }

        private static void GetChildrenRecursivelyInternal(Transform current)
        {
            childrenList.Add(current);
            int childCount = current.childCount;
            for (int i = 0; i < childCount; i++)
            {
                GetChildrenRecursivelyInternal(current.GetChild(i));
            }
        }

        public static T[] GetComponentsInChildrenRecusrively<T>(this GameObject gameObject) where T : Component
        {
            GetChildrenRecursively(gameObject.transform);
            List<T> components = new List<T>();
            for (int i = 0; i < childrenList.Count; i++)
            {
                T component = childrenList[i].GetComponent<T>();
                if(component != null)
                {
                    components.Add(component);
                }
            }
            return components.ToArray();
        }

        public static void GetChildrenRecursively(Transform current, ref List<Transform> transformList)
        {
            transformList.Add(current);
            foreach (Transform child in current) GetChildrenRecursively(child, ref transformList);
        }

        public static T GetComponentInScene<T>(this Scene scene, string objectName = null) where T : Component
        {
            var component = default(T);
            var rootObjects = scene.GetRootGameObjects();

            foreach (var obj in rootObjects)
            {
                if (objectName != null && obj.name != objectName) continue;
                component = obj.GetComponentInChildren<T>();
                if(component != null)
                {
                    break;
                }
            }

            return component;
        }

        public static T[] GetComponentsInScene<T>(this Scene scene, string objectName = null, bool includeInactive = false)
        {
            var rootObjects = scene.GetRootGameObjects();
            var components = new List<T>();

            foreach (var obj in rootObjects)
            {
                var rootComponent = obj.GetComponent<T>();

                if (rootComponent != null && (objectName == null || (objectName != null && obj.gameObject.name == obj.name)))
                {
                    components.Add(rootComponent);
                }

                var foundComponents = obj.GetComponentsInChildren<T>(includeInactive);

                for (int i = 0; i < foundComponents.Length; i++)
                {
                    var component = foundComponents[i] as Component;

                    if (objectName != null && component != null && component.gameObject.name != objectName) continue;

                    components.Add(foundComponents[i]);
                }
            }

            return components.ToArray();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/SceneUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/ScriptableObjectUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 85e4f0317c6ed394cb416b5bf4fe4c59
# ASMDEF: Dreamteck.Utilities.dll
# ---
#if UNITY_EDITOR
namespace Dreamteck {
    using UnityEngine;
    using UnityEditor;
    using System.IO;

    public static class ScriptableObjectUtility
    {
        public static T CreateAsset<T>(string name = "", bool selectAfterCreation = true) where T : ScriptableObject
        {
            T asset = ScriptableObject.CreateInstance<T>();
            SaveAsset(asset, name, selectAfterCreation);
            return asset;
        }

        public static ScriptableObject CreateAsset(string type, string name = "", bool selectAfterCreation = true)
        {
            ScriptableObject asset = ScriptableObject.CreateInstance(type);
            SaveAsset<ScriptableObject>(asset, name, selectAfterCreation);
            return asset;
        }

        static void SaveAsset<T>(T asset, string name = "", bool selectAfterCreation = true) where T : ScriptableObject
        {
            string path = AssetDatabase.GetAssetPath(Selection.activeObject);
            if (path == "")
            {
                path = "Assets";
            }
            else if (Path.GetExtension(path) != "")
            {
                path = path.Replace(Path.GetFileName(AssetDatabase.GetAssetPath(Selection.activeObject)), "");
            }
            string assetName = "New " + typeof(T).ToString();
            if (name != "") assetName = name;
            if(!path.EndsWith("/"))
            {
                path += "/";
            }
            string assetPathAndName = AssetDatabase.GenerateUniqueAssetPath(path + assetName + ".asset");
            AssetDatabase.CreateAsset(asset, assetPathAndName);

            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
            EditorUtility.FocusProjectWindow();
            if (selectAfterCreation)
            {
                Selection.activeObject = asset;
            }
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/ScriptableObjectUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Singleton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 656f05929b8fd1b4eb519de915c24212
# ASMDEF: Dreamteck.Utilities.dll
# ---
namespace Dreamteck
{
    using System.Linq;
    using UnityEngine;

    public class Singleton<T> : PrivateSingleton<T> where T : Component
    {
        public static T instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = Object.FindObjectsOfType<T>().FirstOrDefault();
                }

                return _instance;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Singleton.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TransformUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 157259bef35b27e4ebcccdd7e3eee86b
# ASMDEF: Dreamteck.Utilities.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck
{
    public static class TransformUtility
    {
        public static Vector3 GetPosition(Matrix4x4 m)
        {
            return m.GetColumn(3);
        }

        public static Quaternion GetRotation(Matrix4x4 m)
        {
            return Quaternion.LookRotation(m.GetColumn(2), m.GetColumn(1));
        }

        public static Vector3 GetScale(Matrix4x4 m)
        {
            return new Vector3(m.GetColumn(0).magnitude, m.GetColumn(1).magnitude, m.GetColumn(2).magnitude);
        }

        public static void SetPosition(ref Matrix4x4 m, ref Vector3 p)
        {
            m.SetColumn(3, new Vector4(p.x, p.y, p.z, 1f));
        }

        public static void GetChildCount(Transform parent, ref int count)
        {
            foreach (Transform child in parent)
            {
                count++;
                GetChildCount(child, ref count);
            }
        }

        public static void MergeBoundsRecursively(this Transform rootParent, Transform tr, ref Bounds bounds, string nameToIgnore = null)
        {
            foreach (Transform child in tr)
            {
                if (!string.IsNullOrEmpty(nameToIgnore) && child.name == nameToIgnore)
                {
                    continue;
                }

                rootParent.MergeBoundsRecursively(child, ref bounds);

                var meshFilter = child.GetComponent<MeshFilter>();

                if (meshFilter == null) continue;
                if (meshFilter.sharedMesh == null)
                {
                    Debug.LogError("MESH FILTER " + meshFilter.name + " IS MISSING A MESH");
                    continue;
                }
                var min = child.TransformPoint(meshFilter.sharedMesh.bounds.min);
                var max = child.TransformPoint(meshFilter.sharedMesh.bounds.max);

                bounds.Encapsulate(rootParent.InverseTransformPoint(min));
                bounds.Encapsulate(rootParent.InverseTransformPoint(max));
            }
        }

        public static void DestroyChildren(this Transform src)
        {
            int count = src.childCount;
            for (int i = 0; i < count; i++)
            {
                UnityEngine.Object.Destroy(src.GetChild(i).gameObject);
            }
        }

        public static bool IsParent(Transform child, Transform parent)
        {
            Transform current = child;
            while(current.parent != null)
            {
                current = current.parent;
                if (current == parent) return true;
            }
            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TransformUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Bounds.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2c28a6bb56e8cee4fb7dd9a493afbf83
# ASMDEF: Dreamteck.Utilities.dll
# ---
using UnityEngine;
using System.Collections;

namespace Dreamteck
{
    [System.Serializable]
    public class TS_Bounds
    {
        public Vector3 center = Vector3.zero;
        public Vector3 extents = Vector3.zero;
        public Vector3 max = Vector3.zero;
        public Vector3 min = Vector3.zero;
        public Vector3 size = Vector3.zero;

        public TS_Bounds()
        {

        }

        public TS_Bounds(Bounds bounds)
        {
            center = bounds.center;
            extents = bounds.extents;
            max = bounds.max;
            min = bounds.min;
            size = bounds.size;
        }

        public TS_Bounds(Vector3 c, Vector3 s)
        {
            center = c;
            size = s;
            extents = s / 2;
            max = center + extents;
            min = center - extents;
        }

        public TS_Bounds(Vector3 min, Vector3 max, Vector3 center)
        {
            size = new Vector3(max.x - min.x, max.y - min.y, max.z - min.z);
            extents = size / 2f;
            this.min = min;
            this.max = max;
            this.center = center;
        }

        public void CreateFromMinMax(Vector3 min, Vector3 max)
        {
            size.x = max.x - min.x;
            size.y = max.y - min.y;
            size.z = max.z - min.z;
            extents = size / 2f;
            this.min = min;
            this.max = max;
            center = (Vector3.Lerp(min, max, 0.5f));
        }

        public bool Contains(Vector3 point)
        {
            if (point.x < min.x || point.x > max.x) return false;
            if (point.y < min.y || point.y > max.y) return false;
            if (point.z < min.z || point.z > max.z) return false;
            return true;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Bounds.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Mesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9ca64fd6869620449bcb61d4f66c798e
# ASMDEF: Dreamteck.Utilities.dll
# ---
namespace Dreamteck
{
    using UnityEngine;
    using System.Collections;
    using System.Collections.Generic;
    //Thread-safe mesh & bounds classes for working with threads.
    public class TS_Mesh
    {
        public int vertexCount
        {
            get { return vertices.Length; }
            set { }
        }
        public Vector3[] vertices = new Vector3[0];
        public Vector3[] normals = new Vector3[0];
        public Vector4[] tangents = new Vector4[0];
        public Color[] colors = new Color[0];
        public Vector2[] uv = new Vector2[0];
        public Vector2[] uv2 = new Vector2[0];
        public Vector2[] uv3 = new Vector2[0];
        public Vector2[] uv4 = new Vector2[0];
        public int[] triangles = new int[0];
        public List<int[]> subMeshes = new List<int[]>();
        public TS_Bounds bounds = new TS_Bounds(Vector3.zero, Vector3.zero);
        public UnityEngine.Rendering.IndexFormat indexFormat = UnityEngine.Rendering.IndexFormat.UInt16;

        public volatile bool hasUpdate = false;

        private int[] _submeshTrisCount = new int[0];
        private int[] _submeshOffsets = new int[0];


        public TS_Mesh()
        {

        }

        public TS_Mesh(Mesh mesh)
        {
            CreateFromMesh(mesh);
        }

        public void Clear()
        {
            vertices = new Vector3[0];
            normals = new Vector3[0];
            tangents = new Vector4[0];
            colors = new Color[0];
            uv = new Vector2[0];
            uv2 = new Vector2[0];
            uv3 = new Vector2[0];
            uv4 = new Vector2[0];
            triangles = new int[0];
            subMeshes = new List<int[]>();
            bounds = new TS_Bounds(Vector3.zero, Vector3.zero);
        }

        public void CreateFromMesh(Mesh mesh)
        {
            vertices = mesh.vertices;
            normals = mesh.normals;
            tangents = mesh.tangents;
            colors = mesh.colors;
            uv = mesh.uv;
            uv2 = mesh.uv2;
            uv3 = mesh.uv3;
            uv4 = mesh.uv4;
            triangles = mesh.triangles;
            bounds = new TS_Bounds(mesh.bounds);
            indexFormat = mesh.indexFormat;
            for (int i = 0; i < mesh.subMeshCount; i++)
            {
                subMeshes.Add(mesh.GetTriangles(i));
            }
        }

        /// <summary>
        /// Writes the combineMeshes array to the current TS_Mesh object and tries to not allocate memory
        /// </summary>
        /// <param name="combineMeshes"></param>
        public void Combine(List<TS_Mesh> combineMeshes)
        {
            int totalVertexCount = 0;
            int totalTrisCount = 0;
            int addedSubmeshCount = 0;

            for (int i = 0; i < combineMeshes.Count; i++)
            {
                totalVertexCount += combineMeshes[i].vertices.Length;
                totalTrisCount += combineMeshes[i].triangles.Length;
                if (combineMeshes[i].subMeshes.Count > addedSubmeshCount)
                {
                    addedSubmeshCount = combineMeshes[i].subMeshes.Count;
                }
            }

            if (_submeshTrisCount.Length != addedSubmeshCount)
            {
                _submeshTrisCount = new int[addedSubmeshCount];
            }
            else
            {
                for (int i = 0; i < _submeshTrisCount.Length; i++)
                {
                    _submeshTrisCount[i] = 0;
                }
            }


            for (int i = 0; i < combineMeshes.Count; i++)
            {
                for (int j = 0; j < combineMeshes[i].subMeshes.Count; j++)
                {
                    _submeshTrisCount[j] += combineMeshes[i].subMeshes[j].Length;
                }
            }

            if (vertices.Length != totalVertexCount) vertices = new Vector3[totalVertexCount];
            if (normals.Length != totalVertexCount) normals = new Vector3[totalVertexCount];
            if (uv.Length != totalVertexCount) uv = new Vector2[totalVertexCount];
            if (uv2.Length != totalVertexCount) uv2 = new Vector2[totalVertexCount];
            if (uv3.Length != totalVertexCount) uv3 = new Vector2[totalVertexCount];
            if (uv4.Length != totalVertexCount) uv4 = new Vector2[totalVertexCount];
            if (colors.Length != totalVertexCount) colors = new Color[totalVertexCount];
            if (tangents.Length != totalVertexCount) tangents = new Vector4[totalVertexCount];
            if (triangles.Length != totalTrisCount) triangles = new int[totalTrisCount];
            if (subMeshes.Count > addedSubmeshCount) subMeshes.Clear();

            int vertexOffset = 0;
            int trisOffset = 0;

            if(_submeshOffsets.Length != addedSubmeshCount)
            {
                _submeshOffsets = new int[addedSubmeshCount];
            } else
            {
                for (int i = 0; i < _submeshOffsets.Length; i++)
                {
                    _submeshOffsets[i] = 0;
                }
            }


            for (int i = 0; i < combineMeshes.Count; i++)
            {
                combineMeshes[i].vertices.CopyTo(vertices, vertexOffset);
                combineMeshes[i].normals.CopyTo(normals, vertexOffset);
                combineMeshes[i].uv.CopyTo(uv, vertexOffset);
                combineMeshes[i].uv2.CopyTo(uv2, vertexOffset);
                combineMeshes[i].uv3.CopyTo(uv3, vertexOffset);
                combineMeshes[i].uv4.CopyTo(uv4, vertexOffset);
                combineMeshes[i].colors.CopyTo(colors, vertexOffset);
                combineMeshes[i].tangents.CopyTo(tangents, vertexOffset);

                for (int t = 0; t < combineMeshes[i].triangles.Length; t++)
                {
                    int index = t + trisOffset;
                    triangles[index] = combineMeshes[i].triangles[t] + vertexOffset;
                }

                trisOffset += combineMeshes[i].triangles.Length;

                for (int j = 0; j < combineMeshes[i].subMeshes.Count; j++)
                {
                    if (j >= subMeshes.Count)
                    {
                        subMeshes.Add(new int[_submeshTrisCount[j]]);
                    }
                    else if (subMeshes[j].Length != _submeshTrisCount[j])
                    {
                        subMeshes[j] = new int[_submeshTrisCount[j]];
                    }
                    int[] submesh = combineMeshes[i].subMeshes[j];

                    for (int x = 0; x < submesh.Length; x++)
                    {
                        int index = _submeshOffsets[j] + x;
                        subMeshes[j][index] = submesh[x] + vertexOffset;
                    }
                    _submeshOffsets[j] += submesh.Length;
                }
                vertexOffset += combineMeshes[i].vertices.Length;
            }
        }

        /// <summary>
        /// Adds the provieded mesh list to the current mesh and allocates memory
        /// </summary>
        /// <param name="addedMeshes"></param>
        public void AddMeshes(List<TS_Mesh> addedMeshes)
        {
            int newVerts = 0;
            int newTris = 0;
            int submeshCount = 0;
            for (int i = 0; i < addedMeshes.Count; i++)
            {
                newVerts += addedMeshes[i].vertexCount;
                newTris += addedMeshes[i].triangles.Length;
                if (addedMeshes[i].subMeshes.Count > submeshCount)
                {
                    submeshCount = addedMeshes[i].subMeshes.Count;
                }
            }
            int[] submeshTrisCount = new int[submeshCount];
            int[] submeshOffsets = new int[submeshCount];
            for (int i = 0; i < addedMeshes.Count; i++)
            {
                for (int j = 0; j < addedMeshes[i].subMeshes.Count; j++)
                {
                    submeshTrisCount[j] += addedMeshes[i].subMeshes[j].Length;
                }
            }

            
            Vector3[] newVertices = new Vector3[vertices.Length + newVerts];
            Vector3[] newNormals = new Vector3[vertices.Length + newVerts];
            Vector2[] newUvs = new Vector2[vertices.Length + newVerts];
            Vector2[] newUvs2 = new Vector2[vertices.Length + newVerts];
            Vector2[] newUvs3 = new Vector2[vertices.Length + newVerts];
            Vector2[] newUvs4 = new Vector2[vertices.Length + newVerts];
            Color[] newColors = new Color[vertices.Length + newVerts];
            Vector4[] newTangents = new Vector4[tangents.Length + newVerts];
            int[] newTriangles = new int[triangles.Length + newTris];
            List<int[]> newSubmeshes = new List<int[]>();

            for (int i = 0; i < submeshTrisCount.Length; i++)
            {
                newSubmeshes.Add(new int[submeshTrisCount[i]]);
                if (i < subMeshes.Count)
                {
                    submeshTrisCount[i] = subMeshes[i].Length;
                }
                else
                {
                    submeshTrisCount[i] = 0;
                }
            }

            newVerts = vertexCount;
            newTris = triangles.Length;
            vertices.CopyTo(newVertices, 0);
            normals.CopyTo(newNormals, 0);
            uv.CopyTo(newUvs, 0);
            uv2.CopyTo(newUvs2, 0);
            uv3.CopyTo(newUvs3, 0);
            uv4.CopyTo(newUvs4, 0);
            colors.CopyTo(newColors, 0);
            tangents.CopyTo(newTangents, 0);
            triangles.CopyTo(newTriangles, 0);

            for (int i = 0; i < addedMeshes.Count; i++)
            {
                addedMeshes[i].vertices.CopyTo(newVertices, newVerts);
                addedMeshes[i].normals.CopyTo(newNormals, newVerts);
                addedMeshes[i].uv.CopyTo(newUvs, newVerts);
                addedMeshes[i].uv2.CopyTo(newUvs2, newVerts);
                addedMeshes[i].uv3.CopyTo(newUvs3, newVerts);
                addedMeshes[i].uv4.CopyTo(newUvs4, newVerts);
                addedMeshes[i].colors.CopyTo(newColors, newVerts);
                addedMeshes[i].tangents.CopyTo(newTangents, newVerts);

                for (int n = newTris; n < newTris + addedMeshes[i].triangles.Length; n++)
                {
                    newTriangles[n] = addedMeshes[i].triangles[n - newTris] + newVerts;
                }


                for (int n = 0; n < addedMeshes[i].subMeshes.Count; n++)
                {
                    for (int x = submeshTrisCount[n]; x < submeshTrisCount[n] + addedMeshes[i].subMeshes[n].Length; x++)
                    {
                        newSubmeshes[n][x] = addedMeshes[i].subMeshes[n][x - submeshTrisCount[n]] + newVerts;
                    }
                    submeshTrisCount[n] += addedMeshes[i].subMeshes[n].Length;
                }
                newTris += addedMeshes[i].triangles.Length;
                newVerts += addedMeshes[i].vertexCount;
            }

            vertices = newVertices;
            normals = newNormals;
            uv = newUvs;
            uv2 = newUvs2;
            uv3 = newUvs3;
            uv4 = newUvs4;
            colors = newColors;
            tangents = newTangents;
            triangles = newTriangles;
            subMeshes = newSubmeshes;
        }

        public static TS_Mesh Copy(TS_Mesh input)
        {
            TS_Mesh result = new TS_Mesh();
            result.vertices = new Vector3[input.vertices.Length];
            input.vertices.CopyTo(result.vertices, 0);
            result.normals = new Vector3[input.normals.Length];
            input.normals.CopyTo(result.normals, 0);
            result.uv = new Vector2[input.uv.Length];
            input.uv.CopyTo(result.uv, 0);
            result.uv2 = new Vector2[input.uv2.Length];
            input.uv2.CopyTo(result.uv2, 0);
            result.uv3 = new Vector2[input.uv3.Length];
            input.uv3.CopyTo(result.uv3, 0);
            result.uv4 = new Vector2[input.uv4.Length];
            input.uv4.CopyTo(result.uv4, 0);
            result.colors = new Color[input.colors.Length];
            input.colors.CopyTo(result.colors, 0);
            result.tangents = new Vector4[input.tangents.Length];
            input.tangents.CopyTo(result.tangents, 0);
            result.triangles = new int[input.triangles.Length];
            input.triangles.CopyTo(result.triangles, 0);
            result.subMeshes = new List<int[]>();
            for(int i = 0; i < input.subMeshes.Count; i++)
            {
                result.subMeshes.Add(new int[input.subMeshes[i].Length]);
                input.subMeshes[i].CopyTo(result.subMeshes[i], 0);
            }
            result.bounds = new TS_Bounds(input.bounds.center, input.bounds.size);
            result.indexFormat = input.indexFormat;
            return result;
        }

        public void Absorb(TS_Mesh input)
        {
            if (vertices.Length != input.vertexCount) vertices = new Vector3[input.vertexCount];
            if (normals.Length != input.normals.Length) normals = new Vector3[input.normals.Length];
            if (colors.Length != input.colors.Length) colors = new Color[input.colors.Length];
            if (uv.Length != input.uv.Length) uv = new Vector2[input.uv.Length];
            if (uv2.Length != input.uv2.Length) uv2 = new Vector2[input.uv2.Length];
            if (uv3.Length != input.uv3.Length) uv3 = new Vector2[input.uv3.Length];
            if (uv4.Length != input.uv4.Length) uv4 = new Vector2[input.uv4.Length];
            if (tangents.Length != input.tangents.Length) tangents = new Vector4[input.tangents.Length];
            if (triangles.Length != input.triangles.Length) triangles = new int[input.triangles.Length];

            input.vertices.CopyTo(vertices, 0);
            input.normals.CopyTo(normals, 0);
            input.colors.CopyTo(colors, 0);
            input.uv.CopyTo(uv, 0);
            input.uv2.CopyTo(uv2, 0);
            input.uv3.CopyTo(uv3, 0);
            input.uv4.CopyTo(uv4, 0);
            input.tangents.CopyTo(tangents, 0);
            input.triangles.CopyTo(triangles, 0);

            if (subMeshes.Count == input.subMeshes.Count)
            {
                for (int i = 0; i < subMeshes.Count; i++)
                {
                    if (input.subMeshes[i].Length != subMeshes[i].Length) subMeshes[i] = new int[input.subMeshes[i].Length];
                    input.subMeshes[i].CopyTo(subMeshes[i], 0);
                }
            }
            else
            {
                subMeshes = new List<int[]>();
                for (int i = 0; i < input.subMeshes.Count; i++)
                {
                    subMeshes.Add(new int[input.subMeshes[i].Length]);
                    input.subMeshes[i].CopyTo(subMeshes[i], 0);
                }
            }
            bounds = new TS_Bounds(input.bounds.center, input.bounds.size);
        }

        public void WriteMesh(ref Mesh input)
        {
            if (input == null) input = new Mesh();
            input.Clear();
            input.indexFormat = indexFormat;
            input.vertices = vertices;
            input.normals = normals;
            if (tangents.Length == vertices.Length) input.tangents = tangents;
            if (colors.Length == vertices.Length) input.colors = colors;
            if (uv.Length == vertices.Length) input.uv = uv;
            if (uv2.Length == vertices.Length) input.uv2 = uv2;
            if (uv3.Length == vertices.Length) input.uv3 = uv3;
            if (uv4.Length == vertices.Length) input.uv4 = uv4;
            input.triangles = triangles;
            if (subMeshes.Count > 0)
            {
                input.subMeshCount = subMeshes.Count;
                for (int i = 0; i < subMeshes.Count; i++)
                {
                    input.SetTriangles(subMeshes[i], i);
                }
            }
            input.RecalculateBounds();
            hasUpdate = false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Mesh.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Transform.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c22a5076c8dce1b40a2a12e5bc7abc69
# ASMDEF: Dreamteck.Utilities.dll
# ---
using UnityEngine;
using System.Collections;

namespace Dreamteck
{
    [System.Serializable]
    public class TS_Transform
    {
        public Vector3 position
        {
            get { return new Vector3(posX, posY, posZ); }
            set
            {
                setPosition = true;
                setLocalPosition = false;
                posX = value.x;
                posY = value.y;
                posZ = value.z;
            }
        }
        public Quaternion rotation
        {
            get { return new Quaternion(rotX, rotY, rotZ, rotW); }
            set
            {
                setRotation = true;
                setLocalRotation = false;
                rotX = value.x;
                rotY = value.y;
                rotZ = value.z;
                rotW = value.w;
            }
        }
        public Vector3 scale
        {
            get { return new Vector3(scaleX, scaleY, scaleZ); }
            set
            {
                setScale = true;
                scaleX = value.x;
                scaleY = value.y;
                scaleZ = value.z;
            }
        }

        public Vector3 lossyScale
        {
            get { return new Vector3(lossyScaleX, lossyScaleY, lossyScaleZ); }
            set
            {
                setScale = true;
                lossyScaleX = value.x;
                lossyScaleY = value.y;
                lossyScaleZ = value.z;
            }
        }

        public Vector3 localPosition
        {
            get { return new Vector3(lposX, lposY, lposZ); }
            set
            {
                setLocalPosition = true;
                setPosition = false;
                lposX = value.x;
                lposY = value.y;
                lposZ = value.z;
            }
        }
        public Quaternion localRotation
        {
            get { return new Quaternion(lrotX, lrotY, lrotZ, lrotW); }
            set
            {
                setLocalRotation = true;
                setRotation = false;
                lrotX = value.x;
                lrotY = value.y;
                lrotZ = value.z;
                lrotW = value.w;
            }
        }

        private bool setPosition = false;
        private bool setRotation = false;
        private bool setScale = false;
        private bool setLocalPosition = false;
        private bool setLocalRotation = false;

        public Transform transform
        {
            get
            {
                return _transform;
            }
        }

        [SerializeField]
        [HideInInspector]
        private Transform _transform;

        [SerializeField]
        [HideInInspector]
        private volatile float posX = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float posY = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float posZ = 0f;

        [SerializeField]
        [HideInInspector]
        private volatile float scaleX = 1f;
        [SerializeField]
        [HideInInspector]
        private volatile float scaleY = 1f;
        [SerializeField]
        [HideInInspector]
        private volatile float scaleZ = 1f;

        [SerializeField]
        [HideInInspector]
        private volatile float lossyScaleX = 1f;
        [SerializeField]
        [HideInInspector]
        private volatile float lossyScaleY = 1f;
        [SerializeField]
        [HideInInspector]
        private volatile float lossyScaleZ = 1f;

        [SerializeField]
        [HideInInspector]
        private volatile float rotX = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float rotY = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float rotZ = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float rotW = 0f;


        [SerializeField]
        [HideInInspector]
        private volatile float lposX = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float lposY = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float lposZ = 0f;

        [SerializeField]
        [HideInInspector]
        private volatile float lrotX = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float lrotY = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float lrotZ = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float lrotW = 0f;
#if UNITY_EDITOR
        private volatile bool isPlaying = false;
#endif

        public TS_Transform(Transform input)
        {
            SetTransform(input);
        }

        /// <summary>
        /// Update the TS_Transform. Call this regularly on every frame you need it to update. Should ALWAYS be called from the main thread
        /// </summary>
        public void Update()
        {
            if (transform == null) return;
#if UNITY_EDITOR
            isPlaying = Application.isPlaying;
#endif
            if (setPosition) _transform.position = position;
            else if (setLocalPosition) _transform.localPosition = localPosition;
            else
            {
                position = _transform.position;
                localPosition = _transform.localPosition;
            }

            if (setScale) _transform.localScale = scale;
            else scale = _transform.localScale;
            lossyScale = _transform.lossyScale;
            

            if (setRotation) _transform.rotation = rotation;
            else if (setLocalRotation) _transform.localRotation = localRotation;
            else
            {
                rotation = _transform.rotation;
                localRotation = _transform.localRotation;
            }
            setPosition = setLocalPosition = setRotation = setLocalRotation = setScale = false;
        }

        /// <summary>
        /// Set the transform reference. Should ALWAYS be called from the main thread
        /// </summary>
        /// <param name="input">Transform reference</param>
        public void SetTransform(Transform input)
        {
            _transform = input;
            setPosition = setLocalPosition = setRotation = setLocalRotation = setScale = false;
            Update();
        }

        /// <summary>
        /// Returns true if there's any change in the transform. Should ALWAYS be called from the main thread
        /// </summary>
        /// <returns></returns>
        public bool HasChange()
        {
            return HasPositionChange() || HasRotationChange() || HasScaleChange();
        }

        /// <summary>
        /// Returns true if there's a change in the position. Should ALWAYS be called from the main thread
        /// </summary>
        /// <returns></returns>
        public bool HasPositionChange()
        {
            return posX != _transform.position.x || posY != _transform.position.y || posZ != _transform.position.z;
        }

        /// <summary>
        /// Returns true if there is a change in the rotation. Should ALWAYS be called from the main thread
        /// </summary>
        /// <returns></returns>
        public bool HasRotationChange()
        {
            return rotX != _transform.rotation.x || rotY != _transform.rotation.y || rotZ != _transform.rotation.z || rotW != _transform.rotation.w;
        }

        /// <summary>
        /// Returns true if there is a change in the scale. Should ALWAYS be called from the main thread
        /// </summary>
        /// <returns></returns>
        public bool HasScaleChange()
        {
            return lossyScaleX != _transform.lossyScale.x || lossyScaleY != _transform.lossyScale.y || lossyScaleZ != _transform.lossyScale.z;
        }

        /// <summary>
        /// Thread-safe TransformPoint
        /// </summary>
        /// <param name="point"></param>
        /// <returns></returns>
        public Vector3 TransformPoint(Vector3 point)
        {
#if UNITY_EDITOR
            if (!isPlaying) return transform.TransformPoint(point);
#endif
            Vector3 scaled = new Vector3(point.x * lossyScaleX, point.y * lossyScaleY, point.z * lossyScaleZ);
            Vector3 rotated = rotation * scaled;
            return position + rotated;
        }

        /// <summary>
        /// Thread-safe TransformDirection
        /// </summary>
        /// <param name="direction"></param>
        /// <returns></returns>
        public Vector3 TransformDirection(Vector3 direction)
        {
#if UNITY_EDITOR
            if (!isPlaying) return transform.TransformDirection(direction);
#endif
            return TransformPoint(direction) - position;
        }

        /// <summary>
        /// Thread-safe InverseTransformPoint
        /// </summary>
        /// <param name="point"></param>
        /// <returns></returns>
        public Vector3 InverseTransformPoint(Vector3 point)
        {
#if UNITY_EDITOR
            if (!isPlaying) return transform.InverseTransformPoint(point);
#endif
            return InverseTransformDirection(point - position);
        }

        /// <summary>
        /// Thread-safe InverseTransformDirection
        /// </summary>
        /// <param name="direction"></param>
        /// <returns></returns>
        public Vector3 InverseTransformDirection(Vector3 direction)
        {
#if UNITY_EDITOR
            if (!isPlaying) return transform.InverseTransformDirection(direction);
#endif
            Vector3 rotated = Quaternion.Inverse(rotation) * direction;
            return new Vector3(rotated.x / lossyScaleX, rotated.y / lossyScaleY, rotated.z / lossyScaleZ);
        }

        public T GetComponent<T>()
        {
            return _transform.GetComponent<T>();
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Transform.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Utilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6d12765602d6ee04cbcfeb790254c378
# ASMDEF: Dreamteck.Utilities.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Utilities
{
    public static class Utilities
    {
        public static T SerializableClone<T>(this T obj)
        {
            return JsonUtility.FromJson<T>(JsonUtility.ToJson(obj));
        }

        public static void Shuffle<T>(this IList<T> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = UnityEngine.Random.Range(0, n + 1);
                list.Swap(k, n);
            }
        }
        public static void RemoveAtUnsorted<T>(this List<T> list, int i)
        {
            var last = list.Count - 1;
            list[i--] = list[last];
            list.RemoveAt(last);
        }

        public static T PopLast<T>(this IList<T> list)
        {
            T last = list[list.Count - 1];
            list.RemoveAt(list.Count - 1);
            return last;
        }

        public static void Swap<T>(this IList<T> list, int left, int right)
        {
            T value = list[left];
            list[left] = list[right];
            list[right] = value;
        }

        public static void SafeInvoke(this Delegate del, params object[] parameters)
        {
            foreach (var handler in del.GetInvocationList())
            {
                try
                {
                    handler.Method.Invoke(handler.Target, parameters);
                }
                catch (Exception exception)
                {
                    Debug.LogException(exception);
                }
            }
        }

        public static T PopRandom<T>(this List<T> list)
        {
            if (list.Count > 0)
            {
                int index = UnityEngine.Random.Range(0, list.Count);
                T element = list[index];
                list.RemoveAt(index);
                return element;
            }

            throw new ArgumentException("Attempting to remove an element from an empty list");
        }

        public static bool HasCommandLineArgument(string name)
        {
            var args = Environment.GetCommandLineArgs();
            for (int i = 0; i < args.Length; i++)
            {
                if (args[i] == name)
                {
                    return true;
                }
            }
            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Utilities.cs

