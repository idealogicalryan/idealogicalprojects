# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGBoundsGroup.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 75d63101243298e4e90c40319e35d557
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.DevTools;
using UnityEngine;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Helper class used by VolumeSpots and others
    /// </summary>
    [System.Serializable]
    public class CGBoundsGroup : CGWeightedItem
    {
        /// <summary>
        /// How the rotation axes are defined related to the Volume's data
        /// </summary>
        public enum RotationModeEnum
        {
            /// <summary>
            /// Use Volume's direction and orientation
            /// </summary>
            Full,
            /// <summary>
            /// Use Volume's direction only
            /// </summary>
            Direction,
            /// <summary>
            /// Use Volume's direction only after projecting it on XZ plane
            /// </summary>
            Horizontal,
            /// <summary>
            /// Do not use Volume's data
            /// </summary>
            Independent
        }

        #region ### Serialized Fields ###
        [SerializeField] private string m_Name;
        [SerializeField]
        [Tooltip("When checked, the group will only be placed when all the group's items can be placed in the space left")]
        private bool m_KeepTogether;
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_SpaceBefore = new FloatRegion() { SimpleValue = true };
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_SpaceAfter = new FloatRegion() { SimpleValue = true };
        [SerializeField]
        //BUG Tooltip and FloatRegion are not compatible [Tooltip("Shifts the Cross origin for this group by a value in the defined range")]
        [FloatRegion(RegionIsOptional = true, RegionOptionsPropertyName = nameof(PositionRangeOptions), UseSlider = true, Precision = 3)]
        private FloatRegion m_CrossBase = new FloatRegion(0);
        [SerializeField]
        [Tooltip("If ticked, the Cross origin for this group will not take into consideration the Cross parameters in the General tab")]
        private bool m_IgnoreModuleCrossBase = false;

        [SerializeField]
        [Tooltip("When enabled, items will be selected randomly")]
        private bool m_RandomizeItems;

        [IntRegion(UseSlider = false, RegionOptionsPropertyName = nameof(RepeatingGroupsOptions), Options = AttributeOptionsFlags.Compact)]
        [SerializeField]
        [Tooltip("The randomized items are the the ones that have their indices inside this range")]
        private IntRegion m_RepeatingItems;

        //Translation
        [SerializeField]
        [Tooltip("If unchecked, translation will be done in the global/world space")]
        private bool m_RelativeTranslation = true;
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_TranslationX = new FloatRegion(0);
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_TranslationY = new FloatRegion(0);
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_TranslationZ = new FloatRegion(0);

        //Rotation
        [SerializeField]
        [Tooltip("How the rotation axes are defined related to the Volume's data\r\n  - Full : Use Volume's direction and orientation\r\n  - Direction : Use Volume's direction only\r\n  - Horizontal : Use Volume's direction only after projecting it on XZ plane\r\n  - Independent : Do not use Volume's data")]
        private RotationModeEnum m_RotationMode = RotationModeEnum.Full;

        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_RotationX = new FloatRegion(0);
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_RotationY = new FloatRegion(0);
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_RotationZ = new FloatRegion(0);

        //Scale
        [SerializeField]
        [Tooltip("Whether the scaling is applied equally on all dimensions")]
        private bool m_UniformScaling = true;
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_ScaleX = new FloatRegion(1);
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_ScaleY = new FloatRegion(1);
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_ScaleZ = new FloatRegion(1);

        [SerializeField] private List<CGBoundsGroupItem> m_Items = new List<CGBoundsGroupItem>();

        #endregion

        #region ### Public Members ###

        public string Name
        {
            get { return m_Name; }
            set
            {
                if (m_Name != value)
                    m_Name = value;
            }
        }

        /// <summary>
        /// When true, the group will only be placed when all items can be placed in the space left. 
        /// </summary>
        public bool KeepTogether
        {
            get { return m_KeepTogether; }
            set
            {
                if (m_KeepTogether != value)
                    m_KeepTogether = value;
            }
        }

        public FloatRegion SpaceBefore
        {
            get { return m_SpaceBefore; }
            set
            {
                if (m_SpaceBefore != value)
                    m_SpaceBefore = value;
            }
        }

        public FloatRegion SpaceAfter
        {
            get { return m_SpaceAfter; }
            set
            {
                if (m_SpaceAfter != value)
                    m_SpaceAfter = value;
            }
        }

        /// <summary>
        /// When enabled, items in groups will be selected randomly.
        /// <seealso cref="RepeatingItems"/>
        /// </summary>
        public bool RandomizeItems
        {
            get { return m_RandomizeItems; }
            set
            {
                if (m_RandomizeItems != value)
                    m_RandomizeItems = value;
            }
        }

        /// <summary>
        /// When <seealso cref="RandomizeItems"/> is set to true, the randomized items are the the ones that have their indices inside the RepeatingItems range
        /// </summary>
        public IntRegion RepeatingItems
        {
            get { return m_RepeatingItems; }
            set
            {
                if (m_RepeatingItems != value)
                    m_RepeatingItems = value;
            }
        }

        /// <summary>
        /// Shifts the Cross origin for this group by a value in the defined range
        /// </summary>
        public FloatRegion CrossBase
        {
            get { return m_CrossBase; }
            set
            {
                if (m_CrossBase != value)
                    m_CrossBase = value;
            }
        }

        /// <summary>
        /// If true, the Cross origin for this group will not take into consideration the Cross parameters of the BuildVolumeSpots class/>
        /// </summary>
        public bool IgnoreModuleCrossBase
        {
            get { return m_IgnoreModuleCrossBase; }
            set
            {
                if (m_IgnoreModuleCrossBase != value)
                    m_IgnoreModuleCrossBase = value;
            }
        }

        /// <summary>
        /// How the rotation axes are defined related to the Volume's data
        /// </summary>
        public RotationModeEnum RotationMode
        {
            get { return m_RotationMode; }
            set
            {
                if (m_RotationMode != value)
                    m_RotationMode = value;
            }
        }

        public FloatRegion RotationX
        {
            get { return m_RotationX; }
            set
            {
                if (m_RotationX != value)
                    m_RotationX = value;
            }
        }
        public FloatRegion RotationY
        {
            get { return m_RotationY; }
            set
            {
                if (m_RotationY != value)
                    m_RotationY = value;
            }
        }
        public FloatRegion RotationZ
        {
            get { return m_RotationZ; }
            set
            {
                if (m_RotationZ != value)
                    m_RotationZ = value;
            }
        }

        /// <summary>
        /// When true, the scaling vector is (ScaleX, ScaleX, ScaleX) instead of (ScaleX, ScaleY, ScaleZ)
        /// </summary>
        public bool UniformScaling
        {
            get { return m_UniformScaling; }
            set
            {
                if (m_UniformScaling != value)
                    m_UniformScaling = value;
            }
        }
        public FloatRegion ScaleX
        {
            get { return m_ScaleX; }
            set
            {
                if (m_ScaleX != value)
                    m_ScaleX = value;
            }
        }
        public FloatRegion ScaleY
        {
            get { return m_ScaleY; }
            set
            {
                if (m_ScaleY != value)
                    m_ScaleY = value;
            }
        }
        public FloatRegion ScaleZ
        {
            get { return m_ScaleZ; }
            set
            {
                if (m_ScaleZ != value)
                    m_ScaleZ = value;
            }
        }
        /// <summary>
        /// When true, the translation of an item is done in the relative frame defined by the tangent and orientation (up vector) of the volume at the item's position
        /// </summary>
        public bool RelativeTranslation
        {
            get { return m_RelativeTranslation; }
            set
            {
                if (m_RelativeTranslation != value)
                    m_RelativeTranslation = value;
            }
        }
        public FloatRegion TranslationX
        {
            get { return m_TranslationX; }
            set
            {
                if (m_TranslationX != value)
                    m_TranslationX = value;
            }
        }
        public FloatRegion TranslationY
        {
            get { return m_TranslationY; }
            set
            {
                if (m_TranslationY != value)
                    m_TranslationY = value;
            }
        }
        public FloatRegion TranslationZ
        {
            get { return m_TranslationZ; }
            set
            {
                if (m_TranslationZ != value)
                    m_TranslationZ = value;
            }
        }

        public List<CGBoundsGroupItem> Items
        {
            get { return m_Items; }
        }

        /// <summary>
        /// First index of the <see cref="RepeatingItems"/> range
        /// </summary>
        public int FirstRepeating
        {
            get { return m_RepeatingItems.From; }
            set
            {
                int v = Mathf.Clamp(value, 0, Mathf.Max(0, ItemCount - 1));
                if (m_RepeatingItems.From != v)
                    m_RepeatingItems.From = v;
            }
        }

        /// <summary>
        /// Last index of the <see cref="RepeatingItems"/> range
        /// </summary>
        public int LastRepeating
        {
            get { return m_RepeatingItems.To; }
            set
            {
                int v = Mathf.Clamp(value, FirstRepeating, Mathf.Max(0, ItemCount - 1));
                if (m_RepeatingItems.To != v)
                    m_RepeatingItems.To = v;
            }
        }

        public int ItemCount
        {
            get { return Items.Count; }
        }

        public CGBoundsGroup(string name)
        {
            Name = name;
        }

        /// <summary>
        /// Fill an item bag with items based on their weights
        /// </summary>
        public static void FillItemBag(WeightedRandom<int> bag, IEnumerable<CGWeightedItem> itemsWeights, int firstItem, int lastItem)
        {
            for (int g = firstItem; g <= lastItem; g++)
                bag.Add(g, (int)(itemsWeights.ElementAt(g).Weight * 10));

            if (bag.Size == 0)
                bag.Add(firstItem, 1);
        }

        #endregion

        #region Non Public Members

        private RegionOptions<int> RepeatingGroupsOptions
        {
            get
            {
                return RegionOptions<int>.MinMax(0, Mathf.Max(0, ItemCount - 1));
            }
        }

        private RegionOptions<float> PositionRangeOptions
        {
            get
            {
                return RegionOptions<float>.MinMax(-1f, 1f);
            }
        }
        #endregion

        #region Obsolete code kept for retrocompatibility
        [Obsolete("Enum no more used by Curvy. This enum is kept for retro compatibility reasons")]
        private enum DistributionModeEnum
        {
            Parent,
            Self
        }

#pragma warning disable 649
        [SerializeField, HideInInspector]
        [Obsolete("Use IgnoreModuleCrossBase instead. This field is kept for retro compatibility reasons")]
        private DistributionModeEnum m_DistributionMode;

        [SerializeField, HideInInspector]
        [Obsolete("Use CrossBase instead. This field is kept for retro compatibility reasons")]
        [FloatRegion(RegionIsOptional = true, RegionOptionsPropertyName = nameof(PositionRangeOptions), UseSlider = true, Precision = 3)]
        private FloatRegion m_PositionOffset = new FloatRegion(0);

        [SerializeField, HideInInspector]
        [Obsolete("Use TranslationY instead, while setting RelativeTranslation to true. This field is kept for retro compatibility reasons")]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_Height = new FloatRegion(0);

        [SerializeField, HideInInspector]
        [Obsolete("Use RandomizeItems instead. This field is kept for retro compatibility reasons")]
        private CurvyRepeatingOrderEnum m_RepeatingOrder = CurvyRepeatingOrderEnum.Row;

        [SerializeField, HideInInspector]
        [Obsolete("Use RotationX, RotationY and RotationZ instead. This field is kept for retro compatibility reasons")]
        [VectorEx]
        private Vector3 m_RotationOffset;

        [SerializeField, HideInInspector]
        [Obsolete("Use RotationX, RotationY and RotationZ instead. This field is kept for retro compatibility reasons")]
        [VectorEx]
        private Vector3 m_RotationScatter;
#pragma warning restore 649

        /// <summary>
        /// Converts the obsolete data to the new format
        /// </summary>
        [Obsolete("Method will get removed once the obsolete data will get removed")]
        public void ConvertObsoleteData()
        {
            RandomizeItems = m_RepeatingOrder == CurvyRepeatingOrderEnum.Random;
            IgnoreModuleCrossBase = m_DistributionMode == DistributionModeEnum.Self;
            CrossBase = m_PositionOffset;
            if (m_Height.From != 0f || (m_Height.SimpleValue == false && m_Height.To != 0f))
            {
                TranslationY = m_Height;
                RelativeTranslation = true;
            }

            {
                float from = m_RotationOffset.x - m_RotationScatter.x;
                float to = m_RotationOffset.x + m_RotationScatter.x;
                RotationX = from == to ? new FloatRegion(from) : new FloatRegion(from, to);
            }

            {
                float from = m_RotationOffset.y - m_RotationScatter.y;
                float to = m_RotationOffset.y + m_RotationScatter.y;
                RotationY = from == to ? new FloatRegion(from) : new FloatRegion(from, to);
            }

            {
                float from = m_RotationOffset.z - m_RotationScatter.z;
                float to = m_RotationOffset.z + m_RotationScatter.z;
                RotationZ = from == to ? new FloatRegion(from) : new FloatRegion(from, to);
            }
        }
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGBoundsGroup.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGClasses.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a2040f930733ca34783e346013036c51
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Generator
{
    #region ### CGModule related ###

    /// <summary>
    /// Yes,No,Auto Enum
    /// </summary>
    public enum CGYesNoAuto
    {
        Yes,
        No,
        Auto
    }

    /// <summary>
    /// Which entity an operation refers to: either an object itself or its source
    /// </summary>
    public enum CGReferenceMode
    {
        Source,
        Self
    }

    /// <summary>
    /// Aspect Mode correction modes enum
    /// </summary>
    public enum CGKeepAspectMode
    {
        /// <summary>
        ///  No Aspect correction is applied
        /// </summary>
        Off,
        /// <summary>
        /// U is scaled to keep texel size proportional
        /// </summary>
        ScaleU,
        /// <summary>
        /// V is scaled to keep texel size proportional
        /// </summary>
        ScaleV
    }

    public enum CGColliderEnum
    {
        None,
        Mesh,
        Box,
        Sphere,
        Capsule
    }

    /// <summary>
    /// Spots are used to place objects (like meshes or Game Objects) A spot is defined by spacial coordinates (similar to Transform) and the index of the object to place
    /// </summary>
    [System.Serializable]
    public struct CGSpot : IEquatable<CGSpot>
    {
        [SerializeField]
        [Label("Index")]
        private int m_Index;
        [SerializeField]
        [VectorEx("Position", Options = AttributeOptionsFlags.Compact, Precision = 4)]
        private Vector3 m_Position;
        [SerializeField]
        [VectorEx("Rotation", Options = AttributeOptionsFlags.Compact, Precision = 4)]
        private Quaternion m_Rotation;
        [SerializeField]
        [VectorEx("Scale", Options = AttributeOptionsFlags.Compact, Precision = 4)]
        private Vector3 m_Scale;

        /// <summary>
        /// The index of the object to place
        /// </summary>
        public int Index
        {
            get { return m_Index; }
        }

        /// <summary>
        /// Gets or sets the position
        /// </summary>
        public Vector3 Position
        {
            get { return m_Position; }
            set
            {
                if (m_Position != value)
                    m_Position = value;
            }
        }

        /// <summary>
        /// Gets or sets the rotation
        /// </summary>
        public Quaternion Rotation
        {
            get { return m_Rotation; }
            set
            {
                if (m_Rotation != value)
                    m_Rotation = value;
            }
        }

        /// <summary>
        /// Gets or sets the scale
        /// </summary>
        public Vector3 Scale
        {
            get { return m_Scale; }
            set
            {
                if (m_Scale != value)
                    m_Scale = value;
            }
        }

        /// <summary>
        /// Gets a TRS matrix using Position, Rotation, Scale
        /// </summary>
        public Matrix4x4 Matrix
        {
            get { return Matrix4x4.TRS(m_Position, m_Rotation, m_Scale); }
        }

        public CGSpot(int index) : this(index, Vector3.zero, Quaternion.identity, Vector3.one) { }

        public CGSpot(int index, Vector3 position, Quaternion rotation, Vector3 scale)
        {
            m_Index = index;
            m_Position = position;
            m_Rotation = rotation;
            m_Scale = scale;
        }

        /// <summary>
        /// Sets a transform to match Position, Rotation, Scale in local space
        /// </summary>
        /// <param name="transform"></param>
        public void ToTransform(Transform transform)
        {
            transform.localPosition = Position;
            transform.localRotation = Rotation;
            transform.localScale = Scale;
        }

        public bool Equals(CGSpot other)
        {
            return m_Index == other.m_Index && m_Position.Equals(other.m_Position) && m_Rotation.Equals(other.m_Rotation) && m_Scale.Equals(other.m_Scale);
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
                return false;
            return obj is CGSpot && Equals((CGSpot)obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hashCode = m_Index;
                hashCode = (hashCode * 397) ^ m_Position.GetHashCode();
                hashCode = (hashCode * 397) ^ m_Rotation.GetHashCode();
                hashCode = (hashCode * 397) ^ m_Scale.GetHashCode();
                return hashCode;
            }
        }

        public static bool operator ==(CGSpot left, CGSpot right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(CGSpot left, CGSpot right)
        {
            return !left.Equals(right);
        }
    }

    /// <summary>
    /// An <see cref="IComparer"/> that compares instances of <see cref="CGSpot"/> based on their <see cref="CGSpot.Index"/>
    /// </summary>
    public class CGSpotComparer : IComparer
    {
        public int Compare(object x, object y)
        {
            return ((CGSpot)x).Index.CompareTo(((CGSpot)y).Index);
        }
    }

    /// <summary>
    /// Helper class used by various Curvy Generator modules
    /// </summary>
    [System.Serializable]
    public class CGMaterialSettings
    {
        public bool SwapUV = false;
        [Tooltip("Options to keep texel size proportional")]
        public CGKeepAspectMode KeepAspect = CGKeepAspectMode.Off;
        public float UVRotation = 0;
        public Vector2 UVOffset = Vector2.zero;
        public Vector2 UVScale = Vector2.one;
    }

    /// <summary>
    /// Helper class used by various Curvy Generator modules
    /// </summary>
    [System.Serializable]
    //Design: get rid of CGMaterialSettingsEx, use CGMaterialSettings instead
    public class CGMaterialSettingsEx : CGMaterialSettings
    {
        [Obsolete("This field is not used anymore, will get remove in a future update")]
        public int MaterialID = 0;
    }

    /// <summary>
    /// Helper class used by InputMesh module
    /// </summary>
    [System.Serializable]
    public class CGMeshProperties
    {
        [SerializeField] private Mesh m_Mesh;
        [SerializeField] private Material[] m_Material = new Material[0];
        [SerializeField]
        [VectorEx]
        private Vector3 m_Translation;
        [SerializeField]
        [VectorEx]
        private Vector3 m_Rotation;
        [SerializeField]
        [VectorEx]
        private Vector3 m_Scale = Vector3.one;


        public Mesh Mesh
        {
            get { return m_Mesh; }
            set
            {
                if (m_Mesh != value)
                    m_Mesh = value;
                if (m_Mesh && m_Mesh.subMeshCount != m_Material.Length)
                    System.Array.Resize(ref m_Material, m_Mesh.subMeshCount);
            }
        }
        public Material[] Material
        {
            get { return m_Material; }
            set
            {
                if (m_Material != value)
                    m_Material = value;
            }
        }

        public Vector3 Translation
        {
            get { return m_Translation; }
            set
            {
                if (m_Translation != value)
                    m_Translation = value;
            }
        }

        public Vector3 Rotation
        {
            get { return m_Rotation; }
            set
            {
                if (m_Rotation != value)
                    m_Rotation = value;
            }
        }

        public Vector3 Scale
        {
            get { return m_Scale; }
            set
            {
                if (m_Scale != value)
                    m_Scale = value;
            }
        }

        public Matrix4x4 Matrix
        {
            get { return Matrix4x4.TRS(Translation, Quaternion.Euler(Rotation), Scale); }
        }

        public CGMeshProperties() { }

        public CGMeshProperties(Mesh mesh)
        {
            Mesh = mesh;
            Material = (mesh != null) ? new Material[mesh.subMeshCount] : new Material[0];
        }
#if UNITY_EDITOR
        public void OnValidate()
        {
            Mesh = m_Mesh;
            Material = m_Material;
        }
#endif
    }

    /// <summary>
    /// Helper class used by InputGameObject module
    /// </summary>
    [System.Serializable]
    public class CGGameObjectProperties
    {
        [SerializeField] private GameObject m_Object;
        [SerializeField]
        [VectorEx]
        private Vector3 m_Translation;
        [SerializeField]
        [VectorEx]
        private Vector3 m_Rotation;
        [SerializeField]
        [VectorEx]
        private Vector3 m_Scale = Vector3.one;

        public GameObject Object
        {
            get { return m_Object; }
            set
            {
                if (m_Object != value)
                    m_Object = value;
            }
        }

        public Vector3 Translation
        {
            get { return m_Translation; }
            set
            {
                if (m_Translation != value)
                    m_Translation = value;
            }
        }

        public Vector3 Rotation
        {
            get { return m_Rotation; }
            set
            {
                if (m_Rotation != value)
                    m_Rotation = value;
            }
        }

        public Vector3 Scale
        {
            get { return m_Scale; }
            set
            {
                if (m_Scale != value)
                    m_Scale = value;
            }
        }

        public Matrix4x4 Matrix
        {
            get { return Matrix4x4.TRS(Translation, Quaternion.Euler(Rotation), Scale); }
        }

        public CGGameObjectProperties() { }

        public CGGameObjectProperties(GameObject gameObject)
        {
            Object = gameObject;
        }
    }

    /// <summary>
    /// An item that has a weight associated to it
    /// </summary>
    [Serializable]
    public class CGWeightedItem
    {
        [RangeEx(0, 1, Slider = true, Precision = 1)]
        [SerializeField]
        private float m_Weight = 0.5f;

        public float Weight
        {
            get { return m_Weight; }
            set
            {
                float v = Mathf.Clamp01(value);
                if (m_Weight != v)
                    m_Weight = v;
            }
        }
    }

    /// <summary>
    /// Helper class used by VolumeSpots and others
    /// </summary>
    [System.Serializable]
    public class CGBoundsGroupItem : CGWeightedItem
    {
        public int Index;
    }

    #endregion

    #region ### Spline rasterization related ###

    /// <summary>
    /// Rasterization helper
    /// </summary>
    public struct ControlPointOption : IEquatable<ControlPointOption>
    {
        public float TF;
        public float Distance;
        public bool Include;
        public int MaterialID;
        public bool HardEdge;
        public float MaxStepDistance;
        public bool UVEdge;
        /// <summary>
        /// Also known as ExplicitU
        /// </summary>
        public bool UVShift;
        public float FirstU;
        public float SecondU;


        public ControlPointOption(float tf, float dist, bool includeAnyways, int materialID, bool hardEdge, float maxStepDistance, bool uvEdge, bool uvShift, float firstU, float secondU)
        {
            TF = tf;
            Distance = dist;
            Include = includeAnyways;
            MaterialID = materialID;
            HardEdge = hardEdge;
            if (maxStepDistance == 0)
                MaxStepDistance = float.MaxValue;
            else
                MaxStepDistance = maxStepDistance;
            UVEdge = uvEdge;
            UVShift = uvShift;
            FirstU = firstU;
            SecondU = secondU;
        }

        public bool Equals(ControlPointOption other)
        {
            return TF.Equals(other.TF) && Distance.Equals(other.Distance) && Include == other.Include && MaterialID == other.MaterialID && HardEdge == other.HardEdge && MaxStepDistance.Equals(other.MaxStepDistance) && UVEdge == other.UVEdge && UVShift == other.UVShift && FirstU.Equals(other.FirstU) && SecondU.Equals(other.SecondU);
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
                return false;
            return obj is ControlPointOption && Equals((ControlPointOption)obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hashCode = TF.GetHashCode();
                hashCode = (hashCode * 397) ^ Distance.GetHashCode();
                hashCode = (hashCode * 397) ^ Include.GetHashCode();
                hashCode = (hashCode * 397) ^ MaterialID;
                hashCode = (hashCode * 397) ^ HardEdge.GetHashCode();
                hashCode = (hashCode * 397) ^ MaxStepDistance.GetHashCode();
                hashCode = (hashCode * 397) ^ UVEdge.GetHashCode();
                hashCode = (hashCode * 397) ^ UVShift.GetHashCode();
                hashCode = (hashCode * 397) ^ FirstU.GetHashCode();
                hashCode = (hashCode * 397) ^ SecondU.GetHashCode();
                return hashCode;
            }
        }

        public static bool operator ==(ControlPointOption left, ControlPointOption right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(ControlPointOption left, ControlPointOption right)
        {
            return !left.Equals(right);
        }
    }

    /// <summary>
    /// A patch of vertices to be connected by triangles (i.e. same Material and no hard edges within a patch)
    /// </summary>
    /// <remarks>The index values refer to rasterized points of CGShape</remarks>
    public struct SamplePointsPatch : IEquatable<SamplePointsPatch>
    {
        /// <summary>
        /// First Sample Point Index of the patch
        /// </summary>
        public int Start;
        /// <summary>
        /// Number of Sample Points of the patch
        /// </summary>
        public int Count;

        /// <summary>
        /// Last Sample Point Index of the patch
        /// </summary>
        public int End
        {
            get { return Start + Count; }
            set
            {
                Count = Mathf.Max(0, value - Start);
            }
        }

        public int TriangleCount
        {
            get
            {
                return Count * 2;
            }
        }


        public SamplePointsPatch(int start)
        {
            Start = start;
            Count = 0;
        }

        public override string ToString()
        {
            return string.Format(System.Globalization.CultureInfo.InvariantCulture, "Size={0} ({1}-{2}, {3} Tris)", Count, Start, End, TriangleCount);
        }

        public bool Equals(SamplePointsPatch other)
        {
            return Start == other.Start && Count == other.Count;
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
                return false;
            return obj is SamplePointsPatch && Equals((SamplePointsPatch)obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return (Start * 397) ^ Count;
            }
        }

        public static bool operator ==(SamplePointsPatch left, SamplePointsPatch right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(SamplePointsPatch left, SamplePointsPatch right)
        {
            return !left.Equals(right);
        }
    }

    /// <summary>
    /// A section of one or more patches, all sharing the same MaterialID
    /// </summary>
    public class SamplePointsMaterialGroup
    {
        public int MaterialID;

        public List<SamplePointsPatch> Patches;

        public int TriangleCount
        {
            get
            {
                int cnt = 0;
                for (int p = 0; p < Patches.Count; p++)
                    cnt += Patches[p].TriangleCount;
                return cnt;
            }
        }

        public int StartVertex
        {
            get
            {
                return Patches[0].Start;
            }
        }

        public int EndVertex
        {
            get
            {
                return Patches[Patches.Count - 1].End;
            }
        }

        public int VertexCount
        {
            get
            {
                return EndVertex - StartVertex + 1;
            }
        }

        public SamplePointsMaterialGroup(int materialID) : this(materialID, new List<SamplePointsPatch>())
        {
        }

        public SamplePointsMaterialGroup(int materialID, List<SamplePointsPatch> patches)
        {
            MaterialID = materialID;
            Patches = patches;
        }

        public void GetLengths(CGVolume volume, out float worldLength, out float uLength)
        {
            worldLength = 0;
            for (int v = StartVertex; v < EndVertex; v++)
                worldLength += (volume.Vertices.Array[v + 1] - volume.Vertices.Array[v]).magnitude;
            uLength = volume.CrossCustomValues.Array[EndVertex] - volume.CrossCustomValues.Array[StartVertex];
        }

        /// <summary>
        /// Returns a clone of the current instance.
        /// </summary>
        public SamplePointsMaterialGroup Clone()
        {
            return new SamplePointsMaterialGroup(MaterialID, new List<SamplePointsPatch>(Patches));
        }
    }

    /// <summary>
    /// Data about duplicated points, meaning a couple of points sharing the same position. Such duplicated points are used to store different normals or different U coordinates at the same position
    /// </summary>
    public readonly struct DuplicateSamplePoint : IEquatable<DuplicateSamplePoint>
    {
        /// <summary>
        /// The index of the first point
        /// </summary>
        public int StartIndex { get; }
        /// <summary>
        /// The index of the second point
        /// </summary>
        public int EndIndex { get; }
        /// <summary>
        /// When true, both points don't share the same normal
        /// </summary>
        public bool IsHardEdge { get; }

        public DuplicateSamplePoint(int startIndex, int endIndex, bool isHardEdge)
        {
            StartIndex = startIndex;
            EndIndex = endIndex;
            IsHardEdge = isHardEdge;
        }

        public bool Equals(DuplicateSamplePoint other)
        {
            return StartIndex == other.StartIndex && EndIndex == other.EndIndex && IsHardEdge == other.IsHardEdge;
        }

        public override bool Equals(object obj)
        {
            return obj is DuplicateSamplePoint other && Equals(other);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hashCode = StartIndex;
                hashCode = (hashCode * 397) ^ EndIndex;
                hashCode = (hashCode * 397) ^ IsHardEdge.GetHashCode();
                return hashCode;
            }
        }

        public static bool operator ==(DuplicateSamplePoint left, DuplicateSamplePoint right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(DuplicateSamplePoint left, DuplicateSamplePoint right)
        {
            return !left.Equals(right);
        }

        public override string ToString()
        {
            return $"{nameof(StartIndex)}: {StartIndex}, {nameof(EndIndex)}: {EndIndex}, {nameof(IsHardEdge)}: {IsHardEdge}";
        }
    }


    public struct SamplePointUData : IEquatable<SamplePointUData>
    {
        public int Vertex;
        public bool UVEdge;
        public bool HardEdge;
        public float FirstU;
        public float SecondU;

        [Obsolete("Use other constructors")]
        public SamplePointUData(int vertexIndex, bool uvEdge, float firstU, float secondU) : this(vertexIndex, uvEdge, false, firstU, secondU)
        {
        }

        public SamplePointUData(int vertexIndex, bool uvEdge, bool hardEdge, float firstU, float secondU)
        {
            Vertex = vertexIndex;
            UVEdge = uvEdge;
            HardEdge = hardEdge;
            FirstU = firstU;
            SecondU = secondU;
        }

        public SamplePointUData(int vertexIndex, ControlPointOption controlPointsOption) : this(
            vertexIndex,
            controlPointsOption.UVEdge,
            controlPointsOption.HardEdge,
            controlPointsOption.FirstU,
            controlPointsOption.SecondU
        )
        {
        }


        public override string ToString()
        {
            return string.Format(System.Globalization.CultureInfo.InvariantCulture, "SamplePointUData (Vertex={0}, UVEdge={1}, HardEdge={4}, FirstU={2}, SecondU={3}", Vertex, UVEdge, FirstU, SecondU, HardEdge);
        }

        public bool Equals(SamplePointUData other)
        {
            return Vertex == other.Vertex && UVEdge == other.UVEdge && HardEdge == other.HardEdge && FirstU.Equals(other.FirstU) && SecondU.Equals(other.SecondU);
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
                return false;
            return obj is SamplePointUData && Equals((SamplePointUData)obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hashCode = Vertex;
                hashCode = (hashCode * 397) ^ UVEdge.GetHashCode();
                hashCode = (hashCode * 397) ^ HardEdge.GetHashCode();
                hashCode = (hashCode * 397) ^ FirstU.GetHashCode();
                hashCode = (hashCode * 397) ^ SecondU.GetHashCode();
                return hashCode;
            }
        }

        public static bool operator ==(SamplePointUData left, SamplePointUData right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(SamplePointUData left, SamplePointUData right)
        {
            return !left.Equals(right);
        }
    }

    #endregion


    /// <summary>
    /// List of Material Groups
    /// </summary>
    public class SamplePointsMaterialGroupCollection : List<SamplePointsMaterialGroup>
    {
        public int TriangleCount
        {
            get
            {
                int cnt = 0;
                for (int g = 0; g < this.Count; g++)
                    cnt += this[g].TriangleCount;
                return cnt;
            }
        }

        public int MaterialID;

        [Obsolete("Use AspectCorrectionV instead")]
        public float AspectCorrection
        {
            get => AspectCorrectionV;
            set => AspectCorrectionV = value;
        }

        /// <summary>
        /// A multiplication applied on the U coordinate as part of the aspect correction
        /// </summary>
        public float AspectCorrectionU = 1;

        /// <summary>
        /// A multiplication applied on the V coordinate as part of the aspect correction
        /// </summary>
        public float AspectCorrectionV = 1;

        public SamplePointsMaterialGroupCollection() : base() { }
        public SamplePointsMaterialGroupCollection(int capacity) : base(capacity) { }
        public SamplePointsMaterialGroupCollection(IEnumerable<SamplePointsMaterialGroup> collection) : base(collection) { }

        public void CalculateAspectCorrection(CGVolume volume, CGMaterialSettingsEx matSettings)
        {
            switch (matSettings.KeepAspect)
            {
                case CGKeepAspectMode.Off:
                    AspectCorrectionV = 1;
                    AspectCorrectionU = 1;
                    break;
                case CGKeepAspectMode.ScaleU:
                case CGKeepAspectMode.ScaleV:
                    {
                        float crossLength = 0;
                        float uLength = 0;
                        for (int g = 0; g < Count; g++)
                        {
                            float length, u;
                            this[g].GetLengths(volume, out length, out u);
                            crossLength += length;
                            uLength += u;
                        }

                        if (matSettings.KeepAspect == CGKeepAspectMode.ScaleU)
                        {
                            AspectCorrectionV = 1;
                            AspectCorrectionU = crossLength / volume.Length;
                        }
                        else
                        {
                            AspectCorrectionV = volume.Length * uLength / crossLength;
                            AspectCorrectionU = 1;
                        }
                    }
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }

    /// <summary>
    /// Class referencing a particular module's output slot
    /// </summary>
    /// <remarks>When using, be sure to add the <see cref="CGDataReferenceSelectorAttribute"/> to the field</remarks>
    [System.Serializable]
    public class CGDataReference
    {
        [SerializeField] private CGModule m_Module;
        [SerializeField] private string m_SlotName;

        private CGModuleOutputSlot mSlot;

        public CGData[] Data
        {
            get
            {
                return (Slot != null) ? Slot.Data : new CGData[0];
            }
        }

        public CGModuleOutputSlot Slot
        {
            get
            {
                if ((mSlot == null || mSlot.Module != m_Module || mSlot.Info == null || mSlot.Info.Name != m_SlotName) && m_Module != null && m_Module.Generator != null && m_Module.Generator.IsInitialized && !string.IsNullOrEmpty(m_SlotName))
                {
                    mSlot = m_Module.GetOutputSlot(m_SlotName);
                }
                return mSlot;
            }
        }

        public bool HasValue
        {
            get
            {
                CGModuleOutputSlot cgModuleOutputSlot = Slot;
                return (cgModuleOutputSlot != null) && cgModuleOutputSlot.Data.Length > 0;
            }
        }

        public bool IsEmpty
        {
            get { return string.IsNullOrEmpty(SlotName); }
        }

        public CGModule Module
        {
            get { return m_Module; }
        }
        public string SlotName
        {
            get { return m_SlotName; }
        }

        public CGDataReference()
        {
        }

        public CGDataReference(CGModule module, string slotName)
        {
            setINTERNAL(module, slotName);
        }

        public CGDataReference(CurvyGenerator generator, string moduleName, string slotName)
        {
            setINTERNAL(generator, moduleName, slotName);
        }

        public void Clear()
        {
            setINTERNAL(null, string.Empty);
        }

        public T GetData<T>() where T : CGData
        {
            return (Data.Length == 0) ? null : Data[0] as T;
        }

        public T[] GetAllData<T>() where T : CGData
        {
            return Data as T[];
        }

        #region ### Privates & Internals ###
        /*! \cond PRIVATE */

        public void setINTERNAL(CGModule module, string slotName)
        {
            m_Module = module;
            m_SlotName = slotName;
            mSlot = null;
        }

        public void setINTERNAL(CurvyGenerator generator, string moduleName, string slotName)
        {
            m_Module = generator.GetModule(moduleName, false);
            m_SlotName = slotName;
            mSlot = null;
        }

        /*! \endcond */
        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGClasses.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1e4fde665d7cfa546a1c391d055728ec
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools.Extensions;
using System;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Runtime.CompilerServices;
using FluffyUnderware.Curvy.Pools;
using ToolBuddy.Pooling.Pools;
using FluffyUnderware.DevTools;
using JetBrains.Annotations;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;
using UnityEngine.Rendering;

#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif




namespace FluffyUnderware.Curvy.Generator
{
    //TODO replace all the misuse of the F concept here, where it should really be RelativeDistance 

    /// <summary>
    /// Additional properties for CGData based classes
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class CGDataInfoAttribute : Attribute
    {
        public readonly Color Color;

        public CGDataInfoAttribute(Color color)
        {
            Color = color;
        }

        public CGDataInfoAttribute(float r, float g, float b, float a = 1)
        {
            Color = new Color(r, g, b, a);
        }

        public CGDataInfoAttribute(string htmlColor)
        {
            Color = htmlColor.ColorFromHtml();
        }
    }

    /// <summary>
    /// Data Base class
    /// </summary>
    public class CGData : IDisposable
    {
        #region Dispose pattern

        private bool disposed = false;

        protected virtual bool Dispose(bool disposing)
        {
            if (disposed)
            {
                DTLog.LogWarning("[Curvy] Attempt to dispose a CGData twice. Please raise a bug report.");
                return false;
            }

            disposed = true;
            return true;
        }

        /// <summary>
        /// Disposes an instance that is no more used, allowing it to free its resources immediately.
        /// Dispose is called automatically when an instance is <see cref="Finalize"/>d
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~CGData()
        {
            Dispose(false);
        }

        #endregion

        public string Name;

        public virtual int Count
        {
            get { return 0; }
        }

        public static implicit operator bool(CGData a)
        {
            return !ReferenceEquals(a, null);
        }

        public virtual T Clone<T>() where T : CGData
        {
            return new CGData() as T;
        }

        /// <summary>
        /// Searches FMapArray and returns the index that covers the fValue as well as the percentage between index and index+1
        /// </summary>
        /// <param name="FMapArray">array of sorted values ranging from 0..1</param>
        /// <param name="fValue">a value 0..1</param>
        /// <param name="frag">fragment between the resulting and the next index (0..1)</param>
        /// <returns>the index where fValue lies in</returns>
        protected int getGenericFIndex(SubArray<float> FMapArray, float fValue, out float frag)
        {
            //WARNING this method is inlined in DeformMesh, if you modify something here modify it there too
            int index = CurvyUtility.InterpolationSearch(FMapArray.Array, FMapArray.Count, fValue);

            if (index == FMapArray.Count - 1)
            {
                index -= 1;
                frag = 1;
            }
            else
                frag = (fValue - FMapArray.Array[index]) / (FMapArray.Array[index + 1] - FMapArray.Array[index]);

            return index;
        }
    }

    /// <summary>
    /// Rasterized Shape Data (Polyline)
    /// </summary>
    [CGDataInfo(0.73f, 0.87f, 0.98f)]
    public class CGShape : CGData
    {
        /// <summary>
        /// The relative distance of each point.
        /// A relative distance is a value between 0 and 1 representing how far the point is in a shape.
        /// A value of 0 means the start of the shape, and a value of 1 means the end of it.
        /// It is defined as (the point's distance from the shape's start) / (the total length of the shape)
        /// This is unrelated to the notion of <seealso cref="CurvySplineSegment.TF"/> or F of a spline.
        /// Unfortunately, it is abusively called F in big parts of the the Curvy Generator related code, sorry for the confusion.
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<float> RelativeDistances
        {
            get => relativeDistances;
            set
            {
                ArrayPools.Single.Free(relativeDistances);
                relativeDistances = value;
            }
        }

        /// <summary>
        /// The relative distance of each point relative to the source shape.
        /// A relative distance is a value between 0 and 1 representing how far the point is in a shape.
        /// A value of 0 means the start of the shape, and a value of 1 means the end of it.
        /// It is defined as (the point's distance from the shape's start) / (the total length of the shape)
        /// Contrary to <seealso cref="RelativeDistances"/> which is computed based on the actual shape, SourceRelativeDistances is computed based on the source shape.
        /// For example, if a Shape A is defined as the second quarter of a Shape B, A's first point will have a relative distance of 0, but a source relative distance of 0.25. A's last point will have a relative distance of 1, but a source relative distance of 0.5
        /// This is unrelated to the notion of <seealso cref="CurvySplineSegment.TF"/> or F of a spline.
        /// Unfortunately, it is abusively called F in big parts of the the Curvy Generator related code, sorry for the confusion.
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<float> SourceRelativeDistances
        {
            get => sourceRelativeDistances;
            set
            {
                ArrayPools.Single.Free(sourceRelativeDistances);
                sourceRelativeDistances = value;
            }
        }

        /// <summary>
        /// Positions of the path's points, in the path's local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector3> Positions
        {
            get => positions;
            set
            {
                ArrayPools.Vector3.Free(positions);
                positions = value;
            }
        }

        /// <summary>
        /// Normals of the path's points, in the path's local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector3> Normals
        {
            get => normals;
            set
            {
                ArrayPools.Vector3.Free(normals);
                normals = value;
            }
        }

        /// <summary>
        /// Arbitrary mapped value to each point, usually U coordinate
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<float> CustomValues
        {
            get => customValues;
            set
            {
                ArrayPools.Single.Free(customValues);
                customValues = value;
            }
        }

        /// <summary>
        /// The list of the shape's <see cref="DuplicatePoints"/>
        /// </summary>
        public List<DuplicateSamplePoint> DuplicatePoints { get; set; }

        #region Obsolete

        /// <summary>
        /// The relative distance of each point.
        /// A relative distance is a value between 0 and 1 representing how far the point is in a shape.
        /// A value of 0 means the start of the shape, and a value of 1 means the end of it.
        /// It is defined as (the point's distance from the shape's start) / (the total length of the shape)
        /// This is unrelated to the notion of <seealso cref="CurvySplineSegment.TF"/> or F of a spline.
        /// Unfortunately, it is abusively called F in big parts of the the Curvy Generator related code, sorry for the confusion.
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use RelativeDistances instead")]
        public float[] F
        {
            get => RelativeDistances.CopyToArray(ArrayPools.Single);
            set => RelativeDistances = new SubArray<float>(value);
        }

        /// <summary>
        /// The relative distance of each point relative to the source shape.
        /// A relative distance is a value between 0 and 1 representing how far the point is in a shape.
        /// A value of 0 means the start of the shape, and a value of 1 means the end of it.
        /// It is defined as (the point's distance from the shape's start) / (the total length of the shape)
        /// Contrary to <seealso cref="RelativeDistances"/> which is computed based on the actual shape, SourceRelativeDistances is computed based on the source shape.
        /// For example, if a Shape A is defined as the second quarter of a Shape B, A's first point will have a relative distance of 0, but a source relative distance of 0.25. A's last point will have a relative distance of 1, but a source relative distance of 0.5
        /// This is unrelated to the notion of <seealso cref="CurvySplineSegment.TF"/> or F of a spline.
        /// Unfortunately, it is abusively called F in big parts of the the Curvy Generator related code, sorry for the confusion.
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use SourceRelativeDistances instead")]
        public float[] SourceF
        {
            get => SourceRelativeDistances.CopyToArray(ArrayPools.Single);
            set => SourceRelativeDistances = new SubArray<float>(value);
        }

        /// <summary>
        /// Positions of the path's points, in the path's local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use Positions instead")]
        public Vector3[] Position
        {
            get => Positions.CopyToArray(ArrayPools.Vector3);
            set => Positions = new SubArray<Vector3>(value);
        }

        /// <summary>
        /// Normals of the path's points, in the path's local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use Normals instead")]
        public Vector3[] Normal
        {
            get => Normals.CopyToArray(ArrayPools.Vector3);
            set => Normals = new SubArray<Vector3>(value);
        }

        /// <summary>
        /// Arbitrary mapped value to each point, usually U coordinate
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use CustomValues instead")]
        public float[] Map
        {
            get => CustomValues.CopyToArray(ArrayPools.Single);
            set => CustomValues = new SubArray<float>(value);
        }

        #endregion

        /// <summary>
        /// Groups/Patches
        /// </summary>
        public List<SamplePointsMaterialGroup> MaterialGroups;
        /// <summary>
        /// Whether the source is managed or not
        /// </summary>
        /// <remarks>This could be used to determine if values needs to be transformed into generator space or not</remarks>
        public bool SourceIsManaged;
        /// <summary>
        /// Whether the base spline is closed or not
        /// </summary>
        public bool Closed;
        /// <summary>
        /// Whether the Shape/Path is seamless, i.e. Closed==true and the whole length is covered
        /// </summary>
        public bool Seamless;
        /// <summary>
        /// Length in world units
        /// </summary>
        public float Length;

        /// <summary>
        /// Gets the number of sample points
        /// </summary>
        public override int Count
        {
            get { return relativeDistances.Count; }
        }

        #region ### Private fields ###

        //TODO Debug time checks that F arrays contain values between 0 and 1
        private SubArray<float> relativeDistances;
        //OPTIM can the storage of this array be avoided by storing only SourceF and the start and end Distance, and infer F values only when needed?
        //OPTIM can we just assign SourceF to F when start and end distances are equal to respectively 0 and 1? (which is the case most of the time)
        private SubArray<float> sourceRelativeDistances;
        private SubArray<Vector3> positions;
        private SubArray<Vector3> normals;
        /*TODO Map is defined in CGShape but:
        1- filling it inside an instance of CGPath (which inherits from CGShape) is useless, since Map is used only by CGVolume when it takes it from a CGShape, and not a CGPath. So an optimization would be to not fill Map for instances not consumed by CGVolume
        2- I hope that storing it might be not needed, and calculating it only when needed might be possible
       */
        private SubArray<float> customValues;

        // Caching
        //TODO DESIGN OPTIM are these still needed, now that GetFIndex was greatly optimized?
        private float mCacheLastF = float.MaxValue;
        private int mCacheLastIndex;
        private float mCacheLastFrag;

        #endregion

        public CGShape() : base()
        {
            sourceRelativeDistances = ArrayPools.Single.Allocate(0);
            relativeDistances = ArrayPools.Single.Allocate(0);
            positions = ArrayPools.Vector3.Allocate(0);
            normals = ArrayPools.Vector3.Allocate(0);
            customValues = ArrayPools.Single.Allocate(0);
            DuplicatePoints = new List<DuplicateSamplePoint>();
            MaterialGroups = new List<SamplePointsMaterialGroup>();
        }

        public CGShape(CGShape source) : base()
        {
            positions = ArrayPools.Vector3.Clone(source.positions);
            normals = ArrayPools.Vector3.Clone(source.normals);
            customValues = ArrayPools.Single.Clone(source.customValues);
            DuplicatePoints = new List<DuplicateSamplePoint>(source.DuplicatePoints);
            relativeDistances = ArrayPools.Single.Clone(source.relativeDistances);
            sourceRelativeDistances = ArrayPools.Single.Clone(source.sourceRelativeDistances);
            MaterialGroups = new List<SamplePointsMaterialGroup>(source.MaterialGroups.Count);
            foreach (SamplePointsMaterialGroup materialGroup in source.MaterialGroups)
                MaterialGroups.Add(materialGroup.Clone());
            Closed = source.Closed;
            Seamless = source.Seamless;
            Length = source.Length;
            SourceIsManaged = source.SourceIsManaged;
        }

        protected override bool Dispose(bool disposing)
        {
            bool result = base.Dispose(disposing);
            if (result)
            {
                ArrayPools.Single.Free(sourceRelativeDistances);
                ArrayPools.Single.Free(relativeDistances);
                ArrayPools.Vector3.Free(positions);
                ArrayPools.Vector3.Free(normals);
                ArrayPools.Single.Free(customValues);
            }

            return result;
        }

        public override T Clone<T>()
        {
            return new CGShape(this) as T;
        }

        public static void Copy(CGShape dest, CGShape source)
        {
            ArrayPools.Vector3.Resize(ref dest.positions, source.positions.Count);
            Array.Copy(source.positions.Array, 0, dest.positions.Array, 0, source.positions.Count);
            ArrayPools.Vector3.Resize(ref dest.normals, source.normals.Count);
            Array.Copy(source.normals.Array, 0, dest.normals.Array, 0, source.normals.Count);
            ArrayPools.Single.Resize(ref dest.customValues, source.customValues.Count);
            Array.Copy(source.customValues.Array, 0, dest.customValues.Array, 0, source.customValues.Count);
            ArrayPools.Single.Resize(ref dest.relativeDistances, source.relativeDistances.Count);
            Array.Copy(source.relativeDistances.Array, 0, dest.relativeDistances.Array, 0, source.relativeDistances.Count);
            ArrayPools.Single.Resize(ref dest.sourceRelativeDistances, source.sourceRelativeDistances.Count);
            Array.Copy(source.sourceRelativeDistances.Array, 0, dest.sourceRelativeDistances.Array, 0, source.sourceRelativeDistances.Count);
            dest.DuplicatePoints.Clear();
            dest.DuplicatePoints.AddRange(source.DuplicatePoints);
            dest.MaterialGroups = source.MaterialGroups.Select(g => g.Clone()).ToList();
            dest.Closed = source.Closed;
            dest.Seamless = source.Seamless;
            dest.Length = source.Length;
        }

        //TODO documentation and whatnot
        public void Copy(CGShape source) { Copy(this, source); }

        /// <summary>
        /// Converts absolute (World Units) to relative (F) distance
        /// </summary>
        /// <param name="distance">distance in world units</param>
        /// <returns>Relative distance (0..1)</returns>
        public float DistanceToF(float distance)
        {
            return Mathf.Clamp(distance, 0, Length) / Length;
        }

        /// <summary>
        /// Converts relative (F) to absolute distance (World Units)
        /// </summary>
        /// <param name="f">relative distance (0..1)</param>
        /// <returns>Distance in World Units</returns>
        public float FToDistance(float f)
        {
            return Mathf.Clamp01(f) * Length;
        }

        /// <summary>
        /// Gets the index of a certain F
        /// </summary>
        /// <param name="f">F (0..1)</param>
        /// <param name="frag">fragment between the resulting and the next index (0..1)</param>
        /// <returns>the resulting index</returns>
        public int GetFIndex(float f, out float frag)
        {
#if CURVY_SANITY_CHECKS_PRIVATE
            Assert.IsTrue(f >= 0);
            if (f > 1)
                Debug.LogWarning(f);
#endif
            if (mCacheLastF != f)
            {
                mCacheLastF = f;
                //OPTIM make sure f is a ratio, then remove the following line
                float fValue = f == 1 ? f : f % 1;
                mCacheLastIndex = getGenericFIndex(relativeDistances, fValue, out mCacheLastFrag);
            }
            frag = mCacheLastFrag;

            return mCacheLastIndex;
        }

        /*
        /// <summary>
        /// Gets the index of a certain SourceF
        /// </summary>
        /// <param name="sourceF">F (0..1)</param>
        /// <param name="frag">fragment between the resulting and the next index (0..1)</param>
        /// <returns>the resulting index</returns>
        public int GetSourceFIndex(float sourceF, out float frag)
        {
            if (mCacheLastSourceF != sourceF)
            {
                mCacheLastSourceF = sourceF;

                mCacheLastSourceIndex = getGenericFIndex(ref F, sourceF, out mCacheLastSourceFrag);
            }
            frag = mCacheLastSourceFrag;
            return mCacheLastSourceIndex;
        }
        */
        /// <summary>
        /// Interpolates Position by F
        /// </summary>
        /// <param name="f">0..1</param>
        /// <returns>the interpolated position</returns>
        public Vector3 InterpolatePosition(float f)
        {
            float frag;
            int idx = GetFIndex(f, out frag);
            return OptimizedOperators.LerpUnclamped(positions.Array[idx], positions.Array[idx + 1], frag);
        }

        /// <summary>
        /// Interpolates Normal by F
        /// </summary>
        /// <param name="f">0..1</param>
        /// <returns>the interpolated normal</returns>
        public Vector3 InterpolateUp(float f)
        {
            float frag;
            int idx = GetFIndex(f, out frag);
            return Vector3.SlerpUnclamped(normals.Array[idx], normals.Array[idx + 1], frag);
        }

        /// <summary>
        /// Interpolates Position and Normal by F
        /// </summary>
        /// <param name="f">0..1</param>
        /// <param name="position"></param>
        /// <param name="up">a.k.a normal</param>
        public void Interpolate(float f, out Vector3 position, out Vector3 up)
        {
            float frag;
            int idx = GetFIndex(f, out frag);
            position = OptimizedOperators.LerpUnclamped(positions.Array[idx], positions.Array[idx + 1], frag);
            up = Vector3.SlerpUnclamped(normals.Array[idx], normals.Array[idx + 1], frag);
        }

        public void Move(ref float f, ref int direction, float speed, CurvyClamping clamping)
        {
            f = CurvyUtility.ClampTF(f + speed * direction, ref direction, clamping);
        }

        public void MoveBy(ref float f, ref int direction, float speedDist, CurvyClamping clamping)
        {
            float dist = CurvyUtility.ClampDistance(FToDistance(f) + speedDist * direction, ref direction, clamping, Length);
            f = DistanceToF(dist);
        }

        /// <summary>
        /// Recalculate Length and RelativeDistances (by measuring a polyline built from all Position points)
        /// </summary>
        /// <remarks>Call this after TRS'ing a shape</remarks>
        public virtual void Recalculate()
        {
            Length = 0;
            SubArray<float> dist = ArrayPools.Single.Allocate(Count);

            for (int i = 1; i < Count; i++)
            {
                dist.Array[i] = dist.Array[i - 1] + (positions.Array[i].Subtraction(positions.Array[i - 1])).magnitude;

            }

            if (Count > 0)
            {
                Length = dist.Array[Count - 1];
                if (Length > 0)
                {

                    relativeDistances.Array[0] = 0;
                    float oneOnLength = 1 / Length;
                    for (int i = 1; i < Count - 1; i++)
                        relativeDistances.Array[i] = dist.Array[i] * oneOnLength;
                    relativeDistances.Array[Count - 1] = 1;
                }
                else
                {
                    ArrayPools.Single.ResizeAndClear(ref relativeDistances, Count);
                }
            }

            ArrayPools.Single.Free(dist);

            //for (int i = 1; i < Count; i++)
            //    Direction[i] = (Position[i] - Position[i - 1]).normalized;
        }

        [Obsolete("Use another overload of RecalculateNormals instead")]
        public void RecalculateNormals(List<int> softEdges)
        {
            //TODO this implementation works properly with 2D shapes, but creates invalid results with 3D paths. This is ok for now because the code calls it only on shapes, but it is a ticking bomb
            //TODO document the method after fixing it
            if (normals.Count != positions.Count)
            {
                ArrayPools.Vector3.Resize(ref normals, positions.Count);
            }

            for (int mg = 0; mg < MaterialGroups.Count; mg++)
            {
                for (int p = 0; p < MaterialGroups[mg].Patches.Count; p++)
                {
                    SamplePointsPatch patch = MaterialGroups[mg].Patches[p];
                    Vector3 t;
                    for (int vt = 0; vt < patch.Count; vt++)
                    {
                        int x = patch.Start + vt;
                        t = (positions.Array[x + 1] - positions.Array[x]).normalized;
                        normals.Array[x] = new Vector3(-t.y, t.x, 0);
#if CURVY_SANITY_CHECKS_PRIVATE
                        if (normals.Array[x].magnitude.Approximately(1f) == false)
                            Debug.LogError($"Normal is not normalized, length was {normals.Array[x].magnitude}");//happens if shape is not in the XY plane
#endif
                    }
                    t = (positions.Array[patch.End] - positions.Array[patch.End - 1]).normalized;
                    normals.Array[patch.End] = new Vector3(-t.y, t.x, 0);
#if CURVY_SANITY_CHECKS_PRIVATE
                    if (normals.Array[patch.End].magnitude.Approximately(1f) == false)
                        Debug.LogError("Normal is not normalized");//happens if shape is not in the XY plane
#endif
                }
            }

            // Handle soft edges
            for (int i = 0; i < softEdges.Count; i++)
            {
                int previous = softEdges.ToArray()[i] - 1;
                if (previous < 0)
                    previous = positions.Count - 1;

                int beforePrevious = previous - 1;
                if (beforePrevious < 0)
                    beforePrevious = positions.Count - 1;

                int next = softEdges.ToArray()[i] + 1;
                if (next == positions.Count)
                    next = 0;

                normals.Array[softEdges.ToArray()[i]] = Vector3.Slerp(normals.Array[beforePrevious], normals.Array[next], 0.5f);
                normals.Array[previous] = normals.Array[softEdges.ToArray()[i]];
            }
        }

        /// <summary>
        /// Recalculate the shape's <see cref="Normals"/> based on the spline the shape was rasterized from
        /// </summary>
        public void RecalculateNormals([NotNull] CurvySpline spline)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsFalse(spline.Orientation == CurvyOrientation.None);
#endif
            if (normals.Count != positions.Count)
            {
                ArrayPools.Vector3.Resize(ref normals, positions.Count);
            }

            Vector3[] normalsArray = normals.Array;
            float[] floats = SourceRelativeDistances.Array;

            for (int mg = 0; mg < MaterialGroups.Count; mg++)
            {
                for (int p = 0; p < MaterialGroups[mg].Patches.Count; p++)
                {
                    SamplePointsPatch patch = MaterialGroups[mg].Patches[p];
                    for (int vt = 0; vt < patch.Count; vt++)
                    {
                        int x = patch.Start + vt;
                        normalsArray[x] = spline.GetOrientationUpFast(spline.DistanceToTF(spline.Length * floats[x]), Space.Self);
#if CURVY_SANITY_CHECKS_PRIVATE
                        if (normalsArray[x].magnitude.Approximately(1f) == false)
                            Debug.LogError($"Normal is not normalized, length was {normalsArray[x].magnitude}");//happens if shape is not in the XY plane
#endif
                    }

                    normalsArray[patch.End] = spline.GetOrientationUpFast(spline.DistanceToTF(spline.Length * floats[patch.End]), Space.Self);
#if CURVY_SANITY_CHECKS_PRIVATE
                    if (normalsArray[patch.End].magnitude.Approximately(1f) == false)
                        Debug.LogError("Normal is not normalized");//happens if shape is not in the XY plane
#endif
                }
            }

            // Handle soft edges
            foreach (DuplicateSamplePoint duplicateSamplePoint in DuplicatePoints)
            {
                if (duplicateSamplePoint.IsHardEdge)
                {
                    int index = duplicateSamplePoint.StartIndex;
                    normalsArray[index] = normalsArray[Math.Max(0, index - 1)];
                }
            }
        }

        /// <summary>
        /// Recalculate the shape's <see cref="Normals"/> based on shape's rasterized <see cref="Positions"/>
        /// </summary>
        public void RecalculateNormals()
        {
            //TODO this implementation works properly with 2D shapes, but creates invalid results with 3D paths. This is ok for now because the code calls it only on shapes, but it is a ticking bomb
            //TODO document the method after fixing it
            if (normals.Count != positions.Count)
            {
                ArrayPools.Vector3.Resize(ref normals, positions.Count);
            }

            Vector3[] positionsArray = positions.Array;
            Vector3[] normalsArray = normals.Array;

            for (int mg = 0; mg < MaterialGroups.Count; mg++)
            {
                for (int p = 0; p < MaterialGroups[mg].Patches.Count; p++)
                {
                    SamplePointsPatch patch = MaterialGroups[mg].Patches[p];
                    Vector3 t;
                    int x;
                    for (int vt = 0; vt < patch.Count; vt++)
                    {
                        x = patch.Start + vt;
                        t = (positionsArray[x + 1] - positionsArray[x]).normalized;
                        //todo handle case where t = 0
                        normalsArray[x] = new Vector3(-t.y, t.x, 0);
#if CURVY_SANITY_CHECKS_PRIVATE
                        if (normalsArray[x].magnitude.Approximately(1f) == false)
                            Debug.LogError($"Normal is not normalized, length was {normalsArray[x].magnitude}");//happens if shape is not in the XY plane or if length is 0
#endif
                    }
                    t = (positionsArray[patch.End] - positionsArray[patch.End - 1]).normalized;
                    normalsArray[patch.End] = new Vector3(-t.y, t.x, 0);
#if CURVY_SANITY_CHECKS_PRIVATE
                    if (normalsArray[patch.End].magnitude.Approximately(1f) == false)
                        Debug.LogError("Normal is not normalized");//happens if shape is not in the XY plane
#endif
                }
            }

            // Handle soft edges
            foreach (DuplicateSamplePoint duplicateSamplePoint in DuplicatePoints)
            {
                if (duplicateSamplePoint.IsHardEdge == false)
                {
                    int previous = duplicateSamplePoint.EndIndex - 1;
                    if (previous < 0)
                        previous = positions.Count - 1;

                    int beforePrevious = previous - 1;
                    if (beforePrevious < 0)
                        beforePrevious = positions.Count - 1;

                    int next = duplicateSamplePoint.EndIndex + 1;
                    if (next == positions.Count)
                        next = 0;

                    normalsArray[duplicateSamplePoint.EndIndex] = Vector3.Slerp(normalsArray[beforePrevious], normalsArray[next], 0.5f);
                    normalsArray[previous] = normalsArray[duplicateSamplePoint.EndIndex];

                }
            }
        }
    }

    /// <summary>
    /// Path Data (Shape + Direction (Spline Tangents) + Orientation/Up)
    /// </summary>
    [CGDataInfo(0.13f, 0.59f, 0.95f)]
    public class CGPath : CGShape
    {
        /// <summary>
        /// Tangents of the path's points, in the path's local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector3> Directions
        {
            get => directions;
            set
            {
                ArrayPools.Vector3.Free(directions);
                directions = value;
            }
        }

        /// <summary>
        /// Tangents of the path's points, in the path's local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use Directions instead")]
        public Vector3[] Direction
        {
            get => Directions.CopyToArray(ArrayPools.Vector3);
            set => Directions = new SubArray<Vector3>(value);
        }

        private SubArray<Vector3> directions;

        public CGPath() : base()
        {
            directions = ArrayPools.Vector3.Allocate(0);
        }
        public CGPath(CGPath source) : base(source)
        {
            directions = ArrayPools.Vector3.Clone(source.directions);
        }

        protected override bool Dispose(bool disposing)
        {
            bool result = base.Dispose(disposing);
            if (result)
                ArrayPools.Vector3.Free(directions);
            return result;
        }

        public override T Clone<T>()
        {
            return new CGPath(this) as T;
        }

        public static void Copy(CGPath dest, CGPath source)
        {
            CGShape.Copy(dest, source);
            ArrayPools.Vector3.Resize(ref dest.directions, source.directions.Count);
            Array.Copy(source.directions.Array, 0, dest.directions.Array, 0, source.directions.Count);
        }

        /// <summary>
        /// Interpolates Position, Direction and Normal by F
        /// </summary>
        /// <param name="f">0..1</param>
        /// <param name="position"></param>
        /// <param name="direction">a.k.a tangent</param>
        /// <param name="up">a.k.a normal</param>
        public void Interpolate(float f, out Vector3 position, out Vector3 direction, out Vector3 up)
        {
            float frag;
            int idx = GetFIndex(f, out frag);
            position = OptimizedOperators.LerpUnclamped(Positions.Array[idx], Positions.Array[idx + 1], frag);
            direction = Vector3.SlerpUnclamped(directions.Array[idx], directions.Array[idx + 1], frag);
            up = Vector3.SlerpUnclamped(Normals.Array[idx], Normals.Array[idx + 1], frag);
        }

        [Obsolete("Method is no more used by Curvy and will get removed. Copy its content if you still need it")]
        public void Interpolate(float f, float angleF, out Vector3 pos, out Vector3 dir, out Vector3 up)
        {
            Interpolate(f, out pos, out dir, out up);
            if (angleF != 0)
            {
                Quaternion R = Quaternion.AngleAxis(angleF * -360, dir);
                up = R * up;
            }
        }

        /// <summary>
        /// Interpolates Direction by F
        /// </summary>
        /// <param name="f">0..1</param>
        public Vector3 InterpolateDirection(float f)
        {
            float frag;
            int idx = GetFIndex(f, out frag);
            return Vector3.SlerpUnclamped(directions.Array[idx], directions.Array[idx + 1], frag);
        }
    }

    /// <summary>
    /// Volume Data (Path + Vertex, VertexNormal, Cross)
    /// </summary>
    [CGDataInfo(0.08f, 0.4f, 0.75f)]
    public class CGVolume : CGPath
    {
        /// <summary>
        /// Positions of the points, in the local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector3> Vertices
        {
            get => vertices;
            set
            {
                ArrayPools.Vector3.Free(vertices);
                vertices = value;
            }
        }

        /// <summary>
        /// Notmals of the points, in the local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector3> VertexNormals
        {
            get => vertexNormals;
            set
            {
                ArrayPools.Vector3.Free(vertexNormals);
                vertexNormals = value;
            }
        }

        /// <summary>
        /// The <see cref="CGShape.F"/> of the <see cref="CGShape"/> used in the extrusion of this volume
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<float> CrossRelativeDistances
        {
            get => crossRelativeDistances;
            set
            {
                ArrayPools.Single.Free(crossRelativeDistances);
                crossRelativeDistances = value;
            }
        }

        /// <summary>
        /// The <see cref="CGShape.CustomValues"/> of the <see cref="CGShape"/> used in the extrusion of this volume
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<float> CrossCustomValues
        {
            get => crossCustomValues;
            set
            {
                ArrayPools.Single.Free(crossCustomValues);
                crossCustomValues = value;
            }
        }

        /// <summary>
        /// The 2D scale of the mesh at each sample point of the volume's path
        /// </summary>
        public SubArray<Vector2> Scales
        {
            get => scales;
            set
            {
                ArrayPools.Vector2.Free(scales);
                scales = value;
            }
        }

        #region Obsolete

        /// <summary>
        /// Positions of the points, in the local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use Vertices instead")]
        public Vector3[] Vertex
        {
            get => Vertices.CopyToArray(ArrayPools.Vector3);
            set => Vertices = new SubArray<Vector3>(value);
        }

        /// <summary>
        /// Normals of the points, in the local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use VertexNormals instead")]
        public Vector3[] VertexNormal
        {
            get => VertexNormals.CopyToArray(ArrayPools.Vector3);
            set => VertexNormals = new SubArray<Vector3>(value);
        }

        /// <summary>
        /// The <see cref="CGShape.F"/> of the <see cref="CGShape"/> used in the extrusion of this volume
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use CrossRelativeDistances instead")]
        public float[] CrossF
        {
            get => CrossRelativeDistances.CopyToArray(ArrayPools.Single);
            set => CrossRelativeDistances = new SubArray<float>(value);
        }

        /// <summary>
        /// The <see cref="CGShape.CustomValues"/> of the <see cref="CGShape"/> used in the extrusion of this volume
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use CrossCustomValues instead")]
        public float[] CrossMap
        {
            get => CrossCustomValues.CopyToArray(ArrayPools.Single);
            set => CrossCustomValues = new SubArray<float>(value);
        }

        #endregion

        /// <summary>
        /// Length of a given cross segment. Will be calculated on demand only!
        /// </summary>
        [Obsolete("Do not use this. Use the GetCrossLength method instead")]
        public float[] SegmentLength
        {
            get
            {
                if (_segmentLength == null)
                    _segmentLength = new float[Count];
                return _segmentLength;
            }
            set => _segmentLength = value;
        }

        /// <summary>
        /// Gets the number of cross shape's sample points
        /// </summary>
        public int CrossSize { get { return crossRelativeDistances.Count; } }
        /// <summary>
        /// Whether the Cross base spline is closed or not
        /// </summary>
        public bool CrossClosed;//TODO make obsolete then remove this, it is not needed by Curvy
        /// <summary>
        /// Whether the Cross shape covers the whole length of the base spline
        /// </summary>
        public bool CrossSeamless;
        /// <summary>
        /// A shift of the <see cref="CrossRelativeDistances"/> value that is applied when using the interpolation methods on the volume, like <see cref="InterpolateVolume"/>
        /// </summary>
        public float CrossFShift;

        public SamplePointsMaterialGroupCollection CrossMaterialGroups;

        public int VertexCount { get { return vertices.Count; } }

        #region private fields

        private SubArray<Vector3> vertices;
        private SubArray<Vector3> vertexNormals;
        private SubArray<float> crossRelativeDistances;
        private SubArray<float> crossCustomValues;
        private SubArray<Vector2> scales;
        [Obsolete("Do not use this. Use the GetCrossLength method instead")]
        private float[] _segmentLength;

        #endregion

        #region ### Constructors ###

        [Obsolete("Use one of the other constructors")]
        public CGVolume() : base() { }

        public CGVolume(int samplePoints, CGShape crossShape) : base()
        {
            crossRelativeDistances = ArrayPools.Single.Clone(crossShape.RelativeDistances);
            crossCustomValues = ArrayPools.Single.Clone(crossShape.CustomValues);
            scales = ArrayPools.Vector2.Allocate(samplePoints);
            CrossClosed = crossShape.Closed;
            CrossSeamless = crossShape.Seamless;
            CrossMaterialGroups = new SamplePointsMaterialGroupCollection(crossShape.MaterialGroups);
            vertices = ArrayPools.Vector3.Allocate(CrossSize * samplePoints);
            vertexNormals = ArrayPools.Vector3.Allocate(vertices.Count);
        }

        public CGVolume(CGPath path, CGShape crossShape)
            : base(path)
        {
            crossRelativeDistances = ArrayPools.Single.Clone(crossShape.RelativeDistances);
            crossCustomValues = ArrayPools.Single.Clone(crossShape.CustomValues);
            scales = ArrayPools.Vector2.Allocate(Count);
            CrossClosed = crossShape.Closed;
            CrossSeamless = crossShape.Seamless;
            CrossMaterialGroups = new SamplePointsMaterialGroupCollection(crossShape.MaterialGroups);
            vertices = ArrayPools.Vector3.Allocate(CrossSize * Count);
            vertexNormals = ArrayPools.Vector3.Allocate(vertices.Count);
        }

        public CGVolume(CGVolume source)
            : base(source)
        {
            vertices = ArrayPools.Vector3.Clone(source.vertices);
            vertexNormals = ArrayPools.Vector3.Clone(source.vertexNormals);
            crossRelativeDistances = ArrayPools.Single.Clone(source.crossRelativeDistances);
            crossCustomValues = ArrayPools.Single.Clone(source.crossCustomValues);
            scales = ArrayPools.Vector2.Clone(source.scales);
            CrossClosed = source.Closed;
            CrossSeamless = source.CrossSeamless;
            CrossFShift = source.CrossFShift;
            CrossMaterialGroups = new SamplePointsMaterialGroupCollection(source.CrossMaterialGroups);
        }

        #endregion

        protected override bool Dispose(bool disposing)
        {
            bool result = base.Dispose(disposing);
            if (result)
            {
                ArrayPools.Vector3.Free(vertices);
                ArrayPools.Vector3.Free(vertexNormals);
                ArrayPools.Single.Free(crossRelativeDistances);
                ArrayPools.Single.Free(crossCustomValues);
                ArrayPools.Vector2.Free(scales);
#pragma warning disable 618
                if (SegmentLength != null)
                    ArrayPools.Single.Free(SegmentLength);
#pragma warning restore 618
            }

            return result;
        }

        /// <summary>
        /// Returns a CGVolume made from the given CGPath and CGShape
        /// </summary>
        /// <param name="data">If not null, the returned instance will be the one but with its fields updated. If null, a new instance will be created</param>
        /// <param name="path">The path used in the creation of the volume</param>
        /// <param name="crossShape">The shape used in the creation of the volume</param>
        /// <returns></returns>
        public static CGVolume Get(CGVolume data, CGPath path, CGShape crossShape)
        {
            if (data == null)
                return new CGVolume(path, crossShape);

            Copy(data, path);

#pragma warning disable 618
            if (data._segmentLength != null)
                data.SegmentLength = new float[data.Count];
#pragma warning restore 618

            // Volume
            ArrayPools.Single.Resize(ref data.crossRelativeDistances, crossShape.RelativeDistances.Count, false);
            Array.Copy(crossShape.RelativeDistances.Array, 0, data.crossRelativeDistances.Array, 0, crossShape.RelativeDistances.Count);

            ArrayPools.Single.Resize(ref data.crossCustomValues, crossShape.CustomValues.Count, false);
            Array.Copy(crossShape.CustomValues.Array, 0, data.crossCustomValues.Array, 0, crossShape.CustomValues.Count);

            ArrayPools.Vector2.Resize(ref data.scales, path.Count, false);

            data.CrossClosed = crossShape.Closed;
            data.CrossSeamless = crossShape.Seamless;
            data.CrossMaterialGroups = new SamplePointsMaterialGroupCollection(crossShape.MaterialGroups);
            ArrayPools.Vector3.Resize(ref data.vertices, data.CrossSize * data.Positions.Count, false);
            ArrayPools.Vector3.Resize(ref data.vertexNormals, data.vertices.Count, false);
            return data;
        }


        public override T Clone<T>()
        {
            return new CGVolume(this) as T;
        }



        public void InterpolateVolume(float f, float crossF, out Vector3 pos, out Vector3 dir, out Vector3 up)
        {
            float frag;
            float cfrag;
            int v0Idx = GetVertexIndex(f, crossF, out frag, out cfrag);

            // (2)-(3)
            //  | \ |
            // (0)-(1)
            Vector3 xd, zd;
            Vector3 v0 = vertices.Array[v0Idx];
            Vector3 v1 = vertices.Array[v0Idx + 1];
            Vector3 v2 = vertices.Array[v0Idx + CrossSize];

            if (frag + cfrag > 1)
            {
                Vector3 v3 = vertices.Array[v0Idx + CrossSize + 1];
                xd = v3 - v2;
                zd = v3 - v1;
                pos = v2 - zd * (1 - frag) + xd * (cfrag);
            }
            else
            {
                xd = v1 - v0;
                zd = v2 - v0;
                pos = v0 + zd * frag + xd * cfrag;
            }

            dir = zd.normalized;
            up = Vector3.Cross(zd, xd);
        }

        public Vector3 InterpolateVolumePosition(float f, float crossF)
        {
            float frag;
            float cfrag;
            int v0Idx = GetVertexIndex(f, crossF, out frag, out cfrag);
            // (2)-(3)
            //  | \ |
            // (0)-(1)
            Vector3 xd, zd;
            Vector3 v0 = vertices.Array[v0Idx];
            Vector3 v1 = vertices.Array[v0Idx + 1];
            Vector3 v2 = vertices.Array[v0Idx + CrossSize];

            if (frag + cfrag > 1)
            {
                Vector3 v3 = vertices.Array[v0Idx + CrossSize + 1];
                xd = v3 - v2;
                zd = v3 - v1;
                return v2 - zd * (1 - frag) + xd * (cfrag);
            }
            else
            {
                xd = v1 - v0;
                zd = v2 - v0;
                return v0 + zd * frag + xd * cfrag;
            }
        }

        public Vector3 InterpolateVolumeDirection(float f, float crossF)
        {
            float frag;
            float cfrag;
            int v0Idx = GetVertexIndex(f, crossF, out frag, out cfrag);

            // (2)-(3)
            //  | \ |
            // (0)-(1)
            if (frag + cfrag > 1)
            {
                Vector3 v1 = vertices.Array[v0Idx + 1];
                Vector3 v3 = vertices.Array[v0Idx + CrossSize + 1];
                return (v3 - v1).normalized;
            }
            else
            {
                Vector3 v0 = vertices.Array[v0Idx];
                Vector3 v2 = vertices.Array[v0Idx + CrossSize];
                return (v2 - v0).normalized;
            }

        }

        public Vector3 InterpolateVolumeUp(float f, float crossF)
        {
            float frag;
            float cfrag;
            int v0Idx = GetVertexIndex(f, crossF, out frag, out cfrag);

            // (2)-(3)
            //  | \ |
            // (0)-(1)
            Vector3 xd, zd;

            Vector3 v1 = vertices.Array[v0Idx + 1];
            Vector3 v2 = vertices.Array[v0Idx + CrossSize];

            if (frag + cfrag > 1)
            {
                Vector3 v3 = vertices.Array[v0Idx + CrossSize + 1];
                xd = v3 - v2;
                zd = v3 - v1;
            }
            else
            {
                Vector3 v0 = vertices.Array[v0Idx];
                xd = v1 - v0;
                zd = v2 - v0;
            }
            return Vector3.Cross(zd, xd);
        }

        public float GetCrossLength(float pathF)
        {
            int s0;
            int s1;
            float frag;
#pragma warning disable 618
            GetSegmentIndices(pathF, out s0, out s1, out frag);
#pragma warning restore 618

#pragma warning disable 618
            if (SegmentLength[s0] == 0)
                SegmentLength[s0] = calcSegmentLength(s0);
            if (SegmentLength[s1] == 0)
                SegmentLength[s1] = calcSegmentLength(s1);

            return Mathf.LerpUnclamped(SegmentLength[s0], SegmentLength[s1], frag);
#pragma warning restore 618
        }


        public float CrossFToDistance(float f, float crossF, CurvyClamping crossClamping = CurvyClamping.Clamp)
        {
            return GetCrossLength(f) * CurvyUtility.ClampTF(crossF, crossClamping);
        }

        public float CrossDistanceToF(float f, float distance, CurvyClamping crossClamping = CurvyClamping.Clamp)
        {
            float cl = GetCrossLength(f);
            return CurvyUtility.ClampDistance(distance, crossClamping, cl) / cl;
        }

        /// <summary>
        /// Get the indices of the two points on the path that are surrounding the point at pathF
        /// </summary>
        /// <param name="pathF">The relative distance of the input point on the path</param>
        /// <param name="segment0Index">Index of the path point just before the input point </param>
        /// <param name="segment1Index">Index of the path point just after the input point</param>
        /// <param name="frag">The interpolation value between segment0Index and segment1Index, defining the exact position of the input point between those two points</param>
        [Obsolete("Method will get removed. Copy its content if you still need it")]
        public void GetSegmentIndices(float pathF, out int segment0Index, out int segment1Index, out float frag)
        {
            segment0Index = GetFIndex(Mathf.Repeat(pathF, 1), out frag);
            segment1Index = segment0Index + 1;
        }

        public int GetSegmentIndex(int segment)
        {
            return segment * CrossSize;
        }

        public int GetCrossFIndex(float crossF, out float frag)
        {
            float f = crossF + CrossFShift;
            //OPTIM if f is always positive, replace repeat with %. Right now crossF can be negative
            f = f == 1 ? f : Mathf.Repeat(f, 1);
            int index = getGenericFIndex(crossRelativeDistances, f, out frag);

            return index;
        }

        /// <summary>
        /// Get the index of the first vertex belonging to the segment a certain F is part of
        /// </summary>
        /// <param name="pathF">position on the path (0..1)</param>
        /// <param name="pathFrag">remainder between the returned segment and the next segment</param>
        /// <returns>a vertex index</returns>
        public int GetVertexIndex(float pathF, out float pathFrag)
        {
            int pIdx = GetFIndex(pathF, out pathFrag);
            return pIdx * CrossSize;
        }

        /// <summary>
        /// Get the index of the first vertex of the edge a certain F and CrossF is part of
        /// </summary>
        /// <param name="pathF">position on the path (0..1)</param>
        /// <param name="crossF">position on the cross (0..1)</param>
        /// <param name="pathFrag">remainder between the segment and the next segment</param>
        /// <param name="crossFrag">remainder between the returned vertex and the next vertex</param>
        /// <returns>a vertex index</returns>
        public int GetVertexIndex(float pathF, float crossF, out float pathFrag, out float crossFrag)
        {
            int pIdx = GetVertexIndex(pathF, out pathFrag);
            int cIdx = GetCrossFIndex(crossF, out crossFrag);
            return pIdx + cIdx;
        }

        /// <summary>
        /// Gets all vertices belonging to one or more extruded shape segments
        /// </summary>
        /// <param name="segmentIndices">indices of segments in question</param>
        public Vector3[] GetSegmentVertices(params int[] segmentIndices)
        {
            SubArray<Vector3> verts = ArrayPools.Vector3.Allocate(CrossSize * segmentIndices.Length);
            for (int i = 0; i < segmentIndices.Length; i++)
            {
                int sourceIndex = segmentIndices[i] * CrossSize;
                int destinationIndex = i * CrossSize;
                Array.Copy(vertices.Array, sourceIndex, verts.Array, destinationIndex, CrossSize);
            }

            return verts.CopyToArray(ArrayPools.Vector3);
        }


        private float calcSegmentLength(int segmentIndex)
        {
            int vstart = segmentIndex * CrossSize;
            int vend = vstart + CrossSize - 1;
            float l = 0;
            for (int i = vstart; i < vend; i++)
                l += (vertices.Array[i + 1] - vertices.Array[i]).magnitude;

            return l;
        }

    }

    /// <summary>
    /// Bounds data class
    /// </summary>
    [CGDataInfo(1, 0.8f, 0.5f)]
    public class CGBounds : CGData
    {
        protected Bounds? mBounds;
        public Bounds Bounds
        {
            get
            {
                if (!mBounds.HasValue)
                    RecalculateBounds();
                return mBounds.Value;
            }
            set
            {
                if (mBounds != value)
                    mBounds = value;
            }
        }

        public float Depth
        {
            get
            {
                //OPTIM just do the delta between max z and min z, and get rid of bounds
                return Bounds.size.z;
            }
        }

        public CGBounds() : base() { }

        public CGBounds(Bounds bounds) : base()
        {
            Bounds = bounds;
        }

        public CGBounds(CGBounds source)
        {
            Name = source.Name;
            if (source.mBounds.HasValue) //Do not copy bounds if they are not computed yet
                Bounds = source.Bounds;
        }


        public virtual void RecalculateBounds()
        {
            Bounds = new Bounds();
        }

        public override T Clone<T>()
        {
            return new CGBounds(this) as T;
        }

        public static void Copy(CGBounds dest, CGBounds source)
        {
            if (source.mBounds.HasValue) //Do not copy bounds if they are not computed yet
                dest.Bounds = source.Bounds;
        }
    }

    /// <summary>
    /// SubMesh data (triangles, material)
    /// </summary>
    public class CGVSubMesh : CGData
    {
        /// <summary>
        /// Vertex indices constituting the mesh's triangles
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<int> TrianglesList
        {
            get => triangles;
            set
            {
                ArrayPools.Int32.Free(triangles);
                triangles = value;
            }
        }

        /// <summary>
        /// Vertex indices constituting the mesh's triangles
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use TrianglesList instead")]
        public int[] Triangles
        {
            get => TrianglesList.CopyToArray(ArrayPools.Int32);
            set => TrianglesList = new SubArray<int>(value);
        }

        public Material Material;
        private SubArray<int> triangles;

        public override int Count
        {
            get
            {
                return triangles.Count;
            }
        }

        public CGVSubMesh(Material material = null) : base()
        {
            Material = material;
            triangles = ArrayPools.Int32.Allocate(0);
        }

        public CGVSubMesh(int[] triangles, Material material = null) : base()
        {
            Material = material;
            this.triangles = new SubArray<int>(triangles);
        }

        public CGVSubMesh(SubArray<int> triangles, Material material = null) : base()
        {
            Material = material;
            this.triangles = triangles;
        }

        public CGVSubMesh(int triangleCount, Material material = null) : base()
        {
            Material = material;
            triangles = ArrayPools.Int32.Allocate(triangleCount);
        }

        public CGVSubMesh(CGVSubMesh source) : base()
        {
            Material = source.Material;
            triangles = ArrayPools.Int32.Clone(source.triangles);
        }

        protected override bool Dispose(bool disposing)
        {
            bool result = base.Dispose(disposing);
            if (result)
                ArrayPools.Int32.Free(triangles);
            return result;
        }

        public override T Clone<T>()
        {
            return new CGVSubMesh(this) as T;
        }

        public static CGVSubMesh Get(CGVSubMesh data, int triangleCount, Material material = null)
        {

            if (data == null)
                return new CGVSubMesh(triangleCount, material);

            ArrayPools.Int32.Resize(ref data.triangles, triangleCount);
            data.Material = material;
            return data;
        }

        public void ShiftIndices(int offset, int startIndex = 0)
        {
            for (int i = startIndex; i < triangles.Count; i++)
                triangles.Array[i] += offset;
        }

        public void Add(CGVSubMesh other, int shiftIndexOffset = 0)
        {
            int trianglesLength = triangles.Count;
            int otherTriangleLength = other.triangles.Count;

            if (otherTriangleLength == 0)
                return;

            ArrayPools.Int32.Resize(ref triangles, trianglesLength + otherTriangleLength);

            Array.Copy(other.triangles.Array, 0, triangles.Array, trianglesLength, otherTriangleLength);

            if (shiftIndexOffset != 0)
                ShiftIndices(shiftIndexOffset, trianglesLength);
        }
    }

    /// <summary>
    /// Mesh Data (Bounds + Vertex,UV,UV2,Normal,Tangents,SubMehes)
    /// </summary>
    [CGDataInfo(0.98f, 0.5f, 0)]
    public class CGVMesh : CGBounds
    {

#if CONTRACTS_FULL
        [ContractInvariantMethod]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "Required for code contracts.")]
        private void ObjectInvariant()
        {
            Contract.Invariant(Vertex != null);
            Contract.Invariant(UV != null);
            Contract.Invariant(UV2 != null);
            Contract.Invariant(Normal != null);
            Contract.Invariant(Tangents != null);
            Contract.Invariant(SubMeshes != null);

            Contract.Invariant(UV.Length == 0 || UV.Length == Vertex.Length);
            Contract.Invariant(UV2.Length == 0 || UV2.Length == Vertex.Length);
            Contract.Invariant(Normal.Length == 0 || Normal.Length == Vertex.Length);
            Contract.Invariant(Tangents.Length == 0 || Tangents.Length == Vertex.Length);
        }
#endif

        /// <summary>
        /// Positions of the points, in the local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        /// <remarks>If you modify the content of the returned array, make sure to call <see cref="ClearCachedSortedVertexIndices"/> before calling <see cref="GetCachedSortedVertexIndices"/></remarks>
        public SubArray<Vector3> Vertices
        {
            get => vertices;
            set
            {
                ArrayPools.Vector3.Free(vertices);
                vertices = value;
                OnVerticesChanged();
            }
        }

        /// <summary>
        /// UVs of the points
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector2> UVs
        {
            get => uvs;
            set
            {
                ArrayPools.Vector2.Free(uvs);
                uvs = value;
            }
        }

        /// <summary>
        /// UV2s of the points
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector2> UV2s
        {
            get => uv2s;
            set
            {
                ArrayPools.Vector2.Free(uv2s);
                uv2s = value;
            }
        }

        /// <summary>
        /// Normals of the points, in the local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector3> NormalsList
        {
            get => normals;
            set
            {
                ArrayPools.Vector3.Free(normals);
                normals = value;
            }
        }

        /// <summary>
        /// Tangents of the points, in the local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector4> TangentsList
        {
            get => tangents;
            set
            {
                ArrayPools.Vector4.Free(tangents);
                tangents = value;
            }
        }

        #region Obsolete

        /// <summary>
        /// Positions of the points, in the local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use Vertices instead")]
        public Vector3[] Vertex
        {
            get => Vertices.CopyToArray(ArrayPools.Vector3);
            set => Vertices = new SubArray<Vector3>(value);
        }

        /// <summary>
        /// UVs of the points
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use UVs instead")]
        public Vector2[] UV
        {
            get => UVs.CopyToArray(ArrayPools.Vector2);
            set => UVs = new SubArray<Vector2>(value);
        }

        /// <summary>
        /// UV2s of the points
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use UV2s instead")]
        public Vector2[] UV2
        {
            get => UV2s.CopyToArray(ArrayPools.Vector2);
            set => UV2s = new SubArray<Vector2>(value);
        }


        /// <summary>
        /// Normals of the points, in the local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use NormalList instead")]
        public Vector3[] Normals
        {
            get => NormalsList.CopyToArray(ArrayPools.Vector3);
            set => NormalsList = new SubArray<Vector3>(value);
        }

        /// <summary>
        /// Tangents of the points, in the local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use TangentsList instead")]
        public Vector4[] Tangents
        {
            get => TangentsList.CopyToArray(ArrayPools.Vector4);
            set => TangentsList = new SubArray<Vector4>(value);
        }


        #endregion
        public CGVSubMesh[] SubMeshes;
        /// <summary>
        /// Gets the number of vertices
        /// </summary>
        public override int Count
        {
            get
            {
                return vertices.Count;
            }
        }

        public bool HasUV { get { return uvs.Count > 0; } }
        public bool HasUV2 { get { return uv2s.Count > 0; } }
        /// <summary>
        /// True if at least one vertex has a normal
        /// </summary>
        public bool HasNormals { get { return normals.Count > 0; } }

        /// <summary>
        /// True if <see cref="HasNormals"/> but not all vertices have normals
        /// </summary>
        public bool HasPartialNormals
        {
            get
            {
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(hasPartialNormals == false || HasNormals);
#endif
                return hasPartialNormals;
            }
            private set => hasPartialNormals = value;
        }

        /// <summary>
        /// True if at least one vertex has a tangent
        /// </summary>
        public bool HasTangents { get { return tangents.Count > 0; } }

        /// <summary>
        /// True if <see cref="HasTangents"/> but not all vertices have tangents
        /// </summary>
        public bool HasPartialTangents
        {
            get
            {
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(hasPartialTangents == false || HasTangents);
#endif
                return hasPartialTangents;
            }
            private set => hasPartialTangents = value;
        }

        public int TriangleCount
        {
            get
            {
                int cnt = 0;
                for (int i = 0; i < SubMeshes.Length; i++)
                    cnt += SubMeshes[i].TrianglesList.Count;
                return cnt / 3;
            }
        }

        #region Private fields

        /// <summary>
        /// An array of the index of vertices when sorted by Z coordinate, from smaller to bigger
        /// </summary>
        private SubArray<int>? sortedVertexIndices;
        /// <summary>
        /// Lock used when generating <see cref="sortedVertexIndices"/>
        /// </summary>
        private readonly object vertexIndicesLock = new object();

        private SubArray<Vector3> vertices;

        private SubArray<Vector2> uvs;

        private SubArray<Vector2> uv2s;

        private SubArray<Vector3> normals;

        private SubArray<Vector4> tangents;

        private bool hasPartialNormals;

        private bool hasPartialTangents;

        #endregion
        public CGVMesh() : this(0) { }
        public CGVMesh(int vertexCount, bool addUV = false, bool addUV2 = false, bool addNormals = false, bool addTangents = false) : base()
        {
            vertices = ArrayPools.Vector3.Allocate(vertexCount);
            uvs = addUV
                ? ArrayPools.Vector2.Allocate(vertexCount)
                : ArrayPools.Vector2.Allocate(0);
            uv2s = addUV2
                ? ArrayPools.Vector2.Allocate(vertexCount)
                : ArrayPools.Vector2.Allocate(0);
            normals = addNormals
                ? ArrayPools.Vector3.Allocate(vertexCount)
                : ArrayPools.Vector3.Allocate(0);
            tangents = addTangents
                ? ArrayPools.Vector4.Allocate(vertexCount)
                : ArrayPools.Vector4.Allocate(0);
            hasPartialNormals = false;
            hasPartialTangents = false;
            SubMeshes = new CGVSubMesh[0];
        }
        public CGVMesh(CGVolume volume) : this(volume.Vertices.Count)
        {
            Array.Copy(volume.Vertices.Array, 0, vertices.Array, 0, volume.Vertices.Count);
        }

        public CGVMesh(CGVolume volume, IntRegion subset)
            : this((subset.LengthPositive + 1) * volume.CrossSize, false, false, true)
        {
            int start = subset.Low * volume.CrossSize;
            Array.Copy(volume.Vertices.Array, start, vertices.Array, 0, vertices.Count);
            Array.Copy(volume.VertexNormals.Array, start, normals.Array, 0, normals.Count);
        }

        public CGVMesh(CGVMesh source) : base(source)
        {
            vertices = ArrayPools.Vector3.Clone(source.vertices);
            uvs = ArrayPools.Vector2.Clone(source.uvs);
            uv2s = ArrayPools.Vector2.Clone(source.uv2s);
            normals = ArrayPools.Vector3.Clone(source.normals);
            tangents = ArrayPools.Vector4.Clone(source.tangents);
            hasPartialNormals = source.HasPartialNormals;
            hasPartialTangents = source.HasPartialTangents;
            SubMeshes = new CGVSubMesh[source.SubMeshes.Length];
            for (int i = 0; i < source.SubMeshes.Length; i++)
                SubMeshes[i] = new CGVSubMesh(source.SubMeshes[i]);
        }

        public CGVMesh(CGMeshProperties meshProperties) : this(meshProperties.Mesh, meshProperties.Material, meshProperties.Matrix) { }

        public CGVMesh(Mesh source, Material[] materials, Matrix4x4 trsMatrix) : base()
        {
            Name = source.name;
            vertices = new SubArray<Vector3>(source.vertices);
            normals = new SubArray<Vector3>(source.normals);
            tangents = new SubArray<Vector4>(source.tangents);
            hasPartialNormals = false;
            hasPartialTangents = false;
            uvs = new SubArray<Vector2>(source.uv);
            uv2s = new SubArray<Vector2>(source.uv2);
            SubMeshes = new CGVSubMesh[source.subMeshCount];
            for (int s = 0; s < source.subMeshCount; s++)
                SubMeshes[s] = new CGVSubMesh(source.GetTriangles(s), (materials.Length > s) ? materials[s] : null);

            Bounds = source.bounds;

            if (!trsMatrix.isIdentity)
                TRS(trsMatrix);

        }

        protected override bool Dispose(bool disposing)
        {
            bool result = base.Dispose(disposing);
            if (result)
            {
                if (sortedVertexIndices != null)
                    ArrayPools.Int32.Free(sortedVertexIndices.Value);
                ArrayPools.Vector3.Free(vertices);
                ArrayPools.Vector2.Free(uvs);
                ArrayPools.Vector2.Free(uv2s);
                ArrayPools.Vector3.Free(normals);
                ArrayPools.Vector4.Free(tangents);

                //Do not dispose SubMeshes if the call is due to finalization, since submeshes are disposable by themselves.
                if (disposing)
                    for (var i = 0; i < SubMeshes.Length; i++)
                        SubMeshes[i].Dispose();
            }
            return result;
        }

        public override T Clone<T>()
        {
            return new CGVMesh(this) as T;
        }

        [Obsolete("Member not used by Curvy, will get removed next major version. Use another overload of this method")]
        public static CGVMesh Get(CGVMesh data, CGVolume source, bool addUV, bool reverseNormals)
        {
            return Get(data, source, new IntRegion(0, source.Count - 1), addUV, reverseNormals);
        }

        [Obsolete("Member not used by Curvy, will get removed next major version. Use another overload of this method")]
        public static CGVMesh Get(CGVMesh data, CGVolume source, IntRegion subset, bool addUV, bool reverseNormals)
        {
            return Get(data, source, subset, addUV, false, reverseNormals);
        }

        public static CGVMesh Get(CGVMesh data, CGVolume source, IntRegion subset, bool addUV, bool addUV2, bool reverseNormals)
        {
            int start = subset.Low * source.CrossSize;
            int size = (subset.LengthPositive + 1) * source.CrossSize;

            if (data == null)
                data = new CGVMesh(size, addUV, addUV2, true);
            else
            {
                if (data.vertices.Count != size)
                    ArrayPools.Vector3.Resize(ref data.vertices, size, false);

                if (data.normals.Count != size)
                    ArrayPools.Vector3.Resize(ref data.normals, size, false);

                int uvSize = (addUV) ? size : 0;
                if (data.uvs.Count != uvSize)
                    ArrayPools.Vector2.ResizeAndClear(ref data.uvs, uvSize);

                int uv2Size = (addUV2) ? size : 0;
                if (data.uv2s.Count != uv2Size)
                    ArrayPools.Vector2.ResizeAndClear(ref data.uv2s, uv2Size);

                //data.SubMeshes = new CGVSubMesh[0];//BUG? why is this commented?

                if (data.tangents.Count != 0)
                    ArrayPools.Vector4.Resize(ref data.tangents, 0);
                data.HasPartialTangents = false;
            }

            Array.Copy(source.Vertices.Array, start, data.vertices.Array, 0, size);
            Array.Copy(source.VertexNormals.Array, start, data.normals.Array, 0, size);
            data.hasPartialNormals = false;

            if (reverseNormals)
            {
                Vector3[] normalsArray = data.normals.Array;

                //OPTIM merge loop with normals copy
                for (int n = 0; n < data.normals.Count; n++)
                {
                    normalsArray[n].x = -normalsArray[n].x;
                    normalsArray[n].y = -normalsArray[n].y;
                    normalsArray[n].z = -normalsArray[n].z;
                }
            }

            data.OnVerticesChanged();

            return data;
        }


        public void SetSubMeshCount(int count)
        {
            Array.Resize(ref SubMeshes, count);
        }

        public void AddSubMesh(CGVSubMesh submesh = null)
        {
            SubMeshes = SubMeshes.Add(submesh);
        }

        /// <summary>
        /// Combine/Merge another VMesh into this
        /// </summary>
        /// <param name="source"></param>
        public void MergeVMesh(CGVMesh source) => MergeVMesh(source, Matrix4x4.identity);

        /// <summary>
        /// Combine/Merge another VMesh into this, applying a matrix
        /// </summary>
        /// <param name="source"></param>
        /// <param name="matrix"></param>
        public void MergeVMesh(CGVMesh source, Matrix4x4 matrix)
        {
            //TODO Design: unify implementation with MergeVMeshes
            int preMergeVertexCount = Count;
            // Add base data
            if (source.Count != 0)
            {
                int postMergeVertexCount = preMergeVertexCount + source.Count;
                ArrayPools.Vector3.Resize(ref vertices, postMergeVertexCount);
                if (matrix == Matrix4x4.identity)
                    Array.Copy(source.vertices.Array, 0, vertices.Array, preMergeVertexCount, source.Count);
                else
                    for (int v = preMergeVertexCount; v < postMergeVertexCount; v++)
                        vertices.Array[v] = matrix.MultiplyPoint3x4(source.vertices.Array[v - preMergeVertexCount]);

                MergeUVsNormalsAndTangents(source, preMergeVertexCount);

                // Add Submeshes
                for (int sm = 0; sm < source.SubMeshes.Length; sm++)
                    GetMaterialSubMesh(source.SubMeshes[sm].Material).Add(source.SubMeshes[sm], preMergeVertexCount);

                OnVerticesChanged();
            }
        }

        /// <summary>
        /// Combine/Merge multiple CGVMeshes into this
        /// </summary>
        /// <param name="vMeshes">list of CGVMeshes</param>
        /// <param name="startIndex">Index of the first element of the list to merge</param>
        /// <param name="endIndex">Index of the last element of the list to merge</param>
        public void MergeVMeshes(List<CGVMesh> vMeshes, int startIndex, int endIndex)
        {
            Assert.IsTrue(endIndex < vMeshes.Count);
            int totalVertexCount = 0;
            bool hasNormals = false;
            bool partialNormals = false;
            bool hasTangents = false;
            bool partialTangents = false;
            bool hasUV = false;
            bool hasUV2 = false;
            Dictionary<Material, List<SubArray<int>>> submeshesByMaterial = new Dictionary<Material, List<SubArray<int>>>();
            Dictionary<Material, int> trianglesIndexPerMaterial = new Dictionary<Material, int>();
            //dictionaries can't have null as a key, so to handle null materials, here are the fields equivalent to these dictionaries for null
            List<SubArray<int>> noMaterialSubmeshes = null;
            int noMaterialTrianglesIndex = 0;

            for (int i = startIndex; i <= endIndex; i++)
            {
                CGVMesh cgvMesh = vMeshes[i];
                totalVertexCount += cgvMesh.Count;
                hasNormals |= cgvMesh.HasNormals;
                partialNormals |= cgvMesh.HasNormals == false || cgvMesh.HasPartialNormals;
                hasTangents |= cgvMesh.HasTangents;
                partialTangents |= cgvMesh.HasTangents == false || cgvMesh.hasPartialTangents;
                hasUV |= cgvMesh.HasUV;
                hasUV2 |= cgvMesh.HasUV2;

                //initialize per material data
                for (int sm = 0; sm < cgvMesh.SubMeshes.Length; sm++)
                {
                    CGVSubMesh subMesh = cgvMesh.SubMeshes[sm];
                    if (subMesh.Material != null)
                    {
                        Material subMeshMaterial = subMesh.Material;
                        if (submeshesByMaterial.ContainsKey(subMeshMaterial) == false)
                        {
                            submeshesByMaterial[subMeshMaterial] = new List<SubArray<int>>(1);
                            trianglesIndexPerMaterial[subMeshMaterial] = 0;
                        }
                        submeshesByMaterial[subMeshMaterial].Add(subMesh.TrianglesList);
                    }
                    else
                    {
                        if(noMaterialSubmeshes == null)
                        {
                            noMaterialSubmeshes = new List<SubArray<int>>(1);
                            noMaterialTrianglesIndex = 0;
                        }
                        noMaterialSubmeshes.Add(subMesh.TrianglesList);
                    }

                }
            }

            ArrayPools.Vector3.Resize(ref vertices, totalVertexCount);
            if (hasNormals)
                ArrayPools.Vector3.Resize(ref normals, totalVertexCount);
            hasPartialNormals = partialNormals;

            if (hasTangents)
                ArrayPools.Vector4.Resize(ref tangents, totalVertexCount);
            hasPartialTangents = partialTangents;

            if (hasUV)
                ArrayPools.Vector2.Resize(ref uvs, totalVertexCount);

            if (hasUV2)
                ArrayPools.Vector2.Resize(ref uv2s, totalVertexCount);

            foreach (KeyValuePair<Material, List<SubArray<int>>> pair in submeshesByMaterial)
                ProcessTriangleArrays(pair.Value, pair.Key);
            if(noMaterialSubmeshes != null)
                ProcessTriangleArrays(noMaterialSubmeshes, null);

            int currentVertexCount = 0;
            for (int i = startIndex; i <= endIndex; i++)
            {
                CGVMesh source = vMeshes[i];

                Array.Copy(source.vertices.Array, 0, vertices.Array, currentVertexCount, source.vertices.Count);
                if (hasNormals)
                {
                    if (source.HasNormals)
                        Array.Copy(source.normals.Array, 0, normals.Array, currentVertexCount, source.normals.Count);
                    else
                        Array.Clear(normals.Array, currentVertexCount, source.vertices.Count);
                }

                if (hasTangents)
                {
                    if (source.HasTangents)
                        Array.Copy(source.tangents.Array, 0, tangents.Array, currentVertexCount, source.tangents.Count);
                    else
                        Array.Clear(tangents.Array, currentVertexCount, source.vertices.Count);
                }

                if (hasUV)
                {
                    if (source.HasUV)
                        Array.Copy(source.uvs.Array, 0, uvs.Array, currentVertexCount, source.uvs.Count);
                    else
                        Array.Clear(uvs.Array, currentVertexCount, source.vertices.Count);
                }

                if (hasUV2)
                {
                    if (source.HasUV2)
                        Array.Copy(source.uv2s.Array, 0, uv2s.Array, currentVertexCount, source.uv2s.Count);
                    else
                        Array.Clear(uv2s.Array, currentVertexCount, source.vertices.Count);
                }

                // Add Submeshes
                for (int subMeshIndex = 0; subMeshIndex < source.SubMeshes.Length; subMeshIndex++)
                {
                    CGVSubMesh sourceSubMesh = source.SubMeshes[subMeshIndex];
                    Material sourceMaterial = sourceSubMesh.Material;
                    SubArray<int> sourceTriangles = sourceSubMesh.TrianglesList;
                    int sourceTrianglesLength = sourceTriangles.Count;

                    SubArray<int> destinationTriangles = GetMaterialSubMesh(sourceMaterial).TrianglesList;

                    int trianglesIndex = sourceMaterial == null ? noMaterialTrianglesIndex: trianglesIndexPerMaterial[sourceMaterial];

                    if (sourceTrianglesLength != 0)
                    {
                        if (currentVertexCount == 0)
                            Array.Copy(sourceTriangles.Array, 0, destinationTriangles.Array, trianglesIndex, sourceTrianglesLength);
                        else
                            for (int j = 0; j < sourceTrianglesLength; j++)
                                destinationTriangles.Array[trianglesIndex + j] = sourceTriangles.Array[j] + currentVertexCount;

                        int materialTrianglesIndex = trianglesIndex + sourceTrianglesLength;

                        if (sourceMaterial == null)
                            noMaterialTrianglesIndex = materialTrianglesIndex;
                        else
                            trianglesIndexPerMaterial[sourceMaterial] = materialTrianglesIndex;
                    }
                }
                currentVertexCount += source.vertices.Count;
            }

            OnVerticesChanged();

            void ProcessTriangleArrays(List<SubArray<int>> subArrays, Material material1)
            {
                int totalTrianglesCount = 0;
                for (int arraysIndex = 0; arraysIndex < subArrays.Count; arraysIndex++)
                    totalTrianglesCount += subArrays[arraysIndex].Count;

                AddSubMesh(new CGVSubMesh(totalTrianglesCount, material1));
            }
        }

        private void MergeUVsNormalsAndTangents(CGVMesh source, int preMergeVertexCount)
        {
            int sourceLength = source.Count;
            if (sourceLength == 0)
                return;

            int postMergeVetexCount = preMergeVertexCount + sourceLength;
            if (HasUV || source.HasUV)
            {
                SubArray<Vector2> newUVs = ArrayPools.Vector2.Allocate(postMergeVetexCount, false);

                if (HasUV)
                    Array.Copy(uvs.Array, 0, newUVs.Array, 0, preMergeVertexCount);
                else
                    Array.Clear(newUVs.Array, 0, preMergeVertexCount);

                if (source.HasUV)
                    Array.Copy(source.uvs.Array, 0, newUVs.Array, preMergeVertexCount, sourceLength);
                else
                    Array.Clear(newUVs.Array, preMergeVertexCount, sourceLength);

                UVs = newUVs;

            }

            if (HasUV2 || source.HasUV2)
            {
                SubArray<Vector2> newUV2s = ArrayPools.Vector2.Allocate(postMergeVetexCount, false);

                if (HasUV2)
                    Array.Copy(uv2s.Array, 0, newUV2s.Array, 0, preMergeVertexCount);
                else
                    Array.Clear(newUV2s.Array, 0, preMergeVertexCount);

                if (source.HasUV2)
                    Array.Copy(source.uv2s.Array, 0, newUV2s.Array, preMergeVertexCount, sourceLength);
                else
                    Array.Clear(newUV2s.Array, preMergeVertexCount, sourceLength);

                UV2s = newUV2s;

            }

            if (HasNormals || source.HasNormals)
            {
                HasPartialNormals = HasNormals ^ source.HasNormals;

                SubArray<Vector3> newNormals = ArrayPools.Vector3.Allocate(postMergeVetexCount, false);

                if (HasNormals)
                    Array.Copy(normals.Array, 0, newNormals.Array, 0, preMergeVertexCount);
                else
                    Array.Clear(newNormals.Array, 0, preMergeVertexCount);

                if (source.HasNormals)
                    Array.Copy(source.normals.Array, 0, newNormals.Array, preMergeVertexCount, sourceLength);
                else
                    Array.Clear(newNormals.Array, preMergeVertexCount, sourceLength);

                NormalsList = newNormals;
            }

            if (HasTangents || source.HasTangents)
            {
                HasPartialTangents = HasTangents ^ source.HasTangents;

                SubArray<Vector4> newTangents = ArrayPools.Vector4.Allocate(postMergeVetexCount, false);

                if (HasTangents)
                    Array.Copy(tangents.Array, 0, newTangents.Array, 0, preMergeVertexCount);
                else
                    Array.Clear(newTangents.Array, 0, preMergeVertexCount);

                if (source.HasTangents)
                    Array.Copy(source.tangents.Array, 0, newTangents.Array, preMergeVertexCount, sourceLength);
                else
                    Array.Clear(newTangents.Array, preMergeVertexCount, sourceLength);

                TangentsList = newTangents;
            }
        }

        /// <summary>
        /// Gets the submesh using a certain material
        /// </summary>
        /// <param name="mat">the material the submesh should use</param>
        /// <param name="createIfMissing">whether to create the submesh if no existing one matches</param>
        /// <returns>a submesh using the given material</returns>
        public CGVSubMesh GetMaterialSubMesh(Material mat, bool createIfMissing = true)
        {
            // already having submesh with matching material?
            for (int sm = 0; sm < SubMeshes.Length; sm++)
                if (SubMeshes[sm].Material == mat)
                    return SubMeshes[sm];

            // else create new
            if (createIfMissing)
            {
                CGVSubMesh sm = new CGVSubMesh(mat);
                AddSubMesh(sm);
                return sm;
            }
            else
                return null;
        }

        /// <summary>
        /// Creates a Mesh from the data
        /// </summary>
        public Mesh AsMesh()
        {
            Mesh msh = new Mesh();
            ToMesh(ref msh);
            return msh;
        }

        /// <summary>
        /// Copies the data into an existing Mesh
        /// </summary>
        /// <param name="mesh">The mesh to copy the data from this CGVMesh into</param>
        /// <param name="includeNormals">should normals be copied or set to empty?</param>
        /// <param name="includeTangents">should tangents be copied or set to empty?</param>
        public void ToMesh(ref Mesh mesh, bool includeNormals = true, bool includeTangents = true)
        {
            mesh.indexFormat = Count >= UInt16.MaxValue ? IndexFormat.UInt32 : IndexFormat.UInt16;

            mesh.SetVertices(vertices.Array, 0, vertices.Count);
            mesh.SetUVs(0, uvs.Array, 0, HasUV ? uvs.Count : 0);
            mesh.SetUVs(1, uv2s.Array, 0, HasUV2 ? uv2s.Count : 0);
            mesh.SetNormals(normals.Array, 0, (includeNormals && HasNormals) ? normals.Count : 0);
            mesh.SetTangents(tangents.Array, 0, (includeTangents && HasTangents) ? tangents.Count : 0);

            mesh.subMeshCount = SubMeshes.Length;
            for (int s = 0; s < SubMeshes.Length; s++)
            {
                SubArray<int> subArray = SubMeshes[s].TrianglesList;
                mesh.SetTriangles(subArray.Array, 0, subArray.Count, s);
            }
        }

        /// <summary>
        /// Gets a list of all Materials used
        /// </summary>
        public Material[] GetMaterials()
        {
            List<Material> mats = new List<Material>();
            for (int s = 0; s < SubMeshes.Length; s++)
                mats.Add(SubMeshes[s].Material);
            return mats.ToArray();
        }

        public override void RecalculateBounds()
        {
            if (Count == 0)
            {
                mBounds = new Bounds(Vector3.zero, Vector3.zero);
            }
            else
            {
                int vertexCount = vertices.Count;
                Vector3 min = vertices.Array[0], max = vertices.Array[0];
                for (int i = 1; i < vertexCount; i++)
                {
                    Vector3 vertex = vertices.Array[i];

                    if (vertex.x < min.x)
                        min.x = vertex.x;
                    else if (vertex.x > max.x)
                        max.x = vertex.x;

                    if (vertex.y < min.y)
                        min.y = vertex.y;
                    else if (vertex.y > max.y)
                        max.y = vertex.y;

                    if (vertex.z < min.z)
                        min.z = vertex.z;
                    else if (vertex.z > max.z)
                        max.z = vertex.z;
                }

                Bounds bounds = new Bounds();
                bounds.SetMinMax(min, max);
                mBounds = bounds;
            }
        }

        [Obsolete("Method will get remove in next major update. Copy its content if you need it")]
        public void RecalculateUV2()
        {
            ArrayPools.Vector2.Resize(ref uv2s, UVs.Count);
            CGUtility.CalculateUV2(uvs.Array, uv2s.Array, uvs.Count);
        }

        /// <summary>
        /// Applies the translation, rotation and scale defined by the given matrix
        /// </summary>
        public void TRS(Matrix4x4 matrix)
        {
            int count = Count;
            for (int vertexIndex = 0; vertexIndex < count; vertexIndex++)
                vertices.Array[vertexIndex] = matrix.MultiplyPoint3x4(vertices.Array[vertexIndex]);

            count = normals.Count;
            for (int vertexIndex = 0; vertexIndex < count; vertexIndex++)
                normals.Array[vertexIndex] = matrix.MultiplyVector(normals.Array[vertexIndex]);

            count = tangents.Count;
            for (int vertexIndex = 0; vertexIndex < count; vertexIndex++)
            {
                //Keep in mind that Tangents is a Vector4 array
                Vector4 tangent4 = tangents.Array[vertexIndex];
                Vector3 tangent3;
                tangent3.x = tangent4.x;
                tangent3.y = tangent4.y;
                tangent3.z = tangent4.z;
                tangents.Array[vertexIndex] = matrix.MultiplyVector(tangent3);
            }

            OnVerticesChanged();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void OnVerticesChanged()
        {
            mBounds = null;
            ClearCachedSortedVertexIndices();
        }

        /// <summary>
        /// Gets an array of the index of vertices when sorted by Z coordinate, from smaller to bigger.
        /// This array is cached. Curvy Splines does clear this cache if it modifies <see cref="Vertices"/>, but if you modify <see cref="Vertices"/> through its getter, you will have to clear the cached value by calling <see cref="ClearCachedSortedVertexIndices"/>
        /// </summary>
        /// <remarks>Is thread safe</remarks>
        public SubArray<int> GetCachedSortedVertexIndices()
        {
            if (sortedVertexIndices == null)
            {
                lock (vertexIndicesLock)
                {
                    if (sortedVertexIndices == null)
                    {
                        int verticesCount = vertices.Count;

                        SubArray<int> result = ArrayPools.Int32.Allocate(verticesCount);
                        SubArray<float> verticesZ = ArrayPools.Single.Allocate(verticesCount);
                        for (int k = 0; k < verticesCount; k++)
                        {
                            result.Array[k] = k;
                            verticesZ.Array[k] = vertices.Array[k].z;
                        }

                        Array.Sort(verticesZ.Array, result.Array, 0, verticesCount);
                        ArrayPools.Single.Free(verticesZ);

                        sortedVertexIndices = result;
                    }
                }
            }

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(sortedVertexIndices.Value.Count == Vertices.Count);
#endif
            return sortedVertexIndices.Value;
        }

        /// <summary>
        /// Clears the cached value computed by <see cref="GetCachedSortedVertexIndices"/>
        /// </summary>
        /// <remarks>Is thread safe</remarks>
        private void ClearCachedSortedVertexIndices()
        {
            if (sortedVertexIndices != null)
                lock (vertexIndicesLock)
                {
                    if (sortedVertexIndices != null)
                    {
                        ArrayPools.Int32.Free(sortedVertexIndices.Value);
                        sortedVertexIndices = null;
                    }
                }
        }
    }

    /// <summary>
    /// GameObject data (Bounds + Object)
    /// </summary>
    [CGDataInfo("#FFF59D")]
    public class CGGameObject : CGBounds
    {
        public GameObject Object;
        public Vector3 Translate;
        public Vector3 Rotate;
        public Vector3 Scale = Vector3.one;

        public Matrix4x4 Matrix
        {
            get { return Matrix4x4.TRS(Translate, Quaternion.Euler(Rotate), Scale); }
        }

        public CGGameObject() : base() { }

        public CGGameObject(CGGameObjectProperties properties) : this(properties.Object, properties.Translation, properties.Rotation, properties.Scale) { }

        public CGGameObject(GameObject obj) : this(obj, Vector3.zero, Vector3.zero, Vector3.one) { }

        public CGGameObject(GameObject obj, Vector3 translate, Vector3 rotate, Vector3 scale)
            : base()
        {
            Object = obj;
            Translate = translate;
            Rotate = rotate;
            Scale = scale;
            if (Object)
                Name = Object.name;
        }

        public CGGameObject(CGGameObject source) : base(source)
        {
            Object = source.Object;
            Translate = source.Translate;
            Rotate = source.Rotate;
            Scale = source.Scale;
        }

        public override T Clone<T>()
        {
            return new CGGameObject(this) as T;
        }

        public override void RecalculateBounds()
        {
            if (Object == null)
            {
                mBounds = new Bounds();
            }
            else
            {
                Renderer[] renderer = Object.GetComponentsInChildren<Renderer>(true);
                Collider[] collider = Object.GetComponentsInChildren<Collider>(true);
                Bounds bounds;
                if (renderer.Length > 0)
                {
                    bounds = renderer[0].bounds;
                    for (int i = 1; i < renderer.Length; i++)
                        bounds.Encapsulate(renderer[i].bounds);
                    for (int i = 0; i < collider.Length; i++)
                        bounds.Encapsulate(collider[i].bounds);
                }
                else if (collider.Length > 0)
                {
                    bounds = collider[0].bounds;
                    for (int i = 1; i < collider.Length; i++)
                        bounds.Encapsulate(collider[i].bounds);
                }
                else
                    bounds = new Bounds();

                Vector3 rotationlessBoundsSize = (Quaternion.Inverse(Object.transform.localRotation) * bounds.size);
                bounds.size = new Vector3(
                    rotationlessBoundsSize.x * Scale.x,
                    rotationlessBoundsSize.y * Scale.y,
                    rotationlessBoundsSize.z * Scale.z);

                mBounds = bounds;
            }
        }
    }

    /// <summary>
    /// A collection of <see cref="CGSpot"/>
    /// </summary>
    [CGDataInfo(0.96f, 0.96f, 0.96f)]
    public class CGSpots : CGData
    {
        //DESIGN what is the use of this class? Seems to me like a complicated way to represent an array

        /// <summary>
        /// List of spots
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>

        public SubArray<CGSpot> Spots
        {
            get => spots;
            set
            {
                ArrayPools.CGSpot.Free(spots);
                spots = value;
            }
        }

        /// <summary>
        /// List of spots
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use Spots instead")]
        public CGSpot[] Points
        {
            get => Spots.CopyToArray(ArrayPools.CGSpot);
            set => Spots = new SubArray<CGSpot>(value);
        }

        private SubArray<CGSpot> spots;

        public override int Count
        {
            get
            {
                return spots.Count;
            }
        }

        public CGSpots() : base()
        {
            spots = ArrayPools.CGSpot.Allocate(0);
        }

        public CGSpots(params CGSpot[] points) : base()
        {
            spots = new SubArray<CGSpot>(points);
        }

        public CGSpots(SubArray<CGSpot> spots) : base()
        {
            this.spots = spots;
        }

        public CGSpots(List<CGSpot> spots) : base()
        {
            this.spots = ArrayPools.CGSpot.Allocate(spots.Count);
            spots.CopyTo(0, this.spots.Array, 0, spots.Count);
        }

        public CGSpots(params List<CGSpot>[] spots) : base()
        {
            int c = 0;
            for (int i = 0; i < spots.Length; i++)
                c += spots[i].Count;
            this.spots = ArrayPools.CGSpot.Allocate(c);
            c = 0;
            for (int i = 0; i < spots.Length; i++)
            {
                List<CGSpot> cgSpots = spots[i];
                cgSpots.CopyTo(0, this.spots.Array, c, cgSpots.Count);
                c += cgSpots.Count;
            }
        }

        public CGSpots(CGSpots source) : base()
        {
            spots = ArrayPools.CGSpot.Clone(source.spots);
        }
        protected override bool Dispose(bool disposing)
        {
            bool result = base.Dispose(disposing);
            if (result)
                ArrayPools.CGSpot.Free(spots);
            return result;
        }

        public override T Clone<T>()
        {
            return new CGSpots(this) as T;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGData.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGDataRequests.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 171ae25dd0efed1458b5b7581e352db0
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using FluffyUnderware.Curvy.Pools;
using ToolBuddy.Pooling.Collections;
using ToolBuddy.Pooling.Pools;

#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif


namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Request Parameter base class
    /// </summary>
    public abstract class CGDataRequestParameter
    {
        public static implicit operator bool(CGDataRequestParameter a)
        {
            return !ReferenceEquals(a, null);
        }
    }

    /// <summary>
    /// Additional Spline Request parameters
    /// </summary>
    public class CGDataRequestMetaCGOptions : CGDataRequestParameter
    {
        /// <summary>
        /// Whether Hard Edges should produce extra samples
        /// </summary>
        /// <remarks>This may result in extra samples at affected Control Points</remarks>
        [Obsolete("This option is now always assumed to be true")]
        public bool CheckHardEdges;
        /// <summary>
        /// Whether MaterialID's should be stored
        /// </summary>
        /// <remarks>This may result in extra samples at affected Control Points</remarks>
        [Obsolete("This option is now always assumed to be true")]
        public bool CheckMaterialID;
        /// <summary>
        /// Whether all Control Points should be included
        /// </summary>
        public bool IncludeControlPoints;
        /// <summary>
        /// Whether UVEdge, ExplicitU and custom U settings should be included
        /// </summary>
        [Obsolete("This option is now always assumed to be true")]
        public bool CheckExtendedUV;


        public CGDataRequestMetaCGOptions(bool checkEdges, bool checkMaterials, bool includeCP, bool extendedUV)
        {
#pragma warning disable 618
            CheckHardEdges = checkEdges;
#pragma warning restore 618
#pragma warning disable 618
            CheckMaterialID = checkMaterials;
#pragma warning restore 618
            IncludeControlPoints = includeCP;
#pragma warning disable 618
            CheckExtendedUV = extendedUV;
#pragma warning restore 618
        }

        public override bool Equals(object obj)
        {
            CGDataRequestMetaCGOptions O = obj as CGDataRequestMetaCGOptions;
            if (O == null)
                return false;
#pragma warning disable 618
            return (CheckHardEdges == O.CheckHardEdges && CheckMaterialID == O.CheckMaterialID && IncludeControlPoints == O.IncludeControlPoints && CheckExtendedUV == O.CheckExtendedUV);
#pragma warning restore 618
        }

        public override int GetHashCode()
        {
#pragma warning disable 618
            return new { A = CheckHardEdges, B = CheckMaterialID, C = IncludeControlPoints, D = CheckExtendedUV }.GetHashCode(); //OPTIM avoid array creation
#pragma warning restore 618
        }

        public override string ToString()
        {
#pragma warning disable 618
            return $"{nameof(CheckHardEdges)}: {CheckHardEdges}, {nameof(CheckMaterialID)}: {CheckMaterialID}, {nameof(IncludeControlPoints)}: {IncludeControlPoints}, {nameof(CheckExtendedUV)}: {CheckExtendedUV}";
#pragma warning restore 618
        }
    }

    /// <summary>
    /// Shape Rasterization Request parameters
    /// </summary>
    public class CGDataRequestShapeRasterization : CGDataRequestRasterization
    {
        /// <summary>
        /// The <see cref="CGShape.RelativeDistances"/> array of the <see cref="CGPath"/> instance used for the shape extrusion that requests the current Shape rasterization
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<float> RelativeDistances
        {
            get => relativeDistances;
            set => relativeDistances = value;
        }

        /// <summary>
        /// The <see cref="CGShape.RelativeDistances"/> array of the <see cref="CGPath"/> instance used for the shape extrusion that requests the current Shape rasterization
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use RelativeDistances instead")]
        public float[] PathF
        {
            get => RelativeDistances.CopyToArray(ArrayPools.Single);
            set => RelativeDistances = new SubArray<float>(value);
        }

        private SubArray<float> relativeDistances;

        public CGDataRequestShapeRasterization(SubArray<float> relativeDistance, float start, float rasterizedRelativeLength, int resolution, float angle, ModeEnum mode = ModeEnum.Even) : base(start, rasterizedRelativeLength, resolution, angle, mode)
        {
            relativeDistances = ArrayPools.Single.Clone(relativeDistance);
        }

        [Obsolete("Use another constructor instead")]
        public CGDataRequestShapeRasterization(float[] pathF, float start, float rasterizedRelativeLength, int resolution, float angle, ModeEnum mode = ModeEnum.Even) : base(start, rasterizedRelativeLength, resolution, angle, mode)
        {
            relativeDistances = ArrayPools.Single.Clone(pathF);
        }

        public override bool Equals(object obj)
        {
            CGDataRequestShapeRasterization other = obj as CGDataRequestShapeRasterization;
            if (other == null)
                return false;

            if (!base.Equals(obj) || other.relativeDistances.Count != relativeDistances.Count)
                return false;

            for (var i = 0; i < relativeDistances.Count; i++)
            {
                if (other.relativeDistances.Array[i].Equals(relativeDistances.Array[i]) == false)
                    return false;
            }

            return true;
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return (base.GetHashCode() * 397) ^ (relativeDistances != null
                           ? relativeDistances.GetHashCode()
                           : 0);
            }
        }

        public override string ToString()
        {
            return $"{base.ToString()}, {nameof(RelativeDistances)}: {relativeDistances}";
        }
    }

    /// <summary>
    /// Rasterization Request parameters
    /// </summary>
    public class CGDataRequestRasterization : CGDataRequestParameter
    {
#if CONTRACTS_FULL
        [ContractInvariantMethod]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "Required for code contracts.")]
        private void ObjectInvariant()
        {
            Contract.Invariant(Start.IsRatio());
            Contract.Invariant(RasterizedRelativeLength.IsRatio());
            Contract.Invariant(Resolution > 0);
            Contract.Invariant(Resolution <= 100);
            Contract.Invariant(SplineAbsoluteLength.IsPositiveNumber());
            Contract.Invariant(AngleThreshold.IsIn0To180Range());
        }
#endif


        public enum ModeEnum
        {
            /// <summary>
            /// Distribute sample points evenly spread
            /// </summary>
            Even,
            /// <summary>
            /// Use Source' curvation to optimize the result
            /// </summary>
            Optimized
        }

        /// <summary>
        /// Relative Start Position (0..1)
        /// </summary>
        public float Start;

        /// <summary>
        /// Relative Length. A value of 1 means the full spline length
        /// </summary>
        public float RasterizedRelativeLength;

        /// <summary>
        /// Maximum number of samplepoints
        /// </summary>
        public int Resolution;

        /// <summary>
        /// Angle resolution (0..100) for optimized mode
        /// </summary>
        public float AngleThreshold;

        /// <summary>
        /// Rasterization mode
        /// </summary>
        public ModeEnum Mode;

        public CGDataRequestRasterization(float start, float rasterizedRelativeLength, int resolution, float angle, ModeEnum mode = ModeEnum.Even)
        {
#if CONTRACTS_FULL
            Contract.Requires(rasterizedRelativeLength.IsRatio());
#endif
            Start = Mathf.Repeat(start, 1);
            RasterizedRelativeLength = Mathf.Clamp01(rasterizedRelativeLength);
            Resolution = resolution;
            AngleThreshold = angle;
            Mode = mode;
        }

        public CGDataRequestRasterization(CGDataRequestRasterization source) : this(source.Start, source.RasterizedRelativeLength, source.Resolution, source.AngleThreshold, source.Mode)
        {
        }

        public override bool Equals(object obj)
        {
            CGDataRequestRasterization O = obj as CGDataRequestRasterization;
            if (O == null)
                return false;
            return (Start == O.Start && RasterizedRelativeLength == O.RasterizedRelativeLength && Resolution == O.Resolution && AngleThreshold == O.AngleThreshold && Mode == O.Mode);
        }

        public override int GetHashCode()
        {
            return new { A = Start, B = RasterizedRelativeLength, C = Resolution, D = AngleThreshold, E = Mode }.GetHashCode(); //OPTIM avoid array creation
        }

        public override string ToString()
        {
            return $"{nameof(Start)}: {Start}, {nameof(RasterizedRelativeLength)}: {RasterizedRelativeLength}, {nameof(Resolution)}: {Resolution}, {nameof(AngleThreshold)}: {AngleThreshold}, {nameof(Mode)}: {Mode}";
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGDataRequests.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 795eae83fdd52ee4697860cab17950d3
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;

#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Curvy Generator related event
    /// </summary>
    [System.Serializable]
    public class CurvyCGEvent : UnityEventEx<CurvyCGEventArgs> { }

    /// <summary>
    /// EventArgs for CurvyCGEvent events
    /// </summary>
    public class CurvyCGEventArgs : System.EventArgs
    {
        /// <summary>
        /// the component raising the event
        /// </summary>
        public readonly MonoBehaviour Sender;
        /// <summary>
        /// The related CurvyGenerator
        /// </summary>
        public readonly CurvyGenerator Generator;
        /// <summary>
        /// The related CGModule
        /// </summary>
        public readonly CGModule Module;

        public CurvyCGEventArgs(CGModule module)
        {
            Sender = module;
            Generator = module.Generator;
            Module = module;

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(Sender != null);
#endif
        }

        public CurvyCGEventArgs(CurvyGenerator generator, CGModule module)
        {
            Sender = generator;
            Generator = generator;
            Module = module;

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(Sender != null);
#endif
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGEvents.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGInterfaces.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0db4b847e74dae148ad1ba0205adbd50
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.DevTools;
using JetBrains.Annotations;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// For modules that don't process anything
    /// </summary>
    public interface INoProcessing
    {
    }

    /// <summary>
    /// For modules that rely on external input (Splines, Meshes etc..)
    /// </summary>
    public interface IExternalInput
    {
        /// <summary>
        /// Whether the module currently supports an IPE session
        /// </summary>
        bool SupportsIPE { get; }
    }

    /// <summary>
    /// For modules that process data on demand
    /// </summary>
    public interface IOnRequestProcessing
    {
        CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests);
    }

    /// <summary>
    /// For modules that output instances of <see cref="CGPath"/>
    /// </summary>
    public interface IPathProvider
    {
        bool PathIsClosed { get; }
    }

    /// <summary>
    /// Resource Loader Interface
    /// </summary>
    public interface ICGResourceLoader
    {
        Component Create(CGModule cgModule, [NotNull] string context);
        void Destroy(CGModule cgModule, Component obj, [NotNull] string context, bool kill);
    }

    /// <summary>
    /// Resource Collection interface
    /// </summary>
    public interface ICGResourceCollection
    {
        int Count { get; }
        Component[] ItemsArray { get; }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGInterfaces.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGMeshResource.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bfd1baeec4f08064eb868f23f209ebc6
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using System.Collections.Generic;
using Object = UnityEngine.Object;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Mesh Resource Component used by Curvy Generator
    /// </summary>
    [RequireComponent(typeof(MeshRenderer))]
    [HelpURL(CurvySpline.DOCLINK + "cgmeshresource")]
    public class CGMeshResource : DuplicateEditorMesh, IPoolable
    {
        /// <summary>
        /// The value of the "Everything" entry in a <see cref="MeshCollider.cookingOptions"/>'s inspector
        /// </summary>
        public const MeshColliderCookingOptions EverMeshColliderCookingOptions = 
            MeshColliderCookingOptions.EnableMeshCleaning|
            MeshColliderCookingOptions.CookForFasterSimulation|
            MeshColliderCookingOptions.UseFastMidphase|
            MeshColliderCookingOptions.WeldColocatedVertices;

        private MeshRenderer mRenderer;
        private Collider mCollider;

        public MeshRenderer Renderer
        {
            get
            {
                if (mRenderer == null)
                    mRenderer = GetComponent<MeshRenderer>();
                return mRenderer;
            }
        }

        public Collider Collider
        {
            get
            {
                if (mCollider == null)
                    mCollider = GetComponent<Collider>();
                return mCollider;
            }

        }

        public Mesh Prepare()
        {
            return Filter.PrepareNewShared();
        }

        public bool ColliderMatches(CGColliderEnum type)
        {
            if (Collider == null && type == CGColliderEnum.None)
                return true;
            if (Collider is MeshCollider && type == CGColliderEnum.Mesh)
                return true;
            if (Collider is BoxCollider && type == CGColliderEnum.Box)
                return true;
            if (Collider is SphereCollider && type == CGColliderEnum.Sphere)
                return true;
            if (Collider is CapsuleCollider && type == CGColliderEnum.Capsule)
                return true;

            return false;
        }

        public void RemoveCollider()
        {
            if (Collider)
            {
                mCollider.Destroy(false, false);
                mCollider = null;
            }
        }

        /// <summary>
        /// Updates the collider if existing, and create a new one if not.
        /// </summary>
        /// <param name="mode">The collider's type</param>
        /// <param name="convex">Used only when mode is CGColliderEnum.Mesh</param>
        /// <param name="isTrigger">Is the collider a Trigger</param>
        /// <param name="material">The collider's material</param>
        /// <param name="meshCookingOptions">Used only when mode is CGColliderEnum.Mesh</param>
        /// <returns></returns>
        public bool UpdateCollider(CGColliderEnum mode, bool convex, bool isTrigger, PhysicsMaterial material
            , MeshColliderCookingOptions meshCookingOptions = EverMeshColliderCookingOptions
            )
        {
            if (Collider == null)
                switch (mode)
                {
                    case CGColliderEnum.Mesh:
                        mCollider = gameObject.AddComponent<MeshCollider>();
                        break;
                    case CGColliderEnum.Box:
                        mCollider = gameObject.AddComponent<BoxCollider>();
                        break;
                    case CGColliderEnum.Sphere:
                        mCollider = gameObject.AddComponent<SphereCollider>();
                        break;
                    case CGColliderEnum.Capsule:
                        mCollider = gameObject.AddComponent<CapsuleCollider>();
                        break;
                    case CGColliderEnum.None:
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }

            if (mode != CGColliderEnum.None)
            {
                switch (mode)
                {
                    case CGColliderEnum.Mesh:
                        MeshCollider meshCollider = Collider as MeshCollider;
                        if (meshCollider != null)
                        {
                            meshCollider.sharedMesh = null;
                            meshCollider.convex = convex;
                            meshCollider.isTrigger = isTrigger;
                            meshCollider.cookingOptions = meshCookingOptions;
                            try
                            {
                                meshCollider.sharedMesh = Filter.sharedMesh;
                            }
#if CURVY_SANITY_CHECKS
                            catch (Exception e)
                            {
                                DTLog.LogException(e, this);
#else
                            catch
                            {
#endif
                                return false;
                            }
                        }
                        else
                            DTLog.LogError("[Curvy] Collider of wrong type", this);
                        break;
                    case CGColliderEnum.Box:
                        BoxCollider boxCollider = Collider as BoxCollider;
                        if (boxCollider != null)
                        {
                            boxCollider.isTrigger = isTrigger;
                            boxCollider.center = Filter.sharedMesh.bounds.center;
                            boxCollider.size = Filter.sharedMesh.bounds.size;
                        }
                        else
                            DTLog.LogError("[Curvy] Collider of wrong type", this);
                        break;
                    case CGColliderEnum.Sphere:
                        SphereCollider sphereCollider = Collider as SphereCollider;
                        if (sphereCollider != null)
                        {
                            sphereCollider.isTrigger = isTrigger;
                            sphereCollider.center = Filter.sharedMesh.bounds.center;
                            sphereCollider.radius = Filter.sharedMesh.bounds.extents.magnitude;
                        }
                        else
                            DTLog.LogError("[Curvy] Collider of wrong type", this);
                        break;
                    case CGColliderEnum.Capsule:
                        CapsuleCollider capsuleCollider = Collider as CapsuleCollider;
                        if (capsuleCollider != null)
                        {
                            Bounds sharedMeshBounds = Filter.sharedMesh.bounds;
                            capsuleCollider.isTrigger = isTrigger;
                            capsuleCollider.center = sharedMeshBounds.center;
                            capsuleCollider.radius = new Vector2(sharedMeshBounds.extents.x, sharedMeshBounds.extents.y).magnitude;
                            capsuleCollider.height = sharedMeshBounds.size.z;
                            capsuleCollider.direction = 2;//Z
                        }
                        else
                            DTLog.LogError("[Curvy] Collider of wrong type", this);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }

                Collider.material = material;
            }

            return true;
        }

        public void OnBeforePush()
        {
        }

        public void OnAfterPop()
        {
        }
    }

    /// <summary>
    /// Collection of Mesh Resources
    /// </summary>
    [System.Serializable]
    public class CGMeshResourceCollection : ICGResourceCollection
    {
        public List<CGMeshResource> Items = new List<CGMeshResource>();

        public int Count
        {
            get
            {
                return Items.Count;
            }
        }

        public Component[] ItemsArray
        {
            get { return Items.ToArray(); }
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGMeshResource.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3febf7cd67efdd24cabe9faf9224067e
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections.Generic;
using System.Reflection;
using FluffyUnderware.DevTools.Extensions;

using System.Collections;
using System.Globalization;
using FluffyUnderware.DevTools;
using JetBrains.Annotations;
using Random = UnityEngine.Random;
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.AnimatedValues;
#endif




namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Curvy Generator module base class
    /// </summary>
    [ExecuteAlways]
    public abstract class CGModule : DTVersionedMonoBehaviour
    {
        #region ### Events ###

        /*! \cond PRIVATE */

        [Group("Events", Expanded = false, Sort = 1000)]
        [SerializeField]
        protected CurvyCGEvent m_OnBeforeRefresh = new CurvyCGEvent();
        [Group("Events")]
        [SerializeField]
        protected CurvyCGEvent m_OnRefresh = new CurvyCGEvent();

        /*! \endcond */

        public CurvyCGEvent OnBeforeRefresh
        {
            get { return m_OnBeforeRefresh; }
            set
            {
                if (m_OnBeforeRefresh != value)
                    m_OnBeforeRefresh = value;

            }

        }

        public CurvyCGEvent OnRefresh
        {
            get { return m_OnRefresh; }
            set
            {
                if (m_OnRefresh != value)
                    m_OnRefresh = value;

            }

        }

        protected CurvyCGEventArgs OnBeforeRefreshEvent(CurvyCGEventArgs e)
        {
            if (OnBeforeRefresh != null)
                OnBeforeRefresh.Invoke(e);
            return e;
        }

        protected CurvyCGEventArgs OnRefreshEvent(CurvyCGEventArgs e)
        {
            if (OnRefresh != null)
                OnRefresh.Invoke(e);
            return e;
        }

        #endregion

        #region ### Public Fields & Properties ###

        #region --- Fields ---

        [SerializeField, HideInInspector] private string m_ModuleName;
        [SerializeField, HideInInspector] private bool m_Active = true;

        [Group("Seed Options", Expanded = false, Sort = 1001)]
        [GroupCondition(nameof(usesRandom))]
        [FieldAction("CBSeedOptions", ShowBelowProperty = true)]
        [SerializeField]
        private bool m_RandomizeSeed = false;

        [SerializeField, HideInInspector] private int m_Seed = unchecked((int)System.DateTime.Now.Ticks);

        #endregion


        #region --- API Accessors ---

        public string ModuleName
        {
            get { return name; }
            set
            {
                if (name != value)
                {
                    name = value;
                    renameManagedResourcesINTERNAL();
                }
            }
        }

        public bool Active
        {
            get { return m_Active; }
            set
            {
                if (m_Active != value)
                {
                    m_Active = value;
                    Dirty = true;
                    Generator.sortModulesINTERNAL();
                }
            }
        }

        /// <summary>
        /// If <see cref="RandomizeSeed"/> is set to false, Seed is used to initialize Unity's random numbers generator before refreshing the
        /// If <see cref="RandomizeSeed"/> is set to true, a random seed will be used
        /// current module
        /// </summary>
        public int Seed
        {
            get { return m_Seed; }
            set
            {
                if (m_Seed != value)
                    m_Seed = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// If is set to false, <see cref="Seed"/> is used to initialize Unity's random numbers generator before refreshing the current module.
        /// If set to true, a random seed will be used
        /// </summary>
        public bool RandomizeSeed
        {
            get { return m_RandomizeSeed; }
            set
            {
                if (m_RandomizeSeed != value)
                    m_RandomizeSeed = value;
            }
        }

        #endregion



        [System.NonSerialized]
        public List<string> UIMessages = new List<string>();

        public CurvyGenerator Generator
        {
            get { return mGenerator; }
        }

        private CurvyGenerator mGenerator;



        #endregion

        #region ### Graph Related ###


        #region UniqueID

        [SerializeField, HideInInspector] private int m_UniqueID;

        public int UniqueID
        {
            get { return m_UniqueID; }
        }

        // In order to reduce per frame allocations, we cache the string version
        private string m_UniqueIDString = null;
        private string UniqueIDString
        {
            get
            {
                if (m_UniqueIDString == null)
                    m_UniqueIDString = m_UniqueID.ToString(System.Globalization.CultureInfo.InvariantCulture);
                return m_UniqueIDString;
            }
        }

        #endregion


        /// <summary>
        /// Whether this module has circular reference errors
        /// </summary>
        public bool CircularReferenceError { get; set; }

        /// <summary>
        /// Helper for topology sorting
        /// </summary>
        //DESIGN inline this in doSortModules()
        internal int SortAncestors;


        [HideInInspector]
        public CGModuleProperties Properties = new CGModuleProperties();
        [HideInInspector]
        public List<CGModuleLink> InputLinks = new List<CGModuleLink>();
        [HideInInspector]
        public List<CGModuleLink> OutputLinks = new List<CGModuleLink>();

        // These will be filled by reflection in OnEnable()
        public Dictionary<string, CGModuleInputSlot> InputByName { get; private set; }
        public Dictionary<string, CGModuleOutputSlot> OutputByName { get; private set; }
        public List<CGModuleInputSlot> Input { get; private set; }
        public List<CGModuleOutputSlot> Output { get; private set; }

        public ModuleInfoAttribute Info
        {
            get
            {
                if (mInfo == null)
                    mInfo = getInfo();
                return mInfo;
            }
        }

        private ModuleInfoAttribute mInfo;

        //-----

        public bool Dirty
        {
            get { return mDirty; }
            set
            {
                if (mDirty != value)
                    mDirty = value;


                if (mDirty)
                {
                    bool isConfigured = IsConfigured;
                    if (mLastIsConfiguredState != isConfigured)
                        mStateChangeDirty = true;
                    mLastIsConfiguredState = isConfigured;
                    if (Output != null)
                    {
                        for (int i = 0; i < Output.Count; i++)
                        {
                            if (Output[i].IsLinked)
                            {
                                List<CGModule> modules = Output[i].GetLinkedModules();
                                for (int m = 0; m < modules.Count; m++)
                                    //BUG? does the || modules[m].CircularReferenceError create infinite dirtying logique?
                                    if (modules[m] != this || modules[m].CircularReferenceError) // prevent circular reference
                                        modules[m].Dirty = true;
                            }
                        }
                    }
                }

                if (this is IOnRequestProcessing || this is INoProcessing)
                {
                    mDirty = false;
                    if (Output != null)
                        for (int i = 0; i < Output.Count; i++)
                            Output[i].LastRequestParameters = null;
                }

            }
        }

        private bool mDirty = true;
        private bool mInitialized = false;

        private bool mStateChangeDirty;
        private bool mLastIsConfiguredState;


        #endregion

        #region ### Debugging ###
#if UNITY_EDITOR || CURVY_DEBUG
        public System.DateTime DEBUG_LastUpdateTime;
        public TimeMeasure DEBUG_ExecutionTime = new TimeMeasure(5);
#endif

        #endregion

        #region ### Unity Callbacks (Virtual) ###

        protected virtual void Awake()
        {
            mGenerator = RetrieveGenerator();
        }

        protected virtual void OnEnable()
        {
            if (mGenerator)
            {
                Initialize();
                Generator.sortModulesINTERNAL();
            }
        }

        public void Initialize()
        {
            if (!mGenerator)
                mGenerator = RetrieveGenerator();
            if (!mGenerator)
                Invoke(nameof(Delete), 0);
            else
            {
                mInfo = getInfo();

                if (string.IsNullOrEmpty(ModuleName))
                    if (string.IsNullOrEmpty(Info.ModuleName))
                        ModuleName = Generator.getUniqueModuleNameINTERNAL(Info.MenuName.Substring(Info.MenuName.LastIndexOf("/", StringComparison.Ordinal) + 1));
                    else
                        ModuleName = Generator.getUniqueModuleNameINTERNAL(Info.ModuleName);

                loadSlots();
                mInitialized = true;
            }
        }

        protected virtual void OnDisable()
        {
        }

        protected virtual void OnDestroy()
        {
            bool realDestroy = true;
#if UNITY_EDITOR
            if (EditorApplication.isPlayingOrWillChangePlaymode && !EditorApplication.isPlaying)
                realDestroy = false;
#endif
            setTreeDirtyStateChange();
            List<Component> res;
            List<string> resNames;
            // Resources
            if (realDestroy)
            {
                if (GetManagedResources(out res, out resNames))
                {
                    for (int i = res.Count - 1; i >= 0; i--)
                        DeleteManagedResource(resNames[i], res[i], string.Empty, true);
                }
            }

            // Links

            List<CGModuleInputSlot> inSlots = GetInputSlots();
            foreach (CGModuleInputSlot slot in inSlots)
            {
                List<CGModule> linkedModules = slot.GetLinkedModules();
                foreach (CGModule module in linkedModules)
                    if (module != null)
                        module.ReInitializeLinkedSlots();
            }

            List<CGModuleOutputSlot> outSlots = GetOutputSlots();
            foreach (CGModuleOutputSlot slot in outSlots)
            {
                List<CGModule> linkedModules = slot.GetLinkedModules();
                foreach (CGModule module in linkedModules)
                    if (module != null)
                        module.ReInitializeLinkedSlots();
            }

            if (Generator)
            {
                // Delete module
                Generator.ModulesByID.Remove(UniqueID);
                Generator.Modules.Remove(this);
                Generator.sortModulesINTERNAL();
            }
            mInitialized = false;
        }

#if UNITY_EDITOR
        /*DESIGN:simplify the CGModules' OnValidate and properties by:
        - Make properties set dirty only if the value has changed
        - Set dirty to true in CGModule.OnValidate
        - avoid calling SomeProperty = m_SomeProperty in the OnValidate of all CGModules. You have of course to handle any work done by SomeProperty, that is not dirtying, in the OnValidate of these modules.*/
        protected virtual void OnValidate()
        {
        }

        private void Update()
        {
            if (!Application.isPlaying)
                renameManagedResourcesINTERNAL();
        }
#endif
        private void OnDidApplyAnimationProperties()
        {
            Dirty = true;
        }

        #endregion

        #region ### Virtual Methods & Properties ###

        /// <summary>
        /// Gets whether the module is properly configured i.e. has everything to work like intended
        /// </summary>
        public virtual bool IsConfigured
        {
            get
            {
                if (!IsInitialized || CircularReferenceError || !Active)
                    return false;

                int validTotalLinks = 0;
                for (int i = 0; i < Input.Count; i++)
                {
                    InputSlotInfo myInfo = Input[i].InputInfo;
                    if (Input[i].IsLinked)
                    {
                        for (int link = 0; link < Input[i].Count; link++)
                            if (Input[i].SourceSlot(link) != null)
                            {
                                if (Input[i].SourceSlot(link).Module.IsConfigured)
                                    validTotalLinks++;
                                else if (!myInfo.Optional)
                                    return false;
                            }
                    }
                    else
                        if (myInfo == null || !myInfo.Optional)
                        return false;
                }

                return validTotalLinks > 0 || Input.Count == 0;
            }
        }

        /// <summary>
        /// Gets whether the module and all its dependencies are fully initialized
        /// </summary>
        public virtual bool IsInitialized { get { return mInitialized; } }

        /// <summary>
        /// Add Module processing code in here
        /// </summary>
        public virtual void Refresh()
        {
            //            Debug.Log(name + ".Refresh()");
            UIMessages.Clear();
        }

        public virtual void Reset()
        {
            ModuleName = string.IsNullOrEmpty(Info.ModuleName) ? GetType().Name : Info.ModuleName;

            //Remove all non-persisent (ie created from script) listeners from the events. Might help with garbage collection
            if (OnBeforeRefresh != null)
                OnBeforeRefresh.RemoveAllListeners();
            if (OnRefresh != null)
                OnRefresh.RemoveAllListeners();

            OnBeforeRefresh = new CurvyCGEvent();
            OnRefresh = new CurvyCGEvent();

            DeleteAllOutputManagedResources();
        }

        public void ReInitializeLinkedSlots()
        {
            List<CGModuleInputSlot> ins = GetInputSlots();
            List<CGModuleOutputSlot> ous = GetOutputSlots();
            for (int i = 0; i < ins.Count; i++)
                ins[i].ReInitializeLinkedSlots();
            for (int i = 0; i < ous.Count; i++)
                ous[i].ReInitializeLinkedSlots();
        }

        /// <summary>
        /// Delete all the managed resources acting as an output. One example of this are the generated meshes by the <see cref="FluffyUnderware.Curvy.Generator.Modules.CreateMesh"/> module
        /// </summary>
        /// <returns>True if there were deleted resources</returns>
        virtual public bool DeleteAllOutputManagedResources()
        {
            return false;
        }

        /// <summary>
        /// Called when a module's state changes (Link added/removed, Active toggles etc..)
        /// </summary>
        public virtual void OnStateChange()
        {
            //            Debug.Log(name + ".OSC, configured="+IsConfigured);
            Dirty = true;

            if (Output != null)
            {
                for (int i = 0; i < Output.Count; i++)
                {
                    Output[i].ClearData();
                    /*
                    if (Output[i].IsLinked)
                    {
                        var modules = Output[i].GetLinkedModules();
                        for (int m = 0; m < modules.Count; m++)
                            if (modules[m] != this || modules[m].CircularReferenceError) // prevent circular reference
                                modules[m].CheckAndRaiseOnStateChangedINTERNAL();
                    }
                     */
                }
            }
#if UNITY_EDITOR
            if (Input != null)
                for (int i = 0; i < Input.Count; i++)
                    Input[i].LastDataCountINTERNAL = 0;
#endif
            if (!IsConfigured)
                DeleteAllOutputManagedResources();
        }

        /// <summary>
        /// Called after a module was copied to a template
        /// </summary>
        /// <remarks>Use this handle references that can't be templated etc...</remarks>
        public virtual void OnTemplateCreated()
        {
            DeleteAllOutputManagedResources();
        }

        #endregion

        #region ### Helpers ###

        /// <summary>
        /// Gets a request parameter of a certain type
        /// </summary>
        /// <typeparam name="T">Type derived from PCGDataRequestParameter</typeparam>
        /// <param name="requests">reference to the list of request parameters</param>
        /// <returns>the wanted request parameter or null</returns>
        static protected T GetRequestParameter<T>(ref CGDataRequestParameter[] requests) where T : CGDataRequestParameter
        {
            for (int i = 0; i < requests.Length; i++)
                if (requests[i] is T)
                    return (T)requests[i];

            return null;
        }

        /// <summary>
        /// Removes a certain request parameter from the requests array
        /// </summary>
        /// <param name="requests">reference to the requests array</param>
        /// <param name="request">the request to remove</param>
        static protected void RemoveRequestParameter(ref CGDataRequestParameter[] requests, CGDataRequestParameter request)
        {
            for (int i = 0; i < requests.Length; i++)
                if (requests[i] == request)
                {
                    requests = requests.RemoveAt(i);
                    return;
                }

        }

        #endregion

        #region ### Public Methods ###


        public CGModuleLink GetOutputLink(CGModuleOutputSlot outSlot, CGModuleInputSlot inSlot)
        {
            return GetLink(OutputLinks, outSlot, inSlot);
        }

        public List<CGModuleLink> GetOutputLinks(CGModuleOutputSlot outSlot)
        {
            return GetLinks(OutputLinks, outSlot);
        }

        public CGModuleLink GetInputLink(CGModuleInputSlot inSlot, CGModuleOutputSlot outSlot)
        {
            return GetLink(InputLinks, inSlot, outSlot);
        }

        public List<CGModuleLink> GetInputLinks(CGModuleInputSlot inSlot)
        {
            return GetLinks(InputLinks, inSlot);
        }


        public CGModule CopyTo(CurvyGenerator targetGenerator)
        {
            if (this == null)
                throw new InvalidOperationException($"[Curvy] Trying to copy the already deleted module {this.name}");

            CGModule newModule = this.DuplicateGameObject<CGModule>(targetGenerator.transform, false);
            newModule.mGenerator = targetGenerator;
            newModule.Initialize();
            newModule.ModuleName = ModuleName;
            newModule.ModuleName = targetGenerator.getUniqueModuleNameINTERNAL(newModule.ModuleName);
            newModule.SetUniqueIdINTERNAL();
            newModule.renameManagedResourcesINTERNAL();
            return newModule;
        }

        public Component AddManagedResource(string resourceName, string context = "", int index = -1)
        {
            Component res = CGResourceHandler.CreateResource(this, resourceName, context);
            if (res == null)
                throw new InvalidOperationException(String.Format("[Curvy] Could not create managed resource of type '{0}'. In some cases this is due to not enough elements in a resources Pool", resourceName));
            res.name = GetResourceName(
                context == "" ? resourceName : (resourceName + context),
                index);
            res.transform.SetParent(transform);
            return res;
        }


        public void DeleteManagedResource(string resourceName, Component res, [NotNull] string context = "", bool dontUsePool = false)
        {
            if (res)
                CGResourceHandler.DestroyResource(this, resourceName, res, context, dontUsePool);
        }

        public bool IsManagedResource(Component res)
        {
            return (res && res.transform.parent == transform);//res.gameObject.GetComponentInParent<CurvyGenerator>() == Generator);RetrieveGenerator
        }


        public List<IPool> GetAllPrefabPools()
        {
            return Generator.PoolManager.FindPools(UniqueIDString + "_");
        }

        public void DeleteAllPrefabPools()
        {
            Generator.PoolManager.DeletePools(UniqueIDString + "_");
        }

        public void Delete()
        {
            OnStateChange();
            gameObject.Destroy(true, true);
        }

        public CGModuleInputSlot GetInputSlot(string name)
        {
            return (InputByName != null && InputByName.ContainsKey(name)) ? InputByName[name] : null;
        }

        public List<CGModuleInputSlot> GetInputSlots(System.Type filterType = null)
        {
            if (filterType == null)
                return new List<CGModuleInputSlot>(Input);
            else
            {
                List<CGModuleInputSlot> res = new List<CGModuleInputSlot>();
                for (int i = 0; i < Output.Count; i++)
                    if (Output[i].Info.DataTypes[0] == filterType || Output[i].Info.DataTypes[0].IsSubclassOf(filterType))
                        res.Add(Input[i]);

                return res;
            }
        }

        public CGModuleOutputSlot GetOutputSlot(string name)
        {
            return (OutputByName != null && OutputByName.ContainsKey(name)) ? OutputByName[name] : null;
        }

        public List<CGModuleOutputSlot> GetOutputSlots(System.Type filterType = null)
        {
            if (filterType == null)
                return new List<CGModuleOutputSlot>(Output);
            else
            {
                List<CGModuleOutputSlot> res = new List<CGModuleOutputSlot>();
                for (int i = 0; i < Output.Count; i++)
                    if (Output[i].Info.DataTypes[0] == filterType || Output[i].Info.DataTypes[0].IsSubclassOf(filterType))
                        res.Add(Output[i]);

                return res;
            }
        }

        public bool GetManagedResources(out List<Component> components, out List<string> resourceNames)
        {
            components = new List<Component>();
            resourceNames = new List<string>();
            FieldInfo[] fields = GetType().GetAllFields(false, true);
            foreach (FieldInfo f in fields)
            {
                CGResourceManagerAttribute at = f.GetCustomAttribute<CGResourceManagerAttribute>();
                if (at != null)
                {
                    if (typeof(ICGResourceCollection).IsAssignableFrom(f.FieldType))
                    {
                        ICGResourceCollection col = f.GetValue(this) as ICGResourceCollection;
                        if (col != null)
                        {
                            Component[] items = col.ItemsArray;
                            foreach (Component component in items)
                            {
                                //component can be null if for example the user delete from the hierarchy a CGMeshResource game object
                                if (component && component.transform.parent == transform)
                                {
                                    components.Add(component);
                                    resourceNames.Add(at.ResourceName);
                                }
                            }
                        }
                    }
                    else
                    {
                        Component component = f.GetValue(this) as Component;
                        if (component && component.transform.parent == transform)
                        {
                            components.Add(component);
                            resourceNames.Add(at.ResourceName);
                        }
                    }
                }
            }

            return (components.Count > 0);
        }



        #endregion

        #region ### Privates, Protected and Internals ###
        /*! \cond PRIVATE */
        /*! @name Internal Public
         *  Don't use them unless you know what you're doing!
         */
        //@{

        /*
        public void CheckAndRaiseOnStateChangedINTERNAL()
        {
            
            bool b = mLastIsConfiguredState;
            Debug.Log(name + " check ="+b+":"+IsConfigured);
            if (IsConfigured != b)
                OnStateChange();
            
        }
         */

        private readonly Dictionary<string, Dictionary<int, string>> resourcesNameCache = new Dictionary<string, Dictionary<int, string>>();

        private string GetResourceName(string resourceName, int index)
        {
            string newName = null;
            bool found;
            if (found = resourcesNameCache.TryGetValue(resourceName, out var dictionary))
                found = dictionary.TryGetValue(index, out newName);
            else
                resourcesNameCache[resourceName] = new Dictionary<int, string>();

            if (found == false)
            {
                newName = index > -1
                    ? string.Format(CultureInfo.InvariantCulture, "{0}_{1}_{2}{3:000}", ModuleName, UniqueIDString, resourceName, index)
                    : string.Format(CultureInfo.InvariantCulture, "{0}_{1}_{2}", ModuleName, UniqueIDString, resourceName);
                resourcesNameCache[resourceName][index] = newName;
            }

            return newName;
        }

        protected void RenameResource(string resourceName, Component resource, int index = -1)
        {
            string newName = GetResourceName(resourceName, index);
            //This check is necessary because when CurvyGenerator.ForceFrequentUpdates is true, this bug happens
            //[FIXED] When a scene has input spline path or input spline shape module, renaming objects from the hierarchy or though the F2 shortcut does not work
            if (resource.name != newName)
                resource.name = newName;
        }

        private static CGModuleLink GetLink(List<CGModuleLink> lst, CGModuleSlot source, CGModuleSlot target)
        {
            for (int i = 0; i < lst.Count; i++)
                if (lst[i].IsSame(source, target))
                    return lst[i];
            return null;
        }

        private static List<CGModuleLink> GetLinks(List<CGModuleLink> lst, CGModuleSlot source)
        {
            List<CGModuleLink> res = new List<CGModuleLink>();
            for (int i = 0; i < lst.Count; i++)
                if (lst[i].IsFrom(source))
                    res.Add(lst[i]);
            return res;
        }

        protected PrefabPool GetPrefabPool(GameObject prefab)
        {
            return Generator.PoolManager.GetPrefabPool(UniqueIDString + "_" + prefab.name, prefab);
        }

        protected bool TryDeleteChildrenFromAssociatedPrefab()
        {
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                int childCount = transform.childCount;
                for (int i = 0; i < childCount; i++)
                {
                    Transform item = transform.GetChild(i);
                    if (DTUtility.DoesPrefabStatusAllowDeletion(item.gameObject, out _) == false)
                    {
                        Generator.DeleteAllOutputManagedResourcesFromAssociatedPrefab();
                        return true;
                    }
                }
            }
#endif
            return false;
        }


        public int SetUniqueIdINTERNAL()
        {
            m_UniqueID = ++Generator.m_LastModuleID;
            m_UniqueIDString = null; //invalidate cache
            return m_UniqueID;
        }

        /// <summary>
        /// Initializes SortAncestor with number of connected Input links
        /// </summary>
        //DESIGN inline this in doSortModules()
        internal void initializeSort()
        {
            SortAncestors = 0;
            CircularReferenceError = false;
            //if (Active)
            //{
            for (int i = 0; i < Input.Count; i++)
                if (Input[i].IsLinked)
                    SortAncestors += Input[i].LinkedSlots.Count;
            //}
        }
        /// <summary>
        /// Decrement SortAncestor of linked modules and return a list of childs where SortAncestor==0
        /// </summary>
        /// <returns></returns>
        //DESIGN inline this in doSortModules()
        internal List<CGModule> decrementChilds()
        {
            List<CGModule> noAncestors = new List<CGModule>();
            for (int s = 0; s < Output.Count; s++)
                for (int l = 0; l < Output[s].LinkedSlots.Count; l++)
                {
                    if (--Output[s].LinkedSlots[l].Module.SortAncestors == 0)
                        noAncestors.Add(Output[s].LinkedSlots[l].Module);
                }

            return noAncestors;
        }

        internal void doRefresh()
        {
#if UNITY_EDITOR || CURVY_DEBUG
            DEBUG_LastUpdateTime = System.DateTime.Now;
            DEBUG_ExecutionTime.Start();
#endif

            if (RandomizeSeed)
                Random.InitState(unchecked((int)System.DateTime.Now.Ticks));
            else
                Random.InitState(Seed);
            OnBeforeRefreshEvent(new CurvyCGEventArgs(this));
            Refresh();
            Random.InitState(unchecked((int)System.DateTime.Now.Ticks));

#if UNITY_EDITOR || CURVY_DEBUG
            DEBUG_ExecutionTime.Stop();
#endif
            OnRefreshEvent(new CurvyCGEventArgs(this));

            mDirty = false;
        }

        internal ModuleInfoAttribute getInfo()
        {
            object[] inf = GetType().GetCustomAttributes(typeof(ModuleInfoAttribute), true);
            return (inf.Length > 0) ? (ModuleInfoAttribute)inf[0] : null;
        }

        private bool usesRandom()
        {
            return (Info != null && Info.UsesRandom);
        }

        private void loadSlots()
        {
            // Get list of Slots
            InputByName = new Dictionary<string, CGModuleInputSlot>();
            OutputByName = new Dictionary<string, CGModuleOutputSlot>();
            Input = new List<CGModuleInputSlot>();
            Output = new List<CGModuleOutputSlot>();
            FieldInfo[] fields = GetType().GetAllFields();
            //Debug.Log(name + ".loadSlots()");
            foreach (FieldInfo f in fields)
            {
                if (f.FieldType == typeof(CGModuleInputSlot))
                {
                    CGModuleInputSlot s = (CGModuleInputSlot)f.GetValue(this);
                    s.Module = this;
                    s.Info = getSlotInfo(f);
                    s.ReInitializeLinkedSlots();
                    InputByName.Add(s.Info.Name, s);
                    Input.Add(s);
                }
                else if (f.FieldType == typeof(CGModuleOutputSlot))
                {
                    CGModuleOutputSlot s = (CGModuleOutputSlot)f.GetValue(this);
                    s.Module = this;
                    s.Info = getSlotInfo(f);
                    s.ReInitializeLinkedSlots();
                    OutputByName.Add(s.Info.Name, s);
                    Output.Add(s);
                }
            }
        }

        private SlotInfo getSlotInfo(FieldInfo f)
        {
            SlotInfo si = f.GetCustomAttribute<SlotInfo>();
            if (si != null)
            {
                if (string.IsNullOrEmpty(si.Name))
                    si.Name = f.Name.TrimStart("In").TrimStart("Out");
                for (int x = 0; x < si.DataTypes.Length; x++)
                    if (!si.DataTypes[x].IsSubclassOf(typeof(CGData)))
                        Debug.LogError(string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}, Slot '{1}': Data type needs to be subclass of CGData!", GetType().Name, si.DisplayName));
                return si;
            }
            Debug.LogError("The Slot '" + f.Name + "' of type '" + f.DeclaringType.Name + "' needs a SlotInfo attribute!");
            return null;
        }

        private void setTreeDirtyStateChange()
        {
            mStateChangeDirty = true;
            if (Output != null)
            {
                for (int i = 0; i < Output.Count; i++)
                {
                    if (Output[i].IsLinked)
                    {
                        List<CGModule> modules = Output[i].GetLinkedModules();
                        for (int m = 0; m < modules.Count; m++)
                            //BUG? does the || modules[m].CircularReferenceError create infinite dirtying logique?
                            if (modules[m] != this || modules[m].CircularReferenceError) // prevent circular reference
                                modules[m].setTreeDirtyStateChange();
                    }
                }
            }
        }

        private CurvyGenerator RetrieveGenerator()
        {
            //return GetComponentInParent<CurvyGenerator>();
            return transform.parent != null
                ? transform.parent.GetComponent<CurvyGenerator>()
                : null;
        }

        public void checkOnStateChangedINTERNAL()
        {
            //            Debug.Log(ModuleName+".Check: " + mStateChangeDirty);
            if (mStateChangeDirty)
                OnStateChange();
            mStateChangeDirty = false;
        }


        public void renameManagedResourcesINTERNAL()
        {
            FieldInfo[] fields = GetType().GetAllFields(false, true);
            foreach (FieldInfo f in fields)
            {
                CGResourceManagerAttribute at = f.GetCustomAttribute<CGResourceManagerAttribute>();
                if (at != null)
                {
                    Component cmp = f.GetValue(this) as Component;
                    if (cmp && cmp.transform.parent == this.transform)
                        RenameResource(at.ResourceName, cmp);
                }
            }
        }


        //@}
        /*! \endcond */
        #endregion


    }

    /// <summary>
    /// Attribute defining basic module properties
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public sealed class ModuleInfoAttribute : System.Attribute, System.IComparable
    {
        /// <summary>
        /// Menu-Name of the module (without '/')
        /// </summary>
        public readonly string MenuName;
        /// <summary>
        /// Default Module name
        /// </summary>
        public string ModuleName;
        /// <summary>
        /// Tooltip Info
        /// </summary>
        public string Description;

        /// <summary>
        /// Whether the module uses Random, i.e. should show Seed options
        /// </summary>
        public bool UsesRandom;

        public ModuleInfoAttribute(string name)
        {
            MenuName = name;
        }

        public int CompareTo(object obj)
        {
            return String.Compare(MenuName, ((ModuleInfoAttribute)obj).MenuName, StringComparison.Ordinal);
        }



        //TODO code analysis (CA1036) says that Equal, !=, <, == and > should be defined since IComparable is implemented
    }


    /// <summary>
    /// CGModule helper class
    /// </summary>
    [System.Serializable]
    public class CGModuleProperties
    {
        public Rect Dimensions;
#if UNITY_EDITOR
        public AnimBool Expanded;
#endif
        public float MinWidth = 250;
        public float LabelWidth;
        public Color BackgroundColor = Color.black;

        public CGModuleProperties()
        {
#if UNITY_EDITOR
            Expanded = new AnimBool(true);
            Expanded.speed = 3;
#endif
        }
    }


}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModuleLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a742dce02c15b8544a4337da3c04c78a
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Class defining a linkage between two modules' slots
    /// </summary>
    [System.Serializable]
    public class CGModuleLink
    {
        // Self
        [SerializeField] private int m_ModuleID;
        [SerializeField] private string m_SlotName;
        // Other
        [SerializeField] private int m_TargetModuleID;
        [SerializeField] private string m_TargetSlotName;

        public int ModuleID { get { return m_ModuleID; } }
        public string SlotName { get { return m_SlotName;} }
        public int TargetModuleID { get { return m_TargetModuleID; } }
        public string TargetSlotName { get { return m_TargetSlotName; } }
        
        

        public CGModuleLink(int sourceID, string sourceSlotName, int targetID, string targetSlotName)
        {
            m_ModuleID = sourceID;
            m_SlotName = sourceSlotName;
            m_TargetModuleID = targetID;
            m_TargetSlotName = targetSlotName;
        }

        public CGModuleLink(CGModuleSlot source, CGModuleSlot target) : this(source.Module.UniqueID,source.Name,target.Module.UniqueID,target.Name) {}

        public bool IsSame(CGModuleLink o)
        {
            return (ModuleID == o.ModuleID &&
                    SlotName == o.SlotName &&
                    TargetModuleID == o.TargetModuleID &&
                    TargetSlotName == o.m_TargetSlotName);
        }

        public bool IsSame(CGModuleSlot source, CGModuleSlot target)
        {
            return (ModuleID == source.Module.UniqueID &&
                    SlotName == source.Name &&
                    TargetModuleID == target.Module.UniqueID &&
                    TargetSlotName == target.Name);
        }

        public bool IsTo(CGModuleSlot s)
        {
            return (s.Module.UniqueID == TargetModuleID && s.Name == TargetSlotName);
        }

        public bool IsFrom(CGModuleSlot s)
        {
            return (s.Module.UniqueID == ModuleID && s.Name == SlotName);
        }

        public bool IsUsing(CGModule module)
        {
            return (ModuleID == module.UniqueID || TargetModuleID == module.UniqueID);
        }

        public bool IsBetween(CGModuleSlot one, CGModuleSlot another)
        {
            return ((IsTo(one) && IsFrom(another)) ||
                   (IsTo(another) && IsFrom(one)));
        }

        public void SetModuleIDIINTERNAL(int moduleID, int targetModuleID)
        {
            m_ModuleID = moduleID;
            m_TargetModuleID = targetModuleID;
        }
        

        public static implicit operator bool(CGModuleLink a)
        {
            return !object.ReferenceEquals(a, null);
        }

        public override string ToString()
        {
            return string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}({1})->{2}({3})", SlotName, ModuleID, TargetSlotName, TargetModuleID);
        }
        
    }

   
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModuleLink.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModuleSlot.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 82ee39978f511ae4c9a157723ae1e1c1
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;
using System.Linq;
using System.Reflection;
using FluffyUnderware.DevTools;
using ToolBuddy.Pooling.Pools;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Class defining a module slot
    /// </summary>
    public class CGModuleSlot
    {
        /// <summary>
        /// The Module this Slot belongs to
        /// </summary>
        public CGModule Module { get; internal set; }
        /// <summary>
        /// Gets the SlotInfo Attribute
        /// </summary>
        public SlotInfo Info { get; internal set; }

        /// <summary>
        /// Origin of Link-Wire
        /// </summary>
        public Vector2 Origin { get; set; }
        /// <summary>
        /// Mouse-Hotzone
        /// </summary>
        public Rect DropZone { get; set; }

        /// <summary>
        /// Whether the link is wired or not
        /// </summary>
        public bool IsLinked { get { return LinkedSlots != null && LinkedSlots.Count > 0; } }
        /// <summary>
        /// Whether the link is wired and all connected modules are configured
        /// </summary>
        public bool IsLinkedAndConfigured
        {
            get
            {
                if (!IsLinked)
                    return false;
                for (int i = 0; i < LinkedSlots.Count; i++)
                    if (!LinkedSlots[i].Module.IsConfigured)
                        return false;
                return true;
            }
        }
        /// <summary>
        /// Gets the module as an <see cref="IOnRequestProcessing"/>
        /// </summary>
        public IOnRequestProcessing OnRequestModule { get { return Module as IOnRequestProcessing; } }
        /// <summary>
        /// Gets the module as an <see cref="IPathProvider"/>
        /// </summary>
        public IPathProvider PathProvider { get { return Module as IPathProvider; } }
        /// <summary>
        /// Gets the module as an <see cref="IExternalInput"/>
        /// </summary>
        public IExternalInput ExternalInput { get { return Module as IExternalInput; } }
        /// <summary>
        /// All slots of linked modules
        /// </summary>
        public List<CGModuleSlot> LinkedSlots
        {
            get
            {
                if (mLinkedSlots == null)
                    LoadLinkedSlots();
                return mLinkedSlots ?? new List<CGModuleSlot>();
            }
        }
        /// <summary>
        /// Gets the number of connected links, i.e. shortcut to this.Links.Count
        /// </summary>
        public int Count
        {
            get { return LinkedSlots.Count; }
        }

        public string Name
        {
            get { return (Info != null) ? Info.Name : ""; }
        }

        protected List<CGModuleSlot> mLinkedSlots = null;

        public CGModuleSlot()
        {

        }

        public bool HasLinkTo(CGModuleSlot other)
        {
            for (int i = 0; i < LinkedSlots.Count; i++)
                if (LinkedSlots[i] == other)
                    return true;

            return false;
        }

        /// <summary>
        /// Gets a list of all Links' modules
        /// </summary>
        public List<CGModule> GetLinkedModules()
        {
            List<CGModule> res = new List<CGModule>();
            for (int i = 0; i < LinkedSlots.Count; i++)
                res.Add(LinkedSlots[i].Module);
            return res;
        }

        public virtual void LinkTo(CGModuleSlot other)
        {
            if (Module)
            {
                Module.Generator.sortModulesINTERNAL();
                Module.Dirty = true;
            }
            if (other.Module)
                other.Module.Dirty = true;
        }

        protected static void LinkInputAndOutput(CGModuleSlot inputSlot, CGModuleSlot outputSlot)
        {
            if ((!inputSlot.Info.Array || inputSlot.Info.ArrayType == SlotInfo.SlotArrayType.Hidden) && inputSlot.IsLinked)
                inputSlot.UnlinkAll();

            outputSlot.Module.OutputLinks.Add(new CGModuleLink(outputSlot, inputSlot));
            inputSlot.Module.InputLinks.Add(new CGModuleLink(inputSlot, outputSlot));
            if (!outputSlot.LinkedSlots.Contains(inputSlot))
                outputSlot.LinkedSlots.Add(inputSlot);
            if (!inputSlot.LinkedSlots.Contains(outputSlot))
                inputSlot.LinkedSlots.Add(outputSlot);
        }

        public virtual void UnlinkFrom(CGModuleSlot other)
        {
            if (Module)
            {
                Module.Generator.sortModulesINTERNAL();
                Module.Dirty = true;
            }
            if (other.Module)
                other.Module.Dirty = true;
        }

        public virtual void UnlinkAll()
        {
        }

        public void ReInitializeLinkedSlots()
        {
            mLinkedSlots = null;
        }

        protected virtual void LoadLinkedSlots()
        {
        }

        public static implicit operator bool(CGModuleSlot a)
        {
            return !object.ReferenceEquals(a, null);
        }

        public override string ToString()
        {
            return string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}: {1}.{2}", GetType().Name, Module.name, Name);
        }

    }

    /// <summary>
    /// Class defining a module's input slot
    /// </summary>
    [System.Serializable]
    public class CGModuleInputSlot : CGModuleSlot
    {
        public InputSlotInfo InputInfo { get { return Info as InputSlotInfo; } }
#if UNITY_EDITOR
        public int LastDataCountINTERNAL { get; set; }
#endif
        public CGModuleInputSlot() : base() { }


        protected override void LoadLinkedSlots()
        {
            if (!Module.Generator.IsInitialized)
                return;
            base.LoadLinkedSlots();
            mLinkedSlots = new List<CGModuleSlot>();
            List<CGModuleLink> lnks = Module.GetInputLinks(this);
            foreach (CGModuleLink l in lnks)
            {
                CGModule mod = Module.Generator.GetModule(l.TargetModuleID, true);
                if (mod)
                {
                    CGModuleOutputSlot slot = mod.OutputByName[l.TargetSlotName];
                    // Sanitize missing links
                    if (!slot.Module.GetOutputLink(slot, this))
                    {
                        slot.Module.OutputLinks.Add(new CGModuleLink(slot, this));
                        slot.ReInitializeLinkedSlots();
                    }

                    if (!mLinkedSlots.Contains(slot))
                        mLinkedSlots.Add(slot);
                }
                else
                {
                    Module.InputLinks.Remove(l);
                }
            }
        }

        public override void UnlinkAll()
        {
            List<CGModuleSlot> ls = new List<CGModuleSlot>(LinkedSlots);
            foreach (CGModuleSlot l in ls)
            {
                UnlinkFrom(l);
            }
        }

        public override void LinkTo(CGModuleSlot outputSlot)
        {
            if (!HasLinkTo(outputSlot))
            {
                LinkInputAndOutput(this, outputSlot);
                base.LinkTo(outputSlot);
            }
        }

        public override void UnlinkFrom(CGModuleSlot outputSlot)
        {
            if (HasLinkTo(outputSlot))
            {
                CGModuleOutputSlot cgModuleOutputSlot = (CGModuleOutputSlot)outputSlot;
                CGModuleLink l1 = Module.GetInputLink(this, cgModuleOutputSlot);
                Module.InputLinks.Remove(l1);
                CGModuleLink l2 = outputSlot.Module.GetOutputLink(cgModuleOutputSlot, this);
                outputSlot.Module.OutputLinks.Remove(l2);

                LinkedSlots.Remove(outputSlot);
                outputSlot.LinkedSlots.Remove(this);

                base.UnlinkFrom(outputSlot);
            }
        }



        /// <summary>
        /// Gets a linked Output slot
        /// </summary>
        public CGModuleOutputSlot SourceSlot(int index = 0)
        {
            return (index < Count && index >= 0) ? (CGModuleOutputSlot)LinkedSlots[index] : null;
        }

        /// <summary>
        /// Determines if a particular output slot of another module can link to this slot
        /// </summary>
        /// <param name="source">the slot of the other module that'd like to link to this input slot</param>
        /// <returns>whether linking is allowed or not</returns>
        public bool CanLinkTo(CGModuleOutputSlot source)
        {
            return source.Module != Module && AreInputAndOutputSlotsCompatible(InputInfo, OnRequestModule != null, source.OutputInfo, source.OnRequestModule != null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="inputSlotInfo"></param>
        /// <param name="inputSlotModuleIsOnRequest">Does the module owning the input slot implement the IOnRequestProcessing interface</param>
        /// <param name="outputSlotInfo"></param>
        /// <param name="outputSlotModuleIsOnRequest">Does the module owning the output slot implement the IOnRequestProcessing interface</param>
        /// <returns></returns>
        public static bool AreInputAndOutputSlotsCompatible(InputSlotInfo inputSlotInfo, bool inputSlotModuleIsOnRequest, OutputSlotInfo outputSlotInfo, bool outputSlotModuleIsOnRequest)
        {
            return inputSlotInfo.IsValidFrom(outputSlotInfo.DataType) &&
                    ((outputSlotModuleIsOnRequest && (inputSlotInfo.RequestDataOnly || inputSlotModuleIsOnRequest)) || (outputSlotModuleIsOnRequest == false && !inputSlotInfo.RequestDataOnly));
        }

        /// <summary>
        /// Gets the module connected to the link
        /// </summary>
        /// <param name="index">the link index</param>
        /// <returns>a module</returns>
        private CGModule SourceModule(int index)
        {
            return (index < Count && index >= 0) ? LinkedSlots[index].Module : null;
        }

        /// <summary>
        /// Gets the data from the module connected to a certain input slot. If more than one module is connected, the first module's data is returned
        /// </summary>
        /// <typeparam name="T">type of requested data</typeparam>
        /// <param name="requests">request parameters</param>
        /// <returns>the data</returns>
        public T GetData<T>(params CGDataRequestParameter[] requests) where T : CGData
        {
            return GetData<T>(out _, requests);
        }

        /// <summary>
        /// Gets the data from the module connected to a certain input slot. If more than one module is connected, the first module's data is returned
        /// </summary>
        /// <typeparam name="T">type of requested data</typeparam>
        /// <param name="isDataDisposable">Whether the returned data can be disposed safely after using it, in order to make its resources available for future use, and thus reducing garbage collection.
        /// It is set to false when returned data is a direct reference to data stored by the module, and not a copy of it
        /// <seealso cref="CGData.Dispose(bool)"/>
        /// <seealso cref="ArrayPool{U}"/>
        /// </param>
        /// <param name="requests">request parameters</param>
        /// <returns>the data</returns>
        public T GetData<T>(out bool isDataDisposable, params CGDataRequestParameter[] requests) where T : CGData
        {
            CGData[] data = GetData<T>(0, out isDataDisposable, requests);
#if UNITY_EDITOR
            LastDataCountINTERNAL = (data == null || data.Length == 0) ? 0 : data.Length;
#endif
            if (data == null || data.Length == 0 || data[0] == null)
            {
                isDataDisposable = false;
                return null;
            }

            return data[0] as T;
        }

        /// <summary>
        /// Gets the data from all modules connected to a certain input slot.
        /// </summary>
        /// <typeparam name="T">type of requested data</typeparam>
        /// <param name="requests">request parameters</param>
        /// <returns>the data</returns>
        public List<T> GetAllData<T>(params CGDataRequestParameter[] requests) where T : CGData
        {
            return GetAllData<T>(out _, requests);
        }

        /// <summary>
        /// Gets the data from all modules connected to a certain input slot.
        /// </summary>
        /// <typeparam name="T">type of requested data</typeparam>
        /// <param name="isDataDisposable">Whether the returned data can be disposed safely after using it, in order to make its resources available for future use, and thus reducing garbage collection.
        /// It is set to false when returned data is a direct reference to data stored by the module, and not a copy of it
        /// <seealso cref="CGData.Dispose(bool)"/>
        /// <seealso cref="ArrayPool{U}"/>
        /// </param>
        /// <param name="requests">request parameters</param>
        /// <returns>the data</returns>
        public List<T> GetAllData<T>(out bool isDataDisposable, params CGDataRequestParameter[] requests) where T : CGData
        {
            isDataDisposable = true;
            List<T> res = new List<T>();
            for (int i = 0; i < Count; i++)
            {
                CGData[] data = GetData<T>(i, out bool isDisposable, requests);
                if (data != null)
                {
                    //If in the returned there are multiple CGData, some needing to be disposed, others not, then we consider that none should be disposed
                    //This means that some data might not be flagged as disposable, which means it will be dispose once Finalize is called. Missed opportunity to instantly reuse its data. Not good for reducing garbage collection
                    isDataDisposable &= isDisposable;
#if CURVY_SANITY_CHECKS
                    //TODO right now there are no graph that I am aware of that can trigger the situation explained above, but in the future, if there are modules that take multiple paths as inputs, one of them can be from Input Path module (isDisposable true) and one from Shape Extrusion (output Volume, which is also a path, isDisposable false)
                    if (isDisposable && isDataDisposable == false)
                        DTLog.LogWarning("[Curvy] A disposable data was treated as not disposable");
#endif
                    if (!Info.Array)
                    {
                        res.Add(data[0] as T);
                        break;
                    }

                    for (int a = 0; a < data.Length; a++)
                        res.Add(data[a] as T);
                }
            }

#if UNITY_EDITOR
            LastDataCountINTERNAL = res.Count;
#endif
            return res;
        }

        /// <summary>
        /// Gets the data from the module connected to a certain input slot
        /// </summary>
        /// <typeparam name="T">type of requested data</typeparam>
        /// <param name="slotIndex">slot index (if the slot supports multiple inputs)</param>
        /// <param name="isDataDisposable">Whether the returned data can be disposed safely after using it, in order to make its resources available for future use, and thus reducing garbage collection.
        /// It is set to false when returned data is a direct reference to data stored by the module, and not a copy of it
        /// <seealso cref="CGData.Dispose(bool)"/>
        /// <seealso cref="ArrayPool{U}"/>
        /// </param>
        /// <param name="requests">request parameters</param>
        /// <returns>the data</returns>
        private CGData[] GetData<T>(int slotIndex, out bool isDataDisposable, params CGDataRequestParameter[] requests
            ) where T : CGData
        {
            CGModuleOutputSlot source = SourceSlot(slotIndex);
            if (source == null || !source.Module.Active)
            {
                isDataDisposable = true;
                return new CGData[0];
            }

            // Handles IOnRequestProcessing modules (i.e. modules that provides data on the fly)
            if (source.Module is IOnRequestProcessing)
            {
                bool needNewData = (source.Data == null || source.Data.Length == 0);
                // Return last data?
                if (!needNewData && source.LastRequestParameters != null && source.LastRequestParameters.Length == requests.Length)
                {
                    for (int i = 0; i < requests.Length; i++)
                        if (!requests[i].Equals(source.LastRequestParameters[i]))
                        {
                            needNewData = true;
                            break;
                        }
                }
                else
                    needNewData = true;

                if (needNewData)
                {
                    source.LastRequestParameters = requests;
#if UNITY_EDITOR || CURVY_DEBUG
                    source.Module.DEBUG_LastUpdateTime = System.DateTime.Now;
                    Module.DEBUG_ExecutionTime.Pause();
                    source.Module.DEBUG_ExecutionTime.Start();
#endif
                    source.Module.UIMessages.Clear();//TODO Find a way to move this line of code inside OnSlotDataRequest
                    source.SetData(((IOnRequestProcessing)source.Module).OnSlotDataRequest(this, source, requests));
#if UNITY_EDITOR || CURVY_DEBUG
                    source.Module.DEBUG_ExecutionTime.Stop();
                    Module.DEBUG_ExecutionTime.Start();
#endif
                }

            }

            bool copyData = InputInfo.ModifiesData || source.Module is IOnRequestProcessing;

            CGData[] result = copyData
                ? cloneData<T>(source.Data)
                : source.Data;

            isDataDisposable = copyData && result != null;

            return result; ;
        }

        private static CGData[] cloneData<T>(CGData[] source) where T : CGData
        {
            T[] d = new T[source.Length];
            for (int i = 0; i < source.Length; i++)
                d[i] = source[i] == null ? null : source[i].Clone<T>();
            return d;
        }

    }

    /// <summary>
    /// Class defining a module's output slot
    /// </summary>
    [System.Serializable]
    public class CGModuleOutputSlot : CGModuleSlot
    {
        public OutputSlotInfo OutputInfo { get { return Info as OutputSlotInfo; } }
        public CGData[] Data = new CGData[0];
        public CGDataRequestParameter[] LastRequestParameters; // used for caching of Virtual Modules

        public CGModuleOutputSlot() : base() { }

        protected override void LoadLinkedSlots()
        {
            if (!Module.Generator.IsInitialized)
                return;
            base.LoadLinkedSlots();
            mLinkedSlots = new List<CGModuleSlot>();
            List<CGModuleLink> lnks = Module.GetOutputLinks(this);
            foreach (CGModuleLink l in lnks)
            {
                CGModule mod = Module.Generator.GetModule(l.TargetModuleID, true);
                if (mod)
                {
                    CGModuleInputSlot slot = mod.InputByName[l.TargetSlotName];

                    // Sanitize missing links
                    if (!slot.Module.GetInputLink(slot, this))
                    {
                        slot.Module.InputLinks.Add(new CGModuleLink(slot, this));
                        slot.ReInitializeLinkedSlots();
                    }

                    if (!mLinkedSlots.Contains(slot))
                        mLinkedSlots.Add(slot);
                }
                else
                {
                    Module.OutputLinks.Remove(l);
                }
            }
        }

        public override void LinkTo(CGModuleSlot inputSlot)
        {
            if (!HasLinkTo(inputSlot))
            {
                LinkInputAndOutput(inputSlot, this);
                base.LinkTo(inputSlot);
            }
        }

        public override void UnlinkFrom(CGModuleSlot inputSlot)
        {
            if (HasLinkTo(inputSlot))
            {
                CGModuleInputSlot cgModuleInputSlot = (CGModuleInputSlot)inputSlot;
                CGModuleLink l1 = Module.GetOutputLink(this, cgModuleInputSlot);
                Module.OutputLinks.Remove(l1);

                CGModuleLink l2 = inputSlot.Module.GetInputLink(cgModuleInputSlot, this);
                inputSlot.Module.InputLinks.Remove(l2);

                LinkedSlots.Remove(inputSlot);
                inputSlot.LinkedSlots.Remove(this);

                base.UnlinkFrom(inputSlot);
            }
        }



        public bool HasData
        {
            get { return Data != null && Data.Length > 0 && Data[0] != null; }
        }

        public void ClearData()
        {
            AssignNewData(new CGData[0]);
        }

        private void AssignNewData(CGData[] newData)
        {
            if (Data == newData)
                return;

            foreach (CGData cgData in Data)
                if (cgData && newData.Contains(cgData) == false)
                    cgData.Dispose();

            Data = newData;
        }

        public void SetData<T>(List<T> newData) where T : CGData
        {
            CGData[] newDataArray;
            if (newData == null)
                newDataArray = new CGData[0];
            else
            {
                if (!Info.Array && newData.Count > 1)
                    Debug.LogWarning("[Curvy] " + Module.GetType().Name + " (" + Info.DisplayName + ") only supports a single data item! Either avoid calculating unnecessary data or define the slot as an array!");
                newDataArray = newData.ToArray();
            }
            AssignNewData(newDataArray);
        }

        public void SetData(params CGData[] newData)
        {
            //TODO why does this not do the same test then the other SetData method, i.e. if (!Info.Array && data.Count > 1)
            AssignNewData((newData == null) ? new CGData[0] : newData);
        }

        public T GetData<T>() where T : CGData
        {
            return (Data.Length == 0) ? null : Data[0] as T;
        }

        public T[] GetAllData<T>() where T : CGData
        {
            return Data as T[];
        }
    }

    /// <summary>
    /// Attribute to define slot properties
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1813:AvoidUnsealedAttributes")]
    [AttributeUsage(AttributeTargets.Field)]
    public class SlotInfo : Attribute, IComparable
    {
        /// <summary>
        /// Defines what type of Array is used
        /// </summary>
        public enum SlotArrayType
        {
            Unknown,
            /// <summary>
            /// An array that behaves like an array code wise and UI wise
            /// </summary>
            Normal,
            /// <summary>
            /// An array that behave like an array code wise, but is displayed as a single instance of CGData UI wise.
            /// This allows for CG modules to send/receive arrays, without giving the user the possibility to link multiple modules to the slot
            /// </summary>
            Hidden
        }

        public readonly Type[] DataTypes;

        /// <summary>
        /// If empty Field's name will be used, with slight modifications
        /// </summary>
        public string Name;

        private string displayName = null;
        /// <summary>
        /// If not null, this string will be used in the UI, while <see cref="Name"/> will be used in the data serialization and slots linking logic
        /// </summary>
        public string DisplayName
        {
            get { return displayName ?? Name; }
            set { displayName = value; }
        }

        public string Tooltip;

        /// <summary>
        /// Whether or not the slot accepts an array of CGData instances or a single instance of it
        /// </summary>
        public bool Array;//DESIGN should be renamed to IsArray

        /// <summary>
        /// When <see cref="Array"/> is true, this value defines what type of Array is used
        /// </summary>
        public SlotArrayType ArrayType = SlotArrayType.Normal;

        protected SlotInfo(string name, params Type[] type)
        {
            DataTypes = type;
            Name = name;
        }
        protected SlotInfo(params Type[] type) : this(null, type) { }

        public int CompareTo(object obj)
        {
            return String.Compare(((SlotInfo)obj).Name, Name, StringComparison.Ordinal);
        }

        //TODO code analysis (CA1036) says that Equal, !=, <, == and > should be defined since IComparable is implemented

    }
    /// <summary>
    /// Attribute to define input sot properties
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public sealed class InputSlotInfo : SlotInfo
    {
        public bool RequestDataOnly = false;
        public bool Optional = false;
        /// <summary>
        /// Whether this data is altered by the module.
        /// If true, the module providing data to this slot will return a copy of its data, and not the original copy, so you can safely modify it.
        /// </summary>
        // DESIGN should this be removed, and ask users to just clone the data when they need to modify it?
        public bool ModifiesData = false;

        public InputSlotInfo(string name, params Type[] type) : base(name, type) { }
        public InputSlotInfo(params Type[] type) : this(null, type) { }

        /// <summary>
        /// Gets whether outType is of same type or a subtype of one of our input types
        /// </summary>
        public bool IsValidFrom(Type outType)
        {
            for (int x = 0; x < DataTypes.Length; x++)
                if (outType == DataTypes[x] || outType.IsSubclassOf(DataTypes[x]))
                    return true;
            return false;
        }
    }

    /// <summary>
    /// Attribute to define output slot properties
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public class OutputSlotInfo : SlotInfo
    {
        public Type DataType
        {
            get
            {
                return DataTypes[0];
            }
        }

        public OutputSlotInfo(Type type) : this(null, type) { }

        public OutputSlotInfo(string name, Type type) : base(name, type) { }
    }

    /// <summary>
    /// An <see cref="OutputSlotInfo"/> preset for modules that output CGShape data. Allows modules to output a <see cref="CGShape"/> that varies along a shape extrusion. See also <see cref="CGDataRequestShapeRasterization"/>
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public class ShapeOutputSlotInfo : OutputSlotInfo
    {
        /// <summary>
        /// Whether this module outputs a <see cref="CGShape"/> that varies along a shape extrusion
        /// </summary>
        public bool OutputsVariableShape = false;

        public ShapeOutputSlotInfo() : this(null) { }
        public ShapeOutputSlotInfo(string name) : base(name, typeof(CGShape)) { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModuleSlot.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGResource.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e08f4ad1d0c546b4cab3c0faddd74868
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System.Collections.Generic;
using System.Reflection;
using FluffyUnderware.Curvy.Shapes;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Resource attribute
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public sealed class ResourceLoaderAttribute : System.Attribute
    {
        public readonly string ResourceName;

        public ResourceLoaderAttribute([NotNull] string resName)
        {
            ResourceName = resName;
        }
    }

    /// <summary>
    /// Resource Helper class used by Curvy Generator
    /// </summary>
    public static class CGResourceHandler
    {
        private static readonly Dictionary<string, ICGResourceLoader> Loader = new Dictionary<string, ICGResourceLoader>();

        public static Component CreateResource(CGModule module, [NotNull] string resName, [NotNull] string context)
        {
            if (Loader.Count == 0)
                getLoaders();
            if (Loader.ContainsKey(resName))
            {
                ICGResourceLoader loader = Loader[resName];
                return loader.Create(module, context);
            }
            else
            {
                Debug.LogError("CGResourceHandler: Missing Loader for resource '" + resName + "'");
                return null;
            }

        }

        public static void DestroyResource(CGModule module, [NotNull] string resName, Component obj, [NotNull] string context, bool kill)
        {
            if (Loader.Count == 0)
                getLoaders();
            if (Loader.ContainsKey(resName))
            {
                ICGResourceLoader loader = Loader[resName];
                loader.Destroy(module, obj, context, kill);
            }
            else
                Debug.LogError("CGResourceHandler: Missing Loader for resource '" + resName + "'");
        }

        private static void getLoaders()
        {
#if UNITY_EDITOR
            TypeCache.TypeCollection types = TypeCache.GetTypesDerivedFrom<ICGResourceLoader>();
#else
            Type[] types = TypeExt.GetLoadedTypes();
            Type ICGResourceLoaderType = typeof(ICGResourceLoader);
#endif

            foreach (Type T in types)
            {
#if UNITY_EDITOR == false
                if (ICGResourceLoaderType.IsAssignableFrom(T) && ICGResourceLoaderType != T)
#endif
                {
                    object[] attributes = (object[])T.GetCustomAttributes(typeof(ResourceLoaderAttribute), true);
                    if (attributes.Length > 0)
                    {
                        ICGResourceLoader o = (ICGResourceLoader)System.Activator.CreateInstance(T);
                        if (o != null)
                            Loader.Add(((ResourceLoaderAttribute)attributes[0]).ResourceName, o);
                    }
                    else
                    {
                        DTLog.LogError(String.Format("[Curvy] Could not register resource loader of type {0} because it does not have a ResourceLoader attribute", T.FullName));
                    }
                }
            }
        }
    }

    /// <summary>
    /// Spline resource loader class
    /// </summary>
    [ResourceLoader("Spline")]
    public class CGSplineResourceLoader : ICGResourceLoader
    {
        public Component Create(CGModule cgModule, string context)
        {
            CurvySpline spl = CurvySpline.Create();
            spl.transform.position = Vector3.zero;
            spl.Closed = true;
            spl.Add(new Vector3(0, 0, 0), new Vector3(5, 0, 10), new Vector3(-5, 0, 10));
            return spl;
        }

        public void Destroy(CGModule cgModule, Component obj, string context, bool kill)
        {
            if (obj != null)
                obj.gameObject.Destroy(false, false);//isUndoable is set to false because that's how it was working before. Try make this operation undoable if needed
        }
    }

    /// <summary>
    /// Shape (2D spline) resource loader class
    /// </summary>
    [ResourceLoader("Shape")]
    public class CGShapeResourceLoader : ICGResourceLoader
    {

        public Component Create(CGModule cgModule, string context)
        {
            CurvySpline spl = CurvySpline.Create();
            spl.transform.position = Vector3.zero;
            spl.RestrictTo2D = true;
            spl.Closed = true;
            spl.Orientation = CurvyOrientation.None;
            spl.gameObject.AddComponent<CSCircle>().Refresh();
            return spl;
        }

        public void Destroy(CGModule cgModule, Component obj, string context, bool kill)
        {
            if (obj != null)
                obj.gameObject.Destroy(false, false);//isUndoable is set to false because that's how it was working before. Try make this operation undoable if needed
        }
    }

    /// <summary>
    /// Mesh resource loader class
    /// </summary>
    [ResourceLoader("Mesh")]
    public class CGMeshResourceLoader : ICGResourceLoader
    {
        public Component Create(CGModule cgModule, string context)
        {
            Component cmp = cgModule.Generator.PoolManager.GetComponentPool<CGMeshResource>().Pop();
            return cmp;
        }

        public void Destroy(CGModule cgModule, Component obj, string context, bool kill)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(obj.GetComponent<CGMeshResource>() != null);
#endif
            if (obj != null)
            {
                if (kill)
                {
                    obj.gameObject.Destroy(false, false);
                }
                else
                {
                    obj.StripComponents(typeof(CGMeshResource), typeof(MeshFilter), typeof(MeshRenderer));
                    //OPTIM should we assign null to sharedMesh, so it can be garbage collected? It seems (need deeper investiguation) safe since every time we pop a CGMeshResource from the pool, the following code clears the shared mesh if it exists. And if you put this optim in prod, make sure the retrieval of a CGMeshResource from the pool and its initialization are done in the same atomic operation, and not like now in two separate methods
                    //obj.GetComponent<MeshFilter>().sharedMesh = null;
                    cgModule.Generator.PoolManager.GetComponentPool<CGMeshResource>().Push(obj);
                }
            }
        }
    }

    /// <summary>
    /// GameObject resource loader class
    /// </summary>
    [ResourceLoader("GameObject")]
    public class CGGameObjectResourceLoader : ICGResourceLoader
    {
        public Component Create(CGModule cgModule, string context)
        {
            GameObject go = cgModule.Generator.PoolManager.GetPrefabPool(context).Pop();
            return go ? go.transform : null;
        }

        public void Destroy(CGModule cgModule, Component obj, string context, bool kill)
        {
            if (obj != null)
            {
                if (kill)
                {
                    obj.gameObject.Destroy(false, false);
                }
                else
                {
                    cgModule.Generator.PoolManager.GetPrefabPool(context).Push(obj.gameObject);
                }
            }
        }
    }

    /// <summary>
    /// Collection of GameObject resources
    /// </summary>
    [System.Serializable]
    public class CGGameObjectResourceCollection : ICGResourceCollection
    {
        public List<Transform> Items = new List<Transform>();
        public List<string> PoolNames = new List<string>();

        public int Count
        {
            get
            {
                return Items.Count;
            }
        }

        public Component[] ItemsArray
        {
            get { return Items.ToArray(); }
        }
    }

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGResource.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0ddf8aabfb85e2a40bf54a226d9a16fc
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Curvy Generator Utility class
    /// </summary>
    public static class CGUtility
    {
        /// <summary>
        /// Calculates lightmap UV's
        /// </summary>
        /// <param name="uv">the UV to create UV2 for</param>
        /// <returns>UV2</returns>
        [Obsolete("Method will get remove in next major update. Copy its content if you need it")]
        public static Vector2[] CalculateUV2(Vector2[] uv)
        {
            Vector2[] UV2 = new Vector2[uv.Length];
            CalculateUV2(uv, UV2, uv.Length);
            return UV2;
        }

        /// <summary>
        /// Calculates lightmap UV's. Same as <see cref="CalculateUV2(Vector2[])"/>but without array allocation
        /// </summary>
        /// <param name="uv">the UV to create UV2 for</param>
        /// <param name="uv2">the UV2 array to fill data into</param>
        /// <param name="elementsNumber"> number of array elements to process</param>
        [Obsolete("Method will get remove in next major update. Copy its content if you need it")]
        public static void CalculateUV2(Vector2[] uv, Vector2[] uv2, int elementsNumber)
        {
            float maxU = 0;
            float maxV = 0;
            for (int i = 0; i < elementsNumber; i++)
            {
                maxU = maxU < uv[i].x ? uv[i].x : maxU;
                maxV = maxV < uv[i].y ? uv[i].y : maxV;
            }

            float oneOnMaxU = 1f / maxU;
            float oneOnMaxV = 1f / maxV;
            for (int i1 = 0; i1 < elementsNumber; i1++)
            {
                uv2[i1].x = uv[i1].x * oneOnMaxU;
                uv2[i1].y = uv[i1].y * oneOnMaxV;
            }
        }

        #region ### Rasterization Helpers ###

        /// <summary>
        /// Rasterization Helper class
        /// </summary>
        public static List<ControlPointOption> GetControlPointsWithOptions(CGDataRequestMetaCGOptions options, CurvySpline shape, float startDist, float endDist, bool optimize, out int initialMaterialID, out float initialMaxStep)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(shape.Count > 0);
#endif

            List<ControlPointOption> res = new List<ControlPointOption>();
            initialMaterialID = 0;
            initialMaxStep = float.MaxValue;
            CurvySplineSegment startSeg = shape.DistanceToSegment(startDist);

            CurvySplineSegment finishSeg;
            {
                float clampedEndDist;
                {
                    clampedEndDist = shape.ClampDistance(endDist, shape.Closed ? CurvyClamping.Loop : CurvyClamping.Clamp);
                    if (clampedEndDist == 0)
                        clampedEndDist = endDist;
                }
                finishSeg = (clampedEndDist == shape.Length) ? shape.LastVisibleControlPoint : shape.DistanceToSegment(clampedEndDist);
                if (endDist != shape.Length && endDist > finishSeg.Distance)
                {
                    finishSeg = shape.GetNextControlPoint(finishSeg);
                }
            }

            MetaCGOptions cgOptions;
            float loopOffset = 0;
            if (startSeg)
            {
                cgOptions = startSeg.GetMetadata<MetaCGOptions>(true);
                initialMaxStep = (cgOptions.MaxStepDistance == 0) ? float.MaxValue : cgOptions.MaxStepDistance;
                initialMaterialID = cgOptions.MaterialID;
                int currentMaterialID = initialMaterialID;

                float maxDist = cgOptions.MaxStepDistance;
                /*
                if ((options.CheckMaterialID && cgOptions.MaterialID != 0) ||
                       (optimize && cgOptions.MaxStepDistance != 0))
                    res.Add(new ControlPointOption(startSeg.LocalFToTF(0),
                                                   startSeg.Distance,
                                                   true,
                                                   cgOptions.MaterialID,
                                                   options.CheckHardEdges && cgOptions.HardEdge,
                                                   initialMaxStep,
                                                   (options.CheckExtendedUV && cgOptions.UVEdge),
                                                   options.CheckExtendedUV && cgOptions.ExplicitU,
                                                   cgOptions.FirstU,
                                                   cgOptions.SecondU));
                */


                CurvySplineSegment seg = shape.GetNextSegment(startSeg) ?? shape.GetNextControlPoint(startSeg);
                do
                {
                    cgOptions = seg.GetMetadata<MetaCGOptions>(true);
                    if (shape.GetControlPointIndex(seg) < shape.GetControlPointIndex(startSeg))
                        loopOffset = shape.Length;
                    if (options.IncludeControlPoints ||
                       cgOptions.CorrectedHardEdge ||
                       cgOptions.MaterialID != currentMaterialID ||
                       optimize && cgOptions.MaxStepDistance != maxDist ||
                       (cgOptions.CorrectedUVEdge || cgOptions.ExplicitU)
                        )
                    {
                        maxDist = (cgOptions.MaxStepDistance == 0) ? float.MaxValue : cgOptions.MaxStepDistance;
                        currentMaterialID = cgOptions.MaterialID;
                        res.Add(new ControlPointOption(seg.TF + Mathf.FloorToInt(loopOffset / shape.Length),
                                                       seg.Distance + loopOffset,
                                                       options.IncludeControlPoints,
                                                       currentMaterialID,
                                                        cgOptions.CorrectedHardEdge,
                                                       cgOptions.MaxStepDistance,
                                                       cgOptions.CorrectedUVEdge,
                                                       cgOptions.ExplicitU,
                                                       cgOptions.FirstU,
                                                       cgOptions.SecondU));

                    }
                    seg = shape.GetNextSegment(seg);
                } while (seg && seg != finishSeg);
                // Check UV settings of last cp (not a segment if open spline!)
                if (!seg && shape.LastVisibleControlPoint == finishSeg)
                {
                    cgOptions = finishSeg.GetMetadata<MetaCGOptions>(true);
                    if (cgOptions.ExplicitU)
                        res.Add(new ControlPointOption(1,
                            finishSeg.Distance + loopOffset,
                            options.IncludeControlPoints,
                            currentMaterialID,
                            cgOptions.CorrectedHardEdge,
                            cgOptions.MaxStepDistance,
                            cgOptions.CorrectedUVEdge,
                            cgOptions.ExplicitU,
                            cgOptions.FirstU,
                            cgOptions.SecondU));
                }
            }

            return res;
        }

        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGUtility.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CurvyGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 92f936dd5124460479f65d72577c8d9e
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using UnityEngine.SceneManagement;
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.Experimental.SceneManagement;
using UnityEditor.SceneManagement;
#endif


namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Curvy Generator component
    /// </summary>
    [ExecuteAlways]
    [HelpURL(CurvySpline.DOCLINK + "generator")]
    [AddComponentMenu("Curvy/Generator")]
    [RequireComponent(typeof(PoolManager))]
    public class CurvyGenerator : DTVersionedMonoBehaviour
    {

        #region ### Serialized Fields ###

        [Tooltip("Show Debug Output?")]
        [SerializeField]
        private bool m_ShowDebug;

        [Tooltip("Whether to automatically refresh the generator's output when necessary")]
        [SerializeField]
        private bool m_AutoRefresh = true;

        [FieldCondition(nameof(m_AutoRefresh), true)]
        [Positive(Tooltip = "The minimum delay between two automatic generator's refreshing while in Play mode, in milliseconds")]
        [SerializeField]
        private int m_RefreshDelay = 0;

        [FieldCondition(nameof(m_AutoRefresh), true)]
        [Positive(Tooltip = "The minimum delay between two automatic generator's refreshing while in Edit mode, in milliseconds")]
        [SerializeField]
        private int m_RefreshDelayEditor = 10;

        /*! \cond PRIVATE */

        [Section("Events", false, false, 1000, HelpURL = CurvySpline.DOCLINK + "generator_events")]
        [SerializeField]
        protected CurvyCGEvent m_OnRefresh = new CurvyCGEvent();

        /*! \endcond */

#if UNITY_EDITOR
        [Section("Advanced Settings", Sort = 2000, HelpURL = CurvySpline.DOCLINK + "generator_events", Expanded = false)]
        [Label(Tooltip = "Force this script to update in Edit mode as often as in Play mode. Most users don't need that.")]
        [SerializeField]
        private bool m_ForceFrequentUpdates;
#endif

        /// <summary>
        /// List of modules this Generator contains
        /// </summary>
        [HideInInspector]
        public List<CGModule> Modules = new List<CGModule>();

        [SerializeField, HideInInspector]
        internal int m_LastModuleID;

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Gets or sets whether to show debug outputs
        /// </summary>
        public bool ShowDebug
        {
            get { return m_ShowDebug; }
            set
            {
                if (m_ShowDebug != value)
                    m_ShowDebug = value;
            }
        }
        /// <summary>
        /// Gets or sets whether to automatically call <see cref="Refresh"/> if necessary
        /// </summary>
        public bool AutoRefresh
        {
            get { return m_AutoRefresh; }
            set
            {
                if (m_AutoRefresh != value)
                    m_AutoRefresh = value;
            }
        }
        /// <summary>
        /// Gets or sets the minimum delay between two consecutive calls to <see cref="Refresh"></see> while playing, expressed in milliseconds
        /// </summary>
        public int RefreshDelay
        {
            get { return m_RefreshDelay; }
            set
            {
                int v = Mathf.Max(0, value);
                if (m_RefreshDelay != v)
                    m_RefreshDelay = v;
            }
        }
        /// <summary>
        /// Gets or sets the minimum delay between two consecutive calls to <see cref="Refresh"></see> in the editor
        /// </summary>
        public int RefreshDelayEditor
        {
            get { return m_RefreshDelayEditor; }
            set
            {
                int v = Mathf.Max(0, value);
                if (m_RefreshDelayEditor != v)
                    m_RefreshDelayEditor = v;
            }
        }

#if UNITY_EDITOR
        /// <summary>
        /// By default Unity calls scripts' update less frequently in Edit mode. ForceFrequentUpdates forces this script to update in Edit mode as often as in Play mode. Most users don't need that.
        /// </summary>
        public bool ForceFrequentUpdates
        {
            get { return m_ForceFrequentUpdates; }
            set { m_ForceFrequentUpdates = value; }
        }
#endif

        /// <summary>
        /// Gets the PoolManager
        /// </summary>
        public PoolManager PoolManager
        {
            get
            {
                if (mPoolManager == null)
                    mPoolManager = GetComponent<PoolManager>();
                return mPoolManager;
            }
        }

        /// <summary>
        /// Event raised after refreshing the Generator
        /// </summary>
        public CurvyCGEvent OnRefresh
        {
            get { return m_OnRefresh; }
            set
            {
                if (m_OnRefresh != value)
                    m_OnRefresh = value;

            }
        }

        /// <summary>
        /// Gets whether the generator and all its dependencies are fully initialized
        /// </summary>
        public bool IsInitialized { get { return mInitialized; } }
        /// <summary>
        /// Gets whether the Generator is about to get destroyed
        /// </summary>
        public bool Destroying { get; private set; }

        /// <summary>
        /// Dictionary to get a module by it's ID
        /// </summary>
        public Dictionary<int, CGModule> ModulesByID = new Dictionary<int, CGModule>();

        #endregion

        #region ### Private Fields ###

        private bool mInitialized;
        private bool mInitializedPhaseOne;
        private bool mNeedSort = true;
        private double mLastUpdateTime;
        private PoolManager mPoolManager;

#if UNITY_EDITOR || CURVY_DEBUG
        // Debugging:
        public TimeMeasure DEBUG_ExecutionTime = new TimeMeasure(5);
#endif
#if UNITY_EDITOR
        // Refresh-Handling
        private double mLastEditorUpdateTime;

#endif

        /// <summary>
        /// Used in the modules reordering logic. Value's unit is pixels.
        /// </summary>
        private const int ModulesReorderingDeltaX = 50;
        /// <summary>
        /// Used in the modules reordering logic. Value's unit is pixels.
        /// </summary>
        private const int ModulesReorderingDeltaY = 20;

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        private void OnEnable()
        {
            PoolManager.AutoCreatePools = true;
#if UNITY_EDITOR
            EditorApplication.update += editorUpdate;
            if (!Application.isPlaying)
            {
                UnityEditorInternal.ComponentUtility.MoveComponentUp(this);
            }
#endif
        }

        private void OnDisable()
        {
            mInitialized = false;
            mInitializedPhaseOne = false;
            mNeedSort = true;
#if UNITY_EDITOR
            EditorApplication.update -= editorUpdate;
#endif
        }


        private void OnDestroy()
        {
            Destroying = true;
        }

#if UNITY_EDITOR
        private void editorUpdate()
        {
            if (AutoRefresh && Application.isPlaying == false)
            {
                if (ForceFrequentUpdates)
                    EditorApplication.QueuePlayerLoopUpdate();
                else
                    Update();
            }
        }
#endif

        private void Update()
        {
            if (!IsInitialized)
                Initialize();
            else
                TryAutoRefresh();
        }


        /*! \endcond */
        #endregion

        #region ### Public Static Methods ###

        /// <summary>
        /// Creates a new GameObject with a CurvyGenerator attached
        /// </summary>
        /// <returns>the Generator component</returns>
        public static CurvyGenerator Create()
        {
            GameObject go = new GameObject("Curvy Generator", typeof(CurvyGenerator));
            return go.GetComponent<CurvyGenerator>();
        }

        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Adds a Module
        /// </summary>
        /// <typeparam name="T">type of the Module</typeparam>
        /// <returns>the new Module</returns>
        public T AddModule<T>() where T : CGModule
        {
            return (T)AddModule(typeof(T));
        }
        /// <summary>
        /// Adds a Module
        /// </summary>
        /// <param name="type">type of the Module</param>
        /// <returns>the new Module</returns>
        public CGModule AddModule(System.Type type)
        {
            GameObject go = new GameObject("");
            go.transform.SetParent(transform, false);
            CGModule mod = (CGModule)go.AddComponent(type);
            mod.SetUniqueIdINTERNAL();
            Modules.Add(mod);
            ModulesByID.Add(mod.UniqueID, mod);
            return mod;
        }

        /// <summary>
        /// Auto-Arrange modules' graph canvas position
        /// In other words, this alligns the graph with the top left corner of the canvas. This does not modify the modules position relatively to each other
        /// </summary>
        public void ArrangeModules()
        {
            Vector2 min = new Vector2(float.MaxValue, float.MaxValue);
            foreach (CGModule mod in Modules)
            {
                min.x = Mathf.Min(mod.Properties.Dimensions.x, min.x);
                min.y = Mathf.Min(mod.Properties.Dimensions.y, min.y);
            }
            min -= new Vector2(10, 10);
            foreach (CGModule mod in Modules)
            {
                mod.Properties.Dimensions.x -= min.x;
                mod.Properties.Dimensions.y -= min.y;
            }
        }

        /// <summary>
        /// Changes the modules' positions to make the graph easier to read.
        /// </summary>
        public void ReorderModules()
        {
            Dictionary<CGModule, Rect> initialModulesPositions;
            {
                initialModulesPositions = new Dictionary<CGModule, Rect>(Modules.Count);
                foreach (CGModule cgModule in Modules)
                    initialModulesPositions[cgModule] = cgModule.Properties.Dimensions;
            }


            List<CGModule> endpointModules = Modules.Where(m => m.OutputLinks.Any() == false).ToList();


            //A dictionary that gives for each module the set of all the modules that are connected to its inputs, whether directly or indirectly
            Dictionary<CGModule, HashSet<CGModule>> modulesRecursiveInputs = new Dictionary<CGModule, HashSet<CGModule>>(Modules.Count);
            foreach (CGModule module in endpointModules)
                UpdateModulesRecursiveInputs(modulesRecursiveInputs, module);

            HashSet<int> reordredModuleIds = new HashSet<int>();
            for (int index = 0; index < endpointModules.Count; index++)
            {
                float endPointY = index == 0
                    ? 0
                    //Draw under the previous endpoint recursive inputs
                    : modulesRecursiveInputs[endpointModules[index - 1]].Max(m => m.Properties.Dimensions.yMax) + ModulesReorderingDeltaY;

                CGModule endpointModule = endpointModules[index];
                //Set the endpoint's position
                endpointModule.Properties.Dimensions.position = new Vector2(0, endPointY);
                reordredModuleIds.Add(endpointModule.UniqueID);
                //And then its children's positions, recursively
                ReorderEndpointRecursiveInputs(endpointModule, reordredModuleIds, modulesRecursiveInputs);
            }

            ArrangeModules();
#if UNITY_EDITOR
            if (Application.isPlaying == false)
                //Dirty scene if something changed
                if (Modules.Exists(m => m.Properties.Dimensions != initialModulesPositions[m]))
                    EditorSceneManager.MarkSceneDirty(SceneManager.GetActiveScene());
#endif
        }



        /// <summary>
        /// Clears the whole generator
        /// </summary>
        public void Clear()
        {
            //BUG when a module is a child of another one, destroying the first destroys the second, which lead to unwanted behavior in this loop

            bool isInEditMode = DTUtility.IsInEditMode;
            if (isInEditMode)
            {
#if UNITY_EDITOR
                bool skipAllMessages = false;

                for (int i = Modules.Count - 1; i >= 0; i--)
                {
                    CGModule module = Modules[i];
                    GameObject moduleGO = module.gameObject;

                    if (DTUtility.DoesPrefabStatusAllowDeletion(moduleGO, out string errorMessage))
                    {
                        if (moduleGO.Destroy(true, false) == false)
                            Debug.LogError("Could not destroy a CG module. This is not expected. Please send a bug report.");
                    }
                    else
                    {
                        if (skipAllMessages == false)
                            skipAllMessages = false == EditorUtility.DisplayDialog($"Cannot delete Game Object '{moduleGO.name}'", errorMessage, "Ok", "Skip All");
                    }
                }

                //Destroyed modules are not removed manually from Modules and ModulesByID because in edit mode, game objects are destroyed immediatly after the Destroy call, which leads to the OnDestroy being called, which removes the destroyed module from Modules and ModulesByID. In play mode, the game objects are destroyed at the frame's end, thus the need to clear Modules and ModulesByID in this method
                if (Modules.Count == 0)
                    m_LastModuleID = 0;
#endif
            }
            else
            {
                for (int i = Modules.Count - 1; i >= 0; i--)
                    if (Modules[i].gameObject.Destroy(true, false) == false)
                        Debug.LogError("Could not destroy a CG module. This is not expected. Please send a bug report.");

                Modules.Clear();
                ModulesByID.Clear();
                m_LastModuleID = 0;
            }
        }

        /// <summary>
        /// Deletes a module (same as PCGModule.Delete())
        /// </summary>
        /// <param name="module">a module</param>
        public void DeleteModule(CGModule module)
        {
            if (module)
                module.Delete();
        }

        /// <summary>
        /// Find modules of a given type
        /// </summary>
        /// <typeparam name="T">the module type</typeparam>
        /// <returns>a list of zero or more modules</returns>
        [Obsolete("Use the overload that has a mandatory includeOnRequestProcessing parameter")]
        public List<T> FindModules<T>() where T : CGModule => FindModules<T>(false);

        /// <summary>
        /// Find modules of a given type
        /// </summary>
        /// <typeparam name="T">the module type</typeparam>
        /// <param name="includeOnRequestProcessing">whether to include IOnRequestProcessing modules</param>
        /// <returns>a list of zero or more modules</returns>
        public List<T> FindModules<T>(bool includeOnRequestProcessing) where T : CGModule
        {
            List<T> res = new List<T>();
            for (int i = 0; i < Modules.Count; i++)
                if (Modules[i] is T && (includeOnRequestProcessing || !(Modules[i] is IOnRequestProcessing)))
                    res.Add((T)Modules[i]);
            return res;
        }

        /// <summary>
        /// Gets a list of modules, either including or excluding IOnRequestProcessing modules
        /// </summary>
        /// <returns>a list of zero or more modules</returns>
        [Obsolete("Use the overload that has a mandatory includeOnRequestProcessing parameter")]
        public List<CGModule> GetModules() => GetModules(false);

        /// <summary>
        /// Gets a list of modules, either including or excluding IOnRequestProcessing modules
        /// </summary>
        /// <param name="includeOnRequestProcessing">whether to include IOnRequestProcessing modules</param>
        public List<CGModule> GetModules(bool includeOnRequestProcessing)
        {

            if (includeOnRequestProcessing)
                return new List<CGModule>(Modules);
            else
            {
                List<CGModule> res = new List<CGModule>();
                for (int i = 0; i < Modules.Count; i++)
                    if (!(Modules[i] is IOnRequestProcessing))
                        res.Add(Modules[i]);
                return res;
            }
        }

        /// <summary>
        /// Gets a module by ID, either including or excluding IOnRequestProcessing modules
        /// </summary>
        /// <param name="moduleID">the ID of the module in question</param>
        [Obsolete("Use the overload that has a mandatory includeOnRequestProcessing parameter")]
        public CGModule GetModule(int moduleID) => GetModule(moduleID, false);

        /// <summary>
        /// Gets a module by ID, either including or excluding IOnRequestProcessing modules
        /// </summary>
        /// <param name="moduleID">the ID of the module in question</param>
        /// <param name="includeOnRequestProcessing">whether to include IOnRequestProcessing modules</param>
        public CGModule GetModule(int moduleID, bool includeOnRequestProcessing)
        {
            CGModule res;
            if (ModulesByID.TryGetValue(moduleID, out res) && (includeOnRequestProcessing || !(res is IOnRequestProcessing)))
                return res;
            else
                return null;
        }

        /// <summary>
        /// Gets a module by ID, either including or excluding IOnRequestProcessing modules (Generic version)
        /// </summary>
        /// <typeparam name="T">type of the module</typeparam>
        /// <param name="moduleID">the ID of the module in question</param>
        [Obsolete("Use the overload that has a mandatory includeOnRequestProcessing parameter")]
        public T GetModule<T>(int moduleID) where T : CGModule => GetModule<T>(moduleID, false);

        /// <summary>
        /// Gets a module by ID, either including or excluding IOnRequestProcessing modules (Generic version)
        /// </summary>
        /// <typeparam name="T">type of the module</typeparam>
        /// <param name="moduleID">the ID of the module in question</param>
        /// <param name="includeOnRequestProcessing">whether to include IOnRequestProcessing modules</param>
        public T GetModule<T>(int moduleID, bool includeOnRequestProcessing) where T : CGModule
        {
            return GetModule(moduleID, includeOnRequestProcessing) as T;
        }

        /// <summary>
        /// Gets a module by name, either including or excluding IOnRequestProcessing modules 
        /// </summary>
        /// <param name="moduleName"></param>
        [Obsolete("Use the overload that has a mandatory includeOnRequestProcessing parameter")]
        public CGModule GetModule(string moduleName) => GetModule(moduleName, false);

        /// <summary>
        /// Gets a module by name, either including or excluding IOnRequestProcessing modules 
        /// </summary>
        /// <param name="moduleName"></param>
        /// <param name="includeOnRequestProcessing"></param>
        public CGModule GetModule(string moduleName, bool includeOnRequestProcessing)
        {
            for (int i = 0; i < Modules.Count; i++)
                if (Modules[i].ModuleName.Equals(moduleName, System.StringComparison.CurrentCultureIgnoreCase) && (includeOnRequestProcessing || !(Modules[i] is IOnRequestProcessing)))
                    return Modules[i];

            return null;
        }

        /// <summary>
        /// Gets a module by name, either including or excluding IOnRequestProcessing modules (Generic version)
        /// </summary>
        /// <typeparam name="T">type of the module</typeparam>
        /// <param name="moduleName">the ID of the module in question</param>
        [Obsolete("Use the overload that has a mandatory includeOnRequestProcessing parameter")]
        public T GetModule<T>(string moduleName) where T : CGModule => GetModule<
            T>(moduleName, false);

        /// <summary>
        /// Gets a module by name, either including or excluding IOnRequestProcessing modules (Generic version)
        /// </summary>
        /// <typeparam name="T">type of the module</typeparam>
        /// <param name="moduleName">the ID of the module in question</param>
        /// <param name="includeOnRequestProcessing">whether to include IOnRequestProcessing modules</param>
        public T GetModule<T>(string moduleName, bool includeOnRequestProcessing) where T : CGModule
        {
            return GetModule(moduleName, includeOnRequestProcessing) as T;
        }

        /// <summary>
        /// Gets a module's output slot by module ID and slotName
        /// </summary>
        /// <param name="moduleId">Id of the module</param>
        /// <param name="slotName">Name of the slot</param>
        public CGModuleOutputSlot GetModuleOutputSlot(int moduleId, string slotName)
        {
            CGModule mod = GetModule(moduleId, true);
            if (mod)
                return mod.GetOutputSlot(slotName);
            else
                return null;
        }

        /// <summary>
        /// Gets a module's output slot by module name and slotName
        /// </summary>
        /// <param name="moduleName">Name of the module</param>
        /// <param name="slotName">Name of the slot</param>
        public CGModuleOutputSlot GetModuleOutputSlot(string moduleName, string slotName)
        {
            CGModule mod = GetModule(moduleName, true);
            if (mod)
                return mod.GetOutputSlot(slotName);
            else
                return null;
        }

        //TODO initialize earlier
        /// <summary>
        /// Initializes the Generator
        /// </summary>
        /// <param name="force">true to force reinitialization</param>
        public void Initialize(bool force = false)
        {
            if (this == null)//Modifying a prefab of a shape extrusion generator (removing its input spline then adding it back again) the updated of the generator gets called with a null generator. Probably due to the refreshing of the prefab file (to remove generated mesh)
                return;

            if (!mInitializedPhaseOne || force)
            {
                // Read modules
                ModulesByID.Clear();

                Modules.Clear();
                GetComponentsInChildren(Modules);
                //Not all modules are part of this generator. This happens for example if a generator creates GameObjects that are generators themselves
                Modules.RemoveAll(m => m.transform.parent != this.transform);

                for (int i = 0; i < Modules.Count; i++)
                {
                    if (!Modules[i].IsInitialized || force)
                        Modules[i].Initialize();

                    if (ModulesByID.ContainsKey(Modules[i].UniqueID))
                    {
                        Debug.LogError("ID of '" + Modules[i].ModuleName + "' isn't unique!");
                        return;
                    }
                    ModulesByID.Add(Modules[i].UniqueID, Modules[i]);
                }

                if (Modules.Count > 0)
                {
                    // Sort them
                    sortModulesINTERNAL();
                }
                mInitializedPhaseOne = true;
            }
            for (int m = 0; m < Modules.Count; m++)
                if (Modules[m] is IExternalInput && !Modules[m].IsInitialized)
                    return;

            mInitialized = true;
            mInitializedPhaseOne = false;
            mNeedSort = mNeedSort || force;
            Refresh(true);
        }

        /// <summary>
        /// Refreshes the Generator
        /// </summary>
        /// <param name="forceUpdate">true to force a refresh of all modules</param>
        public void Refresh(bool forceUpdate = false)
        {
            if (!IsInitialized)
                return;

            if (mNeedSort)
                //BUG this does not sort modules correctly
                doSortModules();//This is supposed to sort a module in a way that for each module, all its input modules are set in the modules list (which defines the updating order) before the said module

            CGModule firstChanged = null;

            for (int i = 0; i < Modules.Count; i++)
            {
                if (forceUpdate && Modules[i] is IOnRequestProcessing)
                    Modules[i].Dirty = true; // Dirty state will be resetted to false, but last data will be deleted - forcing a recalculation
                if (!(Modules[i] is INoProcessing) // ignore INoProcessing modules
                    && (Modules[i].Dirty // update dirty modules
                        || (forceUpdate && !(Modules[i] is IOnRequestProcessing)))) //update non dirty modules when forceUpdate is true, except IOnRequestProcessing modules, which by the way are never dirty, because the Dirty setter handles them differently, which I think is bad design, but this is not a major issue
                {
                    Modules[i].checkOnStateChangedINTERNAL();//BUG? this can set dirty to true, so shouldn't it be called before checking the value of Dirty earlier in this method?
                    if (Modules[i].IsInitialized && Modules[i].IsConfigured)
                    {

                        if (firstChanged == null)
                        {
#if UNITY_EDITOR || CURVY_DEBUG
                            DEBUG_ExecutionTime.Start();
#endif
                            firstChanged = Modules[i];
                        }

                        //OPTIM? remove this check, or make its compilation conditional
                        foreach (CGModuleInputSlot inputSlot in Modules[i].Input)
                        {
                            foreach (CGModuleSlot linkedSlot in inputSlot.LinkedSlots)
                                if (linkedSlot.Module.IsConfigured && linkedSlot.Module.Dirty)
                                    DTLog.LogError("[Curvy] Getting data from a dirty module. This shouldn't happen at all. Please raise a bug report. Source module is " + linkedSlot.Module, this);
                        }

                        Modules[i].doRefresh();
                    }
                }
            }
            if (firstChanged != null)
            {
#if UNITY_EDITOR
                DEBUG_ExecutionTime.Stop();
#endif
                OnRefreshEvent(new CurvyCGEventArgs(this, firstChanged));
            }
        }

        /// <summary>
        /// Will try to auto refresh the generator. Basically this calls <see cref="Refresh"/> if <see cref="AutoRefresh"/> is set and the refresh delays are respected
        /// </summary>
        public void TryAutoRefresh()
        {
            if (AutoRefresh)
            {
                double realtimeSinceStartup =
#if UNITY_2020_2_OR_NEWER
                    Time.realtimeSinceStartupAsDouble;
#else
                    Time.realtimeSinceStartup;
#endif

                float refreshDelayInSeconds = RefreshDelay * 0.001f;
                float refreshDelayEditorInSeconds = RefreshDelayEditor * 0.001f;

#if UNITY_EDITOR
                if (mLastEditorUpdateTime > realtimeSinceStartup)
                {
#if CURVY_SANITY_CHECKS
                    DTLog.LogWarning($"[Curvy] Curvy Generator: Auto Refresh timestamp is too big: mLastEditorUpdateTime {mLastEditorUpdateTime} realtimeSinceStartup {realtimeSinceStartup}", this);
#endif
                    mLastEditorUpdateTime = realtimeSinceStartup - refreshDelayEditorInSeconds;
                }
#endif

                if (mLastUpdateTime > realtimeSinceStartup)
                {
#if CURVY_SANITY_CHECKS
                    DTLog.LogWarning($"[Curvy] Curvy Generator: Auto Refresh timestamp is too big: mLastUpdateTime {mLastUpdateTime} realtimeSinceStartup {realtimeSinceStartup}", this);
#endif

                    mLastUpdateTime = realtimeSinceStartup - refreshDelayInSeconds;
                }

                if (Application.isPlaying)
                {
                    if (realtimeSinceStartup - mLastUpdateTime > refreshDelayInSeconds)
                    {
                        mLastUpdateTime = realtimeSinceStartup;
                        Refresh();
                    }
                }
#if UNITY_EDITOR
                else
                {
                    if (realtimeSinceStartup - mLastEditorUpdateTime > refreshDelayEditorInSeconds)
                    {
                        mLastEditorUpdateTime = realtimeSinceStartup;
                        Refresh();
                    }
                }
#endif
            }
        }

        /// <summary>
        /// Delete all the managed resources acting as an output. One example of this are the generated meshes by the <see cref="FluffyUnderware.Curvy.Generator.Modules.CreateMesh"/> module
        /// </summary>
        /// <param name="associatedPrefabWasModified">Is true if an associated prefab was modified to deleted the output resources from it too</param>
        /// <remarks>Due to how the prefab system works, this method has to delete output from associated prefab assets too</remarks>
        /// <returns>True if there were deleted resources</returns>
        public bool DeleteAllOutputManagedResources(out bool associatedPrefabWasModified)
        {
#if UNITY_EDITOR
            if (DTUtility.DoesPrefabStatusAllowDeletion(gameObject, out _) == false)
                associatedPrefabWasModified = DeleteAllOutputManagedResourcesFromAssociatedPrefab();
            else
                associatedPrefabWasModified = false;
#else
            associatedPrefabWasModified = false;
#endif

            bool result = false;
            foreach (CGModule module in Modules)
                result |= module.DeleteAllOutputManagedResources();
            return result;
        }

        #endregion

        #region ### Protected Members ###

        protected CurvyCGEventArgs OnRefreshEvent(CurvyCGEventArgs e)
        {
            if (OnRefresh != null)
                OnRefresh.Invoke(e);
            return e;
        }

        #endregion

        #region ### Privates and Internals ###
        /*! \cond PRIVATE */

#if UNITY_EDITOR
        static CurvyGenerator()
        {
            EditorSceneManager.sceneSaving += OnSceneSaving;
        }

        private static void OnSceneSaving(Scene scene, string path)
        {
            if (CurvyGlobalManager.SaveGeneratorOutputs)
                return;

            //clear all output GOs to avoid saving them.
            foreach (CurvyGenerator generator in FindObjectsOfType<CurvyGenerator>())
                //only if the generator is supposed to refresh automatically, otherwise the users might not expect their generator to update
                if (generator.isActiveAndEnabled && generator.AutoRefresh)
                    foreach (CGModule module in generator.Modules)
                        if (module.DeleteAllOutputManagedResources())
                            module.Dirty = true;//to force update once saving is done
        }
#endif

        /// <summary>
        /// Ensures a module name is unique
        /// </summary>
        /// <param name="name">desired name</param>
        /// <returns>unique name</returns>
        public string getUniqueModuleNameINTERNAL(string name)
        {
            string newName = name;
            bool isUnique;
            int c = 1;
            do
            {
                isUnique = true;
                foreach (CGModule mod in Modules)
                {
                    if (mod.ModuleName.Equals(newName, System.StringComparison.CurrentCultureIgnoreCase))
                    {
                        newName = name + (c++).ToString(System.Globalization.CultureInfo.InvariantCulture);
                        isUnique = false;
                        break;
                    }
                }

            } while (!isUnique);
            return newName;
        }


        /// <summary>
        /// INTERNAL! Don't call this by yourself! 
        /// </summary>
        internal void sortModulesINTERNAL()
        {
            mNeedSort = true;
        }

        private bool doSortModules()
        {
            //DESIGN OPTIM: CGModule has members that are needed only in this method, and are confusing outside of this contexte, so inline everyting here and get rid of these members
            List<CGModule> unsorted = new List<CGModule>(Modules);

            List<CGModule> noAncestor = new List<CGModule>();
            List<CGModule> needNoSort = new List<CGModule>();


            // initialize
            for (int m = unsorted.Count - 1; m >= 0; m--)
            {
                unsorted[m].initializeSort();
                if (unsorted[m] is INoProcessing)
                {
                    needNoSort.Add(unsorted[m]);
                    unsorted.RemoveAt(m);
                }
                else if (unsorted[m].SortAncestors == 0)
                {
                    noAncestor.Add(unsorted[m]);
                    unsorted.RemoveAt(m);
                }
            }

            noAncestor.Sort((a, b) => a.UniqueID.CompareTo(b.UniqueID));

            Modules.Clear();

            // Sort
            int index = 0;
            while (noAncestor.Count > 0)
            {
                // get a module without ancestors
                CGModule mod = noAncestor[0];
                noAncestor.RemoveAt(0);
                // decrement child ancestors and fetch childs without ancestors
                List<CGModule> newModsWithoutAncestors = mod.decrementChilds();
                // Add them to noAncestor list
                noAncestor.AddRange(newModsWithoutAncestors);
                // and remove from unsorted
                for (int i = 0; i < newModsWithoutAncestors.Count; i++)
                    unsorted.Remove(newModsWithoutAncestors[i]);
                // add current module to sorted
                Modules.Add(mod);
                mod.transform.SetSiblingIndex(index++);
            }

            // These modules got errors!
            for (int circ = 0; circ < unsorted.Count; circ++)
                unsorted[circ].CircularReferenceError = true;

            //Debug.Log("====: NeedNoSort=" + needNoSort.Count + ", Unsorted=" + unsorted.Count);
            //foreach (var m in Modules)
            //    Debug.Log("Sort: " + m.ModuleName);

            Modules.AddRange(unsorted);
            Modules.AddRange(needNoSort);



            mNeedSort = false;
            return (unsorted.Count > 0);
        }

        /// <summary>
        /// Sets the position of an endpoint module's recursive inputs in a way that makes the graph easy to read
        /// </summary>
        /// <param name="endPoint">The module which recursive inputs are to be reordred</param>
        /// <param name="reordredModuleIds">Set of modules already reordred</param>
        /// <param name="modulesRecursiveInputs"> A dictionary that gives for each module the set of all the modules that are connected to its inputs, whether directly or indirectly</param>
        static private void ReorderEndpointRecursiveInputs(CGModule endPoint, HashSet<int> reordredModuleIds, Dictionary<CGModule, HashSet<CGModule>> modulesRecursiveInputs)
        {
            float nextInputEndingX = endPoint.Properties.Dimensions.xMin - ModulesReorderingDeltaX;
            float nextInputStartingY = endPoint.Properties.Dimensions.yMin;

            List<CGModule> inputModules = endPoint.Input.SelectMany(i => i.GetLinkedModules()).ToList();
            foreach (CGModule inputModule in inputModules)
            {
                float inputModuleXPosition = nextInputEndingX - inputModule.Properties.Dimensions.width;
                //If module is processed for the first time, process it normally ...
                if (reordredModuleIds.Contains(inputModule.UniqueID) == false)
                {
                    inputModule.Properties.Dimensions.position = new Vector2(inputModuleXPosition, nextInputStartingY);
                    reordredModuleIds.Add(inputModule.UniqueID);
                    ReorderEndpointRecursiveInputs(inputModule, reordredModuleIds, modulesRecursiveInputs);
                }
                //... otherwise allow it to be repositioned only when pushed to the left
                else if (inputModuleXPosition < inputModule.Properties.Dimensions.xMin)
                {
                    inputModule.Properties.Dimensions.position = new Vector2(inputModuleXPosition, inputModule.Properties.Dimensions.yMin);
                    ReorderEndpointRecursiveInputs(inputModule, reordredModuleIds, modulesRecursiveInputs);
                }
                nextInputStartingY = Math.Max(nextInputStartingY, modulesRecursiveInputs[inputModule].Max(m => m.Properties.Dimensions.yMax) + ModulesReorderingDeltaY);
            }
        }

        /// <summary>
        /// Adds to the modules recursive inputs dictionary the entries corresponding to the given module 
        /// </summary>
        /// <returns>The recursive inputs of the given module</returns>
        static private HashSet<CGModule> UpdateModulesRecursiveInputs(Dictionary<CGModule, HashSet<CGModule>> modulesRecursiveInputs, CGModule moduleToAdd)
        {
            if (modulesRecursiveInputs.ContainsKey(moduleToAdd))
                return modulesRecursiveInputs[moduleToAdd];

            List<CGModule> inputModules = moduleToAdd.Input.SelectMany(i => i.GetLinkedModules()).ToList();
            HashSet<CGModule> result = new HashSet<CGModule>
            {
                moduleToAdd
            };
            result.UnionWith(inputModules.SelectMany(i => UpdateModulesRecursiveInputs(modulesRecursiveInputs, i)));
            modulesRecursiveInputs[moduleToAdd] = result;
            return result;
        }

        /// <summary>
        ///  Delete, from the associated prefab if any, all the managed resources acting as an output. One example of such resources is the generated meshes by the <see cref="FluffyUnderware.Curvy.Generator.Modules.CreateMesh"/> module
        /// <remarks>Prefabs instances are not allowed to do some operations, such as deleting a game object. Such operations are done by the Curvy Generator. So run this method before doing any of those operations</remarks>
        /// </summary>
        /// <returns>Whether an associated prefab was modified</returns>
        public bool DeleteAllOutputManagedResourcesFromAssociatedPrefab()
        {
#if UNITY_EDITOR
            string prefabPath = PrefabUtility.GetPrefabAssetPathOfNearestInstanceRoot(this);
            if (String.IsNullOrEmpty(prefabPath))
                return false;

            GameObject prefabContentsRoot = PrefabUtility.LoadPrefabContents(prefabPath);
            CurvyGenerator[] prefabGenerators = prefabContentsRoot.GetComponentsInChildren<CurvyGenerator>();

            bool modified = false;
            foreach (CurvyGenerator prefabGenerator in prefabGenerators)
                foreach (CGModule module in prefabGenerator.Modules)
                    modified |= module.DeleteAllOutputManagedResources();

            if (modified)
            {
                var savedPrefab = PrefabUtility.SaveAsPrefabAsset(prefabContentsRoot, prefabPath);
                if (savedPrefab == null)
                {
                    DTLog.LogError($"[Curvy] The prefab asset '{prefabPath}' containing the generator '{name}' needs to be modified to delete generator output objects. Attempt to modify it failed. See other console messages to know what caused this failure.", this);
                    modified = false;
                }
                else
                {
                    object message = $"[Curvy] The prefab asset '{prefabPath}' containing the generator '{name}' was modified to delete generator output objects.";

                    PrefabStage currentPrefabStage = PrefabStageUtility.GetCurrentPrefabStage();

#if UNITY_2020_1_OR_NEWER
                    if (currentPrefabStage != null && currentPrefabStage.assetPath == prefabPath)
#else
                    if (currentPrefabStage != null && currentPrefabStage.prefabAssetPath == prefabPath)
#endif
                    {
                        message += " This might happen when you save modifications to the prefab asset. You might want to disable Auto Save in Prefab Mode to make this happen less frequently.";
                        DTLog.LogWarning(message, this);
                    }
                    else
                    {
                        message += " This might lead to the refreshing of the associated generator in the prefab instance.";
                        DTLog.Log(message, this);
                    }

                }
            }
            PrefabUtility.UnloadPrefabContents(prefabContentsRoot);
            return modified;
#else
            return false;
#endif
        }

        /// <summary>
        /// Save to scene all the managed resources acting as an output. One example of such resources is the generated meshes by the <see cref="FluffyUnderware.Curvy.Generator.Modules.CreateMesh"/> module
        /// </summary>
        public void SaveAllOutputManagedResources()
        {
            GameObject result = new GameObject($"{name} Exported Resources");
            result.transform.position = this.transform.position;
            result.transform.rotation = this.transform.rotation;
            result.transform.localScale = this.transform.localScale;
            Modules.Where(m => m is ResourceExportingModule).ForEach(m => ((ResourceExportingModule)m).SaveToScene(result.transform));

        }


        /*! \endcond */
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CurvyGenerator.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CurvyPropertyAttributes.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ff18089ea6039164dbd5086635c53ac8
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using System;
using System.Reflection;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy
{

    #region ### CG related ###

    /// <summary>
    /// CG Resource Attribute
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1813:AvoidUnsealedAttributes")]
    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
    public class CGResourceManagerAttribute : DTPropertyAttribute
    {
        public readonly string ResourceName;
        public bool ReadOnly;

        public CGResourceManagerAttribute(string resourceName)
        {
            ResourceName = resourceName;
        }
    }

    /// <summary>
    /// CG Resource Collection Attribute
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
    public sealed class CGResourceCollectionManagerAttribute : CGResourceManagerAttribute
    {
        public bool ShowCount;

        public CGResourceCollectionManagerAttribute(string resourceName)
            : base(resourceName)
        {
            ReadOnly = true;
        }
    }

    /// <summary>
    /// CG Data Reference Selector Attribute
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
    public sealed class CGDataReferenceSelectorAttribute : DTPropertyAttribute
    {
        public readonly System.Type DataType;

        public CGDataReferenceSelectorAttribute(System.Type dataType)
        {
            DataType = dataType;
        }
    }

    #endregion



}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CurvyPropertyAttributes.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/MetaCGOptions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d8e6515f233d3da4fbaeff6c986c19df
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy
{

    /// <summary>
    /// Curvy Generator options Metadata class
    /// </summary>
    [HelpURL(CurvySpline.DOCLINK + "metacgoptions")]
    public class MetaCGOptions : CurvyMetadataBase
    {

        #region ### Serialized Fields ###

        [Positive]
        [SerializeField]
        private int m_MaterialID = DefaultMaterialId;


        [SerializeField]
        [FieldCondition(nameof(ShowUvEdgeOrHardEdge), true)]
        private bool m_HardEdge;
        [Positive(Tooltip = "Max step distance when using optimization")]
        [SerializeField]
        private float m_MaxStepDistance;
        [Section("Extended UV", HelpURL = CurvySpline.DOCLINK + "metacgoptions_extendeduv")]
        [FieldCondition(nameof(ShowUvEdgeOrHardEdge), true)]
        [SerializeField]
        private bool m_UVEdge;

        [Positive]
        [FieldCondition(nameof(showExplicitU), true)]
        [SerializeField]
        private bool m_ExplicitU;
        [FieldCondition(nameof(showFirstU), true)]
        [FieldAction("CBSetFirstU")]
        [Positive]
        [SerializeField]
        private float m_FirstU;
        [FieldCondition(nameof(showSecondU), true)]
        [Positive]
        [SerializeField]
        private float m_SecondU;

        /// <summary>
        /// Whether  or not the conversion of the UVEdge value to the new "system" (starting from Curvy 8) was done. See the commentary on the private method EnsureUVEdgeUpdate to know more.
        /// </summary>
        [SerializeField, HideInInspector] private bool uVEdgeUpdated = false;

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Gets or sets Material ID
        /// </summary>
        public int MaterialID
        {
            get
            {
                return m_MaterialID;
            }
            set
            {
                int v = Mathf.Max(0, value);
                if (m_MaterialID != v)
                {
                    m_MaterialID = v;
                    NotifyModification();
                }
            }
        }

        /// <summary>
        /// Gets or sets whether to create a hard edge or not
        /// This is the raw serialized value. In opposition, <see cref="CorrectedHardEdge"/> takes other considerations into account
        /// </summary>
        public bool HardEdge
        {
            get { return m_HardEdge; }
            set
            {
                if (m_HardEdge != value)
                {
                    m_HardEdge = value;
                    NotifyModification();
                }
            }
        }

        /// <summary>
        /// <see cref="HardEdge"/> is ignored for first and last CPs of an open spline. This method takes that into consideration. In opposition, <see cref="HardEdge"/> is the raw serialized value.
        /// </summary>
        /// <value></value>
        public bool CorrectedHardEdge
        {
            get
            {
                //this one is to handle the case of a cp (of an open spline) that was in the middle of the spline, and has HardEdge, then we delete all its following cps, so it becomes the last cp. This means it has HardEdge to true, but the value is ignored
                return CanHaveUvEdgeOrHadrdEdge() && HardEdge;
            }
        }

        /// <summary>
        /// Gets or sets whether to create an UV edge or not
        /// This is the raw serialized value. In opposition, <see cref="CorrectedUVEdge"/> takes other considerations into account
        /// </summary>
        public bool UVEdge
        {
            get { return m_UVEdge; }
            set
            {
                if (m_UVEdge != value)
                {
                    m_UVEdge = value;
                    NotifyModification();
                }
            }
        }

        /// <summary>
        /// <see cref="UVEdge"/> is ignored for first and last CPs of an open spline. This method takes that into consideration. In opposition, <see cref="UVEdge"/> is the raw serialized value.
        /// </summary>
        /// <value></value>
        public bool CorrectedUVEdge
        {
            get
            {
                //this one is to handle the case of a cp (of an open spline) that was in the middle of the spline, and has UVEdge, then we delete all its following cps, so it becomes the last cp. This means it has UVEdge to true, but the value is ignored
                return CanHaveUvEdgeOrHadrdEdge() && UVEdge;
            }
        }

        /// <summary>
        /// Gets or sets whether to define explicit U values
        /// </summary>
        public bool ExplicitU
        {
            get { return m_ExplicitU; }
            set
            {
                if (m_ExplicitU != value)
                {
                    m_ExplicitU = value;
                    NotifyModification();
                }
            }
        }

        /// <summary>
        /// Gets or sets UV0
        /// </summary>
        public float FirstU
        {
            get { return m_FirstU; }
            set
            {
                if (m_FirstU != value)
                {
                    m_FirstU = value;
                    NotifyModification();
                }
            }
        }

        /// <summary>
        /// Gets or sets UV0
        /// </summary>
        public float SecondU
        {
            get { return m_SecondU; }
            set
            {
                if (m_SecondU != value)
                {
                    m_SecondU = value;
                    NotifyModification();
                }
            }
        }

        /// <summary>
        /// Gets or sets maximum vertex distance when using optimization (0=infinite)
        /// </summary>
        public float MaxStepDistance
        {
            get
            {
                return m_MaxStepDistance;
            }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_MaxStepDistance != v)
                {
                    m_MaxStepDistance = v;
                    NotifyModification();
                }
            }
        }

        public bool HasDifferentMaterial
        {
            get
            {
                MetaCGOptions previousMetaCGOptions = GetPreviousData<MetaCGOptions>(false);
                int previousMaterialId = previousMetaCGOptions == null ? DefaultMaterialId : previousMetaCGOptions.MaterialID;
                return previousMaterialId != MaterialID;
            }
        }

        #endregion

        #region ### Private Fields & Properties ###

        private const int DefaultMaterialId = 0;

        private bool ShowUvEdgeOrHardEdge
        {
            get
            {
                return ControlPoint && CanHaveUvEdgeOrHadrdEdge();
            }
        }

        private bool showExplicitU
        {
            get
            {
                return (ControlPoint && !showSecondU);
            }
        }

        private bool showFirstU
        {
            get
            {
                return ExplicitU || CorrectedUVEdge;
            }
        }

        private bool showSecondU
        {
            get
            {
                return CorrectedUVEdge;
            }
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */


#if UNITY_EDITOR
        private void OnValidate()
        {
            NotifyModification();
        }

        protected override void Awake()
        {
            base.Awake();
            EnsureUVEdgeUpdate();
        }

#endif

        public void Reset()
        {
            MaterialID = DefaultMaterialId;
            HardEdge = false;
            MaxStepDistance = 0;
            UVEdge = false;
            ExplicitU = false;
            FirstU = 0;
            SecondU = 0;
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public float GetDefinedFirstU(float defaultValue)
        {
            return (CorrectedUVEdge || ExplicitU) ? FirstU : defaultValue;
        }

        public float GetDefinedSecondU(float defaultValue)
        {
            return (CorrectedUVEdge) ? SecondU : GetDefinedFirstU(defaultValue);
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATES */

        /// <summary>
        ///Until Curvy 7 included, a change in material id (compared to the one of the previous CP) was automatically considered to be an UVEdge, so in the case users wanted to just change a material id, they had to figure out the right value of first and second U, which is annoying at best. True, they had the option to deactivate Extended UV in the Shape Extrusion module, but that's not an option if you want to use extended UV on CPs other than the one with a material change.
        ///Starting from Curvy 8, the Extended UV option in the Shape Extrusion module is not visible anymore (which solves another problem: people confused about why the UV options they enter are not taken into consideration). The module will act as if Extended UV is always true. With Extended UV not available, a solution had to be implemented to allow for material id change that does not modify the UV. The solution found is to dissociate a material id change from UVEdge. Now you can have both true, false, or having different values.
        ///To keep things backward compatible, I am setting UVEdge to true when I detect a material id change while both U values are different from their default value of 0. This is done when an instance is processed for the first time under Curvy 8. This is not perfect, since you can still have someone who purposefully set both U values to 0.
        /// </summary>
        private void EnsureUVEdgeUpdate()
        {
            if (uVEdgeUpdated == false)
            {
                m_UVEdge = m_UVEdge || (HasDifferentMaterial && false == (FirstU == 0 && SecondU == 0));
                uVEdgeUpdated = true;
            }
        }

        private bool CanHaveUvEdgeOrHadrdEdge()
        {
            return Spline.Closed || (Spline.FirstVisibleControlPoint != ControlPoint && Spline.LastVisibleControlPoint != ControlPoint);
        }

        /*! \endcond */
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/MetaCGOptions.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/ConnectedControlPointsSelector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fa3e4d284c1d61b45b2357dc26add96d
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.DevTools;
using UnityEngine;

namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// A class used by <see cref="SplineController"/> to define custom selection logic to select between the possible connected splines when the controller reaches a <see cref="CurvyConnection"/>
    /// </summary>
    abstract public class ConnectedControlPointsSelector : DTVersionedMonoBehaviour
    {
        /// <summary>
        /// Select, from the current connection, a Control Point to continue moving through.
        /// </summary>
        /// <param name="caller">The spline controller that is calling this selector</param>
        /// <param name="connection">The connection the caller reached and from which it needs to select a Control Point to continue the movement on</param>
        /// <param name="currentControlPoint">the Control Point, part of the connection, the controller is at.</param>
        /// <returns>The control point that the <param name="caller"></param> should continue its movement on</returns>
        abstract public CurvySplineSegment SelectConnectedControlPoint(SplineController caller, CurvyConnection connection, CurvySplineSegment currentControlPoint);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/ConnectedControlPointsSelector.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/ControllersEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a46071b8cead970438b2ce2c36461aef
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using FluffyUnderware.DevTools;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Events;

namespace FluffyUnderware.Curvy.Controllers
{
    #region ### Controller Events ###

    [System.Serializable]
    public class ControllerEvent : UnityEventEx<CurvyController> { }

    /// <summary>
    /// EventArgs used by spline controller movements
    /// </summary>
    [System.Serializable]
    public class CurvySplineMoveEvent : UnityEventEx<CurvySplineMoveEventArgs> { }

    /// <summary>
    /// EventArgs used by spline controller movements
    /// </summary>
    public class CurvySplineMoveEventArgs : System.ComponentModel.CancelEventArgs
    {
        /// <summary>
        /// The Spline Controller raising the event
        /// </summary>
        public SplineController Sender { get; private set; }
        /// <summary>
        /// The related spline
        /// </summary>
        public CurvySpline Spline { get; private set; }
        /// <summary>
        /// The control point which reaching triggered this event
        /// </summary>
        public CurvySplineSegment ControlPoint { get; private set; }
        /// <summary>
        /// Are <see cref="Delta"/> and <see cref="Position"/> in world units (in opposition to relative units)?
        /// </summary>
        public bool WorldUnits { get; private set; }

        /// <summary>
        /// The movement direction the controller had when sending the event
        /// </summary>
        public MovementDirection MovementDirection { get; private set; }
        /// <summary>
        /// The left distance yet to move.
        /// </summary>
        public float Delta { get; private set; }
        /// <summary>
        /// Controller Position on Spline
        /// </summary>
        public float Position { get; private set; }


        public CurvySplineMoveEventArgs(SplineController sender, CurvySpline spline, CurvySplineSegment controlPoint, float position, bool usingWorldUnits, float delta, MovementDirection direction)
        {
            Set_INTERNAL(sender, spline, controlPoint, position, delta, direction, usingWorldUnits);
        }

        /// <summary>
        /// Set all the properties values. Is not meant to be used by code outside of Curvy's code.
        /// </summary>
        internal void Set_INTERNAL(SplineController sender, CurvySpline spline, CurvySplineSegment controlPoint, float position, float delta, MovementDirection direction, bool usingWorldUnits)
        {

            Sender = sender;
            Spline = spline;
            ControlPoint = controlPoint;

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(Sender != null);
            Assert.IsTrue(controlPoint == null || controlPoint.Spline == spline);
#endif
            MovementDirection = direction;
            Delta = delta;
            Position = position;
            WorldUnits = usingWorldUnits;
            Cancel = false;
        }
    }


    //TODO Use CurvyControllerSwitchEvent
    //public class CurvyControllerSwitchEvent : UnityEventEx<CurvyControllerSwitchEventArgs> { }

    //public class CurvyControllerSwitchEventArgs : EventArgs
    //{
    //    /// <summary>
    //    /// The controller raising the event
    //    /// </summary>
    //    public CurvyController Controller { get; private set; }
    //    public CurvySpline SourceSpline { get; private set; }
    //    public CurvySpline DestinationSpline { get; private set; }
    //    public float TFOnSource { get; private set; }
    //    public float TFOnDestination { get; private set; }
    //    public CurvyControllerDirection DirectionOnSource { get; private set; }
    //    public CurvyControllerDirection DirectionOnDestination { get; private set; }
    //    public float SwitchTimeStart { get; private set; }
    //    public float SwitchDuration { get; private set; }
    //    public float SwitchProgression { get; private set; }


    //    public CurvyControllerSwitchEventArgs()
    //    {
    //    }

    //    public void Set(CurvyController controller, float switchTimeStart, float switchDuration, float switchProgression, CurvySpline sourceSpline, CurvySpline destinationSpline, float tfOnSource, float tfOnDestination, CurvyControllerDirection directionOnSource, CurvyControllerDirection directionOnDestination)
    //    {
    //        SwitchDuration = switchDuration;
    //        SwitchProgression = switchProgression;
    //        Controller = controller;
    //        SourceSpline = sourceSpline;
    //        DestinationSpline = destinationSpline;
    //        TFOnSource = tfOnSource;
    //        TFOnDestination = tfOnDestination;
    //        SwitchTimeStart = switchTimeStart;
    //        DirectionOnSource = directionOnSource;
    //        DirectionOnDestination = directionOnDestination;
    //    }
    //}

    #endregion
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/ControllersEvents.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/CurvyController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bb9a1c67a6f383a478b8a20a17b05cc4
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using System.Reflection;
using JetBrains.Annotations;
#if UNITY_EDITOR
using UnityEditor;
#endif

using UnityEngine.Assertions;
using UnityEngine.Events;
using UnityEngine.Serialization;

namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// Controller base class
    /// </summary>
    [ExecuteAlways]
    public abstract class CurvyController : DTVersionedMonoBehaviour, ISerializationCallbackReceiver
    {
        #region ### Enums ###
        /// <summary>
        /// Movement method options
        /// </summary>
        public enum MoveModeEnum
        {
            /// <summary>
            /// Move by Percentage or TF (SplineController only)
            /// </summary>
            Relative = 0,
            /// <summary>
            /// Move by calculated distance
            /// </summary>
            AbsolutePrecise = 1,
        }

        /// <summary>
        /// The play state of the controller
        /// </summary>
        public enum CurvyControllerState
        {
            Stopped,
            Playing,
            Paused
        }

        #endregion

        #region ### Events ###

        /// <summary>
        /// Invoked each time the controller finishes initialization
        /// </summary>
        public ControllerEvent OnInitialized
        {
            get { return onInitialized; }
        }

        #endregion

        #region ### Serialized Fields ###
        //TODO tooltips
        [Section("General", Sort = 0, HelpURL = CurvySpline.DOCLINK + "curvycontroller_general")]
        [Label(Tooltip = "Determines when to update")]
        public CurvyUpdateMethod UpdateIn = CurvyUpdateMethod.Update; // when to update?

        [SerializeField]
        [FieldCondition(nameof(IsNeededRigidbodyMissing), true, false, ActionAttribute.ActionEnum.ShowError,
            "Missing Rigidbody component. Its 'Is Kinematic' setting should be set to true")]
        [FieldCondition(nameof(IsNeeded2DRigidbodyMissing), true, false, ActionAttribute.ActionEnum.ShowError,
            "Missing Rigidbody 2D component. Its 'Body Type' setting should be set to 'Kinematic'")]
        [FieldCondition(nameof(IsNeededRigidbodyNotKinematic), true, false, ActionAttribute.ActionEnum.ShowError,
            "Rigidbody's 'Is Kinematic' setting should be set to true")]
        [FieldCondition(nameof(IsNeeded2DRigidbodyNotKinematic), true, false, ActionAttribute.ActionEnum.ShowError,
            "Rigidbody 2Ds 'Body Type' setting should be set to 'Kinematic'")]
        [FieldCondition(nameof(targetComponent), TargetComponent.Transform, false, ActionAttribute.ActionEnum.ShowInfo,
            "The transform's position and rotation are updated at the selected 'Update In' method.")]
        [FieldCondition(nameof(targetComponent), TargetComponent.Transform, true, ActionAttribute.ActionEnum.ShowInfo,
            "The rigidbody's position and rotation are updated at the physics simulation, and not at the selected 'Update In' method. Please consider this if getting the position or rotation via script.")]
        [Tooltip("The component controlled by the controller")]
        private TargetComponent targetComponent = TargetComponent.Transform;

        [Section("Position", Sort = 100, HelpURL = CurvySpline.DOCLINK + "curvycontroller_position")]
        [SerializeField]
        private CurvyPositionMode m_PositionMode = CurvyPositionMode.WorldUnits;

        /*! \cond PRIVATE */

        [RangeEx(0, nameof(maxPosition))]
        [SerializeField]
        [FormerlySerializedAs("m_InitialPosition")]
        [FieldCondition(nameof(ShouldDisablePositionSlider), true, false, ActionAttribute.ActionEnum.Disable)]
        protected float m_Position;

        /*! \endcond */

        [Section("Motion", Sort = 200, HelpURL = CurvySpline.DOCLINK + "curvycontroller_move")]
        [SerializeField]
        private MoveModeEnum m_MoveMode = MoveModeEnum.AbsolutePrecise;

        [Positive]
        [SerializeField]
        private float m_Speed = 0;

        [SerializeField] private MovementDirection m_Direction = MovementDirection.Forward;

        [SerializeField] private CurvyClamping m_Clamping = CurvyClamping.Loop;

        [Label("Constraints")]
        [Tooltip("Defines what motions are to be frozen")]
        [FieldCondition(nameof(AreConstraintsConflicting), true, false, ActionAttribute.ActionEnum.ShowWarning,
            "The controller targets a Rididbody that has constraints on it. This can creates conflicts with the controller's constraints")]
        [SerializeField] private MotionConstraints motionConstraints = MotionConstraints.None;

        [SerializeField, Tooltip("Start playing automatically when entering play mode")]
        private bool m_PlayAutomatically = true;

        [Section("Orientation", Sort = 300, HelpURL = CurvySpline.DOCLINK + "curvycontroller_orientation")]

        [Label("Source", "Source Vector")]
        [FieldCondition(nameof(ShowOrientationSection), false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [SerializeField]
        private OrientationModeEnum m_OrientationMode = OrientationModeEnum.Orientation;

        [Label("Lock Rotation", "When set, the controller will enforce the rotation to not change")]
#if UNITY_EDITOR //Conditional to avoid WebGL build failure when using Unity 5.5.3
        [FieldCondition(nameof(m_OrientationMode), OrientationModeEnum.None, true, ConditionalAttribute.OperatorEnum.OR, "ShowOrientationSection", false, false, Action = ActionAttribute.ActionEnum.Hide)]
#endif
        [SerializeField]
        private bool m_LockRotation = true;

        [Label("Target", "Target Vector3")]
        [FieldCondition(nameof(m_OrientationMode), OrientationModeEnum.None, false, ConditionalAttribute.OperatorEnum.OR, "ShowOrientationSection", false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [SerializeField]
        private OrientationAxisEnum m_OrientationAxis = OrientationAxisEnum.Up;

        [Tooltip("Should the orientation ignore the movement direction?")]
        [FieldCondition(nameof(m_OrientationMode), OrientationModeEnum.None, false, ConditionalAttribute.OperatorEnum.OR, "ShowOrientationSection", false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [SerializeField]
        private bool m_IgnoreDirection;

        [DevTools.Min(0, "Direction Damping Time", "If non zero, the direction vector will not be updated instantly, but using a damping effect that will last the specified amount of time.")]
        [FieldCondition(nameof(ShowOrientationSection), false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [SerializeField]
        private float m_DampingDirection;

        [DevTools.Min(0, "Up Damping Time", "If non zero, the up vector will not be updated instantly, but using a damping effect that will last the specified amount of time.")]
        [FieldCondition(nameof(ShowOrientationSection), false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [SerializeField]
        private float m_DampingUp;

        [Section("Offset", Sort = 400, HelpURL = CurvySpline.DOCLINK + "curvycontroller_orientation")]
        [FieldCondition(nameof(ShowOffsetSection), false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [RangeEx(-180f, 180f)]
        [SerializeField]
        private float m_OffsetAngle;

        [FieldCondition(nameof(ShowOffsetSection), false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [SerializeField]
        private float m_OffsetRadius;

        [FieldCondition(nameof(ShowOffsetSection), false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [Label("Compensate Offset")]
        [SerializeField]
        private bool m_OffsetCompensation = true;

        [Section("Events", Sort = 500)]
        [SerializeField]
#pragma warning disable 649
        protected ControllerEvent onInitialized = new ControllerEvent();
#pragma warning restore 649

#if UNITY_EDITOR
        [Section("Advanced Settings", Sort = 2000, HelpURL = CurvySpline.DOCLINK + "curvycontroller_general", Expanded = false)]
        [Label(Tooltip = "Force this script to update in Edit mode as often as in Play mode. Most users don't need that.")]
        [SerializeField]
        private bool m_ForceFrequentUpdates;
#endif
        #endregion

        #region ### Public Properties ###


        /// <summary>
        /// The component controlled by the controller
        /// </summary>
        public TargetComponent TargetComponent
        {
            get { return targetComponent; }
            set
            {
                if (targetComponent != value)
                    targetComponent = value;
            }
        }

        /// <summary>
        /// Gets or sets the position mode to use
        /// </summary>
        public CurvyPositionMode PositionMode
        {
            get { return m_PositionMode; }
            set
            {
                m_PositionMode = value;
            }
        }

        /// <summary>
        /// Gets or sets the movement mode to use
        /// </summary>
        public MoveModeEnum MoveMode
        {
            get { return m_MoveMode; }
            set
            {
                if (m_MoveMode != value)
                    m_MoveMode = value;
            }
        }

        /// <summary>
        /// Gets or sets whether to start playing automatically
        /// </summary>
        public bool PlayAutomatically
        {
            get { return m_PlayAutomatically; }
            set
            {
                if (m_PlayAutomatically != value)
                    m_PlayAutomatically = value;
            }
        }

        /// <summary>
        /// Gets or sets what to do when the source's end is reached
        /// </summary>
        public CurvyClamping Clamping
        {
            get { return m_Clamping; }
            set
            {
                if (m_Clamping != value)
                    m_Clamping = value;
            }
        }

        /// <summary>
        /// Defines what motions are to be frozen
        /// </summary>
        public MotionConstraints MotionConstraints
        {
            get { return motionConstraints; }
            set
            {
                if (motionConstraints != value)
                    motionConstraints = value;
            }
        }

        /// <summary>
        /// Gets or sets how to apply rotation
        /// </summary>
        public OrientationModeEnum OrientationMode
        {
            get { return m_OrientationMode; }
            set
            {
                if (m_OrientationMode != value)
                    m_OrientationMode = value;
            }
        }

        /// <summary>
        /// Used only when OrientationMode is equal to None
        /// When true, the controller will enforce the rotation to not change
        /// </summary>
        public bool LockRotation
        {
            get { return m_LockRotation; }
            set
            {
                if (m_LockRotation != value)
                    m_LockRotation = value;

                if (m_LockRotation)
                {
                    GetPositionAndRotation(out _, out Quaternion rotation);
                    LockedRotation = rotation;
                }
            }
        }

        /// <summary>
        /// Gets or sets the axis to apply the rotation to
        /// </summary>
        public OrientationAxisEnum OrientationAxis
        {
            get { return m_OrientationAxis; }
            set
            {
                if (m_OrientationAxis != value)
                    m_OrientationAxis = value;

            }
        }

        /// <summary>
        /// If non zero, the direction vector will not be updated instantly, but using a damping effect that will last the specified amount of time.
        /// </summary>
        public float DirectionDampingTime
        {
            get { return m_DampingDirection; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_DampingDirection != v)
                    m_DampingDirection = v;
            }
        }

        /// <summary>
        /// If non zero, the up vector will not be updated instantly, but using a damping effect that will last the specified amount of time.
        /// </summary>
        public float UpDampingTime
        {
            get { return m_DampingUp; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_DampingUp != v)
                    m_DampingUp = v;
            }
        }



        /// <summary>
        /// Should the controller's orientation ignore the movement direction?
        /// </summary>
        public bool IgnoreDirection
        {
            get { return m_IgnoreDirection; }
            set
            {
                if (m_IgnoreDirection != value)
                    m_IgnoreDirection = value;
            }
        }

        /// <summary>
        /// Gets or sets the angle to offset (-180 to 180 off Orientation)
        /// </summary>
        public float OffsetAngle
        {
            get { return m_OffsetAngle; }
            set
            {
                if (m_OffsetAngle != value)
                    m_OffsetAngle = value;
            }
        }
        /// <summary>
        /// Gets or sets the offset radius
        /// </summary>
        public float OffsetRadius
        {
            get { return m_OffsetRadius; }
            set
            {
                if (m_OffsetRadius != value)
                    m_OffsetRadius = value;
            }
        }

        /// <summary>
        /// Gets or sets whether to compensate offset distances in curvy paths
        /// </summary>
        public bool OffsetCompensation
        {
            get { return m_OffsetCompensation; }
            set { m_OffsetCompensation = value; }
        }

        /// <summary>
        /// Gets or sets the speed either in world units or relative, depending on MoveMode
        /// </summary>
        public float Speed
        {
            get { return m_Speed; }
            set
            {
                if (value < 0)
                {
#if CURVY_SANITY_CHECKS

                    DTLog.LogWarning("[Curvy] Trying to assign a negative value of " + value.ToString() + " to Speed. Speed should always be positive. To set direction, use the Direction property", this);
#endif
                    value = -value;
                }
                m_Speed = value;
            }
        }

        /// <summary>
        /// Gets or sets the relative position on the source, respecting Clamping
        /// </summary>
        public float RelativePosition
        {
            get
            {
                float relativePosition;
                switch (PositionMode)
                {
                    case CurvyPositionMode.Relative:
                        relativePosition = GetClampedPosition(m_Position, CurvyPositionMode.Relative, Clamping, Length);
                        break;
                    case CurvyPositionMode.WorldUnits:
                        relativePosition = AbsoluteToRelative(GetClampedPosition(m_Position, CurvyPositionMode.WorldUnits, Clamping, Length));
                        break;
                    default:
                        throw new NotSupportedException();
                }

                return relativePosition;
            }
            set
            {
                float clampedRelativePosition = GetClampedPosition(value, CurvyPositionMode.Relative, Clamping, Length);
                switch (PositionMode)
                {
                    case CurvyPositionMode.Relative:
                        m_Position = clampedRelativePosition;
                        break;
                    case CurvyPositionMode.WorldUnits:
                        m_Position = RelativeToAbsolute(clampedRelativePosition);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
        }

        /// <summary>
        /// Gets or sets the absolute position on the source, respecting Clamping
        /// </summary>
        public float AbsolutePosition
        {
            get
            {
                float absolutePosition;
                switch (PositionMode)
                {
                    case CurvyPositionMode.Relative:
                        absolutePosition = RelativeToAbsolute(GetClampedPosition(m_Position, CurvyPositionMode.Relative, Clamping, Length));
                        break;
                    case CurvyPositionMode.WorldUnits:
                        absolutePosition = GetClampedPosition(m_Position, CurvyPositionMode.WorldUnits, Clamping, Length);
                        break;
                    default:
                        throw new NotSupportedException();
                }

                return absolutePosition;
            }
            set
            {
                float clampedAbsolutePosition = GetClampedPosition(value, CurvyPositionMode.WorldUnits, Clamping, Length);
                switch (PositionMode)
                {
                    case CurvyPositionMode.Relative:
                        m_Position = AbsoluteToRelative(clampedAbsolutePosition);
                        break;
                    case CurvyPositionMode.WorldUnits:
                        m_Position = clampedAbsolutePosition;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
        }

        /// <summary>
        /// Gets or sets the position on the source (relative or absolute, depending on MoveMode), respecting Clamping
        /// </summary>
        public float Position
        {
            get
            {
                float result;
                switch (PositionMode)
                {
                    case CurvyPositionMode.Relative:
                        result = RelativePosition;
                        break;
                    case CurvyPositionMode.WorldUnits:
                        result = AbsolutePosition;
                        break;
                    default:
                        throw new NotSupportedException();
                }
                return result;
            }
            set
            {
                switch (PositionMode)
                {
                    case CurvyPositionMode.Relative:
                        RelativePosition = value;
                        break;
                    case CurvyPositionMode.WorldUnits:
                        AbsolutePosition = value;
                        break;
                    default:
                        throw new NotSupportedException();
                }
            }
        }

        /// <summary>
        /// Gets or sets the movement direction
        /// </summary>
        public MovementDirection MovementDirection
        {
            get { return m_Direction; }
            set { m_Direction = value; }
        }


        /// <summary>
        /// The state (Playing, paused or stopped) of the controller
        /// </summary>
        public CurvyControllerState PlayState { get { return State; } }

        /// <summary>
        /// Returns true if the controller has all it dependencies ready.
        /// </summary>
        /// <remarks>A controller that is not initialized and has IsReady true, will be initialized at the next update call (automatically each frame or manually through <see cref="Refresh"/>.</remarks>
        abstract public bool IsReady { get; }

#if UNITY_EDITOR
        /// <summary>
        /// By default Unity calls scripts' update less frequently in Edit mode. ForceFrequentUpdates forces this script to update in Edit mode as often as in Play mode. Most users don't need that, but that was helpful for a user working with cameras controlled by Unity in Edit mode
        /// </summary>
        public bool ForceFrequentUpdates
        {
            get { return m_ForceFrequentUpdates; }
            set { m_ForceFrequentUpdates = value; }
        }
#endif

        #endregion

        #region ### Private & Protected Fields ###

        /// <summary>
        /// The position slider is disabled in the inspector when this property returns true
        /// </summary>
        protected virtual bool ShouldDisablePositionSlider => PositionMode == CurvyPositionMode.WorldUnits && IsReady == false;

        /// <summary>
        /// An error message used in various assertions
        /// </summary>
        protected const string ControllerNotReadyMessage = "The controller is not yet ready";

        /// <summary>
        /// The state (Playing, paused or stopped) of the controller
        /// <seealso cref="CurvyControllerState"/>
        /// </summary>
        protected CurvyControllerState State = CurvyControllerState.Stopped;

        /// <summary>
        /// The damping velocity used in the Direction damping
        /// <seealso cref="DirectionDampingTime"/>
        /// <seealso cref="Vector3.SmoothDamp(Vector3, Vector3, ref Vector3, float, float, float)"/>
        /// </summary>
        protected Vector3 DirectionDampingVelocity;//TODO should this value be reinitialized when DirectionDampingTime is set to non strictly positive value or any other moment?

        /// <summary>
        /// The damping velocity used in the Up damping
        /// <seealso cref="UpDampingTime"/>
        /// <seealso cref="Vector3.SmoothDamp(Vector3, Vector3, ref Vector3, float, float, float)"/>
        /// </summary>
        protected Vector3 UpDampingVelocity;//TODO should this value be reinitialized when UpDampingTime is set to non strictly positive value or any other moment?

        /// <summary>
        /// The position of the controller when started playing
        /// </summary>
        protected float PrePlayPosition;

        /// <summary>
        /// The <see cref="MovementDirection"/> of the controller when started playing
        /// </summary>
        protected MovementDirection PrePlayDirection;

        /// <summary>
        /// When <see cref="OrientationMode"/> is None, and <see cref="LockRotation"/> is true, this field is the value of the locked rotation, the one that will be assigned all the time to the controller
        /// </summary>
        protected Quaternion LockedRotation;


#if UNITY_EDITOR
        /// <summary>
        /// The last time the controller was updated while in Edit Mode
        /// </summary>
        protected float EditModeLastUpdate;
#endif

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */
        protected virtual void OnEnable()
        {
            if (isInitialized == false && IsReady)
            {
                Initialize();
                InitializedApplyDeltaTime(0);
            }

#if UNITY_EDITOR
            EditorApplication.update += editorUpdate;
#endif
        }

        protected virtual void Start()
        {
            if (isInitialized == false && IsReady)
            {
                Initialize();
                InitializedApplyDeltaTime(0);
            }

            if (PlayAutomatically && Application.isPlaying)
                Play();
        }

        protected virtual void OnDisable()
        {
#if UNITY_EDITOR
            EditorApplication.update -= editorUpdate;
#endif
            if (isInitialized)
                Deinitialize();
        }

        protected virtual void Update()
        {
            if (UpdateIn == CurvyUpdateMethod.Update)
                ApplyDeltaTime(TimeSinceLastUpdate);
        }

        protected virtual void LateUpdate()
        {
            if (UpdateIn == CurvyUpdateMethod.LateUpdate ||
                (Application.isPlaying == false && UpdateIn == CurvyUpdateMethod.FixedUpdate)) // In edit mode, fixed updates are not called, so we update the controller here instead
                ApplyDeltaTime(TimeSinceLastUpdate);
        }

        protected virtual void FixedUpdate()
        {
            if (UpdateIn == CurvyUpdateMethod.FixedUpdate)
                ApplyDeltaTime(TimeSinceLastUpdate);
        }

#if UNITY_EDITOR
        protected virtual void OnValidate()
        {
            Speed = m_Speed;
            LockRotation = m_LockRotation;
        }
#endif

        protected virtual void Reset()
        {
            UpdateIn = CurvyUpdateMethod.Update;
            TargetComponent = TargetComponent.Transform;
            PositionMode = CurvyPositionMode.WorldUnits;
            m_Position = 0;
            PlayAutomatically = true;
            MoveMode = MoveModeEnum.AbsolutePrecise;
            Speed = 0;
            LockRotation = true;
            MotionConstraints = MotionConstraints.None;
            Clamping = CurvyClamping.Loop;
            OrientationMode = OrientationModeEnum.Orientation;
            OrientationAxis = OrientationAxisEnum.Up;
            IgnoreDirection = false;
        }
        /*! \endcond */
        #endregion

        #region ### Virtual Properties & Methods  ###

        /// <summary>
        /// Gets the transform being controlled by this controller.
        /// </summary>
        /// <seealso cref="TargetComponent"/>
        public virtual Transform Transform
        {
            get
            {
                return transform;
            }
        }

        /// <summary>
        /// Gets the rigidbody being controlled by this controller.
        /// </summary>
        /// <seealso cref="TargetComponent"/>
        public virtual Rigidbody Rigidbody
        {
            [CanBeNull]
            get
            {
                return transform.GetComponent<Rigidbody>();
            }
        }

        /// <summary>
        /// Gets the 2d rigidbody being controlled by this controller.
        /// </summary>
        /// <seealso cref="TargetComponent"/>
        public virtual Rigidbody2D Rigidbody2D
        {
            [CanBeNull]
            get
            {
                return transform.GetComponent<Rigidbody2D>();
            }
        }

        /// <summary>
        /// Advances the controller state by deltaTime seconds. Is called only for initialized controllers
        /// </summary>
        protected virtual void InitializedApplyDeltaTime(float deltaTime)
        {
#if UNITY_EDITOR
            EditModeLastUpdate = Time.realtimeSinceStartup;
#endif
            if (State == CurvyControllerState.Playing && Speed * deltaTime != 0)
            {
                float speed = UseOffset && OffsetCompensation && OffsetRadius != 0f
                    ? ComputeOffsetCompensatedSpeed(deltaTime)
                    : Speed;

                if (speed * deltaTime != 0)
                    Advance(speed, deltaTime);
            }

            Vector3 preRefreshPosition;
            Quaternion preRefreshOrientation;
            GetPositionAndRotation(out preRefreshPosition, out preRefreshOrientation);

            Vector3 newPosition;
            Vector3 newForward;
            Vector3 newUp;
            ComputeTargetPositionAndRotation(out newPosition, out newUp, out newForward);

            Vector3 postDampingForward;
            if (DirectionDampingTime > 0 && State == CurvyControllerState.Playing)
            {
                postDampingForward = deltaTime > 0
                    ? Vector3.SmoothDamp(preRefreshOrientation * Vector3.forward, newForward, ref DirectionDampingVelocity, DirectionDampingTime, float.PositiveInfinity, deltaTime)
                    : preRefreshOrientation * Vector3.forward;
            }
            else
                postDampingForward = newForward;

            Vector3 postDampingUp;
            if (UpDampingTime > 0 && State == CurvyControllerState.Playing)
            {
                postDampingUp = deltaTime > 0
                    ? Vector3.SmoothDamp(preRefreshOrientation * Vector3.up, newUp, ref UpDampingVelocity, UpDampingTime, float.PositiveInfinity, deltaTime)
                    : preRefreshOrientation * Vector3.up;
            }
            else
                postDampingUp = newUp;

            Quaternion newRotation = Quaternion.LookRotation(postDampingForward, postDampingUp);

            SetPositionAndRotation(newPosition, newRotation);

            if (preRefreshPosition.NotApproximately(newPosition) || preRefreshOrientation.DifferentOrientation(newRotation))
                UserAfterUpdate();
        }

        /// <summary>
        /// Gets the position and rotation of the controller, ignoring any damping or other interpolations
        /// </summary>
        /// <param name="targetPosition"></param>
        /// <param name="targetUp"></param>
        /// <param name="targetForward"></param>
        protected virtual void ComputeTargetPositionAndRotation(out Vector3 targetPosition, out Vector3 targetUp, out Vector3 targetForward)
        {
            Vector3 pos;
            Vector3 tangent;
            Vector3 orientation;
            GetInterpolatedSourcePosition(RelativePosition, out pos, out tangent, out orientation);

            if (tangent == Vector3.zero || orientation == Vector3.zero)
                GetOrientationNoneUpAndForward(out targetUp, out targetForward);
            else
            {
                switch (OrientationMode)
                {
                    case OrientationModeEnum.None:
                        GetOrientationNoneUpAndForward(out targetUp, out targetForward);
                        break;
                    case OrientationModeEnum.Orientation:
                        {
                            Vector3 signedTangent = (m_Direction == MovementDirection.Backward && IgnoreDirection == false) ? -tangent : tangent;
                            switch (OrientationAxis)
                            {
                                case OrientationAxisEnum.Up:
                                    targetUp = orientation;
                                    targetForward = signedTangent;
                                    break;
                                case OrientationAxisEnum.Down:
                                    targetUp = -orientation;
                                    targetForward = signedTangent;
                                    break;
                                case OrientationAxisEnum.Forward:
                                    targetUp = -signedTangent;
                                    targetForward = orientation;
                                    break;
                                case OrientationAxisEnum.Backward:
                                    targetUp = signedTangent;
                                    targetForward = -orientation;
                                    break;
                                case OrientationAxisEnum.Left:
                                    targetUp = Vector3.Cross(orientation, signedTangent);
                                    targetForward = signedTangent;
                                    break;
                                case OrientationAxisEnum.Right:
                                    targetUp = Vector3.Cross(signedTangent, orientation);
                                    targetForward = signedTangent;
                                    break;
                                default:
                                    throw new NotSupportedException();
                            }
                        }
                        break;
                    case OrientationModeEnum.Tangent:
                        {

                            Vector3 signedTangent = (m_Direction == MovementDirection.Backward && IgnoreDirection == false) ? -tangent : tangent;
                            switch (OrientationAxis)
                            {
                                case OrientationAxisEnum.Up:
                                    targetUp = signedTangent;
                                    targetForward = -orientation;
                                    break;
                                case OrientationAxisEnum.Down:
                                    targetUp = -signedTangent;
                                    targetForward = orientation;
                                    break;
                                case OrientationAxisEnum.Forward:
                                    targetUp = orientation;
                                    targetForward = signedTangent;
                                    break;
                                case OrientationAxisEnum.Backward:
                                    targetUp = orientation;
                                    targetForward = -signedTangent;
                                    break;
                                case OrientationAxisEnum.Left:
                                    targetUp = orientation;
                                    targetForward = Vector3.Cross(orientation, signedTangent);
                                    break;
                                case OrientationAxisEnum.Right:
                                    targetUp = orientation;
                                    targetForward = Vector3.Cross(signedTangent, orientation);
                                    break;
                                default:
                                    throw new NotSupportedException();
                            }
                        }
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

            targetPosition = (UseOffset && OffsetRadius != 0f)
                ? ApplyOffset(pos, tangent, orientation, OffsetAngle, OffsetRadius)
                : pos;
        }


        virtual protected void Initialize()
        {
            isInitialized = true;
            GetPositionAndRotation(out _, out Quaternion rotation);
            LockedRotation = rotation;
            DirectionDampingVelocity = UpDampingVelocity = Vector3.zero;

            BindEvents();
            UserAfterInit();
            onInitialized.Invoke(this);
        }

        virtual protected void Deinitialize()
        {
            UnbindEvents();
            isInitialized = false;
        }

        /// <summary>
        /// Binds any external events
        /// </summary>
        protected virtual void BindEvents()
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(isInitialized);
#endif
        }
        /// <summary>
        /// Unbinds any external events
        /// </summary>
        protected virtual void UnbindEvents()
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(isInitialized);
#endif
        }

        protected virtual void SavePrePlayState()
        {
            PrePlayPosition = m_Position;
            PrePlayDirection = m_Direction;
        }

        protected virtual void RestorePrePlayState()
        {
            m_Position = PrePlayPosition;
            m_Direction = PrePlayDirection;
        }

        /// <summary>
        /// Gets the current position and rotation of the target component
        /// </summary>
        /// <seealso cref="TargetComponent"/>
        protected virtual void GetPositionAndRotation(out Vector3 position, out Quaternion rotation)
        {
            switch (TargetComponent)
            {
                case TargetComponent.Transform:
                    {
                        Transform cachedTransform = Transform;
                        position = cachedTransform.position;
                        rotation = cachedTransform.rotation;
                    }
                    break;
                case TargetComponent.KinematicRigidbody:
                    {
                        Rigidbody cachedRigidBody = Rigidbody;
                        if (cachedRigidBody == null || Application.isPlaying == false)
                        {
                            Transform cachedTransform = Transform;
                            position = cachedTransform.position;
                            rotation = cachedTransform.rotation;
                        }
                        else
                        {
                            position = cachedRigidBody.position;
                            rotation = cachedRigidBody.rotation;
                        }
                    }
                    break;
                case TargetComponent.KinematicRigidbody2D:
                    {
                        Rigidbody2D cachedRigidBody = Rigidbody2D;
                        if (cachedRigidBody == null || Application.isPlaying == false)
                        {
                            Transform cachedTransform = Transform;
                            position = cachedTransform.position;
                            rotation = cachedTransform.rotation;
                        }
                        else
                        {
                            position = cachedRigidBody.position;
                            rotation = Quaternion.AngleAxis(Rigidbody2D.rotation, cachedRigidBody.transform.rotation * new Vector3(0, 0, 1));
                        }
                    }
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        /// <summary>
        /// Sets a new position and rotation to the target component
        /// </summary>
        /// <seealso cref="TargetComponent"/>
        protected virtual void SetPositionAndRotation(Vector3 position, Quaternion rotation)
        {
            Vector3 constrainedPosition;
            Quaternion constrainedRotation;
            if (MotionConstraints == MotionConstraints.None)
            {
                constrainedPosition = position;
                constrainedRotation = rotation;
            }
            else
            {
                GetPositionAndRotation(out var oldPosition, out var oldRotation);

                //position
                {
                    constrainedPosition.x =
                        (MotionConstraints & MotionConstraints.FreezePositionX) == 0
                            ? position.x
                            : oldPosition.x;

                    constrainedPosition.y =
                        (MotionConstraints & MotionConstraints.FreezePositionY) == 0
                            ? position.y
                            : oldPosition.y;

                    constrainedPosition.z =
                        (MotionConstraints & MotionConstraints.FreezePositionZ) == 0
                            ? position.z
                            : oldPosition.z;
                }

                //rotation
                {

                    Vector3 constrainedRotationEuler;
                    {
                        Vector3 rotationEuler = rotation.eulerAngles;
                        Vector3 oldRotationEuler = oldRotation.eulerAngles;

                        constrainedRotationEuler.x =
                            (MotionConstraints & MotionConstraints.FreezeRotationX) == 0
                                ? rotationEuler.x
                                : oldRotationEuler.x;

                        constrainedRotationEuler.y =
                            (MotionConstraints & MotionConstraints.FreezeRotationY) == 0
                                ? rotationEuler.y
                                : oldRotationEuler.y;

                        constrainedRotationEuler.z =
                            (MotionConstraints & MotionConstraints.FreezeRotationZ) == 0
                                ? rotationEuler.z
                                : oldRotationEuler.z;
                    }

                    constrainedRotation = Quaternion.Euler(constrainedRotationEuler);
                }
            }

            switch (TargetComponent)
            {
                case TargetComponent.Transform:
                    {
                        Transform.SetPositionAndRotation(constrainedPosition, constrainedRotation);
                    }
                    break;
                case TargetComponent.KinematicRigidbody:
                    {
                        Rigidbody cachedRigidBody = Rigidbody;
                        if (cachedRigidBody == null || Application.isPlaying == false)
                        {
                            Transform.SetPositionAndRotation(constrainedPosition, constrainedRotation);
                        }
                        else
                        {
                            cachedRigidBody.MovePosition(constrainedPosition); //cachedRigidbody.position is not yet updated. Will be done after physics simulation.
                            cachedRigidBody.MoveRotation(constrainedRotation); //cachedRigidbody.roation is not yet updated. Will be done after physics simulation.
                        }
                    }
                    break;
                case TargetComponent.KinematicRigidbody2D:
                    {
                        Rigidbody2D cachedRigidBody = Rigidbody2D;
                        if (cachedRigidBody == null || Application.isPlaying == false)
                        {
                            Transform.SetPositionAndRotation(constrainedPosition, constrainedRotation);
                        }
                        else
                        {
                            cachedRigidBody.MovePosition(constrainedPosition); //cachedRigidbody.position is not yet updated. Will be done after physics simulation.
                            cachedRigidBody.MoveRotation(constrainedRotation); //cachedRigidbody.roation is not yet updated. Will be done after physics simulation.
                        }
                    }
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        #region ### Virtual Methods for inherited custom controllers (Easy mode) ###

        /// <summary>
        /// Called after the controller is initialized
        /// </summary>
        protected virtual void UserAfterInit() { }
        /// <summary>
        /// Called after the controller has updated it's position or rotation
        /// </summary>
        protected virtual void UserAfterUpdate() { }

        #endregion

        #region Conditional display in the inspector of CurvyController properties

        /// <summary>
        /// Whether the controller should display the CurvyController properties under the Orientation section or not.
        /// </summary>
        protected virtual bool ShowOrientationSection
        {
            get { return true; }
        }
        /// <summary>
        /// Whether the controller should display the CurvyController properties under the Offset section or not.
        /// </summary>
        protected virtual bool ShowOffsetSection
        {
            get { return OrientationMode != OrientationModeEnum.None; }
        }

        #endregion

        #endregion

        #region ### Abstract Properties and Methods ###

        /// <summary>
        /// Gets the source's length
        /// </summary>
        public abstract float Length { get; }

        /// <summary>
        /// Advance the controller and return the new position. This method will do side effect operations if needed, like updating some internal state, or trigerring events.
        /// </summary>
        /// <param name="speed">controller's speed. Should be strictely positive</param>
        /// <param name="deltaTime">the time that the controller should advance with. Should be strictely positive</param>
        abstract protected void Advance(float speed, float deltaTime);

        /// <summary>
        /// Advance the controller and return the new position. Contrary to <see cref="Advance"/>, this method will not do any side effect operations, like updating some internal state, or trigerring events
        /// 
        /// </summary>
        /// <param name="tf">the current virtual position (either TF or World Units) </param>
        /// <param name="curyDirection">the current direction</param>
        /// <param name="speed">controller's speed. Should be strictely positive</param>
        /// <param name="deltaTime">the time that the controller should advance with. Should be strictely positive</param>
        abstract protected void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime);

        /// <summary>
        /// Converts distance on source from absolute to relative position.
        /// </summary>
        /// <param name="worldUnitDistance">distance in world units from the source start. Should be already clamped</param>
        /// <returns>relative distance in the range 0..1</returns>
        abstract protected float AbsoluteToRelative(float worldUnitDistance);

        /// <summary>
        /// Converts distance on source from relative to absolute position.
        /// </summary>
        /// <param name="relativeDistance">relative distance from the source start. Should be already clamped</param>
        /// <returns>distance in world units from the source start</returns>
        abstract protected float RelativeToAbsolute(float relativeDistance);

        /// <summary>
        /// Retrieve the source global position for a given relative position (TF)
        /// </summary>
        abstract protected Vector3 GetInterpolatedSourcePosition(float tf);

        /// <summary>
        /// Retrieve the source global position, tangent and orientation for a given relative position (TF)
        /// </summary>
        abstract protected void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up);

        /// <summary>
        /// Retrieve the source global Orientation/Up-Vector for a given relative position
        /// </summary>
        abstract protected Vector3 GetOrientation(float tf);

        /// <summary>
        /// Gets global tangent for a given relative position
        /// </summary>
        abstract protected Vector3 GetTangent(float tf);


        #endregion


        #region Non virtual public methods 

        /// <summary>
        /// Plays the controller. Calling this method while the controller is playing will have no effect.
        /// </summary>
        public void Play()
        {
            if (PlayState == CurvyControllerState.Stopped)
                SavePrePlayState();
            State = CurvyControllerState.Playing;
        }

        /// <summary>
        /// Stops the controller, and restore its position (and other relevant states) to its state when starting playing
        /// </summary>
        public void Stop()
        {
            if (PlayState != CurvyControllerState.Stopped)
                RestorePrePlayState();
            State = CurvyControllerState.Stopped;
        }

        /// <summary>
        /// Pauses the controller. To unpause it call Play()
        /// </summary>
        public void Pause()
        {
            if (PlayState == CurvyControllerState.Playing)
                State = CurvyControllerState.Paused;
        }

        /// <summary>
        /// Forces the controller to update its state, without waiting for the automatic per frame update.
        /// Can initialize or deinitialize the controller if the right conditions are met.
        /// </summary>
        public void Refresh()
        {
            ApplyDeltaTime(0);
        }

        /// <summary>
        /// Advances the controller state by deltaTime seconds, without waiting for the automatic per frame update.
        /// Can initialize or deinitialize the controller if the right conditions are met.
        /// </summary>
        public void ApplyDeltaTime(float deltaTime)
        {
            if (isInitialized == false && IsReady)
                Initialize();
            else if (isInitialized && IsReady == false)
                Deinitialize();

            if (isInitialized)
                InitializedApplyDeltaTime(deltaTime);
        }

        /// <summary>
        /// Teleports the controller to a specific position, while handling events triggering and connections.
        /// </summary>
        /// <remarks> Internally, the teleport is handled as a movement of high speed on small time (0.001s). This will call <see cref="ApplyDeltaTime"/> with that small amount of time.</remarks>
        public void TeleportTo(float newPosition)
        {
            float distance = Mathf.Abs(Position - newPosition);
            MovementDirection direction = Position < newPosition
                ? MovementDirection.Forward
                : MovementDirection.Backward;
            TeleportBy(distance, direction);
        }

        /// <summary>
        /// Teleports the controller to by a specific distance, while handling events triggering and connections.
        /// </summary>
        /// <param name="distance"> A positive distance</param>
        /// <param name="direction"> Direction of teleportation</param>
        /// <remarks> Internally, the teleport is handled as a movement of high speed on small time (0.001s). This will call <see cref="ApplyDeltaTime"/> with that small amount of time.</remarks>
        public void TeleportBy(float distance, MovementDirection direction)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(distance >= 0);
#endif
            if (PlayState != CurvyControllerState.Playing)
                DTLog.LogError("[Curvy] Calling TeleportBy on a controller that is stopped. Please make the controller play first", this);

            float preWrapSpeed = Speed;
            MovementDirection preWrapDirection = MovementDirection;

            const float timeFraction = 1000;
            Speed = Mathf.Abs(distance) * timeFraction;
            MovementDirection = direction;

            ApplyDeltaTime(1 / timeFraction);

            Speed = preWrapSpeed;
            MovementDirection = preWrapDirection;
        }



        /// <summary>
        /// Event-friedly helper that sets a field or property value
        /// </summary>
        /// <param name="fieldAndValue">e.g. "MyValue=42"</param>
        public void SetFromString(string fieldAndValue)
        {
            string[] f = fieldAndValue.Split('=');
            if (f.Length != 2)
                return;

            FieldInfo fi = this.GetType().FieldByName(f[0], true, false);
            if (fi != null)
            {
                try
                {
                    if (fi.FieldType.IsEnum)
                        fi.SetValue(this, System.Enum.Parse(fi.FieldType, f[1]));
                    else
                        fi.SetValue(this, System.Convert.ChangeType(f[1], fi.FieldType, System.Globalization.CultureInfo.InvariantCulture));
                }
                catch (System.Exception e)
                {
                    Debug.LogWarning(this.name + ".SetFromString(): " + e.ToString());
                }
            }
            else
            {
                PropertyInfo pi = this.GetType().PropertyByName(f[0], true, false);
                if (pi != null)
                {
                    try
                    {
                        if (pi.PropertyType.IsEnum)
                            pi.SetValue(this, System.Enum.Parse(pi.PropertyType, f[1]), null);
                        else
                            pi.SetValue(this, System.Convert.ChangeType(f[1], pi.PropertyType, System.Globalization.CultureInfo.InvariantCulture), null);
                    }
                    catch (System.Exception e)
                    {
                        Debug.LogWarning(this.name + ".SetFromString(): " + e.ToString());
                    }
                }
            }
        }
        #endregion



        #region ### Privates & Protected Methods & Properties ###

        /// <summary>
        /// Whether or not the controller is initialized. Initialization happens before first usage
        /// </summary>
        protected bool isInitialized { get; private set; }

        /// <summary>
        /// When in Play mode, the controller update happens only in Update or Late Update of Fixed Update, so the time since last update is always equal to Time.deltaTime
        /// When in Edit mode, the controller update happens at various points, including the editor's update, so we compute the time since last update using a time stamp
        /// </summary>
        protected float TimeSinceLastUpdate
        {
            get
            {
#if UNITY_EDITOR
                return (Application.isPlaying) ?
                    Time.deltaTime :
                    Time.realtimeSinceStartup - EditModeLastUpdate;
#else
                    return  Time.deltaTime;
#endif
            }
        }

        /// <summary>
        /// Whether this controller uses Offsetting or not
        /// </summary>
        protected bool UseOffset
        {
            get { return ShowOffsetSection; }
        }

#if UNITY_EDITOR
        private void editorUpdate()
        {
            if (Application.isPlaying == false)
            {
                if (ForceFrequentUpdates)
                    EditorApplication.QueuePlayerLoopUpdate();
                else
                    ApplyDeltaTime(TimeSinceLastUpdate);
            }
        }
#endif

        /// <summary>
        /// Returns the position of the controller after applying an offset
        /// </summary>
        /// <param name="position">The controller's position</param>
        /// <param name="tangent">The tangent at the controller's position</param>
        /// <param name="up">The Up direction at the controller's position</param>
        /// <param name="offsetAngle"><see cref="OffsetAngle"/></param>
        /// <param name="offsetRadius"><see cref="OffsetRadius"/></param>
        protected static Vector3 ApplyOffset(Vector3 position, Vector3 tangent, Vector3 up, float offsetAngle, float offsetRadius)
        {
            Quaternion offsetRotation = Quaternion.AngleAxis(offsetAngle, tangent);
            return position.Addition((offsetRotation * up).Multiply(offsetRadius));
        }

        /// <summary>
        /// Return the clamped position
        /// </summary>
        protected static float GetClampedPosition(float position, CurvyPositionMode positionMode, CurvyClamping clampingMode, float length)
        {
            float clampedPosition;
            {
                switch (positionMode)
                {
                    case CurvyPositionMode.Relative:
                        if (position == 1)
                            clampedPosition = 1;
                        else
                            clampedPosition = CurvyUtility.ClampTF(position, clampingMode);
                        break;
                    case CurvyPositionMode.WorldUnits:
                        if (position == length)
                            clampedPosition = length;
                        else
                            clampedPosition = CurvyUtility.ClampDistance(position, clampingMode, length);
                        break;
                    default:
                        throw new NotSupportedException();
                }
            }
            return clampedPosition;
        }

        private float maxPosition
        {
            get
            {
                return GetMaxPosition(PositionMode);
            }
        }

        /// <summary>
        /// Returns the maximal valid position value using the given <see cref="CurvyPositionMode"/>
        /// </summary>
        /// <param name="positionMode"></param>
        protected float GetMaxPosition(CurvyPositionMode positionMode)
        {
            float result;
            switch (positionMode)
            {
                case CurvyPositionMode.Relative:
                    result = 1;
                    break;
                case CurvyPositionMode.WorldUnits:
                    result = IsReady
                        ? Length
                        : 0;
                    break;
                default:
                    throw new NotSupportedException();
            }

            return result;
        }

        /// <summary>
        /// Returns the Speed after applying Offset Compensation <see cref="OffsetCompensation"/>
        /// </summary>
        /// <param name="deltaTime">Time since last update</param>
        /// <returns></returns>
        protected float ComputeOffsetCompensatedSpeed(float deltaTime)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(deltaTime > 0);
            Assert.IsTrue(UseOffset);
#endif

            if (OffsetRadius == 0)
                return Speed;

            Vector3 previousOffsetlesPosition;
            Vector3 previousOffsetPosition;
            {
                Vector3 previousTangent;
                Vector3 previousUp;
                GetInterpolatedSourcePosition(RelativePosition, out previousOffsetlesPosition, out previousTangent, out previousUp);

                previousOffsetPosition = ApplyOffset(previousOffsetlesPosition, previousTangent, previousUp, OffsetAngle, OffsetRadius);
            }

            Vector3 offsetlesPosition;
            Vector3 offsetPosition;
            {
                float offsetlesRelativePosition;
                {
                    offsetlesRelativePosition = RelativePosition;
                    MovementDirection curvyDirection = m_Direction;
                    SimulateAdvance(ref offsetlesRelativePosition, ref curvyDirection, Speed, deltaTime);
                }

                Vector3 offsetlesTangent;
                Vector3 offsetlesUp;
                GetInterpolatedSourcePosition(offsetlesRelativePosition, out offsetlesPosition, out offsetlesTangent, out offsetlesUp);

                offsetPosition = ApplyOffset(offsetlesPosition, offsetlesTangent, offsetlesUp, OffsetAngle, OffsetRadius);
            }

            float deltaPosition = (offsetlesPosition - previousOffsetlesPosition).magnitude;
            float deltaOffsetPosition = (previousOffsetPosition - offsetPosition).magnitude;
            float ratio = (deltaPosition / deltaOffsetPosition);
            return Speed * (float.IsNaN(ratio) ? 1 : ratio);
        }

        //TODO This should be a local method when all supported unity versions will handle C#7
        /// <summary>
        /// Gets the Up and Forward of the orientation when the <see cref="OrientationMode"/> is set to <see cref="OrientationModeEnum.None"/>
        /// </summary>
        private void GetOrientationNoneUpAndForward(out Vector3 targetUp, out Vector3 targetForward)
        {
            if (LockRotation)
            {
                targetUp = LockedRotation * Vector3.up;
                targetForward = LockedRotation * Vector3.forward;
            }
            else
            {
                GetPositionAndRotation(out _, out Quaternion rotation);

                targetUp = rotation * Vector3.up;
                targetForward = rotation * Vector3.forward;
            }
        }
        #region Rigibody target handling
        private bool IsNeededRigidbodyMissing
        {
            get
            {
                return targetComponent == TargetComponent.KinematicRigidbody && Rigidbody == null;
            }
        }

        private bool IsNeeded2DRigidbodyMissing
        {
            get
            {
                return targetComponent == TargetComponent.KinematicRigidbody2D && Rigidbody2D == null;
            }
        }

        private bool IsNeededRigidbodyNotKinematic
        {
            get
            {
                Rigidbody localRigidBody = Rigidbody;
                return targetComponent == TargetComponent.KinematicRigidbody && localRigidBody != null && localRigidBody.isKinematic == false;
            }
        }

        private bool IsNeeded2DRigidbodyNotKinematic
        {
            get
            {
                Rigidbody2D localRigidBody = Rigidbody2D;
                return targetComponent == TargetComponent.KinematicRigidbody2D && localRigidBody != null && localRigidBody.isKinematic == false;
            }
        }

        private bool AreConstraintsConflicting
        {
            get
            {
                Rigidbody localRigidBody;
                Rigidbody2D localRigidBody2D;
                bool isConflicting;
                switch (TargetComponent)
                {
                    case TargetComponent.KinematicRigidbody when (localRigidBody = Rigidbody) != null:
                        isConflicting = localRigidBody.constraints != RigidbodyConstraints.None;
                        break;
                    case TargetComponent.KinematicRigidbody2D when (localRigidBody2D = Rigidbody2D) != null:
                        isConflicting = localRigidBody2D.constraints != RigidbodyConstraints2D.None;
                        break;
                    default:
                        isConflicting = false;
                        break;
                }

                return isConflicting;
            }
        }

        #endregion

        #endregion

        #region ISerializationCallbackReceiver
        /*! \cond PRIVATE */
        /// <summary>
        /// Implementation of UnityEngine.ISerializationCallbackReceiver
        /// Called automatically by Unity, is not meant to be called by Curvy's users
        /// </summary>
        public void OnBeforeSerialize()
        {
        }

        /// <summary>
        /// Implementation of UnityEngine.ISerializationCallbackReceiver
        /// Called automatically by Unity, is not meant to be called by Curvy's users
        /// </summary>
        public virtual void OnAfterDeserialize()
        {
            if (m_Speed < 0)
            {
                m_Speed = Mathf.Abs(m_Speed);
                m_Direction = MovementDirection.Backward;
            }

            //Merged AbsolutePrecise and AbsoluteExtrapolate into one value
            if ((short)MoveMode == 2)
                MoveMode = MoveModeEnum.AbsolutePrecise;
        }
        /*! \endcond */
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/CurvyController.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/MotionConstraints.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5e008b0661a3c064083d0fff5655a116
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// Defines what motions are to be frozen
    /// </summary>
    [System.Flags]
    public enum MotionConstraints
    {
        /// <summary>
        /// No constraints.
        /// </summary>
        None = 0,
        /// <summary>
        /// Freeze motion along the X-axis.
        /// </summary>
        FreezePositionX = 1 << 0,
        /// <summary>
        /// Freeze motion along the Y-axis.
        /// </summary>
        FreezePositionY = 1 << 1,
        /// <summary>
        /// Freeze motion along the Z-axis.
        /// </summary>
        FreezePositionZ = 1 << 2,
        /// <summary>
        /// Freeze rotation along the X-axis.
        /// </summary>
        FreezeRotationX = 1 << 3,
        /// <summary>
        /// Freeze rotation along the Y-axis.
        /// </summary>
        FreezeRotationY = 1 << 4,
        /// <summary>
        /// Freeze rotation along the Z-axis.
        /// </summary>
        FreezeRotationZ = 1 << 5,

        #region Hidden because of inspector not handling it properly
        /*
        /// <summary>
        /// Freeze motion along all axes.
        /// </summary>
        FreezePosition = FreezePositionX | FreezePositionY | FreezePositionZ,
        /// <summary>
        /// Freeze rotation along all axes.
        /// </summary>
        FreezeRotation = FreezeRotationX | FreezeRotationY | FreezeRotationZ,
        /// <summary>
        /// Freeze motion along all axes.
        /// </summary>
        FreezeAll = FreezePosition | FreezeRotation
        */
        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/MotionConstraints.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/MovementDirection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d7eb8ecd5bf585346a7ad6f0646e4939
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// Defines if the controller will move the object the same direction that the spline or the opposite one
    /// </summary>
    /// <seealso cref="MovementDirectionMethods"/>
    public enum MovementDirection
    {
        /// <summary>
        /// Same direction than spline's tangent
        /// </summary>
        Forward,
        /// <summary>
        /// Opposite direction than spline's tangent
        /// </summary>
        Backward
    }
    /// <summary>
    /// Extension methods for <see cref="MovementDirection"/>
    /// </summary>
    public static class MovementDirectionMethods
    {
        /// <summary>
        /// Converts the int to a direction. Positive int means Forward, negative means backward.
        /// </summary>
        public static MovementDirection FromInt(int value)
        {
           return value >= 0
                ? MovementDirection.Forward
                : MovementDirection.Backward;
        }

        /// <summary>
        /// Returns the opposite value of the given direction value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static MovementDirection GetOpposite(this MovementDirection value)
        {
            MovementDirection result;
            switch (value)
            {
                case MovementDirection.Forward:
                    result = MovementDirection.Backward;
                    break;
                case MovementDirection.Backward:
                    result = MovementDirection.Forward;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            return result;
        }

        /// <summary>
        /// Converts the direction to an int. Positive int means Forward, negative means backward.
        /// </summary>
        public static int ToInt(this MovementDirection direction)
        {
            int result;
            switch (direction)
            {
                case MovementDirection.Forward:
                    result = 1;
                    break;
                case MovementDirection.Backward:
                    result = -1;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            return result;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/MovementDirection.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/OnPositionReachedSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 254770b4f3df24245ba3f57e7b51b875
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;

namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// Settings for events to be triggered when the controller reaches a specific position
    /// </summary>
    [System.Serializable]
    public class OnPositionReachedSettings : ISerializationCallbackReceiver
    {
        public string Name;
        public CurvySplineMoveEvent Event = new CurvySplineMoveEvent();
        public float Position;
        public CurvyPositionMode PositionMode;
        public TriggeringDirections TriggeringDirections;
        public Color GizmoColor;

        #region handling default values

        public OnPositionReachedSettings()
        {
            InitializeFieldsWithDefaultValue();
        }

        [SerializeField, HideInInspector]
        private bool initialized;

        /// <summary>
        /// Default values assigned at field initialization or at construction are overriden with default type values when instances of this class are added to a list. This method is used to fix that issue
        /// </summary>
        private void InitializeFieldsWithDefaultValue()
        {
            Name = "My Event";
            PositionMode = CurvyPositionMode.WorldUnits;
            TriggeringDirections = TriggeringDirections.All;
            GizmoColor = new Color(0.652f, 0.652f, 0.652f);
            initialized = true;
        }

        public void OnBeforeSerialize() { }

        public void OnAfterDeserialize()
        {
            //when an instance of this class is added to a list via the inspector, its fields are set to their types default values (0, false, ...). I try to detect that via this test, then assign the default values I want
            if (initialized == false)
                InitializeFieldsWithDefaultValue();
        }
        #endregion

        public OnPositionReachedSettings Clone()
        {
            return (OnPositionReachedSettings)MemberwiseClone();
        }
    }

    /// <summary>
    /// Defines what travel directions should trigger an event
    /// </summary>
    public enum TriggeringDirections
    {
        /// <summary>
        /// All directions
        /// </summary>
        All,
        /// <summary>
        /// Same direction as spline's tangent
        /// </summary>
        Forward,
        /// <summary>
        /// Opposite direction as spline's tangent
        /// </summary>
        Backward
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/OnPositionReachedSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/PathController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ec8c51951f66b4a4099916a8055d980a
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;


namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// Controller working on Curvy Generator Paths
    /// </summary>
    [AddComponentMenu("Curvy/Controllers/CG Path Controller")]
    [HelpURL(CurvySpline.DOCLINK + "pathcontroller")]
    public class PathController : CurvyController
    {

        #region ### Serialized Fields ###

        [Section("General", Sort = 0)]
        [SerializeField]
        [CGDataReferenceSelector(typeof(CGPath), Label = "Path/Slot")]
        private CGDataReference m_Path = new CGDataReference();

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Gets or sets the path to use
        /// </summary>
        public CGDataReference Path
        {
            get { return m_Path; }
            set { m_Path = value; }
        }

        /// <summary>
        /// Gets the actual CGPath data
        /// </summary>
        public CGPath PathData
        {
            get
            {
                return (Path.HasValue) ? Path.GetData<CGPath>() : null;
            }
        }

        /// <summary>
        /// Gets the source's length
        /// </summary>
        public override float Length
        {
            get
            {
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
                return (PathData != null) ? PathData.Length : 0;
            }
        }

        #endregion

        #region ### Private fields ###


        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        #endregion

        #region ### Protected Methods ###


        override public bool IsReady
        {
            get
            {
                return Path != null && !Path.IsEmpty && Path.HasValue;
            }
        }


        /// <summary>
        /// Converts distance on source from relative to absolute position.
        /// </summary>
        /// <param name="relativeDistance">relative distance from the source start. Should be already clamped</param>
        /// <returns>distance in world units from the source start</returns>
        protected override float RelativeToAbsolute(float relativeDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
            Assert.IsTrue(CurvyUtility.Approximately(relativeDistance, GetClampedPosition(relativeDistance, CurvyPositionMode.Relative, Clamping, Length)));
#endif

            return (PathData != null) ? PathData.FToDistance(relativeDistance) : 0;
        }

        /// <summary>
        /// Converts distance on source from absolute to relative position.
        /// </summary>
        /// <param name="worldUnitDistance">distance in world units from the source start. Should be already clamped</param>
        /// <returns>relative distance in the range 0..1</returns>
        protected override float AbsoluteToRelative(float worldUnitDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
            Assert.IsTrue(CurvyUtility.Approximately(worldUnitDistance, GetClampedPosition(worldUnitDistance, CurvyPositionMode.WorldUnits, Clamping, Length)));
#endif
            return (PathData != null) ? PathData.DistanceToF(worldUnitDistance) : 0;
        }

        protected override Vector3 GetInterpolatedSourcePosition(float tf)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return Path.Module.Generator.transform.TransformPoint(PathData.InterpolatePosition(tf));
        }

        protected override void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            PathData.Interpolate(tf, out interpolatedPosition, out tangent, out up);
            Transform generatorTransform = Path.Module.Generator.transform;
            interpolatedPosition = generatorTransform.TransformPoint(interpolatedPosition);
            tangent = generatorTransform.TransformDirection(tangent);
            up = generatorTransform.TransformDirection(up);
        }

        protected override Vector3 GetTangent(float tf)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return Path.Module.Generator.transform.TransformDirection(PathData.InterpolateDirection(tf));
        }

        protected override Vector3 GetOrientation(float tf)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return Path.Module.Generator.transform.TransformDirection(PathData.InterpolateUp(tf));
        }

        protected override void Advance(float speed, float deltaTime)
        {
            float tf = RelativePosition;
            MovementDirection direction = MovementDirection;

            SimulateAdvance(ref tf, ref direction, speed, deltaTime);

            MovementDirection = direction;
            RelativePosition = tf;
        }

        override protected void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            int directionInt = curyDirection.ToInt();
            switch (MoveMode)
            {
                case MoveModeEnum.Relative:
                    PathData.Move(ref tf, ref directionInt, speed * deltaTime, Clamping);
                    break;
                case MoveModeEnum.AbsolutePrecise:
                    PathData.MoveBy(ref tf, ref directionInt, speed * deltaTime, Clamping);
                    break;
                default:
                    throw new NotSupportedException();
            }
            curyDirection = MovementDirectionMethods.FromInt(directionInt);
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/PathController.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/SplineController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dacc8a2ff207fca49bdaf5d45a943d80
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using UnityEngine.Assertions;
using Random = UnityEngine.Random;

namespace FluffyUnderware.Curvy.Controllers
{

    /// <summary>
    /// Defines what spline a <see cref="SplineController"/> will use when reaching a <see cref="CurvyConnection"/>.
    /// </summary>
    public enum SplineControllerConnectionBehavior
    {
        /// <summary>
        /// Continue moving on the current spline, ignoring the connection.
        /// </summary>
        CurrentSpline,
        /// <summary>
        /// Move to the spline containing the Follow-Up if any. If none, continue moving on the current spline, ignoring the connection.
        /// </summary>
        FollowUpSpline,
        /// <summary>
        /// Move to the spline of a randomly selected control point from all the connected control points.
        /// </summary>
        RandomSpline,
        /// <summary>
        /// Move to the spline containing the Follow-Up if any. If none, move to the spline of a randomly selected control point from all the connected control points.
        /// </summary>
        FollowUpOtherwiseRandom,
        /// <summary>
        /// Use a custom defined selection logic
        /// </summary>
        Custom
    }

    /// <summary>
    /// Controller working with Splines
    /// </summary>
    [AddComponentMenu("Curvy/Controllers/Spline Controller")]
    [HelpURL(CurvySpline.DOCLINK + "splinecontroller")]
    public class SplineController : CurvyController
    {
        public SplineController()
        {
            preAllocatedEventArgs = new CurvySplineMoveEventArgs(this, Spline, null, Single.NaN, false, Single.NaN, MovementDirection.Forward);
        }

        #region ### Serialized Fields ###

        /*! \cond PRIVATE */

        /// <summary>
        /// The spline to use. It is best to set/get the spline through the <see cref="Spline"/> property instead
        /// </summary>
        [Section("General", Sort = 0)]

        [FieldCondition(nameof(m_Spline), null, false, ActionAttribute.ActionEnum.ShowError, "Missing source Spline")]
        [SerializeField]
        protected CurvySpline m_Spline;

        /*! \endcond */

        [SerializeField]
        [Tooltip("Whether spline's cache data should be used. Set this to true to gain performance if precision is not required.")]
        private bool m_UseCache;

        #region Connections handling

        [Section("Connections handling", Sort = 250, HelpURL = CurvySpline.DOCLINK + "curvycontroller_connectionshandling")]

        [SerializeField, Label("At connection, use", "What spline should the controller use when reaching a Connection")]
        private SplineControllerConnectionBehavior connectionBehavior = SplineControllerConnectionBehavior.CurrentSpline;

        #region Random Connection and Follow-Up options

        [SerializeField, Label("Allow direction change", "When true, the controller will modify its direction to best fit the connected spline")]
#if UNITY_EDITOR
        [FieldCondition(nameof(connectionBehavior), SplineControllerConnectionBehavior.FollowUpSpline, false, ConditionalAttribute.OperatorEnum.OR, "ShowRandomConnectionOptions", true, false)]
#endif

        private bool allowDirectionChange = true;

        #endregion

        #region Random Connection options

        [SerializeField, Label("Reject current spline", "Whether the current spline should be excluded from the randomly selected splines")]
        [FieldCondition(nameof(ShowRandomConnectionOptions), true)]
        private bool rejectCurrentSpline = true;

        [SerializeField, Label("Reject divergent splines", "Whether splines that diverge from the current spline with more than a specific angle should be excluded from the randomly selected splines")]
        [FieldCondition(nameof(ShowRandomConnectionOptions), true)]
        private bool rejectTooDivergentSplines = false;

        [SerializeField, Label("Max allowed angle", "Maximum allowed divergence angle in degrees")]
#if UNITY_EDITOR
        [FieldCondition(nameof(ShowRandomConnectionOptions), true, false, ConditionalAttribute.OperatorEnum.AND, "rejectTooDivergentSplines", true, false)]
#endif
        [Range(0, 180)]
        private float maxAllowedDivergenceAngle = 90;

        #endregion

        #region Custom options

        [SerializeField, Label("Custom Selector", "A custom logic to select which connected spline to follow. Select a Script inheriting from SplineControllerConnectionBehavior")]
        [FieldCondition(nameof(connectionBehavior), SplineControllerConnectionBehavior.Custom, false, ActionAttribute.ActionEnum.Show)]
        [FieldCondition(nameof(connectionCustomSelector), null, false, ActionAttribute.ActionEnum.ShowWarning, "Missing custom selector")]
        private ConnectedControlPointsSelector connectionCustomSelector;

        #endregion

        #endregion

        /*! \cond PRIVATE */

        [Section("Events", false, false, 1000, HelpURL = CurvySpline.DOCLINK + "splinecontroller_events")]
        [SerializeField]
        [ArrayEx]
        protected List<OnPositionReachedSettings> onPositionReachedList = new List<OnPositionReachedSettings>();
        [SerializeField]
        protected CurvySplineMoveEvent m_OnControlPointReached = new CurvySplineMoveEvent();
        [SerializeField]
        protected CurvySplineMoveEvent m_OnEndReached = new CurvySplineMoveEvent();
        [SerializeField]
        protected CurvySplineMoveEvent m_OnSwitch = new CurvySplineMoveEvent();

        /*! \endcond */

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Gets or sets the spline to use
        /// </summary>
        public virtual CurvySpline Spline
        {
            get { return m_Spline; }
            set
            { m_Spline = value; }
        }

        /// <summary>
        /// Gets or sets whether spline's cache data should be used
        /// </summary>
        public bool UseCache
        {
            get
            {
                return m_UseCache;
            }
            set
            {
                if (m_UseCache != value)
                    m_UseCache = value;
            }
        }


        #region Connections handling

        /// <summary>
        /// Connections handling: What spline should the controller use when reaching a Connection
        /// </summary>
        public SplineControllerConnectionBehavior ConnectionBehavior
        {
            get { return connectionBehavior; }
            set { connectionBehavior = value; }
        }

        /// <summary>
        /// Connections handling: A custom logic to select which connected spline to follow. Select a Script inheriting from SplineControllerConnectionBehavior. Is used when <see cref="ConnectionBehavior"/> is equal to <see cref="SplineControllerConnectionBehavior.Custom"/>
        /// </summary>
        public ConnectedControlPointsSelector ConnectionCustomSelector
        {
            get { return connectionCustomSelector; }
            set { connectionCustomSelector = value; }
        }

        /// <summary>
        /// Connections handling: When true, the controller will modify its direction to best fit the connected spline. Is used when <see cref="ConnectionBehavior"/> is equal to <see cref="SplineControllerConnectionBehavior.FollowUpSpline"/>,  <see cref="SplineControllerConnectionBehavior.RandomSpline"/>, or <see cref="SplineControllerConnectionBehavior.FollowUpOtherwiseRandom"/>
        /// </summary>
        public bool AllowDirectionChange
        {
            get { return allowDirectionChange; }
            set { allowDirectionChange = value; }
        }

        /// <summary>
        /// Connections handling: Whether the current spline should be excluded from the randomly selected splines. Is used when <see cref="ConnectionBehavior"/> is equal to <see cref="SplineControllerConnectionBehavior.RandomSpline"/>, or <see cref="SplineControllerConnectionBehavior.FollowUpOtherwiseRandom"/>
        /// </summary>
        public bool RejectCurrentSpline
        {
            get { return rejectCurrentSpline; }
            set { rejectCurrentSpline = value; }
        }

        /// <summary>
        /// Connections handling: Whether splines that diverge from the current spline with more than <see cref="MaxAllowedDivergenceAngle"/> should be excluded from the randomly selected splines. Is used when <see cref="ConnectionBehavior"/> is equal to <see cref="SplineControllerConnectionBehavior.RandomSpline"/>, or <see cref="SplineControllerConnectionBehavior.FollowUpOtherwiseRandom"/>
        /// </summary>
        public bool RejectTooDivergentSplines
        {
            get { return rejectTooDivergentSplines; }
            set { rejectTooDivergentSplines = value; }
        }

        /// <summary>
        /// Connections handling: Maximum allowed divergence angle in degrees. Considered when <see cref="MaxAllowedDivergenceAngle"/> is true. Is used when <see cref="ConnectionBehavior"/> is equal to <see cref="SplineControllerConnectionBehavior.RandomSpline"/>, or <see cref="SplineControllerConnectionBehavior.FollowUpOtherwiseRandom"/>
        /// </summary>
        public float MaxAllowedDivergenceAngle
        {
            get { return maxAllowedDivergenceAngle; }
            set { maxAllowedDivergenceAngle = value; }
        }

        #endregion


        /// <summary>
        /// Settings of events raised when moving over specific positions on the spline
        /// </summary>
        public List<OnPositionReachedSettings> OnPositionReachedList
        {
            get { return onPositionReachedList; }
            set { onPositionReachedList = value; }
        }

        /// <summary>
        /// Event raised when moving over a Control Point
        /// </summary>
        public CurvySplineMoveEvent OnControlPointReached
        {
            get { return m_OnControlPointReached; }
            set { m_OnControlPointReached = value; }
        }

        /// <summary>
        /// Event raised when reaching the extends (i.e. the start or end) of the source spline
        /// </summary>
        public CurvySplineMoveEvent OnEndReached
        {
            get { return m_OnEndReached; }
            set { m_OnEndReached = value; }
        }

        /// <summary>
        /// Event raised while switching splines. Splines switching is done via the <see cref="SwitchTo"/> method.
        /// </summary>
        public CurvySplineMoveEvent OnSwitch
        {
            get { return m_OnSwitch; }
            set { m_OnSwitch = value; }
        }


        /// <summary>
        /// Gets whether the Controller is switching splines
        /// </summary>
        public bool IsSwitching { get; private set; }

        /// <summary>
        /// The ratio (value between 0 and 1) expressing the progress of the current spline switch. 0 means the switch just started, 1 means the switch ended.
        /// Its value is 0 if no spline switching is in progress. Spline switching is done by calling <see cref="SwitchTo"/>
        /// </summary>
        public float SwitchProgress { get { return IsSwitching ? Mathf.Clamp01((Time.time - SwitchStartTime) / SwitchDuration) : 0; } }

        /// <summary>
        /// Gets the source's length
        /// </summary>
        public override float Length
        {
            get
            {
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
                return ReferenceEquals(Spline, null) == false ? Spline.Length : 0;
            }
        }

        #endregion

        #region ### Private & Protected Fields & Properties ###

        private CurvySpline prePlaySpline;
        private readonly CurvySplineMoveEventArgs preAllocatedEventArgs;

        #region Switch

        /// <summary>
        /// The time at which the current spline switching started.
        /// Its value is invalid if no spline switching is in progress. Spline switching is done by calling <see cref="SwitchTo"/>
        /// </summary>
        protected float SwitchStartTime;
        /// <summary>
        /// The duration of the the current spline switching.
        /// Its value is invalid if no spline switching is in progress. Spline switching is done by calling <see cref="SwitchTo"/>
        /// </summary>
        protected float SwitchDuration;
        /// <summary>
        /// The spline to which the controller is switching.
        /// Its value is invalid if no spline switching is in progress. Spline switching is done by calling <see cref="SwitchTo"/>
        /// </summary>
        protected CurvySpline SwitchTarget;
        /// <summary>
        /// The controller's current TF on the <see cref="SwitchTarget"/>.
        /// Its value is invalid if no spline switching is in progress. Spline switching is done by calling <see cref="SwitchTo"/>
        /// </summary>
        protected float TfOnSwitchTarget;
        /// <summary>
        /// The controller's current Direction on the <see cref="SwitchTarget"/>.
        /// Its value is invalid if no spline switching is in progress. Spline switching is done by calling <see cref="SwitchTo"/>
        /// </summary>
        protected MovementDirection DirectionOnSwitchTarget;

        #endregion

        #endregion

        #region ## Unity Callbacks ###

        /*! \cond UNITY */
#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            if (IsReady)
                foreach (OnPositionReachedSettings settings in OnPositionReachedList)
                    settings.Position = Mathf.Min(Mathf.Max(settings.Position, 0), GetMaxPosition(settings.PositionMode));
        }
#endif

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Start a spline switch. Should be called only on non stopped controllers.
        /// </summary>
        /// <remarks>While switching is not finished, movement on destination spline will not fire events nor consider connections</remarks>
        /// <param name="destinationSpline">the target spline to switch to</param>
        /// <param name="destinationTf">the target TF</param>
        /// <param name="duration">duration of the switch phase</param>
        public virtual void SwitchTo(CurvySpline destinationSpline, float destinationTf, float duration)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(isInitialized, ControllerNotReadyMessage);
#endif

            if (PlayState == CurvyControllerState.Stopped)
            {
                DTLog.LogError("[Curvy] Controller can not switch when stopped. The switch call will be ignored", this);
            }
            else if (duration <= 0)
            {
                DTLog.LogWarning($"[Curvy] Controller switch has a duration set to {duration}. Duration should be a strictly positive value", this);
                Spline = destinationSpline;
                RelativePosition = destinationTf;
            }
            else
            {
                SwitchStartTime = Time.time;
                SwitchDuration = duration;
                SwitchTarget = destinationSpline;
                TfOnSwitchTarget = destinationTf;
                DirectionOnSwitchTarget = MovementDirection;
                IsSwitching = true;
            }
        }

        /// <summary>
        /// If is switching splines, instantly finishes the current switch.
        /// </summary>
        public void FinishCurrentSwitch()
        {
            if (IsSwitching)
            {
                IsSwitching = false;
                Spline = SwitchTarget;
                RelativePosition = TfOnSwitchTarget;
            }
        }

        /// <summary>
        /// If is switching splines, cancels the current switch.
        /// </summary>
        public void CancelCurrentSwitch()
        {
            if (IsSwitching)
                IsSwitching = false;
        }

        /// <summary>
        /// Get the direction change, in degrees, of controller caused by the crossing of a connection.
        /// </summary>
        /// <param name="before">The control point the controller is on before crossing the connection</param>
        /// <param name="movementMode">The movement mode the controller has before crossing the connection</param>
        /// <param name="after">The control point the controller is on after crossing the connection</param>
        /// <param name="allowMovementModeChange">If true, the controller will change movemen mode to best fit the after control point. <see cref="AllowDirectionChange"/></param>
        /// <returns>A positif angle in degrees</returns>
        public static float GetAngleBetweenConnectedSplines(CurvySplineSegment before, MovementDirection movementMode, CurvySplineSegment after, bool allowMovementModeChange)
        {
            Vector3 currentTangent = before.GetTangentFast(0) * movementMode.ToInt();
            Vector3 newTangent = after.GetTangentFast(0) * GetPostConnectionDirection(after, movementMode, allowMovementModeChange).ToInt();
            return Vector3.Angle(currentTangent, newTangent);
        }

        #endregion

        #region ### Protected Methods ###

        override public bool IsReady
        {
            get
            {
                return ReferenceEquals(Spline, null) == false && Spline.IsInitialized;
            }
        }

        override protected void SavePrePlayState()
        {
            prePlaySpline = Spline;
            base.SavePrePlayState();
        }

        override protected void RestorePrePlayState()
        {
            Spline = prePlaySpline;
            base.RestorePrePlayState();
        }

        protected override float RelativeToAbsolute(float relativeDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
            Assert.IsTrue(CurvyUtility.Approximately(relativeDistance, GetClampedPosition(relativeDistance, CurvyPositionMode.Relative, Clamping, Length)));
#endif
            return Spline.TFToDistance(relativeDistance, Clamping);
        }


        protected override float AbsoluteToRelative(float worldUnitDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
            Assert.IsTrue(CurvyUtility.Approximately(worldUnitDistance, GetClampedPosition(worldUnitDistance, CurvyPositionMode.WorldUnits, Clamping, Length)));
#endif
            return Spline.DistanceToTF(worldUnitDistance, Clamping);
        }

        protected override Vector3 GetInterpolatedSourcePosition(float tf)
        {
            Vector3 p = (UseCache) ? Spline.InterpolateFast(tf) : Spline.Interpolate(tf);

            return Spline.transform.TransformPoint(p);
        }


        protected override void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up)
        {
            CurvySpline spline = Spline;
            Transform splineTransform = spline.transform;

            float localF;
            CurvySplineSegment currentSegment = spline.TFToSegment(tf, out localF);
            if (ReferenceEquals(currentSegment, null) == false)
            {
                if (UseCache)
                    currentSegment.InterpolateAndGetTangentFast(localF, out interpolatedPosition, out tangent);
                else
                    currentSegment.InterpolateAndGetTangent(localF, out interpolatedPosition, out tangent);
                up = currentSegment.GetOrientationUpFast(localF);
            }

            else
            {
                interpolatedPosition = Vector3.zero;
                tangent = Vector3.zero;
                up = Vector3.zero;
            }

            interpolatedPosition = splineTransform.TransformPoint(interpolatedPosition);
            tangent = splineTransform.TransformDirection(tangent);
            up = splineTransform.TransformDirection(up);
        }

        protected override Vector3 GetTangent(float tf)
        {
            Vector3 t = (UseCache) ? Spline.GetTangentFast(tf) : Spline.GetTangent(tf);
            return Spline.transform.TransformDirection(t);
        }

        protected override Vector3 GetOrientation(float tf)
        {
            return Spline.transform.TransformDirection(Spline.GetOrientationUpFast(tf));
        }

        protected override void Advance(float speed, float deltaTime)
        {
            float distance = speed * deltaTime;

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(distance > 0);
#endif

            if (Spline.Count != 0)
                EventAwareMove(distance);


            if (IsSwitching && SwitchTarget.Count > 0)
            {
                SimulateAdvanceOnSpline(ref TfOnSwitchTarget, ref DirectionOnSwitchTarget, SwitchTarget, speed * deltaTime);

                preAllocatedEventArgs.Set_INTERNAL(this, SwitchTarget, null, TfOnSwitchTarget, SwitchProgress, DirectionOnSwitchTarget, false);
                OnSwitch.Invoke(preAllocatedEventArgs);
                if (preAllocatedEventArgs.Cancel)
                    CancelCurrentSwitch();
            }
        }

        override protected void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime)
        {
            SimulateAdvanceOnSpline(ref tf, ref curyDirection, Spline, speed * deltaTime);
        }

        private void SimulateAdvanceOnSpline(ref float tf, ref MovementDirection curyDirection, CurvySpline spline, float distance)
        {
            if (spline.Count > 0)
            {
                int directionInt = curyDirection.ToInt();
                switch (MoveMode)
                {
                    case MoveModeEnum.AbsolutePrecise:
                        tf = spline.DistanceToTF(spline.ClampDistance(spline.TFToDistance(tf) + distance * directionInt, ref directionInt, Clamping));
                        break;
                    case MoveModeEnum.Relative:
                        tf = CurvyUtility.ClampTF(tf + distance * directionInt, ref directionInt, Clamping);
                        break;
                    default:
                        throw new NotSupportedException();
                }
                curyDirection = MovementDirectionMethods.FromInt(directionInt);
            }
        }

        override protected void InitializedApplyDeltaTime(float deltaTime)
        {
            if (Spline.Dirty)
                Spline.Refresh();

            base.InitializedApplyDeltaTime(deltaTime);

            if (IsSwitching && SwitchProgress >= 1)
                FinishCurrentSwitch();
        }

        override protected void ComputeTargetPositionAndRotation(out Vector3 targetPosition, out Vector3 targetUp, out Vector3 targetForward)
        {
            Vector3 switchlessPosition;
            Vector3 switchlessUp;
            Vector3 switchlessForward;
            base.ComputeTargetPositionAndRotation(out switchlessPosition, out switchlessUp, out switchlessForward);
            Quaternion switchlessRotation = Quaternion.LookRotation(switchlessForward, switchlessUp);

            if (IsSwitching)
            {
                CurvySpline preSwitchSpline = Spline;
                float preSwitchSplineTf = RelativePosition;

                m_Spline = SwitchTarget;
                RelativePosition = TfOnSwitchTarget;

                Vector3 positionOnSwitchToSpline;
                Vector3 upOnSwitchToSpline;
                Vector3 forwardOnSwitchToSpline;
                base.ComputeTargetPositionAndRotation(out positionOnSwitchToSpline, out upOnSwitchToSpline, out forwardOnSwitchToSpline);
                Quaternion rotationOnSwitchToSpline = Quaternion.LookRotation(forwardOnSwitchToSpline, upOnSwitchToSpline);

                m_Spline = preSwitchSpline;
                RelativePosition = preSwitchSplineTf;

                targetPosition = OptimizedOperators.LerpUnclamped(switchlessPosition, positionOnSwitchToSpline, SwitchProgress);
                Quaternion interpolatedRotation = Quaternion.LerpUnclamped(switchlessRotation, rotationOnSwitchToSpline, SwitchProgress);
                targetUp = interpolatedRotation * Vector3.up;
                targetForward = interpolatedRotation * Vector3.forward;
            }
            else
            {
                targetPosition = switchlessPosition;
                targetUp = switchlessUp;
                targetForward = switchlessForward;
            }
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */

        /// <summary>
        /// This method gets the controller position, but handles the looping differently than usual (it does not change a relative position of 1 to 0), which avoids hardly solvable ambiguities in the movement logic.
        /// </summary>
        /// <remarks>This is to make controller logic simpler, since it does not need anymore to guess if a position of 0 meant controller on the end of the spline and needed looping, or meant that the controller is on the start of the spline.</remarks>
        /// <param name="positionMode"> The one of the returned position</param>
        /// <param name="clampedPosition"> Uses the controller's <see cref="CurvyController.PositionMode"/></param>
        private static float MovementCompatibleGetPosition(SplineController controller, float clampedPosition, CurvyPositionMode positionMode, out CurvySplineSegment controlPoint, out bool isOnControlPoint)
        {

            float resultPosition;
            CurvySpline spline = controller.Spline;

            bool isOnSegmentLastCp;
            bool isOnSegmentFirstCp;
            float unconvertedLocalPosition;
            switch (controller.PositionMode)
            {
                case CurvyPositionMode.Relative:
                    controlPoint = spline.TFToSegment(clampedPosition, out unconvertedLocalPosition, out isOnSegmentFirstCp, out isOnSegmentLastCp, CurvyClamping.Clamp); //CurvyClamping.Clamp to cancel looping handling
                    break;
                case CurvyPositionMode.WorldUnits:
                    controlPoint = spline.DistanceToSegment(clampedPosition, out unconvertedLocalPosition, out isOnSegmentFirstCp, out isOnSegmentLastCp, CurvyClamping.Clamp); //CurvyClamping.Clamp to cancel looping handling
                    break;
                default:
                    throw new NotSupportedException();
            }

            if (positionMode == controller.PositionMode)
                resultPosition = clampedPosition;
            else
            {
                switch (positionMode)
                {
                    case CurvyPositionMode.Relative:
                        resultPosition = spline.SegmentToTF(controlPoint, controlPoint.DistanceToLocalF(unconvertedLocalPosition));
                        break;
                    case CurvyPositionMode.WorldUnits:
                        resultPosition = controlPoint.Distance + controlPoint.LocalFToDistance(unconvertedLocalPosition);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

            if (isOnSegmentLastCp) //Case of last cp of an open spline
                controlPoint = spline.GetNextControlPoint(controlPoint);

            isOnControlPoint = isOnSegmentFirstCp || isOnSegmentLastCp;

            return resultPosition;
        }

        /// <summary>
        /// This method sets the controller position, but handles the looping differently than usual (it does not change a realtive position of 1 to 0), which avoids hardly solvable ambiguities in the movement logic.
        /// </summary>
        /// <remarks>This is to make controller logic simpler, since it does not need anymore to guess if a position of 0 meant controller on the end of the spline and needed looping, or meant that the controller is on the start of the spline.</remarks>
        private static void MovementCompatibleSetPosition(SplineController controller, CurvyPositionMode positionMode, float specialClampedPosition)
        {
            float clampedPosition = specialClampedPosition;

            if (positionMode == controller.PositionMode)
                controller.m_Position = clampedPosition;
            else
                switch (positionMode)
                {
                    case CurvyPositionMode.Relative:
                        controller.m_Position = controller.Spline.TFToDistance(clampedPosition, controller.Clamping);
                        break;
                    case CurvyPositionMode.WorldUnits:
                        controller.m_Position = controller.Spline.DistanceToTF(clampedPosition, controller.Clamping);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
        }

        private const string InvalidSegmentErrorMessage = "[Curvy] Controller {0} reached segment {1} which is invalid segment because it has a length of 0. Please fix the invalid segment to avoid issues with the controller";

        /// <summary>
        /// Updates position and direction while triggering events when reaching a control point
        /// </summary>
        /// <param name="distance"></param>
        /// <param name="positionMode">The position mode used in the computations. Could be different than SplineController.PositionMode</param>
        private void EventAwareMove(float distance)
        {
#if CURVY_SANITY_CHECKS
            MoveModeEnum moveModeAtMethodStart = MoveMode;
            Assert.IsTrue(distance > 0);
#endif
            CurvyPositionMode movementRelatedPositionMode;
            switch (MoveMode)
            {
                case MoveModeEnum.AbsolutePrecise:
                    movementRelatedPositionMode = CurvyPositionMode.WorldUnits;
                    break;
                case MoveModeEnum.Relative:
                    movementRelatedPositionMode = CurvyPositionMode.Relative;
                    break;
                default:
                    throw new NotSupportedException();
            }

            float currentDelta = distance;

            bool cancelMovement = false;

            //Handle when controller starts at special position
            switch (MovementDirection)
            {
                case MovementDirection.Backward:
                    if (m_Position == 0)
                        if (Clamping == CurvyClamping.PingPong)
                            MovementDirection = MovementDirection.GetOpposite();
                        else if (Clamping == CurvyClamping.Clamp)
                            return;
                    break;
                case MovementDirection.Forward:
                    float upperLimit;
                    {
                        switch (PositionMode)
                        {
                            case CurvyPositionMode.Relative:
                                upperLimit = 1f;
                                break;
                            case CurvyPositionMode.WorldUnits:
                                upperLimit = m_Spline.Length;
                                break;
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                    if (m_Position == upperLimit)
                        if (Clamping == CurvyClamping.PingPong)
                            MovementDirection = MovementDirection.GetOpposite();
                        else if (Clamping == CurvyClamping.Clamp)
                            return;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            CurvySplineSegment currentCp;
            bool isOnCp;
            float movementCompatibleCurrentPosition;
            movementCompatibleCurrentPosition = MovementCompatibleGetPosition(this, m_Position, movementRelatedPositionMode, out currentCp, out isOnCp);

            if (currentCp.Length == 0 && Spline.IsControlPointASegment(currentCp))
                DTLog.LogWarning(String.Format(InvalidSegmentErrorMessage, this.name, currentCp), this);

            int infiniteLoopSafety = 10000;
            while (!cancelMovement && currentDelta > 0 && infiniteLoopSafety-- > 0)
            {

#if CURVY_SANITY_CHECKS
                Assert.IsTrue(Spline.Count > 0);
                Assert.IsTrue(moveModeAtMethodStart == MoveMode);// MoveMode is not allowed to be modified while moving a Spline Controller;
#endif
                CurvySplineSegment candidateControlPoint;
                {
                    if (MovementDirection == MovementDirection.Forward)
                        candidateControlPoint = Spline.GetNextControlPoint(currentCp);
                    else
                        candidateControlPoint = isOnCp
                            ? Spline.GetPreviousControlPoint(currentCp)
                            : currentCp;
                }

                if (ReferenceEquals(candidateControlPoint, null) == false && Spline.IsControlPointVisible(candidateControlPoint))
                {
                    float candidateControlPointPosition;
                    {
                        candidateControlPointPosition = GetControlPointPosition(candidateControlPoint, movementRelatedPositionMode);
                        //handles first cp of closed spline having two values: 0 and max value
                        if (MovementDirection == MovementDirection.Forward && m_Spline.Closed && candidateControlPointPosition == 0)
                            candidateControlPointPosition = GetMaxPosition(movementRelatedPositionMode);
                    }

                    float distanceToCandidate = Mathf.Abs(candidateControlPointPosition - movementCompatibleCurrentPosition);

                    float postEventsEndPosition;

                    if (distanceToCandidate > currentDelta)//If no more control point to reach, move the controller and exit
                    {
                        float movementCompatibleNewPosition_Unclamped = movementCompatibleCurrentPosition + currentDelta * MovementDirection.ToInt();

                        float movementCompatibleNewPosition_Clamped = GetClampedPosition(movementCompatibleNewPosition_Unclamped, movementRelatedPositionMode, Clamping, m_Spline.Length);

                        HandleOnPositionReachedEvents(movementRelatedPositionMode,
                            movementCompatibleCurrentPosition,
                            movementCompatibleNewPosition_Clamped,
                            movementCompatibleNewPosition_Unclamped,
                            out postEventsEndPosition,
                            currentDelta,
                            currentCp,
                            ref cancelMovement);

                        MovementCompatibleSetPosition(this, movementRelatedPositionMode, postEventsEndPosition);

                        break;
                    }

                    HandleOnPositionReachedEvents(movementRelatedPositionMode,
                        movementCompatibleCurrentPosition,
                        candidateControlPointPosition,
                        candidateControlPointPosition,
                        out postEventsEndPosition,
                        currentDelta,
                        currentCp,
                        ref cancelMovement);

                    if (postEventsEndPosition.Approximately(candidateControlPointPosition) == false)
                    {
                        DTLog.LogWarning($"[Curvy] Spline Controller {name}: Position was modified in an {nameof(OnPositionReachedList)} event handler. That modification will be ignored to prioritize the controller reaching a new control point. You can use the {nameof(OnControlPointReached)} event or {(nameof(OnEndReached))} instead. If this behavior is problematic, please contact the developers.", this);
                    }

                    currentDelta -= distanceToCandidate;

                    //Move to next control point
                    HandleReachingNewControlPoint(candidateControlPoint, candidateControlPointPosition, movementRelatedPositionMode, currentDelta, ref cancelMovement, out currentCp, out isOnCp, out movementCompatibleCurrentPosition);
                }

                //handle connection
                {
                    if (isOnCp && currentCp.Connection && currentCp.Connection.ControlPointsList.Count > 1)
                    {
                        MovementDirection newDirection;
                        CurvySplineSegment postConnectionHandlingControlPoint;
                        switch (ConnectionBehavior)
                        {
                            case SplineControllerConnectionBehavior.CurrentSpline:
                                postConnectionHandlingControlPoint = currentCp;
                                newDirection = MovementDirection;
                                break;
                            case SplineControllerConnectionBehavior.FollowUpSpline:
                                postConnectionHandlingControlPoint = HandleFollowUpConnectionBehavior(currentCp, MovementDirection, out newDirection);
                                break;
                            case SplineControllerConnectionBehavior.FollowUpOtherwiseRandom:
                                postConnectionHandlingControlPoint = currentCp.FollowUp
                                    ? HandleFollowUpConnectionBehavior(currentCp, MovementDirection, out newDirection)
                                    : HandleRandomConnectionBehavior(currentCp, MovementDirection, out newDirection, currentCp.Connection.ControlPointsList);
                                break;
                            case SplineControllerConnectionBehavior.RandomSpline:
                                postConnectionHandlingControlPoint = HandleRandomConnectionBehavior(currentCp, MovementDirection, out newDirection, currentCp.Connection.ControlPointsList);
                                break;
                            case SplineControllerConnectionBehavior.Custom:
                                if (ConnectionCustomSelector == null)
                                {
                                    DTLog.LogError("[Curvy] You need to set a non null ConnectionCustomSelector when using SplineControllerConnectionBehavior.Custom", this);
                                    postConnectionHandlingControlPoint = currentCp;
                                }
                                else
                                    postConnectionHandlingControlPoint = ConnectionCustomSelector.SelectConnectedControlPoint(this, currentCp.Connection, currentCp);
                                newDirection = MovementDirection;
                                break;
                            default:
                                throw new ArgumentOutOfRangeException();
                        }

                        if (ReferenceEquals(postConnectionHandlingControlPoint, currentCp) == false)
                        {
                            MovementDirection = newDirection;
                            float postConnectionHandlingControlPointPosition = GetControlPointPosition(postConnectionHandlingControlPoint, movementRelatedPositionMode);
                            HandleReachingNewControlPoint(postConnectionHandlingControlPoint, postConnectionHandlingControlPointPosition, movementRelatedPositionMode, currentDelta, ref cancelMovement, out currentCp, out isOnCp, out movementCompatibleCurrentPosition);
                        }
                    }
                }

                //handle clamping
                {
                    if (isOnCp)
                    {
                        switch (Clamping)
                        {
                            case CurvyClamping.Loop:
                                if (Spline.Closed == false)
                                {
                                    CurvySplineSegment newControlPoint;
                                    if (MovementDirection == MovementDirection.Backward && ReferenceEquals(currentCp, Spline.FirstVisibleControlPoint))
                                        newControlPoint = Spline.LastVisibleControlPoint;
                                    else if (MovementDirection == MovementDirection.Forward && ReferenceEquals(currentCp, Spline.LastVisibleControlPoint))
                                        newControlPoint = Spline.FirstVisibleControlPoint;
                                    else
                                        newControlPoint = null;

                                    if (ReferenceEquals(newControlPoint, null) == false)
                                    {
                                        float newControlPointPosition = GetControlPointPosition(newControlPoint, movementRelatedPositionMode);
                                        HandleReachingNewControlPoint(newControlPoint, newControlPointPosition, movementRelatedPositionMode, currentDelta, ref cancelMovement, out currentCp, out isOnCp, out movementCompatibleCurrentPosition);
                                    }
                                }
                                break;
                            case CurvyClamping.Clamp:
                                if ((MovementDirection == MovementDirection.Backward && ReferenceEquals(currentCp, Spline.FirstVisibleControlPoint)) ||
                                    (MovementDirection == MovementDirection.Forward && ReferenceEquals(currentCp, Spline.LastVisibleControlPoint)))
                                    currentDelta = 0;
                                break;
                            case CurvyClamping.PingPong:
                                if ((MovementDirection == MovementDirection.Backward && ReferenceEquals(currentCp, Spline.FirstVisibleControlPoint)) ||
                                    (MovementDirection == MovementDirection.Forward && ReferenceEquals(currentCp, Spline.LastVisibleControlPoint)))
                                    MovementDirection = MovementDirection.GetOpposite();
                                break;
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                }
            }

            if (infiniteLoopSafety <= 0)
                DTLog.LogError(String.Format("[Curvy] Unexpected behavior in Spline Controller '{0}'. Please raise a Bug Report.", name), this);

        }

        /// <summary>
        /// Triggers relevant OnPositionReached events if any.
        /// </summary>
        private void HandleOnPositionReachedEvents(
            CurvyPositionMode positionMode,
            float startPosition,
            float endPosition,
            float endPositionUnclamped,
            out float postEventsEndPosition,
            float currentDelta,
            CurvySplineSegment currentCp,
            ref bool cancelMovement)
        {

#if CURVY_SANITY_CHECKS
            switch (MovementDirection)
            {
                case MovementDirection.Forward:
                    Assert.IsTrue(startPosition <= endPositionUnclamped);
                    break;
                case MovementDirection.Backward:
                    Assert.IsTrue(startPosition > endPositionUnclamped);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
#endif

            float? nullablePostEventsEndPosition = null;
            foreach (OnPositionReachedSettings eventSettings in OnPositionReachedList)
            {
                nullablePostEventsEndPosition = HandleOnPositionReachedEvent(positionMode, startPosition, endPositionUnclamped, currentDelta, currentCp, ref cancelMovement, eventSettings, nullablePostEventsEndPosition);

                if (Spline.Closed)
                {
                    //handles first cp of closed spline having two values: 0 and max value. In the controller logic, that point has a value of max value when going forward, and 0 when going backwards. To handle this, we create two events, one for each value of the ambiguous point 

                    OnPositionReachedSettings extraEventSettings;
                    if (MovementDirection == MovementDirection.Forward 
                        && eventSettings.Position == 0)
                    {
                        extraEventSettings = eventSettings.Clone();
                        extraEventSettings.Position = GetMaxPosition(eventSettings.PositionMode);
                    }
                    else if (MovementDirection == MovementDirection.Backward 
                             && Mathf.Approximately(eventSettings.Position ,GetMaxPosition(eventSettings.PositionMode)))
                    {
                        extraEventSettings = eventSettings.Clone();
                        extraEventSettings.Position = 0;
                    }
                    else
                    {
                        extraEventSettings = null;
                    }

                    if (extraEventSettings != null)
                        nullablePostEventsEndPosition = HandleOnPositionReachedEvent(positionMode, startPosition, endPositionUnclamped, currentDelta, currentCp, ref cancelMovement, extraEventSettings, nullablePostEventsEndPosition);
                }
            }

           
            postEventsEndPosition = nullablePostEventsEndPosition ?? endPosition;
        }

        private float? HandleOnPositionReachedEvent(
            CurvyPositionMode positionMode,
            float startPosition,
            float endPositionUnclamped,
            float currentDelta,
            CurvySplineSegment currentCp,
            ref bool cancelMovement,
            OnPositionReachedSettings settings,
            float? postEventEndPosition)
        {
            //Debug.Log($"{customEvent.PositionMode} : {startPosition} {endPosition}");

            float eventPosition;
            {
                if (positionMode == settings.PositionMode)
                    eventPosition = settings.Position;
                else
                    switch (positionMode)
                    {
                        case CurvyPositionMode.Relative:
                            eventPosition = Spline.DistanceToTF(settings.Position);
                            break;
                        case CurvyPositionMode.WorldUnits:
                            eventPosition = Spline.TFToDistance(settings.Position);
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(nameof(positionMode), positionMode, null);
                    }
            }

            TriggeringDirections triggeringDirections = settings.TriggeringDirections;

            bool isForwardEventTriggered =
                (triggeringDirections == TriggeringDirections.All ||
                 triggeringDirections == TriggeringDirections.Forward) &&
                startPosition < eventPosition &&
                eventPosition <= endPositionUnclamped;
            bool isBackwardEventTriggered =
                (triggeringDirections == TriggeringDirections.All ||
                 triggeringDirections == TriggeringDirections.Backward) &&
                endPositionUnclamped <= eventPosition &&
                eventPosition < startPosition;

            if (isForwardEventTriggered || isBackwardEventTriggered)
            {
                float delta = Math.Abs(eventPosition - startPosition);

                //every custom event triggering will modify the controller's position to the event's position. This will override any possible position modification by a prior event handler
                MovementCompatibleSetPosition(this, settings.PositionMode, eventPosition);

                preAllocatedEventArgs.Set_INTERNAL(this,
                    Spline,
                    currentCp,
                    eventPosition,
                    currentDelta - delta,
                    MovementDirection,
                    settings.PositionMode == CurvyPositionMode.WorldUnits);

                InvokeEventHandler(settings.Event, preAllocatedEventArgs, positionMode, out _, out _, out postEventEndPosition);

                cancelMovement |= preAllocatedEventArgs.Cancel;
            }

            return postEventEndPosition;
        }

        /// <summary>
        /// Do operations necessary when controller reaches a new control point: setting the controller position, update its spline if necessary, and send events if necessary
        /// </summary>
        private void HandleReachingNewControlPoint(CurvySplineSegment controlPoint,
            float controlPointPosition,
            CurvyPositionMode positionMode,
            float currentDelta,
            ref bool cancelMovement,
            out CurvySplineSegment postEventsControlPoint,
            out bool postEventsIsControllerOnControlPoint,
            out float postEventsControlPointPosition)
        {
            //update state
            MovementCompatibleSetPosition(this, positionMode, controlPointPosition);
            Spline = controlPoint.Spline;
            postEventsControlPoint = controlPoint;
            postEventsIsControllerOnControlPoint = true;
            postEventsControlPointPosition = controlPointPosition;

            //handle invalid situation
            if (controlPoint.Length == 0 && Spline.IsControlPointASegment(controlPoint))
                DTLog.LogWarning(String.Format(InvalidSegmentErrorMessage, this.name, controlPoint), this);


            //setup event param
            preAllocatedEventArgs.Set_INTERNAL(this, Spline, controlPoint, controlPointPosition, currentDelta, MovementDirection, positionMode == CurvyPositionMode.WorldUnits);

            //handle OnControlPointReached
            InvokeEventHandler(OnControlPointReached, preAllocatedEventArgs, positionMode, ref postEventsControlPoint, ref postEventsIsControllerOnControlPoint, ref postEventsControlPointPosition);

            //handle OnEndReached
            if (ReferenceEquals(preAllocatedEventArgs.Spline.FirstVisibleControlPoint, preAllocatedEventArgs.ControlPoint)
                || ReferenceEquals(preAllocatedEventArgs.Spline.LastVisibleControlPoint, preAllocatedEventArgs.ControlPoint))
                InvokeEventHandler(OnEndReached, preAllocatedEventArgs, positionMode, ref postEventsControlPoint, ref postEventsIsControllerOnControlPoint, ref postEventsControlPointPosition);

            cancelMovement |= preAllocatedEventArgs.Cancel;
        }

        private void InvokeEventHandler(CurvySplineMoveEvent @event,
            CurvySplineMoveEventArgs eventArgument,
            CurvyPositionMode positionMode,
            ref CurvySplineSegment postEventsControlPoint,
            ref bool postEventsIsControllerOnControlPoint,
            ref float postEventPosition)
        {
            InvokeEventHandler(@event,
                eventArgument,
                positionMode,
                out CurvySplineSegment outControlPoint,
                out bool? outIsControllerOnControlPoint,
                out float? outPosition);

            if (outPosition != null)
                postEventPosition = outPosition.Value;
            if (outIsControllerOnControlPoint != null)
                postEventsIsControllerOnControlPoint = outIsControllerOnControlPoint.Value;
            if (outControlPoint != null)
                postEventsControlPoint = outControlPoint;

        }

        private void InvokeEventHandler(CurvySplineMoveEvent @event,
            CurvySplineMoveEventArgs eventArgument,
            CurvyPositionMode positionMode,
            out CurvySplineSegment postEventsControlPoint,
            out bool? postEventsIsControllerOnControlPoint,
            out float? postEventPosition)
        {
            //save some data before calling events to know if event handlers changed important state
            float preEventPosition = m_Position;
            CurvyPositionMode preEventPositionMode = PositionMode;
            CurvySpline preEventPositionSpline = m_Spline;
            //call event handler
            @event.Invoke(eventArgument);
            //update state if event handler changed important things
            if (m_Position != preEventPosition || PositionMode != preEventPositionMode || ReferenceEquals(m_Spline, preEventPositionSpline) == false)
            {
                postEventPosition = MovementCompatibleGetPosition(this, m_Position, positionMode, out postEventsControlPoint, out bool outIsOnCP);
                postEventsIsControllerOnControlPoint = outIsOnCP;
            }
            else
            {
                postEventsControlPoint = null;
                postEventsIsControllerOnControlPoint = null;
                postEventPosition = null;
            }
        }

        /// <summary>
        /// Get the correct control point and direction from applying the Random connection handling logic
        /// </summary>
        private CurvySplineSegment HandleRandomConnectionBehavior(CurvySplineSegment currentControlPoint, MovementDirection currentDirection, out MovementDirection newDirection, ReadOnlyCollection<CurvySplineSegment> connectedControlPoints)
        {
            //OPTIM avoid allocation
            List<CurvySplineSegment> validConnectedControlPoints = new List<CurvySplineSegment>(connectedControlPoints.Count);

            for (int index = 0; index < connectedControlPoints.Count; index++)
            {
                CurvySplineSegment controlPoint = connectedControlPoints[index];
                if (RejectCurrentSpline && controlPoint == currentControlPoint)
                    continue;

                if (RejectTooDivergentSplines)
                {
                    if (GetAngleBetweenConnectedSplines(currentControlPoint, currentDirection, controlPoint, AllowDirectionChange) > MaxAllowedDivergenceAngle)
                        continue;
                }

                validConnectedControlPoints.Add(controlPoint);
            }

            CurvySplineSegment newControlPoint = validConnectedControlPoints.Count == 0 ?
                currentControlPoint :
                validConnectedControlPoints[Random.Range(0, validConnectedControlPoints.Count)];

            newDirection = GetPostConnectionDirection(newControlPoint, currentDirection, AllowDirectionChange);

            return newControlPoint;
        }

        /// <summary>
        /// Get the direction the controller should have if moving through a specific connected Control Point
        /// </summary>
        private static MovementDirection GetPostConnectionDirection(CurvySplineSegment connectedControlPoint, MovementDirection currentDirection, bool directionChangeAllowed)
        {
            return directionChangeAllowed && connectedControlPoint.Spline.Closed == false
                ? HeadingToDirection(ConnectionHeadingEnum.Auto, connectedControlPoint, currentDirection)
                : currentDirection;
        }

        /// <summary>
        /// Get the correct control point and direction from applying the FollowUp connection handling logic
        /// </summary>
        private CurvySplineSegment HandleFollowUpConnectionBehavior(CurvySplineSegment currentControlPoint, MovementDirection currentDirection, out MovementDirection newDirection)
        {
            CurvySplineSegment newControlPoint = currentControlPoint.FollowUp
                ? currentControlPoint.FollowUp
                : currentControlPoint;

            newDirection = AllowDirectionChange && currentControlPoint.FollowUp
                ? HeadingToDirection(currentControlPoint.FollowUpHeading, currentControlPoint.FollowUp, currentDirection)
                : currentDirection;

            return newControlPoint;
        }

        /// <summary>
        /// Translates a heading value to a controller direction, based on the current control point situation
        /// </summary>
        static private MovementDirection HeadingToDirection(ConnectionHeadingEnum heading, CurvySplineSegment controlPoint, MovementDirection currentDirection)
        {
            MovementDirection newDirection;
            ConnectionHeadingEnum resolveHeading = heading.ResolveAuto(controlPoint);

            switch (resolveHeading)
            {
                case ConnectionHeadingEnum.Minus:
                    newDirection = MovementDirection.Backward;
                    break;
                case ConnectionHeadingEnum.Sharp:
                    newDirection = currentDirection;
                    break;
                case ConnectionHeadingEnum.Plus:
                    newDirection = MovementDirection.Forward;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            return newDirection;
        }


        /// <summary>
        /// Get the controller position corresponding to a specific control point
        /// </summary>
        private static float GetControlPointPosition(CurvySplineSegment controlPoint, CurvyPositionMode positionMode)
        {
            float position;
            switch (positionMode)
            {
                case CurvyPositionMode.Relative:
                    position = controlPoint.TF;
                    break;
                case CurvyPositionMode.WorldUnits:
                    position = controlPoint.Distance;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            return position;
        }

        /// <summary>
        /// Used as a field condition
        /// </summary>
        private bool ShowRandomConnectionOptions { get { return ConnectionBehavior == SplineControllerConnectionBehavior.FollowUpOtherwiseRandom || ConnectionBehavior == SplineControllerConnectionBehavior.RandomSpline; } }

        /*! \endcond */

        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/SplineController.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/TargetComponent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 39383bb6a7d43ce4591337c8a3c75e7b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// Defines what is the component controlled by the controller
    /// </summary>
    public enum TargetComponent
    {
        /// <summary>
        /// A transform
        /// </summary>
        Transform,
        /// <summary>
        /// A Rigidbody that is set to be kinematic
        /// </summary>
        KinematicRigidbody,
        /// <summary>
        /// A Rigidbody2D that is set to be kinematic
        /// </summary>
        KinematicRigidbody2D
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/TargetComponent.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/UITextSplineController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f3ff25939a248e146b6f134422bd0a55
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using UnityEngine.UI;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Pools;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// SplineController modifying uGUI text
    /// </summary>
    [RequireComponent(typeof(Text))]
    [AddComponentMenu("Curvy/Controllers/UI Text Spline Controller")]
    [HelpURL(CurvySpline.DOCLINK + "uitextsplinecontroller")]
    public class UITextSplineController : SplineController, IMeshModifier
    {
        protected interface IGlyph
        {
            Vector3 Center { get; }
            void Transpose(Vector3 v);
            void Rotate(Quaternion rotation);
        }

        protected class GlyphQuad : IGlyph
        {
            public UIVertex[] V = new UIVertex[4];
            public Rect Rect;
            public Vector3 Center { get { return Rect.center; } }

            public void Load(List<UIVertex> verts, int index)
            {
                V[0] = verts[index];
                V[1] = verts[index + 1];
                V[2] = verts[index + 2];
                V[3] = verts[index + 3];

                calcRect();
            }

            public void LoadTris(List<UIVertex> verts, int index)
            {
                V[0] = verts[index];
                V[1] = verts[index + 1];
                V[2] = verts[index + 2];
                V[3] = verts[index + 4];
                calcRect();
            }

            public void calcRect()
            {
                Rect = new Rect(V[0].position.x,
                              V[2].position.y,
                              V[2].position.x - V[0].position.x,
                              V[0].position.y - V[2].position.y);
            }

            public void Save(List<UIVertex> verts, int index)
            {
                verts[index] = V[0];
                verts[index + 1] = V[1];
                verts[index + 2] = V[2];
                verts[index + 3] = V[3];
            }

            public void Save(VertexHelper vh)
            {
                vh.AddUIVertexQuad(V);
            }

            public void Transpose(Vector3 v)
            {
                for (int i = 0; i < 4; i++)
                    V[i].position += v;

            }

            public void Rotate(Quaternion rotation)
            {
                for (int i = 0; i < 4; i++)
                    V[i].position = V[i].position.RotateAround(Center, rotation);
            }

        }

        protected class GlyphPlain : IGlyph
        {
            public Vector3[] V = new Vector3[4];
            public Rect Rect;
            public Vector3 Center { get { return Rect.center; } }

            public void Load(ref Vector3[] verts, int index)
            {
                V[0] = verts[index];
                V[1] = verts[index + 1];
                V[2] = verts[index + 2];
                V[3] = verts[index + 3];

                calcRect();
            }

            public void calcRect()
            {
                Rect = new Rect(V[0].x,
                              V[2].y,
                              V[2].x - V[0].x,
                              V[0].y - V[2].y);
            }

            public void Save(ref Vector3[] verts, int index)
            {
                verts[index] = V[0];
                verts[index + 1] = V[1];
                verts[index + 2] = V[2];
                verts[index + 3] = V[3];
            }

            public void Transpose(Vector3 v)
            {
                for (int i = 0; i < 4; i++)
                    V[i] += v;

            }

            public void Rotate(Quaternion rotation)
            {
                for (int i = 0; i < 4; i++)
                    V[i] = V[i].RotateAround(Center, rotation);
            }

        }

        #region ### Serialized Fields ###

        [Section("Orientation")]
        [Tooltip("If true, the text characters will keep the same orientation regardless of the spline they follow")]
        [SerializeField]
        private bool staticOrientation;

        #endregion

        #region Public properties

        /// <summary>
        /// If true, the text characters will keep the same orientation regardless of the spline they follow
        /// </summary>
        public bool StaticOrientation
        {
            get { return staticOrientation; }
            set
            {
                staticOrientation = value;
            }
        }

        #endregion


        #region Conditional display in the inspector of CurvyController properties

        protected override bool ShowOrientationSection
        {
            get { return false; }
        }
        protected override bool ShowOffsetSection
        {
            get { return false; }
        }

        #endregion

        private Graphic m_Graphic;
        private RectTransform mRect;
        private Text mText;



        protected Text Text
        {
            get
            {
                if (mText == null)
                    mText = GetComponent<Text>();
                return mText;
            }
        }

        protected RectTransform Rect
        {
            get
            {
                if (mRect == null)
                    mRect = GetComponent<RectTransform>();
                return mRect;
            }
        }

        protected Graphic graphic
        {
            get
            {
                if (m_Graphic == null)
                    m_Graphic = GetComponent<Graphic>();

                return m_Graphic;
            }
        }

        protected override void InitializedApplyDeltaTime(float deltaTime)
        {
            base.InitializedApplyDeltaTime(deltaTime);
            graphic.SetVerticesDirty();
        }

        public void ModifyMesh(Mesh verts)
        {
            if (enabled && gameObject.activeInHierarchy && isInitialized)
            {
                Vector3[] vtArray = verts.vertices;
                GlyphPlain glyph = new GlyphPlain();
                for (int c = 0; c < Text.text.Length; c++)
                {
                    glyph.Load(ref vtArray, c * 4);
                    UpdateGlyph(glyph);
                    glyph.Save(ref vtArray, c * 4);
                }
                verts.vertices = vtArray;
                ArrayPools.Vector3.Free(vtArray);
            }
        }


        public void ModifyMesh(VertexHelper vertexHelper)
        {
            if (enabled && gameObject.activeInHierarchy && isInitialized)
            {
                List<UIVertex> verts = new List<UIVertex>();
                GlyphQuad glyph = new GlyphQuad();

                vertexHelper.GetUIVertexStream(verts);
                vertexHelper.Clear();

                int readingIndex = 0;
                for (int letterIndex = 0; letterIndex < Text.text.Length; letterIndex++)
                {
                    if (Text.text[letterIndex] == ' ')
                        continue;

                    glyph.LoadTris(verts, readingIndex * 6);
                    readingIndex++;
                    UpdateGlyph(glyph);
                    glyph.Save(vertexHelper);
                }
            }
        }

        private void UpdateGlyph(IGlyph glyph)
        {
            //OPTIM use InterpolateAndGetTangent
            float glyphTf = AbsoluteToRelative(GetClampedPosition(AbsolutePosition + glyph.Center.x, CurvyPositionMode.WorldUnits, Clamping, Length));

            // shift to match baseline
            glyph.Transpose(new Vector3(0, glyph.Center.y, 0));

            // Rotate
            if (StaticOrientation == false)
            {
                Vector3 glyphTangent = GetTangent(glyphTf);
                glyph.Rotate(Quaternion.AngleAxis(Mathf.Atan2(glyphTangent.x, -glyphTangent.y) * Mathf.Rad2Deg - 90, Vector3.forward));
            }

            // Center on controller's position
            glyph.Transpose(-glyph.Center);

            // Move on the corresponding position on the spline
            float controllerTf = AbsoluteToRelative(GetClampedPosition(AbsolutePosition, CurvyPositionMode.WorldUnits, Clamping, Length));
            Vector3 controllerPosition = (UseCache)
                ? Spline.InterpolateFast(controllerTf)
                : Spline.Interpolate(controllerTf);
            Vector3 glyphPosition = (UseCache)
                ? Spline.InterpolateFast(glyphTf)
                : Spline.Interpolate(glyphTf);
            glyph.Transpose(Spline.transform.TransformDirection(glyphPosition - controllerPosition));
        }

        #region ### Unity Callbacks ###

        protected override void OnEnable()
        {
            base.OnEnable();
            if (this.graphic != null)
            {
                this.graphic.SetVerticesDirty();
            }
        }

        protected override void OnDisable()
        {
            base.OnDisable();
            if (this.graphic != null)
            {
                this.graphic.SetVerticesDirty();
            }
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            if (isInitialized)
            {
                UnbindSplineRelatedEvents();
                BindSplineRelatedEvents();
            }
            base.OnValidate();
            if (this.graphic != null)
            {
                this.graphic.SetVerticesDirty();
            }
        }
#endif

        #endregion

        #region Spline refreshing


        public override CurvySpline Spline
        {
            get { return m_Spline; }
            set
            {
                if (m_Spline != value)
                {
                    if (isInitialized)
                        UnbindSplineRelatedEvents();

                    m_Spline = value;
                    if (isInitialized)
                        BindSplineRelatedEvents();
                }
            }
        }

        protected override void BindEvents()
        {
            base.BindEvents();
            BindSplineRelatedEvents();
        }

        protected override void UnbindEvents()
        {
            base.UnbindEvents();
            UnbindSplineRelatedEvents();
        }

        private void BindSplineRelatedEvents()
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(isInitialized);
#endif
            if (Spline)
            {
                UnbindSplineRelatedEvents();
                Spline.OnRefresh.AddListener(OnSplineRefreshed);
            }
        }

        private void UnbindSplineRelatedEvents()
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(isInitialized);
#endif
            if (Spline)
            {
                Spline.OnRefresh.RemoveListener(OnSplineRefreshed);
            }
        }

        private void OnSplineRefreshed(CurvySplineEventArgs e)
        {
            CurvySpline senderSpline = e.Sender as CurvySpline;
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(senderSpline != null);
#endif
            if (senderSpline != Spline)
                senderSpline.OnRefresh.RemoveListener(OnSplineRefreshed);
            else
            {
                graphic.SetVerticesDirty();
            }
        }

        #endregion


    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/UITextSplineController.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/VolumeController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 978716ea84cf827468383a8fad80663e
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools;
using FluffyUnderware.Curvy.Utils;
using UnityEngine.Assertions;
using UnityEngine.Serialization;


namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// Controller using a Curvy Generator Volume
    /// </summary>
    [AddComponentMenu("Curvy/Controllers/CG Volume Controller")]
    [HelpURL(CurvySpline.DOCLINK + "volumecontroller")]
    public class VolumeController : CurvyController
    {
        private const float CrossPositionRangeMin = -0.5f;
        private const float CrossPositionRangeMax = 0.5f;

        #region ### Serialized Fields ###

        [Section("General")]
        [CGDataReferenceSelector(typeof(CGVolume), Label = "Volume/Slot")]
        [SerializeField]
        private CGDataReference m_Volume = new CGDataReference();

        [Section("Cross Position", Sort = 1, HelpURL = CurvySpline.DOCLINK + "volumecontroller_crossposition")]
        [SerializeField]
        [FloatRegion(UseSlider = true, Precision = 4, RegionOptionsPropertyName = nameof(CrossRangeOptions), Options = AttributeOptionsFlags.Full)]
        private FloatRegion m_CrossRange = new FloatRegion(CrossPositionRangeMin, CrossPositionRangeMax);

        [RangeEx(nameof(MinCrossRelativePosition), nameof(MaxCrossRelativePosition))]
        [SerializeField]
        private float crossRelativePosition;

        [SerializeField] private CurvyClamping m_CrossClamping;

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Gets or sets the volume to use
        /// </summary>
        public CGDataReference Volume
        {
            get { return m_Volume; }
            set { m_Volume = value; }
        }

        /// <summary>
        /// Gets the actual volume data
        /// </summary>
        public CGVolume VolumeData
        {
            get
            {
                return (Volume.HasValue) ? Volume.GetData<CGVolume>() : null;
            }
        }

        public float CrossFrom
        {
            get { return m_CrossRange.From; }
            set { m_CrossRange.From = Mathf.Clamp(value, CrossPositionRangeMin, CrossPositionRangeMax); }
        }

        public float CrossTo
        {
            get { return m_CrossRange.To; }
            set { m_CrossRange.To = Mathf.Clamp(value, CrossFrom, CrossPositionRangeMax); }
        }

        public float CrossLength
        {
            get { return m_CrossRange.Length; }
        }


        /// <summary>
        /// Gets or sets the clamping mode for lateral movement
        /// </summary>
        public CurvyClamping CrossClamping
        {
            get { return m_CrossClamping; }
            set
            {
                m_CrossClamping = value;
            }
        }

        /// <summary>
        /// Gets or sets the current relative lateral position, respecting clamping. Ranges from <see cref="CrossFrom"/> to <see cref="CrossTo"/>
        /// </summary>
        public float CrossRelativePosition
        {
            get { return GetClampedCrossPosition(crossRelativePosition); }
            set { crossRelativePosition = GetClampedCrossPosition(value); }
        }

        /// <summary>
        /// Gets the source's length
        /// </summary>
        public override float Length
        {
            get
            {
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
                return (VolumeData != null) ? VolumeData.Length : 0;
            }
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Converts relative lateral to absolute position, respecting clamping, ignoring CrossRange
        /// </summary>
        /// <param name="relativeDistance">the relative position</param>
        /// <returns>the absolute position</returns>
        public float CrossRelativeToAbsolute(float relativeDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return (VolumeData != null) ? VolumeData.CrossFToDistance(RelativePosition, relativeDistance, CrossClamping) : 0;
        }

        /// <summary>
        /// Converts absolute lateral to relative position, respecting clamping, ignoring CrossRange
        /// </summary>
        /// <param name="worldUnitDistance">the absolute position</param>
        /// <returns>the relative position</returns>
        public float CrossAbsoluteToRelative(float worldUnitDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return (VolumeData != null) ? VolumeData.CrossDistanceToF(RelativePosition, worldUnitDistance, CrossClamping) : 0;
        }

        #endregion

        #region ### Protected Methods ###

        override public bool IsReady
        {
            get
            {
                return Volume != null && !Volume.IsEmpty && Volume.HasValue;
            }
        }

        /// <summary>
        /// Converts distance on source from relative to absolute position.
        /// </summary>
        /// <param name="relativeDistance">relative distance from the source start. Should be already clamped</param>
        /// <returns>distance in world units from the source start</returns>
        protected override float RelativeToAbsolute(float relativeDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
            Assert.IsTrue(CurvyUtility.Approximately(relativeDistance, GetClampedPosition(relativeDistance, CurvyPositionMode.Relative, Clamping, Length)));
#endif
            return (VolumeData != null) ? VolumeData.FToDistance(relativeDistance) : 0;
        }

        /// <summary>
        /// Converts distance on source from absolute to relative position.
        /// </summary>
        /// <param name="worldUnitDistance">distance in world units from the source start. Should be already clamped</param>
        /// <returns>relative distance in the range 0..1</returns>
        protected override float AbsoluteToRelative(float worldUnitDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
            Assert.IsTrue(CurvyUtility.Approximately(worldUnitDistance, GetClampedPosition(worldUnitDistance, CurvyPositionMode.WorldUnits, Clamping, Length)));
#endif
            return (VolumeData != null) ? VolumeData.DistanceToF(worldUnitDistance) : 0;
        }

        protected override Vector3 GetInterpolatedSourcePosition(float tf)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return Volume.Module.Generator.transform.TransformPoint(VolumeData.InterpolateVolumePosition(tf, CrossRelativePosition));
        }

        protected override void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            VolumeData.InterpolateVolume(tf, CrossRelativePosition, out interpolatedPosition, out tangent, out up);
            Transform generatorTransform = Volume.Module.Generator.transform;
            interpolatedPosition = generatorTransform.TransformPoint(interpolatedPosition);
            tangent = generatorTransform.TransformDirection(tangent);
            up = generatorTransform.TransformDirection(up);
        }


        protected override Vector3 GetTangent(float tf)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return Volume.Module.Generator.transform.TransformDirection(VolumeData.InterpolateVolumeDirection(tf, CrossRelativePosition));
        }


        protected override Vector3 GetOrientation(float tf)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return Volume.Module.Generator.transform.TransformDirection(VolumeData.InterpolateVolumeUp(tf, CrossRelativePosition));
        }

        protected override void Advance(float speed, float deltaTime)
        {
            float tf = RelativePosition;
            MovementDirection direction = MovementDirection;

            SimulateAdvance(ref tf, ref direction, speed, deltaTime);

            MovementDirection = direction;
            RelativePosition = tf;
        }

        override protected void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            int directionInt = curyDirection.ToInt();

            switch (MoveMode)
            {
                case MoveModeEnum.Relative:
                    VolumeData.Move(ref tf, ref directionInt, speed * deltaTime, Clamping);
                    break;
                case MoveModeEnum.AbsolutePrecise:
                    VolumeData.MoveBy(ref tf, ref directionInt, speed * deltaTime, Clamping);
                    break;
                default:
                    throw new NotSupportedException();
            }
            curyDirection = MovementDirectionMethods.FromInt(directionInt);
        }

        #endregion

        #region ### Privates & Internals ###
        /*! \cond PRIVATE */

        private RegionOptions<float> CrossRangeOptions
        {
            get
            {
                return RegionOptions<float>.MinMax(CrossPositionRangeMin, CrossPositionRangeMax);
            }
        }

        private float MinCrossRelativePosition
        {
            get
            {
                return m_CrossRange.From;
            }
        }

        private float MaxCrossRelativePosition
        {
            get
            {
                return m_CrossRange.To;
            }
        }

        private float GetClampedCrossPosition(float position)
        {
            return CurvyUtility.ClampValue(position, CrossClamping, CrossFrom, CrossTo);
        }

        /*! \endcond */
        #endregion

        #region RetroCompatibility code

        [SerializeField, HideInInspector]
        [Obsolete("Use crossRelativePosition instead. This field is kept for retro compatibility reasons")]
        private float m_CrossInitialPosition;

        /*! \cond PRIVATE */
        public override void OnAfterDeserialize()
        {
            base.OnAfterDeserialize();
#pragma warning disable 618
            if (float.IsNaN(m_CrossInitialPosition) == false)
            {
#pragma warning disable 612
                //Converts from the obsolete way of representing cross relative position to the usual one.
                crossRelativePosition = DTMath.MapValue(CrossFrom, CrossTo, m_CrossInitialPosition, CrossPositionRangeMin, CrossPositionRangeMax);
#pragma warning restore 612
                m_CrossInitialPosition = Single.NaN;
            }
#pragma warning restore 618
        }
        /*! \endcond */
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/VolumeController.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/CurvySerializationSpace.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3a81a593ae4669e47b9b277cce50cded
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

namespace FluffyUnderware.Curvy.ImportExport
{
    /// <summary>
    /// Used in the import/export process to define if which coordinates should be read/written, the local ones or the global ones
    /// </summary>
    public enum CurvySerializationSpace
    {
        Global = 0,
        Local = 1
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/CurvySerializationSpace.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/FileFormat.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4a54cc3b2dcf63147bc0b7ba203bdc17
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

namespace FluffyUnderware.Curvy.ImportExport
{
    /// <summary>
    /// Used in the import/export process to define what format to import and/or export to
    /// </summary>
    public enum FileFormat
    {
        JSON = 0,
        SVG = 1
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/FileFormat.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/SplineJsonConverter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f83deb70d027ab1468a94644e80ac33c
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.Curvy.Utils;
using JetBrains.Annotations;
using UnityEngine;


namespace FluffyUnderware.Curvy.ImportExport
{
    /// <summary>
    /// Converts splines to JSON strings, and vice versa
    /// </summary>
    public static class SplineJsonConverter
    {
        /// <summary>
        /// Converts splines to a JSON string
        /// </summary>
        /// <param name="splines">The splines to serialize</param>
        /// <param name="coordinatesSpace">What coordinates of the spline should be serialized: local ones or global ones?</param>
        /// <param name="prettify">Set to true to make the JSON string easy to read. If false, the spline will be compacted to make it small</param>
        public static string SplinesToJson(IEnumerable<CurvySpline> splines, CurvySerializationSpace coordinatesSpace = CurvySerializationSpace.Global, bool prettify = true)
        {
            SerializedCurvySpline[] serializedSplines = splines.Select(s => new SerializedCurvySpline(s, coordinatesSpace)).ToArray();
            return JsonUtility.ToJson(new SerializableArray<SerializedCurvySpline> { Array = serializedSplines }, prettify);
        }

        /// <summary>
        /// Converts a spline to a JSON string
        /// </summary>
        /// <param name="spline">The spline to serialize</param>
        /// <param name="coordinatesSpace">What coordinates of the spline should be serialized: local ones or global ones?</param>
        /// <param name="prettify">Set to true to make the JSON string easy to read. If false, the spline will be compacted to make it small</param>
        public static string SplineToJson(CurvySpline spline, CurvySerializationSpace coordinatesSpace = CurvySerializationSpace.Global, bool prettify = true)
        {
            return SplinesToJson(new[] { spline }, coordinatesSpace, prettify);
        }

        /// <summary>
        /// Converts a JSON string to an array of splines
        /// </summary>
        /// <param name="json">The JSON to deserialize</param>
        /// <param name="coordinatesSpace">How to interpret the coordinates in the JSON: local ones or global ones?</param>
        public static CurvySpline[] JsonToSplines(string json, CurvySerializationSpace coordinatesSpace = CurvySerializationSpace.Global)
        {
            SerializedCurvySpline[] serializedSplines = JsonToSerializedSplines(json);

            CurvySpline[] result = new CurvySpline[serializedSplines.Length];

            for (int index = 0; index < serializedSplines.Length; index++)
            {
                SerializedCurvySpline spline = serializedSplines[index];
                CurvySpline deserializedSpline = result[index] = CurvySpline.Create();
                spline.WriteIntoSpline(deserializedSpline, coordinatesSpace);
            }

            return result;
        }

        /// <summary>
        /// Converts a JSON string to a spline
        /// </summary>
        /// <param name="json">The JSON to deserialize</param>
        /// <param name="coordinatesSpace">How to interpret the coordinates in the JSON: local ones or global ones?</param>
        public static CurvySpline JsonToSpline(string json, CurvySerializationSpace coordinatesSpace = CurvySerializationSpace.Global)
        {
            return JsonToSplines(json, coordinatesSpace).Single();
        }

        /// <summary>
        /// Converts a JSON string to an array of instances of <see cref="SerializedCurvySpline"/>
        /// </summary>
        /// <param name="json">The JSON to deserialize</param>
        public static SerializedCurvySpline[] JsonToSerializedSplines([NotNull] string json)
        {
            if (json == null)
                throw new ArgumentNullException(nameof(json));
            if (string.IsNullOrWhiteSpace(json))
                throw new ArgumentException("Value cannot be null or whitespace.", nameof(json));
            if (string.IsNullOrEmpty(json))
                throw new ArgumentException("Value cannot be null or empty.", nameof(json));
            
            SerializedCurvySpline[] serializedSplines;
            //The following deserializes the JSON text, but instead of doing with a simple and nice one line of code, it is done in a complex way. The reason to that is that JsonUtility doesn't handle default values for JSON fields.
            {
                //First we deserialize the JSON in the sole goal to know how much elements there are in the arrays
                SerializableArray<SerializedCurvySpline> serializableArray = JsonUtility.FromJson<SerializableArray<SerializedCurvySpline>>(json);

                //Knowing the number of array elements, we assign a new instance for each element. By creating the new instances ourselves, through the constructor, we have control on the default value of fields
                for (int index = 0; index < serializableArray.Array.Length; index++)
                {
                    int controlPointsCount = serializableArray.Array[index].ControlPoints.Length;

                    SerializedCurvySpline splineWithCorrectDefaultValue = new SerializedCurvySpline();
                    splineWithCorrectDefaultValue.ControlPoints = new SerializedCurvySplineSegment[controlPointsCount];
                    for (int controlPointIndex = 0; controlPointIndex < controlPointsCount; controlPointIndex++) splineWithCorrectDefaultValue.ControlPoints[controlPointIndex] = new SerializedCurvySplineSegment();

                    serializableArray.Array[index] = splineWithCorrectDefaultValue;
                }

                //Then, through FromJsonOverwrite, we overwrite the fields that are existing in the JSON text
                JsonUtility.FromJsonOverwrite(json, serializableArray);

                serializedSplines = serializableArray.Array;
            }
            
            return serializedSplines;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/SplineJsonConverter.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/SplineSvgConverter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 09e1211c9bcae294fb0787f8ba317d21
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using UnityEngine;
using ToolBuddy.ThirdParty.VectorGraphics;


namespace FluffyUnderware.Curvy.ImportExport
{
    /// <summary>
    /// Converts SVG strings to splines
    /// </summary>
    public static class SplineSvgConverter
    {
        /// <summary>
        /// Converts an SVG string to an array of splines
        /// </summary>
        /// <param name="svg">The SVG to deserialize</param>
        /// <param name="coordinatesSpace">How to interpret the coordinates in the SVG: local ones or global ones?</param>
        public static CurvySpline[] SvgToSplines(string svg, CurvySerializationSpace coordinatesSpace = CurvySerializationSpace.Global)
        {
            List<SerializedCurvySpline> serializedSplines = SvgToSerializedSplines(svg);

            CurvySpline[] result = new CurvySpline[serializedSplines.Count];

            for (int index = 0; index < serializedSplines.Count; index++)
            {
                SerializedCurvySpline spline = serializedSplines[index];
                CurvySpline deserializedSpline = result[index] = CurvySpline.Create();
                spline.WriteIntoSpline(deserializedSpline, coordinatesSpace);
            }

            return result;
        }

        /// <summary>
        /// Converts an SVG string to a spline
        /// </summary>
        /// <param name="svg">The SVG to deserialize</param>
        /// <param name="coordinatesSpace">How to interpret the coordinates in the SVG: local ones or global ones?</param>
        public static CurvySpline SvgToSpline(string svg, CurvySerializationSpace coordinatesSpace = CurvySerializationSpace.Global)
        {
            return SvgToSplines(svg, coordinatesSpace).Single();
        }

        /// <summary>
        /// Converts an SVG string to an array of instances of <see cref="SerializedCurvySpline"/>
        /// </summary>
        /// <param name="svg">The SVG to deserialize</param>
        /// <param name="invertY">Inverts the Y coordinates to match unity's Y axis</param>
        public static List<SerializedCurvySpline> SvgToSerializedSplines([NotNull] string svg, bool invertY = true)
        {
            if (svg == null)
                throw new ArgumentNullException(nameof(svg));
            if (string.IsNullOrWhiteSpace(svg))
                throw new ArgumentException("Value cannot be null or whitespace.", nameof(svg));
            if (string.IsNullOrEmpty(svg))
                throw new ArgumentException("Value cannot be null or empty.", nameof(svg));

            List<SerializedCurvySpline> serializedSplines = new List<SerializedCurvySpline>();

            using (StringReader stringReader = new StringReader(svg))
            {
                SVGParser.SceneInfo sceneInfo = SVGParser.ImportSVG(stringReader);
                DrawNode(sceneInfo.Scene.Root, sceneInfo.Scene.Root.Transform, serializedSplines);
            }

            if (invertY)
                foreach (SerializedCurvySpline spline in serializedSplines)
                {
                    foreach (SerializedCurvySplineSegment controlPoint in spline.ControlPoints)
                    {
                        controlPoint.Position.y *= -1;
                        controlPoint.HandleIn.y *= -1;
                        controlPoint.HandleOut.y *= -1;
                    }
                }

            return serializedSplines;
        }

        private static void DrawNode(SceneNode node, Matrix2D rootTransform, List<SerializedCurvySpline> splines)
        {
            if (node.Clipper != null)
            {
                DTLog.LogWarning("[Curvy] SVG Import: A clipper was encountered. Clippers are not supported.");
            }

            if (node.Shapes != null)
            {
                Matrix2D transform = rootTransform * node.Transform;

                foreach (Shape shape in node.Shapes)
                {
                    foreach (BezierContour bezierContour in shape.Contours)
                    {
                        BezierPathSegment[] segments = bezierContour.Segments;
                        List<SerializedCurvySplineSegment> controlPoints = new List<SerializedCurvySplineSegment>(segments.Length);

                        if (segments.Length == 0)
                            continue;

                        if (segments.Length == 1)
                        {
                            DTLog.LogError("[Curvy] SVG Import: A segments array had only one element. This is unexpected. That contour was ignored. Please raise a bug report.");
                            continue;
                        }

                        SerializedCurvySpline spline = new SerializedCurvySpline();
                        spline.Interpolation = CurvyInterpolation.Bezier;
                        spline.Closed = bezierContour.Closed;
                        spline.Name = $"SVG Spline {splines.Count}";
                        splines.Add(spline);

                        BezierPathSegment firstSegment = segments.First();
                        BezierPathSegment lastSegment = segments.Last();

                        SerializedCurvySplineSegment firstCurvySegment = new SerializedCurvySplineSegment();
                        firstCurvySegment.Position = transform.MultiplyPoint(firstSegment.P0);
                        firstCurvySegment.AutoHandles = false;
                        firstCurvySegment.HandleIn = transform.MultiplyVector(lastSegment.P2 - firstSegment.P0);
                        firstCurvySegment.HandleOut = transform.MultiplyVector(firstSegment.P1 - firstSegment.P0);
                        controlPoints.Add(firstCurvySegment);


                        for (int index = 1; index < segments.Length; index++)
                        {
                            BezierPathSegment previousSegment = segments[index - 1];
                            BezierPathSegment segment = segments[index];

                            SerializedCurvySplineSegment curvySegment = new SerializedCurvySplineSegment();
                            curvySegment.Position = transform.MultiplyPoint(segment.P0);
                            curvySegment.AutoHandles = false;
                            curvySegment.HandleIn = transform.MultiplyVector(previousSegment.P2 - segment.P0);
                            curvySegment.HandleOut = transform.MultiplyVector(segment.P1 - segment.P0);
                            controlPoints.Add(curvySegment);
                        }

                        spline.ControlPoints = controlPoints.ToArray();
                    }
                }
            }

            if (node.Children != null)
                foreach (SceneNode childNode in node.Children)
                    DrawNode(childNode, rootTransform * childNode.Transform, splines);
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/SplineSvgConverter.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/Wrappers.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6cf9b447a28326d47a6e12d03bce0f7c
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using JetBrains.Annotations;
using UnityEngine;

namespace FluffyUnderware.Curvy.ImportExport
{
    /// <summary>
    /// A wrapper to the CurvySpline class
    /// </summary>
    [Serializable]
    public class SerializedCurvySpline
    {
        public string Name;
        public Vector3 Position;
        public Vector3 Rotation;
        public CurvyInterpolation Interpolation;
        public bool RestrictTo2D;
        public bool Closed;
        public bool AutoEndTangents;
        public CurvyOrientation Orientation;
        public float AutoHandleDistance;
        public int CacheDensity;
        public float MaxPointsPerUnit;
        public bool UsePooling;
        public bool UseThreading;
        public bool CheckTransform;
        public CurvyUpdateMethod UpdateIn;
        public bool IsBSplineClamped;
        public int BSplineDegree;
        public SerializedCurvySplineSegment[] ControlPoints;

        public SerializedCurvySpline()
        {
            Interpolation = CurvyGlobalManager.DefaultInterpolation;
            AutoEndTangents = CurvySplineDefaultValues.AutoEndTangents;
            Orientation = CurvySplineDefaultValues.Orientation;
            AutoHandleDistance = CurvySplineDefaultValues.AutoHandleDistance;
            CacheDensity = CurvySplineDefaultValues.CacheDensity;
            MaxPointsPerUnit = CurvySplineDefaultValues.MaxPointsPerUnit;
            UsePooling = CurvySplineDefaultValues.UsePooling;
            CheckTransform = CurvySplineDefaultValues.CheckTransform;
            UpdateIn = CurvySplineDefaultValues.UpdateIn;
            BSplineDegree = CurvySplineDefaultValues.BSplineDegree;
            IsBSplineClamped = CurvySplineDefaultValues.IsBSplineClamped;
            ControlPoints = new SerializedCurvySplineSegment[0];

        }

        public SerializedCurvySpline([NotNull] CurvySpline spline, CurvySerializationSpace space)
        {
            Name = spline.name;
            Position = (space == CurvySerializationSpace.Local)
                ? spline.transform.localPosition
                : spline.transform.position;
            Rotation = (space == CurvySerializationSpace.Local)
                ? spline.transform.localRotation.eulerAngles
                : spline.transform.rotation.eulerAngles;
            Interpolation = spline.Interpolation;
            RestrictTo2D = spline.RestrictTo2D;
            Closed = spline.Closed;
            AutoEndTangents = spline.AutoEndTangents;
            Orientation = spline.Orientation;
            AutoHandleDistance = spline.AutoHandleDistance;
            CacheDensity = spline.CacheDensity;
            MaxPointsPerUnit = spline.MaxPointsPerUnit;
            UsePooling = spline.UsePooling;
            UseThreading = spline.UseThreading;
            CheckTransform = spline.CheckTransform;
            UpdateIn = spline.UpdateIn;
            BSplineDegree = spline.BSplineDegree;
            IsBSplineClamped = spline.IsBSplineClamped;
            ControlPoints = new SerializedCurvySplineSegment[spline.ControlPointCount];
            for (int i = 0; i < spline.ControlPointCount; i++)
                ControlPoints[i] = new SerializedCurvySplineSegment(spline.ControlPointsList[i], space);
        }

        /// <summary>
        /// Fills an existing spline with data from this instance
        /// </summary>
        /// <remarks>This method will dirty the spline</remarks>
        public void WriteIntoSpline([NotNull] CurvySpline deserializedSpline, CurvySerializationSpace space)
        {
            deserializedSpline.name = Name;
            if (space == CurvySerializationSpace.Local)
            {
                deserializedSpline.transform.localPosition = Position;
                deserializedSpline.transform.localRotation = Quaternion.Euler(Rotation);
            }
            else
            {
                deserializedSpline.transform.position = Position;
                deserializedSpline.transform.rotation = Quaternion.Euler(Rotation);
            }
            deserializedSpline.Interpolation = Interpolation;
            deserializedSpline.RestrictTo2D = RestrictTo2D;
            deserializedSpline.Closed = Closed;
            deserializedSpline.AutoEndTangents = AutoEndTangents;
            deserializedSpline.Orientation = Orientation;
            deserializedSpline.AutoHandleDistance = AutoHandleDistance;
            deserializedSpline.CacheDensity = CacheDensity;
            deserializedSpline.MaxPointsPerUnit = MaxPointsPerUnit;
            deserializedSpline.UsePooling = UsePooling;
            deserializedSpline.UseThreading = UseThreading;
            deserializedSpline.CheckTransform = CheckTransform;
            deserializedSpline.UpdateIn = UpdateIn;

            foreach (SerializedCurvySplineSegment serializedControlPoint in ControlPoints)
                serializedControlPoint.WriteIntoControlPoint(deserializedSpline.InsertAfter(null, true), space);

            //degree is assigned after the control points insertion, because the actual value of the degree depends on the number of control points
            deserializedSpline.BSplineDegree = BSplineDegree;
            deserializedSpline.IsBSplineClamped = IsBSplineClamped;

            deserializedSpline.SetDirtyAll();
        }
    }

    /// <summary>
    /// Serialized Control Point
    /// </summary>
    [Serializable]
    public class SerializedCurvySplineSegment
    {
        public Vector3 Position;
        public Vector3 Rotation;
        public bool AutoBakeOrientation;
        public bool OrientationAnchor;
        public CurvyOrientationSwirl Swirl;
        public float SwirlTurns;
        public bool AutoHandles;
        public bool SynchronizeTCB;
        public float AutoHandleDistance;
        public Vector3 HandleOut;
        public Vector3 HandleIn;

        public SerializedCurvySplineSegment()
        {

            Swirl = CurvySplineSegmentDefaultValues.Swirl;
            SynchronizeTCB = CurvySplineSegmentDefaultValues.SynchronizeTCB;
            AutoHandles = CurvySplineSegmentDefaultValues.AutoHandles;
            AutoHandleDistance = CurvySplineSegmentDefaultValues.AutoHandleDistance;
            HandleOut = CurvySplineSegmentDefaultValues.HandleOut;
            HandleIn = CurvySplineSegmentDefaultValues.HandleIn;
        }

        public SerializedCurvySplineSegment([NotNull] CurvySplineSegment segment, CurvySerializationSpace space)
        {
            Position = (space == CurvySerializationSpace.Global)
                ? segment.transform.position
                : segment.transform.localPosition;
            Rotation = (space == CurvySerializationSpace.Global)
                ? segment.transform.rotation.eulerAngles
                : segment.transform.localRotation.eulerAngles;
            AutoBakeOrientation = segment.AutoBakeOrientation;
            OrientationAnchor = segment.SerializedOrientationAnchor;
            Swirl = segment.Swirl;
            SwirlTurns = segment.SwirlTurns;
            AutoHandles = segment.AutoHandles;
            SynchronizeTCB = segment.SynchronizeTCB;
            AutoHandleDistance = segment.AutoHandleDistance;
            HandleOut = segment.HandleOut;
            HandleIn = segment.HandleIn;
        }

        /// <summary>
        /// Fills an existing control point with data from this instance.
        /// </summary>
        public void WriteIntoControlPoint([NotNull] CurvySplineSegment controlPoint, CurvySerializationSpace space)
        {
            if (space == CurvySerializationSpace.Global)
            {
                controlPoint.transform.position = Position;
                controlPoint.transform.rotation = Quaternion.Euler(Rotation);
            }
            else
            {
                controlPoint.transform.localPosition = Position;
                controlPoint.transform.localRotation = Quaternion.Euler(Rotation);
            }
            controlPoint.AutoBakeOrientation = AutoBakeOrientation;
            controlPoint.SerializedOrientationAnchor = OrientationAnchor;
            controlPoint.Swirl = Swirl;
            controlPoint.SynchronizeTCB = SynchronizeTCB;
            controlPoint.SwirlTurns = SwirlTurns;
            controlPoint.AutoHandles = AutoHandles;
            controlPoint.AutoHandleDistance = AutoHandleDistance;
            controlPoint.SetBezierHandleIn(HandleIn);
            controlPoint.SetBezierHandleOut(HandleOut);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/Wrappers.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/BSplineHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1a16162565f8a9c4abf2a7cd62b6f064
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System.Runtime.CompilerServices;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using UnityEngine;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Static methods used in the implementation of B-Splines
    /// </summary>
    public static class BSplineHelper
    {
        /// <summary>
        /// De Boor algorithm for clamped B-Splines. parameter names taken from https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/de-Boor.html.
        /// This is a variant of that implementation, explained in the english De Boor's page in Wikipedia 
        /// </summary>
        public static Vector3 DeBoorClamped(int p, int k, float u, int nPlus1, [NotNull] Vector3[] pArray)
        {
            //OPTIM make a per degree non recursive implementation for degree 2 and maybe other lower degrees
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(pArray.Length >= p + 1);
#endif
            int kMinusP = k - p;
            int maxClampedKnotValue = nPlus1 - p;// n + 1 - p  is the max knot value

            for (int r = 1; r <= p; r++)
            {
                int kPlusOneMinusR = k + 1 - r;

                for (int j = p; j >= r; j--)
                {
                    int i1 = j + kMinusP;
                    int i2 = j + kPlusOneMinusR;

                    int u1;
                    int u2;
                    /*The following code is equivalent to the commented code underneath, but using the fact that i1 is smaller than i2
                    u1 = i1 <= p
                        ? 0
                        : i1 >= nPlus1 // n+1 is m-p 
                            ? maxClampedKnotValue // n - p + 1 is the max knot value
                            : i1 - p;
                    u2 = i2 <= p
                        ? 0
                        : i2 >= nPlus1 // n+1 is m-p 
                            ? maxClampedKnotValue // n - p + 1 is the max knot value
                            : i2 - p;
                    */
                    if (i1 <= p)
                    {
                        u1 = 0;

                        if (i2 <= p)
                            u2 = 0;
                        else
                            u2 = i2 >= nPlus1 // n+1 is m-p 
                                ? maxClampedKnotValue
                                : i2 - p;
                    }
                    else if (i1 >= nPlus1)
                    {
                        u1 = u2 = maxClampedKnotValue;
                    }
                    else
                    {
                        u1 = i1 - p;
                        u2 = i2 >= nPlus1 // n+1 is m-p 
                            ? maxClampedKnotValue
                            : i2 - p;
                    }

                    float a = (u - u1) / (u2 - u1);
                    //equivalent to psArray[j] = (1 - a) * psArray[j - 1] + a * psArray[j];
                    pArray[j] = pArray[j - 1].Multiply(1 - a)
                        .Addition(pArray[j].Multiply(a));
                }
            }

            return pArray[p];
        }

        /// <summary>
        /// De Boor algorithm for clamped B-Splines. parameter names taken from https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/de-Boor.html.
        /// This is a variant of that implementation, explained in the english De Boor's page in Wikipedia 
        /// </summary>
        public static Vector3 DeBoorUnclamped(int p, int k, float u, [NotNull] Vector3[] pArray)
        {
            //OPTIM make a per degree non recursive implementation for degree 2 and maybe other lower degrees

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(pArray.Length >= p + 1);
#endif
            int kMinusP = k - p;

            for (int r = 1; r <= p; r++)
            {
                int kPlusOneMinusR = k + 1 - r;

                for (int j = p; j >= r; j--)
                {
                    float a = (u - (j + kMinusP)) / ((j + kPlusOneMinusR) - (j + kMinusP));
                    //equivalent to psArray[j] = (1 - a) * psArray[j - 1] + a * psArray[j];
                    pArray[j] = pArray[j - 1].Multiply(1 - a)
                        .Addition(pArray[j].Multiply(a));
                }
            }

            return pArray[p];
        }

        /// <summary>
        /// Get the N number as defined in the B-Spline section here: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int GetBSplineN(int controlPointsCount, int degree, bool closed)
        {
            return controlPointsCount - 1 + (closed ? degree : 0);
        }

        /// <summary>
        /// Get the the U and K numbers as defined in the B-Spline section, De Boor's algorithm, here: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void GetBSplineUAndK(float tf, bool isClamped, int p, int n, out float u, out int k)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(tf.IsBetween0And1());
#endif
            if (isClamped)
            {
                u = (n - p + 1) * tf; // n - p + 1 is the max knot value
                int intU = (int)u;
                //case of u equal to 1
                if (intU == n - p + 1) // n - p + 1 is the max knot value
                    intU--;
                k = intU + p;
            }
            else
            {
                u = p + (n + 1 - p) * tf;//inlined version of DTMath.MapValue(p, m - p, tf, 0, 1), knowing that n+1 is m-p
                int intU = (int)u;
                //case of u equal to 1
                if (intU == n + 1) // n+1 is m-p
                    intU--;
                k = intU;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/BSplineHelper.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CodeContractsUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e1897b667b05641448d9cb45004d9bbf
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

#if CONTRACTS_FULL

using System;
using System.Diagnostics.Contracts;
using UnityEngine;

namespace FluffyUnderware.Curvy
{
    public static class CodeContractsUtility
    {
        [Pure]
        public static void AssumeInvariant<T>(T assumptionTarget)
        {
        }

        [Pure]
        public static bool IsPercentage(this float number)
        {
            return number >= 0 && number <= 100;
        }

        [Pure]
        public static bool IsPercentage(this int number)
        {
            return number >= 0 && number <= 100;
        }

        [Pure]
        public static bool IsValidCollectionIndex(this int number, int collectionSize)
        {
            return number >= 0 && number < collectionSize;
        }

        [Pure]
        public static bool IsRatio(this float number)
        {
            return number >= 0 && number <= 1;
        }

        [Pure]
        public static bool IsRatioOrNegativeRatio(this float number)
        {
            return number >= -1 && number <= 1;
        }

        /// <summary>
        /// Returns true if float is neither an infinity nor a NaN
        /// </summary>
        /// <param name="number"></param>
        /// <returns></returns>
        [Pure]
        public static bool IsANumber(this float number)
        {
            return Single.IsNaN(number) == false && number.IsFinite();
        }

        [Pure]
        public static bool IsPositiveNumber(this float number)
        {
            return number >= 0 && number.IsANumber();
        }

        [Pure]
        public static bool IsStrictelyPositiveNumber(this float number)
        {
            return number > 0 && number.IsANumber();
        }

        [Pure]
        public static bool IsNegativeNumber(this float number)
        {
            return number <= 0 && number.IsANumber();
        }

        [Pure]
        public static bool IsOdd(this int number)
        {
            return number % 2 != 0;
        }

        [Pure]
        public static bool IsEven(this int number)
        {
            return number % 2 == 0;
        }


        /// <summary>
        /// Is the given value between 0 and 180 inclusive
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        [Pure]
        public static bool IsIn0To180Range(this float value)
        {
            return value >= 0 && value <= 180;
        }

        /// <summary>
        /// Is the given value between -180 and 180 inclusive
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        [Pure]
        public static bool IsInMinus180To180Range(this float value)
        {
            return value >= -180 && value <= 180;
        }

        /// <summary>
        /// Is the given value between 0 and 90 inclusive
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        [Pure]
        public static bool IsIn0To90Range(this float value)
        {
            return value >= 0 && value <= 90;
        }

        /// <summary>
        /// Is the given value between -90 and 90 inclusive
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        [Pure]
        public static bool IsInMinus90To90Range(this float value)
        {
            return value >= -90 && value <= 90;
        }

        [Pure]
        public static bool IsInRangeExclusive(this float value, float rangeLowerBound, float rangeUpperBound)
        {
            Contract.Requires(rangeLowerBound < rangeUpperBound);

            return value > rangeLowerBound && value < rangeUpperBound;
        }

        [Pure]
        public static bool IsInRangeInclusive(this float value, float rangeLowerBound, float rangeUpperBound)
        {
            Contract.Requires(rangeLowerBound < rangeUpperBound);

            return value >= rangeLowerBound && value <= rangeUpperBound;
        }

        [Pure]
        public static bool IsNan(this float number)
        {
            return Single.IsNaN(number);
        }

        [Pure]
        public static bool IsNormalized(this Vector3 vector)
        {
            return Approximately(vector.magnitude, 1f);
        }

        [Pure]
        public static bool IsNormalized(this Quaternion q)
        {
            return Approximately(
                (float)Math.Sqrt(q.w * q.w + q.x * q.x + q.y * q.y + q.z * q.z)
                , 1f);
        }

        [Pure]
        public static bool ContainsNan(this Vector3 vector)
        {
            return float.IsNaN(vector.x) || float.IsNaN(vector.y) || float.IsNaN(vector.z);
        }

        [Pure]
        public static bool ContainsInfinity(this Vector3 vector)
        {
            return float.IsInfinity(vector.x) || float.IsInfinity(vector.y) || float.IsInfinity(vector.z);

        }
        [Pure]
        public static float PureDot(this Vector3 vector1, Vector3 vector2)
        {
            return Vector3.Dot(vector1, vector2);
        }

        [Pure]
        public static Vector3 PureCross(this Vector3 vector1, Vector3 vector2)
        {
            return Vector3.Cross(vector1, vector2);
        }

        [Pure]
        public static bool PureIsChildOf(this Transform child, Transform parent)
        {
            return child.IsChildOf(parent);
        }

        [Pure]
        public static bool Approximately(this float a, float b)
        {
            return Mathf.Approximately(a, b);
        }

        [Pure]
        public static bool WithinMargin(this float a, float b, float margin)
        {
            return Mathf.Abs(b - a) <= margin;
        }

        [Pure]
        public static bool Approximately(this Vector3 a, Vector3 b)
        {
            return a.x.Approximately(b.x)
                && a.y.Approximately(b.y)
                && a.z.Approximately(b.z);
        }

        [Pure]
        public static bool IsWithinDistance(this Vector3 a, Vector3 b, float maxAllowedDistance)
        {
            Contract.Requires(maxAllowedDistance.IsPositiveNumber());
            return (a - b).magnitude <= maxAllowedDistance;
        }

        //[Pure]
        //public static bool IsWithinAngle(this Quaternion a, Quaternion b, float maxAllowedAngle)
        //{
        //    Contract.Requires(maxAllowedAngle.IsPositiveNumber());

        //    return a.Angle(b) <= maxAllowedAngle;
        //}


        [Pure]
        public static bool IsFinite(this float number)
        {
            Contract.Requires(IsNan(number) == false);

            return float.IsInfinity(number) == false;
        }

        [Pure]
        public static bool IsInfinite(this float number)
        {
            return !IsFinite(number);
        }

        [Pure]
        public static bool IsNotZero(this float number)
        {
            return number.Approximately(0f) == false;
        }

        [Pure]
        public static int MaskNameToLayer(string layerName)
        {
            return LayerMask.NameToLayer(layerName);
        }

        [Pure]
        public static bool AreBarycentricCoordinatesOfPointInTriangle(this Vector3 barycentricCoordinates)
        {
            return
                barycentricCoordinates.x >= 0 &&
                barycentricCoordinates.y >= 0 &&
                barycentricCoordinates.z >= 0 &&
                1f.Approximately(barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z);
        }

        [Pure]
        static public float PureMin(float a, float b)
        {
            Contract.Ensures(Contract.Result<float>() <= a);
            Contract.Ensures(Contract.Result<float>() <= b);
            return Mathf.Min(a, b);
        }

        [Pure]
        static public float PureMax(float a, float b)
        {
            Contract.Ensures(Contract.Result<float>() >= a);
            Contract.Ensures(Contract.Result<float>() >= b);
            return Mathf.Max(a, b);
        }

        [Pure]
        static public T PureGetComponent<T>(this GameObject gameObject)
        {
            return gameObject.GetComponent<T>();
        }

        [Pure]
        static public Component PureGetComponent(this GameObject gameObject, string componentName)
        {
            return gameObject.GetComponent(componentName);
        }
    }
}

#endif
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CodeContractsUtility.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyClasses.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 67f3b369fc26aae43aa3d1cbb9b64d3f
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Orientation options
    /// </summary>
    public enum OrientationModeEnum
    {
        /// <summary>
        /// No Orientation. The initial orientation of the controller is kept.
        /// </summary>
        None,
        /// <summary>
        /// Use Orientation/Up-Vector
        /// </summary>
        Orientation,
        /// <summary>
        /// Use Direction/Tangent
        /// </summary>
        Tangent
    }

    /// <summary>
    /// Orientation axis to use
    /// </summary>
    public enum OrientationAxisEnum
    {
        Up,
        Down,
        Forward,
        Backward,
        Left,
        Right
    }

    /// <summary>
    /// Used by components to determine when updates should occur
    /// </summary>
    public enum CurvyUpdateMethod
    {
        Update,
        LateUpdate,
        FixedUpdate
    }

    public enum CurvyRepeatingOrderEnum
    {
        Random = 0,
        Row = 1
    }

    /// <summary>
    /// Plane definition
    /// </summary>
    public enum CurvyPlane
    {
        /// <summary>
        /// X/Y Plane (Z==0)
        /// </summary>
        XY,
        /// <summary>
        /// X/U Plane (Y==0)
        /// </summary>
        XZ,
        /// <summary>
        /// Y/Z Plane (X==)
        /// </summary>
        YZ
    }

    /// <summary>
    /// Position Mode 
    /// </summary>
    public enum CurvyPositionMode
    {
        /// <summary>
        /// Valid positions are from 0 (Start) to 1 (End)
        /// </summary>
        Relative = 0,
        /// <summary>
        /// Valid positions are from 0 (Start) to Length (End). Also know as Absolute.
        /// </summary>
        WorldUnits = 1,
    }

    /// <summary>
    /// Bezier Handles editing modes
    /// </summary>
    [Flags]
    public enum CurvyBezierModeEnum
    {
        /// <summary>
        /// Don't sync
        /// </summary>
        None = 0,
        /// <summary>
        /// Sync Direction
        /// </summary>
        Direction = 1,
        /// <summary>
        /// Sync Length
        /// </summary>
        Length = 2,
        /// <summary>
        /// Sync connected Control Points
        /// </summary>
        Connections = 4,
        /// <summary>
        /// Combine both Handles of a segment
        /// </summary>
        Combine = 8
    }

    /// <summary>
    /// Bezier Handles editing modes for AdvSplines
    /// </summary>
    public enum CurvyAdvBezierModeEnum
    {
        /// <summary>
        /// Don't sync
        /// </summary>
        None = 0,
        /// <summary>
        /// Sync Direction
        /// </summary>
        Direction = 1,
        /// <summary>
        /// Sync Length
        /// </summary>
        Length = 2,
        /// <summary>
        /// Combine both Handles of a segment
        /// </summary>
        Combine = 8
    }

    /// <summary>
    /// Determines the interpolation method
    /// </summary>
    public enum CurvyInterpolation
    {
        /// <summary>
        ///  Linear interpolation
        /// </summary>
        Linear = 0,
        /// <summary>
        /// Catmul-Rom splines
        /// </summary>
        CatmullRom = 1,
        /// <summary>
        /// Kochanek-Bartels (TCB)-Splines
        /// </summary>
        TCB = 2,
        /// <summary>
        /// Cubic Bezier-Splines
        /// </summary>
        Bezier = 3,
        /// <summary>
        /// B-Splines
        /// </summary>
        BSpline = 4
    }

    /// <summary>
    /// Determines the clamping method used by Move-methods
    /// </summary>
    public enum CurvyClamping
    {
        /// <summary>
        /// Stop at splines ends
        /// </summary>
        Clamp = 0,
        /// <summary>
        /// Start over
        /// </summary>
        Loop = 1,
        /// <summary>
        /// Switch direction
        /// </summary>
        PingPong = 2
    }

    /// <summary>
    /// Determines Orientation mode
    /// </summary>
    public enum CurvyOrientation
    {
        /// <summary>
        /// Ignore rotation
        /// </summary>
        None = 0,
        /// <summary>
        /// Use the splines' tangent and up vectors to create a look rotation 
        /// </summary>
        Dynamic = 1,
        /// <summary>
        /// Interpolate between the Control Point's rotation
        /// </summary>
        Static = 2,
    }

    /// <summary>
    /// Swirl mode
    /// </summary>
    public enum CurvyOrientationSwirl
    {
        /// <summary>
        /// No Swirl
        /// </summary>
        None = 0,
        /// <summary>
        /// Swirl over each segment of anchor group
        /// </summary>
        Segment = 1,
        /// <summary>
        /// Swirl equal over current anchor group's segments
        /// </summary>
        AnchorGroup = 2,
        /// <summary>
        /// Swirl equal over anchor group's length
        /// </summary>
        AnchorGroupAbs = 3
    }



    /// <summary>
    /// Sceneview viewing modes
    /// </summary>
    [Flags]
    public enum CurvySplineGizmos : int
    {
        None = 0,
        Connections = 1,
        Curve = 1 << 1,
        Approximation = 1 << 2,
        Tangents = 1 << 3,
        Orientation = 1 << 4,
        Labels = 1 << 5,
        Metadata = 1 << 6,
        Bounds = 1 << 7,
        TFs = 1 << 8,
        RelativeDistances = 1 << 9,
        OrientationAnchors = 1 << 10,
        All = 65535
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyClasses.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fd4480447eb35824e9fe7f9dd8256ddf
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEngine.Assertions;

#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
namespace FluffyUnderware.Curvy
{
    public class CurvyEventArgs : EventArgs
    {
        /// <summary>
        /// The component raising the event
        /// </summary>
        public readonly MonoBehaviour Sender;
        /// <summary>
        /// Custom data
        /// </summary>
        public readonly object Data;

        public CurvyEventArgs(MonoBehaviour sender, object data)
        {
            Sender = sender;
            Data = data;

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(System.Object.ReferenceEquals(null, Sender) == false);
#endif
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyEvents.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2d6ea997949c6e245aa4edc8a8e04b66
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Pools;
using ToolBuddy.Pooling.Pools;
using FluffyUnderware.Curvy.ThirdParty.LibTessDotNet;
#if UNITY_EDITOR
using UnityEditor;
#endif
using FluffyUnderware.DevTools;
using ToolBuddy.Pooling;
using ToolBuddy.Pooling.Collections;


namespace FluffyUnderware.Curvy.Utils
{

    /// <summary>
    /// A workaround to the Unity Json's class not being able to serialize top level arrays.
    /// Including such arrays in another object avoids the issue.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class SerializableArray<T>
    {
        public T[] Array;
    }

    /// <summary>
    /// Taken from my asset Frame Rate Booster
    /// https://assetstore.unity.com/packages/tools/utilities/frame-rate-booster-120660
    /// </summary>
    public static class OptimizedOperators
    {
        public static Vector3 Addition(this Vector3 a, Vector3 b)
        {
            a.x += b.x;
            a.y += b.y;
            a.z += b.z;
            return a;
        }

        public static Vector3 UnaryNegation(this Vector3 a)
        {
            Vector3 result;
            result.x = -a.x;
            result.y = -a.y;
            result.z = -a.z;
            return result;
        }

        public static Vector3 Subtraction(this Vector3 a, Vector3 b)
        {
            a.x -= b.x;
            a.y -= b.y;
            a.z -= b.z;
            return a;

        }

        public static Vector3 Multiply(this Vector3 a, float d)
        {
            a.x *= d;
            a.y *= d;
            a.z *= d;
            return a;
        }

        public static Vector3 Multiply(this float d, Vector3 a)
        {
            a.x *= d;
            a.y *= d;
            a.z *= d;
            return a;
        }

        public static Vector3 Division(this Vector3 a, float d)
        {
            float inversed = 1 / d;
            a.x *= inversed;
            a.y *= inversed;
            a.z *= inversed;
            return a;
        }

        public static Vector3 Normalize(this Vector3 value)
        {
            Vector3 result;
            float num = (float)Math.Sqrt(value.x * (double)value.x + value.y * (double)value.y + value.z * (double)value.z);
            if (num > 9.99999974737875E-06)
            {
                float inversed = 1 / num;
                result.x = value.x * inversed;
                result.y = value.y * inversed;
                result.z = value.z * inversed;
            }
            else
            {
                result.x = 0;
                result.y = 0;
                result.z = 0;
            }
            return result;
        }

        public static Vector3 LerpUnclamped(this Vector3 a, Vector3 b, float t)
        {
            a.x += (b.x - a.x) * t;
            a.y += (b.y - a.y) * t;
            a.z += (b.z - a.z) * t;
            return a;
        }

        static public Color Multiply(this Color a, float b)
        {
            a.r *= b;
            a.g *= b;
            a.b *= b;
            a.a *= b;
            return a;
        }

        static public Color Multiply(this float b, Color a)
        {
            a.r *= b;
            a.g *= b;
            a.b *= b;
            a.a *= b;
            return a;
        }

        public static Quaternion Multiply(this Quaternion lhs, Quaternion rhs)
        {
            Quaternion result;
            result.x = (lhs.w * rhs.x + lhs.x * rhs.w + lhs.y * rhs.z - lhs.z * rhs.y);
            result.y = (lhs.w * rhs.y + lhs.y * rhs.w + lhs.z * rhs.x - lhs.x * rhs.z);
            result.z = (lhs.w * rhs.z + lhs.z * rhs.w + lhs.x * rhs.y - lhs.y * rhs.x);
            result.w = (lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z);
            return result;
        }
    }


    /// <summary>
    /// Curvy Utility class
    /// </summary>
    public static class CurvyUtility
    {
        #region ### Clamping Methods ###

        /// <summary>
        /// Clamps relative position
        /// </summary>
        public static float ClampTF(float tf, CurvyClamping clamping)
        {
            switch (clamping)
            {
                case CurvyClamping.Loop:
                    return Mathf.Repeat(tf, 1);
                case CurvyClamping.PingPong:
                    return Mathf.PingPong(tf, 1);
                case CurvyClamping.Clamp:
                    return Mathf.Clamp01(tf);
                default:
                    throw new InvalidEnumArgumentException();
            }
        }


        /// <summary>
        /// Clamps relative position and sets new direction
        /// </summary>
        public static float ClampTF(float tf, ref int dir, CurvyClamping clamping)
        {
            switch (clamping)
            {
                case CurvyClamping.Loop:
                    return Mathf.Repeat(tf, 1);
                case CurvyClamping.PingPong:
                    if (Mathf.FloorToInt(tf) % 2 != 0)
                        dir *= -1;
                    return Mathf.PingPong(tf, 1);
                case CurvyClamping.Clamp:
                    return Mathf.Clamp01(tf);
                default:
                    throw new InvalidEnumArgumentException();
            }
        }

        /// <summary>
        /// Clamps a float to a range
        /// </summary>
        public static float ClampValue(float tf, CurvyClamping clamping, float minTF, float maxTF)
        {

            switch (clamping)
            {
                case CurvyClamping.Loop:
                    float v1 = DTMath.MapValue(0, 1, tf, minTF, maxTF);
                    return DTMath.MapValue(minTF, maxTF, Mathf.Repeat(v1, 1), 0, 1);
                case CurvyClamping.PingPong:
                    float v2 = DTMath.MapValue(0, 1, tf, minTF, maxTF);
                    return DTMath.MapValue(minTF, maxTF, Mathf.PingPong(v2, 1), 0, 1);
                case CurvyClamping.Clamp:
                    return Mathf.Clamp(tf, minTF, maxTF);
                default:
                    throw new InvalidEnumArgumentException();
            }
        }

        /// <summary>
        /// Clamps absolute position
        /// </summary>
        public static float ClampDistance(float distance, CurvyClamping clamping, float length)
        {
            if (length == 0)
                return 0;
            switch (clamping)
            {
                case CurvyClamping.Loop:
                    return Mathf.Repeat(distance, length);
                case CurvyClamping.PingPong:
                    return Mathf.PingPong(distance, length);
                case CurvyClamping.Clamp:
                    return Mathf.Clamp(distance, 0, length);
                default:
                    throw new InvalidEnumArgumentException();
            }
        }

        /// <summary>
        /// Clamps absolute position
        /// </summary>
        public static float ClampDistance(float distance, CurvyClamping clamping, float length, float min, float max)
        {
            if (length == 0)
                return 0;
            min = Mathf.Clamp(min, 0, length);
            max = Mathf.Clamp(max, min, length);
            switch (clamping)
            {
                case CurvyClamping.Loop:
                    return min + Mathf.Repeat(distance, max - min);
                case CurvyClamping.PingPong:
                    return min + Mathf.PingPong(distance, max - min);
                case CurvyClamping.Clamp:
                    return Mathf.Clamp(distance, min, max);
                default:
                    throw new InvalidEnumArgumentException();
            }
        }

        /// <summary>
        /// Clamps absolute position and sets new direction
        /// </summary>
        public static float ClampDistance(float distance, ref int dir, CurvyClamping clamping, float length)
        {
            if (length == 0)
                return 0;
            switch (clamping)
            {
                case CurvyClamping.Loop:
                    return Mathf.Repeat(distance, length);
                case CurvyClamping.PingPong:
                    if (Mathf.FloorToInt(distance / length) % 2 != 0)
                        dir *= -1;
                    return Mathf.PingPong(distance, length);
                case CurvyClamping.Clamp:
                    return Mathf.Clamp(distance, 0, length);
                default:
                    throw new InvalidEnumArgumentException();
            }
        }

        /// <summary>
        /// Clamps absolute position and sets new direction
        /// </summary>
        public static float ClampDistance(float distance, ref int dir, CurvyClamping clamping, float length, float min, float max)
        {
            if (length == 0)
                return 0;
            min = Mathf.Clamp(min, 0, length);
            max = Mathf.Clamp(max, min, length);
            switch (clamping)
            {
                case CurvyClamping.Loop:
                    return min + Mathf.Repeat(distance, max - min);
                case CurvyClamping.PingPong:
                    if (Mathf.FloorToInt(distance / (max - min)) % 2 != 0)
                        dir *= -1;
                    return min + Mathf.PingPong(distance, max - min);
                case CurvyClamping.Clamp:
                    return Mathf.Clamp(distance, min, max);
                default:
                    throw new InvalidEnumArgumentException();
            }
        }

        #endregion

        /// <summary>
        /// Gets the default material, i.e. Curvy/Resources/CurvyDefaultMaterial
        /// </summary>
        public static Material GetDefaultMaterial()
        {
            Material mat = Resources.Load("CurvyDefaultMaterial") as Material;
            if (mat == null)
            {
                Shader shader = Shader.Find("Standard");
                if (shader != null) //this can happen, for example in an HDRP build
                    mat = new Material(shader);
            }

            if (mat == null)
                DTLog.LogWarning("[Curvy] Couldn't find Curvy's default material. Please raise a bug report.");

            return mat;
        }


        /// <summary>
        /// Does the same things as Mathf.Approximately, but with different handling of case where one of the two values is 0
        /// Considering inputs of 0 and 1E-7, Mathf.Approximately will return false, while this method will return true.
        /// </summary>
        public static bool Approximately(this float x, float y)
        {
            bool result;
            const float zeroComparisionMargin = 0.000009f;

            float nearlyZero = Mathf.Epsilon * 8f;

            float absX = Math.Abs(x);
            float absY = Math.Abs(y);

            if (absY < nearlyZero)
                result = absX < zeroComparisionMargin;
            else if (absX < nearlyZero)
                result = absY < zeroComparisionMargin;
            else
                result = Mathf.Approximately(x, y);
            return result;
        }

        /// <summary>
        /// Finds the index of x in an array of sorted values (ascendant order). If x not found, the closest smaller value's index is returned if any, -1 otherwise
        /// </summary>
        ///  <param name="array">The array to search into</param>
        ///  <param name="x">The element to search for</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int InterpolationSearch(float[] array, float x)
        {
            return InterpolationSearch(array, array.Length, x);
        }

        ///  <summary>
        ///  Finds the index of x in an array of sorted values (ascendant order). If x not found, the closest smaller value's index is returned if any, -1 otherwise
        ///  </summary>
        ///  <param name="array">The array to search into</param>
        ///  <param name="elementsCount">The number of elements of the array to search into</param>
        ///  <param name="x">The element to search for</param>
        public static int InterpolationSearch(float[] array, int elementsCount, float x)
        {
            int low = 0, high = (elementsCount - 1);

            while (low <= high && array[low] <= x && x <= array[high])
            {
                if (low == high)
                {
                    if (array[low] == x)
                        return low;
                    break;
                }
                int index = low + (int)((((high - low) / (array[high] - array[low])) * (x - array[low])));
                if (array[index] == x)
                    return index;
                if (array[index] < x)
                    low = index + 1;
                else
                    high = index - 1;
            }

            if (low > high)
            {
                (low, high) = (high, low);
            }

            if (x <= array[low])
            {
                while (low >= 0)
                {
                    if (array[low] <= x)
                        return low;
                    low--;
                }

                return 0;
            }

            if (array[high] < x)
            {
                while (high < elementsCount)
                {
                    if (x < array[high])
                        return high - 1;
                    high++;
                }

                return elementsCount - 1;
            }

            return -1;
        }

        /// <summary>
        /// Returns a mesh which boundaries are the input spline, similarly to what the Spline To Mesh window does, but simpler and less configurable.
        /// </summary>
        public static Mesh SplineToMesh(this CurvySpline spline)
        {
            Mesh result;

            Spline2Mesh splineToMesh = new Spline2Mesh();
            splineToMesh.Lines.Add(new SplinePolyLine(spline));
            splineToMesh.Apply(out result);

            if (String.IsNullOrEmpty(splineToMesh.Error) == false)
                Debug.Log(splineToMesh.Error);

            return result;
        }


        /// <summary>
        /// Given an input point, gets the index of the point in the array that is closest to the input point.
        /// </summary>
        /// <param name="point">the input point</param>
        /// <param name="points">A list of points to test against</param>
        /// <param name="pointsCount">The number of points to test against</param>
        /// <param name="index">the index of the closest point</param>
        /// <param name="fragement">a value between 0 and 1 indicating how close the input point is close to the point of index: index + 1</param>
        public static void GetNearestPointIndex(Vector3 point, Vector3[] points, int pointsCount, out int index, out float fragement)
        {
            float nearestSquaredDistance = float.MaxValue;
            int nearestIndex = 0;
            // get the nearest index
            for (int i = 0; i < pointsCount; i++)
            {
                Vector3 delta;
                delta.x = points[i].x - point.x;
                delta.y = points[i].y - point.y;
                delta.z = points[i].z - point.z;
                float squaredDistance = (delta.x * delta.x + delta.y * delta.y + delta.z * delta.z);
                if (squaredDistance <= nearestSquaredDistance)
                {
                    nearestSquaredDistance = squaredDistance;
                    nearestIndex = i;
                }
            }

            // collide p against the lines build by the index
            int leftIdx = (nearestIndex > 0) ? nearestIndex - 1 : -1;
            int rightIdx = (nearestIndex < pointsCount - 1) ? nearestIndex + 1 : -1;

            float leftFrag = 0;
            float rightFrag = 0;
            float leftSquaredDistance = float.MaxValue;
            float rightSquareDistance = float.MaxValue;
            {
                if (leftIdx > -1)
                    leftSquaredDistance = DTMath.LinePointDistanceSqr(points[leftIdx], points[nearestIndex], point, out leftFrag);
                if (rightIdx > -1)
                    rightSquareDistance = DTMath.LinePointDistanceSqr(points[nearestIndex], points[rightIdx], point, out rightFrag);
            }

            if (leftSquaredDistance < rightSquareDistance)
            {
                fragement = leftFrag;
                index = leftIdx;
            }
            else
            {
                fragement = rightFrag;
                index = nearestIndex;
            }
        }
    }

    #region ### Spline2Mesh ###

    /// <summary>
    /// Class to create a Mesh from a set of splines
    /// </summary>
    public class Spline2Mesh
    {
        #region ### Public Fields & Properties ###
        /// <summary>
        /// A list of splines (X/Y only) forming the resulting mesh
        /// </summary>
        public List<SplinePolyLine> Lines = new List<SplinePolyLine>();
        /// <summary>
        /// Winding rule used by triangulator
        /// </summary>
        public WindingRule Winding = WindingRule.EvenOdd;
        public Vector2 UVTiling = Vector2.one;
        public Vector2 UVOffset = Vector2.zero;
        public bool SuppressUVMapping;
        /// <summary>
        /// Whether UV2 should be set
        /// </summary>
        public bool UV2;
        /// <summary>
        /// Name of the returned mesh
        /// </summary>
        public string MeshName = string.Empty;
        /// <summary>
        /// Whether only vertices of the outline spline should be created
        /// </summary>
        public bool VertexLineOnly;

        public string Error { get; private set; }

        #endregion

        #region ### Private Fields ###

        private Tess mTess;
        private Mesh mMesh;

        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Create the Mesh using the current settings
        /// </summary>
        /// <param name="result">the resulting Mesh</param>
        /// <returns>true on success. If false, check the Error property!</returns>
        public bool Apply(out Mesh result)
        {
            ArrayPool<Vector3> pool = ArrayPoolsProvider.GetPool<Vector3>();

            mTess = null;
            mMesh = null;
            Error = string.Empty;
            bool triangulationSucceeded = triangulate();
            if (triangulationSucceeded)
            {
                mMesh = new Mesh();
                mMesh.name = MeshName;

                if (VertexLineOnly && Lines.Count > 0 && Lines[0] != null)
                {
                    SubArray<Vector3> vertices = Lines[0].GetVertexList();
                    mMesh.SetVertices(vertices.Array, 0, vertices.Count);
                    pool.Free(vertices);
                }
                else
                {
                    ContourVertex[] vertices = mTess.Vertices;
                    SubArray<Vector3> vector3s = pool.Allocate(vertices.Length);
                    UnityLibTessUtility.FromContourVertex(vertices, vector3s);
                    mMesh.SetVertices(vector3s.Array, 0, vector3s.Count);
                    mMesh.SetTriangles(mTess.ElementsArray.Value.Array, 0, mTess.ElementsArray.Value.Count, 0);
                    pool.Free(vector3s);
                }

                mMesh.RecalculateBounds();
                mMesh.RecalculateNormals();
                if (!SuppressUVMapping && !VertexLineOnly)
                {
                    Vector3 boundsSize = mMesh.bounds.size;
                    Vector3 boundsMin = mMesh.bounds.min;

                    float minSize = Mathf.Min(boundsSize.x, Mathf.Min(boundsSize.y, boundsSize.z));

                    bool minSizeIsX = minSize == boundsSize.x;
                    bool minSizeIsY = minSize == boundsSize.y;
                    bool minSizeIsZ = minSize == boundsSize.z;

                    Vector3[] vertices = mMesh.vertices;
                    int vertexCount = vertices.Length;

                    //set uv and uv2
                    SubArray<Vector2> uv;
                    SubArray<Vector2> uv2;
                    {
                        uv = ArrayPools.Vector2.Allocate(vertexCount);
                        Vector2[] uvArray = uv.Array;

                        uv2 = ArrayPools.Vector2.Allocate(UV2 ? vertexCount : 0);
                        Vector2[] uv2Array = uv2.Array;

                        for (int i = 0; i < vertexCount; i++)
                        {
                            float u;
                            float v;
                            Vector3 vertex = vertices[i];

                            if (minSizeIsX)
                            {
                                u = (vertex.y - boundsMin.y) / boundsSize.y;
                                v = (vertex.z - boundsMin.z) / boundsSize.z;
                            }
                            else if (minSizeIsY)
                            {
                                u = (vertex.z - boundsMin.z) / boundsSize.z;
                                v = (vertex.x - boundsMin.x) / boundsSize.x;
                            }
                            else if (minSizeIsZ)
                            {
                                u = (vertex.x - boundsMin.x) / boundsSize.x;
                                v = (vertex.y - boundsMin.y) / boundsSize.y;
                            }
                            else
                                throw new InvalidOperationException("Couldn't find the minimal bound dimension");

                            if (UV2)
                            {
                                uv2Array[i].x = u;
                                uv2Array[i].y = v;
                            }

                            u += UVOffset.x;
                            v += UVOffset.y;

                            u *= UVTiling.x;
                            v *= UVTiling.y;
                            uvArray[i].x = u;
                            uvArray[i].y = v;
                        }
                        mMesh.SetUVs(0, uv.Array, 0, uv.Count);
                        mMesh.SetUVs(1, uv2.Array, 0, uv2.Count);
                    }

                    ArrayPools.Vector2.Free(uv);
                    ArrayPools.Vector2.Free(uv2);
                    ArrayPools.Vector3.Free(vertices);
                }
            }
            result = mMesh;
            return triangulationSucceeded;
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */

        private bool triangulate()
        {
            if (Lines.Count == 0)
            {
                Error = "Missing splines to triangulate";
                return false;
            }

            if (VertexLineOnly)
                return true;

            mTess = new Tess();

            for (int i = 0; i < Lines.Count; i++)
            {
                if (Lines[i].Spline == null)
                {
                    Error = "Missing Spline";
                    return false;
                }
                if (!polyLineIsValid(Lines[i]))
                {
                    Error = Lines[i].Spline.name + ": Angle must be >0";
                    return false;
                }
                SubArray<Vector3> vertices = Lines[i].GetVertexList();
                if (vertices.Count < 3)
                {
                    Error = Lines[i].Spline.name + ": At least 3 Vertices needed!";
                    return false;
                }
                mTess.AddContour(UnityLibTessUtility.ToContourVertex(vertices, false), Lines[i].Orientation);
                ArrayPoolsProvider.GetPool<Vector3>().Free(vertices);
            }
            try
            {
                mTess.Tessellate(Winding, ElementType.Polygons, 3);
                return true;
            }
            catch (System.Exception e)
            {
                Error = e.Message;
            }

            return false;
        }

        private static bool polyLineIsValid(SplinePolyLine pl)
        {
            return (pl != null && pl.VertexMode == SplinePolyLine.VertexCalculation.ByApproximation ||
                    !Mathf.Approximately(0, pl.Angle));
        }

        /*! \endcond */
        #endregion
    }

    /// <summary>
    /// Spline Triangulation Helper Class
    /// </summary>
    [System.Serializable]
    public class SplinePolyLine
    {
        /// <summary>
        /// How to calculate vertices
        /// </summary>
        public enum VertexCalculation
        {
            /// <summary>
            /// Use Approximation points
            /// </summary>
            ByApproximation,
            /// <summary>
            /// By curvation angle
            /// </summary>
            ByAngle
        }

        /// <summary>
        /// Orientation order
        /// </summary>
        public ContourOrientation Orientation = ContourOrientation.Original;

        /// <summary>
        /// Base Spline
        /// </summary>
        public CurvySpline Spline;
        /// <summary>
        /// Vertex Calculation Mode
        /// </summary>
        public VertexCalculation VertexMode;
        /// <summary>
        /// Angle, used by VertexMode.ByAngle only
        /// </summary>
        public float Angle;
        /// <summary>
        /// Minimum distance, used by VertexMode.ByAngle only
        /// </summary>
        public float Distance;
        public Space Space;

        /// <summary>
        /// Creates a Spline2MeshCurve class using Spline2MeshCurve.VertexMode.ByApproximation
        /// </summary>
        public SplinePolyLine(CurvySpline spline) : this(spline, VertexCalculation.ByApproximation, 0, 0) { }
        /// <summary>
        /// Creates a Spline2MeshCurve class using Spline2MeshCurve.VertexMode.ByAngle
        /// </summary>
        public SplinePolyLine(CurvySpline spline, float angle, float distance) : this(spline, VertexCalculation.ByAngle, angle, distance) { }

        private SplinePolyLine(CurvySpline spline, VertexCalculation vertexMode, float angle, float distance, Space space = Space.World)
        {
            Spline = spline;
            VertexMode = vertexMode;
            Angle = angle;
            Distance = distance;
            Space = space;
        }
        /// <summary>
        /// Gets whether the spline is closed
        /// </summary>
        public bool IsClosed
        {
            get
            {
                return (Spline && Spline.Closed);
            }
        }

        /// <summary>
        /// Get vertices calculated using the current VertexMode
        /// </summary>
        /// <returns>an array of vertices</returns>
        [Obsolete("No more used in Curvy. Will get removed. Copy it if you still need it")]
        public Vector3[] GetVertices()
        {
            SubArray<Vector3> vertexList = GetVertexList();
            Vector3[] result = vertexList.CopyToArray(ArrayPools.Vector3);
            ArrayPools.Vector3.Free(vertexList);
            return result;
        }

        /// <summary>
        /// Get vertices calculated using the current VertexMode
        /// </summary>
        /// <returns>an array of vertices</returns>
        public SubArray<Vector3> GetVertexList()
        {
            SubArray<Vector3> points;
            switch (VertexMode)
            {
                case VertexCalculation.ByAngle:
                    points = GetPolygon(Spline, 0, 1, Angle, Distance, -1, false).ToSubArray();
                    break;
                default:
                    points = Spline.GetPositionsCache(Space.Self);
                    break;
            }

            if (Space == Space.World)
            {
                Vector3[] pointsArray = points.Array;
                int pointsCount = points.Count;
                for (int i = 0; i < pointsCount; i++)
                    pointsArray[i] = Spline.transform.TransformPoint(pointsArray[i]);
            }

            return points;
        }

        /// <summary>
        /// Gets an array of sampled points that follow some restrictions on the distance between two consecutive points, and the angle of tangents between those points
        /// </summary>
        /// <param name="fromTF">start TF</param>
        /// <param name="toTF">end TF</param>
        /// <param name="maxAngle">maximum angle in degrees between tangents</param>
        /// <param name="minDistance">minimum distance between two points</param>
        /// <param name="maxDistance">maximum distance between two points</param>
        /// <param name="vertexTF">Stores the TF of the resulting points</param>
        /// <param name="vertexTangents">Stores the Tangents of the resulting points</param>
        /// <param name="includeEndPoint">Whether the end position should be included</param>
        /// <param name="stepSize">the stepsize to use</param>
        /// <returns>an array of interpolated positions</returns>
        private static SubArrayList<Vector3> GetPolygon(CurvySpline spline, float fromTF, float toTF, float maxAngle, float minDistance, float maxDistance, bool includeEndPoint = true, float stepSize = 0.01f)
        {
            stepSize = Mathf.Clamp(stepSize, 0.002f, 1);
            maxDistance = (maxDistance == -1) ? spline.Length : Mathf.Clamp(maxDistance, 0, spline.Length);
            minDistance = Mathf.Clamp(minDistance, 0, maxDistance);
            if (!spline.Closed)
            {
                toTF = Mathf.Clamp01(toTF);
                fromTF = Mathf.Clamp(fromTF, 0, toTF);
            }
            SubArrayList<Vector3> vPos = new SubArrayList<Vector3>(50, ArrayPools.Vector3);

            int linearSteps = 0;
            float angleFromLast = 0;
            float distAccu = 0;
            Vector3 curPos = spline.Interpolate(fromTF);
            Vector3 curTangent = spline.GetTangent(fromTF);
            Vector3 lastPos = curPos;
            Vector3 lastTangent = curTangent;

            Action<Vector3> addPoint = ((position) =>
            {
                vPos.Add(position);
                angleFromLast = 0;
                distAccu = 0;

                linearSteps = 0;
            });

            addPoint(curPos);

            float tf = fromTF + stepSize;
            while (tf < toTF)
            {
                // Get Point Pos & Tangent
                spline.InterpolateAndGetTangent(tf % 1, out curPos, out curTangent);
                if (curTangent == Vector3.zero)
                {
                    Debug.Log("zero Tangent! Oh no!");
                }
                distAccu += (curPos - lastPos).magnitude;
                if (curTangent == lastTangent)
                    linearSteps++;
                if (distAccu >= minDistance)
                {
                    // Exceeding distance?
                    if (distAccu >= maxDistance)
                        addPoint(curPos);
                    else // Check angle
                    {
                        angleFromLast += Vector3.Angle(lastTangent, curTangent);
                        // Max angle reached or entering/leaving a linear zone
                        if (angleFromLast >= maxAngle || (linearSteps > 0 && angleFromLast > 0))
                            addPoint(curPos);
                    }
                }
                tf += stepSize;
                lastPos = curPos;
                lastTangent = curTangent;
            }
            if (includeEndPoint)
            {
                curPos = spline.Interpolate(toTF % 1);
                vPos.Add(curPos);
            }

            return vPos;
        }
    }
    #endregion
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyUtility.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/Base/SplineProcessor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7ad2b5fc1f2381b4eb677973a985c772
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using FluffyUnderware.DevTools;
using JetBrains.Annotations;
using UnityEngine;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Base class for components that process a spline to produce something else, a line renderer or an edge collider for example
    /// </summary>
    [ExecuteAlways]
    public abstract class SplineProcessor : DTVersionedMonoBehaviour
    {
        /// <summary>
        /// The source spline
        /// </summary>
        public CurvySpline Spline
        {
            get { return m_Spline; }
            set
            {
                if (m_Spline != value)
                {
                    UnbindEvents();
                    m_Spline = value;
                    BindEvents();
                    Refresh();
                }
            }
        }

        /// <summary>
        /// Method that processes the associated <see cref="CurvySpline"/>
        /// </summary>
        abstract public void Refresh();

        #region private

        /*! \cond PRIVATE */

        [SerializeField] protected CurvySpline m_Spline;

        /*! \endcond */

        private void OnSplineRefresh(CurvySplineEventArgs e)
        {
            ProcessEvent(e.Spline);
        }

        private void OnSplineCoordinatesChanged(CurvySpline spline)
        {
            ProcessEvent(spline);
        }

        private void ProcessEvent([NotNull] CurvySpline spline)
        {
            if (Spline != spline)
                UnbindEvents(spline);
            else
                Refresh();
        }

        #endregion

        #region protected

        #region Unity callbacks

        protected virtual void Awake()
        {
            if (m_Spline == null)
            {
                m_Spline = GetComponent<CurvySpline>();
                if (ReferenceEquals(m_Spline, null) == false)
                    DTLog.Log(String.Format("[Curvy] Spline '{0}' was assigned to the {1} by default.", this.name, this.GetType().Name), this);
            }
        }

        protected virtual void OnEnable()
        {
            BindEvents();
        }

        protected virtual void OnDisable()
        {
            UnbindEvents();
        }

#if UNITY_EDITOR
        protected virtual void OnValidate()
        {
            UnbindEvents();
            BindEvents();

            Refresh();
        }
#endif
        protected virtual void Start()
        {
            Refresh();
        }

        #endregion

        protected void BindEvents()
        {
            if (Spline)
            {
                Spline.OnRefresh.AddListenerOnce(OnSplineRefresh);
                Spline.OnGlobalCoordinatesChanged += OnSplineCoordinatesChanged;
            }
        }

        protected void UnbindEvents()
        {
            if (Spline)
                UnbindEvents(Spline);
        }

        private void UnbindEvents([NotNull] CurvySpline spline)
        {
            spline.OnRefresh.RemoveListener(OnSplineRefresh);
            spline.OnGlobalCoordinatesChanged -= OnSplineCoordinatesChanged;
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/Base/SplineProcessor.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyGlobalManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f7da6ae8fd39ffa439ccf96f0d3da992
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Pools;
using Object = UnityEngine.Object;


namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Curvy Global Scene Manager component
    /// </summary>
    [ExecuteInEditMode]
    [RequireComponent(typeof(PoolManager))]
    [RequireComponent(typeof(ArrayPoolsSettings))]
    [HelpURL(CurvySpline.DOCLINK + "curvyglobalmanager")]
    public class CurvyGlobalManager : DTSingleton<CurvyGlobalManager>
    {
        #region Do not move these

        //Do not move these. If they are moved to another file or lower in this file (bellow their usage by say DefaultGizmoColor), this issue will happen:
        // https://stackoverflow.com/questions/22927167/strange-behavior-on-static-members-of-a-class-hows-this-possible
        // https://github.com/RalfKoban/MiKo-Analyzers/issues/295

        /// <summary>
        /// Default value of the <see cref="DefaultGizmoColor"/> 
        /// </summary>
        public static readonly Color DefaultDefaultGizmoColor = new Color(0.71f, 0.71f, 0.71f);
        /// <summary>
        /// Default value of the <see cref="DefaultGizmoSelectionColor"/>
        /// </summary>
        public static readonly Color DefaultDefaultGizmoSelectionColor = new Color(0.6f, 0.15f, 0.68f);
        /// <summary>
        /// Default value of the <see cref="GizmoOrientationColor"/>
        /// </summary>
        public static readonly Color DefaultGizmoOrientationColor = new Color(0.75f, 0.75f, 0.4f);
        #endregion

        #region ### Public Static Fields (Editor->Runtime Bridge) ###
        public static bool HideManager = false;
        /// <summary>
        /// Whether the output of Curvy Generators should be saved in the scene file.
        /// Disable this option to reduce the size of scene files. This might increase the saving time for complex scenes.
        /// This option applies only on generators that are enabled and have Auto Refresh set to true
        /// </summary>
        public static bool SaveGeneratorOutputs = true;
        /// <summary>
        /// Resolution of SceneView spline rendering
        /// </summary>
        public static float SceneViewResolution = 0.5f;
        /// <summary>
        /// Default spline color
        /// </summary>
        public static Color DefaultGizmoColor = DefaultDefaultGizmoColor;
        /// <summary>
        /// Default selected spline color
        /// </summary>
        public static Color DefaultGizmoSelectionColor = DefaultDefaultGizmoSelectionColor;
        /// <summary>
        /// Default interpolation used by new splines
        /// </summary>
        public static CurvyInterpolation DefaultInterpolation = CurvyInterpolation.CatmullRom;
        /// <summary>
        /// Size of control point gizmos
        /// </summary>
        public static float GizmoControlPointSize = 0.15f;
        /// <summary>
        /// Size of orientation gizmo
        /// </summary>
        public static float GizmoOrientationLength = 1f;
        /// <summary>
        /// Orientation gizmo color
        /// </summary>
        public static Color GizmoOrientationColor = DefaultGizmoOrientationColor;
        public static int SplineLayer = 0;
        /// <summary>
        /// Default view settings
        /// </summary>
        public static CurvySplineGizmos Gizmos = CurvySplineGizmos.Curve | CurvySplineGizmos.Connections;

        public static bool ShowCurveGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Curve) == CurvySplineGizmos.Curve; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Curve;
                else
                    Gizmos &= ~CurvySplineGizmos.Curve;
            }
        }

        public static bool ShowConnectionsGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Connections) == CurvySplineGizmos.Connections; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Connections;
                else
                    Gizmos &= ~CurvySplineGizmos.Connections;
            }
        }

        public static bool ShowApproximationGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Approximation) == CurvySplineGizmos.Approximation; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Approximation;
                else
                    Gizmos &= ~CurvySplineGizmos.Approximation;
            }
        }

        public static bool ShowTangentsGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Tangents) == CurvySplineGizmos.Tangents; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Tangents;
                else
                    Gizmos &= ~CurvySplineGizmos.Tangents;
            }
        }

        public static bool ShowOrientationGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Orientation) == CurvySplineGizmos.Orientation; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Orientation;
                else
                    Gizmos &= ~CurvySplineGizmos.Orientation;
            }
        }

        public static bool ShowTFsGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.TFs) == CurvySplineGizmos.TFs; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.TFs;
                else
                    Gizmos &= ~CurvySplineGizmos.TFs;
            }
        }

        public static bool ShowRelativeDistancesGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.RelativeDistances) == CurvySplineGizmos.RelativeDistances; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.RelativeDistances;
                else
                    Gizmos &= ~CurvySplineGizmos.RelativeDistances;
            }
        }

        public static bool ShowLabelsGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Labels) == CurvySplineGizmos.Labels; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Labels;
                else
                    Gizmos &= ~CurvySplineGizmos.Labels;
            }
        }

        public static bool ShowMetadataGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Metadata) == CurvySplineGizmos.Metadata; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Metadata;
                else
                    Gizmos &= ~CurvySplineGizmos.Metadata;
            }
        }

        public static bool ShowBoundsGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Bounds) == CurvySplineGizmos.Bounds; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Bounds;
                else
                    Gizmos &= ~CurvySplineGizmos.Bounds;
            }
        }

        public static bool ShowOrientationAnchorsGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.OrientationAnchors) == CurvySplineGizmos.OrientationAnchors; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.OrientationAnchors;
                else
                    Gizmos &= ~CurvySplineGizmos.OrientationAnchors;
            }
        }

        #endregion

        #region ### Private Fields ###

        private PoolManager mPoolManager;
        private ComponentPool mControlPointPool;
        private ArrayPoolsSettings arrayPoolsSettings;
        #endregion

        #region ### Public Methods & Properties ###


        /// <summary>
        /// Gets the PoolManager
        /// </summary>
        public PoolManager PoolManager
        {
            get
            {
                if (mPoolManager == null)
                    mPoolManager = GetComponent<PoolManager>();
                return mPoolManager;
            }
        }

        public ComponentPool ControlPointPool
        {
            get
            {
                return mControlPointPool;
            }
        }

        public ArrayPoolsSettings ArrayPoolsSettings
        {
            get
            {
                if (arrayPoolsSettings == null)
                    arrayPoolsSettings = GetComponent<ArrayPoolsSettings>();
                return arrayPoolsSettings;
            }
        }

        /// <summary>
        /// Gets all connections in the scene
        /// </summary>
        public CurvyConnection[] Connections
        {
            get
            {
                return GetComponentsInChildren<CurvyConnection>();
            }
        }

        /// <summary>
        /// Returns all the connections that are exclusively connecting cps within the splines parameter
        /// </summary>
        /// <param name="splines"></param>
        /// <returns></returns>
        public CurvyConnection[] GetContainingConnections(params CurvySpline[] splines)
        {
            List<CurvyConnection> connectionsResult = new List<CurvyConnection>();
            List<CurvySpline> splinesList = new List<CurvySpline>(splines);
            foreach (CurvySpline spline in splinesList)
            {
                foreach (CurvySplineSegment controlPoint in spline.ControlPointsList)
                    if (controlPoint.Connection != null && !connectionsResult.Contains(controlPoint.Connection))
                    {
                        bool add = true;
                        // only process connections if all involved splines are part of the prefab
                        foreach (CurvySplineSegment connectedControlPoint in controlPoint.Connection.ControlPointsList)
                        {
                            if (connectedControlPoint.Spline != null && !splinesList.Contains(connectedControlPoint.Spline))
                            {
                                add = false;
                                break;
                            }
                        }
                        if (add)
                            connectionsResult.Add(controlPoint.Connection);
                    }
            }

            return connectionsResult.ToArray();
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */
        public override void Awake()
        {
            base.Awake();
            name = "_CurvyGlobal_";
            transform.SetAsLastSibling();
            // Unity 5.3 introduces buug that hides GameObject when calling this outside playmode!
            if (Application.isPlaying)
                Object.DontDestroyOnLoad(this);

            mPoolManager = GetComponent<PoolManager>();

            PoolSettings s = new PoolSettings()
            {
                MinItems = 0,
                Threshold = 50,
                Prewarm = true,
                AutoCreate = true,
                AutoEnableDisable = true
            };
            mControlPointPool = mPoolManager.CreateComponentPool<CurvySplineSegment>(s);

            arrayPoolsSettings = GetComponent<ArrayPoolsSettings>();
            //this is needed even though there is a [RequireComponent(typeof(ArrayPoolsSettings))] attribute, because that attribute works only at the moment the component is added, and does nothing for previously existing instances
            if (arrayPoolsSettings == null)
                arrayPoolsSettings = gameObject.AddComponent<ArrayPoolsSettings>();
        }

        private void Start()
        {
            if (HideManager)
                gameObject.hideFlags = HideFlags.HideInHierarchy;
            else
                gameObject.hideFlags = HideFlags.None;
        }

        /*! \endcond */
        #endregion

        #region ### Privates & Internals ###
        /*! \cond PRIVATE */

        [RuntimeInitializeOnLoadMethod]
        private static void LoadRuntimeSettings()
        {
            if (!PlayerPrefs.HasKey("Curvy_MaxCachePPU"))
                SaveRuntimeSettings();
            SceneViewResolution = DTUtility.GetPlayerPrefs("Curvy_SceneViewResolution", SceneViewResolution);
            HideManager = DTUtility.GetPlayerPrefs("Curvy_HideManager", HideManager);
            DefaultGizmoColor = DTUtility.GetPlayerPrefs("Curvy_DefaultGizmoColor", DefaultGizmoColor);
            DefaultGizmoSelectionColor = DTUtility.GetPlayerPrefs("Curvy_DefaultGizmoSelectionColor", DefaultGizmoColor);
            DefaultInterpolation = DTUtility.GetPlayerPrefs("Curvy_DefaultInterpolation", DefaultInterpolation);
            GizmoControlPointSize = DTUtility.GetPlayerPrefs("Curvy_ControlPointSize", GizmoControlPointSize);
            GizmoOrientationLength = DTUtility.GetPlayerPrefs("Curvy_OrientationLength", GizmoOrientationLength);
            GizmoOrientationColor = DTUtility.GetPlayerPrefs("Curvy_OrientationColor", GizmoOrientationColor);
            Gizmos = DTUtility.GetPlayerPrefs("Curvy_Gizmos", Gizmos);
            SplineLayer = DTUtility.GetPlayerPrefs("Curvy_SplineLayer", SplineLayer);
            SaveGeneratorOutputs = DTUtility.GetPlayerPrefs("Curvy_SaveGeneratorOutputs", SaveGeneratorOutputs);
        }

        public static void SaveRuntimeSettings()
        {
            //TODO some of these are not runtime settings at all, fix that
            DTUtility.SetPlayerPrefs("Curvy_SceneViewResolution", SceneViewResolution);
            DTUtility.SetPlayerPrefs("Curvy_HideManager", HideManager);
            DTUtility.SetPlayerPrefs("Curvy_DefaultGizmoColor", DefaultGizmoColor);
            DTUtility.SetPlayerPrefs("Curvy_DefaultGizmoSelectionColor", DefaultGizmoSelectionColor);
            DTUtility.SetPlayerPrefs("Curvy_DefaultInterpolation", DefaultInterpolation);
            DTUtility.SetPlayerPrefs("Curvy_ControlPointSize", GizmoControlPointSize);
            DTUtility.SetPlayerPrefs("Curvy_OrientationLength", GizmoOrientationLength);
            DTUtility.SetPlayerPrefs("Curvy_OrientationColor", GizmoOrientationColor);
            DTUtility.SetPlayerPrefs("Curvy_Gizmos", Gizmos);
            DTUtility.SetPlayerPrefs("Curvy_SplineLayer", SplineLayer);
            DTUtility.SetPlayerPrefs("Curvy_SaveGeneratorOutputs", SaveGeneratorOutputs);
            PlayerPrefs.Save();
        }



        public override void MergeDoubleLoaded(IDTSingleton newInstance)
        {
            base.MergeDoubleLoaded(newInstance);

            CurvyGlobalManager other = newInstance as CurvyGlobalManager;
            // Merge connection from a doubled CurvyGlobalManager before it get destroyed by DTSingleton
            CurvyConnection[] otherConnections = other.Connections;
            for (int i = 0; i < otherConnections.Length; i++)
                otherConnections[i].transform.SetParent(this.transform);
        }


        /*! \endcond */
        #endregion



    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyGlobalManager.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyGLRenderer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d025f1b57fec5ca4f8585046c3fd23c8
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.DevTools;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Pools;
using ToolBuddy.Pooling.Collections;
using ToolBuddy.Pooling.Pools;
// =====================================================================
// Copyright 2013-2014 FluffyUnderware
// All rights reserved
// =====================================================================
using UnityEngine;
/* Renders curvy spline(s) approximation using GL.Draw
 * 
 * Add this script to a camera
 */

namespace FluffyUnderware.Curvy.Components
{

    /// <summary>
    /// Class to render a spline using GL.Draw
    /// </summary>
    /// <remarks>Useful for debugging</remarks>
    [HelpURL(CurvySpline.DOCLINK + "curvyglrenderer")]
    [AddComponentMenu("Curvy/Misc/Curvy GL Renderer")]
    public class CurvyGLRenderer : DTVersionedMonoBehaviour
    {
        [ArrayEx(ShowAdd = false, Draggable = false)]
        public List<GLSlotData> Splines = new List<GLSlotData>();

        private Material lineMaterial;

        private void CreateLineMaterial()
        {
            if (!lineMaterial)
            {
#if UNITY_5_0 || UNITY_4_6
                lineMaterial = new Material("Shader \"Lines/Colored Blended\" {" +
                    "SubShader { Pass { " +
                    "    Blend SrcAlpha OneMinusSrcAlpha " +
                    "    ZWrite Off Cull Off Fog { Mode Off } " +
                    "    BindChannels {" +
                    "      Bind \"vertex\", vertex Bind \"color\", color }" +
                    "} } }");
                    
#else
                lineMaterial = new Material(Shader.Find("Hidden/Internal-Colored"));
#endif
                lineMaterial.hideFlags = HideFlags.HideAndDontSave;
                lineMaterial.shader.hideFlags = HideFlags.HideAndDontSave;
            }
        }

#if UNITY_EDITOR
        private void OnValidate()
        {
            sanitize();
        }
#endif

        private void OnPostRender()
        {
            sanitize();
            CreateLineMaterial();
            for (int i = Splines.Count - 1; i >= 0; i--)
            {
                Splines[i].Spline.OnRefresh.AddListenerOnce(OnSplineRefresh);
                if (Splines[i].VertexData.Count == 0)
                    Splines[i].GetVertexData();

                Splines[i].Render(lineMaterial);
            }

        }

        private void sanitize()
        {
            for (int i = Splines.Count - 1; i >= 0; i--)
                if (Splines[i] == null || Splines[i].Spline == null)
                    Splines.RemoveAt(i);
        }

        private void OnSplineRefresh(CurvySplineEventArgs e)
        {
            GLSlotData slot = getSlot((CurvySpline)e.Sender);
            if (slot == null)
                ((CurvySpline)e.Sender).OnRefresh.RemoveListener(OnSplineRefresh);
            else
                slot.VertexData.Clear();
        }

        private GLSlotData getSlot(CurvySpline spline)
        {
            if (spline)
            {
                foreach (GLSlotData slot in Splines)
                    if (slot.Spline == spline)
                        return slot;
            }
            return null;
        }

        public void Add(CurvySpline spline)
        {
            if (spline != null)
                Splines.Add(new GLSlotData() { Spline = spline });
        }

        public void Remove(CurvySpline spline)
        {
            for (int i = Splines.Count - 1; i >= 0; i--)
                if (Splines[i].Spline == spline)
                    Splines.RemoveAt(i);
        }

    }

    /// <summary>
    /// Helper class used by CurvyGLRenderer
    /// </summary>
    [System.Serializable]
    public class GLSlotData
    {
        [SerializeField]
        public CurvySpline Spline;
        public Color LineColor = CurvyGlobalManager.DefaultGizmoColor;
        public List<Vector3[]> VertexData = new List<Vector3[]>();

        public void GetVertexData()
        {

            VertexData.Clear();
            List<CurvySpline> splines = new List<CurvySpline>
            {
                Spline
            };

            ArrayPool<Vector3> vector3ArrayPool = ArrayPools.Vector3;

            for (int i = 0; i < splines.Count; i++)
                if (splines[i].IsInitialized)
                {
                    SubArray<Vector3> positionsCache = splines[i].GetPositionsCache(Space.World);
                    //OPTIM avoid the CopyToArray call, make the class work with SubArrays
                    VertexData.Add(positionsCache.CopyToArray(vector3ArrayPool));
                    vector3ArrayPool.Free(positionsCache);
                }
        }

        public void Render(Material mat)
        {
            for (int i = 0; i < VertexData.Count; i++)
                if (VertexData[i].Length > 0)
                {
                    mat.SetPass(0);
                    GL.Begin(GL.LINES);
                    GL.Color(LineColor);
                    for (int v = 1; v < VertexData[i].Length; v++)
                    {
                        GL.Vertex(VertexData[i][v - 1]);
                        GL.Vertex(VertexData[i][v]);
                    }
                    GL.End();
                }
        }
    }


}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyGLRenderer.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyLineRenderer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f2d74ea90b9d85945b180cf66c7c0f6b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.Curvy.Pools;
using UnityEngine;
using FluffyUnderware.DevTools;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Components
{
    /// <summary>
    /// Class to drive a LineRenderer with a CurvySpline
    /// </summary>
    [AddComponentMenu(ComponentPath)]
    [RequireComponent(typeof(LineRenderer))]
    [HelpURL(CurvySpline.DOCLINK + "curvylinerenderer")]
    public class CurvyLineRenderer : SplineProcessor
    {
        public const string ComponentPath = "Curvy/Converters/Curvy Line Renderer";

        private LineRenderer mRenderer;

        protected override void Awake()
        {
            mRenderer = GetComponent<LineRenderer>();
            base.Awake();
        }

        protected override void OnEnable()
        {
            mRenderer = GetComponent<LineRenderer>();
            base.OnEnable();
        }

        private void Update()
        {
            EnforceWorldSpaceUsage();
        }

        private void EnforceWorldSpaceUsage()
        {
            if (mRenderer.useWorldSpace == false)
            {
                mRenderer.useWorldSpace = true;
                DTLog.Log("[Curvy] CurvyLineRenderer: Line Renderer's Use World Space was overriden to true", this);
            }
        }

        /// <summary>
        /// Update the <see cref="LineRenderer"/>'s points with the cache points of the <see cref="CurvySpline"/>
        /// </summary>
        public override void Refresh()
        {
            if (Spline)
            {
                if (Spline.IsInitialized && Spline.Dirty == false)
                {
#if CURVY_SANITY_CHECKS
                    Assert.IsTrue(mRenderer != null);
#endif
                    EnforceWorldSpaceUsage();
                    SubArray<Vector3> positions = Spline.GetPositionsCache(Space.World);
                    mRenderer.positionCount = positions.Count;
                    mRenderer.SetPositions(positions.Array);
                    ArrayPools.Vector3.Free(positions);
                }
                else if (mRenderer != null)
                {
                    EnforceWorldSpaceUsage();
                    mRenderer.positionCount = 0;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyLineRenderer.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvySplineToEdgeCollider2D.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b69e477d494cd7d4197144300b3a3a51
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using FluffyUnderware.Curvy.Pools;
using UnityEngine;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Converts a <see cref="CurvySpline"/> to an <see cref="EdgeCollider2D"/> 
    /// </summary>
    [AddComponentMenu(ComponentPath)]
    [RequireComponent(typeof(EdgeCollider2D))]
    [HelpURL(CurvySpline.DOCLINK + "edgecollider2d")]
    public class CurvySplineToEdgeCollider2D : SplineProcessor
    {
        public const string ComponentPath = "Curvy/Converters/Curvy Spline To Edge Collider 2D";

        private EdgeCollider2D edgeCollider2D;

        protected override void Awake()
        {
            edgeCollider2D = GetComponent<EdgeCollider2D>();
            base.Awake();
        }

        protected override void OnEnable()
        {
            edgeCollider2D = GetComponent<EdgeCollider2D>();
            base.OnEnable();
        }

        /// <summary>
        /// Update the <see cref="EdgeCollider2D.points"/> with the cache points of the <see cref="CurvySpline"/>
        /// </summary>
        public override void Refresh()
        {
            if (Spline)
            {
                if (Spline.IsInitialized && Spline.Dirty == false)
                {
#if CURVY_SANITY_CHECKS
                    Assert.IsTrue(edgeCollider2D != null);
#endif
                    SubArray<Vector3> positions = Spline.GetPositionsCache(Space.Self);
                    SubArray<Vector2> positions2D = ArrayPools.Vector2.AllocateExactSize(positions.Count);
                    Vector3[] positionsArray = positions.Array;
                    Vector2[] positions2DArray = positions2D.Array;
                    for (var i = 0; i < positions.Count; i++)
                    {
                        positions2DArray[i].x = positionsArray[i].x;
                        positions2DArray[i].y = positionsArray[i].y;
                    }
                    edgeCollider2D.points = positions2DArray;
                    ArrayPools.Vector2.Free(positions2D);
                    ArrayPools.Vector3.Free(positions);
                }
                else if (edgeCollider2D != null)
                {
                    edgeCollider2D.points = Array.Empty<Vector2>();
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvySplineToEdgeCollider2D.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/NearestSplinePoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a062b6bd68605bc4fb191834584d2d0d
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.DevTools;
using UnityEngine;
using UnityEditor;
using UnityEngine.Events;

namespace FluffyUnderware.Curvy
{

    /// <summary>
    /// Given a <see cref="CurvySpline"/> and an input position, this class will provide you with the nearest point to that position on the given spline.
    /// The nearest position is provided either in an <see cref="OnUpdated"/> event, or as an override of the position of the <see cref="TargetPosition"/>
    /// </summary>
    /// <remarks>This script simply calls the <see cref="CurvySpline.GetNearestPoint"/> method. If you are a programmer, you don't need to go through this script, just call <see cref="CurvySpline.GetNearestPoint"/></remarks>
    [HelpURL(CurvySpline.DOCLINK + "nearestsplinepoint")]
    [AddComponentMenu("Curvy/Misc/Nearest Spline Point")]
    [ExecuteAlways]
    public class NearestSplinePoint : MonoBehaviour
    {
        /// <summary>
        /// The <see cref="CurvySpline"/> on which the nearest position is searched for
        /// </summary>
        [Tooltip("The spline on which the nearest position is searched for")]
        public CurvySpline Spline;
        /// <summary>
        /// A transform which position will be used as the input position for the lookup
        /// </summary>
        [Tooltip("A transform which position will be used as the input position for the lookup")]
        public Transform SourcePosition;
        /// <summary>
        /// A transform which position will be updated with the nearest point on Spline to Source Position
        /// </summary>
        [Tooltip("A transform which position will be updated with the nearest point on Spline to Source Position")]
        public Transform TargetPosition;
        /// <summary>
        /// When to run the lookup
        /// </summary>
        [Tooltip("When to run the lookup")]
        public CurvyUpdateMethod UpdateIn;
        /// <summary>
        /// At each update, this event is called with the result of the lookup
        /// </summary>
        [Tooltip("At each update, this event is called with the result of the lookup")]
        public UnityEventEx<Vector3> OnUpdated = new UnityEventEx<Vector3>();

        private void Process()
        {
            if (SourcePosition && Spline && Spline.IsInitialized && Spline.Dirty == false)
            {
                Vector3 destinationPosition = Spline.GetNearestPoint(SourcePosition.position, Space.Self);
                if (TargetPosition)
                    TargetPosition.position = destinationPosition;
                OnUpdated?.Invoke(destinationPosition);
            }
        }

        #region Updating methods

#if UNITY_EDITOR
        private void Update()
        {
            if (UpdateIn == CurvyUpdateMethod.Update)
                Process();
        }

        private void LateUpdate()
        {
            if (UpdateIn == CurvyUpdateMethod.LateUpdate ||
                (Application.isPlaying == false && UpdateIn == CurvyUpdateMethod.FixedUpdate)) // In edit mode, fixed updates are not called, so we update here instead
                Process();
        }

        private void FixedUpdate()
        {
            if (UpdateIn == CurvyUpdateMethod.FixedUpdate)
                Process();
        }

        protected virtual void OnEnable()
        {
            EditorApplication.update += OnEditorUpdate;
        }

        protected virtual void OnDisable()
        {
            EditorApplication.update -= OnEditorUpdate;
        }

        private void OnEditorUpdate()
        {
            if (Application.isPlaying == false)
                Process();
        }
#endif

        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/NearestSplinePoint.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Pools/ArrayPools.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e950a29ae4d3e4f40b03ecd2271da862
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.Curvy.Generator;
using ToolBuddy.Pooling;
using ToolBuddy.Pooling.Pools;
using UnityEngine;

namespace FluffyUnderware.Curvy.Pools
{
    /// <summary>
    /// A class which sole purpose is to centralize references to the various <see cref="ArrayPool{T}"/>s instances
    /// </summary>
    public static class ArrayPools
    {
        static ArrayPools()
        {
            Int32 = ArrayPoolsProvider.GetPool<int>();
            Single = ArrayPoolsProvider.GetPool<float>();
            Vector2 = ArrayPoolsProvider.GetPool<Vector2>();
            Vector3 = ArrayPoolsProvider.GetPool<Vector3>();
            Vector4 = ArrayPoolsProvider.GetPool<Vector4>();
            CGSpot = ArrayPoolsProvider.GetPool<CGSpot>();
        }

        /// <summary>
        /// Gets the reference to the unique <see cref="ArrayPool{T}"/> of said type
        /// </summary>
        public static ArrayPool<Vector2> Vector2 { get; }
        /// <summary>
        /// Gets the reference to the unique <see cref="ArrayPool{T}"/> of said type
        /// </summary>
        public static ArrayPool<Vector3> Vector3 { get; }
        /// <summary>
        /// Gets the reference to the unique <see cref="ArrayPool{T}"/> of said type
        /// </summary>
        public static ArrayPool<Vector4> Vector4 { get; }
        /// <summary>
        /// Gets the reference to the unique <see cref="ArrayPool{T}"/> of said type
        /// </summary>
        public static ArrayPool<int> Int32 { get; }
        /// <summary>
        /// Gets the reference to the unique <see cref="ArrayPool{T}"/> of said type
        /// </summary>
        public static ArrayPool<float> Single { get; }
        /// <summary>
        /// Gets the reference to the unique <see cref="ArrayPool{T}"/> of said type
        /// </summary>
        public static ArrayPool<CGSpot> CGSpot { get; }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Pools/ArrayPools.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Pools/ArrayPoolsSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6fd1ed065a5ad4241ade72657b4c6e4b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using FluffyUnderware.DevTools;
using ToolBuddy.Pooling.Pools;
using UnityEngine;

namespace FluffyUnderware.Curvy.Pools
{
    /// <summary>
    /// A component that allows setting, via the editor, the settings of the used <see cref="ToolBuddy.Pooling.Pools.ArrayPool{T}"/>s
    /// </summary>
    [HelpURL(DTUtility.HelpUrlBase + "arraypoolsettings")]
    [ExecuteAlways]
    [DisallowMultipleComponent]
    public class ArrayPoolsSettings : DTVersionedMonoBehaviour
    {
        [SerializeField]
        [Tooltip("The maximal number of elements of type Vector2 allowed to be stored in the arrays' pool waiting to be reused")]
        private long vector2Capacity = 100_000;

        [SerializeField]
        [Tooltip("The maximal number of elements of type Vector3 allowed to be stored in the arrays' pool waiting to be reused")]
        private long vector3Capacity = 100_000;

        [SerializeField]
        [Tooltip("The maximal number of elements of type Vector4 allowed to be stored in the arrays' pool waiting to be reused")]
        private long vector4Capacity = 100_000;

        [SerializeField]
        [Tooltip("The maximal number of elements of type Int32 allowed to be stored in the arrays' pool waiting to be reused")]
        private long intCapacity = 100_000;

        [SerializeField]
        [Tooltip("The maximal number of elements of type Single (a.k.a float) allowed to be stored in the arrays' pool waiting to be reused")]
        private long floatCapacity = 10_000;

        [SerializeField]
        [Tooltip("The maximal number of elements of type CGSpots allowed to be stored in the arrays' pool waiting to be reused")]
        private long cgSpotCapacity = 10_000;
        
        [Tooltip("Log in the console each time an array pool allocates a new array in memory")]
        [SerializeField]
        private bool logAllocations = false;

        /// <summary>
        /// The maximal number of elements of type Vector2 allowed to be stored in the arrays' pool waiting to be reused
        /// </summary>
        public long Vector2Capacity
        {
            get { return vector2Capacity; }
            set
            {
                vector2Capacity = Math.Max(0, value);
                ArrayPools.Vector2.ElementsCapacity = vector2Capacity;

            }
        }

        /// <summary>
        /// The maximal number of elements of type Vector3 allowed to be stored in the arrays' pool waiting to be reused
        /// </summary>
        public long Vector3Capacity
        {
            get { return vector3Capacity; }
            set
            {
                vector3Capacity = Math.Max(0, value);
                ArrayPools.Vector3.ElementsCapacity = vector3Capacity;
            }
        }

        /// <summary>
        /// The maximal number of elements of type Vector4 allowed to be stored in the arrays' pool waiting to be reused
        /// </summary>
        public long Vector4Capacity
        {
            get { return vector4Capacity; }
            set
            {
                vector4Capacity = Math.Max(0, value);
                ArrayPools.Vector4.ElementsCapacity = vector4Capacity;
            }
        }

        /// <summary>
        /// The maximal number of elements of type Int32 allowed to be stored in the arrays' pool waiting to be reused
        /// </summary>
        public long IntCapacity
        {
            get { return intCapacity; }
            set
            {
                intCapacity = Math.Max(0, value);
                ArrayPools.Int32.ElementsCapacity = IntCapacity;
            }
        }

        /// <summary>
        /// The maximal number of elements of type Single allowed to be stored in the arrays' pool waiting to be reused
        /// </summary>
        public long FloatCapacity
        {
            get { return floatCapacity; }
            set
            {
                floatCapacity = Math.Max(0, value);
                ArrayPools.Single.ElementsCapacity = floatCapacity;
            }
        }

        /// <summary>
        /// The maximal number of elements of type CGSpot allowed to be stored in the arrays' pool waiting to be reused
        /// </summary>
        public long CGSpotCapacity
        {
            get { return cgSpotCapacity; }
            set
            {
                cgSpotCapacity = Math.Max(0, value);
                ArrayPools.CGSpot.ElementsCapacity = cgSpotCapacity;
            }
        }
        /// <summary>
        /// Log in the console each time an array pool allocates a new array in memory
        /// </summary>
        public bool LogAllocations
        {
            get { return logAllocations; }
            set
            {
                logAllocations = value;
                ArrayPools.CGSpot.LogAllocations = logAllocations;
                ArrayPools.Int32.LogAllocations = logAllocations;
                ArrayPools.Single.LogAllocations = logAllocations;
                ArrayPools.Vector2.LogAllocations = logAllocations;
                ArrayPools.Vector3.LogAllocations = logAllocations;
                ArrayPools.Vector4.LogAllocations = logAllocations;
            }
        }

        private void Reset() => ValidateAndApply();

        private void OnValidate() => ValidateAndApply();

        private void Awake() => ValidateAndApply();

        private void OnEnable()
        {
#if UNITY_EDITOR
            if (FindObjectsOfType<ArrayPoolsSettings>().Length > 1)
                DTLog.LogWarning("[Curvy] More than one instance of 'Array Pools Settings' detected. You should keep only one instance of this script.", this);
#endif
            ValidateAndApply();
        }

        private void Start() => ValidateAndApply();

        private void ValidateAndApply()
        {
            Vector2Capacity = vector2Capacity;
            Vector3Capacity = vector3Capacity;
            Vector4Capacity = vector4Capacity;
            IntCapacity = intCapacity;
            FloatCapacity = floatCapacity;
            CGSpotCapacity = cgSpotCapacity;
            LogAllocations = logAllocations;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Pools/ArrayPoolsSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSCircle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: db925cc84d8129f40818e17a75bc7ef3
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Shapes
{
    /// <summary>
    /// Circle Shape (2D)
    /// </summary>
    [CurvyShapeInfo("2D/Circle")]
    [RequireComponent(typeof(CurvySpline))]
    [AddComponentMenu("Curvy/Shapes/Circle")]
    public class CSCircle : CurvyShape2D
    {
        [Positive(Tooltip="Number of Control Points")]
        [SerializeField]
        private int m_Count=4;
        public int Count
        {
            get { return m_Count; }
            set
            {
                int v = Mathf.Max(2, value);
                if (m_Count != v)
                {
                    m_Count = v;
                    Dirty = true;
                }
            }
        }

        [SerializeField] private float m_Radius = 1;
        public float Radius
        {
            get { return m_Radius;}
            set 
            {
                float v = Mathf.Max(0, value);
                if (m_Radius != v)
                {
                    m_Radius = v;
                    Dirty = true;
                }
            }
        }


#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Count = m_Count;
            Radius = m_Radius;
        }
#endif

        protected override void Reset()
        {
            base.Reset();
            Count = 4;
            Radius = 1;
        }

        protected override void ApplyShape()
        {
            PrepareSpline(CurvyInterpolation.Bezier);
            PrepareControlPoints(Count);
            float d = 360f * Mathf.Deg2Rad / Count;
            for (int i = 0; i < Count; i++)
                Spline.ControlPointsList[i].transform.localPosition = new Vector3(Mathf.Sin(d * i) * Radius, Mathf.Cos(d * i) * Radius, 0);
        }

      


       

    }


}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSCircle.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSPie.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 11531ee0acb05f147a569dab22766734
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Shapes
{
    /// <summary>
    /// Pie Shape (2D)
    /// </summary>
    [CurvyShapeInfo("2D/Pie")]
    [RequireComponent(typeof(CurvySpline))]
    [AddComponentMenu("Curvy/Shapes/Pie")]
    public class CSPie : CSCircle
    {

        [Range(0, 1)]
        [SerializeField]
        private float m_Roundness = 1f;
        public float Roundness
        {
            get { return m_Roundness; }
            set
            {
                float v = Mathf.Clamp01(value);
                if (m_Roundness != v)
                {
                    m_Roundness = v;
                    Dirty = true;
                }

            }
        }

        public enum EatModeEnum
        {
            Left,
            Right,
            Center
        }

        [SerializeField]
        [RangeEx(0, nameof(maxEmpty), "Empty", "Number of empty slices")]
        private int m_Empty = 1;
        public int Empty
        {
            get { return m_Empty; }
            set
            {
                int v = Mathf.Clamp(value, 0, maxEmpty);
                if (m_Empty != v)
                {
                    m_Empty = v;
                    Dirty = true;
                }
            }
        }

        private int maxEmpty { get { return Count; } }

        [Label(Tooltip = "Eat Mode")]
        [SerializeField]
        private EatModeEnum m_Eat = EatModeEnum.Right;
        public EatModeEnum Eat
        {
            get { return m_Eat; }
            set
            {
                if (m_Eat != value)
                {
                    m_Eat = value;
                    Dirty = true;
                }
            }
        }



#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Empty = m_Empty;
            Eat = m_Eat;
            Roundness = m_Roundness;
        }
#endif

        protected override void Reset()
        {
            base.Reset();
            Roundness = 1f;
            Empty = 1;
            Eat = EatModeEnum.Right;
        }

        private Vector3 cpPosition(int i, int empty, float d)
        {
            switch (Eat)
            {
                case EatModeEnum.Left:
                    return new Vector3(Mathf.Sin(d * i) * Radius, Mathf.Cos(d * i) * Radius, 0);
                case EatModeEnum.Right:
                    return new Vector3(Mathf.Sin(d * (i + empty)) * Radius, Mathf.Cos(d * (i + empty)) * Radius, 0);
                default:
                    return new Vector3(Mathf.Sin(d * (i + empty * 0.5f)) * Radius, Mathf.Cos(d * (i + empty * 0.5f)) * Radius, 0);
            }
        }

        protected override void ApplyShape()
        {
            PrepareSpline(CurvyInterpolation.Bezier, CurvyOrientation.Dynamic);
            PrepareControlPoints(Count - Empty + 2);

            float d = 360f * Mathf.Deg2Rad / Count;
            float distPercent = Roundness * 0.39f;

            for (int i = 0; i < Spline.ControlPointCount - 1; i++)
            {
                Spline.ControlPointsList[i].AutoHandles = true;
                Spline.ControlPointsList[i].AutoHandleDistance = distPercent;
                SetPosition(i, cpPosition(i, Empty, d));
            }


            // Center
            SetPosition(Spline.ControlPointCount - 1, Vector3.zero);
            SetBezierHandles(Spline.ControlPointCount - 1, 0);

            // From Center
            Spline.ControlPointsList[0].AutoHandles = false;
            Spline.ControlPointsList[0].HandleIn = Vector3.zero;
            Spline.ControlPointsList[0].SetBezierHandles(distPercent,
                                                     cpPosition(Count - 1, Empty, d) - Spline.ControlPointsList[0].transform.localPosition,
                                                     cpPosition(1, Empty, d) - Spline.ControlPointsList[0].transform.localPosition, false, true);

            // To Center
            Spline.ControlPointsList[Spline.ControlPointCount - 2].AutoHandles = false;
            Spline.ControlPointsList[Spline.ControlPointCount - 2].HandleOut = Vector3.zero;
            Spline.ControlPointsList[Spline.ControlPointCount - 2].SetBezierHandles(distPercent,
                                                     cpPosition(Count - 1 - Empty, Empty, d) - Spline.ControlPointsList[Spline.ControlPointCount - 2].transform.localPosition,
                                                     cpPosition(Count + 1 - Empty, Empty, d) - Spline.ControlPointsList[Spline.ControlPointCount - 2].transform.localPosition, true, false);

        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSPie.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSRectangle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eb08e1dcb0ad99946b5fa3f2aab502ab
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Shapes
{
    /// <summary>
    /// Rectangle Shape (2D)
    /// </summary>
    [CurvyShapeInfo("2D/Rectangle")]
    [RequireComponent(typeof(CurvySpline))]
    [AddComponentMenu("Curvy/Shapes/Rectangle")]
    public class CSRectangle : CurvyShape2D
    {
        [Positive]
        [SerializeField]
        private float m_Width = 1;
        public float Width
        {
            get { return m_Width; }
            set 
            {
                float v = Mathf.Max(0, value);
                if (m_Width != v)
                {
                    m_Width = v;
                    Dirty = true;
                }
            }
        }
        [Positive]
        [SerializeField]
        private float m_Height = 1;
        public float Height
        {
            get { return m_Height; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_Height != v)
                {
                    m_Height = v;
                    Dirty = true;
                }
            }
        }

        protected override void Reset()
        {
            base.Reset();
            Width = 1;
            Height = 1;
        }

        protected override void ApplyShape()
        {
            base.ApplyShape();
            PrepareSpline(CurvyInterpolation.Linear, CurvyOrientation.Dynamic,1, true);
            PrepareControlPoints(4);
            float hw = Width / 2;
            float hh = Height / 2;
            SetCGHardEdges();
            
            SetPosition(0,new Vector3(-hw, -hh));
            SetPosition(1,new Vector3(-hw, hh));
            SetPosition(2,new Vector3(hw, hh));
            SetPosition(3,new Vector3(hw, -hh));
        }


#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Width = m_Width;
            Height = m_Height;
        }
#endif

      
      
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSRectangle.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSRoundedRectangle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 40c554b1636af874788a322143049112
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Shapes
{
    /// <summary>
    /// Rounded Rectangle (2D)
    /// </summary>
    [CurvyShapeInfo("2D/Rounded Rectangle")]
    [RequireComponent(typeof(CurvySpline))]
    [AddComponentMenu("Curvy/Shapes/Rounded Rectangle")]
    public class CSRoundedRectangle : CurvyShape2D
    {
        [Positive]
        [SerializeField]
        private float m_Width = 1;
        public float Width
        {
            get { return m_Width; }
            set
            {
                float v = Mathf.Max(0, value); ;
                if (m_Width != v)
                {
                    m_Width = v;
                    Dirty = true;
                }
            }
        }
        [Positive]
        [SerializeField]
        private float m_Height = 1;
        public float Height
        {
            get { return m_Height; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_Height != v)
                {
                    m_Height = v;
                    Dirty = true;
                }
            }
        }

        [Range(0, 1)]
        [SerializeField]
        private float m_Roundness = 0.5f;
        public float Roundness
        {
            get { return m_Roundness; }
            set
            {
                float v = Mathf.Clamp01(value);
                if (m_Roundness != v)
                {
                    m_Roundness = v;
                    Dirty = true;
                }
            }
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Width = m_Width;
            Height = m_Height;
            Roundness = m_Roundness;
        }
#endif

        protected override void Reset()
        {
            base.Reset();
            Width = 1;
            Height = 1;
            Roundness = 0.5f;
        }

        protected override void ApplyShape()
        {
            PrepareSpline(CurvyInterpolation.Bezier);
            bool isSquare = Roundness == 0;
            PrepareControlPoints(isSquare ? 4 : 8);

            float hw = Width / 2;
            float hh = Height / 2;

            if (isSquare)
            {
                SetPosition(0, new Vector3(-hw, -hh));
                SetPosition(1, new Vector3(-hw, hh));
                SetPosition(2, new Vector3(hw, hh));
                SetPosition(3, new Vector3(hw, -hh));

                SetBezierHandles(0, Vector3.zero, Vector3.zero, Space.Self);
                SetBezierHandles(1, Vector3.zero, Vector3.zero, Space.Self);
                SetBezierHandles(2, Vector3.zero, Vector3.zero, Space.Self);
                SetBezierHandles(3, Vector3.zero, Vector3.zero, Space.Self);
            }
            else
            {
                float off = Mathf.Min(hw, hh) * Roundness;
                SetPosition(0, new Vector3(-hw, -hh + off));
                SetPosition(1, new Vector3(-hw, hh - off));
                SetPosition(2, new Vector3(-hw + off, hh));
                SetPosition(3, new Vector3(hw - off, hh));
                SetPosition(4, new Vector3(hw, hh - off));
                SetPosition(5, new Vector3(hw, -hh + off));
                SetPosition(6, new Vector3(hw - off, -hh));
                SetPosition(7, new Vector3(-hw + off, -hh));

                SetBezierHandles(0, Vector3.down * off, Vector3.zero, Space.Self);
                SetBezierHandles(1, Vector3.zero, Vector3.up * off, Space.Self);
                SetBezierHandles(2, Vector3.left * off, Vector3.right * off, Space.Self);
                SetBezierHandles(3, Vector3.zero, Vector3.right * off, Space.Self);
                SetBezierHandles(4, Vector3.up * off, Vector3.zero, Space.Self);
                SetBezierHandles(5, Vector3.zero, Vector3.down * off, Space.Self);
                SetBezierHandles(6, Vector3.right * off, Vector3.zero, Space.Self);
                SetBezierHandles(7, Vector3.zero, Vector3.left * off, Space.Self);
            }

        }



    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSRoundedRectangle.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSSpiral.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 78fe27cadd58631478ff940cc42687c1
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Shapes
{
    /// <summary>
    /// Spiral Spline Shape
    /// </summary>
    [CurvyShapeInfo("3D/Spiral",false)]
    [RequireComponent(typeof(CurvySpline))]
    [AddComponentMenu("Curvy/Shapes/Spiral")]
    public class CSSpiral : CurvyShape2D
    {
        [Positive(Tooltip = "Number of Control Points per full Circle")]
        [SerializeField]
        private int m_Count = 8;
        public int Count
        {
            get { return m_Count; }
            set
            {
                int v = Mathf.Max(0, value);
                if (m_Count != v)
                {
                    m_Count = v;
                    Dirty = true;   
                }
            }
        }

        [Positive(Tooltip = "Number of Full Circles")]
        [SerializeField]
        private float m_Circles = 3;
        public float Circles
        {
            get { return m_Circles; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_Circles != v)
                {
                    m_Circles = v;
                    Dirty = true;
                }
            }
        }

        [Positive(Tooltip="Base Radius")]
        [SerializeField]
        private float m_Radius = 5;
        public float Radius
        {
            get { return m_Radius; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_Radius != v)
                {
                    m_Radius = v;
                    Dirty = true;
                }
            }
        }

        [Label(Tooltip="Radius Multiplicator")]
        [SerializeField]
        private AnimationCurve m_RadiusFactor = AnimationCurve.Linear(0, 1, 1, 1);
        public AnimationCurve RadiusFactor
        {
            get { return m_RadiusFactor; }
            set
            {
                if (m_RadiusFactor != value)
                {
                    m_RadiusFactor = value;
                    Dirty = true;
                }
            }
        }

        [SerializeField] private AnimationCurve m_Z = AnimationCurve.Linear(0, 0f, 1, 10f);
        public AnimationCurve Z
        {
            get { return m_Z; }
            set
            {
                if (m_Z != value)
                {
                    m_Z = value;
                    Dirty = true;
                }
            }
        }


        protected override void Reset()
        {
 	         base.Reset();
            Count=8;
            Circles=3;
            Radius=5;
            RadiusFactor=AnimationCurve.Linear(0,1,1,1);
            Z=AnimationCurve.Linear(0,0,1,10);
        }

        protected override void ApplyShape()
        {
            PrepareSpline(CurvyInterpolation.CatmullRom, CurvyOrientation.Dynamic, 50, false);
            Spline.RestrictTo2D = false;
            int cpCount = Mathf.FloorToInt(Count * Circles);
            PrepareControlPoints(cpCount);
            if (cpCount == 0)
                return;
            float d = 360f * Mathf.Deg2Rad / Count;
            
            for (int i = 0; i < cpCount; i++)
            {
                float frag = i / (float)cpCount;
                float rad = Radius * RadiusFactor.Evaluate(frag);
                SetPosition(i,new Vector3(Mathf.Sin(d * i) * rad, Mathf.Cos(d * i) * rad, m_Z.Evaluate(frag)));
            }
        }


        

    }
    

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSSpiral.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSStar.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c23adbe234d78794db53da7b155a4b75
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Shapes
{
    /// <summary>
    /// Star Shape (2D)
    /// </summary>
    [CurvyShapeInfo("2D/Star")]
    [RequireComponent(typeof(CurvySpline))]
    [AddComponentMenu("Curvy/Shapes/Star")]
    public class CSStar : CurvyShape2D
    {
        
        [SerializeField]
        [Positive(Tooltip = "Number of Sides", MinValue = 2)]
        private int m_Sides = 5;
        public int Sides
        {
            get { return m_Sides; }
            set
            {
                int v = Mathf.Max(0, value);
                if (m_Sides != v)
                {
                    m_Sides = v;
                    Dirty = true;
                }
            }
        }

        
        [SerializeField]
        [Positive]
        private float m_OuterRadius = 2;
        public float OuterRadius
        {
            get { return m_OuterRadius; }
            set
            {
                float v = Mathf.Max(InnerRadius, value);
                if (m_OuterRadius != v)
                {
                    m_OuterRadius = v;
                    Dirty = true;
                }
                
            }
        }

        
        [SerializeField]
        [RangeEx(0, 1)]
        private float m_OuterRoundness = 0;
        public float OuterRoundness
        {
            get { return m_OuterRoundness; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_OuterRoundness != v)
                {
                    m_OuterRoundness = v;
                    Dirty = true;
                }
            }
        }
        
        
        [SerializeField]
        [Positive]
        private float m_InnerRadius = 1;
        public float InnerRadius
        {
            get { return m_InnerRadius; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_InnerRadius != v)
                {
                    m_InnerRadius = v;
                    Dirty = true;
                }
            }
        }

        [SerializeField]
        [RangeEx(0, 1)]
        private float m_InnerRoundness = 0;
        public float InnerRoundness
        {
            get { return m_InnerRoundness; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_InnerRoundness != v)
                {
                    m_InnerRoundness = v;
                    Dirty = true;
                }
            }
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Sides=m_Sides;
            OuterRadius = m_OuterRadius;
            InnerRadius=m_InnerRadius;
            OuterRoundness = m_OuterRoundness;
            InnerRoundness = m_InnerRoundness;
        }
#endif

        protected override void Reset()
        {
 	         base.Reset();
            Sides=5;
            OuterRadius=2;
            OuterRoundness=0;
            InnerRadius=1;
            InnerRoundness=0;
        }

        protected override void ApplyShape()
        {
            PrepareSpline(CurvyInterpolation.Bezier);
            PrepareControlPoints(Sides*2);
            float d = 360f * Mathf.Deg2Rad / Spline.ControlPointCount;
            for (int i = 0; i < Spline.ControlPointCount; i += 2)
            {
                Vector3 dir = new Vector3(Mathf.Sin(d * i), Mathf.Cos(d * i), 0);

                SetPosition(i, dir * OuterRadius);
                //SetBezierHandles(i,new Vector3(-dir.y, dir.x, 0),new Vector3(dir.y, -dir.x, 0),Space.Self);
                Spline.ControlPointsList[i].AutoHandleDistance = OuterRoundness;
                dir=new Vector3(Mathf.Sin(d*(i+1)),Mathf.Cos(d*(i+1)),0);
                SetPosition(i+1,dir * InnerRadius);
                //SetBezierHandles(i+1,new Vector3(-dir.y, dir.x, 0),new Vector3(dir.y, -dir.x, 0),Space.Self);
                Spline.ControlPointsList[i + 1].AutoHandleDistance = InnerRoundness;
            }
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSStar.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CurvyShape.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3bf249c70f8faf74991ef60947480cb5
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System.Collections.Generic;
using FluffyUnderware.DevTools;
using System;
#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools.Extensions;


namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Base class for CurvyShape components
    /// </summary>
    [RequireComponent(typeof(CurvySpline))]
    //[DisallowMultipleComponent]
    [ExecuteAlways]
    [HelpURL(CurvySpline.DOCLINK + "curvyshape")]
    public class CurvyShape : DTVersionedMonoBehaviour
    {
        #region ### Serialized Fields ###

        [SerializeField, Label("Plane")] private CurvyPlane m_Plane = CurvyPlane.XY;

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Gets or sets the plane to create the shape in
        /// </summary>
        public CurvyPlane Plane
        {
            get { return m_Plane; }
            set
            {
                Spline.Restricted2DPlane = value;
                if (m_Plane != value)
                {
                    m_Plane = value;
                    Dirty = true;
                }
            }
        }

        /// <summary>
        /// Gets the attached spline
        /// </summary>
        public CurvySpline Spline
        {
            get
            {
                if (!mSpline)
                    mSpline = GetComponent<CurvySpline>();
                return mSpline;
            }
        }

        #endregion

        #region ### Private fields ###

        private static Dictionary<CurvyShapeInfo, Type> mShapeDefs = new Dictionary<CurvyShapeInfo, System.Type>();

        private CurvySpline mSpline;
        [System.NonSerialized]
        public bool Dirty;
#if UNITY_EDITOR
        private bool isEnabled;
#endif
        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */
        private void Update()
        {
            // Prevent updating while dragging prefab
#if UNITY_EDITOR
            //if (Selection.activeGameObject==gameObject)
#endif
            Refresh();
        }

#if UNITY_EDITOR

        private void OnEnable()
        {
            isEnabled = true;
        }

        private void OnDisable()
        {
            isEnabled = false;
        }

        protected virtual void OnValidate()
        {
            if (isEnabled)
            {
                Plane = m_Plane;
                Dirty = true;
            }
        }
#endif

        protected virtual void Reset()
        {
            Plane = CurvyPlane.XY;
            Dirty = true;
        }
        /*! \endcond */

        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Remove the CurvyShape component from it's GameObject
        /// </summary>
        public void Delete()
        {
            this.Destroy(true, false);
        }

        /// <summary>
        /// Called to refresh the shape. Please call base.Refresh() or RefreshSpline() after your custom code!
        /// </summary>
        /// <remarks>Warning: Only work with ControlPoints, not with segments</remarks>
        public void Refresh()
        {
            if (Dirty)
            {
                //#if UNITY_EDITOR
                //                if (!Application.isPlaying)
                //                    Undo.RecordObject(Spline, "Apply Shape");
                //#endif
                ApplyShape();
                applyPlane();
                Spline.SetDirtyAll();
                Spline.Refresh();
            }
            Dirty = false;
        }


        /// <summary>
        /// Replace the current script with another shape's script
        /// </summary>
        /// <returns>the new shape script</returns>
        public CurvyShape Replace(string menuName)
        {
            Type shapeType = GetShapeType(menuName);
            if (shapeType != null)
            {
                GameObject go = this.gameObject;

                Delete();
                CurvyShape shape;

#if UNITY_EDITOR
                shape = (CurvyShape)Undo.AddComponent(go, shapeType);
#else
                shape = (CurvyShape)go.AddComponent(shapeType);
#endif

                shape.Dirty = true;
                return shape;
            }
            return null;
        }


        #endregion

        #region ### Protected Methods ###

        /// <summary>
        /// Sets basic spline parameters
        /// </summary>
        protected void PrepareSpline(CurvyInterpolation interpolation, CurvyOrientation orientation = CurvyOrientation.Dynamic, int cachedensity = 50, bool closed = true)
        {
            Spline.Interpolation = interpolation;
            Spline.Orientation = orientation;
            Spline.CacheDensity = cachedensity;
            Spline.Closed = closed;
            Spline.RestrictTo2D = this is CurvyShape2D;
        }

        /// <summary>
        /// Sets a Control Point's position by index
        /// </summary>
        /// <param name="no">Control point index</param>
        /// <param name="position">local position</param>
        protected void SetPosition(int no, Vector3 position)
        {
            Spline.ControlPointsList[no].SetLocalPosition(position);
        }

        /// <summary>
        /// Sets a Control Point's rotation by index
        /// </summary>
        /// <param name="no">Control point index</param>
        /// <param name="rotation">local rotation</param>
        protected void SetRotation(int no, Quaternion rotation)
        {
            Spline.ControlPointsList[no].SetLocalRotation(rotation);
        }

        /// <summary>
        /// Sets a Control Point's Bezier Handles by index
        /// </summary>
        /// <param name="no">Control point index</param>
        /// <param name="distanceFrag">distance in percent</param>
        protected void SetBezierHandles(int no, float distanceFrag)
        {
            SetBezierHandles(no, distanceFrag, distanceFrag);
        }

        /// <summary>
        /// Sets a Control Point's Bezier Handles by index
        /// </summary>
        /// <param name="no">Control point index</param>
        /// <param name="inDistanceFrag">distance in percent for HandleIn</param>
        /// /// <param name="outDistanceFrag">distance in percent for HandleOut</param>
        protected void SetBezierHandles(int no, float inDistanceFrag, float outDistanceFrag)
        {
            CurvySplineSegment curvySplineSegment = Spline.ControlPointsList[no];

            if (no >= 0 && no < Spline.ControlPointCount)
            {
                if (inDistanceFrag == outDistanceFrag)
                {
                    curvySplineSegment.AutoHandles = true;
                    curvySplineSegment.AutoHandleDistance = inDistanceFrag;
                }
                else
                {
                    curvySplineSegment.AutoHandles = false;
                    curvySplineSegment.AutoHandleDistance = (inDistanceFrag + outDistanceFrag) / 2f;
                    SetBezierHandles(inDistanceFrag, true, false, curvySplineSegment);
                    SetBezierHandles(outDistanceFrag, false, true, curvySplineSegment);
                }


            }
        }

        /// <summary>
        /// Sets a Control Point's Bezier Handles position
        /// </summary>
        /// <param name="no">the ControlPoint</param>
        /// <param name="i">HandlInPosition</param>
        /// <param name="o">HandleOutPosition</param>
        /// <param name="space">World or local space</param>
        protected void SetBezierHandles(int no, Vector3 i, Vector3 o, Space space = Space.World)
        {
            if (no >= 0 && no < Spline.ControlPointCount)
            {
                CurvySplineSegment curvySplineSegment = Spline.ControlPointsList[no];

                curvySplineSegment.AutoHandles = false;
                if (space == Space.World)
                {
                    curvySplineSegment.HandleInPosition = i;
                    curvySplineSegment.HandleOutPosition = o;
                }
                else
                {
                    curvySplineSegment.HandleIn = i;
                    curvySplineSegment.HandleOut = o;
                }
            }
        }

        /// <summary>
        /// Automatically place Bezier handles for a set of Control Points
        /// </summary>
        /// <param name="distanceFrag">how much % distance between neighbouring CPs are applied to the handle length?</param>
        /// <param name="setIn">Set HandleIn?</param>
        /// <param name="setOut">Set HandleOut?</param>
        /// <param name="controlPoints">one or more Control Points to set</param>
        public static void SetBezierHandles(float distanceFrag, bool setIn, bool setOut, params CurvySplineSegment[] controlPoints)
        {
            if (controlPoints.Length == 0)
                return;

            foreach (CurvySplineSegment cp in controlPoints)
                cp.SetBezierHandles(distanceFrag, setIn, setOut);
        }

        /// <summary>
        /// Enables CGHardEdge for a set of Control Points
        /// </summary>
        /// <param name="controlPoints">list of Control Point indices</param>
        protected void SetCGHardEdges(params int[] controlPoints)
        {
            if (controlPoints.Length == 0)
            {
                for (int i = 0; i < Spline.ControlPointCount; i++)
                    Spline.ControlPointsList[i].GetMetadata<MetaCGOptions>(true).HardEdge = true;
            }
            else
            {
                for (int i = 0; i < controlPoints.Length; i++)
                    if (i >= 0 && i < Spline.ControlPointCount)
                        Spline.ControlPointsList[i].GetMetadata<MetaCGOptions>(true).HardEdge = true;
            }
        }

        /// <summary>
        /// Override this to add custom code
        /// </summary>
        protected virtual void ApplyShape()
        {
        }

        /// <summary>
        /// Resizes the spline to have a certain number of Control Points
        /// </summary>
        /// <param name="count">number of Control Points</param>
        protected void PrepareControlPoints(int count)
        {
#if CONTRACTS_FULL
            Contract.Requires(Spline.LastVisibleControlPoint != null);
#endif

            /*
            Spline.Clear();
            while (count-- > 0)
                Spline.Add();
            Spline.Refresh();
            */
            int delta = count - Spline.ControlPointCount;
            bool upd = delta != 0;

            while (delta > 0)
            {
                Spline.InsertAfter(null, true);
                delta--;
            }

            while (delta < 0)
            {
                Spline.Delete(Spline.LastVisibleControlPoint, true, false);
                delta++;
            }
            // Revert to default settings
            for (int i = 0; i < Spline.ControlPointsList.Count; i++)
            {
                CurvySplineSegment controlPoint = Spline.ControlPointsList[i];
                controlPoint.transform.localPosition = Vector3.zero;
                controlPoint.transform.localRotation = Quaternion.identity;
                controlPoint.transform.localScale = Vector3.one;
                controlPoint.Reset();
                controlPoint.Disconnect();
                MetaCGOptions mcg = controlPoint.GetMetadata<MetaCGOptions>();
                if (mcg)
                    mcg.Reset();
            }

            if (upd)
                Spline.Refresh();
        }

        #endregion

        #region ### Public Static Methods & Properties ###

        /// <summary>
        /// Dictionary of Shape definitions and their types
        /// </summary>
        //TODO should be private
        public static Dictionary<CurvyShapeInfo, System.Type> ShapeDefinitions
        {
            get
            {
                if (mShapeDefs.Count == 0)
                    mShapeDefs = typeof(CurvyShape).GetAllTypesWithAttribute<CurvyShapeInfo>();

                return mShapeDefs;
            }
        }

        /// <summary>
        /// Gets a list of Menu Names of available shapes
        /// </summary>
        /// <param name="only2D">whether to skip 3D shapes or not</param>
        /// <returns>a list of Menu Names</returns>
        public static List<string> GetShapesMenuNames(bool only2D = false)
        {
            List<string> res = new List<string>();
            foreach (CurvyShapeInfo shapeInfo in ShapeDefinitions.Keys)
                if (!only2D || shapeInfo.Is2D)
                    res.Add(shapeInfo.Name);

            return res;
        }

        /// <summary>
        /// Gets a list of Menu Names of available shapes
        /// </summary>
        /// <param name="currentShapeType">the current shape type</param>
        /// <param name="currentIndex">returns the index of the current shape type</param>
        /// <param name="only2D">whether only to show 2D shapes</param>
        /// <returns>a list of Menu Names</returns>
        public static List<string> GetShapesMenuNames(System.Type currentShapeType, out int currentIndex, bool only2D = false)
        {
            currentIndex = 0;
            if (currentShapeType == null)
                return GetShapesMenuNames(only2D);
            List<string> lst = new List<string>();
            foreach (KeyValuePair<CurvyShapeInfo, Type> kv in ShapeDefinitions)
            {
                if (!only2D || kv.Key.Is2D)
                    lst.Add(kv.Key.Name);
                if (kv.Value == currentShapeType)
                    currentIndex = lst.Count - 1;

            }
            return lst;
        }

        /// <summary>
        /// Gets Shape Menu Name from a CurvyShape subclass type
        /// </summary>
        /// <param name="shapeType"></param>
        /// <returns></returns>
        public static string GetShapeName(System.Type shapeType)
        {
            foreach (KeyValuePair<CurvyShapeInfo, Type> kv in ShapeDefinitions)
                if (kv.Value == shapeType)
                    return kv.Key.Name;
            return null;
        }

        /// <summary>
        /// Gets a CurvyShape subclass type from a Shape's MenuName
        /// </summary>
        /// <param name="menuName"></param>
        /// <returns></returns>
        public static Type GetShapeType(string menuName)
        {
            foreach (CurvyShapeInfo shapeInfo in ShapeDefinitions.Keys)
                if (shapeInfo.Name == menuName)
                    return ShapeDefinitions[shapeInfo];

            return null;
        }

        #endregion

        #region ### Privates ###

        private void applyPlane()
        {
            switch (Plane)
            {
                case CurvyPlane.XZ:
                    applyRotation(Quaternion.Euler(90, 0, 0));
                    break;
                case CurvyPlane.YZ:
                    applyRotation(Quaternion.Euler(0, 90, 0));
                    break;
                default:
                    applyRotation(Quaternion.Euler(0, 0, 0));
                    break;
            }
        }

        private void applyRotation(Quaternion q)
        {
            Spline.transform.localRotation = Quaternion.identity;

            for (int i = 0; i < Spline.ControlPointCount; i++)
            {
                CurvySplineSegment curvySplineSegment = Spline.ControlPointsList[i];
                curvySplineSegment.SetLocalRotation(q * curvySplineSegment.transform.localRotation);
                curvySplineSegment.SetLocalPosition(q * curvySplineSegment.transform.localPosition);
                if (Spline.Interpolation == CurvyInterpolation.Bezier)
                {
                    curvySplineSegment.HandleIn = q * curvySplineSegment.HandleIn;
                    curvySplineSegment.HandleOut = q * curvySplineSegment.HandleOut;
                }
            }
        }

        #endregion


    }

    /// <summary>
    /// CurvyShape Info Attribute
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
    public sealed class CurvyShapeInfo : System.Attribute
    {
        public readonly string Name;
        public readonly bool Is2D;

        public CurvyShapeInfo(string name, bool is2D = true)
        {
            Name = name;
            Is2D = is2D;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CurvyShape.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CurvyShape2D.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dd2a6fa79083d8c468863ad668f919e3
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.Curvy.Utils;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Base class for 2D Shapes
    /// </summary>
    public class CurvyShape2D : CurvyShape
    {
       
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CurvyShape2D.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Connections/ConnectionHeadingEnum.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 053e00672ed69584292283c8a26f4a09
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Connection's Follow-Up heading direction
    /// </summary>
    public enum ConnectionHeadingEnum
    {
        /// <summary>
        /// Head towards the targets start (negative F)
        /// </summary>
        Minus = -1,
        /// <summary>
        /// Do not head anywhere, stay still
        /// </summary>
        Sharp = 0,
        /// <summary>
        /// Head towards the targets end (positive F)
        /// </summary>
        Plus = 1,
        /// <summary>
        /// Automatically choose the appropriate value
        /// </summary>
        Auto = 2
    }

    /// <summary>
    /// Extension methods of <see cref="ConnectionHeadingEnum"/>
    /// </summary>
    public static class ConnectionHeadingEnumMethods
    {
        /// <summary>
        /// If heading is Auto, this method will translate it to a Plus, Minus or Sharp value depending on the Follow-Up control point.
        /// </summary>
        /// <param name="heading">the value to resolve</param>
        /// <param name="followUp">the related followUp control point</param>
        /// <returns></returns>
        static public ConnectionHeadingEnum ResolveAuto(this ConnectionHeadingEnum heading, CurvySplineSegment followUp)
        {
            if (heading == ConnectionHeadingEnum.Auto)
            {
                if (CurvySplineSegment.CanFollowUpHeadToEnd(followUp))
                    heading = ConnectionHeadingEnum.Plus;
                else if (CurvySplineSegment.CanFollowUpHeadToStart(followUp))
                    heading = ConnectionHeadingEnum.Minus;
                else
                    heading = ConnectionHeadingEnum.Sharp;
            }
            return heading;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Connections/ConnectionHeadingEnum.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Connections/CurvyConnection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 320a2489ca748ce44a808c78b9a5c740
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.SceneManagement;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Connection component
    /// </summary>
    [ExecuteInEditMode]
    [HelpURL(CurvySpline.DOCLINK + "curvyconnection")]
    public class CurvyConnection : DTVersionedMonoBehaviour, ISerializationCallbackReceiver
    {
        #region ### Serialized Fields ###

        [SerializeField, Hide] private List<CurvySplineSegment> m_ControlPoints = new List<CurvySplineSegment>();

        #endregion

        #region ### Private Fields ###

        private ReadOnlyCollection<CurvySplineSegment> readOnlyControlPoints;
        /// <summary>
        /// The coordinates of the connection the last time synchronisation was processed
        /// </summary>
        private Couple<Vector3, Quaternion> processedConnectionCoordinates;
        /// <summary>
        /// The coordinates of the connection's control points the last time synchronisation was processed
        /// </summary>
        [SerializeField, Hide] private List<ControlPointCoordinates> processedControlPointsCoordinates = new List<ControlPointCoordinates>();

        #endregion

        #region ### Public Properties ###


        /// <summary>
        /// The list of connected control points
        /// </summary>
        public ReadOnlyCollection<CurvySplineSegment> ControlPointsList
        {
            //TODO apply the same TODOs than CurvySpline.ControlPointsList
            get
            {
                if (readOnlyControlPoints == null)
                    readOnlyControlPoints = m_ControlPoints.AsReadOnly();
                return readOnlyControlPoints;
            }
        }
        /// <summary>
        /// Gets the number of Control Points being part of this connection
        /// </summary>
        public int Count
        {
            get { return m_ControlPoints.Count; }
        }

        /// <summary>
        /// Gets a certain Control Point by index
        /// </summary>
        /// <param name="idx">index of the Control Point</param>
        /// <returns>a Control Point</returns>
        public CurvySplineSegment this[int idx]
        {
            get
            {
                return m_ControlPoints[idx];
            }
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */


        private void OnEnable()
        {
            SceneManager.sceneLoaded += OnSceneLoaded;

            ResetProcessedCoordinates();
#if UNITY_EDITOR
            EditorApplication.update += EditorUpdate;
#endif
        }

        private void OnDisable()
        {
            SceneManager.sceneLoaded -= OnSceneLoaded;
#if UNITY_EDITOR
            EditorApplication.update -= EditorUpdate;
#endif
        }

#if UNITY_EDITOR
        private void EditorUpdate()
        {
            DoUpdate();
        }
#endif


        private void Update()
        {
            if (Application.isPlaying)
                DoUpdate();
        }

        private void LateUpdate()
        {
            if (Application.isPlaying)
                DoUpdate();
        }

        private void FixedUpdate()
        {
            if (Application.isPlaying)
                DoUpdate();
        }

        private void OnDestroy()
        {
            bool realDestroy = true;
#if UNITY_EDITOR
            if (EditorApplication.isPlayingOrWillChangePlaymode && !EditorApplication.isPlaying)
                realDestroy = false;
#endif
            if (realDestroy)
            {
                List<CurvySplineSegment> controlPointsToDisconnect = new List<CurvySplineSegment>(m_ControlPoints);
                foreach (CurvySplineSegment cp in controlPointsToDisconnect)
                    cp.Disconnect(false);

                //This is needed even if cp.Disconnect removes the cp from those lists via Connection.RemoveControlPoint, because when calling cp.Disconnect you can have cp.Connection == null, which will lead to Connection.RemoveControlPoint not being called. Saw that happening when undoing the creation of a connect CP (via the Smart Connect tool)
                m_ControlPoints.Clear();
                processedControlPointsCoordinates.Clear();
            }
        }


        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Creates a connection and adds Control Points
        /// </summary>
        /// <param name="controlPoints">Control Points to add</param>
        /// <returns>the new connection</returns>
        public static CurvyConnection Create(params CurvySplineSegment[] controlPoints)
        {
            CurvyGlobalManager curvyGlobalManager = CurvyGlobalManager.Instance;
            if (curvyGlobalManager == null)
            {
                DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.");
                return null;
            }

            CurvyConnection con = curvyGlobalManager.AddChildGameObject<CurvyConnection>("Connection");
#if UNITY_EDITOR
            if (!Application.isPlaying)
                Undo.RegisterCreatedObjectUndo(con.gameObject, "Add Connection");
#endif
            if (!con)
                return null;
            if (controlPoints.Length > 0)
            {
                con.transform.position = controlPoints[0].transform.position;
                con.AddControlPoints(controlPoints);
            }

            return con;
        }

        /// <summary>
        /// Adds Control Points to this connection
        /// </summary>
        /// <param name="controlPoints">the Control Points to add</param>
        public void AddControlPoints(params CurvySplineSegment[] controlPoints)
        {
            foreach (CurvySplineSegment cp in controlPoints)
            {
                if (cp.Connection)
                {
                    DTLog.LogErrorFormat(this, "[Curvy] CurvyConnection.AddControlPoints called on a control point '{0}' that has already a connection. Only control points with no connection can be added.", cp);
                    continue;
                }

#if UNITY_EDITOR
                if (!Application.isPlaying)
                    Undo.RecordObject(cp, "Add Connection");
#endif
#if CURVY_SANITY_CHECKS
                Assert.IsFalse(m_ControlPoints.Contains(cp));
#endif
                m_ControlPoints.Add(cp);
                processedControlPointsCoordinates.Add(new ControlPointCoordinates(cp));
                cp.Connection = this;
            }
            AutoSetFollowUp();
        }

        public void AutoSetFollowUp()
        {
            if (Count == 2)
            {
                CurvySplineSegment firstControlPoint = m_ControlPoints[0];
                CurvySplineSegment secondControlPoint = m_ControlPoints[1];
                if (firstControlPoint.transform.position == secondControlPoint.transform.position && firstControlPoint.ConnectionSyncPosition && secondControlPoint.ConnectionSyncPosition)
                {
                    if (firstControlPoint.FollowUp == null && firstControlPoint.Spline && firstControlPoint.Spline.CanControlPointHaveFollowUp(firstControlPoint))
                        firstControlPoint.SetFollowUp(secondControlPoint);
                    if (secondControlPoint.FollowUp == null && secondControlPoint.Spline && secondControlPoint.Spline.CanControlPointHaveFollowUp(secondControlPoint))
                        secondControlPoint.SetFollowUp(firstControlPoint);
                }
            }
        }

        /// <summary>
        /// Removes a Control Point from this connection
        /// </summary>
        /// <param name="controlPoint">the Control Point to remove</param>
        /// <param name="destroySelfIfEmpty">whether the connection should be destroyed when empty afterwards</param>
        public void RemoveControlPoint(CurvySplineSegment controlPoint, bool destroySelfIfEmpty = true)
        {
#if UNITY_EDITOR
            const string undoingStepLabel = "Disconnect from Connection";

            Undo.RegisterCompleteObjectUndo(new UnityEngine.Object[]{
                controlPoint, this
            }, undoingStepLabel);
#endif

            controlPoint.Connection = null;

            m_ControlPoints.Remove(controlPoint);
            processedControlPointsCoordinates.RemoveAll(element => ReferenceEquals(element.ControlPoint, controlPoint));

            foreach (CurvySplineSegment splineSegment in m_ControlPoints)
            {
                if (splineSegment.FollowUp == controlPoint)
                {
#if UNITY_EDITOR
                    Undo.RegisterCompleteObjectUndo(splineSegment, undoingStepLabel);
#endif
                    splineSegment.SetFollowUp(null);
                }
            }
            if (m_ControlPoints.Count == 0 && destroySelfIfEmpty)
                Delete();
        }

        /// <summary>
        /// Deletes the connection
        /// </summary>
        public void Delete()
        {
            gameObject.Destroy(true, true);
        }

        /// <summary>
        /// Gets all Control Points except the one provided
        /// </summary>
        /// <param name="source">the Control Point to filter out</param>
        /// <returns>list of Control Points</returns>
        public List<CurvySplineSegment> OtherControlPoints(CurvySplineSegment source)
        {
            List<CurvySplineSegment> res = new List<CurvySplineSegment>(m_ControlPoints);
            res.Remove(source);
            return res;
        }

        /// <summary>
        /// Synchronise all the connected control points to match the given position and rotation, based on their synchronisation options, namely <see cref="CurvySplineSegment.ConnectionSyncPosition"/> and <see cref="CurvySplineSegment.ConnectionSyncRotation"/>. Will update the CurvyConnection's game object's transform too.
        /// </summary>
        /// <remarks>Can dirty the splines of the updated control points</remarks>
        public void SetSynchronisationPositionAndRotation(Vector3 referencePosition, Quaternion referenceRotation)
        {
            Transform cachedTransform = transform;

            cachedTransform.position = referencePosition;
            cachedTransform.rotation = referenceRotation;
            cachedTransform.hasChanged = false;
            processedConnectionCoordinates.First = referencePosition;
            processedConnectionCoordinates.Second = referenceRotation;

            for (int i = 0; i < m_ControlPoints.Count; i++)
            {
                CurvySplineSegment controlPoint = m_ControlPoints[i];

                bool positionModified = controlPoint.ConnectionSyncPosition && controlPoint.transform.position.NotApproximately(referencePosition);
                bool rotationModified = controlPoint.ConnectionSyncRotation && controlPoint.transform.rotation.DifferentOrientation(referenceRotation);

                if (positionModified)
                    controlPoint.transform.position = referencePosition;
                if (rotationModified)
                    controlPoint.transform.rotation = referenceRotation;

                ControlPointCoordinates processedControlPointCoordinates =
                    processedControlPointsCoordinates.Single(element => ReferenceEquals(element.ControlPoint, controlPoint));

                processedControlPointCoordinates.Position = controlPoint.transform.position;
                processedControlPointCoordinates.Rotation = controlPoint.transform.rotation;

                if (positionModified || (rotationModified && controlPoint.OrientatinInfluencesSpline))
                    controlPoint.Spline.SetDirtyPartial(controlPoint
                        , positionModified == false ? SplineDirtyingType.OrientationOnly : SplineDirtyingType.Everything);
            }
        }


#if UNITY_EDITOR
        /// <summary>
        /// Gets the gizmo color based on the synchronization options of the connected control points
        /// </summary>
        public Color GetGizmoColor()
        {
            Color gizmoColor;

            if (ControlPointsList.Count == 0)
                gizmoColor = Color.black;
            else
            {
                bool allPositionsSynced = true;
                bool allRotationsSynced = true;
                foreach (CurvySplineSegment controlPoint in ControlPointsList)
                {
                    allPositionsSynced = allPositionsSynced && controlPoint.ConnectionSyncPosition;
                    allRotationsSynced = allRotationsSynced && controlPoint.ConnectionSyncRotation;

                    if (allPositionsSynced == false && allRotationsSynced == false)
                        break;
                }

                if (allPositionsSynced)
                    gizmoColor = allRotationsSynced
                        ? Color.white
                        : new Color(255 / 255f, 49 / 255f, 38 / 255f);
                else if (allRotationsSynced)
                    gizmoColor = new Color(1, 1, 0);
                else
                    gizmoColor = Color.black;
            }

            return gizmoColor;
        }
#endif


        #endregion

        #region ### Privates & Internals ###
        /*! \cond PRIVATE */

        private void DoUpdate()
        {
            Transform cachedTransform = transform;

            bool synchronised;
            if (cachedTransform.hasChanged)
            {
                cachedTransform.hasChanged = false;
                if (cachedTransform.position.NotApproximately(processedConnectionCoordinates.First) ||
                    cachedTransform.rotation.DifferentOrientation(processedConnectionCoordinates.Second))
                {
                    SetSynchronisationPositionAndRotation(cachedTransform.position, cachedTransform.rotation);
                    synchronised = true;
                }
                else
                    synchronised = false;
            }
            else
                synchronised = false;

            if (synchronised == false)
            {
                Vector3? synchronisationPosition = null;
                Quaternion? synchronisationRotation = null;

                foreach (CurvySplineSegment controlPoint in m_ControlPoints)
                {
                    if (controlPoint.gameObject == null)
                    {
                        //The only case I am aware of where this happens is when running test (see [TestFixture]), when the test is finished, a connection is duplicated and "restored", while having in its CPs list CPs that have been destroyed.
                        //This is somehow related to the following statement in the RemoveControlPoint method:
                        //Undo.RegisterCompleteObjectUndo(new UnityEngine.Object[]{
                        //    controlPoint, this
                        //}, undoingStepLabel);

                        //If you fix the problem above, remove unnecessary checks on controlPoint.gameObject. Look for the following comment to find such places:
                        // "see comment in CurvyConnection.DoUpdate to know more about when cp.gameObject can be null"

                        DTLog.LogError(String.Format("[Curvy] Connection named '{0}' had in its list a control point with no game object. Control point was ignored", this.name), this);
                        continue;
                    }
                    ControlPointCoordinates processedControlPointsCoordinate =
                        processedControlPointsCoordinates.Single(element => ReferenceEquals(element.ControlPoint, controlPoint));

                    Transform controlPointTransform = controlPoint.transform;

                    if (controlPoint.ConnectionSyncPosition && controlPointTransform.position.NotApproximately(processedControlPointsCoordinate.Position))
                        synchronisationPosition = controlPointTransform.position;

                    if (controlPoint.ConnectionSyncRotation && controlPointTransform.rotation.DifferentOrientation(processedControlPointsCoordinate.Rotation))
                        synchronisationRotation = controlPointTransform.rotation;

                    if (synchronisationPosition != null && synchronisationRotation != null)
                        break;
                }

                if (synchronisationPosition != null || synchronisationRotation != null)
                    SetSynchronisationPositionAndRotation(synchronisationPosition ?? transform.position, synchronisationRotation ?? transform.rotation);
            }
        }

        private void OnSceneLoaded(Scene arg0, LoadSceneMode arg1)
        {
            //m_ControlPoints can have null references in it because if the cp it has is disabled, and then the scene is switched, the cp will not execute its OnDestroy, ans thus will not remove himself from the connection. And since destroyed unity objects become equal to null, the CPs list will have a null value in it
            int removedElementsCount = m_ControlPoints.RemoveAll(cp => cp == null);
            if (removedElementsCount != 0)
            {
                if (m_ControlPoints.Count == 0)
                    Delete();
                else
                {
                    DTLog.LogWarning("[Curvy] Connection " + this.name + " was not destroyed after scene switch. That should not happen. Please raise a bug report.", this);
                    ResetProcessedCoordinates();
                }
            }
        }

        private void ResetProcessedCoordinates()
        {
            Transform cachedTransform = transform;
            processedConnectionCoordinates =
                new Couple<Vector3, Quaternion>(cachedTransform.position, cachedTransform.rotation);
            processedControlPointsCoordinates.Clear();
            for (int index = 0; index < m_ControlPoints.Count; index++)
                processedControlPointsCoordinates.Add(new ControlPointCoordinates(m_ControlPoints[index]));
        }

        /*! \endcond */
        #endregion

        #region ISerializationCallbackReceiver
        /*! \cond PRIVATE */
        /// <summary>
        /// Implementation of UnityEngine.ISerializationCallbackReceiver
        /// Called automatically by Unity, is not meant to be called by Curvy's users
        /// </summary>
        public void OnBeforeSerialize()
        {
            m_ControlPoints.RemoveAll(cp => ReferenceEquals(cp, null));
        }

        /// <summary>
        /// Implementation of UnityEngine.ISerializationCallbackReceiver
        /// Called automatically by Unity, is not meant to be called by Curvy's users
        /// </summary>
        public void OnAfterDeserialize()
        {
            m_ControlPoints.RemoveAll(cp => ReferenceEquals(cp, null));
        }
        /*! \endcond */
        #endregion

    }

    /// <summary>
    /// A class that exists only because Unity does not serialize Dictionary<CurvySplineSegment, Couple<Vector3, Quaternion>>
    /// </summary>
    [Serializable]
    internal class ControlPointCoordinates
    {
        internal ControlPointCoordinates(CurvySplineSegment controlPoint)
        {
            ControlPoint = controlPoint;
            if(controlPoint.gameObject)
            {
                // see comment in CurvyConnection.DoUpdate to know more about when cp.gameObject can be null
                Position = controlPoint.transform.position;
                Rotation = controlPoint.transform.rotation;
            }
        }
        [SerializeField]
        internal CurvySplineSegment ControlPoint;
        [SerializeField]
        internal Vector3 Position;
        [SerializeField]
        internal Quaternion Rotation;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Connections/CurvyConnection.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySpline.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 82f49053b9b703e4cbb1c6e76a563270
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using UnityEngine.Serialization;
using FluffyUnderware.DevTools.Extensions;
using System.Reflection;
using FluffyUnderware.Curvy.Pools;
using JetBrains.Annotations;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;
#if UNITY_EDITOR
using UnityEditor;
#endif
#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif


namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Curvy Spline class
    /// </summary>
    [HelpURL(CurvySpline.DOCLINK + "curvyspline")]
    [AddComponentMenu("Curvy/Curvy Spline")]
    [ExecuteAlways]
    public partial class CurvySpline : DTVersionedMonoBehaviour
    {
        /*! \cond PRIVATE */
        //TODO move elsewhere
        public const string VERSION = "8.4.0";
        public const string APIVERSION = "840";
        public const string WEBROOT = "https://curvyeditor.com/";
        public const string DOCLINK = WEBROOT + "doclink/";
        /*! \endcond */

#if UNITY_EDITOR
        /// <summary>
        /// The number of precomputed spline names 
        /// </summary>
        //DESIGN Make this parametrable by users?
        private const short CachedControlPointsNameCount = 250;
        /// <summary>
        /// A list of precomputed control point names
        /// </summary>
        static readonly private string[] controlPointNames = GetControlPointNames();

#endif

        public CurvySpline()
        {
            refreshCurveAction = (controlPoint, controlPointIndex, controlPointsCount) => controlPoint.refreshCurveINTERNAL();
            defaultSplineEventArgs = new CurvySplineEventArgs(this, this, null);
            defaultAddAfterEventArgs = new CurvyControlPointEventArgs(this, this, null, CurvyControlPointEventArgs.ModeEnum.AddAfter);
            defaultDeleteEventArgs = new CurvyControlPointEventArgs(this, this, null, CurvyControlPointEventArgs.ModeEnum.Delete);
        }

        #region ### Serialized fields ###

        /// <summary>
        /// The list of control points
        /// </summary>
        /// <remarks>The returned list should not be modified</remarks>
        [SerializeField, HideInInspector]
        private List<CurvySplineSegment> ControlPoints = new List<CurvySplineSegment>();

        /// <summary>
        /// Whether to show the Gizmos enabled in the view settings or not at all 
        /// </summary>
        [HideInInspector]
        public bool ShowGizmos = true;

        #endregion

        #region ### Public Properties ###

        #region --- General ---

        /// <summary>
        /// The interpolation method used by this spline
        /// </summary>
        /// <remarks>AutoEndTangents's value can be updated depending on Interpolation value</remarks>
        public CurvyInterpolation Interpolation
        {
            get { return m_Interpolation; }
            set
            {
                if (m_Interpolation != value)
                {
                    m_Interpolation = value;
                    InvalidateControlPointsRelationshipCacheINTERNAL();
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }

                //Since canHaveManualEndCP uses Interpolation, and is used by AutoEndTangents, we force the later's update
                AutoEndTangents = m_AutoEndTangents;
            }
        }

        /// <summary>
        /// Whether to restrict Control Points to a local 2D plane
        /// </summary>
        /// <seealso cref="Restricted2DPlane"/>
        public bool RestrictTo2D
        {
            get { return m_RestrictTo2D; }
            set
            {
                if (m_RestrictTo2D != value)
                {
                    m_RestrictTo2D = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// The local 2D plane to restrict the spline's control point in
        /// </summary>
        /// <seealso cref="RestrictTo2D"/>
        public CurvyPlane Restricted2DPlane
        {
            get { return restricted2DPlane; }
            set
            {
                if (restricted2DPlane != value)
                {
                    restricted2DPlane = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// Gets or sets the default Handle distance for Bezier splines
        /// </summary>
        public float AutoHandleDistance
        {
            get { return m_AutoHandleDistance; }
            set
            {
                float clampedValue = Mathf.Clamp01(value);
                if (m_AutoHandleDistance != clampedValue)
                {
                    m_AutoHandleDistance = clampedValue;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// Whether this spline is closed or not
        /// </summary>
        /// <remarks>AutoEndTangents's value can be updated depending on Close value</remarks>
        public bool Closed
        {
            get { return m_Closed; }
            set
            {
                if (m_Closed != value)
                {
                    m_Closed = value;
                    InvalidateControlPointsRelationshipCacheINTERNAL();
                    SetDirtyAll(SplineDirtyingType.Everything, true);
                }
                //Since canHaveManualEndCP uses Closed, and is used by AutoEndTangents, we force the later's update
                AutoEndTangents = m_AutoEndTangents;
            }
        }

        /// <summary>
        /// Whether the first/last Control Point should act as the end tangent, too.
        /// </summary>
        /// <remarks>Ignored by linear splines and Bezier ones</remarks>
        public bool AutoEndTangents
        {
            get { return m_AutoEndTangents; }
            set
            {
                bool v = !CanHaveManualEndCp() || value;
                if (m_AutoEndTangents != v)
                {
                    m_AutoEndTangents = v;
                    InvalidateControlPointsRelationshipCacheINTERNAL();
                    SetDirtyAll(SplineDirtyingType.Everything, true);
                }
            }
        }

        /// <summary>
        /// Orientation mode
        /// </summary>
        public CurvyOrientation Orientation
        {
            get { return m_Orientation; }
            set
            {
                if (m_Orientation != value)
                {
                    m_Orientation = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        public CurvyUpdateMethod UpdateIn
        {
            get { return m_UpdateIn; }
            set
            {
                if (m_UpdateIn != value)
                    m_UpdateIn = value;
            }
        }

        #endregion

        #region --- Advanced Settings ---

        /// <summary>
        /// Gets or sets Spline color
        /// </summary>
        public Color GizmoColor
        {
            get { return m_GizmoColor; }
            set
            {
                if (m_GizmoColor != value)
                    m_GizmoColor = value;
            }
        }

        /// <summary>
        /// Gets or sets selected segment color
        /// </summary>
        public Color GizmoSelectionColor
        {
            get { return m_GizmoSelectionColor; }
            set
            {
                if (m_GizmoSelectionColor != value)
                    m_GizmoSelectionColor = value;
            }
        }

        /// <summary>
        /// Gets or sets the cache density
        /// Defines how densely the cached points are. When the value is 100, the number of cached points per world distance unit is equal to the spline's <see cref="MaxPointsPerUnit"/>
        /// </summary>
        public int CacheDensity
        {
            get { return m_CacheDensity; }
            set
            {
                int clampedDensity = Mathf.Clamp(value, 1, 100);

                if (m_CacheDensity != clampedDensity)
                {
                    m_CacheDensity = clampedDensity;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// The maximum number of sampling points per world distance unit. Sampling is used in caching or shape extrusion for example</summary>
        public float MaxPointsPerUnit
        {
            get
            {
                return m_MaxPointsPerUnit;
            }
            set
            {
                float clampedValue = Mathf.Clamp(value, MinimalMaxPointsPerUnit, 1000);
                if (m_MaxPointsPerUnit != clampedValue)
                {
                    m_MaxPointsPerUnit = clampedValue;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// Whether to use GameObject pooling for Control Points at runtime
        /// </summary>
        public bool UsePooling
        {
            get { return m_UsePooling; }
            set
            {
                if (m_UsePooling != value)
                    m_UsePooling = value;
            }
        }
        /// <summary>
        /// Whether to use threading where applicable or not.
        /// Threading is currently not supported when targeting WebGL and Universal Windows Platform
        /// </summary>
        public bool UseThreading
        {
            get
            {
#if !UNITY_WSA && !UNITY_WEBGL
                return m_UseThreading;
#else

                return false;
#endif
            }
            set
            {
                if (m_UseThreading != value)
                    m_UseThreading = value;
            }
        }

        /// <summary>
        /// Whether the spline should automatically refresh when a Control Point's position change
        /// </summary>
        /// <remarks>Enable this if you animate a Control Point's transform!</remarks>
        public bool CheckTransform
        {
            get { return m_CheckTransform; }
            set
            {
                if (m_CheckTransform != value)
                {
                    m_CheckTransform = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }


        #endregion

        #region --- TCB Options ---

        /// <summary>
        /// Global Tension
        /// </summary>
        /// <remarks>This only applies to TCB interpolation</remarks>
        public float Tension
        {
            get { return m_Tension; }
            set
            {
                if (m_Tension != value)
                {
                    m_Tension = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// Global Continuity
        /// </summary>
        /// <remarks>This only applies to TCB interpolation</remarks>
        public float Continuity
        {
            get { return m_Continuity; }
            set
            {
                if (m_Continuity != value)
                {
                    m_Continuity = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// Global Bias
        /// </summary>
        /// <remarks>This only applies to TCB interpolation</remarks>
        public float Bias
        {
            get { return m_Bias; }
            set
            {
                if (m_Bias != value)
                {
                    m_Bias = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }
        #endregion

        #region --- B-Spline Options ---

        /// <summary>
        /// Used only when <see cref="Interpolation"/> is <see cref="CurvyInterpolation.BSpline"/>
        /// The degree of the piecewise polynomial functions
        /// Is in the range [2; control points count - 1]
        /// </summary>
        public int BSplineDegree
        {
            get { return bSplineDegree; }
            set
            {
                value = Mathf.Min(Mathf.Max(minBSplineDegree, value), MaxBSplineDegree);
                if (bSplineDegree != value)
                {
                    bSplineDegree = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// Used only when <see cref="Interpolation"/> is <see cref="CurvyInterpolation.BSpline"/>
        /// Make the curve pass through the first and last control points by increasing the multiplicity of the first and last knots.
        /// In technical terms, when this parameter is true, the knot vector is [0, 0, ...,0, 1, 2, ..., N-1, N, N, ..., N]. When false, it is [0, 1, 2, ..., N-1, N]
        /// </summary>
        public bool IsBSplineClamped
        {
            get { return CanBeClamped() && isBSplineClamped; }
            set
            {
                if (isBSplineClamped != value)
                {
                    isBSplineClamped = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }
        #endregion

        #region --- Others ---

        /// <summary>
        /// Whether the spline is fully initialized and all segments loaded
        /// </summary>
        public bool IsInitialized { get { return mIsInitialized; } }

        /// <summary>
        /// The bounding box of the spline, in world space
        /// </summary>
        public Bounds Bounds
        {
            get
            {
                if (!mBounds.HasValue)
                {
#if CURVY_SANITY_CHECKS
                    DoSanityChecks();
#endif
                    Bounds bounds;
                    if (Count > 0)
                    {
                        Bounds b = this[0].Bounds;

                        for (int i = 1; i < Count; i++)
                            b.Encapsulate(this[i].Bounds);
                        bounds = b;
                    }
                    else
                        bounds = new Bounds(transform.position, Vector3.zero);

                    if (Dirty == false)
                        mBounds = bounds;
                    return bounds;
                }
                return mBounds.Value;
            }
        }

        /// <summary>
        /// Gets the number of Segments
        /// </summary>
        public int Count { get { return Segments.Count; } }
        /// <summary>
        /// Gets the number of Control Points
        /// </summary>
        public int ControlPointCount { get { return ControlPoints.Count; } }

        /// <summary>
        /// Gets total Cache Size
        /// </summary>
        public int CacheSize
        {
            get
            {
                if (mCacheSize < 0)
                {
#if CURVY_SANITY_CHECKS
                    DoSanityChecks();
#endif
                    int cacheSize = 0;
                    List<CurvySplineSegment> segments = Segments;
                    for (int i = 0; i < segments.Count; i++)
                        cacheSize += segments[i].CacheSize;

                    if (Dirty == false)
                        mCacheSize = cacheSize;
                    return cacheSize;
                }
                return mCacheSize;
            }
        }

        /// <summary>
        /// Gets the total length of the Spline or SplineGroup
        /// </summary>
        /// <remarks>The accuracy depends on the current Granularity (higher Granularity means more exact values)</remarks>
        public float Length
        {
            get
            {
                if (length < 0)
                {
#if CURVY_SANITY_CHECKS
                    DoSanityChecks();
#endif

                    float tempLength;
                    if (Segments.Count == 0)
                        tempLength = 0;
                    else
                        tempLength = (Closed) ? this[Count - 1].Distance + this[Count - 1].Length : LastVisibleControlPoint.Distance;
                    if (Dirty == false)
                        length = tempLength;
                    return tempLength;
                }
                return length;
            }
        }

        /// <summary>
        /// When a spline is dirty, this means that it's cached data is no more up to date, and should be updated. The update is done automatically each frame when needed, or manually by calling <see cref="Refresh"/>
        /// </summary>
        public bool Dirty
        {
            get
            {
                return (allControlPointsAreDirty || dirtyControlPointsMinimalSet.Count > 0);
            }
        }

        /// <summary>
        /// Gets the Segment at a certain index
        /// </summary>
        /// <param name="idx">an index in the range 0..Count</param>
        /// <returns>the corresponding spline segment</returns>
        public CurvySplineSegment this[int idx]
        {
            get
            {
#if CONTRACTS_FULL
                Contract.Requires(idx > -1 && idx < Segments.Count);
#endif
                return Segments[idx];
            }
        }

        /// <summary>
        /// The list of control points
        /// </summary>
        public ReadOnlyCollection<CurvySplineSegment> ControlPointsList
        {
            //TODO use IReadOnlyList when .NET 4.6 will be default
            get
            {
                //OPTIM find the proper place to initialize readOnlyControlPoints, to avoid the if bellow to be tested at each call.
                //Note: even when initializing readOnlyControlPoints in Awake, OnEnable, OnAfterDeserialize  and OnValidate, scene 25 had a null reference exception on readOnlyControlPoints. Here is the stack trace:
                /*
                NullReferenceException: Object reference not set to an instance of an object
                FluffyUnderware.Curvy.CurvySpline.GetControlPointIndex (FluffyUnderware.Curvy.CurvySplineSegment controlPoint) (at Assets/Packages/Curvy/Base/CurvySpline.cs:254)
                FluffyUnderware.Curvy.CurvySplineSegment.GetPreviousControlPoint (System.Boolean segmentsOnly, System.Boolean useFollowUp) (at Assets/Packages/Curvy/Base/CurvySplineSegment.cs:1552)
                FluffyUnderware.Curvy.CurvySplineSegment.SetDirty (System.Boolean dirtyCurve, System.Boolean dirtyOrientation) (at Assets/Packages/Curvy/Base/CurvySplineSegment.cs:2148)
                FluffyUnderware.Curvy.CurvyMetadataBase.SetDirty () (at Assets/Packages/Curvy/Base/CurvyMetadataBase.cs:84)
                FluffyUnderware.Curvy.MetaCGOptions.OnValidate () (at Assets/Packages/Curvy/Base/CG/MetaCGOptions.cs:239)
                */
                if (readOnlyControlPoints == null)
                    readOnlyControlPoints = ControlPoints.AsReadOnly();
                return readOnlyControlPoints;
            }
        }



        /// <summary>
        /// Gets the first visible Control Point (equals the first segment or this[0])
        /// </summary>
        /// <remarks>Can be null, for example for a Catmull-Rom spline whith only two splines and AutoEndTangent set to false</remarks>
        [CanBeNull]
        public CurvySplineSegment FirstVisibleControlPoint
        {
            get
            {
                if (isCpsRelationshipCacheValid == false)
                    RebuildControlPointsRelationshipCache(true);
                return firstVisibleControlPoint;
            }
        }

        /// <summary>
        /// Gets the last visible Control Point (i.e. the end CP of the last segment)
        /// </summary>
        /// <remarks>Is null if spline has no segments</remarks>
        [CanBeNull]
        public CurvySplineSegment LastVisibleControlPoint
        {
            get
            {
                if (isCpsRelationshipCacheValid == false)
                    RebuildControlPointsRelationshipCache(true);
                return lastVisibleControlPoint;
            }
        }

        /// <summary>
        /// Gets the first segment of the spline
        /// </summary>
        public CurvySplineSegment FirstSegment
        {
            get
            {
                if (isCpsRelationshipCacheValid == false)
                    RebuildControlPointsRelationshipCache(true);
                return firstSegment;
            }
        }

        /// <summary>
        /// Gets the last segment of the spline
        /// </summary>
        public CurvySplineSegment LastSegment
        {
            get
            {
                if (isCpsRelationshipCacheValid == false)
                    RebuildControlPointsRelationshipCache(true);
                return lastSegment;
            }
        }

        /// <summary>
        /// Returns true if the global position, rotation or scale of the spline has changed this frame
        /// </summary>
        /// <seealso cref="OnGlobalCoordinatesChanged"/>
        public bool GlobalCoordinatesChangedThisFrame
        {
            get { return globalCoordinatesChangedThisFrame; }
        }

        /// <summary>
        /// Is triggered when the global position, rotation or scale of the spline changes.
        /// The triggering instance of CurvySpline is passed as a parameter of the delegate
        /// </summary>
        /// <remarks>This is triggered at the very end of the spline updating method. <see cref="UpdateIn"/></remarks>
        /// <seealso cref="GlobalCoordinatesChangedThisFrame"/>
        public Action<CurvySpline> OnGlobalCoordinatesChanged { get; set; }

        public CurvySplineEvent OnRefresh
        {
            get { return m_OnRefresh; }
            set
            {
                if (m_OnRefresh != value)
                    m_OnRefresh = value;

            }

        }
        /// <summary>
        /// Callback after one or more Control Points have been added or deleted
        /// </summary>
        /// <remarks>This executes last, after individual add/delete events and OnRefresh </remarks>
        public CurvySplineEvent OnAfterControlPointChanges
        {
            get { return m_OnAfterControlPointChanges; }
            set
            {
                if (m_OnAfterControlPointChanges != value)
                    m_OnAfterControlPointChanges = value;
            }
        }
        /// <summary>
        /// Callback before a Control Point is about to be added
        /// </summary>
        public CurvyControlPointEvent OnBeforeControlPointAdd
        {
            get { return m_OnBeforeControlPointAdd; }
            set
            {
                if (m_OnBeforeControlPointAdd != value)
                    m_OnBeforeControlPointAdd = value;
            }
        }
        /// <summary>
        /// Callback after a Control Point has been added and the spline was refreshed
        /// </summary>
        public CurvyControlPointEvent OnAfterControlPointAdd
        {
            get { return m_OnAfterControlPointAdd; }
            set
            {
                if (m_OnAfterControlPointAdd != value)
                    m_OnAfterControlPointAdd = value;
            }

        }
        /// <summary>
        /// Callback before a Control Point is about to be deleted. Return false to cancel the execution.
        /// </summary>
        public CurvyControlPointEvent OnBeforeControlPointDelete
        {
            get { return m_OnBeforeControlPointDelete; }
            set
            {
                if (m_OnBeforeControlPointDelete != value)
                    m_OnBeforeControlPointDelete = value;
            }
        }

        #endregion

        #endregion

        #region ### Public Static Methods ###

        /// <summary>
        /// Creates an empty spline
        /// </summary>
        public static CurvySpline Create()
        {
            CurvySpline spl = new GameObject("Curvy Spline", typeof(CurvySpline)).GetComponent<CurvySpline>();
            spl.gameObject.layer = CurvyGlobalManager.SplineLayer;
            spl.Start();
            return spl;
        }

        /// <summary>
        /// Creates an empty spline with the same settings as another spline
        /// </summary>
        /// <param name="takeOptionsFrom">another spline</param>
        public static CurvySpline Create(CurvySpline takeOptionsFrom)
        {
            CurvySpline spl = Create();
            if (takeOptionsFrom)
            {
                spl.RestrictTo2D = takeOptionsFrom.RestrictTo2D;
                spl.GizmoColor = takeOptionsFrom.GizmoColor;
                spl.GizmoSelectionColor = takeOptionsFrom.GizmoSelectionColor;
                spl.Interpolation = takeOptionsFrom.Interpolation;
                spl.Closed = takeOptionsFrom.Closed;
                spl.AutoEndTangents = takeOptionsFrom.AutoEndTangents;
                spl.CacheDensity = takeOptionsFrom.CacheDensity;
                spl.MaxPointsPerUnit = takeOptionsFrom.MaxPointsPerUnit;
                spl.Orientation = takeOptionsFrom.Orientation;
                spl.CheckTransform = takeOptionsFrom.CheckTransform;
            }
            return spl;
        }

        /// <summary>
        /// Gets the number of Cache Points needed for a certain part of a spline
        /// </summary>
        /// <param name="density">A value between 1 and 100 included. When equal to 100, the number of cache points per world distance unit is equal to maxPointsPerUnit</param>
        /// <param name="segmentLength">the length of the spline segment</param>
        /// <param name="maxPointsPerUnit">Maximum number of Cache Points per world distance unit</param>
        public static int CalculateCacheSize(int density, float segmentLength, float maxPointsPerUnit)
        {
#if CONTRACTS_FULL
            Contract.Requires(CodeContractsUtility.IsPositiveNumber(segmentLength));
#endif
            //This basically equals to Mathf.FloorToInt(length * (maxPointsPerUnit * (density - 1) / 99) + MinimalMaxPointsPerUnit) + 1
            //Here is a plot of (density - 1) / 99)
            //https://www.wolframalpha.com/input/?i=plot+((x+-+1)+%2F+99+)%5E2+for+x+from+1+to+100
            float samplePoints = CalculateSamplingPointsPerUnit(density, maxPointsPerUnit) * segmentLength;
            samplePoints = Math.Min(samplePoints, MaxSegmentCacheSize - 1);
            return Mathf.FloorToInt(samplePoints) + 1;
        }

        /// <summary>
        /// Returns the (floating) number of sampling points per world distance unit.
        /// </summary>
        /// <param name="density">A value between 1 and 100 included. When equal to 100, the number of sampling points per world distance unit is equal to maxPointsPerUnit</param>
        /// <param name="maxPointsPerUnit">Maximum number of sampling points per world distance unit</param>
        /// <returns></returns>
        static public float CalculateSamplingPointsPerUnit(int density, float maxPointsPerUnit)
        {
#if CONTRACTS_FULL
            Contract.Requires(density > 0);
            Contract.Requires(density <= 100);
            Contract.Requires(maxPointsPerUnit.IsPositiveNumber());
#endif
            int clampedDensity = Mathf.Clamp(density, 1, 100);
            if (clampedDensity != density)
            {
                DTLog.LogWarning("[Curvy] CalculateSamplingPointsPerUnit got an invalid density parameter. It should be between 1 and 100. The parameter value was " + density);
                density = clampedDensity;
            }

            //This basically equals to (maxPointsPerUnit * (density - 1) / 99) + MinimalMaxPointsPerUnit)
            //Here is a plot of (density - 1) / 99)
            //https://www.wolframalpha.com/input/?i=plot+((x+-+1)+%2F+99+)%5E2+for+x+from+1+to+100
            return DTTween.QuadIn(density - 1, MinimalMaxPointsPerUnit, maxPointsPerUnit, 99);
        }

        /// <summary>
        /// Cubic-Beziere Interpolation
        /// </summary>
        /// <param name="T0">HandleIn</param>
        /// <param name="P0">Pn</param>
        /// <param name="P1">Pn+1</param>
        /// <param name="T1">HandleOut</param>
        /// <param name="f">f in the range 0..1</param>
        /// <returns></returns>
        public static Vector3 Bezier(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f)
        {
            //If you modify this, modify also the inlined version of this method in refreshCurveINTERNAL()

            const double Ft2 = 3; const double Ft3 = -3;
            const double Fu1 = 3; const double Fu2 = -6; const double Fu3 = 3;
            const double Fv1 = -3; const double Fv2 = 3;

            double FAX = -P0.x + Ft2 * T0.x + Ft3 * T1.x + P1.x;
            double FBX = Fu1 * P0.x + Fu2 * T0.x + Fu3 * T1.x;
            double FCX = Fv1 * P0.x + Fv2 * T0.x;
            double FDX = P0.x;

            double FAY = -P0.y + Ft2 * T0.y + Ft3 * T1.y + P1.y;
            double FBY = Fu1 * P0.y + Fu2 * T0.y + Fu3 * T1.y;
            double FCY = Fv1 * P0.y + Fv2 * T0.y;
            double FDY = P0.y;

            double FAZ = -P0.z + Ft2 * T0.z + Ft3 * T1.z + P1.z;
            double FBZ = Fu1 * P0.z + Fu2 * T0.z + Fu3 * T1.z;
            double FCZ = Fv1 * P0.z + Fv2 * T0.z;
            double FDZ = P0.z;

            float FX = (float)(((FAX * f + FBX) * f + FCX) * f + FDX);
            float FY = (float)(((FAY * f + FBY) * f + FCY) * f + FDY);
            float FZ = (float)(((FAZ * f + FBZ) * f + FCZ) * f + FDZ);

            Vector3 result;
            result.x = FX;
            result.y = FY;
            result.z = FZ;
            return result;
        }

        //OPTIM Is using this better than using positions delta?
        public static Vector3 BezierTangent(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f)
        {
            Vector3 C1 = (P1 - (3.0f * T1) + (3.0f * T0) - P0);
            Vector3 C2 = ((3.0f * T1) - (6.0f * T0) + (3.0f * P0));
            Vector3 C3 = ((3.0f * T0) - (3.0f * P0));
            return ((3.0f * f * f * C1) + (2.0f * f * C2) + C3);
        }

        /// <summary>
        /// Catmull-Rom Interpolation
        /// </summary>
        /// <param name="T0">Pn-1 (In Tangent)</param>
        /// <param name="P0">Pn</param>
        /// <param name="P1">Pn+1</param>
        /// <param name="T1">Pn+2 (Out Tangent)</param>
        /// <param name="f">f in the range 0..1</param>
        /// <returns>the interpolated position</returns>
        public static Vector3 CatmullRom(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f)
        {
            //If you modify this, modify also the inlined version of this method in refreshCurveINTERNAL()

            const double Ft1 = -0.5; const double Ft2 = 1.5; const double Ft3 = -1.5; const double Ft4 = 0.5;
            const double Fu2 = -2.5; const double Fu3 = 2; const double Fu4 = -0.5;
            const double Fv1 = -0.5; const double Fv3 = 0.5;

            double FAX = Ft1 * T0.x + Ft2 * P0.x + Ft3 * P1.x + Ft4 * T1.x;
            double FBX = T0.x + Fu2 * P0.x + Fu3 * P1.x + Fu4 * T1.x;
            double FCX = Fv1 * T0.x + Fv3 * P1.x;
            double FDX = P0.x;

            double FAY = Ft1 * T0.y + Ft2 * P0.y + Ft3 * P1.y + Ft4 * T1.y;
            double FBY = T0.y + Fu2 * P0.y + Fu3 * P1.y + Fu4 * T1.y;
            double FCY = Fv1 * T0.y + Fv3 * P1.y;
            double FDY = P0.y;

            double FAZ = Ft1 * T0.z + Ft2 * P0.z + Ft3 * P1.z + Ft4 * T1.z;
            double FBZ = T0.z + Fu2 * P0.z + Fu3 * P1.z + Fu4 * T1.z;
            double FCZ = Fv1 * T0.z + Fv3 * P1.z;
            double FDZ = P0.z;

            float FX = (float)(((FAX * f + FBX) * f + FCX) * f + FDX);
            float FY = (float)(((FAY * f + FBY) * f + FCY) * f + FDY);
            float FZ = (float)(((FAZ * f + FBZ) * f + FCZ) * f + FDZ);

            Vector3 result;
            result.x = FX;
            result.y = FY;
            result.z = FZ;
            return result;
        }

        /// <summary>
        /// Kochanek-Bartels/TCB-Interpolation
        /// </summary>
        /// <param name="T0">Pn-1 (In Tangent)</param>
        /// <param name="P0">Pn</param>
        /// <param name="P1">Pn+1</param>
        /// <param name="T1">Pn+2 (Out Tangent)</param>
        /// <param name="f">f in the range 0..1</param>
        /// <param name="FT0">Start Tension</param>
        /// <param name="FC0">Start Continuity</param>
        /// <param name="FB0">Start Bias</param>
        /// <param name="FT1">End Tension</param>
        /// <param name="FC1">End Continuity</param>
        /// <param name="FB1">End Bias</param>
        /// <returns>the interpolated position</returns>
        public static Vector3 TCB(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f, float FT0, float FC0, float FB0, float FT1, float FC1, float FB1)
        {
            //If you modify this, modify also the inlined version of this method in refreshCurveINTERNAL()

            double FFA = (1 - FT0) * (1 + FC0) * (1 + FB0);
            double FFB = (1 - FT0) * (1 - FC0) * (1 - FB0);
            double FFC = (1 - FT1) * (1 - FC1) * (1 + FB1);
            double FFD = (1 - FT1) * (1 + FC1) * (1 - FB1);

            double DD = 2;
            double Ft1 = -FFA / DD; double Ft2 = (+4 + FFA - FFB - FFC) / DD; double Ft3 = (-4 + FFB + FFC - FFD) / DD; double Ft4 = FFD / DD;
            double Fu1 = +2 * FFA / DD; double Fu2 = (-6 - 2 * FFA + 2 * FFB + FFC) / DD; double Fu3 = (+6 - 2 * FFB - FFC + FFD) / DD; double Fu4 = -FFD / DD;
            double Fv1 = -FFA / DD; double Fv2 = (FFA - FFB) / DD; double Fv3 = FFB / DD;
            double Fw2 = +2 / DD;

            double FAX = Ft1 * T0.x + Ft2 * P0.x + Ft3 * P1.x + Ft4 * T1.x;
            double FBX = Fu1 * T0.x + Fu2 * P0.x + Fu3 * P1.x + Fu4 * T1.x;
            double FCX = Fv1 * T0.x + Fv2 * P0.x + Fv3 * P1.x;
            double FDX = Fw2 * P0.x;

            double FAY = Ft1 * T0.y + Ft2 * P0.y + Ft3 * P1.y + Ft4 * T1.y;
            double FBY = Fu1 * T0.y + Fu2 * P0.y + Fu3 * P1.y + Fu4 * T1.y;
            double FCY = Fv1 * T0.y + Fv2 * P0.y + Fv3 * P1.y;
            double FDY = Fw2 * P0.y;

            double FAZ = Ft1 * T0.z + Ft2 * P0.z + Ft3 * P1.z + Ft4 * T1.z;
            double FBZ = Fu1 * T0.z + Fu2 * P0.z + Fu3 * P1.z + Fu4 * T1.z;
            double FCZ = Fv1 * T0.z + Fv2 * P0.z + Fv3 * P1.z;
            double FDZ = Fw2 * P0.z;

            float FX = (float)(((FAX * f + FBX) * f + FCX) * f + FDX);
            float FY = (float)(((FAY * f + FBY) * f + FCY) * f + FDY);
            float FZ = (float)(((FAZ * f + FBZ) * f + FCZ) * f + FDZ);

            Vector3 result;
            result.x = FX;
            result.y = FY;
            result.z = FZ;
            return result;
        }


        /// <summary>
        /// This method returns the Control Point next to the Follow-Up, based on the ConnectionHeadingEnum's value
        /// </summary>
        /// <param name="followUp">The Control Point used as a Follow-Up</param>
        /// <param name="headingDirection">The head to direction</param>
        /// <returns>The Control Point the Follow-Up is heading to </returns>
        [NotNull]
        public static CurvySplineSegment GetFollowUpHeadingControlPoint(CurvySplineSegment followUp, ConnectionHeadingEnum headingDirection)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(followUp != null);
            Assert.IsTrue(followUp.Spline != null);
#endif
            ConnectionHeadingEnum resolveHeading = headingDirection.ResolveAuto(followUp);
            CurvySplineSegment result;
            switch (resolveHeading)
            {
                case ConnectionHeadingEnum.Minus:
                    result = followUp.Spline.GetPreviousControlPoint(followUp);
                    break;
                case ConnectionHeadingEnum.Plus:
                    result = followUp.Spline.GetNextControlPoint(followUp);
                    break;
                case ConnectionHeadingEnum.Sharp:
                    result = followUp;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            return result;
        }

        #endregion

        #region ### Public Methods ###

        #region --- Methods based on TF (total fragment) ---

        /// <summary>
        /// Gets the position of a point on the spline segment
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 Interpolate(float tf, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                return seg.Interpolate(localF, space);

            return space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets the position of a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 InterpolateFast(float tf, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                return seg.InterpolateFast(localF, space);

            return space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets the position of a point on the spline segment
        /// </summary>
        /// <param name="distance">The distance between the spline's start and the point you are interested in. Value should be in the range from 0 to <see cref="Length"/> inclusive</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 InterpolateByDistance(float distance, Space space = Space.Self)
        {
            return Interpolate(DistanceToTF(distance), space);
        }

        /// <summary>
        /// Gets the position of a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="distance">The distance between the spline's start and the point you are interested in. Value should be in the range from 0 to <see cref="Length"/> inclusive</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 InterpolateByDistanceFast(float distance, Space space = Space.Self)
        {
            return InterpolateFast(DistanceToTF(distance), space);
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 GetTangent(float tf, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                return seg.GetTangent(localF, space);

            return space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment.
        /// This method is faster than <see cref="GetTangent(float, Space)"/> if you have already the position of the point.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="position">the position of the point at localF. In other words, the result of <see cref="Interpolate(float, Space)"/></param>
        /// <param name="space">The space (local/object or global/world) in which the returned result and the <paramref name="position"/> parameter are expressed</param>
        public Vector3 GetTangent(float tf, Vector3 position, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                return seg.GetTangent(localF, position, space);

            return space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 GetTangentFast(float tf, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                return seg.GetTangentFast(localF, space);

            return space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment
        /// </summary>
        /// <param name="distance">The distance between the spline's start and the point you are interested in. Value should be in the range from 0 to <see cref="Length"/> inclusive</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 GetTangentByDistance(float distance, Space space = Space.Self)
        {
            return GetTangent(DistanceToTF(distance), space);
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="distance">The distance between the spline's start and the point you are interested in. Value should be in the range from 0 to <see cref="Length"/> inclusive</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 GetTangentByDistanceFast(float distance, Space space = Space.Self)
        {
            return GetTangentFast(DistanceToTF(distance), space);
        }

        /// <summary>
        /// Gets the position and normalized tangent at a point on the spline segment
        /// Is Faster than calling <see cref="Interpolate(float, Space)"/> and <see cref="Interpolate(float, Space)"/> separately
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="position">the output position</param>
        /// <param name="tangent">the output tangent</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public void InterpolateAndGetTangent(float tf, out Vector3 position, out Vector3 tangent, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                seg.InterpolateAndGetTangent(localF, out position, out tangent, space);
            else
                position = tangent = space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets the position and normalized tangent at a point on the spline segment
        /// Is Faster than calling <see cref="Interpolate(float, Space)"/> and <see cref="Interpolate(float, Space)"/> separately
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="position">the output position</param>
        /// <param name="tangent">the output tangent</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public void InterpolateAndGetTangentFast(float tf, out Vector3 position, out Vector3 tangent, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                seg.InterpolateAndGetTangentFast(localF, out position, out tangent, space);
            else
                position = tangent = space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets the Up vector of a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 GetOrientationUpFast(float tf, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                return seg.GetOrientationUpFast(localF, space);

            return space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets a rotation looking to Tangent with the head upwards along the Up-Vector
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="inverse">whether the orientation should be inversed or not</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <returns>a rotation, relative to the spline's local space</returns>
        public Quaternion GetOrientationFast(float tf, bool inverse = false, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                return seg.GetOrientationFast(localF, inverse, space);

            return space == Space.Self ? Quaternion.identity : cachedTransform.rotation;
        }

        /// <summary>
        /// Gets metadata for a certain TF
        /// </summary>
        /// <typeparam name="T">Metadata type interfacing ICurvyMetadata</typeparam>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <returns>the metadata</returns>
        public T GetMetadata<T>(float tf) where T : CurvyMetadataBase
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            return ReferenceEquals(seg, null) == false ? seg.GetMetadata<T>() : null;
        }


        /// <summary>
        /// Gets an interpolated Metadata value for a certain TF
        /// </summary>
        /// <typeparam name="T">Metadata type inheriting from CurvyInterpolatableMetadataBase</typeparam>
        /// <typeparam name="U">Metadata's Value type</typeparam>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <returns>The interpolated value. If no Metadata of specified type is present at the given tf, the default value of type U is returned</returns>
        public U GetInterpolatedMetadata<T, U>(float tf) where T : CurvyInterpolatableMetadataBase<U>
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            return ReferenceEquals(seg, null) == false ? seg.GetInterpolatedMetadata<T, U>(localF) : default;
        }

        #endregion

        #region --- Conversion Methods ---

        /// <summary>
        /// Converts a TF value to a distance
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="clamping">Clamping to use</param>
        /// <returns>distance from spline's start</returns>
        public float TFToDistance(float tf, CurvyClamping clamping = CurvyClamping.Clamp)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif
            float splineLength = Length;

            float result;
            if (splineLength == 0)
                result = 0;
            else if (tf == 0)
                result = 0;
            else if (tf == 1)
                result = splineLength;
            else
            {
                float localF;
                CurvySplineSegment seg = TFToSegment(tf, out localF, clamping);
                result = (ReferenceEquals(seg, null) == false) ? seg.Distance + seg.LocalFToDistance(localF) : 0;
            }
            return result;
        }

        /// <summary>
        /// Gets the segment and the local F for a certain TF
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="localF">gets the remaining localF in the range 0..1</param>
        /// <param name="isOnSegmentStart">Is True if the given distance is positioned at the returned segment's start</param>
        /// <param name="isOnSegmentEnd">Is True if the given distance is positioned at the returned segment's end</param>
        /// <param name="clamping">Clamping to use</param>
        /// <returns>the segment the given TF is inside</returns>
        public CurvySplineSegment TFToSegment(float tf, out float localF, out bool isOnSegmentStart, out bool isOnSegmentEnd, CurvyClamping clamping)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            tf = CurvyUtility.ClampTF(tf, clamping);
            int segmentsCount = Count;
            if (segmentsCount == 0)
            {
                localF = 0;
                isOnSegmentStart = false;
                isOnSegmentEnd = false;
                return null;
            }

            float f = tf * segmentsCount;
            int idx = (int)f;
            localF = f - idx;

            if (idx == segmentsCount)
            {
                idx--;
                localF = 1;
            }

            isOnSegmentStart = f == (float)idx;
            isOnSegmentEnd = tf == 1f;

            return this[idx];
        }

        /// <summary>
        /// Gets the segment and the local F for a certain TF
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="localF">gets the remaining localF in the range 0..1</param>
        /// <param name="clamping">Clamping to use</param>
        /// <returns>the segment the given TF is inside</returns>
        public CurvySplineSegment TFToSegment(float tf, out float localF, CurvyClamping clamping)
        {
            return TFToSegment(tf, out localF, out _, out _, clamping);
        }

        /// <summary>
        /// Gets the segment for a certain TF
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="clamping">Clamping to use</param>
        /// <returns>the segment the given TF is inside</returns>
        public CurvySplineSegment TFToSegment(float tf, CurvyClamping clamping)
        {
            return TFToSegment(tf, out _, clamping);
        }

        /// <summary>
        /// Gets the segment for a certain TF clamped to 0..1
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <returns>the segment the given TF is inside</returns>
        public CurvySplineSegment TFToSegment(float tf)
        {
            return TFToSegment(tf, out _, CurvyClamping.Clamp);
        }
        /// <summary>
        /// Gets the segment and the local F for a certain TF clamped to 0..1
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="localF">gets the remaining localF in the range 0..1</param>
        /// <returns>the segment the given TF is inside</returns>
        public CurvySplineSegment TFToSegment(float tf, out float localF)
        {
            return TFToSegment(tf, out localF, CurvyClamping.Clamp);
        }

        /// <summary>
        /// Gets a TF value from a segment
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="segment">a segment</param>
        /// <returns>a TF value in the range 0..1</returns>
        public float SegmentToTF(CurvySplineSegment segment)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, segment.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, segment, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            return segment.GetExtrinsicPropertiesINTERNAL().TF;
        }

        /// <summary>
        /// Gets a TF value from a segment and a local F
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="segment">a segment</param>
        /// <param name="localF">F of this segment in the range 0..1</param>
        /// <returns>a TF value in the range 0..1</returns>
        public float SegmentToTF(CurvySplineSegment segment, float localF)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, segment.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, segment, name));
            Assert.IsTrue(localF.IsBetween0And1(), localF.ToString("R"));
#endif

            float result;
            if (IsControlPointASegment(segment))
            {
                //OPTIM a possible optimization would be to make this branch of the if the only executed code, so no call to IsControlPointASegment. the comparison with 1 bellow will take care of the last cp. The only remaining issue would be to handle the fake first cp create by AutoEndTangents for CatmullRom and TCB splines. I believe the only way to handle it would be to have separate treatment for autoendtangents. Might still be worth it.

                result = SegmentToTF(segment) + (localF / Count);
                //sometimes due to float imprecision, result can go beyond 1
                if (result > 1)
                    result = 1;
            }
            else
                result = SegmentToTF(segment);

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(result.IsBetween0And1(), result.ToString("R"));
#endif

            return result;
        }

        /// <summary>
        /// Converts a distance to a TF value
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="distance">distance</param>
        /// <param name="clamping">Clamping to use</param>
        /// <returns>a TF value in the range 0..1</returns>
        public float DistanceToTF(float distance, CurvyClamping clamping = CurvyClamping.Clamp)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif
            float result;
            if (Length == 0)
                result = 0;
            else if (distance == 0)
                result = 0;
            else if (distance == Length)
                result = 1;
            else
            {
                float localDistance;
                // Get the segment the distance lies within
                CurvySplineSegment seg = DistanceToSegment(distance, out localDistance, clamping);
                result = ReferenceEquals(seg, null) == false ? SegmentToTF(seg, seg.DistanceToLocalF(localDistance)) : 0;
            }
            return result;
        }

        /// <summary>
        /// Gets the segment a certain distance lies within
        /// </summary>
        /// <param name="distance">a distance in the range 0..Length</param>
        /// <param name="clamping">clamping to use</param>
        /// <returns>a spline segment or null</returns>
        public CurvySplineSegment DistanceToSegment(float distance, CurvyClamping clamping = CurvyClamping.Clamp)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float d;
            return DistanceToSegment(distance, out d, clamping);
        }

        /// <summary>
        /// Gets the segment a certain distance lies within
        /// </summary>
        /// <param name="distance">a distance in the range 0..Length</param>
        /// <param name="localDistance">gets the remaining distance inside the segment</param>
        /// <param name="clamping">clamping to use</param>
        /// <returns>a spline segment</returns>
        public CurvySplineSegment DistanceToSegment(float distance, out float localDistance, CurvyClamping clamping = CurvyClamping.Clamp)
        {
            return DistanceToSegment(distance, out localDistance, out _, out _, clamping);
        }

        /// <summary>
        /// Gets the segment a certain distance lies within
        /// </summary>
        /// <param name="distance">a distance in the range 0..Length</param>
        /// <param name="localDistance">gets the remaining distance inside the segment</param>
        /// <param name="isOnSegmentStart">Is True if the given distance is positioned at the returned segment's start</param>
        /// <param name="isOnSegmentEnd">Is True if the given distance is positioned at the returned segment's end</param>
        /// <param name="clamping">clamping to use</param>
        /// <returns>a spline segment</returns>
        public CurvySplineSegment DistanceToSegment(float distance, out float localDistance, out bool isOnSegmentStart, out bool isOnSegmentEnd, CurvyClamping clamping = CurvyClamping.Clamp)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif
            distance = CurvyUtility.ClampDistance(distance, clamping, Length);
            CurvySplineSegment resultSegment;
            if (Count > 0)
            {
                int resultCpIndex = CurvyUtility.InterpolationSearch(controlPointsDistances, controlPointsDistances.Length, distance);
                bool notAutoEndTangents = AutoEndTangents == false;
                int cpCount = ControlPointsList.Count;
                if (notAutoEndTangents)
                {
#if CURVY_SANITY_CHECKS_PRIVATE
                    UnityEngine.Assertions.Assert.IsFalse(Closed);
#endif
                    if (resultCpIndex == 0)
                        resultCpIndex = 1;
                    else if (resultCpIndex == cpCount - 1 || resultCpIndex == cpCount - 2)
                        resultCpIndex = cpCount - 3;
                }
                else if (Closed == false && resultCpIndex == cpCount - 1)
                    resultCpIndex = cpCount - 2;

                resultSegment = ControlPointsList[resultCpIndex];
                localDistance = distance - resultSegment.Distance;

                isOnSegmentStart = distance == resultSegment.Distance;
                isOnSegmentEnd = distance == Length;
            }
            else
            {
                resultSegment = null;
                localDistance = -1;
                isOnSegmentStart = false;
                isOnSegmentEnd = false;
            }

            return resultSegment;
        }


        #endregion


        #region Clamping

        /// <summary>
        /// Clamps absolute position
        /// </summary>
        public float ClampDistance(float distance, CurvyClamping clamping)
        {
            return CurvyUtility.ClampDistance(distance, clamping, Length);
        }

        /// <summary>
        /// Clamps absolute position
        /// </summary>
        public float ClampDistance(float distance, CurvyClamping clamping, float min, float max)
        {
            return CurvyUtility.ClampDistance(distance, clamping, Length, min, max);
        }

        /// <summary>
        /// Clamps absolute position and sets new direction
        /// </summary>
        public float ClampDistance(float distance, ref int dir, CurvyClamping clamping)
        {
            return CurvyUtility.ClampDistance(distance, ref dir, clamping, Length);
        }

        /// <summary>
        /// Clamps absolute position and sets new direction
        /// </summary>
        public float ClampDistance(float distance, ref int dir, CurvyClamping clamping, float min, float max)
        {
            return CurvyUtility.ClampDistance(distance, ref dir, clamping, Length, min, max);
        }

        #endregion

        #region --- General ---

        /// <summary>
        /// Adds a Control Point at the end of the spline
        /// This method will <see cref="Refresh"/> the spline and call the relevant events.
        /// If you want more control on the order of the added Control Point, its position, or whether <see cref="Refresh"/> and events should be called, use the <see cref="InsertBefore(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="InsertAfter(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="Add(Vector3,Space)"/> instead
        /// </summary>
        /// <returns>The added Control Point</returns>
        public CurvySplineSegment Add() { return InsertAfter(null, false); }

        /// <summary>
        /// Adds several Control Points at the end of the spline
        /// This method will <see cref="Refresh"/> the spline and call the relevant events.
        /// If you want more control on the order of the added Control Points, their position, or whether <see cref="Refresh"/> and events should be called, use the <see cref="InsertBefore(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="InsertAfter(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="Add(Vector3[],Space)"/> instead
        /// </summary>
        /// <param name="controlPointsCount">The number of  Control Points to add</param>
        public CurvySplineSegment[] Add(int controlPointsCount)
        {
            Vector3[] controlPointsLocalPositions = new Vector3[controlPointsCount];
            return Add(controlPointsLocalPositions);
        }

        /// <summary>
        /// Adds several Control Points at the end of the spline
        /// This method will <see cref="Refresh"/> the spline and call the relevant events.
        /// If you want more control on the order of the added Control Points, their position, or whether <see cref="Refresh"/> and events should be called, use the <see cref="InsertBefore(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="InsertAfter(CurvySplineSegment,Vector3,bool,Space)"/> instead
        /// </summary>
        /// <param name="controlPointPosition">The position of the Control Point to add</param>
        /// <param name="space">Whether the position is in the local or global space</param>
        /// <returns>The added Control Points</returns>
        public CurvySplineSegment Add(Vector3 controlPointPosition, Space space)
        {
            OnBeforeControlPointAddEvent(defaultAddAfterEventArgs);

            CurvySplineSegment result = InsertAfter(null, controlPointPosition, true, space);

            Refresh();
            OnAfterControlPointAddEvent(defaultAddAfterEventArgs);
            OnAfterControlPointChangesEvent(defaultSplineEventArgs);

            return result;
        }

        /// <summary>
        /// Adds several Control Points at the end of the spline
        /// This method will <see cref="Refresh"/> the spline and call the relevant events.
        /// If you want more control on the order of the added Control Points, their position, or whether <see cref="Refresh"/> and events should be called, use the <see cref="InsertBefore(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="InsertAfter(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="Add(Vector3[],Space)"/> instead
        /// </summary>
        /// <param name="controlPointsLocalPositions">The local position of the Control Points to add</param>
        /// <returns>The added Control Points</returns>
        public CurvySplineSegment[] Add(params Vector3[] controlPointsLocalPositions)
        {
            OnBeforeControlPointAddEvent(defaultAddAfterEventArgs);

            CurvySplineSegment[] cps = new CurvySplineSegment[controlPointsLocalPositions.Length];
            for (int i = 0; i < controlPointsLocalPositions.Length; i++)
                cps[i] = InsertAfter(null, controlPointsLocalPositions[i], true, Space.Self);

            Refresh();
            OnAfterControlPointAddEvent(defaultAddAfterEventArgs);
            OnAfterControlPointChangesEvent(defaultSplineEventArgs);

            return cps;
        }

        /// <summary>
        /// Adds several Control Points at the end of the spline
        /// This method will <see cref="Refresh"/> the spline and call the relevant events.
        /// If you want more control on the order of the added Control Points, their position, or whether <see cref="Refresh"/> and events should be called, use the <see cref="InsertBefore(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="InsertAfter(CurvySplineSegment,Vector3,bool,Space)"/> instead
        /// </summary>
        /// <param name="controlPointsPositions">The positions of the Control Points to add</param>
        /// <param name="space">Whether the positions are in the local or global space</param>
        /// <returns>The added Control Points</returns>
        public CurvySplineSegment[] Add(Vector3[] controlPointsPositions, Space space)
        {
            OnBeforeControlPointAddEvent(defaultAddAfterEventArgs);

            CurvySplineSegment[] cps = new CurvySplineSegment[controlPointsPositions.Length];
            for (int i = 0; i < controlPointsPositions.Length; i++)
                cps[i] = InsertAfter(null, controlPointsPositions[i], true, space);

            Refresh();
            OnAfterControlPointAddEvent(defaultAddAfterEventArgs);
            OnAfterControlPointChangesEvent(defaultSplineEventArgs);

            return cps;
        }

        /// <summary>
        /// Inserts a Control Point before a given Control Point
        /// </summary>
        /// <remarks>If you add several Control Points in a row, using <see cref="Add(Vector3[] controlPoints)"/> will be more efficient</remarks>
        /// <param name="controlPoint">A control point of the spline, before which the new control point will be added. If null, the CP will be added at the start of the spline</param>
        /// <returns>The created Control Point</returns>
        /// <param name="skipRefreshingAndEvents">If true, the spline's <see cref="Refresh"/> method will not be called, and the relevant events will not be triggered</param>
        public CurvySplineSegment InsertBefore(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents = false)
        {
            Vector3 position;
            CurvySplineSegment previousControlPoint;
            if (controlPoint && (previousControlPoint = GetPreviousControlPoint(controlPoint)))
                position = IsControlPointASegment(previousControlPoint) ?
                    previousControlPoint.Interpolate(0.5f, Space.World) :
                    OptimizedOperators.LerpUnclamped(previousControlPoint.transform.position, controlPoint.transform.position, 0.5f);
            else
                position = transform.position;

            return InsertBefore(controlPoint, position, skipRefreshingAndEvents, Space.World);
        }

        /// <summary>
        /// Inserts a Control Point before a given Control Point
        /// </summary>
        /// <remarks>If you add several Control Points in a row, using <see cref="Add(Vector3[] controlPoints)"/> will be more efficient</remarks>
        /// <param name="controlPoint">A control point of the spline, before which the new control point will be added. If null, the CP will be added at the start of the spline</param>
        /// <param name="position">The position of the control point at its creation</param>
        /// <param name="skipRefreshingAndEvents">If true, the spline's <see cref="Refresh"/> method will not be called, and the relevant events will not be triggered</param>
        /// <param name="space">Whether the position is in the local or global space</param>
        /// <returns>The created Control Point</returns>
        public CurvySplineSegment InsertBefore([CanBeNull] CurvySplineSegment controlPoint, Vector3 position, bool skipRefreshingAndEvents = false, Space space = Space.World)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(controlPoint, null) == false && ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            return InsertAt(
                controlPoint,
                position,
                ReferenceEquals(controlPoint, null) == false
                    ? Mathf.Max(0, GetControlPointIndex(controlPoint))
                    : 0,
                CurvyControlPointEventArgs.ModeEnum.AddBefore,
                skipRefreshingAndEvents,
                space);
        }

        /// <summary>
        /// Inserts a Control Point after a given Control Point
        /// </summary>
        /// <remarks>If you add several Control Points in a row, using <see cref="Add(Vector3[] controlPoints)"/> will be more efficient</remarks>
        /// <param name="controlPoint">A control point of the spline, behind which the new control point will be added. If null, the CP will be added at the end of the spline</param>
        /// <param name="skipRefreshingAndEvents">If true, the spline's <see cref="Refresh"/> method will not be called, and the relevant events will not be triggered</param>
        /// <returns>the new Control Point</returns>
        public CurvySplineSegment InsertAfter(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents = false)
        {
            Vector3 position;
            if (controlPoint)
            {
                if (IsControlPointASegment(controlPoint))
                    position = controlPoint.Interpolate(0.5f, Space.World);
                else
                {
                    CurvySplineSegment nextControlPoint = GetNextControlPoint(controlPoint);
                    position = nextControlPoint
                        ? OptimizedOperators.LerpUnclamped(nextControlPoint.transform.position, controlPoint.transform.position, 0.5f)
                        : controlPoint.transform.position;
                }
            }
            else
                position = transform.position;

            return InsertAfter(controlPoint, position, skipRefreshingAndEvents, Space.World);
        }

        /// <summary>
        /// Inserts a Control Point after a given Control Point
        /// </summary>
        /// <remarks>If you add several Control Points in a row, using <see cref="Add(Vector3[] controlPoints)"/> will be more efficient</remarks>
        /// <param name="controlPoint">A control point of the spline, behind which the new control point will be added. If null, the CP will be added at the end of the spline</param>
        /// <param name="position">The position of the control point at its creation</param>
        /// <param name="skipRefreshingAndEvents">If true, the spline's <see cref="Refresh"/> method will not be called, and the relevant events will not be triggered</param>
        /// <param name="space">Whether the position is in the local or global space</param>
        /// <returns>the new Control Point</returns>
        public CurvySplineSegment InsertAfter([CanBeNull] CurvySplineSegment controlPoint, Vector3 position, bool skipRefreshingAndEvents = false, Space space = Space.World)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(controlPoint, null) == false && ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif
            return InsertAt(
                controlPoint,
                position,
                ReferenceEquals(controlPoint, null) == false
                    ? GetControlPointIndex(controlPoint) + 1
                    : ControlPoints.Count,
                CurvyControlPointEventArgs.ModeEnum.AddAfter,
                skipRefreshingAndEvents,
                space);
        }

        /// <summary>
        /// Removes all control points
        /// <param name="isUndoable">If true, the clearing of the spline is made undoable (CTRL+Z) in the editor</param>
        /// </summary>
        public void Clear(bool isUndoable = true)
        {
            OnBeforeControlPointDeleteEvent(defaultDeleteEventArgs);

            for (int i = ControlPointCount - 1; i >= 0; i--)
                if (UsePooling && Application.isPlaying)
                {
                    CurvyGlobalManager curvyGlobalManager = CurvyGlobalManager.Instance;
                    if (curvyGlobalManager == null)
                        DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.", this);
                    else
                        curvyGlobalManager.ControlPointPool.Push(ControlPoints[i]);
                }
                else
                {
#if UNITY_EDITOR
                    if (!Application.isPlaying)
                        //BUG I am sure this is source of bug if the scene has an id 42. Check this potential issue
                        _newSelectionInstanceIDINTERNAL = 42; // Prevent selection of another CP/Spline
#endif
                    ControlPoints[i].gameObject.Destroy(isUndoable, true);
                }

            ClearControlPoints();

            Refresh();
            OnAfterControlPointChangesEvent(defaultSplineEventArgs);
#if UNITY_EDITOR
            _newSelectionInstanceIDINTERNAL = 0;
#endif
        }

        /// <summary>
        /// Deletes a Control Point
        /// </summary>
        /// <param name="controlPoint">a Control Point</param>
        /// <param name="skipRefreshingAndEvents">If true, the spline's <see cref="Refresh"/> method will not be called, and the relevant events will not be triggered</param>
        public void Delete(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents = false)
        {
            Delete(controlPoint, skipRefreshingAndEvents, true);
        }

        /// <summary>
        /// Deletes a Control Point
        /// </summary>
        /// <param name="controlPoint">a Control Point</param>
        /// <param name="skipRefreshingAndEvents">If true, the spline's <see cref="Refresh"/> method will not be called, and the relevant events will not be triggered</param>
        /// <param name="isUndoableDeletion">If true, the destruction of the control point's game object is made undoable (CTRL+Z) in the editor</param>
        public void Delete(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents, bool isUndoableDeletion)
        {
            if (!controlPoint)
                return;

#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (skipRefreshingAndEvents == false)
                OnBeforeControlPointDeleteEvent(new CurvyControlPointEventArgs(this, this, controlPoint, CurvyControlPointEventArgs.ModeEnum.Delete));

            RemoveControlPoint(controlPoint);

#if UNITY_EDITOR == false
            //TODO do we need this SetAsLastSibling?
            controlPoint.transform.SetAsLastSibling();// IMPORTANT! Runtime Delete is delayed, so we need to make sure it got sorted to the end 
#endif
            if (UsePooling && Application.isPlaying)
            {
                CurvyGlobalManager curvyGlobalManager = CurvyGlobalManager.Instance;
                if (curvyGlobalManager == null)
                    DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.", this);
                else
                    curvyGlobalManager.ControlPointPool.Push(controlPoint);
            }
            else
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    //BUG I am sure this is source of bug if the scene has an id 42. Check this potential issue
                    _newSelectionInstanceIDINTERNAL = 42; // Prevent selection of another CP/Spline
#endif
                controlPoint.gameObject.Destroy(isUndoableDeletion, true);
            }

            if (skipRefreshingAndEvents == false)
            {
                Refresh();
                OnAfterControlPointChangesEvent(defaultSplineEventArgs);
            }
        }

        #region Cache access

        /// <summary>
        /// Gets an array containing all approximation points
        /// </summary>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <remarks>Returns a copy of the internal cache</remarks>
        /// <returns>an array of world/local positions</returns>
        public SubArray<Vector3> GetPositionsCache(Space space)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif
            SubArray<Vector3> result = ArrayPools.Vector3.Allocate(CacheSize + 1);
            Vector3[] resultArray = result.Array;

            int idx = 0;
            for (int si = 0; si < Count; si++)
            {
                this[si].Approximation.CopyTo(resultArray, idx);
                idx += Mathf.Max(0, this[si].Approximation.Length - 1);
            }

            if (space == Space.World)
            {
                Matrix4x4 m = transform.localToWorldMatrix;
                for (int i = 0; i < result.Count; i++)
                    resultArray[i] = m.MultiplyPoint3x4(resultArray[i]);
            }

            return result;
        }

        /// <summary>
        /// Gets an array containing all approximation points
        /// </summary>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <remarks>This can be used to feed meshbuilders etc...</remarks>
        /// <returns>an array of world/local positions</returns>
        [Obsolete("Use GetPositionsCache instead")]
        public Vector3[] GetApproximation(Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif
            Vector3[] apps = new Vector3[CacheSize + 1];
            int idx = 0;
            for (int si = 0; si < Count; si++)
            {
                this[si].Approximation.CopyTo(apps, idx);
                idx += Mathf.Max(0, this[si].Approximation.Length - 1);
            }

            if (space == Space.World)
            {
                Matrix4x4 m = transform.localToWorldMatrix;
                for (int i = 0; i < apps.Length; i++)
                    apps[i] = m.MultiplyPoint3x4(apps[i]);
            }

            return apps;
        }

        /// <summary>
        /// Gets all Approximation points for a given spline part
        /// </summary>
        /// <param name="fromTF">start TF</param>
        /// <param name="toTF">end TF</param>
        /// <param name="includeEndPoint">Whether the end position should be included</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <returns>an array of Approximation points</returns>
        // DESIGN Make a GetPositionsCache equivalent, then make obsolete and remove/rename getApproximationIndexINTERNAL
        public Vector3[] GetApproximation(float fromTF, float toTF, bool includeEndPoint = true, Space space = Space.Self)
        {
            float startLF;
            float startFrag;
            float endLF;
            float endFrag;
            CurvySplineSegment startSeg = TFToSegment(fromTF, out startLF);
            int startIdx = startSeg.getApproximationIndexINTERNAL(startLF, out startFrag);
            CurvySplineSegment endSeg = TFToSegment(toTF, out endLF);
            int endIdx = endSeg.getApproximationIndexINTERNAL(endLF, out endFrag);

            CurvySplineSegment seg = startSeg;
            //bug usage of startIdx + 1 whithout checking if it is not out of bounds, which may happen if seg's length is 0
            Vector3[] res = new Vector3[1] { Vector3.Lerp(seg.Approximation[startIdx], seg.Approximation[startIdx + 1], startFrag) };
            //if (startFrag == 1)
            //    seg = seg.NextSegment;
            while (seg && ReferenceEquals(seg, endSeg) == false)
            {
                res = res.AddRange(seg.Approximation.SubArray(startIdx + 1, seg.Approximation.Length - 1));
                startIdx = 1;
                seg = seg.Spline.GetNextSegment(seg);
            }
            if (ReferenceEquals(seg, null) == false)
            {
                int i = (startSeg == seg) ? startIdx + 1 : 1;
                res = res.AddRange(seg.Approximation.SubArray(i, endIdx - i));
                if (includeEndPoint && (endFrag > 0 || endFrag < 1))
                {
                    res = res.Add(Vector3.Lerp(seg.Approximation[endIdx], seg.Approximation[endIdx + 1], endFrag));
                }
            }

            if (space == Space.World)
            {
                Matrix4x4 m = transform.localToWorldMatrix;
                for (int i = 0; i < res.Length; i++)
                    res[i] = m.MultiplyPoint3x4(res[i]);
            }

            return res;
        }

        /// <summary>
        /// Gets an array containing all approximation tangents
        /// </summary>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <remarks>Returns a copy of the internal cache</remarks>
        /// <returns>an array of tangents</returns>
        public SubArray<Vector3> GetTangentsCache(Space space)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            SubArray<Vector3> result = ArrayPools.Vector3.Allocate(CacheSize + 1);
            Vector3[] resultArray = result.Array;

            int idx = 0;
            for (int si = 0; si < Count; si++)
            {
                this[si].ApproximationT.CopyTo(resultArray, idx);
                idx += Mathf.Max(0, this[si].ApproximationT.Length - 1);
            }

            if (space == Space.World)
            {
                Matrix4x4 m = transform.localToWorldMatrix;
                for (int i = 0; i < result.Count; i++)
                    resultArray[i] = m.MultiplyVector(resultArray[i]);
            }

            return result;
        }

        /// <summary>
        /// Gets an array containing all approximation tangents
        /// </summary>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <remarks>This can be used to feed meshbuilders etc...</remarks>
        /// <returns>an array of tangents</returns>
        [Obsolete("Use GetTangentsCache instead")]
        public Vector3[] GetApproximationT(Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            Vector3[] apps = new Vector3[CacheSize + 1];
            int idx = 0;
            for (int si = 0; si < Count; si++)
            {
                this[si].ApproximationT.CopyTo(apps, idx);
                idx += Mathf.Max(0, this[si].ApproximationT.Length - 1);
            }

            if (space == Space.World)
            {
                Matrix4x4 m = transform.localToWorldMatrix;
                for (int i = 0; i < apps.Length; i++)
                    apps[i] = m.MultiplyVector(apps[i]);
            }

            return apps;
        }

        /// <summary>
        /// Gets an array containing all approximation Up-Vectors
        /// </summary>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <remarks>Returns a copy of the internal cache</remarks>
        /// <returns>an array of Up-Vectors</returns>
        public SubArray<Vector3> GetNormalsCache(Space space)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            SubArray<Vector3> result = ArrayPools.Vector3.Allocate(CacheSize + 1);
            Vector3[] resultArray = result.Array;

            int idx = 0;
            for (int si = 0; si < Count; si++)
            {
                this[si].ApproximationUp.CopyTo(resultArray, idx);
                idx += Mathf.Max(0, this[si].ApproximationUp.Length - 1);
            }

            if (space == Space.World)
            {
                Matrix4x4 m = transform.localToWorldMatrix;
                for (int i = 0; i < result.Count; i++)
                    resultArray[i] = m.MultiplyVector(resultArray[i]);
            }

            return result;
        }

        /// <summary>
        /// Gets an array containing all approximation Up-Vectors
        /// </summary>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <remarks>This can be used to feed meshbuilders etc...</remarks>
        /// <returns>an array of Up-Vectors</returns>
        [Obsolete("Use GetNormalsCache instead")]
        public Vector3[] GetApproximationUpVectors(Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            Vector3[] apps = new Vector3[CacheSize + 1];
            int idx = 0;
            for (int si = 0; si < Count; si++)
            {
                this[si].ApproximationUp.CopyTo(apps, idx);
                idx += Mathf.Max(0, this[si].ApproximationUp.Length - 1);
            }

            if (space == Space.World)
            {
                Matrix4x4 m = transform.localToWorldMatrix;
                for (int i = 0; i < apps.Length; i++)
                    apps[i] = m.MultiplyVector(apps[i]);
            }

            return apps;
        }

        #endregion

        /// <summary>
        /// Gets the point on the spline that is the nearest to a given <paramref name="position"/>
        /// </summary>
        /// <param name="position">The input point's position</param>
        /// <param name="space">The space (local/object or global/world) in which the <paramref name="position"/> and the returned value are expressed</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>The nearest point on the spline to the given <paramref name="position"/>, expressed in the space defined by the <paramref name="space"/> parameter</returns>
        public Vector3 GetNearestPoint(Vector3 position, Space space)
        {
            Vector3 result;
            GetNearestPointTF(position, out result, out _, out _, 0, -1, space);
            return result;
        }

        /// <summary>
        /// Gets the TF value of the point on the spline that is the nearest to a given position
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="localPosition">The point's position expressed in the spline's local space</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>a TF value in the range 0..1. If spline has no segments the returned value will be -1</returns>
        public float GetNearestPointTF(Vector3 localPosition)
        {
            return GetNearestPointTF(localPosition, out _, out _, out _, 0, -1, Space.Self);
        }

        /// <summary>
        /// Gets the TF value of the point on the spline that is the nearest to a given position
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="position">The point's position</param>
        /// <param name="space">The space (local/object or global/world) in which the <paramref name="position"/> is expressed</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>a TF value in the range 0..1. If spline has no segments the returned value will be -1</returns>
        public float GetNearestPointTF(Vector3 position, Space space)
        {
            return GetNearestPointTF(position, out _, out _, out _, 0, -1, space);
        }

        /// <summary>
        /// Gets the TF value of the point on the spline that is the nearest to a given position
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="localPosition">The point's position expressed in the spline's local space</param>
        /// <param name="nearestPoint">the nearest point on the spline to the given <paramref name="localPosition"/>, expressed in the local space</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>a TF value in the range 0..1. If spline has no segments the returned value will be -1</returns>
        public float GetNearestPointTF(Vector3 localPosition, out Vector3 nearestPoint)
        {
            return GetNearestPointTF(localPosition, out nearestPoint, out _, out _, 0, -1, Space.Self);
        }

        /// <summary>
        /// Gets the TF value of the point on the spline that is the nearest to a given position
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="position">The point's position</param>
        /// <param name="nearestPoint">the nearest point on the spline to the given <paramref name="position"/>, expressed in the space defined by the <paramref name="space"/> parameter</param>
        /// <param name="space">The space (local/object or global/world) in which the <paramref name="position"/> is expressed</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>a TF value in the range 0..1. If spline has no segments the returned value will be -1</returns>
        public float GetNearestPointTF(Vector3 position, out Vector3 nearestPoint, Space space)
        {
            return GetNearestPointTF(position, out nearestPoint, out _, out _, 0, -1, space);
        }

        /// <summary>
        /// Gets the TF value of the point on the spline that is the nearest to a given position
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="position">The point's position</param>
        /// <param name="searchStartSegmentIndex">the index of the first segment to include in the search. Set it to 0 to start searching from the spline's start</param>
        /// <param name="searchEndSegmentIndex">the index of the last segment to include in the search. Set it to -1 to search until the spline's end</param>
        /// <param name="space">The space (local/object or global/world) in which the <paramref name="position"/> is expressed</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>a TF value in the range 0..1. If spline has no segments the returned value will be -1</returns>
        public float GetNearestPointTF(Vector3 position, int searchStartSegmentIndex = 0, int searchEndSegmentIndex = -1, Space space = Space.Self)
        {
            return GetNearestPointTF(position, out _, out _, out _, searchStartSegmentIndex, searchEndSegmentIndex, space);
        }

        /// <summary>
        /// Gets the TF value of the point on the spline that is the nearest to a given position
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="position">The point's position</param>
        /// <param name="nearestPoint">the nearest point on the spline to the given <paramref name="position"/>, expressed in the space defined by the <paramref name="space"/> parameter</param>
        /// <param name="searchStartSegmentIndex">the index of the first segment to include in the search. Set it to 0 to start searching from the spline's start</param>
        /// <param name="searchEndSegmentIndex">the index of the last segment to include in the search. Set it to -1 to search until the spline's end</param>
        /// <param name="space">The space (local/object or global/world) in which the <paramref name="position"/> is expressed</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>a TF value in the range 0..1. If spline has no segments the returned value will be -1</returns>
        public float GetNearestPointTF(Vector3 position, out Vector3 nearestPoint, int searchStartSegmentIndex = 0, int searchEndSegmentIndex = -1, Space space = Space.Self)
        {
            return GetNearestPointTF(position, out nearestPoint, out _, out _, searchStartSegmentIndex, searchEndSegmentIndex, space);
        }

        /// <summary>
        /// Gets the TF value of the point on the spline that is the nearest to a given position
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="position">The point's position</param>
        /// <param name="nearestPoint">the nearest point on the spline to the given <paramref name="position"/>, expressed in the space defined by the <paramref name="space"/> parameter</param>
        /// <param name="nearestSegment">the nearest segment of the spline to the given <paramref name="position"/></param>
        /// <param name="nearestPointLocalF">LocalF of the nearest point on the nearest segment</param>
        /// <param name="searchStartSegmentIndex">the index of the first segment to include in the search. Set it to 0 to start searching from the spline's start</param>
        /// <param name="searchEndSegmentIndex">the index of the last segment to include in the search. Set it to -1 to search until the spline's end</param>
        /// <param name="space">The space (local/object or global/world) in which the <paramref name="position"/> is expressed</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>a TF value in the range 0..1. If spline has no segments the returned value will be -1</returns>
        public float GetNearestPointTF(Vector3 position, out Vector3 nearestPoint, [CanBeNull] out CurvySplineSegment nearestSegment, out float nearestPointLocalF, int searchStartSegmentIndex = 0, int searchEndSegmentIndex = -1, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            nearestPoint = Vector3.zero;
            if (Count == 0)
            {
                nearestSegment = null;
                nearestPointLocalF = -1;
                return -1;
            }
            // for each segment, get the distance to it's approximation points
            float distSqr = float.MaxValue;
            float resF = 0;

            CurvySplineSegment resSeg = null;
            if (searchEndSegmentIndex == -1)
                searchEndSegmentIndex = Count - 1;
            searchStartSegmentIndex = Mathf.Clamp(searchStartSegmentIndex, 0, Count - 1);
            searchEndSegmentIndex = Mathf.Clamp(searchEndSegmentIndex + 1, searchStartSegmentIndex + 1, Count);
            for (int i = searchStartSegmentIndex; i < searchEndSegmentIndex; i++)
            {
                float f = this[i].GetNearestPointF(position, space);
                Vector3 v = this[i].Interpolate(f, space);
                float magSqr = (v - position).sqrMagnitude;
                if (magSqr <= distSqr)
                {
                    resSeg = this[i];
                    resF = f;
                    nearestPoint = v;
                    distSqr = magSqr;
                }
            }

            nearestSegment = resSeg;
            nearestPointLocalF = resF;
            // return the nearest
            return resSeg.LocalFToTF(resF);
        }

        /// <summary>
        /// Refreshs the spline
        /// </summary>
        /// <remarks>This is called automatically on the next Update() if any changes are pending</remarks>
        public void Refresh()
        {
            if (ProcessDirtyControlPoints())
                OnRefreshEvent(defaultSplineEventArgs);
        }

        /// <summary>
        /// Ensures the whole spline (curve & orientation) will be recalculated on next call to Refresh()
        /// </summary>
        public void SetDirtyAll()
        {
            SetDirtyAll(SplineDirtyingType.Everything, true);
        }

        /// <summary>
        /// Ensure the whole spline will be recalculated on next call to Refresh()
        /// </summary>
        /// <param name="dirtyingType">Defines what aspect should be dirtied</param>
        /// <param name="dirtyConnectedControlPoints">whether to set dirty other splines's control points connected to one of this spline's control points</param>
        public void SetDirtyAll(SplineDirtyingType dirtyingType, bool dirtyConnectedControlPoints)
        {
#if CURVY_LOG_DIRTYING
            Debug.Log("Set Dirty all " + dirtyingType);
#endif
            allControlPointsAreDirty = true;
            SetDirtyingFlags(dirtyingType);

            if (dirtyConnectedControlPoints)
                //OPTIM: maintain a boolean saying if any control point has a connection. And then, avoid the following code if that boolean is false. Same suggestion for other dirtying codes related to connections
                for (int index = 0; index < ControlPoints.Count; index++)
                {
                    CurvySplineSegment controlPoint = ControlPoints[index];
                    if (controlPoint && controlPoint.Connection)//controlPoint can be null if you create a spline via the pen tool, and then undo it
                    {
                        ReadOnlyCollection<CurvySplineSegment> connectedControlPoints = controlPoint.Connection.ControlPointsList;
                        for (int connectedIndex = 0; connectedIndex < connectedControlPoints.Count; connectedIndex++)
                        {
                            CurvySplineSegment connectedControlPoint = connectedControlPoints[connectedIndex];
                            CurvySpline connectedSpline = connectedControlPoint != null
                                ? connectedControlPoint.Spline
                                : null;
                            if (connectedSpline && connectedSpline != this)
                            {
                                connectedSpline.dirtyControlPointsMinimalSet.Add(connectedControlPoint);
                                connectedSpline.SetDirtyingFlags(dirtyingType);
                            }
                        }
                    }
                }
        }

        /// <summary>
        /// Marks a Control Point to get recalculated on next call to Refresh(). Will also mark connected control points and control points that depend on the current one through the Follow-Up feature.
        /// </summary>
        /// <param name="dirtyControlPoint">the Control Point to dirty</param>
        /// <param name="dirtyingType">Defines what aspect should be dirtied</param>
        public void SetDirty(CurvySplineSegment dirtyControlPoint, SplineDirtyingType dirtyingType)
        {
            SetDirty(dirtyControlPoint, dirtyingType, GetPreviousControlPoint(dirtyControlPoint), GetNextControlPoint(dirtyControlPoint), false);
        }

        /// <summary>
        /// Marks a Control Point to get recalculated on next call to Refresh(). Will also mark connected control points and control points that depend on the current one through the Follow-Up feature. Be aware, this method, and unlike SetDirty, will not mark as dirty the control points connected to the "controlPoint" parameter
        /// </summary>
        /// <param name="dirtyControlPoint">the Control Point to dirty</param>
        /// <param name="dirtyingType">Defines what aspect should be dirtied</param>
        public void SetDirtyPartial(CurvySplineSegment dirtyControlPoint, SplineDirtyingType dirtyingType)
        {
            //OPTIM skip this if dirtyControlPoint is already dirty?
            SetDirty(dirtyControlPoint, dirtyingType, GetPreviousControlPoint(dirtyControlPoint), GetNextControlPoint(dirtyControlPoint), true);
        }

        /// <summary>
        /// Transforms position from local space to world space
        /// </summary>
        public Vector3 ToWorldPosition(Vector3 localPosition)
        {
            return cachedTransform.TransformPoint(localPosition);
        }

        /// <summary>
        /// Transforms direction from local space to world space
        /// </summary>
        public Vector3 ToWorldDirection(Vector3 localDirection)
        {
            return cachedTransform.TransformDirection(localDirection);
        }

        /// <summary>
        /// Transforms position from world space to local space
        /// </summary>
        public Vector3 ToLocalPosition(Vector3 worldPosition)
        {
            return cachedTransform.InverseTransformPoint(worldPosition);
        }

        /// <summary>
        /// Transforms direction from world space to local space
        /// </summary>
        public Vector3 ToLocalDirection(Vector3 localDirection)
        {
            return cachedTransform.InverseTransformDirection(localDirection);
        }

#if UNITY_EDITOR

        /// <summary>
        /// Apply proper names to all Control Points
        /// </summary>
        public void ApplyControlPointsNames()
        {
            // rename them and set their order based on ControlPoint list
            for (short i = 0; i < ControlPoints.Count; i++)
                ControlPoints[i].name = GetControlPointName(i);
        }

#endif

        /// <summary>
        /// Rebuilds the ControlPoints list from the hierarchy. It sets the spline as Dirty
        /// </summary>
        public void SyncSplineFromHierarchy()
        {
            ClearControlPoints();
            for (int i = 0; i < transform.childCount; i++)
            {
                CurvySplineSegment cp = transform.GetChild(i).GetComponent<CurvySplineSegment>();
                if (cp)
                    AddControlPoint(cp);
            }
        }

        #endregion

        #region --- Utilities ---

        /// <summary>
        /// Checks if the curve is planar
        /// </summary>
        /// <param name="ignoreAxis">returns the axis that can be ignored (0=x,1=y,2=z)</param>
        /// <returns>true if a planar axis was found</returns>
        public bool IsPlanar(out int ignoreAxis)
        {
            bool xp, yp;
            bool res = IsPlanar(out xp, out yp, out _);
            if (xp)
                ignoreAxis = 0;
            else if (yp)
                ignoreAxis = 1;
            else
                ignoreAxis = 2;
            return res;
        }

        /// <summary>
        /// Checks if the curve is planar
        /// </summary>
        /// <param name="xplanar">whether the x-axis is planar</param>
        /// <param name="yplanar">whether the y-axis is planar</param>
        /// <param name="zplanar">whether the z-axis is planar</param>
        /// <returns>true if at least on axis is planar</returns>
        public bool IsPlanar(out bool xplanar, out bool yplanar, out bool zplanar)
        {
            xplanar = true;
            yplanar = true;
            zplanar = true;
            if (ControlPointCount == 0) return true;
            Vector3 p = ControlPoints[0].transform.localPosition;
            for (int i = 1; i < ControlPointCount; i++)
            {
                if (!Mathf.Approximately(ControlPoints[i].transform.localPosition.x, p.x))
                    xplanar = false;
                if (!Mathf.Approximately(ControlPoints[i].transform.localPosition.y, p.y))
                    yplanar = false;
                if (!Mathf.Approximately(ControlPoints[i].transform.localPosition.z, p.z))
                    zplanar = false;

                if (xplanar == false && yplanar == false && zplanar == false)
                    return false;

            }
            return true;
        }

        /// <summary>
        /// Determines if the spline is at zero position on a certain plane
        /// </summary>
        /// <param name="plane">the plane the spline should be tested against</param>
        /// <returns>true if the spline is on the plane</returns>
        public bool IsPlanar(CurvyPlane plane)
        {
            switch (plane)
            {
                case CurvyPlane.XY:
                    for (int i = 0; i < ControlPointCount; i++)
                        if (ControlPoints[i].transform.localPosition.z.Approximately(0f) == false)
                            return false;
                    break;
                case CurvyPlane.XZ:
                    for (int i = 0; i < ControlPointCount; i++)
                        if (ControlPoints[i].transform.localPosition.y.Approximately(0f) == false)
                            return false;
                    break;
                case CurvyPlane.YZ:
                    for (int i = 0; i < ControlPointCount; i++)
                        if (ControlPoints[i].transform.localPosition.x.Approximately(0f) == false)
                            return false;
                    break;
            }
            return true;
        }

        /// <summary>
        /// Forces the spline to be at zero position on a certain plane
        /// </summary>
        /// <param name="plane">the plane the should be on</param>
        public void MakePlanar(CurvyPlane plane)
        {
            switch (plane)
            {
                case CurvyPlane.XY:
                    for (int i = 0; i < ControlPointCount; i++)
                        if (ControlPoints[i].transform.localPosition.z != 0)
                        {
#if UNITY_EDITOR
                            if (!Application.isPlaying)
                                Undo.RecordObject(ControlPoints[i].transform, "MakePlanar");
#endif
                            ControlPoints[i].SetLocalPosition(new Vector3(ControlPoints[i].transform.localPosition.x, ControlPoints[i].transform.localPosition.y, 0));
                        }
                    break;
                case CurvyPlane.XZ:
                    for (int i = 0; i < ControlPointCount; i++)
                        if (ControlPoints[i].transform.localPosition.y != 0)
                        {
#if UNITY_EDITOR
                            if (!Application.isPlaying)
                                Undo.RecordObject(ControlPoints[i].transform, "MakePlanar");
#endif
                            ControlPoints[i].SetLocalPosition(new Vector3(ControlPoints[i].transform.localPosition.x, 0, ControlPoints[i].transform.localPosition.z));
                        }
                    break;
                case CurvyPlane.YZ:
                    for (int i = 0; i < ControlPointCount; i++)
                        if (ControlPoints[i].transform.localPosition.x != 0)
                        {
#if UNITY_EDITOR
                            if (!Application.isPlaying)
                                Undo.RecordObject(ControlPoints[i].transform, "MakePlanar");
#endif
                            ControlPoints[i].SetLocalPosition(new Vector3(0, ControlPoints[i].transform.localPosition.y, ControlPoints[i].transform.localPosition.z));
                        }
                    break;
                default:
                    throw new NotImplementedException();
            }
            Refresh();
        }

        /// <summary>
        /// Equalize one axis of the spline to match the first control points's value
        /// </summary>
        /// <param name="axis">the axis to equalize (0=x,1=y,2=z)</param>
        public void MakePlanar(int axis)
        {
            Vector3 p = ControlPoints[0].transform.localPosition;
            for (int i = 1; i < ControlPointCount; i++)
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    Undo.RecordObject(ControlPoints[i].transform, "MakePlanar");
#endif
                Vector3 pi = ControlPoints[i].transform.localPosition;
                switch (axis)
                {
                    case 0: pi.x = p.x; break;
                    case 1: pi.y = p.y; break;
                    case 2: pi.z = p.z; break;
                }
                ControlPoints[i].transform.localPosition = pi;
            }
            SetDirtyAll(SplineDirtyingType.Everything, true);
            Refresh();
        }


        /// <summary>
        /// Subdivides the spline, i.e. adds additional segments to a certain range
        /// </summary>
        /// <param name="fromCP">starting ControlPoint</param>
        /// <param name="toCP">ending ControlPoint</param>
        public void Subdivide(CurvySplineSegment fromCP = null, CurvySplineSegment toCP = null)
        {
            if (!fromCP)
                fromCP = FirstVisibleControlPoint;
            if (!toCP)
                toCP = LastVisibleControlPoint;

            if (fromCP == null || toCP == null || fromCP.Spline != this || toCP.Spline != this)
            {
                Debug.Log("CurvySpline.Subdivide: Not a valid range selection!");
                return;
            }

            int startCPIndex = Mathf.Clamp(fromCP.Spline.GetControlPointIndex(fromCP), 0, ControlPointCount - 2);
            int endCPIndex = Mathf.Clamp(toCP.Spline.GetControlPointIndex(toCP), startCPIndex + 1, ControlPointCount - 1);

            if (endCPIndex - startCPIndex < 1)
            {
                Debug.Log("CurvySpline.Subdivide: Not a valid range selection!");
            }
            else
            {
                OnBeforeControlPointAddEvent(defaultAddAfterEventArgs);

                Dictionary<int, Vector3> newCPsPosition = new Dictionary<int, Vector3>();
                //We first iterate to compute the positions. Interpolate should be called on non Dirty splines, that's why I first call Interpolate then in a latter loop update the spline (which will dirty it)
                for (int i = endCPIndex - 1; i >= startCPIndex; i--)
                    newCPsPosition[i] = ControlPoints[i].Interpolate(0.5f, Space.Self);

                for (int i = endCPIndex - 1; i >= startCPIndex; i--)
                {
                    CurvySplineSegment previousControlPoint = ControlPoints[i];
                    CurvySplineSegment nextControlPoint = ControlPoints[i + 1];
                    CurvySplineSegment newControlPoint =
                        InsertAfter(
                        ControlPoints[i],
                        newCPsPosition[i],
                        true,
                        Space.Self);

                    if (Interpolation == CurvyInterpolation.Bezier)
                    {
#if UNITY_EDITOR
                        if (!Application.isPlaying)
                        {
                            Undo.RecordObject(nextControlPoint, "Subdivide");
                            Undo.RecordObject(previousControlPoint, "Subdivide");
                        }
#endif

                        //Update Bzier handles to maintain the spline's shape
                        //Based on De Casteljau's algorithm. The following is it's special case implementation for a subdivision at the middle of a spline segment.
                        //Here is a picture explaining things: https://jeremykun.files.wordpress.com/2013/05/subdivision.png from https://jeremykun.com/2013/05/11/bezier-curves-and-picasso/

                        Vector3 P0 = previousControlPoint.transform.position;
                        Vector3 P1 = previousControlPoint.HandleOutPosition;
                        Vector3 P2 = nextControlPoint.HandleInPosition;
                        Vector3 P3 = nextControlPoint.transform.position;

                        Vector3 m0 = (P0 + P1) / 2;
                        Vector3 m1 = (P1 + P2) / 2;
                        Vector3 m2 = (P2 + P3) / 2;

                        Vector3 q0 = (m0 + m1) / 2;
                        Vector3 q1 = (m1 + m2) / 2;

                        previousControlPoint.AutoHandles = false;
                        previousControlPoint.HandleOutPosition = m0;

                        nextControlPoint.AutoHandles = false;
                        nextControlPoint.HandleInPosition = m2;

                        newControlPoint.AutoHandles = false;
                        newControlPoint.HandleInPosition = q0;
                        newControlPoint.HandleOutPosition = q1;
                    }
#if UNITY_EDITOR
                    if (!Application.isPlaying)
                        Undo.RegisterCreatedObjectUndo(newControlPoint.gameObject, "Subdivide");
#endif
                }

                Refresh();
                OnAfterControlPointAddEvent(defaultAddAfterEventArgs);
                OnAfterControlPointChangesEvent(defaultSplineEventArgs);
            }
        }

        /// <summary>
        /// Simplifies the spline, i.e. remove segments from a certain range
        /// </summary>
        /// <param name="fromCP">starting ControlPoint</param>
        /// <param name="toCP">ending ControlPoint</param>
        public void Simplify(CurvySplineSegment fromCP = null, CurvySplineSegment toCP = null)
        {
            if (!fromCP)
                fromCP = FirstVisibleControlPoint;
            if (!toCP)
                toCP = LastVisibleControlPoint;

            if (fromCP == null || toCP == null || fromCP.Spline != this || toCP.Spline != this)
            {
                Debug.Log("CurvySpline.Simplify: Not a valid range selection!");
                return;
            }
            int startCPIndex = Mathf.Clamp(fromCP.Spline.GetControlPointIndex(fromCP), 0, ControlPointCount - 2);
            int endCPIndex = Mathf.Clamp(toCP.Spline.GetControlPointIndex(toCP), startCPIndex + 2, ControlPointCount - 1);
            if (endCPIndex - startCPIndex < 2)
            {
                Debug.Log("CurvySpline.Simplify: Not a valid range selection!");
            }
            else
            {
                OnBeforeControlPointDeleteEvent(defaultDeleteEventArgs);

                for (int i = endCPIndex - 2; i >= startCPIndex; i -= 2)
                {
                    Delete(ControlPoints[i + 1], true);
#if UNITY_EDITOR
                    _newSelectionInstanceIDINTERNAL = 0;
#endif
                }
                Refresh();
                OnAfterControlPointChangesEvent(defaultSplineEventArgs);
            }
        }

        /// <summary>
        /// Equalizes the segment length of a certain range
        /// </summary>
        /// <param name="fromCP">starting ControlPoint</param>
        /// <param name="toCP">ending ControlPoint</param>
        public void Equalize(CurvySplineSegment fromCP = null, CurvySplineSegment toCP = null)
        {
            if (!fromCP)
                fromCP = FirstVisibleControlPoint;
            if (!toCP)
                toCP = LastVisibleControlPoint;

            if (fromCP == null || toCP == null || fromCP.Spline != this || toCP.Spline != this)
            {
                Debug.Log("CurvySpline.Equalize: Not a valid range selection!");
                return;
            }
            int startCPIndex = Mathf.Clamp(GetControlPointIndex(fromCP), 0, ControlPointCount - 2);
            int endCPIndex = Mathf.Clamp(GetControlPointIndex(toCP), startCPIndex + 2, ControlPointCount - 1);
            if (endCPIndex - startCPIndex < 2)
            {
                Debug.Log("CurvySpline.Equalize: Not a valid range selection!");
                return;
            }
            float segmentLength = ControlPoints[endCPIndex].Distance - ControlPoints[startCPIndex].Distance;
            float equal = segmentLength / (endCPIndex - startCPIndex);
            float dist = ControlPoints[startCPIndex].Distance;

            Vector3[] newCpPositions = new Vector3[endCPIndex - startCPIndex - 1];

            for (int i = startCPIndex + 1; i < endCPIndex; i++)
            {
                int iterationIndex = i - startCPIndex - 1;
                newCpPositions[iterationIndex] = InterpolateByDistance(dist + (iterationIndex + 1) * equal);
            }

            for (int i = startCPIndex + 1; i < endCPIndex; i++)
            {
                int iterationIndex = i - startCPIndex - 1;
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    Undo.RecordObject(ControlPoints[i].transform, "Equalize");
#endif
                ControlPoints[i].SetLocalPosition(newCpPositions[iterationIndex]);
            }
            Refresh();
        }

        /// <summary>
        /// Applies a spline's scale to it's Control Points and resets scale
        /// </summary>
        public void Normalize()
        {
            Vector3 scl = transform.localScale;

            if (scl != Vector3.one)
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    Undo.RecordObject(transform, "Normalize Spline");
#endif
                transform.localScale = Vector3.one;
                for (int i = 0; i < ControlPointCount; i++)
                {
                    CurvySplineSegment curvySplineSegment = ControlPoints[i];
#if UNITY_EDITOR
                    if (!Application.isPlaying)
                    {
                        Undo.RecordObject(curvySplineSegment.transform, "Normalize Spline");
                        Undo.RecordObject(curvySplineSegment, "Normalize Spline");
                    }
#endif
                    curvySplineSegment.SetLocalPosition(Vector3.Scale(curvySplineSegment.transform.localPosition, scl));
                    curvySplineSegment.HandleIn = Vector3.Scale(curvySplineSegment.HandleIn, scl);
                    curvySplineSegment.HandleOut = Vector3.Scale(curvySplineSegment.HandleOut, scl);

                }
                Refresh();
            }
        }

        /// <summary>
        /// Sets the pivot of the spline
        /// </summary>
        /// <param name="xRel">-1 to 1</param>
        /// <param name="yRel">-1 to 1</param>
        /// <param name="zRel">-1 to 1</param>
        /// <param name="preview">if true, only return the new pivot position</param>
        /// <returns>the new pivot position</returns>
        public Vector3 SetPivot(float xRel = 0, float yRel = 0, float zRel = 0, bool preview = false)
        {
            Bounds b = Bounds;
            Vector3 v = new Vector3(b.min.x + b.size.x * ((xRel + 1) / 2),
                                    b.max.y - b.size.y * ((yRel + 1) / 2),
                                    b.min.z + b.size.z * ((zRel + 1) / 2));

            Vector3 off = transform.position - v;
            if (preview)
                return transform.position - off;

            for (int index = 0; index < ControlPoints.Count; index++)
            {
                CurvySplineSegment cp = ControlPoints[index];
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    Undo.RecordObject(cp.transform, "SetPivot");
#endif
                cp.transform.position += off;
            }
#if UNITY_EDITOR
            if (!Application.isPlaying)
                Undo.RecordObject(transform, "SetPivot");
#endif
            transform.position -= off;
            SetDirtyAll(SplineDirtyingType.Everything, true);
            return transform.position;
        }

        /// <summary>
        /// Flips the direction of the spline, i.e. the first Control Point will become the last and vice versa.
        /// </summary>
        public void Flip()
        {
            if (ControlPointCount <= 1)
                return;
#if UNITY_EDITOR
            if (!Application.isPlaying)
                Undo.RegisterFullObjectHierarchyUndo(this, "Flip Spline");
#endif
            switch (Interpolation)
            {
                case CurvyInterpolation.TCB:
                    Bias *= -1;
                    for (int i = ControlPointCount - 1; i >= 0; i--)
                    {
                        CurvySplineSegment cur = ControlPoints[i];

                        int j = i - 1;
                        if (j >= 0)
                        {
                            CurvySplineSegment prev = ControlPoints[j];

                            cur.EndBias = prev.StartBias * -1;
                            cur.EndContinuity = prev.StartContinuity;
                            cur.EndTension = prev.StartTension;

                            cur.StartBias = prev.EndBias * -1;
                            cur.StartContinuity = prev.EndContinuity;
                            cur.StartTension = prev.EndTension;

                            cur.OverrideGlobalBias = prev.OverrideGlobalBias;
                            cur.OverrideGlobalContinuity = prev.OverrideGlobalContinuity;
                            cur.OverrideGlobalTension = prev.OverrideGlobalTension;

                            cur.SynchronizeTCB = prev.SynchronizeTCB;
                        }
                    }
                    break;
                case CurvyInterpolation.Bezier:
                    for (int i = ControlPointCount - 1; i >= 0; i--)
                    {
                        CurvySplineSegment cur = ControlPoints[i];

                        (cur.HandleIn, cur.HandleOut) = (cur.HandleOut, cur.HandleIn);
                    }
                    break;
            }
            ReverseControlPoints();
            Refresh();
        }

        /// <summary>
        /// Moves ControlPoints from this spline, inserting them after a destination ControlPoint of another spline
        /// </summary>
        /// <param name="startIndex">ControlPointIndex of the first CP to move</param>
        /// <param name="count">number of ControlPoints to move</param>
        /// <param name="destCP">ControlPoint at the destination spline to insert after</param>
        public void MoveControlPoints(int startIndex, int count, CurvySplineSegment destCP)
        {
            if (!destCP || this == destCP.Spline || destCP.Spline.GetControlPointIndex(destCP) == -1)
                return;
            startIndex = Mathf.Clamp(startIndex, 0, ControlPointCount - 1);
            count = Mathf.Clamp(count, startIndex, ControlPointCount - startIndex);

            CurvySplineSegment cp;
            for (int i = 0; i < count; i++)
            {
                cp = ControlPoints[startIndex];
                RemoveControlPoint(cp);
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    Undo.SetTransformParent(cp.transform, destCP.Spline.transform, "Move ControlPoints");
                else
#endif
                    cp.transform.SetParent(destCP.Spline.transform, true);

                destCP.Spline.InsertControlPoint(destCP.Spline.GetControlPointIndex(destCP) + i + 1, cp);
            }
            Refresh();
            destCP.Spline.Refresh();
        }

        /// <summary>
        /// Insert this spline after another spline's destination Control Point and delete this spline
        /// </summary>
        /// <param name="destCP">the Control Point of the destination spline</param>
        public void JoinWith(CurvySplineSegment destCP)
        {
            if (destCP.Spline == this)
                return;
            MoveControlPoints(0, ControlPointCount, destCP);
            gameObject.Destroy(true, true);
        }

        /// <summary>
        /// Splits this spline with the parameter controlPoint becoming the first Control Point of the new spline
        /// </summary>
        /// <returns>The new spline</returns>
        public CurvySpline Split(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            CurvySpline newSpline = CurvySpline.Create(this);
            newSpline.transform.SetParent(transform.parent, true);
            newSpline.name = name + "_parted";

#if UNITY_EDITOR
            if (!Application.isPlaying)
                Undo.RegisterCreatedObjectUndo(newSpline.gameObject, "Split Spline");
#endif

            // Move CPs
            List<CurvySplineSegment> affectedControlPoints;
            {
                int controlPointIndex = GetSegmentIndex(controlPoint);
                affectedControlPoints = new List<CurvySplineSegment>(ControlPointCount - controlPointIndex);
                for (int i = controlPointIndex; i < ControlPointCount; i++)
                    affectedControlPoints.Add(ControlPoints[i]);
            }

            for (int i = 0; i < affectedControlPoints.Count; i++)
            {
                CurvySplineSegment curvySplineSegment = affectedControlPoints[i];
                RemoveControlPoint(curvySplineSegment);
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    Undo.SetTransformParent(curvySplineSegment.transform, newSpline.transform, "Split Spline");
#endif
                if (Application.isPlaying)
                    curvySplineSegment.transform.SetParent(newSpline.transform, true);
                newSpline.AddControlPoint(curvySplineSegment);
            }

            Refresh();
            newSpline.Refresh();
            return newSpline;
        }

        /// <summary>
        /// Defines the given Control Point to be the first Control Point of the spline
        /// </summary>
        /// <param name="controlPoint">One of this spline's control points</param>
        public void SetFirstControlPoint(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            short controlPointIndex = GetControlPointIndex(controlPoint);
            CurvySplineSegment[] controlPointsToMove = new CurvySplineSegment[controlPointIndex];
            for (int i = 0; i < controlPointIndex; i++)
                controlPointsToMove[i] = ControlPoints[i];

            for (int index = 0; index < controlPointsToMove.Length; index++)
            {
                CurvySplineSegment seg = controlPointsToMove[index];
                RemoveControlPoint(seg);
                AddControlPoint(seg);
            }
            Refresh();
        }

        #endregion

        #region Query data about control points

        /// <summary>
        /// Is the control point an orientation anchor? The answer is related to the control point's serialized OrientationAnchor value, plus it's position in the spline.
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        public bool IsControlPointAnOrientationAnchor(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            return IsControlPointVisible(controlPoint) && (controlPoint.SerializedOrientationAnchor || (controlPoint == FirstVisibleControlPoint || controlPoint == LastVisibleControlPoint));
        }

        /// <summary>
        /// Can this control point have a Follow-Up? This is true if the control point is the beginning of the first segment or the end of the last segment of an open spline
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        public bool CanControlPointHaveFollowUp(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            return controlPoint.GetExtrinsicPropertiesINTERNAL().CanHaveFollowUp;
        }

        /// <summary>
        /// Index of the control point
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        public short GetControlPointIndex(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            short controlPointIndex = controlPoint.GetExtrinsicPropertiesINTERNAL().ControlPointIndex;
#if CURVY_SANITY_CHECKS_PRIVATE//Judged too expensive in cpu time to be part of the sanity checks available to users
            UnityEngine.Assertions.Assert.IsTrue(controlPoint == ControlPoints[controlPointIndex]);
#endif

            return controlPointIndex;
        }

        /// <summary>
        /// Index of the segment that this control point starts. -1 if control point does not start a segment.
        /// </summary>
        /// <param name="segment"></param>
        /// <returns></returns>
        public short GetSegmentIndex(CurvySplineSegment segment)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, segment.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, segment, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            short segementIndex = segment.GetExtrinsicPropertiesINTERNAL().SegmentIndex;
#if CURVY_SANITY_CHECKS_PRIVATE//Judged too expensive in cpu time to be part of the sanity checks available to users
            UnityEngine.Assertions.Assert.IsTrue(segementIndex == -1 || segment == mSegments[segementIndex]);
#endif
            return segementIndex;
        }

        /// <summary>
        /// The next control point on the spline. Is null if none. Follow-Up not considered
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        [CanBeNull]
        public CurvySplineSegment GetNextControlPoint(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            short nextControlPointIndex = controlPoint.GetExtrinsicPropertiesINTERNAL().NextControlPointIndex;
            return nextControlPointIndex == -1 ? null : ControlPoints[nextControlPointIndex];
        }

        /// <summary>
        /// The index of the next control point on the spline. Is -1 if none. Follow-Up not considered
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        [CanBeNull]
        public short GetNextControlPointIndex(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            return controlPoint.GetExtrinsicPropertiesINTERNAL().NextControlPointIndex;
        }

        /// <summary>
        /// The next control point. Is null if none. Follow-Up is considered
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        [CanBeNull]
        public CurvySplineSegment GetNextControlPointUsingFollowUp(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            return controlPoint.FollowUp != null && ReferenceEquals(LastVisibleControlPoint, controlPoint)
                ? GetFollowUpHeadingControlPoint(controlPoint.FollowUp, controlPoint.FollowUpHeading)
                : GetNextControlPoint(controlPoint);
        }

        /// <summary>
        /// The previous control point on the spline. Is null if none. Follow-Up not considered
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        [CanBeNull]
        public CurvySplineSegment GetPreviousControlPoint(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            short previousControlPointIndex = controlPoint.GetExtrinsicPropertiesINTERNAL().PreviousControlPointIndex;
            return previousControlPointIndex == -1 ? null : ControlPoints[previousControlPointIndex];
        }

        /// <summary>
        /// The index of the previous control point on the spline. Is -1 if none. Follow-Up not considered
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        [CanBeNull]
        public short GetPreviousControlPointIndex(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            return controlPoint.GetExtrinsicPropertiesINTERNAL().PreviousControlPointIndex;
        }

        /// <summary>
        /// The previous control point. Is null if none. Follow-Up is considered
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        [CanBeNull]
        public CurvySplineSegment GetPreviousControlPointUsingFollowUp(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            return controlPoint.FollowUp != null && ReferenceEquals(FirstVisibleControlPoint, controlPoint)
                ? GetFollowUpHeadingControlPoint(controlPoint.FollowUp, controlPoint.FollowUpHeading)
                : GetPreviousControlPoint(controlPoint);
        }

        /// <summary>
        /// The next control point on the spline if it starts a segment. Is null if none. Follow-Up not considered
        /// </summary>
        /// <param name="segment"></param>
        /// <returns></returns>
        [CanBeNull]
        public CurvySplineSegment GetNextSegment(CurvySplineSegment segment)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, segment.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, segment, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);

            CurvySplineSegment.ControlPointExtrinsicProperties cpExtrinsicProperties = segment.GetExtrinsicPropertiesINTERNAL();
            return cpExtrinsicProperties.NextControlPointIsSegment
                ? ControlPoints[cpExtrinsicProperties.NextControlPointIndex]
                : null;
        }

        /// <summary>
        /// The previous control point on the spline if it starts a segment. Is null if none. Follow-Up not considered. 
        /// </summary>
        /// <param name="segment"></param>
        /// <returns></returns>
        [CanBeNull]
        public CurvySplineSegment GetPreviousSegment(CurvySplineSegment segment)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, segment.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, segment, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            CurvySplineSegment.ControlPointExtrinsicProperties cpExtrinsicProperties = segment.GetExtrinsicPropertiesINTERNAL();
            return cpExtrinsicProperties.PreviousControlPointIsSegment
                ? ControlPoints[cpExtrinsicProperties.PreviousControlPointIndex]
                : null;
        }

        /// <summary>
        /// Is the control point the start of a segment?
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        public bool IsControlPointASegment(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            return controlPoint.GetExtrinsicPropertiesINTERNAL().IsSegment;
        }

        /// <summary>
        /// Is the control point part of a segment (whether starting it or ending it)
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        public bool IsControlPointVisible(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            return controlPoint.GetExtrinsicPropertiesINTERNAL().IsVisible;
        }

        /// <summary>
        /// The index of the control point being the orientation anchor for the anchor group containing the controlPoint
        /// Is -1 for non visible control points
        /// </summary>
        public short GetControlPointOrientationAnchorIndex(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            return controlPoint.GetExtrinsicPropertiesINTERNAL().OrientationAnchorIndex;
        }
        #endregion

        /// <summary>
        /// Event-friendly helper that sets a field or property value
        /// </summary>
        /// <param name="fieldAndValue">e.g. "MyValue=42"</param>
        public void SetFromString(string fieldAndValue)
        {
            string[] f = fieldAndValue.Split('=');
            if (f.Length != 2)
                return;

            FieldInfo fi = this.GetType().FieldByName(f[0], true, false);
            if (fi != null)
            {
                try
                {
                    if (fi.FieldType.IsEnum)
                        fi.SetValue(this, System.Enum.Parse(fi.FieldType, f[1]));
                    else
                        fi.SetValue(this, System.Convert.ChangeType(f[1], fi.FieldType, System.Globalization.CultureInfo.InvariantCulture));
                }
                catch (System.Exception e)
                {
                    Debug.LogWarning(this.name + ".SetFromString(): " + e.ToString());
                }
            }
            else
            {
                PropertyInfo pi = this.GetType().PropertyByName(f[0], true, false);
                if (pi != null)
                {
                    try
                    {
                        if (pi.PropertyType.IsEnum)
                            pi.SetValue(this, System.Enum.Parse(pi.PropertyType, f[1]), null);
                        else
                            pi.SetValue(this, System.Convert.ChangeType(f[1], pi.PropertyType, System.Globalization.CultureInfo.InvariantCulture), null);
                    }
                    catch (System.Exception e)
                    {
                        Debug.LogWarning(this.name + ".SetFromString(): " + e.ToString());
                    }
                }
            }
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySpline.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineDefaultValues.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 99611b5d3dd7bc74c9a0f49dbedd1e78
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Here you can find all the default values for CurvySpline's serialized fields. If you don't find a field here, this means that it's type's default value is the same than the field's default value, except for <see cref="CurvySpline.Interpolation"/> which default value is user defined, see <see cref="CurvyGlobalManager.DefaultInterpolation"/>
    /// </summary>
    public static class CurvySplineDefaultValues
    {
        public const bool AutoEndTangents = true;
        public const CurvyOrientation Orientation = CurvyOrientation.Dynamic;
        public const float AutoHandleDistance = 0.39f;
        public const int CacheDensity = 50;
        public const float MaxPointsPerUnit = 8;
        public const bool UsePooling = true;
        public const CurvyUpdateMethod UpdateIn = CurvyUpdateMethod.Update;
        public const bool CheckTransform = true;
        public const int BSplineDegree = 2;
        public const bool IsBSplineClamped = true;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineDefaultValues.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment.ControlPointExtrinsicProperties.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 776cd6a1dc4e38e4f843a10b00a09c5b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;

namespace FluffyUnderware.Curvy
{
    public partial class CurvySplineSegment
    {
        /// <summary>
        /// Contains data about a control point related to it's parent spline. For example, is a control point a valid segment in the spline or not.
        /// </summary>
        internal readonly struct ControlPointExtrinsicProperties : IEquatable<ControlPointExtrinsicProperties>
        {
            private readonly bool isVisible;
            /// <summary>
            /// Is the control point part of a segment (whether starting it or ending it)
            /// </summary>
            internal bool IsVisible
            {
                get { return isVisible; }
            }

            private readonly float tf;
            /// <summary>
            /// Gets the TF of this Control Point
            /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.
            /// This is the "time" parameter used in the splines' formulas.
            /// A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
            /// </summary>
            internal float TF
            {
                get { return tf; }
            }

            private readonly short segmentIndex;
            /// <summary>
            /// Index of the segment that this control point starts. -1 if control point does not start a segment.
            /// </summary>
            internal short SegmentIndex
            {
                get { return segmentIndex; }
            }

            private readonly short controlPointIndex;
            /// <summary>
            /// Index of the control point
            /// </summary>
            internal short ControlPointIndex
            {
                get { return controlPointIndex; }
            }

            private readonly short nextControlPointIndex;
            /// <summary>
            /// The index of the next control point on the spline. Is -1 if none. Follow-Up not considered
            /// </summary>
            internal short NextControlPointIndex
            {
                get { return nextControlPointIndex; }
            }

            private readonly short previousControlPointIndex;
            /// <summary>
            /// The index of the previous control point on the spline. Is -1 if none. Follow-Up not considered. 
            /// </summary>
            internal short PreviousControlPointIndex
            {
                get { return previousControlPointIndex; }
            }

            private readonly bool previousControlPointIsSegment;
            /// <summary>
            /// Is previous Control Point a segment start?
            /// </summary>
            internal bool PreviousControlPointIsSegment
            {
                get { return previousControlPointIsSegment; }
            }

            private readonly bool nextControlPointIsSegment;
            /// <summary>
            /// Is next Control Point a segment start?
            /// </summary>
            internal bool NextControlPointIsSegment
            {
                get { return nextControlPointIsSegment; }
            }

            private readonly bool canHaveFollowUp;
            /// <summary>
            /// Can this control point have a Follow-Up? This is true if the control point is visible and does not have a previous or next control point on its spline
            /// </summary>
            internal bool CanHaveFollowUp
            {
                get { return canHaveFollowUp; }
            }

            /// <summary>
            /// Is the control point the start of a segment?
            /// </summary>
            internal bool IsSegment { get { return SegmentIndex != -1; } }

            private readonly short orientationAnchorIndex;
            /// <summary>
            /// The index of the control point being the orientation anchor for the anchor group containing the current control point
            /// Is -1 for non visible control points
            /// </summary>
            internal short OrientationAnchorIndex
            {
                get { return orientationAnchorIndex; }
            }

            internal ControlPointExtrinsicProperties(bool isVisible, float tf, short segmentIndex, short controlPointIndex, short previousControlPointIndex, short nextControlPointIndex, bool previousControlPointIsSegment, bool nextControlPointIsSegment, bool canHaveFollowUp, short orientationAnchorIndex)
            {
                this.isVisible = isVisible;
                this.tf = tf;
                this.segmentIndex = segmentIndex;
                this.controlPointIndex = controlPointIndex;
                this.nextControlPointIndex = nextControlPointIndex;
                this.previousControlPointIndex = previousControlPointIndex;
                this.previousControlPointIsSegment = previousControlPointIsSegment;
                this.nextControlPointIsSegment = nextControlPointIsSegment;
                this.canHaveFollowUp = canHaveFollowUp;
                this.orientationAnchorIndex = orientationAnchorIndex;
            }

            public bool Equals(ControlPointExtrinsicProperties other)
            {
                return IsVisible == other.IsVisible
                       && TF == other.TF
                       && SegmentIndex == other.SegmentIndex
                       && ControlPointIndex == other.ControlPointIndex
                       && NextControlPointIndex == other.NextControlPointIndex
                       && PreviousControlPointIndex == other.PreviousControlPointIndex
                       && PreviousControlPointIsSegment == other.PreviousControlPointIsSegment
                       && NextControlPointIsSegment == other.NextControlPointIsSegment
                       && CanHaveFollowUp == other.CanHaveFollowUp
                       && OrientationAnchorIndex == other.OrientationAnchorIndex;
            }

            public override bool Equals(object obj)
            {
                if (ReferenceEquals(null, obj))
                    return false;
                return obj is ControlPointExtrinsicProperties && Equals((ControlPointExtrinsicProperties)obj);
            }

            public override int GetHashCode()
            {
                unchecked
                {
                    int hashCode = IsVisible.GetHashCode();
                    hashCode = (hashCode * 397) ^ TF.GetHashCode();
                    hashCode = (hashCode * 397) ^ SegmentIndex.GetHashCode();
                    hashCode = (hashCode * 397) ^ ControlPointIndex.GetHashCode();
                    hashCode = (hashCode * 397) ^ NextControlPointIndex.GetHashCode();
                    hashCode = (hashCode * 397) ^ PreviousControlPointIndex.GetHashCode();
                    hashCode = (hashCode * 397) ^ PreviousControlPointIsSegment.GetHashCode();
                    hashCode = (hashCode * 397) ^ NextControlPointIsSegment.GetHashCode();
                    hashCode = (hashCode * 397) ^ CanHaveFollowUp.GetHashCode();
                    hashCode = (hashCode * 397) ^ OrientationAnchorIndex.GetHashCode();
                    return hashCode;
                }
            }

            public static bool operator ==(ControlPointExtrinsicProperties left, ControlPointExtrinsicProperties right)
            {
                return left.Equals(right);
            }

            public static bool operator !=(ControlPointExtrinsicProperties left, ControlPointExtrinsicProperties right)
            {
                return !left.Equals(right);
            }

        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment.ControlPointExtrinsicProperties.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1f3c8d58ac75eab43bd8d07d598ce5bd
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Utils;
using System.Collections.Generic;
using FluffyUnderware.DevTools;
using UnityEngine.Serialization;
using System.Reflection;
using System;
using System.Collections.ObjectModel;
using System.Linq;
#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
using JetBrains.Annotations;
using UnityEngine.Assertions;


namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Class covering a Curvy Spline Segment / ControlPoint
    /// </summary>
    [ExecuteAlways]
    [HelpURL(CurvySpline.DOCLINK + "curvysplinesegment")]
    public partial class CurvySplineSegment : DTVersionedMonoBehaviour, IPoolable
    {
        /// <summary>
        /// The color used in Gizmos to draw a segment's tangents
        /// </summary>
        public static readonly Color GizmoTangentColor = new Color(0, 0.7f, 0);

        #region ### Public Properties ###

        /// <summary>
        /// List of precalculated interpolations
        /// </summary>
        /// <remarks>Based on Spline's CacheDensity</remarks>
        [NonSerialized]
        public Vector3[] Approximation = new Vector3[0];

        /// <summary>
        /// List of precalculated distances
        /// </summary>
        /// <remarks>Based on Spline's CacheDensity</remarks>
        [NonSerialized]
        public float[] ApproximationDistances = new float[0];

        /// <summary>
        /// List of precalculated Up-Vectors
        /// </summary>
        /// <remarks>Based on Spline's CacheDensity</remarks>
        [NonSerialized]
        public Vector3[] ApproximationUp = new Vector3[0];

        /// <summary>
        /// List of precalculated Tangent-Normals
        /// </summary>
        /// <remarks>Based on Spline's CacheDensity</remarks>
        [NonSerialized]
        public Vector3[] ApproximationT = new Vector3[0];

        /// <summary>
        /// If set, Control Point's rotation will be set to the calculated Up-Vector3
        /// </summary>
        /// <remarks>This is particularly useful when connecting splines</remarks>
        public bool AutoBakeOrientation
        {
            get { return m_AutoBakeOrientation; }
            set
            {
                if (m_AutoBakeOrientation != value)
                {
                    m_AutoBakeOrientation = value;
                }
            }
        }

        /// <summary>
        /// The serialized value of OrientationAnchor. This value is ignored in some cases (invisible control points, first and last visible control points). Use <see cref="CurvySpline.IsControlPointAnOrientationAnchor"/> to get the correct value.
        /// </summary>
        public bool SerializedOrientationAnchor
        {
            get { return m_OrientationAnchor; }
            set
            {
                if (m_OrientationAnchor != value)
                {
                    m_OrientationAnchor = value;
                    Spline.SetDirty(this, SplineDirtyingType.OrientationOnly);
                    Spline.InvalidateControlPointsRelationshipCacheINTERNAL();
                }
            }
        }

        /// <summary>
        /// Swirling Mode
        /// </summary>
        public CurvyOrientationSwirl Swirl
        {
            get { return m_Swirl; }
            set
            {
                if (m_Swirl != value)
                {
                    m_Swirl = value;
                    Spline.SetDirty(this, SplineDirtyingType.OrientationOnly);
                }
            }
        }

        /// <summary>
        /// Turns to swirl
        /// </summary>
        public float SwirlTurns
        {
            get { return m_SwirlTurns; }
            set
            {
                if (m_SwirlTurns != value)
                {
                    m_SwirlTurns = value;
                    Spline.SetDirty(this, SplineDirtyingType.OrientationOnly);
                }
            }
        }

        #region --- Bezier ---
        //TODO Make sure that every place in the code setting Handles respects the constraints of Sync length, Sync direction and Sync connections

        /// <summary>
        /// Bzier spline left handle in spline's local coordinates
        /// </summary>
        public Vector3 HandleIn
        {
            get
            { return m_HandleIn; }
            set
            {
                if (m_HandleIn != value)
                {
                    m_HandleIn = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// Bzier spline right handle in spline's local coordinates
        /// </summary>
        public Vector3 HandleOut
        {
            get { return m_HandleOut; }
            set
            {
                if (m_HandleOut != value)
                {
                    m_HandleOut = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        //BUG this doesn't handle scaled splines. Go through all similar situations and fix them, or add as a constraint that scaled splines should be normalized (scale set back to 1) before doing any operations on them
        /// <summary>
        /// Bzier spline left handle in world coordinates
        /// </summary>
        public Vector3 HandleInPosition
        {
            get
            {
                return cachedTransform.position + Spline.transform.rotation * HandleIn;
            }
            set
            {
                HandleIn = Spline.transform.InverseTransformDirection(value - cachedTransform.position);
            }
        }

        /// <summary>
        /// Bzier spline right handle in world coordinates
        /// </summary>
        public Vector3 HandleOutPosition
        {
            get
            {
                return cachedTransform.position + Spline.transform.rotation * HandleOut;
            }
            set
            {
                HandleOut = Spline.transform.InverseTransformDirection(value - cachedTransform.position);
            }
        }
        /// <summary>
        /// Gets or Sets Auto Handles. When setting it the value of connected control points is also updated
        /// </summary>
        public bool AutoHandles
        {
            get { return m_AutoHandles; }
            set
            {
                if (SetAutoHandles(value))
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
            }
        }

        public float AutoHandleDistance
        {
            get { return m_AutoHandleDistance; }
            set
            {
                if (m_AutoHandleDistance != value)
                {
                    float clampedDistance = Mathf.Clamp01(value);
                    if (m_AutoHandleDistance != clampedDistance)
                    {
                        m_AutoHandleDistance = clampedDistance;
                        Spline.SetDirty(this, SplineDirtyingType.Everything);
                    }
                }
            }
        }

        #endregion

        #region --- TCB ---

        /// <summary>
        /// Keep Start/End-TCB synchronized
        /// </summary>
        /// <remarks>Applies only to TCB Interpolation</remarks>
        public bool SynchronizeTCB
        {
            get { return m_SynchronizeTCB; }
            set
            {
                if (m_SynchronizeTCB != value)
                {
                    m_SynchronizeTCB = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// Whether local Tension should be used
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Tension</remarks>
        public bool OverrideGlobalTension
        {
            get { return m_OverrideGlobalTension; }
            set
            {
                if (m_OverrideGlobalTension != value)
                {
                    m_OverrideGlobalTension = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// Whether local Continuity should be used
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Continuity</remarks>
        public bool OverrideGlobalContinuity
        {
            get { return m_OverrideGlobalContinuity; }
            set
            {
                if (m_OverrideGlobalContinuity != value)
                {
                    m_OverrideGlobalContinuity = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// Whether local Bias should be used
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Bias</remarks>
        public bool OverrideGlobalBias
        {
            get { return m_OverrideGlobalBias; }
            set
            {
                if (m_OverrideGlobalBias != value)
                {
                    m_OverrideGlobalBias = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// Start Tension
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Tension</remarks>
        public float StartTension
        {
            get { return m_StartTension; }
            set
            {
                if (m_StartTension != value)
                {
                    m_StartTension = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// Start Continuity
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Continuity</remarks>
        public float StartContinuity
        {
            get { return m_StartContinuity; }
            set
            {
                if (m_StartContinuity != value)
                {
                    m_StartContinuity = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// Start Bias
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Bias</remarks>
        public float StartBias
        {
            get { return m_StartBias; }
            set
            {
                if (m_StartBias != value)
                {
                    m_StartBias = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// End Tension
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Tension</remarks>
        public float EndTension
        {
            get { return m_EndTension; }
            set
            {
                if (m_EndTension != value)
                {
                    m_EndTension = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// End Continuity
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Continuity</remarks>
        public float EndContinuity
        {
            get { return m_EndContinuity; }
            set
            {
                if (m_EndContinuity != value)
                {
                    m_EndContinuity = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// End Bias
        /// </summary>
        ///<remarks>This only applies to interpolation methods using Bias</remarks>
        public float EndBias
        {
            get { return m_EndBias; }
            set
            {
                if (m_EndBias != value)
                {
                    m_EndBias = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }


        #endregion
        /*
#region --- CG ---

        /// <summary>
        /// Material ID (used by PCG)
        /// </summary>
        public int CGMaterialID
        {
            get
            {
                return m_CGMaterialID;
            }
            set
            {
                if (m_CGMaterialID != Mathf.Max(0, value))
                    m_CGMaterialID = Mathf.Max(0, value);
            }
        }

        /// <summary>
        /// Whether to create a hard edge or not (used by PCG)
        /// </summary>
        public bool CGHardEdge
        {
            get { return m_CGHardEdge; }
            set
            {
                if (m_CGHardEdge != value)
                    m_CGHardEdge = value;
            }
        }
        /// <summary>
        /// Maximum vertex distance when using optimization (0=infinite)
        /// </summary>
        public float CGMaxStepDistance
        {
            get
            {
                return m_CGMaxStepDistance;
            }
            set
            {
                if (m_CGMaxStepDistance != Mathf.Max(0, value))
                    m_CGMaxStepDistance = Mathf.Max(0, value);
            }
        }

#endregion
        */
        #region --- Connections ---
        /// <summary>
        /// Gets the connected Control Point that is set as "Head To"
        /// </summary>
        public CurvySplineSegment FollowUp
        {
            get
            {
                //TODO reactivate this sanity check once the connections related data are no more stored in the control point but in the connection. Right now the check is disabled because the code in CurvyConnection.RemoveControlPoint needs to get the follow up while m_FollowUp.Connection == Connection is not true so that it can correct the situation
                //#if CURVY_SANITY_CHECKS
                //                Assert.IsTrue(m_FollowUp == null || m_FollowUp.Connection == Connection);
                //#endif
                return m_FollowUp;
            }
            private set
            {
                if (m_FollowUp != value)
                {
                    m_FollowUp = value;
#if CURVY_SANITY_CHECKS
                    Assert.IsTrue(m_FollowUp == null || m_FollowUp.Connection == Connection);
#endif
                    if (mSpline != null)
                        mSpline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }


        /// <summary>
        /// Gets or sets the heading toward the "Head To" segment
        /// </summary>
        //Remark Set/Get value is validated through GetValidateConnectionHeading
        public ConnectionHeadingEnum FollowUpHeading
        {
            get
            {
                return GetValidateConnectionHeading(m_FollowUpHeading, FollowUp);
            }
            set
            {
                value = GetValidateConnectionHeading(value, FollowUp);

                if (m_FollowUpHeading != value)
                {
                    m_FollowUpHeading = value;
                    if (mSpline != null)
                        mSpline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// When part of a <see cref="CurvyConnection"/>, this defines whether the connection's position is applied to this Control Point
        /// The synchronization process is applied by <see cref="CurvyConnection"/> at each frame in its update methods. So if you modify the value of this property, and want the synchronization to happen right away, you will have to call the connection's <see cref="CurvyConnection.SetSynchronisationPositionAndRotation(Vector3, Quaternion)"/> with the connection's position and rotation as parameters
        /// </summary>
        public bool ConnectionSyncPosition
        {
            get { return m_ConnectionSyncPosition; }
            set
            {
                if (m_ConnectionSyncPosition != value)
                {
                    m_ConnectionSyncPosition = value;
                    //DESIGN think about removing the code that handles ConnectionSyncPosition and ConnectionSyncRotation, and replace it with a code that always runs in Refresh, and make that code happen by calling SetDirty() here;
                }
            }
        }

        /// <summary>
        /// When part of a <see cref="CurvyConnection"/>, this defines whether the connection's rotation is applied to this Control Point
        /// The synchronization process is applied by <see cref="CurvyConnection"/> at each frame in its update methods. So if you modify the value of this property, and want the synchronization to happen right away, you will have to call the connection's <see cref="CurvyConnection.SetSynchronisationPositionAndRotation(Vector3, Quaternion)"/> with the connection's position and rotation as parameters
        /// </summary>
        public bool ConnectionSyncRotation
        {
            get { return m_ConnectionSyncRotation; }
            set
            {
                if (m_ConnectionSyncRotation != value)
                {
                    m_ConnectionSyncRotation = value;
                    //DESIGN think about removing the code that handles ConnectionSyncPosition and ConnectionSyncRotation, and replace it with a code that always runs in Refresh, and make that code happen by calling SetDirty() here;
                }
            }
        }

        /// <summary>
        /// Gets/Sets the connection handler this Control Point is using (if any)
        /// </summary>
        /// <remarks>If set to null, FollowUp wil be set to null to</remarks>
        public CurvyConnection Connection
        {
            get { return m_Connection; }
            internal set
            {
                if (SetConnection(value))
                    if (mSpline != null)
                        mSpline.SetDirty(this, SplineDirtyingType.Everything);
            }
        }

        #endregion


        /// <summary>
        /// Gets the number of individual cache points of this segment
        /// </summary>
        /// <remarks>The actual approximations arrays' size is CacheSize + 1</remarks>
        public int CacheSize
        {
            get
            {
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(Approximation.Length > 0, "[Curvy] CurvySplineSegment has uninitialized cache");
#endif
                return Approximation.Length - 1;
            }

        }

        /// <summary>
        /// Gets this segment's bounds in world space
        /// </summary>
        public Bounds Bounds
        {
            get
            {
                if (!mBounds.HasValue)
                {
                    Bounds result;
                    if (Approximation.Length == 0)
                        result = new Bounds(cachedTransform.position, Vector3.zero);
                    else
                    {
                        Matrix4x4 mat = Spline.transform.localToWorldMatrix;
                        result = new Bounds(mat.MultiplyPoint3x4(Approximation[0]), Vector3.zero);
                        int u = Approximation.Length;
                        for (int i = 1; i < u; i++)
                            result.Encapsulate(mat.MultiplyPoint3x4(Approximation[i]));
                    }

                    mBounds = result;
                }
                return mBounds.Value;
            }
        }

        /// <summary>
        /// Gets the length of this spline segment
        /// </summary>
        public float Length { get; private set; }

        /// <summary>
        /// Gets the distance from spline start to the first control point (localF=0) 
        /// </summary>
        public float Distance { get; internal set; }

        /// <summary>
        /// Gets the TF of this Control Point
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.
        /// This is the "time" parameter used in the splines' formulas.
        /// A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <remarks>This yields the same result as LocalFToTF(0)</remarks>
        public float TF
        {
            get
            {
                return mSpline.SegmentToTF(this);
            }
#if UNITY_2020_3_OR_NEWER
            [Obsolete("Setting a TF value is not allowed anymore")]
#endif
            internal set => Debug.LogError("[Curvy] CurvySplineSegment.TF: Setting a TF value is not allowed");
        }

        /// <summary>
        /// Gets whether this Control Point is the first IGNORING closed splines
        /// </summary>
        public bool IsFirstControlPoint
        {
            get
            {
                return (Spline.GetControlPointIndex(this) == 0);
            }
        }

        /// <summary>
        /// Gets whether this Control Point is the last IGNORING closed splines
        /// </summary>
        public bool IsLastControlPoint
        {
            get
            {
                return (Spline.GetControlPointIndex(this) == Spline.ControlPointCount - 1);
            }
        }

        /// <summary>
        /// The Metadata components added to this GameObject
        /// </summary>
        public HashSet<CurvyMetadataBase> Metadata
        {
            get
            {
                return mMetadata;
            }
        }

        /// <summary>
        /// Gets the parent spline
        /// </summary>
        public CurvySpline Spline
        {
            get
            {
                return mSpline;
            }
        }


        /// <summary>
        /// Returns true if the local position is different than the last one used in the segment approximations cache computation
        /// </summary>
        public bool HasUnprocessedLocalPosition { get { return cachedTransform.localPosition.Approximately(lastProcessedLocalPosition) == false; } }
        /// <summary>
        /// Returns true if the local orientation is different than the last one used in the segment approximations cache computation
        /// </summary>
        public bool HasUnprocessedLocalOrientation { get { return cachedTransform.localRotation.DifferentOrientation(lastProcessedLocalRotation); } }
        /// <summary>
        /// Returns wheter the orientation of this Control Point influences the orientation of its containing spline's approximation points.
        /// Returns false if control point is not part of a spline
        /// </summary>
        public bool OrientatinInfluencesSpline { get { return mSpline != null && (mSpline.Orientation == CurvyOrientation.Static || mSpline.IsControlPointAnOrientationAnchor(this)); } }

        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Sets Bezier HandleIn
        /// </summary>
        /// <param name="position">HandleIn position</param>
        /// <param name="space">The space (spline's local space or the world space) in which the <paramref name="position"/> is expressed</param>
        /// <param name="mode">Handle synchronization mode</param>
        public void SetBezierHandleIn(Vector3 position, Space space = Space.Self, CurvyBezierModeEnum mode = CurvyBezierModeEnum.None)
        {
            if (space == Space.Self)
                HandleIn = position;
            else
                HandleInPosition = position;

            bool syncDirections = (mode & CurvyBezierModeEnum.Direction) == CurvyBezierModeEnum.Direction;
            bool syncLengths = (mode & CurvyBezierModeEnum.Length) == CurvyBezierModeEnum.Length;
            bool syncConnectedCPs = (mode & CurvyBezierModeEnum.Connections) == CurvyBezierModeEnum.Connections;

            if (syncDirections)
                HandleOut = HandleOut.magnitude * (HandleIn.normalized * -1);
            if (syncLengths)
                HandleOut = HandleIn.magnitude * ((HandleOut == Vector3.zero) ? HandleIn.normalized * -1 : HandleOut.normalized);
            if (Connection && syncConnectedCPs && (syncDirections || syncLengths))
            {
                ReadOnlyCollection<CurvySplineSegment> connectionControlPoints = Connection.ControlPointsList;
                for (int index = 0; index < connectionControlPoints.Count; index++)
                {
                    CurvySplineSegment connectedCp = connectionControlPoints[index];
                    if (connectedCp == this)
                        continue;

                    if (connectedCp.HandleIn.magnitude == 0)
                        connectedCp.HandleIn = HandleIn;

                    if (syncDirections)
                        connectedCp.SetBezierHandleIn(connectedCp.HandleIn.magnitude * HandleIn.normalized * Mathf.Sign(Vector3.Dot(HandleIn, connectedCp.HandleIn)), Space.Self, CurvyBezierModeEnum.Direction);
                    if (syncLengths)
                        connectedCp.SetBezierHandleIn(connectedCp.HandleIn.normalized * HandleIn.magnitude, Space.Self, CurvyBezierModeEnum.Length);
                }
            }
        }

        /// <summary>
        /// Sets Bezier HandleOut
        /// </summary>
        /// <param name="position">HandleOut position</param>
        /// <param name="space">The space (spline's local space or the world space) in which the <paramref name="position"/> is expressed</param>
        /// <param name="mode">Handle synchronization mode</param>
        public void SetBezierHandleOut(Vector3 position, Space space = Space.Self, CurvyBezierModeEnum mode = CurvyBezierModeEnum.None)
        {
            if (space == Space.Self)
                HandleOut = position;
            else
                HandleOutPosition = position;

            bool syncDirections = (mode & CurvyBezierModeEnum.Direction) == CurvyBezierModeEnum.Direction;
            bool syncLengths = (mode & CurvyBezierModeEnum.Length) == CurvyBezierModeEnum.Length;
            bool syncConnectedCPs = (mode & CurvyBezierModeEnum.Connections) == CurvyBezierModeEnum.Connections;

            if (syncDirections)
                HandleIn = HandleIn.magnitude * (HandleOut.normalized * -1);
            if (syncLengths)
                HandleIn = HandleOut.magnitude * ((HandleIn == Vector3.zero) ? HandleOut.normalized * -1 : HandleIn.normalized);

            if (Connection && syncConnectedCPs && (syncDirections || syncLengths))
            {
                for (int index = 0; index < (Connection.ControlPointsList).Count; index++)
                {
                    CurvySplineSegment connectedCp = (Connection.ControlPointsList)[index];
                    if (connectedCp == this)
                        continue;

                    if (connectedCp.HandleOut.magnitude == 0)
                        connectedCp.HandleOut = HandleOut;

                    if (syncDirections)
                        connectedCp.SetBezierHandleOut(connectedCp.HandleOut.magnitude * HandleOut.normalized * Mathf.Sign(Vector3.Dot(HandleOut, connectedCp.HandleOut)), Space.Self, CurvyBezierModeEnum.Direction);
                    if (syncLengths)
                        connectedCp.SetBezierHandleOut(connectedCp.HandleOut.normalized * HandleOut.magnitude, Space.Self, CurvyBezierModeEnum.Length);
                }
            }
        }

        /// <summary>
        /// Automatically place Bezier handles relative to neighbour Control Points
        /// </summary>
        /// <param name="distanceFrag">how much % distance between neighbouring CPs are applied to the handle length?</param>
        /// <param name="setIn">Set HandleIn?</param>
        /// <param name="setOut">Set HandleOut?</param>
        /// <param name="noDirtying">If true, the Bezier handles will be modified without dirtying any spline</param>
        public void SetBezierHandles(float distanceFrag = -1, bool setIn = true, bool setOut = true, bool noDirtying = false)
        {
            Vector3 pIn = Vector3.zero;
            Vector3 pOut = Vector3.zero;
            if (distanceFrag == -1)
                distanceFrag = AutoHandleDistance;
            if (distanceFrag > 0)
            {
                CurvySpline spline = Spline;

                CurvySplineSegment nextControlPoint = spline.GetNextControlPoint(this);
                Transform nextTt = nextControlPoint
                    ? nextControlPoint.transform
                    : cachedTransform;
                CurvySplineSegment previousControlPoint = spline.GetPreviousControlPoint(this);
                Transform previousTt = previousControlPoint
                    ? previousControlPoint.transform
                    : cachedTransform;


                Vector3 c = cachedTransform.localPosition;
                Vector3 p = previousTt.localPosition - c;
                Vector3 n = nextTt.localPosition - c;
                SetBezierHandles(distanceFrag, p, n, setIn, setOut, noDirtying);
            }
            else
            {
                // Fallback to zero
                if (setIn)
                    if (noDirtying)
                        m_HandleIn = pIn;
                    else
                        HandleIn = pIn;

                if (setOut)
                    if (noDirtying)
                        m_HandleOut = pOut;
                    else
                        HandleOut = pOut;
            }

        }

        /// <summary>
        /// Automatically place Bezier handles
        /// </summary>
        /// <param name="distanceFrag">how much % distance between neighbouring CPs are applied to the handle length?</param>
        /// <param name="p">Position the In-Handle relates to</param>
        /// <param name="n">Position the Out-Handle relates to</param>
        /// <param name="setIn">Set HandleIn?</param>
        /// <param name="setOut">Set HandleOut?</param>
        /// <param name="noDirtying">If true, the Bezier handles will be modified without dirtying any spline</param>
        public void SetBezierHandles(float distanceFrag, Vector3 p, Vector3 n, bool setIn = true, bool setOut = true, bool noDirtying = false)
        {
            float pLen = p.magnitude;
            float nLen = n.magnitude;
            Vector3 pIn = Vector3.zero;
            Vector3 pOut = Vector3.zero;

            if (pLen != 0 || nLen != 0)
            {
                Vector3 dir = ((pLen / nLen) * n - p).normalized;
                pIn = -dir * (pLen * distanceFrag);
                pOut = dir * (nLen * distanceFrag);
            }

            // Fallback to zero
            if (setIn)
                if (noDirtying)
                    m_HandleIn = pIn;
                else
                    HandleIn = pIn;

            if (setOut)
                if (noDirtying)
                    m_HandleOut = pOut;
                else
                    HandleOut = pOut;
        }


        /// <summary>
        /// Sets Follow-Up of this Control Point
        /// </summary>
        /// <param name="target">the Control Point to follow to</param>
        /// <param name="heading">the Heading on the target's spline</param>
        public void SetFollowUp(CurvySplineSegment target, ConnectionHeadingEnum heading = ConnectionHeadingEnum.Auto)
        {
            if (target == null)
            {
                FollowUp = target;
                FollowUpHeading = heading;
            }
            else if (Spline.CanControlPointHaveFollowUp(this))
            {
                if (Connection == null || Connection != target.Connection)
                    DTLog.LogError("[Curvy] Trying to set as a Follow-Up a Control Point that is not part of the same connection", this);
                else
                {
                    FollowUp = target;
                    FollowUpHeading = heading;
                }
            }
            else
                DTLog.LogError("[Curvy] Setting a Follow-Up to a Control Point that can't have one", this);
        }

        /// <summary>
        /// Resets the connections related data (Connection, FollowUp, etc) while updating the Connection object and dirtying relevant splines.
        /// </summary>
        public void Disconnect()
        {
            Disconnect(true);
        }

        /// <summary>
        /// Resets the connections related data (Connection, FollowUp, etc) while updating the Connection object and dirtying relevant splines.
        /// </summary>
        /// <param name="destroyEmptyConnection">whether the related <see cref="Connection"/> should be destroyed if it becomes empty due to this Disconnect call</param>
        public void Disconnect(bool destroyEmptyConnection)
        {
            if (Connection)
                Connection.RemoveControlPoint(this, destroyEmptyConnection);

            //TODO make all this data part of the connection and not the CP
            //Reset connection related data
            FollowUp = null;
            FollowUpHeading = ConnectionHeadingEnum.Auto;
            ConnectionSyncPosition = false;
            ConnectionSyncRotation = false;
        }

        /// <summary>
        /// Gets the position of a point on the spline segment
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public Vector3 Interpolate(float localF, Space space = Space.Self)
        {
            CurvySpline spline = Spline;

#if CURVY_SANITY_CHECKS
            if (spline.Dirty)
                DTLog.LogWarning("Interpolate should not be called on segment of a dirty spline. Call CurvySpline.Refresh first", this);
            Assert.IsTrue(spline.IsControlPointASegment(this));
            Assert.IsTrue(spline.IsCpsRelationshipCacheValidINTERNAL);
#endif
            CurvyInterpolation curvyInterpolation = spline.Interpolation;

            Vector3 result;
            localF = Mathf.Clamp01(localF);

            //If you modify this, modify also the inlined version of this method in refreshCurveINTERNAL()
            switch (curvyInterpolation)
            {
                case CurvyInterpolation.BSpline:
                    result = BSpline(spline.ControlPointsList, spline.SegmentToTF(this, localF), spline.IsBSplineClamped, spline.Closed, spline.BSplineDegree, BSplineP0Array.Array);
                    break;
                case CurvyInterpolation.Bezier:
                    {
                        result = CurvySpline.Bezier(threadSafeLocalPosition.Addition(HandleOut),
                            threadSafeLocalPosition,
                            threadSafeNextCpLocalPosition,
                            threadSafeNextCpLocalPosition.Addition(cachedNextControlPoint.HandleIn),
                            localF);
                        break;
                    }
                case CurvyInterpolation.CatmullRom:
                case CurvyInterpolation.TCB:
                    {
                        if (curvyInterpolation == CurvyInterpolation.TCB)
                        {
                            float t0 = StartTension; float t1 = EndTension;
                            float c0 = StartContinuity; float c1 = EndContinuity;
                            float b0 = StartBias; float b1 = EndBias;

                            if (!OverrideGlobalTension)
                                t0 = t1 = mSpline.Tension;
                            if (!OverrideGlobalContinuity)
                                c0 = c1 = mSpline.Continuity;
                            if (!OverrideGlobalBias)
                                b0 = b1 = mSpline.Bias;

                            result = CurvySpline.TCB(threadSafePreviousCpLocalPosition,
                                threadSafeLocalPosition,
                                threadSafeNextCpLocalPosition,
                                cachedNextControlPoint.threadSafeNextCpLocalPosition,
                                localF, t0, c0, b0, t1, c1, b1);
                        }
                        else
                            result = CurvySpline.CatmullRom(threadSafePreviousCpLocalPosition,
                                threadSafeLocalPosition,
                                threadSafeNextCpLocalPosition,
                                cachedNextControlPoint.threadSafeNextCpLocalPosition,
                                localF);
                    }
                    break;
                case CurvyInterpolation.Linear:
                    result = OptimizedOperators.LerpUnclamped(
                        threadSafeLocalPosition,
                        threadSafeNextCpLocalPosition,
                        localF);
                    break;
                default:
                    DTLog.LogError("[Curvy] Invalid interpolation value " + curvyInterpolation, this);
                    return Vector3.zero;
            }

            if (space == Space.World)
                result = spline.ToWorldPosition(result);
            return result;
        }

        /// <summary>
        /// Gets the position of a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public Vector3 InterpolateFast(float localF, Space space = Space.Self)
        {
            Vector3 result;
            if (Approximation.Length > 1)
            {
                float frag;
                int idx = getApproximationIndexINTERNAL(localF, out frag);
                result = OptimizedOperators.LerpUnclamped(Approximation[idx], Approximation[idx + 1], frag);
            }
            else
                result = Approximation[0];

            if (space == Space.World)
                result = Spline.ToWorldPosition(result);
            return result;
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public Vector3 GetTangent(float localF, Space space = Space.Self)
        {
            localF = Mathf.Clamp01(localF);
            Vector3 position = Interpolate(localF, space);
            return GetTangent(localF, position, space);
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment.
        /// This method is faster than <see cref="GetTangent(float, Space)"/> if you have already the position of the point.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="position">the position of the point at localF. In other words, the result of <see cref="Interpolate(float, Space)"/></param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public Vector3 GetTangent(float localF, Vector3 position, Space space = Space.Self)
        {
            CurvySpline curvySpline = Spline;
#if CONTRACTS_FULL
            Contract.Requires(curvySpline != null);
#endif
            Vector3 p2;
            int leave = 2;
            const float fIncrement = 0.01f;
            do
            {
                float f2 = localF + fIncrement;
                if (f2 > 1)
                {
                    CurvySplineSegment nSeg = curvySpline.GetNextSegment(this);
                    if (nSeg)
                        p2 = nSeg.Interpolate(f2 - 1, space);//return (NextSegment.Interpolate(f2 - 1) - position).normalized;
                    else
                    {
                        f2 = localF - fIncrement;
                        return OptimizedOperators.Normalize(position.Subtraction(Interpolate(f2, space)));
                    }
                }
                else
                    p2 = Interpolate(f2, space); // return (Interpolate(f2) - position).normalized;

                localF += fIncrement;
            } while (p2 == position && --leave > 0);

            return OptimizedOperators.Normalize(p2.Subtraction(position));
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public Vector3 GetTangentFast(float localF, Space space = Space.Self)
        {
            Vector3 result;
            if (ApproximationT.Length > 1)
            {
                float frag;
                int idx = getApproximationIndexINTERNAL(localF, out frag);
                result = Vector3.SlerpUnclamped(ApproximationT[idx], ApproximationT[idx + 1], frag);
            }
            else
                result = ApproximationT[0];

            if (space == Space.World)
                result = Spline.ToWorldDirection(result);
            return result;
        }

        /// <summary>
        /// Gets the position and normalized tangent at a point on the spline segment
        /// Is Faster than calling <see cref="Interpolate(float, Space)"/> and <see cref="Interpolate(float, Space)"/> separately
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="position">the output position</param>
        /// <param name="tangent">the output tangent</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public void InterpolateAndGetTangent(float localF, out Vector3 position, out Vector3 tangent, Space space = Space.Self)
        {
            localF = Mathf.Clamp01(localF);
            position = Interpolate(localF, space);
            tangent = GetTangent(localF, position, space);
        }

        /// <summary>
        /// Gets the position and normalized tangent at a point on the spline segment
        /// Is Faster than calling <see cref="Interpolate(float, Space)"/> and <see cref="Interpolate(float, Space)"/> separately
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="position">the output position</param>
        /// <param name="tangent">the output tangent</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public void InterpolateAndGetTangentFast(float localF, out Vector3 position, out Vector3 tangent, Space space = Space.Self)
        {
            if (Approximation.Length > 1)
            {
                float frag;
                int idx = getApproximationIndexINTERNAL(localF, out frag);
                int idx2 = idx + 1;
                position = OptimizedOperators.LerpUnclamped(Approximation[idx], Approximation[idx2], frag);
                tangent = Vector3.SlerpUnclamped(ApproximationT[idx], ApproximationT[idx2], frag);
            }
            else
            {
                position = Approximation[0];
                tangent = ApproximationT[0];
            }


            if (space == Space.World)
            {
                position = Spline.ToWorldPosition(position);
                tangent = Spline.ToWorldDirection(tangent);
            }
        }

        /// <summary>
        /// Gets the Up vector of a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public Vector3 GetOrientationUpFast(float localF, Space space = Space.Self)
        {
            Vector3 result;
            if (ApproximationUp.Length > 1)
            {
                float frag;
                int idx = getApproximationIndexINTERNAL(localF, out frag);
                result = Vector3.SlerpUnclamped(ApproximationUp[idx], ApproximationUp[idx + 1], frag);
            }
            else
                result = ApproximationUp[0];

            if (space == Space.World)
                result = Spline.ToWorldDirection(result);
            return result;
        }

        /// <summary>
        /// Gets the rotation of a point on the spline segment. The rotation's forward is the segment's tangent, and it's up is the segment's orientation
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="inverse">whether the orientation should look at the opposite direction of the tangent</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public Quaternion GetOrientationFast(float localF, bool inverse = false, Space space = Space.Self)
        {
            Vector3 view = GetTangentFast(localF, space);

            Quaternion result;
            if (view != Vector3.zero)
            {
                if (inverse)
                    view *= -1;
                result = Quaternion.LookRotation(view, GetOrientationUpFast(localF, space));
            }
            else
            {
#if CURVY_SANITY_CHECKS
                Debug.LogError(string.Format("[Curvy] Invalid Orientation for segment {0} at localF {1}", this, localF));
#endif
                result = Quaternion.identity;
            }

            return result;

        }


        #region MetaData handling

        /// <summary>
        /// Rebuilds <see cref="Metadata"/>
        /// </summary>
        public void ReloadMetaData()
        {
            Metadata.Clear();
            CurvyMetadataBase[] metaDataComponents = GetComponents<CurvyMetadataBase>();
            foreach (CurvyMetadataBase metaData in metaDataComponents)
                Metadata.Add(metaData);

            CheckAgainstMetaDataDuplication();
        }

        /// <summary>
        /// Adds a MetaData instance to <see cref="Metadata"/>
        /// </summary>
        public void RegisterMetaData(CurvyMetadataBase metaData)
        {
            Metadata.Add(metaData);
            CheckAgainstMetaDataDuplication();
        }

        /// <summary>
        /// Removes a MetaData instance from <see cref="Metadata"/>
        /// </summary>
        public void UnregisterMetaData(CurvyMetadataBase metaData)
        {
            Metadata.Remove(metaData);
        }

        /// <summary>
        /// Gets Metadata of this ControlPoint
        /// </summary>
        /// <typeparam name="T">Metadata type</typeparam>
        /// <param name="autoCreate">whether to create the Metadata component if it's not present</param>
        /// <returns>the Metadata component or null</returns>
        public T GetMetadata<T>(bool autoCreate = false) where T : CurvyMetadataBase
        {
            Type type = typeof(T);
            T result = null;

            foreach (CurvyMetadataBase metaData in Metadata)
                if (metaData != null && metaData.GetType() == type)
                {
                    result = (T)metaData;
                    break;
                }

            if (autoCreate && result == null)
            {
                result = gameObject.AddComponent<T>();
                Metadata.Add(result);
            }
            return result;
        }

        /// <summary>
        /// Gets an interpolated Metadata value for a certain F
        /// </summary>
        /// <typeparam name="T">Metadata type inheriting from CurvyInterpolatableMetadataBase</typeparam>
        /// <typeparam name="U">Metadata's Value type</typeparam>
        /// <param name="f">a local F in the range 0..1</param>
        /// <returns>The interpolated value. If no Metadata of specified type is present at the given tf, the default value of type U is returned</returns>
        public U GetInterpolatedMetadata<T, U>(float f) where T : CurvyInterpolatableMetadataBase<U>
        {
            T metaData = GetMetadata<T>();
            if (metaData != null)
            {
                CurvySplineSegment nextCp = Spline.GetNextControlPointUsingFollowUp(this);
                CurvyInterpolatableMetadataBase<U> nextMetaData = null;
                if (nextCp)
                    nextMetaData = nextCp.GetMetadata<T>();
                return metaData.Interpolate(nextMetaData, f);
            }
            return default;
        }

        /// <summary>
        /// Removes all Metadata components of this Control Point
        /// </summary>
        public void DeleteMetadata()
        {
            List<CurvyMetadataBase> metaDataList = Metadata.ToList();
            for (int i = metaDataList.Count - 1; i >= 0; i--)
                metaDataList[i].Destroy(true, false);
        }
        #endregion

        /// <summary>
        /// Gets the localF of the point on the segment that is the nearest to a given position
        /// localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment
        /// </summary>
        /// <param name="position">The point's position</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param> <paramref name="position"/> is expressed</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CurvySpline.CacheDensity"/></remarks>
        public float GetNearestPointF(Vector3 position, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(CacheSize >= 0, "[Curvy] CurvySplineSegment has uninitialized cache. Call Refresh() on the CurvySpline it belongs to.");
#endif
            if (space == Space.World)
                position = Spline.ToLocalPosition(position);

            CurvyUtility.GetNearestPointIndex(position, Approximation, Approximation.Length, out int index, out float frag);

            // return the nearest collision
            return (index + frag) / (Approximation.Length - 1);

        }


        /// <summary>
        /// Gets the local F of a point given its local distance
        /// Local F stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment
        /// </summary>
        /// <param name="localDistance">The distance between the segment's start and the point you are interested in. Value should be in the range from 0 to <see cref="Length"/> inclusive</param>>
        public float DistanceToLocalF(float localDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(localDistance >= 0);
            Assert.IsTrue(localDistance <= Length);
#endif
            int approximationDistancesLength = ApproximationDistances.Length;

            if (approximationDistancesLength <= 1 || localDistance == 0)
                return 0;

            int lowerIndex = CurvyUtility.InterpolationSearch(ApproximationDistances, ApproximationDistances.Length, localDistance);
            if (lowerIndex == approximationDistancesLength - 1)
                return 1;

            //BUG this basically interpolates linearly the F value between two cache points. This is an approximation that is not correct because F does not vary linearly between two points, unlike distance that does. The issue is not big as long as there is a lot of cache points to keep the difference between the correct answer and the approximate one small enough.
            float frag = (localDistance - ApproximationDistances[lowerIndex]) / (ApproximationDistances[lowerIndex + 1] - ApproximationDistances[lowerIndex]);
            return (lowerIndex + frag) / (approximationDistancesLength - 1);
        }

        /// <summary>
        /// Gets the local distance of a point at a certain localF.
        /// Local distance is the distance between a point and the start of its segment. Value ranges from 0 to the segment's <see cref="Length"/>, inclusive
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        public float LocalFToDistance(float localF)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(localF >= 0);
            Assert.IsTrue(localF <= 1);
#endif
            if (ApproximationDistances.Length <= 1 || localF == 0)
                return 0;

            if (localF == 1f)
                return Length;

            float frag;
            int idx = getApproximationIndexINTERNAL(localF, out frag);
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(idx >= 0);
            Assert.IsTrue(idx < ApproximationDistances.Length - 1);
#endif
            float d = ApproximationDistances[idx + 1] - ApproximationDistances[idx];
            return ApproximationDistances[idx] + d * frag;
        }

        /// <summary>
        /// Gets TF for a certain local F
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <returns>a TF value</returns>
        public float LocalFToTF(float localF)
        {
            return Spline.SegmentToTF(this, localF);
        }

        public override string ToString()
        {
            if (Spline != null)
                return Spline.name + "." + name;
            else
                return base.ToString();
        }

        /// <summary>
        /// Modify the control point's local rotation to match the segment's orientation
        /// </summary>
        public void BakeOrientationToTransform()
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(ApproximationUp.Length > 0);
#endif

            Quaternion orientation = GetOrientationFast(0);
            if (cachedTransform.localRotation.DifferentOrientation(orientation))
                SetLocalRotation(orientation);
        }

        /// <summary>
        /// Internal, gets the index of mApproximation by F and the remaining fragment
        /// </summary>
        public int getApproximationIndexINTERNAL(float localF, out float frag)
        {
            int approximationLength = Approximation.Length;

            float f = localF * (approximationLength - 1);

            int tempIndex = (int)f;
            int index = tempIndex <= 0
                ? 0
                : tempIndex >= approximationLength - 2
                    ? approximationLength - 2
                    : tempIndex;

            float tempFrag = f - index;
            frag = tempFrag <= 0
                ? 0
                : tempFrag >= 1
                    ? 1
                    : tempFrag;

            return index;
        }

        public void LinkToSpline(CurvySpline spline)
        {
#if CURVY_SANITY_CHECKS
            //The following assertion is commented because, when dragging CPs from spline A to Spline B, we might have B's SyncSplineFromHierarchy executed before A's, and will call A's CP.LinkToSpline(B) while A's CP still has mSpline != null
            //Assert.IsTrue(mSpline == null, name);
#endif

            mSpline = spline;
        }

        public void UnlinkFromSpline()
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(mSpline != null);
#endif
            mSpline = null;
        }

#if CONTRACTS_FULL
        [ContractInvariantMethod]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "Required for code contracts.")]
        private void ObjectInvariant()
        {
            //Contract.Invariant(mSpline == null || transform.parent.GetComponent<CurvySpline>() == mSpline);
            //Contract.Invariant((mSpline == null) == (mControlPointIndex == -1));
            //Contract.Invariant(mSpline == null || mControlPointIndex < mSpline.ControlPointCount);
            //Contract.Invariant(mSpline == null || mSpline.ControlPoints.ElementAt(mControlPointIndex) == this);
            Contract.Invariant(Connection == null || Connection.ControlPoints.Contains(this));
            Contract.Invariant(Connection == null || Spline != null);
            Contract.Invariant(FollowUp == null || Connection != null);

            //TODO CONTRACT reactivate these if you find a way to call GetNextControlPoint and GetPreviousControlPoint without modifying the cache
            //Contract.Invariant(FollowUp == null || Spline.GetNextControlPoint(this) == null || Spline.GetPreviousControlPoint(this) == null);
        }
#endif

        #region Update position and rotation

        /// <summary>
        /// Sets the local position while dirtying the spline, dirtying the connected splines, and updating the connected control points' positions accordingly.
        /// </summary>
        /// <param name="newPosition"></param>
        public void SetLocalPosition(Vector3 newPosition)
        {
            if (cachedTransform.localPosition != newPosition)
            {
                cachedTransform.localPosition = newPosition;
                Spline.SetDirtyPartial(this, SplineDirtyingType.Everything);
                if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
                    Connection.SetSynchronisationPositionAndRotation(
                        ConnectionSyncPosition ? cachedTransform.position : Connection.transform.position,
                        ConnectionSyncRotation ? cachedTransform.rotation : Connection.transform.rotation);
            }
        }

        /// <summary>
        /// Sets the global position while dirtying the spline, dirtying the connected splines, and updating the connected control points' positions accordingly.
        /// </summary>
        /// <param name="value"></param>
        public void SetPosition(Vector3 value)
        {
            if (cachedTransform.position != value)
            {
                cachedTransform.position = value;
                Spline.SetDirtyPartial(this, SplineDirtyingType.Everything);
                if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
                    Connection.SetSynchronisationPositionAndRotation(
                        ConnectionSyncPosition ? cachedTransform.position : Connection.transform.position,
                        ConnectionSyncRotation ? cachedTransform.rotation : Connection.transform.rotation);
            }
        }

        /// <summary>
        /// Sets the local rotation while dirtying the spline, dirtying the connected splines, and updating the connected control points' rotations accordingly.
        /// </summary>
        /// <param name="value"></param>
        public void SetLocalRotation(Quaternion value)
        {
            if (cachedTransform.localRotation != value)
            {
                cachedTransform.localRotation = value;
                if (OrientatinInfluencesSpline)
                    Spline.SetDirtyPartial(this, SplineDirtyingType.OrientationOnly);
                if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
                    Connection.SetSynchronisationPositionAndRotation(
                        ConnectionSyncPosition ? cachedTransform.position : Connection.transform.position,
                        ConnectionSyncRotation ? cachedTransform.rotation : Connection.transform.rotation);
            }
        }

        /// <summary>
        /// Sets the global rotation while dirtying the spline, dirtying the connected splines, and updating the connected control points' rotations accordingly.
        /// </summary>
        /// <param name="value"></param>
        public void SetRotation(Quaternion value)
        {
            if (cachedTransform.rotation != value)
            {
                cachedTransform.rotation = value;
                if (OrientatinInfluencesSpline)
                    Spline.SetDirtyPartial(this, SplineDirtyingType.OrientationOnly);
                if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
                    Connection.SetSynchronisationPositionAndRotation(
                        ConnectionSyncPosition ? cachedTransform.position : Connection.transform.position,
                        ConnectionSyncRotation ? cachedTransform.rotation : Connection.transform.rotation);
            }
        }

        #endregion

        /// <summary>
        /// Returns true if followUp can be associated with a heading direction of <see cref="ConnectionHeadingEnum.Minus"/>
        /// </summary>
        public static bool CanFollowUpHeadToStart([NotNull] CurvySplineSegment followUp)
        {
            return followUp.Spline.GetPreviousControlPointIndex(followUp) != -1;
        }

        /// <summary>
        /// Returns true if followUp can be associated with a heading direction of <see cref="ConnectionHeadingEnum.Plus"/>
        /// </summary>
        public static bool CanFollowUpHeadToEnd([NotNull] CurvySplineSegment followUp)
        {
            return followUp.Spline.GetNextControlPointIndex(followUp) != -1;
        }

        /// <summary>
        /// Gets the position of a point on the B-Spline
        /// </summary>
        /// <param name="controlPoints">The spline's control points.</param>
        /// <param name="tf">A value between 0 and 1 defining where the point is on the spline</param>
        /// <param name="isClamped"><see cref="CurvySpline.IsBSplineClamped"/></param>
        /// <param name="isClosed"><see cref="CurvySpline.Closed"/></param>
        /// <param name="degree"><see cref="CurvySpline.BSplineDegree"/></param>
        /// <param name="p0Array">An array used in internal computations. This is to avoid excessive allocations.The length of the array should be greater or equal to <paramref name="degree"/> + 1. The content of the array does not matter, since it gets overwritten by the method</param>
        public static Vector3 BSpline([NotNull] ReadOnlyCollection<CurvySplineSegment> controlPoints, float tf, bool isClamped, bool isClosed, int degree, [NotNull] Vector3[] p0Array)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(p0Array.Length >= degree + 1);
            Assert.IsTrue(tf.IsBetween0And1());
#endif
            int controlPointsCount = controlPoints.Count;
            int n = BSplineHelper.GetBSplineN(controlPointsCount, degree, isClosed);
            BSplineHelper.GetBSplineUAndK(tf, isClamped, degree, n, out float u, out int k);
            GetBSplineP0s(controlPoints, controlPointsCount, degree, k, p0Array);
            return isClamped
                ? BSplineHelper.DeBoorClamped(degree, k, u, n + 1, p0Array)
                : BSplineHelper.DeBoorUnclamped(degree, k, u, p0Array);
        }

        #endregion

        #region ### Interface Implementations ###

        //IPoolable
        public void OnBeforePush()
        {
            this.StripComponents();
            Disconnect();
            DeleteMetadata();
        }

        //IPoolable
        public void OnAfterPop()
        {
            Reset();
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegmentDefaultValues.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e978a42d747dc414a880c903dec0e67f
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Here you can find all the default values for CurvySplineSegment's serialized fields. If you don't find a field here, this means that it's type's default value is the same than the field's default value
    /// </summary>
    public static class CurvySplineSegmentDefaultValues
    {
        public const CurvyOrientationSwirl Swirl = CurvyOrientationSwirl.None;
        public const bool SynchronizeTCB = true;
        public const bool AutoHandles = true;
        public const float AutoHandleDistance = 0.39f;
        public static readonly Vector3 HandleIn = new Vector3(-1, 0, 0);
        public static readonly Vector3 HandleOut = new Vector3(1, 0, 0);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegmentDefaultValues.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment_private.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 948d240c45adf9141b1aaaa44f7d5254
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Utils;
using System.Collections.Generic;
using FluffyUnderware.DevTools;
using UnityEngine.Serialization;
using System.Reflection;
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Runtime.CompilerServices;
using FluffyUnderware.Curvy.Pools;
#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
using JetBrains.Annotations;
using ToolBuddy.Pooling.Collections;
using ToolBuddy.Pooling.Pools;
using UnityEngine.Assertions;


namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Class covering a Curvy Spline Segment / ControlPoint
    /// </summary>
    public partial class CurvySplineSegment : DTVersionedMonoBehaviour, IPoolable
    {

        #region ### Serialized Fields ###

        #region --- General ---

        [Group("General")]
        [FieldAction("CBBakeOrientation", Position = ActionAttribute.ActionPositionEnum.Below)]
        [Label("Bake Orientation", "Automatically apply orientation to CP transforms?")]
        [SerializeField]
        private bool m_AutoBakeOrientation;

        [Group("General")]
        [Tooltip("Check to use this transform's rotation")]
        [FieldCondition(nameof(IsOrientationAnchorEditable), true)]
        [SerializeField]
        private bool m_OrientationAnchor;

        [Label("Swirl", "Add Swirl to orientation?")]
        [Group("General")]
        [FieldCondition(nameof(canHaveSwirl), true)]
        [SerializeField]
        private CurvyOrientationSwirl m_Swirl = CurvySplineSegmentDefaultValues.Swirl;

        [Label("Turns", "Number of swirl turns")]
        [Group("General")]
        [FieldCondition(nameof(canHaveSwirl), true, false, ConditionalAttribute.OperatorEnum.AND, "m_Swirl", CurvyOrientationSwirl.None, true)]
        [SerializeField]
        private float m_SwirlTurns;

        #endregion

        #region --- Bezier ---

        [Section("Bezier Options", Sort = 1, HelpURL = CurvySpline.DOCLINK + "curvysplinesegment_bezier")]
        [GroupCondition(nameof(interpolation), CurvyInterpolation.Bezier)]
        [SerializeField]
        private bool m_AutoHandles = CurvySplineSegmentDefaultValues.AutoHandles;

        [RangeEx(0, 1, "Distance %", "Handle length by distance to neighbours")]
        [FieldCondition(nameof(m_AutoHandles), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        [SerializeField]
        private float m_AutoHandleDistance = CurvySplineSegmentDefaultValues.AutoHandleDistance;

        [VectorEx(Precision = 3, Options = AttributeOptionsFlags.Clipboard | AttributeOptionsFlags.Negate, Color = "#FFFF00")]
        [SerializeField, FormerlySerializedAs("HandleIn")]
        private Vector3 m_HandleIn = CurvySplineSegmentDefaultValues.HandleIn;

        [VectorEx(Precision = 3, Options = AttributeOptionsFlags.Clipboard | AttributeOptionsFlags.Negate, Color = "#00FF00")]
        [SerializeField, FormerlySerializedAs("HandleOut")]
        private Vector3 m_HandleOut = CurvySplineSegmentDefaultValues.HandleOut;

        #endregion

        #region --- TCB ---

        [Section("TCB Options", Sort = 1, HelpURL = CurvySpline.DOCLINK + "curvysplinesegment_tcb")]
        [GroupCondition(nameof(interpolation), CurvyInterpolation.TCB)]
        [GroupAction("TCBOptionsGUI", Position = ActionAttribute.ActionPositionEnum.Below)]

        [Label("Local Tension", "Override Spline Tension?")]
        [SerializeField, FormerlySerializedAs("OverrideGlobalTension")]
        private bool m_OverrideGlobalTension;

        [Label("Local Continuity", "Override Spline Continuity?")]
        [SerializeField, FormerlySerializedAs("OverrideGlobalContinuity")]
        private bool m_OverrideGlobalContinuity;

        [Label("Local Bias", "Override Spline Bias?")]
        [SerializeField, FormerlySerializedAs("OverrideGlobalBias")]
        private bool m_OverrideGlobalBias;
        [Tooltip("Synchronize Start and End Values")]
        [SerializeField, FormerlySerializedAs("SynchronizeTCB")]
        private bool m_SynchronizeTCB = CurvySplineSegmentDefaultValues.SynchronizeTCB;
        [Label("Tension"), FieldCondition("m_OverrideGlobalTension", true)]
        [SerializeField, FormerlySerializedAs("StartTension")]
        private float m_StartTension;

        [Label("Tension (End)"), FieldCondition("m_OverrideGlobalTension", true, false, ConditionalAttribute.OperatorEnum.AND, "m_SynchronizeTCB", false, false)]
        [SerializeField, FormerlySerializedAs("EndTension")]
        private float m_EndTension;

        [Label("Continuity"), FieldCondition("m_OverrideGlobalContinuity", true)]
        [SerializeField, FormerlySerializedAs("StartContinuity")]
        private float m_StartContinuity;

        [Label("Continuity (End)"), FieldCondition("m_OverrideGlobalContinuity", true, false, ConditionalAttribute.OperatorEnum.AND, "m_SynchronizeTCB", false, false)]
        [SerializeField, FormerlySerializedAs("EndContinuity")]
        private float m_EndContinuity;

        [Label("Bias"), FieldCondition("m_OverrideGlobalBias", true)]
        [SerializeField, FormerlySerializedAs("StartBias")]
        private float m_StartBias;

        [Label("Bias (End)"), FieldCondition("m_OverrideGlobalBias", true, false, ConditionalAttribute.OperatorEnum.AND, "m_SynchronizeTCB", false, false)]
        [SerializeField, FormerlySerializedAs("EndBias")]
        private float m_EndBias;

        #endregion
        /*
#region --- CG Options ---
        
        /// <summary>
        /// Material ID (used by CG)
        /// </summary>
        [Section("Generator Options", true, Sort = 5, HelpURL = CurvySpline.DOCLINK + "curvysplinesegment_cg")]
        [Positive(Label="Material ID")]
        [SerializeField]
        int m_CGMaterialID;

        /// <summary>
        /// Whether to create a hard edge or not (used by PCG)
        /// </summary>
        [Label("Hard Edge")]
        [SerializeField]
        bool m_CGHardEdge;
        /// <summary>
        /// Maximum vertex distance when using optimization (0=infinite)
        /// </summary>
        [Positive(Label="Max Step Size",Tooltip="Max step distance when using optimization")]
        [SerializeField]
        float m_CGMaxStepDistance;
#endregion
        */
        #region --- Connections ---

        [SerializeField, HideInInspector] private CurvySplineSegment m_FollowUp;
        [SerializeField, HideInInspector] private ConnectionHeadingEnum m_FollowUpHeading = ConnectionHeadingEnum.Auto;
        //DESIGN: shouldn't these two be part of Connection? By spreading them on the ControlPoints, we risk a desynchronisation between m_ConnectionSyncPosition's value of a CP and the one of the connected CP
        [SerializeField, HideInInspector] private bool m_ConnectionSyncPosition;
        [SerializeField, HideInInspector] private bool m_ConnectionSyncRotation;

        [SerializeField, HideInInspector] private CurvyConnection m_Connection;

        #endregion

        #endregion

        #region ### Private Fields ###

        //Because Unity pre 2019 doesn't act like it is supposed to, I have to make two different codes for cachedTransform. Here is the issue:
        //cachedTransform is used as an optim. The idea is to get transform once at script's start, and then use it later. Execution order says that CurvySplineSegment runs before CurvySpline. So all CSS's OnEnable methods should run before CS's ones. But this is not the case in pre 2019. So you end up with CS's OnEnable accessing (through public members) to CSS's cachedTransform, which is still set to null because its OnEnable was not called yet.
#if (UNITY_2019_1_OR_NEWER)
        private Transform cachedTransform;
#else
        private Transform _cachedTransform;
        private Transform cachedTransform
        {
            get
            {
                if (ReferenceEquals(_cachedTransform, null))
                    _cachedTransform = transform;
                return _cachedTransform;
            }
            set
            {
                _cachedTransform = value;
            }
        }
#endif


        /// <summary>
        /// This exists because Transform can not be accessed in non main threads. So before refreshing the spline, we store the local position here so it can be accessed in multithread spline refreshing code
        /// </summary>
        /// <remarks>Warning: Make sure it is set with valid value before using it</remarks>
        private Vector3 threadSafeLocalPosition;
        /// <summary>
        /// Same as <see cref="threadSafeLocalPosition"/>, but for the next CP. Is equal to <see cref="threadSafeLocalPosition"/> if no next cp. Takes into consideration Follow-Ups if spline uses them to define its shape
        /// </summary>
        private Vector3 threadSafeNextCpLocalPosition;
        /// <summary>
        /// Same as <see cref="threadSafeLocalPosition"/>, but for the next CP. Is equal to <see cref="threadSafeLocalPosition"/> if no previous cp. Takes into consideration Follow-Ups if spline uses them to define its shape
        /// </summary>
        private Vector3 threadSafePreviousCpLocalPosition;
        /// <summary>
        /// This exists because Transform can not be accesed in non main threads. So before refreshing the spline, we store the local rotation here so it can be accessed in multithread spline refreshing code
        /// </summary>
        /// <remarks>Warning: Make sure it is set with valid value before using it</remarks>
        private Quaternion threadSafeLocalRotation;
        /// <summary>
        /// The cached result of Spline.GetNextControlPoint(this)
        /// OPTIM: use this more often?
        /// </summary>
        private CurvySplineSegment cachedNextControlPoint;

        private CurvySpline mSpline;
        private Bounds? mBounds;

        /// <summary>
        /// The Metadata components added to this GameObject
        /// </summary>
        private readonly HashSet<CurvyMetadataBase> mMetadata = new HashSet<CurvyMetadataBase>();
        /// <summary>
        /// The local position used in the segment approximations cache latest computation
        /// </summary>
        private Vector3 lastProcessedLocalPosition;
        /// <summary>
        /// The local rotation used in the segment approximations cache latest computation
        /// </summary>
        private Quaternion lastProcessedLocalRotation;

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */


        private void Awake()
        {
            //Happens when duplicating a spline that has a connection. This can be avoided
            if (Connection && Connection.ControlPointsList.Contains(this) == false)
                SetConnection(null);

            cachedTransform = transform;
            ReloadMetaData();
        }

        private void OnEnable()
        {
            Awake();
        }

#if UNITY_EDITOR

        private void OnDrawGizmos()
        {
            if (Spline && Spline.IsInitialized && Spline.ShowGizmos)
            {
                bool isSelected = Selection.Contains(gameObject.GetInstanceID());
                bool isThisOrParentSelected;
                {
                    if (isSelected)
                    {
                        isThisOrParentSelected = true;
                    }
                    else
                    {
                        Transform testedTransform = gameObject.transform.parent;
                        do
                        {
                            isThisOrParentSelected = Selection.Contains(testedTransform.gameObject.GetInstanceID());
                            testedTransform = testedTransform.parent;
                        }
                        while (!isThisOrParentSelected && ReferenceEquals(testedTransform, null) == false);
                    }
                }

                bool willOnDrawGizmosSelectedGetCalled;
                {
#if UNITY_2022_1_OR_NEWER
                    willOnDrawGizmosSelectedGetCalled = isSelected;
#else
                    willOnDrawGizmosSelectedGetCalled = isThisOrParentSelected;
#endif
                }

                if (willOnDrawGizmosSelectedGetCalled == false)
                {
#if UNITY_2022_1_OR_NEWER
                    doGizmos(isThisOrParentSelected);
#else
                    doGizmos(false);
#endif
                }
            }
        }

        private void OnDrawGizmosSelected()
        {
            if (Spline && Spline.IsInitialized)
                doGizmos(true);
        }
#endif

        private void OnDestroy()
        {
            //BUG? Why do we have that realDestroy boolean? Why not always do the same thing? This might hide something bad
            //When asked about this jake said:
            //That was quite a dirty hack as far as I remember, to counter issues with Unity's serialization
            //TBH I'm not sure if those issues still are present, so you might want to see if it's working without it now.
            bool realDestroy = true;
#if UNITY_EDITOR
            if (EditorApplication.isPlayingOrWillChangePlaymode && !EditorApplication.isPlaying)
                realDestroy = false;
#endif
            //Debug.Log("realDestroy " + realDestroy);
#if UNITY_EDITOR
            //mSpline is non null when the user delete only this CP. mSpline is null when the user deletes the spline, which then leads to this method to be called
            if (mSpline != null)
            {
                if (!Application.isPlaying &&
                    (CurvySpline._newSelectionInstanceIDINTERNAL == 0 || CurvySpline._newSelectionInstanceIDINTERNAL == GetInstanceID())
                    )
                {
                    if (Spline.GetPreviousControlPoint(this))
                        CurvySpline._newSelectionInstanceIDINTERNAL = Spline.GetPreviousControlPoint(this).GetInstanceID();
                    else if (Spline.GetNextControlPoint(this))
                        CurvySpline._newSelectionInstanceIDINTERNAL = Spline.GetNextControlPoint(this).GetInstanceID();
                    else
                        CurvySpline._newSelectionInstanceIDINTERNAL = mSpline.GetInstanceID();
                }
            }
#endif
            if (realDestroy)
            {
                Disconnect();
                if (bSplineP0Array.Count > 0)
                    ArrayPools.Vector3.Free(bSplineP0Array);
            }
        }

#if UNITY_EDITOR
        private void OnValidate()
        {
            //Debug.Log("    OnValidate " + name);
            SetAutoHandles(m_AutoHandles);
            SetConnection(m_Connection);
            if (mSpline != null)
            {
                Spline.SetDirtyAll(SplineDirtyingType.Everything, true);
                Spline.InvalidateControlPointsRelationshipCacheINTERNAL();
            }
        }

#endif

        /// <summary>
        /// Resets the properties of this control point, but will not remove its Connection if it has any.
        /// </summary>
        public void Reset()
        {
            m_OrientationAnchor = false;
            m_Swirl = CurvySplineSegmentDefaultValues.Swirl;
            m_SwirlTurns = 0;
            // Bezier
            m_AutoHandles = CurvySplineSegmentDefaultValues.AutoHandles;
            m_AutoHandleDistance = CurvySplineSegmentDefaultValues.AutoHandleDistance;
            m_HandleIn = CurvySplineSegmentDefaultValues.HandleIn;
            m_HandleOut = CurvySplineSegmentDefaultValues.HandleOut;
            // TCB
            m_SynchronizeTCB = CurvySplineSegmentDefaultValues.SynchronizeTCB;
            m_OverrideGlobalTension = false;
            m_OverrideGlobalContinuity = false;
            m_OverrideGlobalBias = false;
            m_StartTension = 0;
            m_EndTension = 0;
            m_StartContinuity = 0;
            m_EndContinuity = 0;
            m_StartBias = 0;
            m_EndBias = 0;
            if (mSpline)
            {
                Spline.SetDirty(this, SplineDirtyingType.Everything);
                Spline.InvalidateControlPointsRelationshipCacheINTERNAL();
            }
        }
        /*! \endcond */
        #endregion

        #region ### Privates & Internals ###
        /*! \cond PRIVATE */

        #region Properties used in inspector's field condition and group condition

        // Used as a group condition
        private CurvyInterpolation interpolation
        {
            get { return Spline ? Spline.Interpolation : CurvyInterpolation.Linear; }
        }

        // Used as a field condition
        private bool isDynamicOrientation
        {
            get { return Spline && Spline.Orientation == CurvyOrientation.Dynamic; }
        }

        // Used as a field condition
        private bool IsOrientationAnchorEditable
        {
            get
            {
                CurvySpline curvySpline = Spline;
                return isDynamicOrientation && curvySpline.IsControlPointVisible(this) && curvySpline.FirstVisibleControlPoint != this && curvySpline.LastVisibleControlPoint != this;
            }
        }

        // Used as a field condition
        private bool canHaveSwirl
        {
            get
            {
                CurvySpline curvySpline = Spline;
                return isDynamicOrientation && curvySpline && curvySpline.IsControlPointAnOrientationAnchor(this) && (curvySpline.Closed || curvySpline.LastVisibleControlPoint != this);
            }
        }

        #endregion

        #region BSplines

        /// <summary>
        /// A subArray used in the computation of B-Splines, to avoid arrays computation at each computation
        /// </summary>
        private SubArray<Vector3> bSplineP0Array;

        /// <summary>
        /// A subArray used in the computation of B-Splines, to avoid arrays computation at each computation
        /// </summary>
        private SubArray<Vector3> BSplineP0Array
        {
            get
            {
                if (bSplineP0Array.Count != mSpline.BSplineDegree + 1)
                {
                    ArrayPool<Vector3> arrayPool = ArrayPools.Vector3;
                    if (bSplineP0Array.Count > 0)
                        arrayPool.Free((SubArray<Vector3>)bSplineP0Array);
                    bSplineP0Array = arrayPool.Allocate(Spline.BSplineDegree + 1, false);
                }
                return bSplineP0Array;
            }
        }

        /// <summary>
        /// Fills <paramref name="pArray"/> with the P0s numbers as defined in the B-Spline section, De Boor's algorithm, here: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void GetBSplineP0s([NotNull] ReadOnlyCollection<CurvySplineSegment> controlPoints, int controlPointsCount, int degree, int k, [NotNull] Vector3[] pArray)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(pArray.Length >= degree + 1);
#endif
            for (int j = 0; j <= degree; j++)
            {
                int index = j + k - degree;
                pArray[j] = controlPoints[
                        index < controlPointsCount
                            ? index
                            : (index - controlPointsCount)
                    ]
                    .threadSafeLocalPosition;
            }
        }

        #endregion

        #region Extrinsic properties

        private ControlPointExtrinsicProperties extrinsicPropertiesINTERNAL;

        /// <summary>
        /// Properties describing the relationship between this CurvySplineSegment and its containing CurvySpline.
        /// </summary>
        internal void SetExtrinsicPropertiesINTERNAL(ControlPointExtrinsicProperties value)
        {
            extrinsicPropertiesINTERNAL = value;
        }
        internal ref readonly ControlPointExtrinsicProperties GetExtrinsicPropertiesINTERNAL()
        {
            return ref extrinsicPropertiesINTERNAL;
        }

        #endregion

        private void CheckAgainstMetaDataDuplication()
        {
            if (Metadata.Count > 1)
            {
                HashSet<Type> metaDataTypes = new HashSet<Type>();
                foreach (CurvyMetadataBase metaData in Metadata)
                {
                    Type componentType = metaData.GetType();
                    if (metaDataTypes.Contains(componentType))
                        DTLog.LogWarning(String.Format("[Curvy] Game object '{0}' has multiple Components of type '{1}'. Control Points should have no more than one Component instance for each MetaData type.", this.ToString(), componentType), this);
                    else
                        metaDataTypes.Add(componentType);
                }
            }
        }

        /// <summary>
        /// Sets the connection handler this Control Point is using
        /// </summary>
        /// <param name="newConnection"></param>
        /// <returns>Whether a modification was done or not</returns>
        /// <remarks>If set to null, FollowUp wil be set to null to</remarks>
        private bool SetConnection(CurvyConnection newConnection)
        {
            bool modificationDone = false;
            if (m_Connection != newConnection)
            {
                modificationDone = true;
                m_Connection = newConnection;
            }
            if (m_Connection == null && m_FollowUp != null)
            {
                modificationDone = true;
                m_FollowUp = null;
            }
            return modificationDone;
        }

        /// <summary>
        /// Returns a different ConnectionHeadingEnum value when connectionHeading has a value that is no more valid in the context of this spline. For example, heading to start (Minus) when there is no previous CP
        /// </summary>
        private static ConnectionHeadingEnum GetValidateConnectionHeading(ConnectionHeadingEnum connectionHeading, [CanBeNull] CurvySplineSegment followUp)
        {
            if (followUp == null)
                return connectionHeading;

            if ((connectionHeading == ConnectionHeadingEnum.Minus && CanFollowUpHeadToStart(followUp) == false)
                || (connectionHeading == ConnectionHeadingEnum.Plus && CanFollowUpHeadToEnd(followUp) == false))
                return ConnectionHeadingEnum.Auto;

            return connectionHeading;
        }

        /// <summary>
        /// Sets Auto Handles. When setting it the value of connected control points is also updated
        /// </summary>
        /// <param name="newValue"></param>
        /// <returns>Whether a modifcation was done or not</returns>
        private bool SetAutoHandles(bool newValue)
        {
            bool modificationDone = false;
            if (Connection)
            {
                ReadOnlyCollection<CurvySplineSegment> controlPoints = Connection.ControlPointsList;
                for (int index = 0; index < controlPoints.Count; index++)
                {
                    CurvySplineSegment controlPoint = controlPoints[index];
                    modificationDone = modificationDone || controlPoint.m_AutoHandles != newValue;
                    controlPoint.m_AutoHandles = newValue;
                }
            }
            else
            {
                modificationDone = m_AutoHandles != newValue;
                m_AutoHandles = newValue;
            }
            return modificationDone;
        }

        #region approximations cache computation

        internal void refreshCurveINTERNAL()
        {
            CurvySpline spline = Spline;
            bool isControlPointASegment = spline.IsControlPointASegment(this);
            int newCacheSize;
            if (isControlPointASegment)
            {
#if CURVY_SANITY_CHECKS
                Assert.IsNotNull(cachedNextControlPoint);
#endif
                newCacheSize = CurvySpline.CalculateCacheSize(
                    spline.CacheDensity,
                    (cachedNextControlPoint.threadSafeLocalPosition.Subtraction(threadSafeLocalPosition)).magnitude,
                    spline.MaxPointsPerUnit);
            }
            else
                newCacheSize = 0;

            Array.Resize(ref Approximation, newCacheSize + 1);
            Array.Resize(ref ApproximationT, newCacheSize + 1);
            Array.Resize(ref ApproximationDistances, newCacheSize + 1);
            Array.Resize(ref ApproximationUp, newCacheSize + 1);

            bool hasNextControlPoint = ReferenceEquals(cachedNextControlPoint, null) == false;

            //set Approximation[0] and Approximation[newCacheSize]
            switch (interpolation)
            {
                case CurvyInterpolation.Linear:
                case CurvyInterpolation.CatmullRom:
                case CurvyInterpolation.TCB:
                case CurvyInterpolation.Bezier:
                    Approximation[0] = threadSafeLocalPosition;
                    if (newCacheSize != 0)
                        Approximation[newCacheSize] = hasNextControlPoint
                            ? cachedNextControlPoint.threadSafeLocalPosition
                            : threadSafeLocalPosition;
                    break;
                case CurvyInterpolation.BSpline:
                    if (isControlPointASegment)
                    {
                        Approximation[0] = BSpline(spline.ControlPointsList, spline.SegmentToTF(this), spline.IsBSplineClamped, spline.Closed, spline.BSplineDegree, BSplineP0Array.Array);
                        Approximation[newCacheSize] = BSpline(spline.ControlPointsList, spline.SegmentToTF(this, 1), spline.IsBSplineClamped, spline.Closed, spline.BSplineDegree, BSplineP0Array.Array);
                    }
                    else
                        //staying coherent with other interpolation types. TODO check why Approximation should have the element 0 when not a segment. What happens if we simply keep the array empty?
                        Approximation[0] = threadSafeLocalPosition;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            ApproximationDistances[0] = 0;
            //  ApproximationT[0] and ApproximationUp[0] are handled later
            mBounds = null;
            Length = 0;

            if (isControlPointASegment)
            {
                float segmentLength = 0;
                switch (spline.Interpolation)
                {
                    case CurvyInterpolation.BSpline:
                        segmentLength = InterpolateBSplineSegment(newCacheSize);
                        break;
                    case CurvyInterpolation.Bezier:
                        segmentLength = InterpolateBezierSegment(cachedNextControlPoint, newCacheSize);
                        break;
                    case CurvyInterpolation.CatmullRom:
                        segmentLength = InterpolateCatmullSegment(cachedNextControlPoint, newCacheSize);
                        break;
                    case CurvyInterpolation.TCB:
                        segmentLength = InterpolateTCBSegment(cachedNextControlPoint, newCacheSize, spline.Tension, spline.Continuity, spline.Bias);
                        break;
                    case CurvyInterpolation.Linear:
                        segmentLength = InterpolateLinearSegment(cachedNextControlPoint, newCacheSize);
                        break;
                    default:
                        DTLog.LogError("[Curvy] Invalid interpolation value " + spline.Interpolation, this);
                        break;
                }
                Length = segmentLength;

                Vector3 tangent = Approximation[newCacheSize].Subtraction(Approximation[newCacheSize - 1]);
                Length += tangent.magnitude;
                ApproximationDistances[newCacheSize] = Length;
                ApproximationT[newCacheSize - 1] = tangent.normalized;
                // ApproximationT[cacheSize] is set in Spline's Refresh method
                ApproximationT[newCacheSize] = ApproximationT[newCacheSize - 1];
            }
            else
            {
                if (hasNextControlPoint)
                    ApproximationT[0] = (cachedNextControlPoint.threadSafeLocalPosition.Subtraction(Approximation[0])).normalized;
                else
                {
                    short previousControlPointIndex = spline.GetPreviousControlPointIndex(this);
                    if (previousControlPointIndex != -1)
                        ApproximationT[0] = (Approximation[0].Subtraction(spline.ControlPointsList[previousControlPointIndex].threadSafeLocalPosition)).normalized;
                    else
                        ApproximationT[0] = threadSafeLocalRotation * Vector3.forward;
                }

                //Last visible control point gets the last tangent from the previous segment. This is done in Spline's Refresh method 

            }

            lastProcessedLocalPosition = threadSafeLocalPosition;
        }


        #region Inlined code for optimization


        private float InterpolateBSplineSegment(int newCacheSize)
        {
            CurvySpline spline = Spline;

            float mStepSize = 1f / newCacheSize;
            float lengthAccumulator = 0;

            bool isClamped = spline.IsBSplineClamped;
            ReadOnlyCollection<CurvySplineSegment> controlPoints = spline.ControlPointsList;
            int degree = spline.BSplineDegree;
            float segmentTF = spline.SegmentToTF(this);
            float tfIncrement = mStepSize / spline.Count;

            int controlPointsCount = controlPoints.Count;
            int n = BSplineHelper.GetBSplineN(controlPointsCount, degree, spline.Closed);
            int previousK = int.MinValue;

            SubArray<Vector3> splinePsVector = BSplineP0Array;
            Vector3[] ps = splinePsVector.Array;
            int psCount = splinePsVector.Count;

            SubArray<Vector3> psCopySubArray = ArrayPools.Vector3.Allocate(psCount);
            Vector3[] psCopy = psCopySubArray.Array;

            int nPlus1 = n + 1;
            for (int i = 1; i < newCacheSize; i++)
            {
                float tf = segmentTF + tfIncrement * i;
                BSplineHelper.GetBSplineUAndK(tf, isClamped, degree, n, out float u, out int k);

                if (k != previousK)
                {
                    GetBSplineP0s(controlPoints, controlPointsCount, degree, k, ps);
                    previousK = k;
                }

                Array.Copy(ps, 0, psCopy, 0, psCount);

                Approximation[i] = isClamped ? BSplineHelper.DeBoorClamped(degree, k, u, nPlus1, psCopy) : BSplineHelper.DeBoorUnclamped(degree, k, u, psCopy);

                Vector3 delta = Approximation[i].Subtraction(Approximation[i - 1]);
                lengthAccumulator += delta.magnitude;
                ApproximationDistances[i] = lengthAccumulator;
                ApproximationT[i - 1] = OptimizedOperators.Normalize(delta);
            }

            ArrayPools.Vector3.Free(psCopySubArray);

            return lengthAccumulator;
        }

        private float InterpolateBezierSegment(CurvySplineSegment nextControlPoint, int newCacheSize)
        {
            //The following code is the inlined version of this code:
            //        for (int i = 1; i < CacheSize; i++)
            //        {
            //            Approximation[i] = interpolateBezier(i * mStepSize);
            //            t = (Approximation[i] - Approximation[i - 1]);
            //            Length += t.magnitude;
            //            ApproximationDistances[i] = Length;
            //            ApproximationT[i - 1] = t.normalized;
            //        }

            float mStepSize = 1f / newCacheSize;

            float lengthAccumulator = 0;
            CurvySplineSegment ncp = nextControlPoint;
            Vector3 p0 = threadSafeLocalPosition;
            Vector3 t0 = p0 + HandleOut;
            Vector3 p1 = ncp.threadSafeLocalPosition;
            Vector3 t1 = p1 + ncp.HandleIn;

            const double Ft2 = 3;
            const double Ft3 = -3;
            const double Fu1 = 3;
            const double Fu2 = -6;
            const double Fu3 = 3;
            const double Fv1 = -3;
            const double Fv2 = 3;

            double FAX = -p0.x + Ft2 * t0.x + Ft3 * t1.x + p1.x;
            double FBX = Fu1 * p0.x + Fu2 * t0.x + Fu3 * t1.x;
            double FCX = Fv1 * p0.x + Fv2 * t0.x;
            double FDX = p0.x;

            double FAY = -p0.y + Ft2 * t0.y + Ft3 * t1.y + p1.y;
            double FBY = Fu1 * p0.y + Fu2 * t0.y + Fu3 * t1.y;
            double FCY = Fv1 * p0.y + Fv2 * t0.y;
            double FDY = p0.y;

            double FAZ = -p0.z + Ft2 * t0.z + Ft3 * t1.z + p1.z;
            double FBZ = Fu1 * p0.z + Fu2 * t0.z + Fu3 * t1.z;
            double FCZ = Fv1 * p0.z + Fv2 * t0.z;
            double FDZ = p0.z;
            Vector3 tangent;

            for (int i = 1; i < newCacheSize; i++)
            {
                float localF = i * mStepSize;

                Approximation[i].x = (float)(((FAX * localF + FBX) * localF + FCX) * localF + FDX);
                Approximation[i].y = (float)(((FAY * localF + FBY) * localF + FCY) * localF + FDY);
                Approximation[i].z = (float)(((FAZ * localF + FBZ) * localF + FCZ) * localF + FDZ);

                tangent.x = (Approximation[i].x - Approximation[i - 1].x);
                tangent.y = (Approximation[i].y - Approximation[i - 1].y);
                tangent.z = (Approximation[i].z - Approximation[i - 1].z);

                float tMagnitude = Mathf.Sqrt((float)(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z));
                lengthAccumulator += tMagnitude;
                ApproximationDistances[i] = lengthAccumulator;
                if ((double)tMagnitude > 9.99999974737875E-06)
                {
                    float oneOnMagnitude = 1 / tMagnitude;
                    ApproximationT[i - 1].x = tangent.x * oneOnMagnitude;
                    ApproximationT[i - 1].y = tangent.y * oneOnMagnitude;
                    ApproximationT[i - 1].z = tangent.z * oneOnMagnitude;
                }
                else
                {
                    ApproximationT[i - 1].x = 0;
                    ApproximationT[i - 1].y = 0;
                    ApproximationT[i - 1].z = 0;
                }
            }
            return lengthAccumulator;
        }


        private float InterpolateTCBSegment(CurvySplineSegment nextControlPoint, int newCacheSize, float splineTension, float splineContinuity, float splineBias)
        {
            //The following code is the inlined version of this code:
            //        for (int i = 1; i < CacheSize; i++)
            //        {
            //            Approximation[i] = interpolateCatmull(i * mStepSize);
            //            t = (Approximation[i] - Approximation[i - 1]);
            //            Length += t.magnitude;
            //            ApproximationDistances[i] = Length;
            //            ApproximationT[i - 1] = t.normalized;
            //        }

            float mStepSize = 1f / newCacheSize;

            float lengthAccumulator = 0;

            float ft0 = StartTension;
            float ft1 = EndTension;
            float fc0 = StartContinuity;
            float fc1 = EndContinuity;
            float fb0 = StartBias;
            float fb1 = EndBias;

            if (!OverrideGlobalTension)
                ft0 = ft1 = splineTension;
            if (!OverrideGlobalContinuity)
                fc0 = fc1 = splineContinuity;
            if (!OverrideGlobalBias)
                fb0 = fb1 = splineBias;

            Vector3 p0 = threadSafeLocalPosition;
            Vector3 p1 = threadSafeNextCpLocalPosition;
            Vector3 t0 = threadSafePreviousCpLocalPosition;
            Vector3 t1 = nextControlPoint.threadSafeNextCpLocalPosition;

            double FFA = (1 - ft0) * (1 + fc0) * (1 + fb0);
            double FFB = (1 - ft0) * (1 - fc0) * (1 - fb0);
            double FFC = (1 - ft1) * (1 - fc1) * (1 + fb1);
            double FFD = (1 - ft1) * (1 + fc1) * (1 - fb1);

            double DD = 2;
            double Ft1 = -FFA / DD;
            double Ft2 = (+4 + FFA - FFB - FFC) / DD;
            double Ft3 = (-4 + FFB + FFC - FFD) / DD;
            double Ft4 = FFD / DD;
            double Fu1 = +2 * FFA / DD;
            double Fu2 = (-6 - 2 * FFA + 2 * FFB + FFC) / DD;
            double Fu3 = (+6 - 2 * FFB - FFC + FFD) / DD;
            double Fu4 = -FFD / DD;
            double Fv1 = -FFA / DD;
            double Fv2 = (FFA - FFB) / DD;
            double Fv3 = FFB / DD;
            double Fw2 = +2 / DD;

            double FAX = Ft1 * t0.x + Ft2 * p0.x + Ft3 * p1.x + Ft4 * t1.x;
            double FBX = Fu1 * t0.x + Fu2 * p0.x + Fu3 * p1.x + Fu4 * t1.x;
            double FCX = Fv1 * t0.x + Fv2 * p0.x + Fv3 * p1.x;
            double FDX = Fw2 * p0.x;

            double FAY = Ft1 * t0.y + Ft2 * p0.y + Ft3 * p1.y + Ft4 * t1.y;
            double FBY = Fu1 * t0.y + Fu2 * p0.y + Fu3 * p1.y + Fu4 * t1.y;
            double FCY = Fv1 * t0.y + Fv2 * p0.y + Fv3 * p1.y;
            double FDY = Fw2 * p0.y;

            double FAZ = Ft1 * t0.z + Ft2 * p0.z + Ft3 * p1.z + Ft4 * t1.z;
            double FBZ = Fu1 * t0.z + Fu2 * p0.z + Fu3 * p1.z + Fu4 * t1.z;
            double FCZ = Fv1 * t0.z + Fv2 * p0.z + Fv3 * p1.z;
            double FDZ = Fw2 * p0.z;
            Vector3 tangent;
            for (int i = 1; i < newCacheSize; i++)
            {
                float localF = i * mStepSize;

                Approximation[i].x = (float)(((FAX * localF + FBX) * localF + FCX) * localF + FDX);
                Approximation[i].y = (float)(((FAY * localF + FBY) * localF + FCY) * localF + FDY);
                Approximation[i].z = (float)(((FAZ * localF + FBZ) * localF + FCZ) * localF + FDZ);

                tangent.x = (Approximation[i].x - Approximation[i - 1].x);
                tangent.y = (Approximation[i].y - Approximation[i - 1].y);
                tangent.z = (Approximation[i].z - Approximation[i - 1].z);

                float tMagnitude = Mathf.Sqrt((float)(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z));
                lengthAccumulator += tMagnitude;
                ApproximationDistances[i] = lengthAccumulator;
                if ((double)tMagnitude > 9.99999974737875E-06)
                {
                    float oneOnMagnitude = 1 / tMagnitude;
                    ApproximationT[i - 1].x = tangent.x * oneOnMagnitude;
                    ApproximationT[i - 1].y = tangent.y * oneOnMagnitude;
                    ApproximationT[i - 1].z = tangent.z * oneOnMagnitude;
                }
                else
                {
                    ApproximationT[i - 1].x = 0;
                    ApproximationT[i - 1].y = 0;
                    ApproximationT[i - 1].z = 0;
                }
            }
            return lengthAccumulator;
        }

        private float InterpolateCatmullSegment(CurvySplineSegment nextControlPoint, int newCacheSize)
        {
            //The following code is the inlined version of this code:
            //        for (int i = 1; i < CacheSize; i++)
            //        {
            //            Approximation[i] = interpolateTCB(i * mStepSize);
            //            t = (Approximation[i] - Approximation[i - 1]);
            //            Length += t.magnitude;
            //            ApproximationDistances[i] = Length;
            //            ApproximationT[i - 1] = t.normalized;
            //        }

            float mStepSize = 1f / newCacheSize;

            float lengthAccumulator = 0;

            Vector3 p0 = threadSafeLocalPosition;
            Vector3 p1 = threadSafeNextCpLocalPosition;
            Vector3 t0 = threadSafePreviousCpLocalPosition;
            Vector3 t1 = nextControlPoint.threadSafeNextCpLocalPosition;

            const double Ft1 = -0.5;
            const double Ft2 = 1.5;
            const double Ft3 = -1.5;
            const double Ft4 = 0.5;
            const double Fu2 = -2.5;
            const double Fu3 = 2;
            const double Fu4 = -0.5;
            const double Fv1 = -0.5;
            const double Fv3 = 0.5;

            double FAX = Ft1 * t0.x + Ft2 * p0.x + Ft3 * p1.x + Ft4 * t1.x;
            double FBX = t0.x + Fu2 * p0.x + Fu3 * p1.x + Fu4 * t1.x;
            double FCX = Fv1 * t0.x + Fv3 * p1.x;
            double FDX = p0.x;

            double FAY = Ft1 * t0.y + Ft2 * p0.y + Ft3 * p1.y + Ft4 * t1.y;
            double FBY = t0.y + Fu2 * p0.y + Fu3 * p1.y + Fu4 * t1.y;
            double FCY = Fv1 * t0.y + Fv3 * p1.y;
            double FDY = p0.y;

            double FAZ = Ft1 * t0.z + Ft2 * p0.z + Ft3 * p1.z + Ft4 * t1.z;
            double FBZ = t0.z + Fu2 * p0.z + Fu3 * p1.z + Fu4 * t1.z;
            double FCZ = Fv1 * t0.z + Fv3 * p1.z;
            double FDZ = p0.z;
            Vector3 tangent;
            for (int i = 1; i < newCacheSize; i++)
            {
                float localF = i * mStepSize;

                Approximation[i].x = (float)(((FAX * localF + FBX) * localF + FCX) * localF + FDX);
                Approximation[i].y = (float)(((FAY * localF + FBY) * localF + FCY) * localF + FDY);
                Approximation[i].z = (float)(((FAZ * localF + FBZ) * localF + FCZ) * localF + FDZ);

                tangent.x = (Approximation[i].x - Approximation[i - 1].x);
                tangent.y = (Approximation[i].y - Approximation[i - 1].y);
                tangent.z = (Approximation[i].z - Approximation[i - 1].z);

                float tMagnitude = Mathf.Sqrt((float)(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z));
                lengthAccumulator += tMagnitude;
                ApproximationDistances[i] = lengthAccumulator;
                if ((double)tMagnitude > 9.99999974737875E-06)
                {
                    float oneOnMagnitude = 1 / tMagnitude;
                    ApproximationT[i - 1].x = tangent.x * oneOnMagnitude;
                    ApproximationT[i - 1].y = tangent.y * oneOnMagnitude;
                    ApproximationT[i - 1].z = tangent.z * oneOnMagnitude;
                }
                else
                {
                    ApproximationT[i - 1].x = 0;
                    ApproximationT[i - 1].y = 0;
                    ApproximationT[i - 1].z = 0;
                }
            }
            return lengthAccumulator;
        }

        private float InterpolateLinearSegment(CurvySplineSegment nextControlPoint, int newCacheSize)
        {
            //The following code is the inlined version of this code:
            //        for (int i = 1; i < CacheSize; i++)
            //        {
            //            Approximation[i] = interpolateLinear(i * mStepSize);
            //            t = (Approximation[i] - Approximation[i - 1]);
            //            Length += t.magnitude;
            //            ApproximationDistances[i] = Length;
            //            ApproximationT[i - 1] = t.normalized;
            //        }

            float mStepSize = 1f / newCacheSize;

            float lengthAccumulator = 0;
            Vector3 pStart = threadSafeLocalPosition;
            Vector3 pEnd = nextControlPoint.threadSafeLocalPosition;
            Vector3 tangent;
            for (int i = 1; i < newCacheSize; i++)
            {
                float localF = i * mStepSize;
                Approximation[i] = OptimizedOperators.LerpUnclamped(pStart, pEnd, localF);

                tangent.x = (Approximation[i].x - Approximation[i - 1].x);
                tangent.y = (Approximation[i].y - Approximation[i - 1].y);
                tangent.z = (Approximation[i].z - Approximation[i - 1].z);

                float tMagnitude = Mathf.Sqrt((float)(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z));
                lengthAccumulator += tMagnitude;
                ApproximationDistances[i] = lengthAccumulator;
                if ((double)tMagnitude > 9.99999974737875E-06)
                {
                    float oneOnMagnitude = 1 / tMagnitude;
                    ApproximationT[i - 1].x = tangent.x * oneOnMagnitude;
                    ApproximationT[i - 1].y = tangent.y * oneOnMagnitude;
                    ApproximationT[i - 1].z = tangent.z * oneOnMagnitude;
                }
                else
                {
                    ApproximationT[i - 1].x = 0;
                    ApproximationT[i - 1].y = 0;
                    ApproximationT[i - 1].z = 0;
                }
            }
            return lengthAccumulator;
        }

        #endregion

        internal void refreshOrientationNoneINTERNAL()
        {
            Array.Clear(ApproximationUp, 0, ApproximationUp.Length);
            lastProcessedLocalRotation = threadSafeLocalRotation;
        }

        internal void refreshOrientationStaticINTERNAL()
        {
            Vector3 firstUp = ApproximationUp[0] = getOrthoUp0INTERNAL();
            if (Approximation.Length > 1)
            {
                int cachedCachesize = CacheSize;
                Vector3 lastUp = ApproximationUp[cachedCachesize] = getOrthoUp1INTERNAL();
                float oneOnCachSize = 1f / cachedCachesize;
                for (int i = 1; i < cachedCachesize; i++)
                    ApproximationUp[i] = Vector3.SlerpUnclamped(firstUp, lastUp, i * oneOnCachSize);
            }

            lastProcessedLocalRotation = threadSafeLocalRotation;
        }

        /// <summary>
        /// Set each point's up as the initialUp rotated by the same rotation than the one that rotates initial tangent to the point's tangent
        /// </summary>
        /// <remarks>Does not handle swirl</remarks>
        /// <param name="initialUp"></param>
        internal void refreshOrientationDynamicINTERNAL(Vector3 initialUp)
        {
            int upsLength = ApproximationUp.Length;
            ApproximationUp[0] = initialUp;
            for (int i = 1; i < upsLength; i++)
            {
                //Inlined version of ups[i] = DTMath.ParallelTransportFrame(ups[i-1], tangents[i - 1], tangents[i]) and with less checks for performance reasons
                Vector3 tan0 = ApproximationT[i - 1];
                Vector3 tan1 = ApproximationT[i];
                //Inlined version of Vector3 A = Vector3.Cross(tan0, tan1);
                Vector3 A;
                {
                    A.x = tan0.y * tan1.z - tan0.z * tan1.y;
                    A.y = tan0.z * tan1.x - tan0.x * tan1.z;
                    A.z = tan0.x * tan1.y - tan0.y * tan1.x;
                }
                //Inlined version of float a = (float)Math.Atan2(A.magnitude, Vector3.Dot(tan0, tan1));
                float a = (float)Math.Atan2(
                    Math.Sqrt(A.x * A.x + A.y * A.y + A.z * A.z),
                    tan0.x * tan1.x + tan0.y * tan1.y + tan0.z * tan1.z);
                ApproximationUp[i] = Quaternion.AngleAxis(Mathf.Rad2Deg * a, A) * ApproximationUp[i - 1];
            }

            lastProcessedLocalRotation = threadSafeLocalRotation;
        }

        #endregion

        internal void ClearBoundsINTERNAL()
        {
            mBounds = null;
        }

        /// <summary>
        /// Gets Transform.up orthogonal to ApproximationT[0]
        /// </summary>
        internal Vector3 getOrthoUp0INTERNAL()
        {
            Vector3 u = threadSafeLocalRotation * Vector3.up;
            Vector3.OrthoNormalize(ref ApproximationT[0], ref u);
            return u;
        }

        private Vector3 getOrthoUp1INTERNAL()
        {
            CurvySplineSegment nextControlPoint = Spline.GetNextControlPoint(this);
            Quaternion nextRotation = nextControlPoint
                ? nextControlPoint.threadSafeLocalRotation
                : threadSafeLocalRotation;
            Vector3 u = nextRotation * Vector3.up;
            Vector3.OrthoNormalize(ref ApproximationT[CacheSize], ref u);
            return u;
        }

        internal void UnsetFollowUpWithoutDirtyingINTERNAL()
        {
            m_FollowUp = null;
            m_FollowUpHeading = ConnectionHeadingEnum.Auto;
        }

#if UNITY_EDITOR

#endif

        #region Gizmo drawing

        private static readonly Plane[] gizomTestCameraPlanes = new Plane[6];
        private static Vector3 gizomTestCamearPosition;
        private static Vector3 gizomTestCameraForward;
        private static float gizomTestFov;
        private static float gizomTestPixelWidth;
        private static float gizomTestPixelHeight;


        private void doGizmos(bool selected)
        {
            //OPTIM try multithreading some of the loops in this method. All loops have in them operations that unity forbids the usage of outside the main thread (drawline, worldtoscreen, ...). Maybe using Unity's jobs?
            if (CurvyGlobalManager.Gizmos == CurvySplineGizmos.None)
                return;

            Camera currentCamera = Camera.current;
            int cameraPixelWidth = currentCamera.pixelWidth;
            int cameraPixelHeight = currentCamera.pixelHeight;
            Transform cameraTransform = currentCamera.transform;
            Vector3 cameraPosition = cameraTransform.position;
            Vector3 cameraZDirection;
            Vector3 cameraXDirection;
            {
                Quaternion cameraRotation = cameraTransform.rotation;
                Vector3 direction;
                {
                    direction.x = 0;
                    direction.y = 0;
                    direction.z = 1;
                }
                cameraZDirection = cameraRotation * direction;

                {
                    direction.x = 1;
                    direction.y = 0;
                    direction.z = 0;
                }
                cameraXDirection = cameraRotation * direction;
            }
            Bounds bounds = Bounds;


            //Update gizomTestCameraPlanes if camera changed
            if (gizomTestCamearPosition != cameraPosition ||
                gizomTestCameraForward != cameraZDirection ||
                gizomTestPixelWidth != cameraPixelWidth ||
                gizomTestPixelHeight != cameraPixelHeight ||
                gizomTestFov != currentCamera.fieldOfView)
            {
                //Design Reading and writing static fields can be dangerous if this code is multi-threaded
                gizomTestCamearPosition = cameraPosition;
                gizomTestCameraForward = cameraZDirection;
                gizomTestPixelWidth = cameraPixelWidth;
                gizomTestPixelHeight = cameraPixelHeight;
                gizomTestFov = currentCamera.fieldOfView;
                GeometryUtility.CalculateFrustumPlanes(currentCamera, gizomTestCameraPlanes);
            }

            // Skip if the segment isn't in view
            if (!GeometryUtility.TestPlanesAABB(gizomTestCameraPlanes, bounds))
                return;

            CurvySpline spline = Spline;
            Transform splineTransform = spline.transform;
            Vector3 splineTransformLocalScale = splineTransform.localScale;
            Vector3 scale;
            {
                scale.x = 1 / splineTransformLocalScale.x;
                scale.y = 1 / splineTransformLocalScale.y;
                scale.z = 1 / splineTransformLocalScale.z;
            }
            Color splineGizmoColor = (selected) ? spline.GizmoSelectionColor : spline.GizmoColor;
            Vector3 transformPosition = transform.position;
            float cameraCenterWidth = cameraPixelWidth * 0.5f;
            float cameraCenterHeight = cameraPixelHeight * 0.5f;

            bool viewCurve = CurvyGlobalManager.ShowCurveGizmo;

            // Control Point
            if (viewCurve)
            {
                Gizmos.color = splineGizmoColor;
                float handleSize = DTUtility.GetHandleSize(transformPosition, currentCamera, cameraCenterWidth, cameraCenterHeight, cameraPosition, cameraZDirection, cameraXDirection);
                float cpGizmoSize = handleSize * (selected ? 1 : 0.7f) * CurvyGlobalManager.GizmoControlPointSize;

                if (spline.RestrictTo2D)
                    Gizmos.DrawCube(transformPosition, OptimizedOperators.Multiply(Vector3.one, cpGizmoSize));
                else
                    Gizmos.DrawSphere(transformPosition, cpGizmoSize);
            }

            //Remaining
            if (spline.IsControlPointASegment(this))
            {
                if (spline.Dirty)
                    spline.Refresh();

                Matrix4x4 initialGizmoMatrix = Gizmos.matrix;
                Matrix4x4 currentGizmoMatrix = Gizmos.matrix = splineTransform.localToWorldMatrix;

                //Spline lines
                if (viewCurve)
                {
                    float steps;
                    {
                        float camDistance = (cameraPosition.Subtraction(bounds.ClosestPoint(cameraPosition))).magnitude;

                        float df = Mathf.Clamp(camDistance, 1, 3000) / 3000;
                        df = (df < 0.01f) ? DTTween.SineOut(df, 0, 1) : DTTween.QuintOut(df, 0, 1);

                        steps = Mathf.Clamp((Length * CurvyGlobalManager.SceneViewResolution * 0.1f) / df, 1, 10000);
                    }
                    DrawGizmoLines(1 / steps);
                }

                //Approximations
                if (Approximation.Length > 0 && CurvyGlobalManager.ShowApproximationGizmo)
                {
                    Gizmos.color = spline.GizmoColor.Multiply(0.8f);
                    Vector3 size = OptimizedOperators.Multiply(0.1f, scale);
                    for (int i = 0; i < Approximation.Length; i++)
                    {
                        float handleSize = DTUtility.GetHandleSize(currentGizmoMatrix.MultiplyPoint3x4(Approximation[i]), currentCamera, cameraCenterWidth, cameraCenterHeight, cameraPosition, cameraZDirection, cameraXDirection);

                        Gizmos.DrawCube(Approximation[i], handleSize.Multiply(size));
                    }
                }

                //Orientation
                if (spline.Orientation != CurvyOrientation.None && ApproximationUp.Length > 0 && CurvyGlobalManager.ShowOrientationGizmo)
                {
                    Gizmos.color = CurvyGlobalManager.GizmoOrientationColor;
                    Vector3 orientationGizmoSize = scale.Multiply(CurvyGlobalManager.GizmoOrientationLength);

                    for (int i = 0; i < ApproximationUp.Length; i++)
                    {
                        Vector3 lineEnd;
                        lineEnd.x = Approximation[i].x + ApproximationUp[i].x * orientationGizmoSize.x;
                        lineEnd.y = Approximation[i].y + ApproximationUp[i].y * orientationGizmoSize.y;
                        lineEnd.z = Approximation[i].z + ApproximationUp[i].z * orientationGizmoSize.z;

                        Gizmos.DrawLine(Approximation[i], lineEnd);
                    }


                    if (spline.IsControlPointAnOrientationAnchor(this) && spline.Orientation == CurvyOrientation.Dynamic)
                    {
                        if (ApproximationUp.Length != 0)
                        {
                            Gizmos.color = CurvyGlobalManager.GizmoOrientationColor;
                            Vector3 u = ApproximationUp[0];
                            u.Set(u.x * scale.x, u.y * scale.y, u.z * scale.z);
                            Gizmos.DrawRay(Approximation[0],
                                CurvyGlobalManager.GizmoOrientationLength * 1.75f * u);
                        }
                    }
                }

                //Tangent
                if (ApproximationT.Length > 0 && CurvyGlobalManager.ShowTangentsGizmo)
                {
                    int segmentCacheSize = CacheSize;
                    float tangentSize = CurvyGlobalManager.GizmoOrientationLength;
                    for (int i = 0; i < ApproximationT.Length; i++)
                    {
                        //updating gizmo color
                        if (i == 0)
                            Gizmos.color = Color.blue;
                        else if (i == 1)
                            Gizmos.color = GizmoTangentColor;
                        else if (i == segmentCacheSize)
                            Gizmos.color = Color.black;

                        Vector3 lineEnd;
                        lineEnd.y = Approximation[i].y + ApproximationT[i].y * tangentSize;
                        lineEnd.z = Approximation[i].z + ApproximationT[i].z * tangentSize;
                        lineEnd.x = Approximation[i].x + ApproximationT[i].x * tangentSize;

                        Gizmos.DrawLine(Approximation[i], lineEnd);
                    }
                }
                Gizmos.matrix = initialGizmoMatrix;
            }

        }

        /// <summary>
        /// Draw gizmo lines representing the spline segment
        /// </summary>
        /// <param name="stepSize">The relative distance between the start and end of each line. Must be exclusively between 0 and 1</param>
        private void DrawGizmoLines(float stepSize)
        {
            CurvySpline spline = Spline;
            CurvyInterpolation splineInterpolation = spline.Interpolation;

#if CURVY_SANITY_CHECKS
            if (spline.Dirty)
                DTLog.LogWarning("Interpolate should not be called on segment of a dirty spline. Call CurvySpline.Refresh first", this);
            Assert.IsTrue(spline.IsControlPointASegment(this));
            Assert.IsTrue(spline.IsCpsRelationshipCacheValidINTERNAL);
            Assert.IsTrue(stepSize > 0);
            Assert.IsTrue(stepSize <= 1);
#endif
            if (splineInterpolation == CurvyInterpolation.Linear)
                Gizmos.DrawLine(Interpolate(0), Interpolate(1));
            else
            {
                Vector3 startPoint;
                if (splineInterpolation == CurvyInterpolation.BSpline)
                    startPoint = BSpline(spline.ControlPointsList, spline.SegmentToTF(this), spline.IsBSplineClamped, spline.Closed, spline.BSplineDegree, BSplineP0Array.Array);
                else
                    startPoint = threadSafeLocalPosition;

                //used only in BSplines for performance reasons
                bool isBSplineClamped = default;
                int bSplineDegree = default;
                ReadOnlyCollection<CurvySplineSegment> controlPoints = default;
                int controlPointsCount = default;
                float segmentTF = default;
                int n = default;
                int nPlus1 = default;
                int previousK = default;
                Vector3[] ps = default;
                int psCount = default;
                Vector3[] psCopy = default;
                SubArray<Vector3> psCopySubArray = default;
                if (splineInterpolation == CurvyInterpolation.BSpline)
                {
                    isBSplineClamped = spline.IsBSplineClamped;
                    bSplineDegree = spline.BSplineDegree;
                    controlPoints = spline.ControlPointsList;
                    segmentTF = spline.SegmentToTF(this);
                    controlPointsCount = controlPoints.Count;
                    n = BSplineHelper.GetBSplineN(controlPointsCount, bSplineDegree, spline.Closed);
                    nPlus1 = n + 1;
                    previousK = int.MinValue;
                    SubArray<Vector3> splinePsVector = BSplineP0Array;
                    ps = splinePsVector.Array;
                    psCount = splinePsVector.Count;
                    psCopySubArray = ArrayPools.Vector3.Allocate(psCount);
                    psCopy = psCopySubArray.Array;
                }

                for (float localF = 0; localF < 1; localF += stepSize)
                {
                    Vector3 interpolatedPoint;
                    {
                        Vector3 result;
                        //Inlined version of Interpolate, stripped from some code for performance reasons
                        //If you modify this, modify also the inlined version of this method in refreshCurveINTERNAL()
                        switch (splineInterpolation)
                        {
                            case CurvyInterpolation.BSpline:
                                {

                                    float tf = segmentTF + localF / spline.Count;
                                    BSplineHelper.GetBSplineUAndK(tf, isBSplineClamped, bSplineDegree, n, out float u, out int k);
                                    if (k != previousK)
                                    {
                                        GetBSplineP0s(controlPoints, controlPointsCount, bSplineDegree, k, ps);
                                        previousK = k;
                                    }
                                    Array.Copy(ps, 0, psCopy, 0, psCount);
                                    result = isBSplineClamped ? BSplineHelper.DeBoorClamped(bSplineDegree, k, u, nPlus1, psCopy) : BSplineHelper.DeBoorUnclamped(bSplineDegree, k, u, psCopy);
                                    break;
                                }
                            case CurvyInterpolation.CatmullRom:
                                {
                                    result = CurvySpline.CatmullRom(threadSafePreviousCpLocalPosition,
                                        threadSafeLocalPosition,
                                        threadSafeNextCpLocalPosition,
                                        cachedNextControlPoint.threadSafeNextCpLocalPosition,
                                        localF);
                                }
                                break;
                            case CurvyInterpolation.Bezier:
                                {
                                    result = CurvySpline.Bezier(threadSafeLocalPosition.Addition(HandleOut),
                                        threadSafeLocalPosition,
                                        threadSafeNextCpLocalPosition,
                                        threadSafeNextCpLocalPosition.Addition(cachedNextControlPoint.HandleIn),
                                        localF);
                                    break;
                                }
                            case CurvyInterpolation.TCB:
                                {
                                    float t0 = StartTension; float t1 = EndTension;
                                    float c0 = StartContinuity; float c1 = EndContinuity;
                                    float b0 = StartBias; float b1 = EndBias;

                                    if (!OverrideGlobalTension)
                                        t0 = t1 = mSpline.Tension;
                                    if (!OverrideGlobalContinuity)
                                        c0 = c1 = mSpline.Continuity;
                                    if (!OverrideGlobalBias)
                                        b0 = b1 = mSpline.Bias;

                                    result = CurvySpline.TCB(threadSafePreviousCpLocalPosition,
                                        threadSafeLocalPosition,
                                        threadSafeNextCpLocalPosition,
                                        cachedNextControlPoint.threadSafeNextCpLocalPosition,
                                        localF, t0, c0, b0, t1, c1, b1);
                                }
                                break;
                            default:
                                DTLog.LogError("[Curvy] Invalid interpolation value " + splineInterpolation, this);
                                result = startPoint;
                                break;
                        }

                        interpolatedPoint = result;
                    }

                    Gizmos.DrawLine(startPoint, interpolatedPoint);
                    startPoint = interpolatedPoint;
                }

                if (interpolation == CurvyInterpolation.BSpline)
                    ArrayPools.Vector3.Free(psCopySubArray);

                Vector3 endPoint;
                if (splineInterpolation == CurvyInterpolation.BSpline)
                    endPoint = BSpline(spline.ControlPointsList, spline.SegmentToTF(this, 1), spline.IsBSplineClamped, spline.Closed, spline.BSplineDegree, BSplineP0Array.Array);
                else
                    endPoint = threadSafeNextCpLocalPosition;
                ;
                Gizmos.DrawLine(startPoint, endPoint);
            }
        }
        #endregion

        /// <summary>
        /// Set the correct values to the thread safe local positions and rotation
        /// When multithreading, you can't access Transform in the not main threads. Here we cache that data so it is available for threads
        /// </summary>
        internal void PrepareThreadCompatibleDataINTERNAL(bool useFollowUp)
        {
            CurvySpline spline = Spline;
            CurvySplineSegment previousCP = spline.GetPreviousControlPoint(this);
            CurvySplineSegment nextCP = spline.GetNextControlPoint(this);

            //TODO: get rid of this the day you will be able to access transforms in threads
            threadSafeLocalPosition = cachedTransform.localPosition;
            threadSafeLocalRotation = cachedTransform.localRotation;

            //This isn't cached for thread compatibility, but for performance
            cachedNextControlPoint = nextCP;

            if (useFollowUp)
            {
                CurvySplineSegment followUpPreviousCP;
                bool hasFollowUp = FollowUp != null;
                if (hasFollowUp && ReferenceEquals(spline.FirstVisibleControlPoint, this))
                    followUpPreviousCP = CurvySpline.GetFollowUpHeadingControlPoint(FollowUp, this.FollowUpHeading);
                else
                    followUpPreviousCP = previousCP;
                CurvySplineSegment followUpNextCP;
                if (hasFollowUp && ReferenceEquals(spline.LastVisibleControlPoint, this))
                    followUpNextCP = CurvySpline.GetFollowUpHeadingControlPoint(FollowUp, this.FollowUpHeading);
                else
                    followUpNextCP = nextCP;

                if (followUpPreviousCP != null)
                {
                    threadSafePreviousCpLocalPosition = ReferenceEquals(followUpPreviousCP.Spline, spline) ?
                        followUpPreviousCP.cachedTransform.localPosition :
                        spline.transform.InverseTransformPoint(followUpPreviousCP.cachedTransform.position);
                }
                else
                    threadSafePreviousCpLocalPosition = threadSafeLocalPosition;

                if (followUpNextCP != null)
                {
                    threadSafeNextCpLocalPosition = ReferenceEquals(followUpNextCP.Spline, spline) ?
                        followUpNextCP.cachedTransform.localPosition :
                        spline.transform.InverseTransformPoint(followUpNextCP.cachedTransform.position);
                }
                else
                    threadSafeNextCpLocalPosition = threadSafeLocalPosition;
            }
            else
            {
                threadSafePreviousCpLocalPosition = ReferenceEquals(previousCP, null) == false ? previousCP.cachedTransform.localPosition :
                    threadSafeLocalPosition;

                threadSafeNextCpLocalPosition = ReferenceEquals(nextCP, null) == false ? nextCP.cachedTransform.localPosition :
                    threadSafeLocalPosition;
            }
        }

        /*! \endcond */
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment_private.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySpline_private.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0f1fc37177eb11444bdb58be9d5bd79e
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using UnityEngine.Serialization;
using FluffyUnderware.DevTools.Extensions;
using System.Reflection;
using JetBrains.Annotations;
#if UNITY_EDITOR
using UnityEditor;
#endif
#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
using UnityEngine.Assertions;


namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Curvy Spline class
    /// </summary>
    public partial class CurvySpline : DTVersionedMonoBehaviour
    {
        #region ### Privates Fields ###

        #region ### Serialized fields ###

        #region --- General ---

        [Section("General", HelpURL = CurvySpline.DOCLINK + "curvyspline_general")]
        [Tooltip("Interpolation Method")]
        [SerializeField, FormerlySerializedAs("Interpolation")]
        private CurvyInterpolation m_Interpolation = CurvyGlobalManager.DefaultInterpolation;

        [Tooltip("Restrict Control Points to a local 2D plane")]
        [SerializeField]
        private bool m_RestrictTo2D;

        [Tooltip("The local 2D plane to restrict the spline's control points to")]
        [SerializeField]
        [FieldCondition(nameof(RestrictTo2D), true)]
        [FieldAction("CBCheck2DPlanar")]
        private CurvyPlane restricted2DPlane = CurvyPlane.XY;

        [SerializeField, FormerlySerializedAs("Closed")]
        private bool m_Closed;

        [FieldCondition(nameof(CanHaveManualEndCp), Action = ActionAttribute.ActionEnum.Enable)]
        [Tooltip("Handle End Control Points automatically?")]
        [SerializeField, FormerlySerializedAs("AutoEndTangents")]
        private bool m_AutoEndTangents = CurvySplineDefaultValues.AutoEndTangents;

        [Tooltip("Orientation Flow")]
        [SerializeField, FormerlySerializedAs("Orientation")]
        private CurvyOrientation m_Orientation = CurvySplineDefaultValues.Orientation;

        #endregion

        #region --- Bezier Options ---

        [Section("Global Bezier Options", HelpURL = CurvySpline.DOCLINK + "curvyspline_bezier")]
        [GroupCondition(nameof(m_Interpolation), CurvyInterpolation.Bezier)]
        [RangeEx(0, 1, "Default Distance %", "Handle length by distance to neighbours")]
        [SerializeField]
        private float m_AutoHandleDistance = CurvySplineDefaultValues.AutoHandleDistance;

        #endregion

        #region --- TCB Options ---

        [Section("Global TCB Options", HelpURL = CurvySpline.DOCLINK + "curvyspline_tcb")]
        [GroupCondition(nameof(m_Interpolation), CurvyInterpolation.TCB)]
        [GroupAction("TCBOptionsGUI", Position = ActionAttribute.ActionPositionEnum.Below)]
        [SerializeField, FormerlySerializedAs("Tension")]
        private float m_Tension;

        [SerializeField, FormerlySerializedAs("Continuity")]
        private float m_Continuity;

        [SerializeField, FormerlySerializedAs("Bias")]
        private float m_Bias;
        #endregion

        #region --- B-Spline Options ---

        [Section("B-Spline Options", HelpURL = CurvySpline.DOCLINK + "curvyspline_bspline")]
        [GroupCondition(nameof(m_Interpolation), CurvyInterpolation.BSpline)]
        [RangeEx(minBSplineDegree, nameof(MaxBSplineDegree), "Degree", "The degree of the piecewise polynomial functions.\nIs in the range [2; control points count - 1]")]
        [SerializeField]
        private int bSplineDegree = CurvySplineDefaultValues.BSplineDegree;


        [FieldCondition(nameof(CanBeClamped), Action = ActionAttribute.ActionEnum.Enable)]
        [Label("Clamped", "Make the curve pass through the first and last control points by increasing the multiplicity of the first and last knots.\n\nIn technical terms, when this parameter is true, the knot vector is [0, 0, ...,0, 1, 2, ..., N-1, N, N, ..., N]. When false, it is [0, 1, 2, ..., N-1, N]")]
        [SerializeField]
        private bool isBSplineClamped = CurvySplineDefaultValues.IsBSplineClamped;

        #endregion

        #region --- Advanced Settings ---

        [Section("Advanced Settings", HelpURL = CurvySpline.DOCLINK + "curvyspline_advanced")]
        [FieldAction("ShowGizmoGUI", Position = ActionAttribute.ActionPositionEnum.Above)]
        [Label("Color", "Gizmo color")]
        [SerializeField]
        private Color m_GizmoColor = CurvyGlobalManager.DefaultGizmoColor;

        [FieldAction("CheckGizmoColor", Position = ActionAttribute.ActionPositionEnum.Above)]
        [FieldAction("CheckGizmoSelectionColor", Position = ActionAttribute.ActionPositionEnum.Below)]
        [Label("Active Color", "Selected Gizmo color")]
        [SerializeField]
        private Color m_GizmoSelectionColor = CurvyGlobalManager.DefaultGizmoSelectionColor;

        [RangeEx(1, 100)]
        [SerializeField, FormerlySerializedAs("Granularity"), Tooltip("Defines how densely the cached points are. When the value is 100, the number of cached points per world distance unit is equal to the spline's MaxPointsPerUnit")]
        private int m_CacheDensity = CurvySplineDefaultValues.CacheDensity;
        [SerializeField, Tooltip("The maximum number of sampling points per world distance unit. Sampling is used in caching or shape extrusion for example")]
        private float m_MaxPointsPerUnit = CurvySplineDefaultValues.MaxPointsPerUnit;
        [SerializeField, Tooltip("Use a GameObject pool at runtime")]
        private bool m_UsePooling = CurvySplineDefaultValues.UsePooling;
        [SerializeField, Tooltip("Use threading where applicable. Threading is is currently not supported when targetting WebGL and Universal Windows Platform")]
        private bool m_UseThreading;
        [Tooltip("Refresh when Control Point position change?")]
        [SerializeField, FormerlySerializedAs("AutoRefresh")]
        private bool m_CheckTransform = CurvySplineDefaultValues.CheckTransform;
        [SerializeField] private CurvyUpdateMethod m_UpdateIn = CurvySplineDefaultValues.UpdateIn;
        #endregion

        #region --- Events ---

        /*! \cond PRIVATE */

        [Group("Events", Expanded = false, Sort = 1000, HelpURL = DOCLINK + "curvyspline_events")]
        [SortOrder(0)]
        [SerializeField]
        protected CurvySplineEvent m_OnRefresh = new CurvySplineEvent();
        [Group("Events", Sort = 1000)]
        [SortOrder(1)]
        [SerializeField]
        protected CurvySplineEvent m_OnAfterControlPointChanges = new CurvySplineEvent();
        [Group("Events", Sort = 1000)]
        [SortOrder(2)]
        [SerializeField]
        protected CurvyControlPointEvent m_OnBeforeControlPointAdd = new CurvyControlPointEvent();
        [Group("Events", Sort = 1000)]
        [SortOrder(3)]
        [SerializeField]
        protected CurvyControlPointEvent m_OnAfterControlPointAdd = new CurvyControlPointEvent();
        [Group("Events", Sort = 1000)]
        [SortOrder(4)]
        [SerializeField]
        protected CurvyControlPointEvent m_OnBeforeControlPointDelete = new CurvyControlPointEvent();

        /*! \endcond */

        #endregion

        #endregion

        private bool mIsInitialized;

        private bool isStarted;
        private bool sendOnRefreshEventNextUpdate;
        private readonly object controlPointsRelationshipCacheLock = new object();
#if UNITY_EDITOR
        private bool transformChildrenChanged;
        private bool syncHierarchyFromSplineNeeded;
#endif

        //OPTIM Instead of having a segments list, use the controlPointsList, while providing the methods to convert from a segment index to a control point index.
        /// <summary>
        /// Controlpoints that start a valid spline segment
        /// </summary>
        private readonly List<CurvySplineSegment> mSegments = new List<CurvySplineSegment>();
        /// <summary>
        /// Read-only version of <see cref="controlPoints"/>
        /// </summary>
        private ReadOnlyCollection<CurvySplineSegment> readOnlyControlPoints;

        private float length = -1;
        private int mCacheSize = -1;
        private Bounds? mBounds;
        private bool mDirtyCurve;
        private bool mDirtyOrientation;
        private readonly HashSet<CurvySplineSegment> dirtyControlPointsMinimalSet = new HashSet<CurvySplineSegment>();

        private readonly List<CurvySplineSegment> dirtyCpsExtendedList = new List<CurvySplineSegment>();
        //DESIGN I think allControlPointsAreDirty can be removed, and related code can just fill dirtyControlPointsMinimalSet with all control points instead. Check that perfs lose is not significant before doing so.
        private bool allControlPointsAreDirty;
        //TODO mThreadWorker is disposable. CurvySpline should dispose it. See rule CA1001
        //https://docs.microsoft.com/en-us/visualstudio/code-quality/ca1001-types-that-own-disposable-fields-should-be-disposable?view=vs-2019
        private readonly ThreadPoolWorker<CurvySplineSegment> mThreadWorker = new ThreadPoolWorker<CurvySplineSegment>();

        //reusable events
        private readonly CurvySplineEventArgs defaultSplineEventArgs;
        private readonly CurvyControlPointEventArgs defaultAddAfterEventArgs;
        private readonly CurvyControlPointEventArgs defaultDeleteEventArgs;

        /// <summary>
        /// ControlPointsDistances[i] is equal to ControlPoints[i].Distance. ControlPointsDistances exists only to make search time shorter when searching for a Cp based on its Distance
        /// </summary>
        private float[] controlPointsDistances = new float[0];

        private readonly Action<CurvySplineSegment, int, int> refreshCurveAction;

#if CURVY_SANITY_CHECKS
        private int sanityErrorLogsThisFrame;
        private int sanityWaringLogsThisFrame;
#endif

        #region Keeping track of transform's change

        /// <summary>
        /// The global position of the spline the last time it was checked. Checks are done at least once a frame.
        /// </summary>
        private Vector3 lastProcessedPosition;
        /// <summary>
        /// The global rotation of the spline the last time it was checked. Checks are done at least once a frame.
        /// </summary>
        private Quaternion lastProcessedRotation;
        /// <summary>
        /// The global scale of the spline the last time it was checked. Checks are done at least once a frame.
        /// </summary>
        private Vector3 lastProcessedScale;
        /// <summary>
        /// True if the global position, rotation or scale of the spline has changed this frame
        /// </summary>
        private bool globalCoordinatesChangedThisFrame;

        #endregion


        #region ControlPoints relastionship cache

        private bool isCpsRelationshipCacheValid;
        private CurvySplineSegment firstSegment;
        private CurvySplineSegment lastSegment;
        private CurvySplineSegment firstVisibleControlPoint;
        private CurvySplineSegment lastVisibleControlPoint;

        #endregion

        #endregion


        #region ### Unity Callbacks ###
        /*! \cond UNITY */
#if UNITY_EDITOR
        private void OnValidate()
        {
            //Debug.Log("OnValidate " + name);

            Closed = m_Closed;
            Interpolation = m_Interpolation;
            AutoEndTangents = m_AutoEndTangents;
            MaxPointsPerUnit = m_MaxPointsPerUnit;
            BSplineDegree = bSplineDegree;

            InvalidateControlPointsRelationshipCacheINTERNAL();
            SetDirtyAll(SplineDirtyingType.Everything, true);
        }
#endif

        private void Awake()
        {
            cachedTransform = transform;

            //Debug.Log("Awake " + name);

            if (UsePooling)
            {
                //Create the CurvyGlobalManager if not existing already
                _ = CurvyGlobalManager.Instance;
            }
        }

        private void OnEnable()
        {
            cachedTransform = transform;

            SyncSplineFromHierarchy();
#if UNITY_EDITOR
            EditorApplication.update += EditorUpdate;
#endif
            if (isStarted)
            {
                bool processedDirtyCps = Initialize();
                if (processedDirtyCps)
                    OnRefreshEvent(defaultSplineEventArgs);

            }
        }

        /// <summary>
        /// Initialize the spline. This is called automatically by Unity at the first frame.
        /// The only situation I see where you will need to call it manually is if you instantiate a CurvySpline via Unity API, and need to use it the same frame before Unity calls Start() on it the next frame.
        /// </summary>
        public void Start()
        {
            //Debug.Log("Start");
            if (isStarted == false)
            {
                bool processedDirtyCps = Initialize();
                isStarted = true;
                if (processedDirtyCps)
                    OnRefreshEvent(defaultSplineEventArgs);
            }
        }

        private void OnDisable()
        {
            //Debug.Log("OnDisable " + name);
            mIsInitialized = false;
#if UNITY_EDITOR
            EditorApplication.update -= EditorUpdate;
#endif
        }

        private void OnDestroy()
        {
            //BUG? Why do we have that realDestroy boolean? Why not always do the same thing? This might hide something bad
            //When asked about this jake said:
            //That was quite a dirty hack as far as I remember, to counter issues with Unity's serialization
            //TBH I'm not sure if those issues still are present, so you might want to see if it's working without it now.
            //Debug.Log("OnDestroy " + name);
            bool realDestroy = true;
#if UNITY_EDITOR
            if (EditorApplication.isPlayingOrWillChangePlaymode && !EditorApplication.isPlaying)
                realDestroy = false;
#endif
            if (realDestroy)
            {
                if (UsePooling && Application.isPlaying)
                {
                    CurvyGlobalManager curvyGlobalManager = CurvyGlobalManager.Instance;
                    if (curvyGlobalManager != null)
                        for (int i = 0; i < ControlPointCount; i++)
                            curvyGlobalManager.ControlPointPool.Push(ControlPoints[i]);
                }
                else
                    mThreadWorker.Dispose();
            }
            ClearControlPoints();
            isStarted = false;
        }

#if UNITY_EDITOR
        private void OnTransformChildrenChanged()
        {
            transformChildrenChanged = true;
        }
#endif


        virtual protected void Reset()
        {
            //Debug.Log("Reset " + name);

            Interpolation = CurvyGlobalManager.DefaultInterpolation;
            RestrictTo2D = false;
            AutoHandleDistance = 0.39f;
            Closed = false;
            AutoEndTangents = CurvySplineDefaultValues.AutoEndTangents;
            // Orientation
            Orientation = CurvySplineDefaultValues.Orientation;
            // Advanced
            GizmoColor = CurvyGlobalManager.DefaultGizmoColor;
            GizmoSelectionColor = CurvyGlobalManager.DefaultGizmoSelectionColor;
            CacheDensity = CurvySplineDefaultValues.CacheDensity;
            MaxPointsPerUnit = CurvySplineDefaultValues.MaxPointsPerUnit;
            CheckTransform = CurvySplineDefaultValues.CheckTransform;
            // TCB
            Tension = 0;
            Continuity = 0;
            Bias = 0;
            BSplineDegree = CurvySplineDefaultValues.BSplineDegree;
            IsBSplineClamped = CurvySplineDefaultValues.IsBSplineClamped;
            SyncSplineFromHierarchy();
        }

        private void Update()
        {
#if UNITY_EDITOR
            if (syncHierarchyFromSplineNeeded)
            {
                syncHierarchyFromSplineNeeded = false;
                SyncHierarchyFromSpline();
            }
#endif
#if CURVY_SANITY_CHECKS
            if (Application.isPlaying)
            {
                sanityWaringLogsThisFrame = 0;
                sanityErrorLogsThisFrame = 0;
            }
#endif

            if (Application.isPlaying && UpdateIn == CurvyUpdateMethod.Update)
                DoUpdate();
        }

        private void LateUpdate()
        {
            if (Application.isPlaying && UpdateIn == CurvyUpdateMethod.LateUpdate)
                DoUpdate();
        }

        private void FixedUpdate()
        {
            if (Application.isPlaying && UpdateIn == CurvyUpdateMethod.FixedUpdate)
                DoUpdate();
        }
        /*! \endcond */
        #endregion

        #region ### Privates & Internals ###
        /*! \cond PRIVATE */

        private const float MinimalMaxPointsPerUnit = 0.0001f;
        /// <summary>
        /// The maximal size of the cache of a spline's segment
        /// </summary>
        private const float MaxSegmentCacheSize = 1000000;

        private static readonly string InvalidCPErrorMessage = "[Curvy] Method called with a control point '{0}' that is not part of the current spline '{1}'";

#if CURVY_SANITY_CHECKS
        /// <summary>
        /// Returns isCpsRelationshipCacheValid. Getter was created just for the sake of some sanity checks
        /// </summary>
        internal bool IsCpsRelationshipCacheValidINTERNAL
        {
            get { return isCpsRelationshipCacheValid; }
        }
#endif

        //cachedTransform in CurvySplineSegment is subject to an issue in Unity that leads to a bug. Read its comment to understand what it is. The same issue applies to CurvySpline, but does not lead to a known bug. So just as a precaution, I am avoiding the issue here too
#if (UNITY_2019_1_OR_NEWER)
        private Transform cachedTransform;
#else
        private Transform _cachedTransform;
        private Transform cachedTransform
        {
            get
            {
                if (ReferenceEquals(_cachedTransform, null))
                    _cachedTransform = transform;
                return _cachedTransform;
            }
            set
            {
                _cachedTransform = value;
            }
        }
#endif

        /// <summary>
        /// Access the list of Segments
        /// </summary>
        /// <remarks>The returned list should not be modified</remarks>
        private List<CurvySplineSegment> Segments
        {
            get
            {
                if (isCpsRelationshipCacheValid == false)
                    RebuildControlPointsRelationshipCache(true);
                return mSegments;
            }
        }

        private const int minBSplineDegree = 2;//update CurvySplineDefaultValues.BSplineDegree and documentation/tooltip of IsBSplineClamped if you modify this
        private int MaxBSplineDegree => Mathf.Max(minBSplineDegree, ControlPoints.Count - 1);

#if UNITY_EDITOR
        public static int _newSelectionInstanceIDINTERNAL; // Editor Bridge helper to determine new selection after object deletion
#endif

#if CONTRACTS_FULL
        [ContractInvariantMethod]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "Required for code contracts.")]
        private void ObjectInvariant()
        {
            Contract.Invariant(MaxPointsPerUnit.IsANumber());
            Contract.Invariant(MaxPointsPerUnit > 0);

            //TODO CONTRACT reactivate these if you find a way to call GetSegmentIndex and IsSegment without modifying the cache
            //Contract.Invariant(Contract.ForAll(Segments, s => GetSegmentIndex(s) == Segments.IndexOf(s)));
            //Contract.Invariant(Contract.ForAll(Segments, s => IsSegment(s)));

            //TODO CONTRACT more code contracts
            Contract.Invariant(Contract.ForAll(ControlPoints, cp => cp.Spline == this));
        }
#endif

        private bool Initialize()
        {
            SetDirtyAll(SplineDirtyingType.Everything, false);
            bool processedDirtyCps = ProcessDirtyControlPoints();
            UpdatedLastProcessedGlobalCoordinates();
            mIsInitialized = true;
            return processedDirtyCps;
        }

#if CURVY_SANITY_CHECKS

        [System.Diagnostics.Conditional("UNITY_ASSERTIONS")]
        private void DoSanityChecks()
        {
            const int limit = 20;
            if (!IsInitialized)
            {
                if (sanityErrorLogsThisFrame < limit)
                {
                    if (sanityErrorLogsThisFrame == limit - 1)
                        DTLog.LogError("[Curvy] Too many errors to display.", this);
                    else
                        DTLog.LogError("[Curvy] Calling public method on non initialized spline.", this);
                    sanityErrorLogsThisFrame++;
                }
            }
            else if (Dirty)
            {
                if (sanityWaringLogsThisFrame < limit)
                {
                    if (sanityWaringLogsThisFrame == limit - 1)
                        DTLog.LogWarning("[Curvy] Too many warnings to display.", this);
                    else
                        DTLog.LogWarning(string.Format(System.Globalization.CultureInfo.InvariantCulture, "[Curvy] Calling public method on a dirty spline. The returned result will not be up to date. Either refresh the spline manually by calling Refresh(), or wait for it to be refreshed automatically at the next {0} call", UpdateIn.ToString()), this);
                    sanityWaringLogsThisFrame++;
                }
            }
        }
#endif

#if UNITY_EDITOR
        private void EditorUpdate()
        {
#if CURVY_SANITY_CHECKS
            if (Application.isPlaying == false)
            {
                sanityWaringLogsThisFrame = 0;
                sanityErrorLogsThisFrame = 0;
            }
#endif
            if (Application.isPlaying == false && IsInitialized)
            {
                if (syncHierarchyFromSplineNeeded)
                {
                    syncHierarchyFromSplineNeeded = false;
                    SyncHierarchyFromSpline();
                }
                DoUpdate();
            }
        }
#endif


        private void DoUpdate()
        {
#if UNITY_EDITOR
            if (transformChildrenChanged)
            {
                transformChildrenChanged = false;
                if (ControlPoints.Count != GetComponentsInChildren<CurvySplineSegment>().Length)
                {
                    //The SyncSplineFromHierarchy is meant only to handle the case where the user adds or removes a contol point from the editor hierarchy. The addition or removal of a control point through Curvy's API is handled efficiently elsewhere. I said efficiently because, contrary to SyncSplineFromHierarchy, it does not lead to rebuilding the whole spline.
                    //There is in fact another case where the following code would be useful, which is removing a CP's gameobject through Unity's API. In this case, even if UNITY_EDITOR == false, the syncing would be necessary. But, to not impact the performances of the common user case (using Curvy API to modify CPs), I decided to not handle this case. Removing cps, or adding them, via Unity API is not supported.
                    SyncSplineFromHierarchy();
                }
            }
#endif

            int controlPointCount = ControlPointCount;
            for (int index = 0; index < controlPointCount; index++)
            {
                CurvySplineSegment controlPoint = ControlPoints[index];
                if (controlPoint.AutoBakeOrientation && controlPoint.ApproximationUp.Length > 0)
                    controlPoint.BakeOrientationToTransform();
            }

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);

            globalCoordinatesChangedThisFrame = false;
            if (cachedTransform.hasChanged)
            {
                cachedTransform.hasChanged = false;

                //This additional test is done since transform.hasChanged is true even when changing parent with no change in both local and global coordinates. And even a change in local coordinates doesn't interest us, since bounds computation only need global coordinates
                if (cachedTransform.position.NotApproximately(lastProcessedPosition) || cachedTransform.rotation.DifferentOrientation(lastProcessedRotation) || cachedTransform.lossyScale != lastProcessedScale)
                {
                    globalCoordinatesChangedThisFrame = true;
                    UpdatedLastProcessedGlobalCoordinates();

                    mBounds = null;
                    //OPTIM Right now, transform change lead to recomputing the bounds in world space. This can be avoided by computing the bounds in local space only when the spline is modified, and transform that to the world space here, where a spline transform has changed.
                    for (int i = 0; i < controlPointCount; i++)
                        ControlPoints[i].ClearBoundsINTERNAL();
                }

            }

            if ((CheckTransform || !Application.isPlaying) && (allControlPointsAreDirty == false))
                for (int i = 0; i < controlPointCount; i++)
                {
                    CurvySplineSegment currentControlPoint = ControlPoints[i];
                    bool dirtyCurve = currentControlPoint.HasUnprocessedLocalPosition;
                    if (dirtyCurve || currentControlPoint.HasUnprocessedLocalOrientation && currentControlPoint.OrientatinInfluencesSpline)
                        currentControlPoint.Spline.SetDirty(currentControlPoint, dirtyCurve == false ? SplineDirtyingType.OrientationOnly : SplineDirtyingType.Everything);
                }

            if (Dirty)
                Refresh();
            else if (sendOnRefreshEventNextUpdate)
                OnRefreshEvent(defaultSplineEventArgs);

            sendOnRefreshEventNextUpdate = false;

            if (globalCoordinatesChangedThisFrame && OnGlobalCoordinatesChanged != null)
                OnGlobalCoordinatesChanged.Invoke(this);
        }

        /// <summary>
        /// are manual start/end CP's allowed?
        /// </summary>
        private bool CanHaveManualEndCp()
        {
            return !Closed && (Interpolation == CurvyInterpolation.CatmullRom || Interpolation == CurvyInterpolation.TCB);
        }

        private bool CanBeClamped()
        {
            return !Closed && (Interpolation == CurvyInterpolation.BSpline);
        }

#if UNITY_EDITOR


        /// <summary>
        /// Get the correct control point name that should be displayed in the hierarchy
        /// </summary>
        /// <param name="controlPointIndex"></param>
        static private string GetControlPointName(short controlPointIndex)
        {
            if (controlPointIndex < CachedControlPointsNameCount)
                return controlPointNames[controlPointIndex];

            return MakeControlPointName(controlPointIndex);
        }

        private static string[] GetControlPointNames()
        {
            string[] names = new string[CachedControlPointsNameCount];
            for (short i = 0; i < CachedControlPointsNameCount; i++)
                names[i] = MakeControlPointName(i);
            return names;
        }

        static private string MakeControlPointName(short controlPointIndex)
        {
            return "CP" + controlPointIndex.ToString("D4", System.Globalization.CultureInfo.InvariantCulture);
        }
#endif

        /// <summary>
        /// Marks a Control Point to get recalculated on next call to Refresh(). Will also mark connected control points if dirtyConnection is set to true.  Will also mark control points that depend on the current one through the Follow-Up feature.
        /// </summary>
        /// <param name="controlPoint">the Control Point to refresh</param>
        /// <param name="dirtyingType">Defines what aspect should be dirtied</param>
        /// <param name="previousControlPoint"></param>
        /// <param name="nextControlPoint"></param>
        /// <param name="ignoreConnectionOfInputControlPoint">If true, this method will not mark as dirty the control points connected to the "controlPoint" parameter</param>
        private void SetDirty(CurvySplineSegment controlPoint, SplineDirtyingType dirtyingType, CurvySplineSegment previousControlPoint, CurvySplineSegment nextControlPoint, bool ignoreConnectionOfInputControlPoint)
        {
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));

#if CURVY_LOG_DIRTYING
            Debug.Log("Set Dirty CP " + dirtyingType);
#endif
            if (ignoreConnectionOfInputControlPoint == false && controlPoint.Connection)
            {
                //Setting all connected CPs is a bit overkill, but at least, you are sure to avoid the multitude of Connections related bugs, plus simplifies the code a lot. You might try to OPTIM by dirtying only the relevant connected CPs, and only in the relevant scenarios, but (seeing the old code that I removed) it is a very dangerous optimization, and you can surely optimize other stuff that will take less time to optimize, and can generate less bugs
                ReadOnlyCollection<CurvySplineSegment> connectionControlPoints = controlPoint.Connection.ControlPointsList;
                for (int index = 0; index < connectionControlPoints.Count; index++)
                {
                    CurvySplineSegment connectedControlPoint = connectionControlPoints[index];
                    CurvySpline connectedSpline = connectedControlPoint.Spline;
                    if (connectedSpline)
                    {
                        connectedSpline.dirtyControlPointsMinimalSet.Add(connectedControlPoint);
                        connectedSpline.SetDirtyingFlags(dirtyingType);
                    }
                }
#if CURVY_SANITY_CHECKS
                if (connectionControlPoints.Contains(controlPoint) == false)
                    DTLog.LogError("[Curvy] SetDirty couldn't find the dirtying control point in the connection.", this);
#endif
            }
            else
            {
                dirtyControlPointsMinimalSet.Add(controlPoint);
                SetDirtyingFlags(dirtyingType);
            }

            //Dirty CPs that could depend on the current CP through the Follow-Up feature
            {
                if (previousControlPoint && previousControlPoint.Connection)
                {
                    ReadOnlyCollection<CurvySplineSegment> connectionControlPoints = previousControlPoint.Connection.ControlPointsList;
                    for (int index = 0; index < connectionControlPoints.Count; index++)
                    {
                        CurvySplineSegment connectedControlPoint = connectionControlPoints[index];
                        CurvySpline connectedSpline = connectedControlPoint.Spline;
                        if (connectedSpline && connectedControlPoint.FollowUp == previousControlPoint)
                        {
                            connectedSpline.dirtyControlPointsMinimalSet.Add(connectedControlPoint);
                            connectedSpline.SetDirtyingFlags(dirtyingType);
                        }
                    }
                }

                if (nextControlPoint && nextControlPoint.Connection)
                {
                    ReadOnlyCollection<CurvySplineSegment> connectionControlPoints = nextControlPoint.Connection.ControlPointsList;
                    for (int index = 0; index < connectionControlPoints.Count; index++)
                    {
                        CurvySplineSegment connectedControlPoint = connectionControlPoints[index];
                        CurvySpline connectedSpline = connectedControlPoint.Spline;
                        if (connectedSpline && connectedControlPoint.FollowUp == nextControlPoint)
                        {
                            connectedSpline.dirtyControlPointsMinimalSet.Add(connectedControlPoint);
                            connectedSpline.SetDirtyingFlags(dirtyingType);
                        }
                    }
                }
            }
        }

        private void SetDirtyingFlags(SplineDirtyingType dirtyingType)
        {
            mDirtyCurve = mDirtyCurve || dirtyingType == SplineDirtyingType.Everything;
            mDirtyOrientation = true;

            if (mDirtyCurve)
            {
                mCacheSize = -1;
                length = -1;
                mBounds = null;
            }
        }

        private void ReverseControlPoints()
        {
            ControlPoints.Reverse();
            InvalidateControlPointsRelationshipCacheINTERNAL();
            SetDirtyAll(SplineDirtyingType.Everything, true);
        }

        static private short GetNextControlPointIndex(short controlPointIndex, bool isSplineClosed, int controlPointsCount)
        {
            if (isSplineClosed && controlPointsCount <= 1)
                return -1;
            if (controlPointIndex + 1 < controlPointsCount)
                return (short)(controlPointIndex + 1);
            return (short)(isSplineClosed ? 0 : -1);
        }

        static private short GetPreviousControlPointIndex(short controlPointIndex, bool isSplineClosed, int controlPointsCount)
        {
            if (isSplineClosed && controlPointsCount <= 1)
                return -1;
            if (controlPointIndex - 1 >= 0)
                return (short)(controlPointIndex - 1);
            return (short)(isSplineClosed ? controlPointsCount - 1 : -1);
        }

        //OPTIM should you use this instead of the isSegment poperties in ControlPointExtrinsicProperties?
        private static bool IsControlPointASegment(int controlPointIndex, int controlPointCount, bool isClosed, bool notAutoEndTangentsAndIsCatmullRomOrTCB, bool isBSpline, int bSplineDegree)
        {
#if CONTRACTS_FULL
            Contract.Requires(controlPointIndex >= 0 && controlPointIndex < ControlPointCount);
            Contract.Requires(bSplineDegree >= 0);
#endif

            return (isBSpline == false || bSplineDegree < controlPointCount)
                   &&
                   (isClosed && controlPointCount > 1
                     || (notAutoEndTangentsAndIsCatmullRomOrTCB
                         ? controlPointIndex > 0 && controlPointIndex < controlPointCount - 2
                         : controlPointIndex < controlPointCount - 1));
        }

        #region Modifying control points list
        private void AddControlPoint(CurvySplineSegment item)
        {
            ControlPoints.Add(item);
            item.LinkToSpline(this);
            InvalidateControlPointsRelationshipCacheINTERNAL();
            short previousControlPointIndex = GetPreviousControlPointIndex((short)(ControlPoints.Count - 1), Closed, ControlPoints.Count);
            short nextControlPointIndex = GetNextControlPointIndex((short)(ControlPoints.Count - 1), Closed, ControlPoints.Count);
            SetDirty(item, SplineDirtyingType.Everything,
                previousControlPointIndex != -1 ? ControlPoints[previousControlPointIndex] : null,
                nextControlPointIndex != -1 ? ControlPoints[nextControlPointIndex] : null, false);
        }

        /// <summary>
        /// Adds a control point at a specific index
        /// </summary>
        /// <param name="index"></param>
        /// <param name="item"></param>
        private void InsertControlPoint(int index, CurvySplineSegment item)
        {
            ControlPoints.Insert(index, item);
            item.LinkToSpline(this);
            InvalidateControlPointsRelationshipCacheINTERNAL();
            //Dirtying
            {
                short previousControlPointIndex = GetPreviousControlPointIndex((short)index, Closed, ControlPoints.Count);
                short nextControlPointIndex = GetNextControlPointIndex((short)index, Closed, ControlPoints.Count);
                SetDirty(item, SplineDirtyingType.Everything,
                    previousControlPointIndex == -1 ? null : ControlPoints[previousControlPointIndex],
                    nextControlPointIndex == -1 ? null : ControlPoints[nextControlPointIndex], false);
            }
        }

        private void RemoveControlPoint(CurvySplineSegment item)
        {
            int indexOftItem = GetControlPointIndex(item);
            //Dirtying
            if (ControlPoints.Count == 1)//Removing the last CP
                SetDirtyAll(SplineDirtyingType.Everything, true);
            else
            {
                short previousControlPointIndex = GetPreviousControlPointIndex((short)indexOftItem, Closed, ControlPoints.Count);
                short nextControlPointIndex = GetNextControlPointIndex((short)indexOftItem, Closed, ControlPoints.Count);
                if (previousControlPointIndex != -1)
                    SetDirty(ControlPoints[previousControlPointIndex], SplineDirtyingType.Everything);
                if (nextControlPointIndex != -1)
                    SetDirty(ControlPoints[nextControlPointIndex], SplineDirtyingType.Everything);
            }
            ControlPoints.RemoveAt(indexOftItem);
            dirtyControlPointsMinimalSet.Remove(item);
            if (item.Spline == this)
                item.UnlinkFromSpline();
            InvalidateControlPointsRelationshipCacheINTERNAL();
        }

        private void ClearControlPoints()
        {
            SetDirtyAll(SplineDirtyingType.Everything, true);
            for (int index = 0; index < ControlPoints.Count; index++)
            {
                CurvySplineSegment controlPoint = ControlPoints[index];
                if (controlPoint && //controlPoint can be null if you create a spline via the pen tool, and then undo it
                    controlPoint.Spline == this) //This if is to avoid the case where the code, executed because of a change in the number of children, will unlink a CP that has been moved to another spline through the hierarchy editor.
                    controlPoint.UnlinkFromSpline();
            }
            ControlPoints.Clear();
            dirtyControlPointsMinimalSet.Clear();
            InvalidateControlPointsRelationshipCacheINTERNAL();
        }
        #endregion

        #region ControlPoints relastionship cache

        internal void InvalidateControlPointsRelationshipCacheINTERNAL()
        {
            if (isCpsRelationshipCacheValid)
            {
                lock (controlPointsRelationshipCacheLock)
                {
                    isCpsRelationshipCacheValid = false;
                    firstSegment = lastSegment = firstVisibleControlPoint = lastVisibleControlPoint = null;
                }
            }
        }

        /// <summary>
        /// Is not thread safe
        /// </summary>
        /// <param name="fixNonCoherentControlPoints">If true, control points with properties that are no more coherent with their position in the spline will get modified</param>
        /// <remarks>Is not thread safe</remarks>
        private void RebuildControlPointsRelationshipCache(bool fixNonCoherentControlPoints)
        {
            lock (controlPointsRelationshipCacheLock)
            {
                if (isCpsRelationshipCacheValid)
                    return;

                //force clamping of B-spline's degree, in case control points got removed
                BSplineDegree = bSplineDegree;

                //TODO Try to do elsewhere the work done here when fixNonCoherentControlPoints, so it is always true, and not only true when Relationship cache is build
                int controlPointsCount = ControlPoints.Count;
                mSegments.Clear();
                mSegments.Capacity = controlPointsCount;
                if (controlPointsCount > 0)
                {
                    CurvySplineSegment firsAssignedSegment = null;
                    bool firstSegmentFound = false;
                    CurvySplineSegment lastAssignedSegment = null;

                    CurvySplineSegment.ControlPointExtrinsicProperties previousCpInfo = new CurvySplineSegment.ControlPointExtrinsicProperties(false, -1, -1, -1, -1, -1, false, false, false, -1);

                    bool isSplineClosed = Closed;
                    bool isCatmullRomOrTcb = (Interpolation == CurvyInterpolation.CatmullRom || Interpolation == CurvyInterpolation.TCB);
                    bool notAutoEndTangentsAndIsCatmullRomOrTcb = AutoEndTangents == false && isCatmullRomOrTcb;
                    bool isBSpline = Interpolation == CurvyInterpolation.BSpline;


                    float tfInverseDenominator;
                    {
                        if (notAutoEndTangentsAndIsCatmullRomOrTcb)
                            tfInverseDenominator = 1f / (controlPointsCount > 3 ? controlPointsCount - 3 : 1);
                        else if (isSplineClosed)
                            tfInverseDenominator = 1f / controlPointsCount;
                        else
                            tfInverseDenominator = 1f / (controlPointsCount > 1 ? controlPointsCount - 1 : 1);
                    }

                    short segmentIndex = 0;
                    short lastProcessedOrientationAnchorIndex = -1;
                    for (short index = 0; index < controlPointsCount; index++)
                    {
                        CurvySplineSegment controlPoint = ControlPoints[index];

                        short previousControlPointIndex = GetPreviousControlPointIndex(index, isSplineClosed, controlPointsCount);
                        short nextControlPointIndex = GetNextControlPointIndex(index, isSplineClosed, controlPointsCount);

                        bool isSegment = IsControlPointASegment(index, controlPointsCount, isSplineClosed, notAutoEndTangentsAndIsCatmullRomOrTcb, isBSpline, bSplineDegree);
                        bool isVisible = isSegment || previousCpInfo.IsSegment;

                        if (isVisible
                            && (lastProcessedOrientationAnchorIndex == -1//is first segment
                                || controlPoint.SerializedOrientationAnchor// is anchor
                                || !isSegment))// is last visible CP
                            lastProcessedOrientationAnchorIndex = index;

                        bool canHaveFollowUp = isVisible && (nextControlPointIndex == -1 || previousControlPointIndex == -1);

                        float tf;
                        {
                            if (notAutoEndTangentsAndIsCatmullRomOrTcb)
                                tf = tfInverseDenominator
                                     * (index == 0
                                        ? 0
                                        : index == controlPointsCount - 1
                                            ? Math.Max(0, index - 2)
                                            : index - 1);
                            else
                                tf = tfInverseDenominator * index;
                        }

                        previousCpInfo = new CurvySplineSegment.ControlPointExtrinsicProperties(
                            isVisible,
                            tf,
                            isSegment ? segmentIndex : (short)-1,
                            index,
                            previousControlPointIndex,
                            nextControlPointIndex,
                            previousControlPointIndex != -1
                                && IsControlPointASegment(previousControlPointIndex, controlPointsCount, isSplineClosed, notAutoEndTangentsAndIsCatmullRomOrTcb, isBSpline, bSplineDegree),
                            nextControlPointIndex != -1
                                && IsControlPointASegment(nextControlPointIndex, controlPointsCount, isSplineClosed, notAutoEndTangentsAndIsCatmullRomOrTcb, isBSpline, bSplineDegree),
                            canHaveFollowUp,
                            isVisible ? lastProcessedOrientationAnchorIndex : (short)-1);
                        controlPoint.SetExtrinsicPropertiesINTERNAL(previousCpInfo);

                        if (isSegment)
                        {
                            mSegments.Add(controlPoint);
                            segmentIndex++;
                            if (firstSegmentFound == false)
                            {
                                firstSegmentFound = true;
                                firsAssignedSegment = controlPoint;
                            }
                            lastAssignedSegment = controlPoint;
                        }

                        if (fixNonCoherentControlPoints && canHaveFollowUp == false)
                            controlPoint.UnsetFollowUpWithoutDirtyingINTERNAL();
                    }

                    firstSegment = firsAssignedSegment;
                    lastSegment = lastAssignedSegment;
                    firstVisibleControlPoint = firstSegment;
                    lastVisibleControlPoint = ReferenceEquals(lastSegment, null) == false
                        ? ControlPoints[lastSegment.GetExtrinsicPropertiesINTERNAL().NextControlPointIndex]
                        : null;
                }
                else
                {
                    firstSegment = lastSegment = firstVisibleControlPoint = lastVisibleControlPoint = null;
                }

                isCpsRelationshipCacheValid = true;

#if UNITY_EDITOR
                if (fixNonCoherentControlPoints)
                    syncHierarchyFromSplineNeeded = true;
#endif
            }
        }

        #endregion

        private bool ProcessDirtyControlPoints()
        {
            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);

            FillDirtyCpsExtendedList();

            bool thereAreDirtyControlPoints = allControlPointsAreDirty || dirtyCpsExtendedList.Count > 0;

            dirtyControlPointsMinimalSet.Clear();
            allControlPointsAreDirty = false;

            //OPTIM: the current implementation will refresh all dirty CP's orientations, even if one of them needed it, and the others needed only position related refresh. This is because the mDirtyCurve and mDirtyOrientation are spline wide, and not per CP. This can be improved
            //OPTIM: make all the per CP work threadable, and multi thread everything
            if (thereAreDirtyControlPoints)
            {
                if (!(mDirtyOrientation || mDirtyCurve))
                    Debug.LogError("Invalid dirtying flags");

                PrepareThreadCompatibleData();

                int controlPointsCount = ControlPointCount;

                if (mDirtyCurve)
                {
                    #region --- Curve ---

                    // Update Bezier Handles
                    if (Interpolation == CurvyInterpolation.Bezier)
                    {
                        for (int i = 0; i < dirtyCpsExtendedList.Count; i++)
                        {
                            CurvySplineSegment dirtyControlPoint = dirtyCpsExtendedList[i];
                            if (dirtyControlPoint.AutoHandles)
                                dirtyControlPoint.SetBezierHandles(-1f, true, true, true);
                        }
                    }

                    // Iterate through all changed for threadable tasks (cache Approximation, ApproximationT, ApproximationDistance)
                    if (UseThreading)
                        mThreadWorker.ParallelFor(refreshCurveAction, dirtyCpsExtendedList);
                    else
                        for (int i = 0; i < dirtyCpsExtendedList.Count; i++)
                            dirtyCpsExtendedList[i].refreshCurveINTERNAL();

                    // Iterate through all ControlPoints for some basic actions
                    if (controlPointsCount > 0)
                    {

                        List<CurvySplineSegment> segments = Segments;
                        int segmentsCount = segments.Count;

                        Array.Resize(ref controlPointsDistances, controlPointsCount);

                        //// Distances
                        controlPointsDistances[0] = ControlPoints[0].Distance = 0;
                        for (int i = 1; i < controlPointsCount; i++)
                            controlPointsDistances[i] = ControlPoints[i].Distance = ControlPoints[i - 1].Distance + ControlPoints[i - 1].Length;

                        for (int index = 0; index < segmentsCount; index++)
                        {
                            CurvySplineSegment segment = segments[index];
                            CurvySplineSegment nextSegment = GetNextSegment(segment);
                            if (nextSegment)
                                //enforce tangents continuity
                                segment.ApproximationT[segment.CacheSize] = nextSegment.ApproximationT[0];
                            else
                            {
                                //handles tangent of last visible control point
                                GetNextControlPoint(segment).ApproximationT[0] = segment.ApproximationT[segment.CacheSize];
                            }
                        }
                    }

                    #endregion
                }

                if (mDirtyOrientation && Count > 0)
                {
                    #region --- Orientation ---

                    switch (Orientation)
                    {
                        case CurvyOrientation.None:

                            #region --- None ---

                            //No threading here since the operation is too quick to have any benefice in multithreading it
                            for (int i = 0; i < dirtyCpsExtendedList.Count; i++)
                                dirtyCpsExtendedList[i].refreshOrientationNoneINTERNAL();
                            break;

                        #endregion

                        case CurvyOrientation.Static:

                            #region --- Static ---

                            if (UseThreading)
                            {
                                Action<CurvySplineSegment, int, int> action = (controlPoint, cpIndex, cpsCount) => controlPoint.refreshOrientationStaticINTERNAL();
                                mThreadWorker.ParallelFor(action, dirtyCpsExtendedList);
                            }
                            else
                            {
                                for (int i = 0; i < dirtyCpsExtendedList.Count; i++)
                                    dirtyCpsExtendedList[i].refreshOrientationStaticINTERNAL();
                            }

                            break;

                        #endregion

                        case CurvyOrientation.Dynamic:

                            #region --- Dynamic ---

                            // process PTF and smoothing for all anchor groups of dirty CPs
                            int dead = controlPointsCount + 1;
                            do
                            {
                                CurvySplineSegment currentDirtyControlPoint = dirtyCpsExtendedList[0];
                                if (IsControlPointASegment(currentDirtyControlPoint) == false)
                                {
                                    currentDirtyControlPoint.refreshOrientationDynamicINTERNAL(currentDirtyControlPoint.getOrthoUp0INTERNAL());
                                    dirtyCpsExtendedList.RemoveAt(0);
                                }
                                else
                                {
                                    short currentOrientationAnchorIndex = GetControlPointOrientationAnchorIndex(currentDirtyControlPoint);
                                    CurvySplineSegment currentOrientationAnchor = ControlPoints[currentOrientationAnchorIndex];

                                    float swirlPerSegment;
                                    float smoothingAngleStep;
                                    int sampleCount = 0;
                                    short firstCpOutsideAnchorGroupIndex;
                                    {
                                        short anchorGroupCurrentCpIndex = currentOrientationAnchorIndex;
                                        CurvySplineSegment anchorGroupCurrentCp = currentOrientationAnchor;
                                        int anchorgroupSegmentCount = 0;
                                        float anchorgroupLength = 0;
                                        Vector3 nextControlPointInitialUp = currentOrientationAnchor.getOrthoUp0INTERNAL();
                                        do
                                        {
                                            sampleCount += anchorGroupCurrentCp.CacheSize;
                                            anchorgroupSegmentCount++;
                                            anchorgroupLength += anchorGroupCurrentCp.Length;

                                            anchorGroupCurrentCp.refreshOrientationDynamicINTERNAL(nextControlPointInitialUp);
                                            nextControlPointInitialUp = anchorGroupCurrentCp.ApproximationUp[anchorGroupCurrentCp.ApproximationUp.Length - 1];

                                            anchorGroupCurrentCpIndex = GetNextControlPointIndex(anchorGroupCurrentCpIndex, m_Closed, controlPointsCount);
                                            anchorGroupCurrentCp = ControlPoints[anchorGroupCurrentCpIndex];
                                        } while (!IsControlPointAnOrientationAnchor(anchorGroupCurrentCp));
                                        firstCpOutsideAnchorGroupIndex = anchorGroupCurrentCpIndex;
                                        smoothingAngleStep = nextControlPointInitialUp.AngleSigned(anchorGroupCurrentCp.getOrthoUp0INTERNAL(), anchorGroupCurrentCp.ApproximationT[0]) / sampleCount;

                                        // Apply swirl
                                        {
                                            switch (currentOrientationAnchor.Swirl)
                                            {
                                                case CurvyOrientationSwirl.Segment:
                                                    swirlPerSegment = currentOrientationAnchor.SwirlTurns * 360;
                                                    break;
                                                case CurvyOrientationSwirl.AnchorGroup:
                                                    swirlPerSegment = (currentOrientationAnchor.SwirlTurns * 360 / anchorgroupSegmentCount);
                                                    break;
                                                case CurvyOrientationSwirl.AnchorGroupAbs:
                                                    swirlPerSegment = (currentOrientationAnchor.SwirlTurns * 360) / anchorgroupLength;
                                                    break;
                                                case CurvyOrientationSwirl.None:
                                                    swirlPerSegment = 0;
                                                    break;
                                                default:
                                                    swirlPerSegment = 0;
                                                    DTLog.LogError("[Curvy] Invalid Swirl value " + currentOrientationAnchor.Swirl, this);
                                                    break;
                                            }
                                        }
                                    }


                                    {
                                        float angleAccumulator = smoothingAngleStep;
                                        short anchorGroupCurrentCpIndex = currentOrientationAnchorIndex;
                                        bool isSwirlAnchorGroupAbs = currentOrientationAnchor.Swirl == CurvyOrientationSwirl.AnchorGroupAbs;
                                        Vector3 nextControlPointInitialUp = currentOrientationAnchor.ApproximationUp[0];
                                        do
                                        {
                                            CurvySplineSegment anchorGroupCurrentCp = ControlPoints[anchorGroupCurrentCpIndex];
                                            float swirlAngleStep = isSwirlAnchorGroupAbs
                                                ? smoothingAngleStep + swirlPerSegment * anchorGroupCurrentCp.Length / anchorGroupCurrentCp.CacheSize
                                                : smoothingAngleStep + swirlPerSegment / anchorGroupCurrentCp.CacheSize;

                                            //rotate Ups around tangents
                                            Vector3[] tangents = anchorGroupCurrentCp.ApproximationT;
                                            Vector3[] ups = anchorGroupCurrentCp.ApproximationUp;
                                            int upsLength = ups.Length;
                                            ups[0] = nextControlPointInitialUp;

                                            //OPTIM: I thought that the commented version of the code will be faster because of SIMD, but it doesn't seem so. Maybe further work on parallelisation will indded make it faster, but a quick test with Parallel.For didn't show any increase in perfs, but the opposite. Maybe parallelising the ups on a single CP is too little work for multi-threading. Maybe if all the cps' ups were computed in the same loop, multithreading will be worth it.
                                            /*
                                            float angleAccumulatorLoopStart = angleAccumulator;
                                            for (int i = 1; i < upsLength; i++)
                                                ups[i] = Quaternion.AngleAxis(angleAccumulatorLoopStart + (i - 1) * swirlAngleStep, tangents[i]) * ups[i];
                                            angleAccumulator = angleAccumulatorLoopStart + (upsLength - 1) * swirlAngleStep;
                                            */
                                            for (int i = 1; i < upsLength; i++)
                                            {
                                                ups[i] = Quaternion.AngleAxis(angleAccumulator, tangents[i]) * ups[i];
                                                angleAccumulator += swirlAngleStep;
                                            }
                                            nextControlPointInitialUp = ups[upsLength - 1];
                                            dirtyCpsExtendedList.Remove(anchorGroupCurrentCp);

                                            anchorGroupCurrentCpIndex = GetNextControlPointIndex(anchorGroupCurrentCpIndex, m_Closed, controlPointsCount);
                                        } while (anchorGroupCurrentCpIndex != firstCpOutsideAnchorGroupIndex);
                                    }
                                }
                            } while (dirtyCpsExtendedList.Count > 0 && dead-- > 0);
                            if (dead <= 0)
                                DTLog.LogWarning("[Curvy] Deadloop in CurvySpline.Refresh! Please raise a bugreport!", this);
                            break;
                        default:
                            DTLog.LogError("[Curvy] Invalid Orientation value " + Orientation, this);
                            break;
                            #endregion
                    }

                    // Handle very last CP
                    if (!Closed)
                    {
                        CurvySplineSegment beforLastVisibleCp = GetPreviousControlPoint(LastVisibleControlPoint);
                        LastVisibleControlPoint.ApproximationUp[0] = beforLastVisibleCp.ApproximationUp[beforLastVisibleCp.CacheSize];
                    }

                    #endregion
                }
            }

#if CURVY_SANITY_CHECKS
            //These asserts are to make sure that the Refresh code doesn't modify the dirtiness state, which was the case before and could create bugs or unecessary calculations
            Assert.IsTrue(dirtyControlPointsMinimalSet.Count == 0);
            Assert.IsTrue(allControlPointsAreDirty == false);
#endif
            mDirtyCurve = false;
            mDirtyOrientation = false;

            return thereAreDirtyControlPoints;
        }

        /// <summary>
        /// Set the correct values to the thread compatible local positions and rotation
        /// When multithreading, you can't access Transform in the not main threads. Here we cache that data so it is available for threads
        /// </summary>
        private void PrepareThreadCompatibleData()
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(isCpsRelationshipCacheValid);
#endif
            int controlPointsCount = ControlPointCount;
            bool useFollowUp = Interpolation == CurvyInterpolation.CatmullRom || Interpolation == CurvyInterpolation.TCB;

            //prepare the TTransform for all needed control points, which are ....
            // OPTIM: preparing the TTransform of all those CPs is overkill. Restrict the following the prepared CPs to only the CPs being related to the dirtied CPs
            //... all the spline's control points, and ...
            for (int i = 0; i < controlPointsCount; i++)
            {
                CurvySplineSegment controlPoint = ControlPoints[i];
                controlPoint.PrepareThreadCompatibleDataINTERNAL(useFollowUp);
            }
            //... possible other splines' control points because of the followup feature ...
            if (Count > 0)
            {
                CurvySplineSegment beforeFirst = GetPreviousControlPointUsingFollowUp(FirstVisibleControlPoint);
                //before first can be contorlPoints[0] in the case of a spline with AutoEndTangent set to false
                if (ReferenceEquals(beforeFirst, null) == false && beforeFirst.Spline != this)
                    beforeFirst.PrepareThreadCompatibleDataINTERNAL(useFollowUp);
                CurvySplineSegment afterLast = GetNextControlPointUsingFollowUp(LastVisibleControlPoint);
                //afterLast first can be contorlPoints[controlPoints.Count - 1] in the case of a spline with AutoEndTangent set to false
                if (ReferenceEquals(afterLast, null) == false && afterLast.Spline != this)
                    afterLast.PrepareThreadCompatibleDataINTERNAL(useFollowUp);
            }
        }

        /// <summary>
        /// Fills dirtyCpsExtendedList from dirtyControlPointsMinimalSet
        /// </summary>
        private void FillDirtyCpsExtendedList()
        {
            int controlPointsCount = ControlPoints.Count;
            dirtyCpsExtendedList.Clear();
            if (allControlPointsAreDirty)
                for (int i = 0; i < controlPointsCount; i++)
                    dirtyCpsExtendedList.Add(ControlPoints[i]);
            else
            {
                //OPTIM use cps indexes in dirtyControlPointsMinimalSet instead of cps references, will reduce the time passed in getHash and ==

                int minimalDirtyCpsCount = dirtyControlPointsMinimalSet.Count;
                //We expend dirtyControlPointsMinimalSet to include the extended list of dirty control points
                for (int index = 0; index < minimalDirtyCpsCount; index++)
                {
                    //OPTIM ElementAt allocates enumerator, avoid this. Maybe a way to avoid it is to use dirtyControlPointsMinimalSet.Copyto(array) to copy the content of the hashset into an array, and then iterate on that array instead of the hashset. The array needs to be a member of the CurvySpline class, so it is allocated only one
                    CurvySplineSegment dirtyCp = dirtyControlPointsMinimalSet.ElementAt(index);

                    {
                        switch (Interpolation)
                        {
                            case CurvyInterpolation.Linear:
                                {
                                    CurvySplineSegment previousCp = GetPreviousControlPoint(dirtyCp);
                                    if (previousCp)
                                        dirtyControlPointsMinimalSet.Add(previousCp);
                                }
                                break;
                            case CurvyInterpolation.CatmullRom:
                            case CurvyInterpolation.TCB:
                            case CurvyInterpolation.Bezier:
                                {
                                    CurvySplineSegment previousCp = GetPreviousControlPoint(dirtyCp);
                                    if (previousCp)
                                        dirtyControlPointsMinimalSet.Add(previousCp);

                                    //Add other segments to reflect the effect of Bezier handles (and Auto Handles) and Catmull-Rom and TCB's extended influence of CPs.
                                    //OPTIM in the bezier case, always including this extended set of CPs is overkill, but at least it avoids bugs and the complicated dirtying logic associated with the Bezier handles handling code.
                                    if (previousCp)
                                    {
                                        //OPTIM you can get dirtyCp's index, then use GetPreviousControlPointIndex to get previousCp and previousPreviousCp
                                        CurvySplineSegment previousPreviousCp = GetPreviousControlPoint(previousCp);
                                        if (previousPreviousCp)
                                            dirtyControlPointsMinimalSet.Add(previousPreviousCp);
                                    }

                                    CurvySplineSegment nextCp = GetNextControlPoint(dirtyCp);
                                    if (nextCp)
                                        dirtyControlPointsMinimalSet.Add(nextCp);
                                }
                                break;
                            case CurvyInterpolation.BSpline:
                                {
                                    int degree = BSplineDegree;
                                    bool closed = Closed;
                                    bool isClamped = IsBSplineClamped;
                                    int n = BSplineHelper.GetBSplineN(controlPointsCount, degree, closed);
                                    int dirtyCpIndex = GetControlPointIndex(dirtyCp);
                                    for (int testedCpIndex = 0; testedCpIndex < controlPointsCount; testedCpIndex++)
                                    {
                                        CurvySplineSegment testedCP = ControlPoints[testedCpIndex];

                                        int startK;
                                        int endK;

                                        BSplineHelper.GetBSplineUAndK(
                                            SegmentToTF(testedCP), isClamped, degree, n,
                                            out _, out startK);

                                        if (dirtyCpIndex >= startK - degree && dirtyCpIndex <= startK)
                                            dirtyCpsExtendedList.Add(testedCP);
                                        else
                                        {
                                            BSplineHelper.GetBSplineUAndK(
                                                SegmentToTF(testedCP, 1), isClamped, degree, n,
                                                out _, out endK);
                                            if (dirtyCpIndex >= endK - degree && dirtyCpIndex <= endK)
                                                dirtyCpsExtendedList.Add(testedCP);
                                            else if (closed)
                                            {
                                                int loopedCpIndex = dirtyCpIndex + controlPointsCount;
                                                if (loopedCpIndex >= startK - degree && loopedCpIndex <= startK)
                                                    dirtyCpsExtendedList.Add(testedCP);
                                                else
                                                {
                                                    BSplineHelper.GetBSplineUAndK(
                                                        SegmentToTF(testedCP, 1), isClamped, degree, n,
                                                        out _, out endK);
                                                    if (loopedCpIndex >= endK - degree && loopedCpIndex <= endK)
                                                        dirtyCpsExtendedList.Add(testedCP);
                                                }
                                            }
                                        }
                                    }
                                }
                                break;
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                }

#if CURVY_SANITY_CHECKS
                Assert.IsTrue(isCpsRelationshipCacheValid);
#endif
                dirtyCpsExtendedList.AddRange(dirtyControlPointsMinimalSet);
            }
        }

        /// <summary>
        /// Call this to make the spline send an event to notify its listeners of the change in the spline data.
        /// </summary>
        internal void NotifyMetaDataModification()
        {
            //DESIGN until 2.2.3, meta data change triggered OnRefresh event by dirtying its associated control point. I think spline should have different events (or at least a param in the event) to distinguish between the event coming from an actual change in the spline's geometry, and a change in its meta data.
            sendOnRefreshEventNextUpdate = true;
        }

        /// <summary>
        /// Rebuilds the hierarchy from the ControlPoints list
        /// </summary>
        private void SyncHierarchyFromSpline(bool renameControlPoints = true)
        {
#if UNITY_EDITOR
            // rename them and set their order based on ControlPoint list
            int count = ControlPoints.Count;
            for (short i = 0; i < count; i++)
            {
                CurvySplineSegment curvySplineSegment = ControlPoints[i];
                if (curvySplineSegment)
                //curvySplineSegment was null in the following case:
                //In edit mode, using the pen tool, added a new spline with a cp (CTRL + Left click on empty spot), then added a connected spline (CTRL + Right click on empty spot), and then hit ctrl+Z, which undone the creation of the connected spline, and in the next update this code is called with ControlPoints containing destroyed CPs 
                {
                    curvySplineSegment.transform.SetSiblingIndex(i);

                    if (renameControlPoints)
                        curvySplineSegment.name = GetControlPointName(i);
                }
            }
#endif
        }

        private void UpdatedLastProcessedGlobalCoordinates()
        {
            lastProcessedPosition = cachedTransform.position;
            lastProcessedRotation = cachedTransform.rotation;
            lastProcessedScale = cachedTransform.lossyScale;
        }

        /// <summary>
        /// Inserts a Control Point, trigger events and refresh spline
        /// </summary>
        /// <param name="controlPoint">A control point used as a param of the OnBeforeControlPointAddEvent</param>
        /// <param name="position">The position of the control point at its creation</param>
        /// <param name="insertionIndex">Index at which the newly created control point will be inserted in the spline.</param>
        /// <param name="insertionMode">Used as a param of send events</param>
        /// <param name="skipRefreshingAndEvents">If true, the spline's <see cref="Refresh"/> method will not be called, and the relevant events will not be triggered</param>
        /// <param name="space">Whether the positions are in the local or global space</param>
        /// <returns>The created Control Point</returns>
        private CurvySplineSegment InsertAt(CurvySplineSegment controlPoint, Vector3 position, int insertionIndex, CurvyControlPointEventArgs.ModeEnum insertionMode, bool skipRefreshingAndEvents, Space space)
        {
#if CONTRACTS_FULL
            Contract.Requires(controlPoint.Spline == this);
            Contract.Requires(controlPoints.Contains(controlPoint));
#endif

            if (skipRefreshingAndEvents == false)
                OnBeforeControlPointAddEvent(new CurvyControlPointEventArgs(this, this, controlPoint, insertionMode));

            GameObject go;
            CurvySplineSegment insertedControlPoint;

            if (UsePooling && Application.isPlaying)
            {
                CurvyGlobalManager curvyGlobalManager = CurvyGlobalManager.Instance;
                if (curvyGlobalManager != null)
                {
                    insertedControlPoint = curvyGlobalManager.ControlPointPool.Pop<CurvySplineSegment>(cachedTransform);//TODO should this be callse with "null" instead of "transform", to be coherent with the other branches, and knowing that the parent is set to "transform" anyway in subsequent calls?
                    go = insertedControlPoint.gameObject;
                }
                else
                {
                    DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.", this);
                    go = new GameObject("NewCP", typeof(CurvySplineSegment));
                    insertedControlPoint = go.GetComponent<CurvySplineSegment>();
                }
            }
            else
            {
                go = new GameObject("NewCP", typeof(CurvySplineSegment));
                insertedControlPoint = go.GetComponent<CurvySplineSegment>();
            }

            go.layer = gameObject.layer;
            go.transform.SetParent(cachedTransform);

            InsertControlPoint(insertionIndex, insertedControlPoint);
            insertedControlPoint.AutoHandleDistance = AutoHandleDistance;
            if (space == Space.World)
                insertedControlPoint.transform.position = position;
            else
                insertedControlPoint.transform.localPosition = position;
            insertedControlPoint.transform.localRotation = Quaternion.identity;
            insertedControlPoint.transform.localScale = Vector3.one;

            if (skipRefreshingAndEvents == false)
            {
                Refresh();
                OnAfterControlPointAddEvent(new CurvyControlPointEventArgs(this, this, insertedControlPoint, insertionMode));
                OnAfterControlPointChangesEvent(defaultSplineEventArgs);
            }

            return insertedControlPoint;
        }

        #region Events

        private CurvySplineEventArgs OnRefreshEvent(CurvySplineEventArgs e)
        {
            if (OnRefresh != null)
                OnRefresh.Invoke(e);
            return e;
        }

        private CurvyControlPointEventArgs OnBeforeControlPointAddEvent(CurvyControlPointEventArgs e)
        {
            if (OnBeforeControlPointAdd != null)
                OnBeforeControlPointAdd.Invoke(e);
            return e;
        }

        private CurvyControlPointEventArgs OnAfterControlPointAddEvent(CurvyControlPointEventArgs e)
        {
            if (OnAfterControlPointAdd != null)
                OnAfterControlPointAdd.Invoke(e);
            return e;
        }

        private CurvyControlPointEventArgs OnBeforeControlPointDeleteEvent(CurvyControlPointEventArgs e)
        {
            if (OnBeforeControlPointDelete != null)
                OnBeforeControlPointDelete.Invoke(e);
            return e;
        }

        private CurvySplineEventArgs OnAfterControlPointChangesEvent(CurvySplineEventArgs e)
        {
            if (OnAfterControlPointChanges != null)
                OnAfterControlPointChanges.Invoke(e);
            return e;
        }

        #endregion


        /*! \endcond */

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySpline_private.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvyUISpline.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3a6c45371b22846469f6b81fca388a48
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Spline component that fits perfectly to uGUI Canvas
    /// </summary>
    [RequireComponent(typeof(RectTransform))]
    [AddComponentMenu("Curvy/Curvy UI Spline")]
    [HelpURL(CurvySpline.DOCLINK + "curvyuispline")]
    public class CurvyUISpline : CurvySpline
    {
        //DESIGN Isn't there a better way to create UI splines? The current code is set in a way that will not set up the spline properly if you don't go through the CreateUISpline method. This is an issue.
        //Jake explains here that CurvyUISpline just to have a different PPU https://forum.curvyeditor.com/thread-431-post-1672.html#pid1672

        /// <summary>
        /// Creates a GameObject with a CurvyUISpline attached
        /// </summary>
        /// <returns>the component</returns>
        public static CurvyUISpline CreateUISpline(string gameObjectName = "Curvy UI Spline")
        {
            CurvyUISpline spl = new GameObject(gameObjectName, typeof(CurvyUISpline)).GetComponent<CurvyUISpline>();
            spl.SetupUISpline();
            return spl;
        }

        override protected void Reset()
        {
            base.Reset();
            SetupUISpline();
        }

        private void SetupUISpline()
        {
            RestrictTo2D = true;
            MaxPointsPerUnit = 1;
            Orientation = CurvyOrientation.None;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvyUISpline.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Metadata/CurvyInterpolatableMetadataBaseGeneric.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: aae93c9564267e4419881a7c0347a902
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Base class for Metadata classes that support interpolation.
    /// </summary>
    /// <typeparam name="T">The Type of the Metadata's value</typeparam>
    [ExecuteAlways]
    public abstract class CurvyInterpolatableMetadataBase<T> : CurvyMetadataBase
    {
        /// <summary>
        /// The value stored within this Metadata instance
        /// </summary>
        public abstract T MetaDataValue { get; }

        /// <summary>
        /// Interpolates between the current Metadata's value and the one from the next Control Point's Metadata.
        /// </summary>
        /// <param name="nextMetadata">The Metadata from the Control Point next to the current one</param>
        /// <param name="interpolationTime">The local F value on the segment defined by the current Control Point and the next one</param>
        /// <returns></returns>
        public abstract T Interpolate(CurvyInterpolatableMetadataBase<T> nextMetadata, float interpolationTime);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Metadata/CurvyInterpolatableMetadataBaseGeneric.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Metadata/CurvyMetadataBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6b43fe84c1280624d89fe7b112993489
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.DevTools;
using UnityEngine;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Base class for all Metadata classes.
    /// A Metadata is a custom data attached to a Control Point
    /// </summary>
    [RequireComponent(typeof(CurvySplineSegment))]
    [ExecuteAlways]
    public abstract class CurvyMetadataBase : DTVersionedMonoBehaviour
    {
        #region ### Serialized Fields ###
        #endregion

        #region ### Public Properties ###

        public CurvySplineSegment ControlPoint
        {
            get { return mCP; }
        }

        public CurvySpline Spline
        {
            get
            {
                //DESIGN should this throw an exception if mCP is null?
                return (mCP) ? mCP.Spline : null;
            }
        }

        #endregion

        #region ### Private Fields & Properties ###

        private CurvySplineSegment mCP;

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected virtual void Awake()
        {
            mCP = GetComponent<CurvySplineSegment>();
            mCP.RegisterMetaData(this);
        }

        private void OnDestroy()
        {
            mCP.UnregisterMetaData(this);
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public T GetPreviousData<T>(bool autoCreate = true, bool segmentsOnly = true, bool useFollowUp = false) where T : CurvyMetadataBase
        {
            if (ControlPoint)
            {
                CurvySplineSegment controlPoint = ControlPoint;
                CurvySpline spline = Spline;


                CurvySplineSegment previousControlPoint;
                if (!spline || spline.ControlPointsList.Count == 0)
                    previousControlPoint = null;
                else
                {
                    previousControlPoint = useFollowUp
                        ? spline.GetPreviousControlPointUsingFollowUp(controlPoint)
                        : spline.GetPreviousControlPoint(controlPoint);

                    if (segmentsOnly && previousControlPoint && previousControlPoint.Spline.IsControlPointASegment(previousControlPoint) == false)
                        previousControlPoint = null;
                }

                if (previousControlPoint)
                    return previousControlPoint.GetMetadata<T>(autoCreate);
            }
            return default;
        }

        public T GetNextData<T>(bool autoCreate = true, bool segmentsOnly = true, bool useFollowUp = false) where T : CurvyMetadataBase
        {
            if (ControlPoint)
            {
                CurvySplineSegment controlPoint = ControlPoint;
                CurvySpline spline = Spline;

                CurvySplineSegment nextControlPoint;
                if (!spline || spline.ControlPointsList.Count == 0)
                    nextControlPoint = null;
                else
                {
                    nextControlPoint = useFollowUp
                        ? spline.GetNextControlPointUsingFollowUp(controlPoint)
                        : spline.GetNextControlPoint(controlPoint);

                    if (segmentsOnly && nextControlPoint && nextControlPoint.Spline.IsControlPointASegment(nextControlPoint) == false)
                        nextControlPoint = null;
                }

                if (nextControlPoint)
                    return nextControlPoint.GetMetadata<T>(autoCreate);
            }
            return default;
        }

        /// <summary>
        /// Call this to make the owner spline send an event to notify its listeners of the change in the spline data.
        /// </summary>
        protected void NotifyModification()
        {
            CurvySpline spline = Spline;
            if (spline && spline.IsInitialized)
                spline.NotifyMetaDataModification();
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATES */


        /*! \endcond */
        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Metadata/CurvyMetadataBase.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/SplineDirtyingType.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0e4eb203c5d588c48926e1ee743423ab
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Used as a parameter for dirtying methods. Instructs if only the spline's orientation cache should be recomputed, or the whole approximations cache
    /// </summary>
    public enum SplineDirtyingType
    {
        /// <summary>
        /// Orientation approximations cache will be dirtied. Positions approximations cache will be ignored.
        /// </summary>
        OrientationOnly,
        /// <summary>
        /// Orientation approximations cache and positions approximations cache will be dirtied.
        /// </summary>
        Everything
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/SplineDirtyingType.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/SplineEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e5224b0feeae2424abf53d1d1c4eafc6
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;

#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Class used by spline related events
    /// </summary>
    [System.Serializable]
    public class CurvySplineEvent : UnityEventEx<CurvySplineEventArgs> { }

    /// <summary>
    /// Class used by spline related events
    /// </summary>
    [System.Serializable]
    public class CurvyControlPointEvent : UnityEventEx<CurvyControlPointEventArgs> { }

    /// <summary>
    /// EventArgs used by CurvyControlPointEvent events
    /// </summary>
    public class CurvyControlPointEventArgs : CurvySplineEventArgs
    {
        /// <summary>
        /// Event Mode
        /// </summary>
        public enum ModeEnum
        {
            /// <summary>
            /// Send for events that are not related to control points adding or removal
            /// </summary>
            None,
            /// <summary>
            /// Send when a Control point is added before an existing one
            /// </summary>
            AddBefore,
            /// <summary>
            /// Send when a Control point is added after an existing one
            /// </summary>
            AddAfter,
            /// <summary>
            /// Send when a Control point is deleted
            /// </summary>
            Delete
        }

        /// <summary>
        /// Determines the action this event was raised for
        /// </summary>
        public readonly ModeEnum Mode;
        /// <summary>
        /// Related Control Point
        /// </summary>
        public readonly CurvySplineSegment ControlPoint;

        public CurvyControlPointEventArgs(MonoBehaviour sender, CurvySpline spline, CurvySplineSegment cp, ModeEnum mode = ModeEnum.None, object data = null) : base(sender, spline, data)
        {
            ControlPoint = cp;
            Mode = mode;
        }
    }



    /// <summary>
    /// EventArgs used by CurvySplineEvent events
    /// </summary>
    public class CurvySplineEventArgs : CurvyEventArgs
    {
        /// <summary>
        /// The related spline
        /// </summary>
        public readonly CurvySpline Spline;

        public CurvySplineEventArgs(MonoBehaviour sender, CurvySpline spline, object data = null) : base(sender, data)
        {
            Spline = spline;


#if CURVY_SANITY_CHECKS
            Assert.IsTrue(System.Object.ReferenceEquals(Spline,null) == false);
#endif
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/SplineEvents.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Attributes.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 353b27613f9971242bf7f5673b2529a5
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Reflection;
using System;
using System.Collections.Generic;
using FluffyUnderware.DevTools.Extensions;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FluffyUnderware.DevTools
{
    #region ### Interfaces ###
    /// <summary>
    /// Interface for attributes that change group parsing options
    /// </summary>
    public interface IDTGroupParsingAttribute 
    {
        string Path { get; }
    }
    /// <summary>
    /// Interface for attributes that change field parsing options
    /// </summary>
    public interface IDTFieldParsingAttribute { }
    /// <summary>
    /// Interface for attributes that change group rendering options
    /// </summary>
    public interface IDTGroupRenderAttribute { }
    /// <summary>
    /// Interface for attributes that change field rendering options
    /// </summary>
    public interface IDTFieldRenderAttribute { }

    #endregion

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public class DTVersionAttribute : System.Attribute
    {
        public readonly string Version;

        public DTVersionAttribute(string version)
        {
            Version = version;
        }
    }


    #region ### Base Attributes ###
    //OPTIM: all the attributes bellow (and maybe DTVersionAttribute too) seem to be used only in editor code. If so, and there overhead is big, make their compilation conditional to gain performance in the build applications

    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class DTAttribute : System.Attribute, IComparable
    {
        public int TypeSort { get; protected set; }
        public int Sort = 100;
        public bool ShowBelowProperty;
        public int Space;

        public virtual int CompareTo(object obj)
        {
            DTAttribute other = (DTAttribute)obj;
            int v = ShowBelowProperty.CompareTo(other.ShowBelowProperty);
            if (v == 0)
            {
                int ts = TypeSort.CompareTo(other.TypeSort);
                if (ts == 0)
                    return Sort.CompareTo(other.Sort);
                else
                    return ts;
            }
            else
                return v;
        }

        public DTAttribute(int sortOrder, bool showBelow = false)
        {
            TypeSort = sortOrder;
            ShowBelowProperty = showBelow;
        }
    }

    /// <summary>
    /// Explicitely add the next field to a specific group
    /// </summary>
    public class GroupAttribute : DTAttribute, IDTGroupParsingAttribute, IDTGroupRenderAttribute
    {
        public string Path
        {
            get { return mPath; }
            protected set
            {
                PathIsAbsolute = !string.IsNullOrEmpty(value) && value.StartsWith("@");
                if (PathIsAbsolute)
                {
                    mPath = value.Substring(1);
                    if (string.IsNullOrEmpty(mPath))
                        mPath = null;
                }
                else
                    mPath = value;
            }
        }
        public bool PathIsAbsolute { get; private set; }

        public bool Expanded = true;
        public bool Invisible;
        public string Label = null;
        public string Tooltip = null;
        public string HelpURL = null;

        string mPath;

        public GroupAttribute(string pathAndName)
            : base(15)
        {
            Path = pathAndName;
        }
    }

    public class ActionAttribute : DTAttribute
    {
        public enum ActionEnum { Show, Hide, Enable, Disable, ShowInfo, ShowWarning, ShowError, Callback }
        public enum ActionPositionEnum { Above, Below }
        public ActionEnum Action = ActionEnum.Callback;
        public ActionPositionEnum Position = ActionPositionEnum.Below;
        public object ActionData;

        MethodInfo mCallback;

        protected ActionAttribute(string actionData, ActionEnum action = ActionEnum.Callback)
            : base(50)
        {
            ActionData = actionData;
            Action = action;
        }

        public void Callback(object classInstance)
        {
            string methodName = ActionData as string;
            if (!string.IsNullOrEmpty(methodName))
            {
                if (mCallback == null)
                    mCallback = classInstance.GetType().MethodByName(methodName, true, true);

                if (mCallback != null)
                    mCallback.Invoke(classInstance, null);
                else
                    Debug.LogWarningFormat("[DevTools] Unable to find method '{0}' at class '{1}' !", methodName, classInstance.GetType().Name);
            }
        }
    }

    public class ConditionalAttribute : ActionAttribute
    {
        public enum OperatorEnum { AND, OR };
        public class Condition
        {
            public string FieldName;
            public FieldInfo FieldInfo;
            public PropertyInfo PropertyInfo;
            public object CompareTo;
            public bool CompareFalse;
            public OperatorEnum Operator;
            public MethodInfo MethodInfo;
            public string MethodName;
        }

        public Condition[] Conditions;


        protected ConditionalAttribute(string fieldOrProperty, object compareTo, bool compareFalse = false)
            : base(null, ActionEnum.Show)
        {
            TypeSort = 55;
            Conditions = new Condition[1]
            {
                new Condition()
                {
                    FieldName=fieldOrProperty,
                    CompareTo=compareTo,
                    CompareFalse=compareFalse
                }
            };
        }

        protected ConditionalAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op,
                                    string fieldOrProperty2, object compareTo2, bool compareFalse2)
            : base(null, ActionEnum.Show)
        {
            TypeSort = 55;
            Conditions = new Condition[2]
            {
                new Condition()
                {
                    FieldName=fieldOrProperty,
                    CompareTo=compareTo,
                    CompareFalse=compareFalse
                },
                new Condition()
                {
                    FieldName=fieldOrProperty2,
                    CompareTo=compareTo2,
                    CompareFalse=compareFalse2,
                    Operator=op
                }
            };
        }

        protected ConditionalAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op,
                                    string fieldOrProperty2, object compareTo2, bool compareFalse2,
                                    string fieldOrProperty3, object compareTo3, bool compareFalse3)
            : base(null, ActionEnum.Show)
        {
            TypeSort = 55;
            Conditions = new Condition[3]
            {
                new Condition()
                {
                    FieldName=fieldOrProperty,
                    CompareTo=compareTo,
                    CompareFalse=compareFalse
                },
                new Condition()
                {
                    FieldName=fieldOrProperty2,
                    CompareTo=compareTo2,
                    CompareFalse=compareFalse2,
                    Operator=op
                },
                new Condition()
                {
                    FieldName=fieldOrProperty3,
                    CompareTo=compareTo3,
                    CompareFalse=compareFalse3,
                    Operator=op
                }
            };
        }

        protected ConditionalAttribute(string methodToQuery)
            : base(null, ActionEnum.Show)
        {
            TypeSort = 55;
            Conditions = new Condition[1]
            {
                new Condition()
                {
                    MethodName=methodToQuery,
                    CompareTo=null
                }
            };
        }


        public virtual bool ConditionMet(object classInstance)
        {
            bool result = evaluate(Conditions[0], classInstance);

            for (int i = 1; i < Conditions.Length; i++)
            {
                Condition c = Conditions[i];
                switch (c.Operator)
                {
                    case OperatorEnum.AND:
                        result = result && evaluate(c, classInstance);
                        break;
                    case OperatorEnum.OR:
                        result = result || evaluate(c, classInstance);
                        break;
                }
            }
            return result;


        }

        bool evaluate(Condition cond, object classInstance)
        {
            if (!string.IsNullOrEmpty(cond.MethodName))
            {
                if (cond.MethodInfo == null)
                    cond.MethodInfo = classInstance.GetType().MethodByName(cond.MethodName, true, true);
                if (cond.MethodInfo != null)
                {
                    if (cond.CompareFalse)
                        return !(bool)cond.MethodInfo.Invoke(classInstance, null);
                    else
                        return (bool)cond.MethodInfo.Invoke(classInstance, null);
                }
                else
                {
                    Debug.LogWarningFormat("[DevTools] Unable to find method '{0}' at class '{1}' !", cond.MethodName, classInstance.GetType().Name);
                    return cond.CompareFalse;
                }
            }
            else
            {
                if (cond.FieldInfo == null)
                {
                    cond.FieldInfo = classInstance.GetType().FieldByName(cond.FieldName, true, true);
                    if (cond.FieldInfo == null)
                    {
                        cond.PropertyInfo = classInstance.GetType().PropertyByName(cond.FieldName, true, true);
                    }
                }
                object value = null;
                if (cond.FieldInfo != null)
                    value = cond.FieldInfo.GetValue(classInstance);
                else if (cond.PropertyInfo != null)
                    value = cond.PropertyInfo.GetValue(classInstance, null);

                if (value == null)
                {
                    return (cond.CompareTo == null && !cond.CompareFalse);
                }
                else
                    return value.Equals(cond.CompareTo) == !cond.CompareFalse;
            }
        }

    }

    #endregion

    #region ### Attributes handling Nesting/Parsing ###

    public class SortOrderAttribute : DTAttribute, IDTFieldParsingAttribute
    {
        public SortOrderAttribute(int sort = 100) : base(0)
        {
            Sort = sort;
        }
    }

    /// <summary>
    /// Show children inside a section. Start the path with "@" to break out of any previous sections
    /// </summary>
    public class AsGroupAttribute : GroupAttribute, IDTFieldParsingAttribute, IDTFieldRenderAttribute
    {

        public AsGroupAttribute(string pathAndName = null)
            : base(pathAndName)
        {
            TypeSort = 10;
        }
    }

    /// <summary>
    /// Show all subsequent fields inside a section rendered as a tab
    /// </summary>
    public class TabAttribute : GroupAttribute
    {
        public readonly string TabName;
        public readonly string TabBarName;

        public TabAttribute(string pathAndName)
            : base("")
        {
            TypeSort = 10;
            string p;
            split(pathAndName, out p, out TabBarName, out TabName);
            Path = p;
        }

        static bool split(string pathAndName, out string path, out string tabBar, out string tabname)
        {
            string[] p = pathAndName.Split('/');
            path = string.Empty;
            tabBar = string.Empty;
            tabname = pathAndName;
            if (p.Length == 0)
                return false;
            else if (p.Length == 1)
            {
                tabname = p[0];
                tabBar = "Default";
                return true;
            }
            else
            {
                tabname = p[p.Length - 1];
                tabBar = p[p.Length - 2];
                path = string.Join("/", p, 0, p.Length - 2);
                return true;
            }

        }
    }

    /// <summary>
    /// Show all subsequent fields inside a section.
    /// </summary>
    public class SectionAttribute : GroupAttribute
    {
        public bool Fixed;

        public SectionAttribute(string name, bool expanded = true, bool fix = false, int sort = 100)
            : base(name)
        {
            Expanded = expanded;
            TypeSort = 10;
            Sort = sort;
            Fixed = fix;
        }
    }

    /// <summary>
    /// Ends any section
    /// </summary>
    public class NoSectionAttribute : SectionAttribute
    {
        public NoSectionAttribute() : base("")
        {
            TypeSort = 10;
        }
    }



    /// <summary>
    /// Hides Field and doesn't enter children
    /// </summary>
    public class Hide : DTAttribute, IDTFieldParsingAttribute, IDTFieldRenderAttribute
    {
        public Hide() : base(20) { }
    }

    /// <summary>
    /// Hides Field, but enter children
    /// </summary>
    public class Inline : DTAttribute, IDTFieldParsingAttribute, IDTFieldRenderAttribute
    {
        public Inline() : base(21) { }
    }





    #endregion

    #region ### Attributes handling visual representation ###

    public class ArrayExAttribute : DTAttribute, IDTFieldParsingAttribute
    {
        public bool Draggable = true;
        public bool ShowHeader = true;
        public bool ShowAdd = true;
        public bool ShowDelete = true;
        public bool DropTarget = true;

        public ArrayExAttribute()
            : base(35)
        {
        }
    }

    #endregion

    #region ### Attributes handling actions and dynamic evaluation ###



    public class FieldActionAttribute : ActionAttribute, IDTFieldRenderAttribute
    {
        public FieldActionAttribute(string actionData, ActionEnum action = ActionEnum.Callback)
            : base(actionData, action) { }

    }

    public class GroupActionAttribute : ActionAttribute, IDTGroupRenderAttribute
    {
        public GroupActionAttribute(string actionData, ActionEnum action = ActionEnum.Callback)
            : base(actionData, action) { }
    }



    public class FieldConditionAttribute : ConditionalAttribute, IDTFieldRenderAttribute
    {
        public FieldConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse = false, ActionEnum action = ActionEnum.Show, object actionData = null, ActionPositionEnum position = ActionPositionEnum.Below)
            : base(fieldOrProperty, compareTo, compareFalse)
        {
            Action = action;
            ActionData = actionData;
            Position = position;
        }


        public FieldConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op,
                                    string fieldOrProperty2, object compareTo2, bool compareFalse2)
            : base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2) { }


        public FieldConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op,
                                    string fieldOrProperty2, object compareTo2, bool compareFalse2,
                                    string fieldOrProperty3, object compareTo3, bool compareFalse3)
            : base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2, fieldOrProperty3, compareTo3, compareFalse3) { }

        public FieldConditionAttribute(string methodToQuery)
            : base(methodToQuery) { }

    }
    public class GroupConditionAttribute : ConditionalAttribute, IDTGroupRenderAttribute
    {
        public GroupConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse = false)
            : base(fieldOrProperty, compareTo, compareFalse) { }


        public GroupConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op,
                                    string fieldOrProperty2, object compareTo2, bool compareFalse2)
            : base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2) { }


        public GroupConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op,
                                    string fieldOrProperty2, object compareTo2, bool compareFalse2,
                                    string fieldOrProperty3, object compareTo3, bool compareFalse3)
            : base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2, fieldOrProperty3, compareTo3, compareFalse3) { }

        public GroupConditionAttribute(string methodToQuery)
            : base(methodToQuery) { }
    }

    #endregion

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Attributes.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Couple.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c3f887f64f3b22845b9c93163066963a
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FluffyUnderware.DevTools
{
    public class Couple<T1, T2>
    {
        public T1 First { get; set; }
        public T2 Second { get; set; }
        public Couple(T1 first, T2 second)
        {
            First = first;
            Second = second;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Couple.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Data.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 45f5314b4eeb54743a8d8494c74a292b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using JetBrains.Annotations;
using Random = UnityEngine.Random;

namespace FluffyUnderware.DevTools
{
    [System.Serializable]
    public struct FloatRegion : IEquatable<FloatRegion>
    {
        public float From;
        public float To;
        public bool SimpleValue;

        public FloatRegion(float value)
        {
            From = value;
            To = value;
            SimpleValue = true;
        }

        public FloatRegion(float A, float B)
        {
            this.From = A;
            this.To = B;
            SimpleValue = false;
        }

        public static FloatRegion ZeroOne
        {
            get { return new FloatRegion(0, 1); }
        }

        public void MakePositive()
        {
            if (To < From)
            {
                (From, To) = (To, From);
            }
        }

        public void Clamp(float low, float high)
        {
            Low = Mathf.Clamp(Low, low, high);
            High = Mathf.Clamp(High, low, high);
        }

        public bool Positive
        {
            get { return From <= To; }
        }

        public float Low
        {
            get { return (Positive) ? From : To; }
            set
            {
                if (Positive)
                    From = value;
                else
                    To = value;
            }
        }

        public float High
        {
            get { return (Positive) ? To : From; }
            set
            {
                if (Positive)
                    To = value;
                else
                    From = value;
            }
        }

        public float Random
        {
            get
            {
                return UnityEngine.Random.Range(From, To);
            }
        }

        /// <summary>
        /// Gets the next value in the range
        /// <remarks>Depending on the value of <see cref="SimpleValue"/>, this call will or will not make the Random generator's seed progress</remarks>
        /// </summary>
        public float Next
        {
            get
            {
                if (SimpleValue)
                    return From;
                else
                    return Random;
            }
        }

        public float Length
        {
            get
            {
                return To - From;
            }
        }

        public float LengthPositive
        {
            get { return (Positive) ? To - From : From - To; }
        }

        public override string ToString()
        {
            return string.Format("({0:F2}-{1:F2})", From, To);
        }

        public override int GetHashCode()
        {
            return From.GetHashCode() ^ To.GetHashCode() << 2;
        }

        public bool Equals(FloatRegion other)
        {
            return From.Equals(other.From) && To.Equals(other.To);
        }

        public override bool Equals(object other)
        {
            if (!(other is FloatRegion))
            {
                return false;
            }
            FloatRegion r = (FloatRegion)other;
            return From.Equals(r.From) && To.Equals(r.To);
        }

        public static FloatRegion operator +(FloatRegion a, FloatRegion b)
        {
            return new FloatRegion(a.From + b.From, a.To + b.To);
        }

        public static FloatRegion operator -(FloatRegion a, FloatRegion b)
        {
            return new FloatRegion(a.From - b.From, a.To - b.To);
        }

        public static FloatRegion operator -(FloatRegion a)
        {
            return new FloatRegion(-a.From, -a.To);
        }

        public static FloatRegion operator *(FloatRegion a, float v)
        {
            return new FloatRegion(a.From * v, a.To * v);
        }

        public static FloatRegion operator *(float v, FloatRegion a)
        {
            return new FloatRegion(a.From * v, a.To * v);
        }

        public static FloatRegion operator /(FloatRegion a, float v)
        {
            return new FloatRegion(a.From / v, a.To / v);
        }

        public static bool operator ==(FloatRegion lhs, FloatRegion rhs)
        {
            return lhs.SimpleValue == rhs.SimpleValue && Mathf.Approximately(lhs.From, rhs.From) && Mathf.Approximately(lhs.To, rhs.To);
        }
        public static bool operator !=(FloatRegion lhs, FloatRegion rhs)
        {
            return lhs.SimpleValue != rhs.SimpleValue || !Mathf.Approximately(lhs.From, rhs.From) || !Mathf.Approximately(lhs.To, rhs.To);
        }
    }

    [System.Serializable]
    public struct IntRegion : IEquatable<IntRegion>
    {
        public int From;
        public int To;
        public bool SimpleValue;


        public IntRegion(int value)
        {
            From = value;
            To = value;
            SimpleValue = true;

        }

        public IntRegion(int A, int B)
        {
            this.From = A;
            this.To = B;
            SimpleValue = false;

        }

        public static IntRegion ZeroOne
        {
            get { return new IntRegion(0, 1); }
        }

        public void MakePositive()
        {
            if (To < From)
            {
                (From, To) = (To, From);
            }
        }

        public void Clamp(int low, int high)
        {
            Low = Mathf.Clamp(Low, low, high);
            High = Mathf.Clamp(High, low, high);
        }

        public bool Positive
        {
            get { return From <= To; }
        }

        public int Low
        {
            get { return (Positive) ? From : To; }
            set
            {
                if (Positive)
                    From = value;
                else
                    To = value;
            }
        }

        public int High
        {
            get { return (Positive) ? To : From; }
            set
            {
                if (Positive)
                    To = value;
                else
                    From = value;
            }
        }

        public int Random
        {
            get
            {
                return UnityEngine.Random.Range(From, To);
            }
        }

        public int Length
        {
            get
            {
                return To - From;
            }
        }

        public int LengthPositive
        {
            get { return (Positive) ? To - From : From - To; }
        }

        public override string ToString()
        {
            return string.Format("({0}-{1})", From, To);
        }

        public override int GetHashCode()
        {
            return From.GetHashCode() ^ To.GetHashCode() << 2;
        }

        public bool Equals(IntRegion other)
        {
            return From.Equals(other.From) && To.Equals(other.To);
        }

        public override bool Equals(object other)
        {
            if (!(other is IntRegion))
            {
                return false;
            }
            IntRegion r = (IntRegion)other;
            return From.Equals(r.From) && To.Equals(r.To);
        }

        public static IntRegion operator +(IntRegion a, IntRegion b)
        {
            return new IntRegion(a.From + b.From, a.To + b.To);
        }

        public static IntRegion operator -(IntRegion a, IntRegion b)
        {
            return new IntRegion(a.From - b.From, a.To - b.To);
        }

        public static IntRegion operator -(IntRegion a)
        {
            return new IntRegion(-a.From, -a.To);
        }

        public static IntRegion operator *(IntRegion a, int v)
        {
            return new IntRegion(a.From * v, a.To * v);
        }

        public static IntRegion operator *(int v, IntRegion a)
        {
            return new IntRegion(a.From * v, a.To * v);
        }

        public static IntRegion operator /(IntRegion a, int v)
        {
            return new IntRegion(a.From / v, a.To / v);
        }

        public static bool operator ==(IntRegion lhs, IntRegion rhs)
        {
            return lhs.From == rhs.From && lhs.To == rhs.To && lhs.SimpleValue != rhs.SimpleValue;
        }
        public static bool operator !=(IntRegion lhs, IntRegion rhs)
        {
            return lhs.From != rhs.From || lhs.To != rhs.To || lhs.SimpleValue != rhs.SimpleValue;
        }
    }

    /// <summary>
    /// Simple but effective ShuffleBag<T> implementation
    /// </summary>
    public class WeightedRandom<T>
    {
        readonly List<T> mData;
        int mCurrentPosition = -1;
        T mCurrentItem;

        public int Seed { get; set; }

        public bool RandomizeSeed { get; set; }

        private int Capacity { get { return mData.Capacity; } }
        public int Size { get { return mData.Count; } }

        public WeightedRandom(int initCapacity = 0)
        {
            mData = new List<T>(initCapacity);
        }

        public WeightedRandom(int initCapacity, int seed):this(initCapacity)
        {
            Seed = seed;
        }

        /// <summary>
        /// Adds items to the bag
        /// </summary>
        /// <param name="item">the item</param>
        /// <param name="amount">number of times this item should be added</param>
        public void Add(T item, int amount)
        {
            for (int i = 0; i < amount; i++)
                mData.Add(item);
            mCurrentPosition = Size - 1;
        }

        /// <summary>
        /// Gets a random item from the bag
        /// </summary>
        /// <returns>an item</returns>
        public T Next()
        {
            if (mCurrentPosition < 1)
            {
                mCurrentPosition = Size - 1;
                mCurrentItem = mData[0];
                return mCurrentItem;
            }
            Random.State s = Random.state;
            if (RandomizeSeed)
                Seed = Random.Range(0, int.MaxValue);
            Random.InitState(Seed);
            int idx = Random.Range(0, mCurrentPosition);
            Random.state = s;

            mCurrentItem = mData[idx];
            mData[idx] = mData[mCurrentPosition];
            mData[mCurrentPosition] = mCurrentItem;
            mCurrentPosition--;
            return mCurrentItem;
        }

        /// <summary>
        /// Refill the bag
        /// </summary>
        public void Reset()
        {
            mCurrentPosition = Size - 1;
        }

        /// <summary>
        /// Clear the bag
        /// </summary>
        public void Clear()
        {
            mData.Clear();
            mCurrentPosition = -1;
        }

    }

    public class Ring<T> : IList<T>
    {
        readonly List<T> mList;
        public int Size { get; private set; }

        int mIndex;

        public Ring(int size)
        {
            mList = new List<T>(size);
            Size = size;
        }

        public void Add(T item)
        {
            if (mList.Count == Size)
            {
                mList[mIndex++] = item;
                if (mIndex == mList.Count)
                    mIndex = 0;
            }
            else
                mList.Add(item);
        }

        public void Clear()
        {
            mList.Clear();
            mIndex = 0;
        }


        public int IndexOf(T item)
        {
            return mList.IndexOf(item);
        }

        public void Insert(int index, T item)
        {
            throw new System.NotSupportedException();
        }

        public void RemoveAt(int index)
        {
            throw new System.NotSupportedException();
        }

        public T this[int index]
        {
            get
            {
                return mList[index];
            }
            set
            {
                mList[index] = value;
            }
        }

        public IEnumerator GetEnumerator()
        {
            return mList.GetEnumerator();
        }


        public bool Contains(T item)
        {
            return mList.Contains(item);
        }

        public void CopyTo(T[] array, int arrayIndex)
        {
            mList.CopyTo(array, arrayIndex);
        }

        public int Count
        {
            get { return mList.Count; }
        }

        public bool IsReadOnly
        {
            get { throw new System.NotSupportedException(); }
        }

        public bool Remove(T item)
        {
            return mList.Remove(item);
        }

        IEnumerator<T> IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
        }
    }

    public class Pool<T> : IPool
    {
        readonly List<T> mObjects = new List<T>();

        public string Identifier { get; set; }

        public PoolSettings Settings { get; protected set; }

        public System.Type Type
        {
            get { return typeof(T); }
        }

        double mLastTime;
        double mDeltaTime;


        public Pool(PoolSettings settings = null)
        {
            Settings = settings ?? new PoolSettings();
            Identifier = typeof(T).FullName;
            mLastTime = DTTime.TimeSinceStartup + UnityEngine.Random.Range(0, Settings.Speed);
            if (Settings.Prewarm)
                Reset();
        }

        public void Update()
        {
            mDeltaTime += DTTime.TimeSinceStartup - mLastTime;
            mLastTime = DTTime.TimeSinceStartup;

            if (Settings.Speed > 0)
            {
                int c = (int)(mDeltaTime / Settings.Speed);
                mDeltaTime -= c;

                if (Count > Settings.Threshold)
                {
                    c = Mathf.Min(c, Count - Settings.Threshold);
                    while (c-- > 0)
                    {
                        destroy(mObjects[0]);
                        mObjects.RemoveAt(0);
                        log("Threshold exceeded: Deleting item");
                    }
                }
                else if (Count < Settings.MinItems)
                {
                    c = Mathf.Min(c, Settings.MinItems - Count);
                    while (c-- > 0)
                    {
                        mObjects.Add(create());
                        log("Below MinItems: Adding item");
                    }
                }
            }
            else
                mDeltaTime = 0;
        }

        public void Reset()
        {
            if (Application.isPlaying)
            {
                while (Count < Settings.MinItems)
                {
                    mObjects.Add(create());
                }
                while (Count > Settings.Threshold)
                {
                    destroy(mObjects[0]);
                    mObjects.RemoveAt(0);
                }
                log("Prewarm/Reset");
            }
        }

        public void Clear()
        {
            log("Clear");
            for (int i = 0; i < Count; i++)
                destroy(mObjects[i]);
            mObjects.Clear();
        }

        public int Count
        {
            get { return mObjects.Count; }
        }

        public virtual T Pop(Transform parent = null)
        {
            T item = default;
            if (Count > 0)
            {
                item = mObjects[0];
                mObjects.RemoveAt(0);

            }
            else
            {
                if (Settings.AutoCreate || !Application.isPlaying)
                {
                    log("Auto create item");
                    item = create();

                }
            }
            if (item != null)
            {
                sendAfterPop(item);
                setParent(item, parent);
                log("Pop " + item);
            }

            return item;
        }

        public virtual void Push(T item)
        {
            log("Push " + item);
            if (Application.isPlaying && item != null)
            {
                sendBeforePush(item);
                mObjects.Add(item);
            }
        }

        protected virtual void sendBeforePush(T item)
        {
            if (item is IPoolable)
                ((IPoolable)item).OnBeforePush();
        }

        protected virtual void sendAfterPop(T item)
        {
            if (item is IPoolable)
                ((IPoolable)item).OnAfterPop();
        }

        protected virtual void setParent(T item, Transform parent)
        {
        }

        protected virtual T create()
        {
            return System.Activator.CreateInstance<T>();
        }

        protected virtual void destroy(T item)
        {
        }

        void log(string msg)
        {
            if (Settings.Debug)
                Debug.Log(string.Format("[{0}] ({1} items) {2}", Identifier, Count, msg));
        }
    }


    [System.Serializable]
    public class PoolSettings
    {
        [SerializeField]
        bool m_Prewarm = false;
        [SerializeField]
        bool m_AutoCreate = true;
        [SerializeField]
        bool m_AutoEnableDisable = true;
        [Positive]
        [SerializeField]
        int m_MinItems = 0;

        [Positive]
        [SerializeField]
        int m_Threshold = 0;

        [Positive]
        [SerializeField]
        float m_Speed = 1;




        public bool Debug;

        public PoolSettings() { }

        public PoolSettings(PoolSettings src)
        {
            Prewarm = src.Prewarm;
            AutoCreate = src.AutoCreate;
            MinItems = src.MinItems;
            Threshold = src.Threshold;
            Speed = src.Speed;
            Debug = src.Debug;
        }

        public bool Prewarm
        {
            get { return m_Prewarm; }
            set
            {
                if (m_Prewarm != value)
                    m_Prewarm = value;
            }
        }

        public bool AutoCreate
        {
            get { return m_AutoCreate; }
            set
            {
                if (m_AutoCreate != value)
                    m_AutoCreate = value;
            }
        }

        public bool AutoEnableDisable
        {
            get { return m_AutoEnableDisable; }
            set
            {
                if (m_AutoEnableDisable != value)
                    m_AutoEnableDisable = value;
            }
        }

        public int MinItems
        {
            get { return m_MinItems; }
            set
            {
                int v = Mathf.Max(0, value);
                if (m_MinItems != v)
                    m_MinItems = v;
            }
        }

        public int Threshold
        {
            get { return m_Threshold; }
            set
            {
                int v = Mathf.Max(MinItems, value);
                if (m_Threshold != v)
                    m_Threshold = v;
            }
        }

        public float Speed
        {
            get { return m_Speed; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_Speed != v)
                    m_Speed = v;
            }
        }

        public void OnValidate()
        {
            MinItems = m_MinItems;
            Threshold = m_Threshold;
            Speed = m_Speed;
        }
    }


    public interface IPool
    {
        [NotNull]
        string Identifier { get; set; }
        PoolSettings Settings { get; }
        void Clear();
        void Reset();
        void Update();
        int Count { get; }
    }

    public interface IPoolable
    {
        void OnBeforePush();

        void OnAfterPop();
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Data.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTEase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d57d3ecf09b87c9438cf6d0622a903fb
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;

namespace FluffyUnderware.DevTools
{
    public static class DTTween
    {
        public enum EasingMethod
        {
            Linear              = 0,
            ExponentialIn       = 1,
            ExponentialOut      = 2,
            ExponentialInOut    = 3,
            ExponentialOutIn    = 4,
            CircularIn          = 5,
            CircularOut         = 6,
            CircularInOut       = 7,
            CircularOutIn       = 8,
            QuadraticIn         = 9,
            QuadraticOut        = 10,
            QuadraticInOut      = 11,
            QuadraticOutIn      = 12,
            SinusIn             = 13,
            SinusOut            = 14,
            SinusInOut          = 15,
            SinusOutIn          = 16,
            CubicIn             = 17,
            CubicOut            = 18,
            CubicInOut          = 19,
            CubicOutIn          = 20,
            QuarticIn           = 21,
            QuarticOut          = 22,
            QuarticInOut        = 23,
            QuarticOutIn        = 24,
            QuinticIn           = 25,
            QuinticOut          = 26,
            QuinticInOut        = 27,
            QuinticOutIn        = 28
        }


        /// <summary>
        /// Tween
        /// </summary>
        /// <param name="method">Tweening method</param>
        /// <param name="t">Time (0..1)</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float Ease(EasingMethod method, float t, float b, float c)
        {
            switch (method)
            {
                case EasingMethod.ExponentialIn: return ExpoIn(t, b, c);
                case EasingMethod.ExponentialOut: return ExpoOut(t, b, c);
                case EasingMethod.ExponentialInOut: return ExpoInOut(t, b, c);
                case EasingMethod.ExponentialOutIn: return ExpoOutIn(t, b, c);
                case EasingMethod.CircularIn: return CircIn(t, b, c);
                case EasingMethod.CircularOut: return CircOut(t, b, c);
                case EasingMethod.CircularInOut: return CircInOut(t, b, c);
                case EasingMethod.CircularOutIn: return CircOutIn(t, b, c);
                case EasingMethod.QuadraticIn: return QuadIn(t, b, c);
                case EasingMethod.QuadraticOut: return QuadOut(t, b, c);
                case EasingMethod.QuadraticInOut: return QuadInOut(t, b, c);
                case EasingMethod.QuadraticOutIn: return QuadOutIn(t, b, c);
                case EasingMethod.SinusIn: return SineIn(t, b, c);
                case EasingMethod.SinusOut: return SineOut(t, b, c);
                case EasingMethod.SinusInOut: return SineInOut(t, b, c);
                case EasingMethod.SinusOutIn: return SineOutIn(t, b, c);
                case EasingMethod.CubicIn: return CubicIn(t, b, c);
                case EasingMethod.CubicOut: return CubicOut(t, b, c);
                case EasingMethod.CubicInOut: return CubicInOut(t, b, c);
                case EasingMethod.CubicOutIn: return CubicOutIn(t, b, c);
                case EasingMethod.QuarticIn: return QuartIn(t, b, c);
                case EasingMethod.QuarticOut: return QuartOut(t, b, c);
                case EasingMethod.QuarticInOut: return QuartInOut(t, b, c);
                case EasingMethod.QuarticOutIn: return QuartOutIn(t, b, c);
                case EasingMethod.QuinticIn: return QuintIn(t, b, c);
                case EasingMethod.QuinticOut: return QuintOut(t, b, c);
                case EasingMethod.QuinticInOut: return QuintInOut(t, b, c);
                case EasingMethod.QuinticOutIn: return QuintOutIn(t, b, c);
                default: return Linear(t, b, c);
            }
        }

        /// <summary>
        /// Tween
        /// </summary>
        /// <param name="method">Tweening method</param>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float Ease(EasingMethod method, float t, float b, float c, float d)
        {
            switch (method)
            {
                case EasingMethod.ExponentialIn: return ExpoIn(t, b, c, d);
                case EasingMethod.ExponentialOut: return ExpoOut(t, b, c, d);
                case EasingMethod.ExponentialInOut : return ExpoInOut(t, b, c, d);
                case EasingMethod.ExponentialOutIn: return ExpoOutIn(t, b, c, d);
                case EasingMethod.CircularIn: return CircIn(t, b, c, d);
                case EasingMethod.CircularOut: return CircOut(t, b, c, d);
                case EasingMethod.CircularInOut: return CircInOut(t, b, c, d);
                case EasingMethod.CircularOutIn: return CircOutIn(t, b, c, d);
                case EasingMethod.QuadraticIn : return QuadIn(t, b, c, d);
                case EasingMethod.QuadraticOut : return QuadOut(t, b, c, d);
                case EasingMethod.QuadraticInOut : return QuadInOut(t, b, c, d);
                case EasingMethod.QuadraticOutIn : return QuadOutIn(t, b, c, d);
                case EasingMethod.SinusIn: return SineIn(t, b, c, d);
                case EasingMethod.SinusOut: return SineOut(t, b, c, d);
                case EasingMethod.SinusInOut : return SineInOut(t, b, c, d);
                case EasingMethod.SinusOutIn  : return SineOutIn(t, b, c, d);
                case EasingMethod.CubicIn: return CubicIn(t, b, c, d);
                case EasingMethod.CubicOut: return CubicOut(t, b, c, d);
                case EasingMethod.CubicInOut: return CubicInOut(t, b, c, d);
                case EasingMethod.CubicOutIn: return CubicOutIn(t, b, c, d);
                case EasingMethod.QuarticIn: return QuartIn(t, b, c, d);
                case EasingMethod.QuarticOut: return QuartOut(t, b, c, d);
                case EasingMethod.QuarticInOut: return QuartInOut(t, b, c, d);
                case EasingMethod.QuarticOutIn: return QuartOutIn(t, b, c, d);
                case EasingMethod.QuinticIn: return QuintIn(t, b, c, d);
                case EasingMethod.QuinticOut: return QuintOut(t, b, c, d);
                case EasingMethod.QuinticInOut: return QuintInOut(t, b, c, d);
                case EasingMethod.QuinticOutIn: return QuintOutIn(t, b, c, d);
                default: return Linear(t, b, c, d);
            }
        }

        #region ### Linear ###
        /// <summary>
        /// Linear tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float Linear(float t, float b, float c)
        {
            return c * Mathf.Clamp01(t) + b;
        }
        /// <summary>
        /// Linear tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float Linear(float t, float b, float c, float d)
        {
            return c * t / d + b;
        }
        #endregion

        #region ### Exponential ###
        /// <summary>
        /// Exponential tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float ExpoOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return (t == 1) ? b + c : c * (-Mathf.Pow(2, -10 * t) + 1) + b;
        }
        /// <summary>
        /// Exponential tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float ExpoOut(float t, float b, float c, float d)
        {
            return (t == d) ? b + c : c * (-Mathf.Pow(2, -10 * t / d) + 1) + b;
        }

        /// <summary>
        /// Exponential tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float ExpoIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return (t == 0) ? b : c * Mathf.Pow(2, 10 * (t-1)) + b;
        }
        /// <summary>
        /// Exponential tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float ExpoIn(float t, float b, float c, float d)
        {
            return (t == 0) ? b : c * Mathf.Pow(2, 10 * (t / d - 1)) + b;
        }

        /// <summary>
        /// Exponential tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float ExpoInOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t == 0)
                return b;

            if (t == 1)
                return b + c;

            if ((t /= .5f) < 1)
                return c / 2 * Mathf.Pow(2, 10 * (t - 1)) + b;

            return c / 2 * (-Mathf.Pow(2, -10 * --t) + 2) + b;
        }
        /// <summary>
        /// Exponential tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float ExpoInOut(float t, float b, float c, float d)
        {
            if (t == 0)
                return b;

            if (t == d)
                return b + c;

            if ((t /= d / 2) < 1)
                return c / 2 * Mathf.Pow(2, 10 * (t - 1)) + b;

            return c / 2 * (-Mathf.Pow(2, -10 * --t) + 2) + b;
        }

        /// <summary>
        /// Exponential tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float ExpoOutIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t < .5f)
                return ExpoOut(t * 2, b, c / 2);

            return ExpoIn((t * 2) - 1, b + c / 2, c / 2);
        }
        /// <summary>
        /// Exponential tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float ExpoOutIn(float t, float b, float c, float d)
        {
            if (t < d / 2)
                return ExpoOut(t * 2, b, c / 2, d);

            return ExpoIn((t * 2) - d, b + c / 2, c / 2, d);
        }

        #endregion

        #region ### Circular ###
        /// <summary>
        /// Circular tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CircOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return c * Mathf.Sqrt(1 - (t = t - 1) * t) + b;
        }
        /// <summary>
        /// Circular tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CircOut(float t, float b, float c, float d)
        {
            return c * Mathf.Sqrt(1 - (t = t / d - 1) * t) + b;
        }

        /// <summary>
        /// Circular tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CircIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return -c * (Mathf.Sqrt(1 - t * t) - 1) + b;
        }
        /// <summary>
        /// Circular tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CircIn(float t, float b, float c, float d)
        {
            return -c * (Mathf.Sqrt(1 - (t /= d) * t) - 1) + b;
        }

        /// <summary>
        /// Circular tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CircInOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if ((t /= .5f) < 1)
                return -c / 2 * (Mathf.Sqrt(1 - t * t) - 1) + b;

            return c / 2 * (Mathf.Sqrt(1 - (t -= 2) * t) + 1) + b;
        }
        /// <summary>
        /// Circular tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CircInOut(float t, float b, float c, float d)
        {
            if ((t /= d / 2) < 1)
                return -c / 2 * (Mathf.Sqrt(1 - t * t) - 1) + b;

            return c / 2 * (Mathf.Sqrt(1 - (t -= 2) * t) + 1) + b;
        }

        /// <summary>
        /// Circular tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CircOutIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t < .5f)
                return CircOut(t * 2, b, c / 2);

            return CircIn((t * 2) - 1, b + c / 2, c / 2);
        }
        /// <summary>
        /// Circular tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CircOutIn(float t, float b, float c, float d)
        {
            if (t < d / 2)
                return CircOut(t * 2, b, c / 2, d);

            return CircIn((t * 2) - d, b + c / 2, c / 2, d);
        }

        #endregion

        #region ### Quadratic ###
        /// <summary>
        /// Quadratic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuadOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return -c * t * (t - 2) + b;
        }
        /// <summary>
        /// Quadratic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuadOut(float t, float b, float c, float d)
        {
            return -c * (t /= d) * (t - 2) + b;
        }

        /// <summary>
        /// Quadratic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuadIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return c * t * t + b;
        }
        /// <summary>
        /// Quadratic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuadIn(float t, float b, float c, float d)
        {
            return c * (t /= d) * t + b;
        }

        /// <summary>
        /// Quadratic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuadInOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if ((t /= .5f) < 1)
                return -c / 2 * (Mathf.Sqrt(1 - t * t) - 1) + b;

            return c / 2 * (Mathf.Sqrt(1 - (t -= 2) * t) + 1) + b;
        }
        /// <summary>
        /// Quadratic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuadInOut(float t, float b, float c, float d)
        {
            if ((t /= d / 2) < 1)
                return -c / 2 * (Mathf.Sqrt(1 - t * t) - 1) + b;

            return c / 2 * (Mathf.Sqrt(1 - (t -= 2) * t) + 1) + b;
        }

        /// <summary>
        /// Quadratic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuadOutIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t < .5f)
                return QuadOut(t * 2, b, c / 2);

            return QuadIn((t * 2) - 1, b + c / 2, c / 2);
        }

        /// <summary>
        /// Quadratic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuadOutIn(float t, float b, float c, float d)
        {
            if (t < d / 2)
                return QuadOut(t * 2, b, c / 2, d);

            return QuadIn((t * 2) - d, b + c / 2, c / 2, d);
        }

        #endregion

        #region ### Sinus ###
        /// <summary>
        /// Sinusoidal tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float SineOut(float t, float b, float c)
        {
            return c * Mathf.Sin(Mathf.Clamp01(t) * (Mathf.PI / 2)) + b;
        }
        /// <summary>
        /// Sinusoidal tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float SineOut(float t, float b, float c, float d)
        {
            return c * Mathf.Sin(t / d * (Mathf.PI / 2)) + b;
        }

        /// <summary>
        /// Sinusoidal tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float SineIn(float t, float b, float c)
        {
            return -c * Mathf.Cos(Mathf.Clamp01(t) * (Mathf.PI / 2)) + c + b;
        }
        /// <summary>
        /// Sinusoidal tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float SineIn(float t, float b, float c, float d)
        {
            return -c * Mathf.Cos(t / d * (Mathf.PI / 2)) + c + b;
        }

        /// <summary>
        /// Sinusoidal tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float SineInOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if ((t /= .5f) < 1)
                return c / 2 * (Mathf.Sin(Mathf.PI * t / 2)) + b;

            return -c / 2 * (Mathf.Cos(Mathf.PI * --t / 2) - 2) + b;

        }
        /// <summary>
        /// Sinusoidal tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float SineInOut(float t, float b, float c, float d)
        {
            if ((t /= d / 2) < 1)
                return c / 2 * (Mathf.Sin(Mathf.PI * t / 2)) + b;

            return -c / 2 * (Mathf.Cos(Mathf.PI * --t / 2) - 2) + b;
        }

        /// <summary>
        /// Sinusoidal tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float SineOutIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t < .5f)
                return SineOut(t * 2, b, c / 2);

            return SineIn((t * 2) - 1, b + c / 2, c / 2);
        }

        /// <summary>
        /// Sinusoidal tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float SineOutIn(float t, float b, float c, float d)
        {
            if (t < d / 2)
                return SineOut(t * 2, b, c / 2, d);

            return SineIn((t * 2) - d, b + c / 2, c / 2, d);
        }

        #endregion

        #region ### Cubic ###

        /// <summary>
        /// Cubic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CubicOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return c * ((t = t - 1) * t * t + 1) + b;
        }
        /// <summary>
        /// Cubic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CubicOut(float t, float b, float c, float d)
        {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        }

        /// <summary>
        /// Cubic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CubicIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return c * t * t * t + b;
        }
        /// <summary>
        /// Cubic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CubicIn(float t, float b, float c, float d)
        {
            return c * (t /= d) * t * t + b;
        }

        /// <summary>
        /// Cubic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CubicInOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if ((t /= .5f) < 1)
                return c / 2 * t * t * t + b;

            return c / 2 * ((t -= 2) * t * t + 2) + b;

        }
        /// <summary>
        /// Cubic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CubicInOut(float t, float b, float c, float d)
        {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t + b;

            return c / 2 * ((t -= 2) * t * t + 2) + b;
        }

        /// <summary>
        /// Cubic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CubicOutIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t < .5f)
                return CubicOut(t * 2, b, c / 2);

            return CubicIn((t * 2) - 1, b + c / 2, c / 2);
        }

        /// <summary>
        /// Cubic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CubicOutIn(float t, float b, float c, float d)
        {
            if (t < d / 2)
                return CubicOut(t * 2, b, c / 2, d);

            return CubicIn((t * 2) - d, b + c / 2, c / 2, d);
        }

        #endregion

        #region ### Quartic ###

        /// <summary>
        /// Quartic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuartOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return -c * ((t = t - 1) * t * t * t - 1) + b;
        }
        /// <summary>
        /// Quartic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuartOut(float t, float b, float c, float d)
        {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b;
        }

        /// <summary>
        /// Quartic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuartIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return c * t * t * t * t + b;
        }
        /// <summary>
        /// Quartic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuartIn(float t, float b, float c, float d)
        {
            return c * (t /= d) * t * t * t + b;
        }

        /// <summary>
        /// Quartic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuartInOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if ((t /= .5f) < 1)
                return c / 2 * t * t * t * t + b;

            return -c / 2 * ((t -= 2) * t * t * t - 2) + b;

        }
        /// <summary>
        /// Quartic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuartInOut(float t, float b, float c, float d)
        {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t * t + b;

            return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
        }

        /// <summary>
        /// Quartic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuartOutIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t < .5f)
                return QuartOut(t * 2, b, c / 2);

            return QuartIn((t * 2) - 1, b + c / 2, c / 2);
        }

        /// <summary>
        /// Quartic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuartOutIn(float t, float b, float c, float d)
        {
            if ( t < d / 2 )
                return QuartOut( t * 2, b, c / 2, d );

            return QuartIn( ( t * 2 ) - d, b + c / 2, c / 2, d );
        }

        #endregion

        #region ### Quintic ###

        /// <summary>
        /// Quintic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuintOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return c * ((t = t - 1) * t * t * t * t + 1) + b;
        }
        /// <summary>
        /// Quintic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuintOut(float t, float b, float c, float d)
        {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        }

        /// <summary>
        /// Quintic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuintIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return c * t * t * t * t * t + b;
        }
        /// <summary>
        /// Quintic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuintIn(float t, float b, float c, float d)
        {
            return c * (t /= d) * t * t * t * t + b;
        }

        /// <summary>
        /// Quintic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuintInOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if ((t /= .5f) < 1)
                return c / 2 * t * t * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;

        }
        /// <summary>
        /// Quintic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuintInOut(float t, float b, float c, float d)
        {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        }

        /// <summary>
        /// Quintic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuintOutIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t < .5f)
                return QuintOut(t * 2, b, c / 2);
            return QuintIn((t * 2) - 1, b + c / 2, c / 2);
        }

        /// <summary>
        /// Quintic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuintOutIn(float t, float b, float c, float d)
        {
            if (t < d / 2)
                return QuintOut(t * 2, b, c / 2, d);
            return QuintIn((t * 2) - d, b + c / 2, c / 2, d);
        }

        #endregion

        // TODO: Add missing formulas (Elastic etc.) from here: http://wpf-animation.googlecode.com/svn/trunk/src/WPF/Animation/PennerDoubleAnimation.cs
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTEase.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTObjectDump.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 64b16d693c41e7a44979cd06b6d9e47b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Text;
using System;
using System.Reflection;
using FluffyUnderware.DevTools.Extensions;

namespace FluffyUnderware.DevTools
{

    public class DTObjectDump
    {
        const int INDENTSPACES = 5;
        string mIndent;
        StringBuilder mSB;
        object mObject;

        public DTObjectDump(object o, int indent = 0)
        {
            mIndent = new string(' ', indent);
            mSB = new StringBuilder();
            mObject = o;

            Type T = o.GetType();
            FieldInfo[] fia = T.GetAllFields(false, true);
            if (fia.Length > 0)
                AppendHeader("Fields");
            foreach (FieldInfo fi in fia)
                AppendMember(fi);

            PropertyInfo[] pia = T.GetAllProperties(false, true);
            if (pia.Length > 0)
                AppendHeader("Properties");
            foreach (PropertyInfo pi in pia)
                AppendMember(pi);
        }

        public override string ToString()
        {
            return mSB.ToString();
        }

        void AppendHeader(string name)
        {
            mSB.AppendLine(mIndent + "<b>---===| " + name + " |===---</b>\n");
        }

        void AppendMember(MemberInfo info)
        {
            Type type;
            string typeName;
            object value;

            FieldInfo fi = info as FieldInfo;
            if (fi != null)
            {
                type = fi.FieldType;
                typeName = type.Name;
                value = fi.GetValue(mObject);
            }
            else
            {
                PropertyInfo pi = info as PropertyInfo;
                type = pi.PropertyType;
                typeName = type.Name;
                value = pi.GetValue(mObject, null);
            }

            if (value != null)
            {
                if (typeof(IEnumerable).IsAssignableFrom(type))
                {
                    string tmp = mIndent;
                    int count = 0;
                    IEnumerable ie = value as IEnumerable;
                    if (ie != null)
                    {
                        if (type.GetEnumerableType().BaseType == typeof(ValueType))
                        {
                            foreach (object e in ie)
                                tmp = string.Concat(tmp, string.Format("<b>{0}</b>: {1} ", (count++).ToString(), e.ToString()));
                        }
                        else
                        {
                            if (typeof(IList).IsAssignableFrom(type))
                                typeName = "IList<" + type.GetEnumerableType() + ">";
                            tmp += "\n";
                            foreach (object e in ie)
                                tmp = string.Concat(tmp, string.Format("<b>{0}</b>: {1} ", (count++).ToString(), new DTObjectDump(e, mIndent.Length + INDENTSPACES).ToString()));
                        }
                    }
                    mSB.Append(mIndent);
                    mSB.AppendFormat("(<i>{0}</i>) <b>{1}[{2}]</b> = ", typeName, info.Name, count);
                    mSB.AppendLine(tmp);
                }
                else
                {
                    mSB.Append(mIndent);
                    mSB.AppendFormat("(<i>{0}</i>) <b>{1}</b> = ", typeName, info.Name);
                    mSB.AppendLine(mIndent + value.ToString());
                }
            }
        }
    }

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTObjectDump.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d3a715a2c19f08a4ba8b136add10408f
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System;
using System.Text;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using UnityEngine.Events;
using Object = UnityEngine.Object;
#if UNITY_EDITOR
using UnityEditor;
using System.Linq;
#endif

namespace FluffyUnderware.DevTools
{
    public static class DTUtility
    {
        /// <summary>
        /// The base Url for DT components' documentation
        /// </summary>
        public const string HelpUrlBase = "https://curvyeditor.com/doclink/";

#if UNITY_EDITOR
        static MethodInfo mGetBuiltinExtraResourcesMethod;
#endif

        public static Material GetDefaultMaterial()
        {
#if UNITY_EDITOR
            if (mGetBuiltinExtraResourcesMethod == null)
            {
                BindingFlags bfs = BindingFlags.NonPublic | BindingFlags.Static;
                mGetBuiltinExtraResourcesMethod = typeof(UnityEditor.EditorGUIUtility).GetMethod("GetBuiltinExtraResource", bfs);
            }

            Material result;
            if (mGetBuiltinExtraResourcesMethod == null)
            {
                result = null;
                Debug.LogError("Couldn't find method GetBuiltinExtraResource in type UnityEditor.EditorGUIUtility");
            }
            else
                result = (Material)mGetBuiltinExtraResourcesMethod.Invoke(null, new object[] { typeof(Material), "Default-Diffuse.mat" });

            return result;
#else
            return null;
#endif
        }


        public static bool IsEditorStateChange
        {
            get
            {
#if UNITY_EDITOR
                if (UnityEditor.EditorApplication.isPlayingOrWillChangePlaymode && !UnityEditor.EditorApplication.isPlaying)
                    return true;
                else
#endif
                    return false;
            }
        }


#if UNITY_EDITOR
        private const string INDENT_STRING = "    ";
        public static string FormatJson(string str)
        {
            int indent = 0;
            bool quoted = false;
            StringBuilder sb = new System.Text.StringBuilder();
            for (int i = 0; i < str.Length; i++)
            {
                char ch = str[i];
                switch (ch)
                {
                    case '{':
                    case '[':
                        sb.Append(ch);
                        if (!quoted)
                        {
                            sb.AppendLine();
                            Enumerable.Range(0, ++indent).ForEach(item => sb.Append(INDENT_STRING));
                        }
                        break;
                    case '}':
                    case ']':
                        if (!quoted)
                        {
                            sb.AppendLine();
                            Enumerable.Range(0, --indent).ForEach(item => sb.Append(INDENT_STRING));
                        }
                        sb.Append(ch);
                        break;
                    case '"':
                        sb.Append(ch);
                        bool escaped = false;
                        int index = i;
                        while (index > 0 && str[--index] == '\\')
                            escaped = !escaped;
                        if (!escaped)
                            quoted = !quoted;
                        break;
                    case ',':
                        sb.Append(ch);
                        if (!quoted)
                        {
                            sb.AppendLine();
                            Enumerable.Range(0, indent).ForEach(item => sb.Append(INDENT_STRING));
                        }
                        break;
                    case ':':
                        sb.Append(ch);
                        if (!quoted)
                            sb.Append(" ");
                        break;
                    default:
                        sb.Append(ch);
                        break;
                }
            }
            return sb.ToString();
        }
#endif

        /// <summary>
        /// Much like HandleUtility.GetHandleSize(), but works for gizmos
        /// </summary>
        /// <param name="position"> handle position in world space</param>
        public static float GetHandleSize(Vector3 position)
        {
            Camera camera = Camera.current;

            if (camera)
            {
                Transform cameraTransform = camera.transform;

                Vector3 localDirection;
                localDirection.x = 0;
                localDirection.y = 0;
                localDirection.z = 1;
                Vector3 cameraZDirection = cameraTransform.TransformDirection(localDirection);

                localDirection.x = 1;
                localDirection.y = 0;
                localDirection.z = 0;
                Vector3 cameraXDirection = cameraTransform.TransformDirection(localDirection);


                return GetHandleSize(Gizmos.matrix.MultiplyPoint3x4(position), camera, camera.pixelWidth * 0.5f, camera.pixelHeight * 0.5f, cameraTransform.position, cameraZDirection, cameraXDirection);
            }

            return 20f;
        }

        /// <summary>
        /// Much like HandleUtility.GetHandleSize(), but works for gizmos
        /// </summary>
        /// <param name="position"> handle position in world space</param>
        /// <param name="camera"> the camera through which the object is displayed</param>
        /// <param name="cameraCenterWidth"> camera.pixelWidth * 0.5f</param>
        /// <param name="cameraCenterHeight"> camera.pixelHeight * 0.5f</param>
        /// <param name="cameraPosition"> camera.transform.position</param>
        /// <param name="cameraZDirection"> camera.transform.forward</param>
        /// <param name="cameraXDirection"> camera.transform.right</param>
        public static float GetHandleSize(Vector3 position, Camera camera, float cameraCenterWidth, float cameraCenterHeight, Vector3 cameraPosition, Vector3 cameraZDirection, Vector3 cameraXDirection)
        {
            //inlined version of Vector3.Dot(positionMinusCameraPosition, cameraZDirection)
            float z = (position.x - cameraPosition.x) * cameraZDirection.x +
                      (position.y - cameraPosition.y) * cameraZDirection.y +
                      (position.z - cameraPosition.z) * cameraZDirection.z;

            //OPTIM
            //If you reaaaally need those extra milliseconds, use this
            //return z * 0.15f;
            //This will give a good enough result. The problem with this method is that the handle size is unsatisfying when transitioning between Perspective and Orthogonal view, and when the scene view window is too narrow to the point that it changes the FOV of the scene view.

            Vector3 b;
            {
                Vector3 camPosPlusDirB;
                camPosPlusDirB.x = cameraPosition.x + cameraZDirection.x * z + cameraXDirection.x;
                camPosPlusDirB.y = cameraPosition.y + cameraZDirection.y * z + cameraXDirection.y;
                camPosPlusDirB.z = cameraPosition.z + cameraZDirection.z * z + cameraXDirection.z;
                b = camera.WorldToScreenPoint(camPosPlusDirB, Camera.MonoOrStereoscopicEye.Mono);
            }

            float aMinusBX = cameraCenterWidth - b.x;
            float aMinusBY = cameraCenterHeight - b.y;
            return 80f / (float)Math.Sqrt(aMinusBX * aMinusBX +
                                          aMinusBY * aMinusBY);
        }

        public static void SetPlayerPrefs<T>(string key, T value)
        {
            Type tt = typeof(T);
            if (tt.IsEnum)
            {
                PlayerPrefs.SetInt(key, Convert.ToInt32(Enum.Parse(typeof(T), value.ToString()) as Enum));
            }
            else if (tt.IsArray)
            {
                throw new System.NotImplementedException();
            }
            else if (tt.Matches(typeof(int), typeof(Int32)))
                PlayerPrefs.SetInt(key, (value as int?).Value);
            else if (tt == typeof(string))
                PlayerPrefs.SetString(key, (value as string));
            else if (tt == typeof(float))
                PlayerPrefs.SetFloat(key, (value as float?).Value);
            else if (tt == typeof(bool))
                PlayerPrefs.SetInt(key, ((value as bool?).Value == true) ? 1 : 0);
            else if (tt == typeof(Color))
                PlayerPrefs.SetString(key, (value as Color?).Value.ToHtml());
            else
                Debug.LogError("[DevTools.SetEditorPrefs] Unsupported datatype: " + tt.Name);
        }

        public static T GetPlayerPrefs<T>(string key, T defaultValue)
        {
            if (PlayerPrefs.HasKey(key))
            {
                Type tt = typeof(T);
                try
                {
                    if (tt.IsEnum || tt.Matches(typeof(int), typeof(Int32)))
                    {
                        return (T)(object)PlayerPrefs.GetInt(key, (int)(object)defaultValue);
                    }
                    else if (tt.IsArray)
                    {
                        throw new System.NotImplementedException();
                    }
                    else if (tt == typeof(string))
                        return (T)(object)PlayerPrefs.GetString(key, defaultValue.ToString());
                    else if (tt == typeof(float))
                        return (T)(object)PlayerPrefs.GetFloat(key, (float)(object)defaultValue);
                    else if (tt == typeof(bool))
                        return (T)(object)(PlayerPrefs.GetInt(key, ((bool)(object)defaultValue == true) ? 1 : 0) == 1);
                    else if (tt == typeof(Color))
                        return (T)(object)PlayerPrefs.GetString(key, ((Color)(object)defaultValue).ToHtml()).ColorFromHtml();
                    else
                        Debug.LogError("[DevTools.SetEditorPrefs] Unsupported datatype: " + tt.Name);
                }
                catch (Exception e)
                {
                    Debug.LogException(e);
                    return defaultValue;
                }
            }


            return defaultValue;
        }

        public static float RandomSign()
        {
            return UnityEngine.Random.Range(0, 2) * 2 - 1;
        }

        public static string GetHelpUrl(object forClass)
        {
            return (forClass == null) ? string.Empty : GetHelpUrl(forClass.GetType());
        }

        public static string GetHelpUrl(Type classType)
        {
            if (classType != null)
            {
                object[] attribs = classType.GetCustomAttributes(typeof(HelpURLAttribute), true);
                if (attribs.Length > 0)
                    return (((HelpURLAttribute)attribs[0]).URL);
            }
            return string.Empty;
        }

        public static Vector3 GetCenterPosition(Vector3 fallback, params Vector3[] vectors)
        {
            if (vectors.Length == 0)
                return fallback;
            Vector3 v = vectors[0];
            for (int i = 1; i < vectors.Length; i++)
                v += vectors[i];
            return (v / vectors.Length);
        }

        public static T CreateGameObject<T>(Transform parent, string name) where T : MonoBehaviour
        {
            GameObject go = new GameObject(name);
            go.transform.parent = parent;
            go.transform.localPosition = Vector3.zero;
            go.transform.localRotation = Quaternion.identity;
            T cmp = go.AddComponent<T>();
            return cmp;
        }

#if UNITY_EDITOR
        /// <summary>
        /// Returns true if the object's prefab instance status allows for deletion
        /// </summary>
        /// <param name="object">The input object to test</param>
        /// <param name="errorMessage"> Is set to empty string if method returns true, otherwise it is set to a message error, similar to the one display by Unity, explaining the issue.</param>
        /// <see cref="PrefabInstanceStatus"/>
        public static bool DoesPrefabStatusAllowDeletion(this UnityEngine.Object @object, out string errorMessage)
        {
            PrefabInstanceStatus prefabInstanceStatus = default;
            bool isDeletionAllowed = @object is GameObject == false || DoesPrefabStatusAllowDeletion((GameObject)@object, out prefabInstanceStatus);
            if (isDeletionAllowed == false)
            {
                errorMessage = $"You initiated an operation that leads to the deletion of the Game Object '{@object.name}', which is part of a Prefab instance.\n\n";
                if (prefabInstanceStatus == PrefabInstanceStatus.MissingAsset)
                    errorMessage += "The Prefab asset is missing. You have to unpack the Prefab instance to be able to execute this operation";
                else
                    errorMessage += $"Children of a Prefab instance cannot be deleted or moved, and components cannot be reordered. \n\nYou have to open the Prefab in Prefab Mode to restructure the Prefab Asset itself, or unpack the Prefab instance to remove its Prefab connection.";
            }
            else
            {
                errorMessage = string.Empty;
            }

            return isDeletionAllowed;
        }

        /// <summary>
        /// Returns true if the object's prefab instance status allows for deletion
        /// </summary>
        /// <param name="gameObject">The input object to test</param>
        /// <param name="prefabInstanceStatus"> The prefab instance status of the gameObject</param>
        public static bool DoesPrefabStatusAllowDeletion(this GameObject gameObject, out PrefabInstanceStatus prefabInstanceStatus)
        {
            prefabInstanceStatus = PrefabUtility.GetPrefabInstanceStatus(gameObject);
            return prefabInstanceStatus != PrefabInstanceStatus.Connected || PrefabUtility.IsOutermostPrefabInstanceRoot(gameObject);
        }
#endif

        /// <summary>
        /// Returns whether the code is executed in edit mode or not
        /// </summary>
        public static bool IsInEditMode
        {
            get
            {
                bool result;
#if UNITY_EDITOR
                result = !Application.isPlaying;
#else
                result = false;
#endif
                return result;
            }
        }
    }

    public static class DTTime
    {
        static float _EditorDeltaTime;
        static float _EditorLastTime;

        public static double TimeSinceStartup
        {
            get
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    return UnityEditor.EditorApplication.timeSinceStartup;
#endif
                return Time.timeSinceLevelLoad;
            }
        }

        [Obsolete("Seems to me that this is not working properly. Probably because InitializeEditorTime and UpdateEditorTime are never called. Fix this before using it")]
        public static float deltaTime
        {
            get
            {
                return (Application.isPlaying) ? Time.deltaTime : _EditorDeltaTime;
            }
        }

        public static void InitializeEditorTime()
        {
            _EditorLastTime = Time.realtimeSinceStartup;
            _EditorDeltaTime = 0;
        }

        public static void UpdateEditorTime()
        {
            float cur = Time.realtimeSinceStartup;
            float timeDelta = (cur - _EditorLastTime);

            _EditorDeltaTime = timeDelta;
            _EditorLastTime = cur;

            /*
            if (frameDelta > 20 || timeDelta > 1)
            {
                _EditorLastFrame = Time.frameCount;
                _EditorLastTime = cur;
                _EditorDeltaTime = 0;
            }
            else if (frameDelta > 0)
            {
                _EditorDeltaTime = timeDelta / frameDelta;
                _EditorLastTime = cur;
                _EditorLastFrame = Time.frameCount;
            }*/
        }


    }

    public class TimeMeasure : Ring<long>
    {
        public System.Diagnostics.Stopwatch mWatch = new System.Diagnostics.Stopwatch();

        public TimeMeasure(int size) : base(size)
        { }

        public void Start()
        {
            mWatch.Start();
        }

        public void Stop()
        {
            mWatch.Stop();
            Add(mWatch.ElapsedTicks);
            mWatch.Reset();
        }

        public void Pause()
        {
            mWatch.Stop();
        }

        public double LastTicks
        {
            get
            {
                return this[this.Count - 1];
            }
        }

        public double LastMS
        {
            get
            {
                return LastTicks / (double)System.TimeSpan.TicksPerMillisecond;
            }
        }

        public double AverageMS
        {
            get
            {
                long d = 0;
                for (int i = 0; i < this.Count; i++)
                    d += this[i];

                return DTMath.FixNaN((d / (double)System.TimeSpan.TicksPerMillisecond) / Count);
            }
        }

        public double MinimumMS
        {
            get
            {
                long d = long.MaxValue;
                for (int i = 0; i < this.Count; i++)
                    d = System.Math.Min(d, this[i]);

                return DTMath.FixNaN(d / (double)System.TimeSpan.TicksPerMillisecond);
            }
        }

        public double MaximumMS
        {
            get
            {
                long d = long.MinValue;
                for (int i = 0; i < this.Count; i++)
                    d = System.Math.Max(d, this[i]);

                return DTMath.FixNaN(d / (double)System.TimeSpan.TicksPerMillisecond);
            }
        }

        public double AverageTicks
        {
            get
            {
                long d = 0;
                for (int i = 0; i < this.Count; i++)
                    d += this[i];
                return d / (double)Count;
            }
        }

        public double MinimumTicks
        {
            get
            {
                long d = long.MaxValue;
                for (int i = 0; i < this.Count; i++)
                    d = System.Math.Min(d, this[i]);
                return d;
            }
        }

        public double MaximumTicks
        {
            get
            {
                long d = 0;
                for (int i = 0; i < this.Count; i++)
                    d = System.Math.Max(d, this[i]);
                return d;
            }
        }
    }

    public static class DTMath
    {
        public static Vector3 ParallelTransportFrame(Vector3 up, Vector3 tan0, Vector3 tan1)
        {
            Vector3 A = Vector3.Cross(tan0, tan1);
            if (tan0 == -tan1) //Result is undefined in this case
            {
                Debug.LogWarning("[DevTools] ParallelTransportFrame's result is undefined for cases where tan0 == -tan1");
            }
            float a = Mathf.Atan2(A.magnitude, Vector3.Dot(tan0, tan1));
            return Quaternion.AngleAxis(Mathf.Rad2Deg * a, A) * up;
        }

        public static Vector3 LeftTan(ref Vector3 tan, ref Vector3 up)
        {
            return Vector3.Cross(tan, up);
        }

        public static Vector3 RightTan(ref Vector3 tan, ref Vector3 up)
        {
            return Vector3.Cross(up, tan);
        }

        /// <summary>
        /// Much like Mathf.Repeat(), but DTMath.Repeat(v,v) returns v instead of 0
        /// </summary>
        public static float Repeat(float t, float length)
        {
            return (t == length) ? t : t - Mathf.Floor(t / length) * length;
        }

        public static double FixNaN(double v)
        {
            if (double.IsNaN(v))
                v = 0;
            return v;
        }

        public static float FixNaN(float v)
        {
            if (float.IsNaN(v))
                v = 0;
            return v;
        }

        public static Vector2 FixNaN(Vector2 v)
        {
            if (float.IsNaN(v.x))
            {
                v.x = 0;
            }
            if (float.IsNaN(v.y))
            {
                v.y = 0;
            }
            return v;
        }

        /// <summary>
        /// Fixes NaN for Vector3
        /// </summary>
        /// <param name="v">a Vector3</param>
        /// <returns>the "cleaned up" vector</returns>
        public static Vector3 FixNaN(Vector3 v)
        {
            if (float.IsNaN(v.x))
            {
                v.x = 0;
            }
            if (float.IsNaN(v.y))
            {
                v.y = 0;
            }
            if (float.IsNaN(v.z))
            {
                v.z = 0;
            }
            return v;
        }

        /// <summary>
        /// Maps a value from a source range to a destination range
        /// </summary>
        /// <param name="min">min destination value</param>
        /// <param name="max">max destination value</param>
        /// <param name="value">current source value</param>
        /// <param name="vMin">min source value</param>
        /// <param name="vMax">max source value</param>
        /// <returns></returns>
        public static float MapValue(float min, float max, float value, float vMin = -1, float vMax = 1)
        {
            return min + (max - min) * (value - vMin) / (vMax - vMin);
        }

        public static float SnapPrecision(float value, int decimals)
        {
            return (decimals >= 0) ? (float)System.Math.Round(value, decimals) : value;
        }

        public static Vector2 SnapPrecision(Vector2 value, int decimals)
        {
            if (decimals < 0)
                return value;

            value.Set(SnapPrecision(value.x, decimals), SnapPrecision(value.y, decimals));
            return value;
        }

        public static Vector3 SnapPrecision(Vector3 value, int decimals)
        {
            if (decimals < 0)
                return value;
            value.Set(SnapPrecision(value.x, decimals), SnapPrecision(value.y, decimals), SnapPrecision(value.z, decimals));
            return value;
        }

        /// <summary>
        /// Gets the squared distance to the nearest point on a line
        /// </summary>
        /// <param name="l1">Line P1</param>
        /// <param name="l2">Line P2</param>
        /// <param name="p">a Point</param>
        /// <param name="frag">fragment on the line (0..1) of the nearest point</param>
        /// <returns>sqrMagnitude</returns>
        public static float LinePointDistanceSqr(Vector3 l1, Vector3 l2, Vector3 p, out float frag)
        {
            Vector3 v = l2;
            v.x -= l1.x;
            v.y -= l1.y;
            v.z -= l1.z;

            Vector3 w = p;
            w.x -= l1.x;
            w.y -= l1.y;
            w.z -= l1.z;

            float c1 = Vector3.Dot(w, v);
            if (c1 <= 0)
            {
                frag = 0;
                return w.sqrMagnitude;
            }
            float c2 = Vector3.Dot(v, v);
            if (c2 <= c1)
            {
                frag = 1;

                Vector3 pMinusl2 = p;
                pMinusl2.x -= l2.x;
                pMinusl2.y -= l2.y;
                pMinusl2.z -= l2.z;

                return pMinusl2.sqrMagnitude;
            }
            frag = c1 / c2;

            Vector3 fragMulv = v;
            fragMulv.x *= frag;
            fragMulv.y *= frag;
            fragMulv.z *= frag;

            Vector3 pb = l1;
            pb.x += fragMulv.x;
            pb.y += fragMulv.y;
            pb.z += fragMulv.z;

            Vector3 pMinuspb = p;
            pMinuspb.x -= pb.x;
            pMinuspb.y -= pb.y;
            pMinuspb.z -= pb.z;

            return pMinuspb.sqrMagnitude;
        }

        /// <summary>
        /// Collide a ray (point + direction) against a line segment and return the hit point
        /// </summary>
        /// <param name="r0">Ray position</param>
        /// <param name="dir">Ray direction</param>
        /// <param name="l1">Line P1</param>
        /// <param name="l2">Line P2</param>
        /// <param name="hit">Collision Point</param>
        /// <param name="frag">fragment on the line (0..1) of the collision point</param>
        /// <returns>true if collision occurs</returns>
        public static bool RayLineSegmentIntersection(Vector2 r0, Vector2 dir, Vector2 l1, Vector2 l2, out Vector2 hit, out float frag)
        {
            Vector2 s2 = l2 - l1;
            float t;
            frag = (-dir.y * (r0.x - l1.x) + dir.x * (r0.y - l1.y)) / (-s2.x * dir.y + dir.x * s2.y);
            t = (s2.x * (r0.y - l1.y) - s2.y * (r0.x - l1.x)) / (-s2.x * dir.y + dir.x * s2.y);

            if (frag >= 0 && frag <= 1 && t > 0)
            {
                hit = new Vector2(r0.x + (t * dir.x), r0.y + (t * dir.y));
                return true;
            }
            hit = Vector2.zero;
            return false;
        }

        /// <summary>
        /// Calculates the intersection line segment between 2 lines (not segments).
        /// </summary>
        /// <returns>false if no solution can be found</returns>
        public static bool ShortestIntersectionLine(Vector3 line1A, Vector3 line1B,
            Vector3 line2A, Vector3 line2B, out Vector3 resultSegmentA, out Vector3 resultSegmentB)
        {
            // Algorithm is ported from the C algorithm of 
            // Paul Bourke at http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline3d/
            resultSegmentA = Vector3.zero;
            resultSegmentB = Vector3.zero;

            Vector3 p1 = line1A;
            Vector3 p2 = line1B;
            Vector3 p3 = line2A;
            Vector3 p4 = line2B;
            Vector3 p13 = p1 - p3;
            Vector3 p43 = p4 - p3;

            if (p43.sqrMagnitude < Mathf.Epsilon)
            {
                return false;
            }
            Vector3 p21 = p2 - p1;
            if (p21.sqrMagnitude < Mathf.Epsilon)
            {
                return false;
            }

            double d1343 = p13.x * (double)p43.x + (double)p13.y * p43.y + (double)p13.z * p43.z;
            double d4321 = p43.x * (double)p21.x + (double)p43.y * p21.y + (double)p43.z * p21.z;
            double d1321 = p13.x * (double)p21.x + (double)p13.y * p21.y + (double)p13.z * p21.z;
            double d4343 = p43.x * (double)p43.x + (double)p43.y * p43.y + (double)p43.z * p43.z;
            double d2121 = p21.x * (double)p21.x + (double)p21.y * p21.y + (double)p21.z * p21.z;

            double denom = d2121 * d4343 - d4321 * d4321;
            if (System.Math.Abs(denom) < double.Epsilon)
            {
                return false;
            }
            double numer = d1343 * d4321 - d1321 * d4343;

            double mua = numer / denom;
            double mub = (d1343 + d4321 * (mua)) / d4343;
            resultSegmentA = new Vector3((float)(p1.x + mua * p21.x), (float)(p1.y + mua * p21.y), (float)(p1.z + mua * p21.z));
            resultSegmentB = new Vector3((float)(p3.x + mub * p43.x), (float)(p3.y + mub * p43.y), (float)(p3.z + mub * p43.z));
            return true;
        }

        /// <summary>
        /// Calculates the intersection between two line segments
        /// </summary>
        /// <returns>false if no solution can be found</returns>
        public static bool LineLineIntersection(Vector3 line1A, Vector3 line1B, Vector3 line2A, Vector3 line2B, out Vector3 hitPoint)
        {
            Vector3 resB;
            if (ShortestIntersectionLine(line1A, line1B, line2A, line2B, out hitPoint, out resB))
            {
                if ((resB - hitPoint).sqrMagnitude <= Mathf.Epsilon * Mathf.Epsilon)
                    return true;
            }
            return false;
        }

        public static bool LineLineIntersect(Vector2 line1A, Vector2 line1B, Vector2 line2A, Vector2 line2B, out Vector2 hitPoint, bool segmentOnly = true)
        {
            hitPoint = Vector2.zero;
            // Denominator for ua and ub are the same, so store this calculation
            double d =
               (line2B.y - line2A.y) * (line1B.x - line1A.x)
               -
               (line2B.x - line2A.x) * (line1B.y - line1A.y);

            //n_a and n_b are calculated as seperate values for readability
            double n_a =
               (line2B.x - line2A.x) * (line1A.y - line2A.y)
               -
               (line2B.y - line2A.y) * (line1A.x - line2A.x);

            double n_b =
               (line1B.x - line1A.x) * (line1A.y - line2A.y)
               -
               (line1B.y - line1A.y) * (line1A.x - line2A.x);

            // Make sure there is not a division by zero - this also indicates that
            // the lines are parallel.  
            // If n_a and n_b were both equal to zero the lines would be on top of each 
            // other (coincidental).  This check is not done because it is not 
            // necessary for this implementation (the parallel check accounts for this).
            if (d == 0)
                return false;

            // Calculate the intermediate fractional point that the lines potentially intersect.
            double ua = n_a / d;
            double ub = n_b / d;

            // The fractional point will be between 0 and 1 inclusive if the lines
            // intersect.  If the fractional calculation is larger than 1 or smaller
            // than 0 the lines would need to be longer to intersect.
            if (!segmentOnly || (ua >= 0d && ua <= 1d && ub >= 0d && ub <= 1d))
            {
                hitPoint.Set((float)(line1A.x + (ua * (line1B.x - line1A.x))), (float)(line1A.y + (ua * (line1B.y - line1A.y))));
                return true;
            }
            return false;
        }

        public static bool PointInsideTriangle(Vector3 A, Vector3 B, Vector3 C, Vector3 p, out float ac, out float ab, bool edgesAllowed)
        {
            Vector3 v0 = C - A;
            Vector3 v1 = B - A;
            Vector3 v2 = p - A;
            float dot00 = Vector3.Dot(v0, v0);
            float dot01 = Vector3.Dot(v0, v1);
            float dot02 = Vector3.Dot(v0, v2);
            float dot11 = Vector3.Dot(v1, v1);
            float dot12 = Vector3.Dot(v1, v2);
            float invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
            ac = (dot11 * dot02 - dot01 * dot12) * invDenom;
            ab = (dot00 * dot12 - dot01 * dot02) * invDenom;
            if (edgesAllowed)
                return ac >= 0 && ab >= 0 && (ac + ab < 1);
            else
                return ac > 0 && ab > 0 && (ac + ab < 1);
        }
    }

    /// <summary>
    /// Extended UnityEvent
    /// </summary>
    public class UnityEventEx<T0> : UnityEvent<T0>
    {
        object mCallerList;
        MethodInfo mCallsCount;
        int mCount = -1;

        /// <summary>
        /// Removes and adds a listener, ensuring it's only bound once
        /// </summary>
        /// <param name="call"></param>
        public void AddListenerOnce(UnityAction<T0> call)
        {
            base.RemoveListener(call);
            base.AddListener(call);
            CheckForListeners();
        }

        /// <summary>
        /// Whether the event has any listeners at all
        /// </summary>
        /// <returns></returns>
        public bool HasListeners()
        {
            if (mCallsCount == null)
            {
                FieldInfo fi = typeof(UnityEventBase).FieldByName("m_Calls", false, true);
                if (fi != null)
                {
                    mCallerList = fi.GetValue(this);
                    if (mCallerList != null)
                        mCallsCount = mCallerList.GetType().PropertyByName("Count").GetGetMethod();
                }
            }
            if (mCount == -1)
            {
                if (mCallerList != null && mCallsCount != null)
                    mCount = (int)mCallsCount.Invoke(mCallerList, null); //.GetValue(mCallerList, null);
                mCount += GetPersistentEventCount();
            }
            return (mCount > 0);
        }

        /// <summary>
        /// Force HasListeners() to recheck for dynamically bound events
        /// </summary>
        public void CheckForListeners()
        {
            mCount = -1;
        }
    }

    /// <summary>
    /// Same functionality as various UnityEngine.Debug methods
    /// </summary>
    /// <remarks>Used to distinct between temporarly debug output and regular package output</remarks>
    public static class DTLog
    {
        public static void Log(object message)
        {
            Debug.Log(message);
        }

        public static void Log(object message, [CanBeNull] Object context)
        {
            Debug.Log(message, context);
        }

        public static void LogError(object message)
        {
            Debug.LogError(message);
        }

        public static void LogError(object message, [CanBeNull] Object context)
        {
            Debug.LogError(message, context);
        }

        public static void LogErrorFormat(string format, params object[] args)
        {
            Debug.LogErrorFormat(format, args);
        }

        public static void LogErrorFormat(UnityEngine.Object context, string format, params object[] args)
        {
            Debug.LogErrorFormat(context, format, args);
        }

        public static void LogException(Exception exception)
        {
            Debug.LogException(exception);
        }

        public static void LogException(Exception exception, [CanBeNull] Object context)
        {
            Debug.LogException(exception, context);
        }

        public static void LogFormat(string format, params object[] args)
        {
            Debug.LogFormat(format, args);
        }

        public static void LogFormat(UnityEngine.Object context, string format, params object[] args)
        {
            Debug.LogFormat(context, format, args);
        }

        public static void LogWarning(object message)
        {
            Debug.LogWarning(message);
        }

        public static void LogWarning(object message, [CanBeNull] Object context)
        {
            Debug.LogWarning(message, context);
        }

        public static void LogWarningFormat(string format, params object[] args)
        {
            Debug.LogWarningFormat(format, args);
        }

        public static void LogWarningFormat(Object context, string format, params object[] args)
        {
            Debug.LogWarningFormat(context, format, args);
        }
    }

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTUtility.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/PropertyAttributes.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eed9fb14b94dcae4e826c61c76e7e7b2
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;
using System;
using System.Reflection;

namespace FluffyUnderware.DevTools
{
    public enum DTMessageType
    {
        None = 0,
        Info = 1,
        Warning = 2,
        Error = 3,
    }

    public enum AttributeOptionsFlags : int
    {
        None = 0,
        Compact = 1,
        Clipboard = 128,
        Zero = 256,
        One = 512,
        Negate = 1024,
        Full = 1920,
        FullCompact = 1921
    }

    public class DTPropertyAttribute : PropertyAttribute
    {
        
        public string Label;
        public string Tooltip;
        public string Color;
        public AttributeOptionsFlags Options;
        public int Precision = -1;

        public DTPropertyAttribute(string label="", string tooltip = "")
        {
            Label = label;
            Tooltip = tooltip;
        }
    }

    public class LabelAttribute : DTPropertyAttribute
    {
        public LabelAttribute() : base() { }
        public LabelAttribute(string label, string tooltip = "") : base(label, tooltip) { }
    }

    public class ToggleButtonAttribute : DTPropertyAttribute
    {
        public ToggleButtonAttribute(string label = "", string tooltip = "") : base(label, tooltip)
        {
        }
    }

    public class LayerAttribute : DTPropertyAttribute
    {
        public LayerAttribute(string label = "", string tooltip = "")
            : base(label, tooltip)
        {
        }
    }

    public class TagAttribute : DTPropertyAttribute
    {
        public TagAttribute(string label = "", string tooltip = "")
            : base(label, tooltip)
        {
        }
    }

    public class VectorExAttribute : DTPropertyAttribute
    {
        public VectorExAttribute(string label = "", string tooltip = "") : base(label, tooltip)
        {
            Options = AttributeOptionsFlags.Full;
        }
    }

    public class AnimationCurveExAttribute : DTPropertyAttribute
    {
        public AnimationCurveExAttribute(string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            Options = AttributeOptionsFlags.Clipboard;
        }
    }

    public class MinAttribute : DTPropertyAttribute
    {
        public float MinValue;
        public string MinFieldOrPropertyName;

        public MinAttribute(float value, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MinValue = value;
        }

        public MinAttribute(string fieldOrProperty, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MinFieldOrPropertyName = fieldOrProperty;
        }
    }

    public class PositiveAttribute : MinAttribute
    {
        public PositiveAttribute() : base(0) { }
    }

    public class MaxAttribute : DTPropertyAttribute
    {
        public float MaxValue;
        public string MaxFieldOrPropertyName;

        public MaxAttribute(float value, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MaxValue = value;
        }

        public MaxAttribute(string fieldOrProperty, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MaxFieldOrPropertyName = fieldOrProperty;
        }
    }

    public class RangeExAttribute : DTPropertyAttribute
    {
        public float MinValue;
        public string MinFieldOrPropertyName;
        public float MaxValue;
        public string MaxFieldOrPropertyName;
        public bool Slider=true;

        public RangeExAttribute(float minValue, float maxValue, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MinValue = minValue;
            MaxValue = maxValue;
        }

        public RangeExAttribute(string minFieldOrProperty, float maxValue, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MinFieldOrPropertyName = minFieldOrProperty;
            MaxValue = maxValue;
        }

        public RangeExAttribute(float minValue, string  maxFieldOrProperty, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MinValue = minValue;
            MaxFieldOrPropertyName = maxFieldOrProperty;
        }

        public RangeExAttribute(string minFieldOrProperty, string maxFieldOrProperty, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MinFieldOrPropertyName = minFieldOrProperty;
            MaxFieldOrPropertyName = maxFieldOrProperty;
        }

    }

    public class MinMaxAttribute : DTPropertyAttribute
    {
        public readonly string MaxValueField;
        public float Min;
        public string MinBoundFieldOrPropertyName;
        public float Max;
        public string MaxBoundFieldOrPropertyName;

        public MinMaxAttribute(string maxValueField, string label="", string tooltip="") : base(label, tooltip) 
        {
            MaxValueField = maxValueField;
            Min = 0;
            Max = 1;
        }
    }

    public class EnumFlagAttribute : DTPropertyAttribute
    {
        public EnumFlagAttribute(string label = "", string tooltip = "") : base(label,tooltip) { }
    }

    public class ObjectSelectorAttribute : DTPropertyAttribute
    {
        public ObjectSelectorAttribute(string label = "", string tooltip = "") : base(label, tooltip)
        { }
    }

    public class PathSelectorAttribute : DTPropertyAttribute
    {
        public enum DialogMode
        {
            OpenFile,
            OpenFolder,
            CreateFile
        }

        public readonly DialogMode Mode;
        public string Title;
        public string Directory;
        public string Extension;
        public string DefaultName;

        public PathSelectorAttribute(DialogMode mode=DialogMode.OpenFile)
        {
            Mode = mode;
            Directory = Application.dataPath;
        }
    }

    public class EnumSelectionGridAttribute : DTPropertyAttribute
    {
        public EnumSelectionGridAttribute(string label="",string tooltip="") : base(label,tooltip) { }
    }

    public class DTRegionAttribute : DTPropertyAttribute
    {
        public bool RegionIsOptional;
        public string RegionOptionsPropertyName;
        public bool UseSlider=true;
    }

    public class FloatRegionAttribute : DTRegionAttribute { }
    public class IntRegionAttribute : DTRegionAttribute { }

    public struct RegionOptions<T>
    {
        public string LabelFrom;
        public string LabelTo;
        public string OptionalTooltip;
        public DTValueClamping ClampFrom;
        public DTValueClamping ClampTo;
        public T FromMin;
        public T FromMax;
        public T ToMin;
        public T ToMax;

        public static RegionOptions<T> Default
        {
            get
            {
                return new RegionOptions<T>
                {
                    OptionalTooltip = "Range",
                    LabelFrom= "From",
                    LabelTo= "To",
                    ClampFrom = DTValueClamping.None,
                    ClampTo = DTValueClamping.None
                };
            }
        }

        public static RegionOptions<T> MinMax(T min, T max)
        {
            return new RegionOptions<T>
            {
                LabelFrom = "From",
                LabelTo = "To",
                ClampFrom = DTValueClamping.Range,
                ClampTo = DTValueClamping.Range,
                FromMin=min,
                FromMax=max,
                ToMin=min,
                ToMax=max
            };
            
        }
    }

    public enum DTValueClamping
    {
        None = 0,
        Min = 1,
        Max = 2,
        Range = 3
    }

    
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/PropertyAttributes.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/ThreadPoolWorker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a997f755ef82a3e439a530a09753ae2f
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;
using System;
using System.Collections.Generic;
using System.Linq;
#if ENABLE_IL2CPP == false
using System.Linq.Expressions;
#endif
using System.Runtime.CompilerServices;
using UnityEngine.Assertions;
#if !UNITY_WSA && !UNITY_WEBGL
using System.Threading;
#endif

namespace FluffyUnderware.DevTools
{
    /// <summary>
    /// A class to execute actions in a multi-threaded way
    /// </summary>
    /// <typeparam name="T">The type of the action input</typeparam>
    public class ThreadPoolWorker<T> : IDisposable
    {
        //TODO OPTIM Is ThreadPoolWorker still needed. Aren't all unity version handling .Net's parallel fors now?
#if !UNITY_WSA && !UNITY_WEBGL
        private readonly SimplePool<QueuedCallback> queuedCallbackPool = new SimplePool<QueuedCallback>(4);
        private readonly SimplePool<LoopState<T>> loopStatePool = new SimplePool<LoopState<T>>(4);

        private int _remainingWorkItems = 1;
        private ManualResetEvent _done = new ManualResetEvent(false);
        private readonly WaitCallback handleWorkItemCallBack;
        private readonly WaitCallback handleLoopCallBack;

        public ThreadPoolWorker()
        {
            handleWorkItemCallBack = o =>
            {
                QueuedCallback queuedCallback = (QueuedCallback)o;
                try
                {
                    queuedCallback.Callback(queuedCallback.State);
                }
                finally
                {
                    lock (queuedCallbackPool)
                        queuedCallbackPool.ReleaseItem(queuedCallback);
                    DoneWorkItem();
                }
            };

            handleLoopCallBack = state =>
            {
                LoopState<T> loopS = (LoopState<T>)state;
                for (int i = loopS.StartIndex; i <= loopS.EndIndex; i++)
                {
                    loopS.Action(loopS.Items.ElementAt(i), i, loopS.ItemsCount);
                }
                lock (loopStatePool)
                    loopStatePool.ReleaseItem(loopS);
            };
        }

        [Obsolete("Use ParallelFor(Action<T,int,int> action, IEnumerable<T> list) instead")]
        public void ParralelFor(Action<T> action, List<T> list)
        {
            ParallelFor((item, itemIndex, itemsCount) => action(item), list, list.Count());
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ParallelFor(Action<T, int, int> action, IEnumerable<T> list)
        {
            ParallelFor(action, list, list.Count());
        }

        public void ParallelFor(Action<T, int, int> action, IEnumerable<T> list, int elementsCount)
        {
            int threadsToUseCount;
            {
                int availableThreads;
#if NET_4_6
                int temp;
                ThreadPool.GetAvailableThreads(out availableThreads, out temp);
#else
                availableThreads = Environment.ProcessorCount - 1;
#endif
                threadsToUseCount = 1 /*main thread*/ + Math.Min(availableThreads, Environment.ProcessorCount - 1 /*keep one processor for the main thead*/);
            }
            //BUG a bug in iterationPerThread leads to sometimes not using all available threads. For example, if you have 5 items and 4 cores, only 3 cores will be used
            int iterationPerThread = threadsToUseCount == 1
                ? elementsCount
                : (int)Math.Ceiling((float)elementsCount / threadsToUseCount);
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(iterationPerThread * threadsToUseCount >= elementsCount);
#endif
            int currentIndex = 0;
            while (currentIndex < elementsCount)
            {
                int endEndex = Math.Min(currentIndex + iterationPerThread - 1, elementsCount - 1);

                if (endEndex == elementsCount - 1)
                    for (int i = currentIndex; i <= endEndex; i++)
                        action(list.ElementAt(i), i, elementsCount);
                else
                {

                    QueuedCallback queuedCallback;
                    {
                        lock (queuedCallbackPool)
                            queuedCallback = queuedCallbackPool.GetItem();
                    }


                    LoopState<T> loopState;
                    {
                        lock (loopStatePool)
                            loopState = loopStatePool.GetItem();
                    }

                    loopState.Set((short)currentIndex,
                        (short)endEndex,
                        list,
                        elementsCount,
                        action);

                    queuedCallback.State = loopState;
                    queuedCallback.Callback = handleLoopCallBack;

                    ThrowIfDisposed();
                    //Debug.LogWarning("New thread " + " from "+ loopState.StartIndex +  " to " + loopState.EndIndex);
                    lock (_done)
                        _remainingWorkItems++;
                    ThreadPool.QueueUserWorkItem(handleWorkItemCallBack, queuedCallback);
                }
                currentIndex = endEndex + 1;
            }

            WaitAll(-1, false);
        }

        bool WaitAll(int millisecondsTimeout, bool exitContext)
        {
            ThrowIfDisposed();
            DoneWorkItem();
            bool rv = _done.WaitOne(millisecondsTimeout, exitContext);
            lock (_done)
            {
                if (rv)
                {
                    _remainingWorkItems = 1;
                    _done.Reset();
                }
                else
                    _remainingWorkItems++;
            }
            return rv;
        }

        private void ThrowIfDisposed()
        {
            if (_done == null)
                throw new ObjectDisposedException(GetType().Name);
        }

        private void DoneWorkItem()
        {
            lock (_done)
            {
                --_remainingWorkItems;
                if (_remainingWorkItems == 0)
                    _done.Set();
            }
        }

        public void Dispose()
        {
            if (_done != null)
            {
                ((IDisposable)_done).Dispose();
                _done = null;
            }
        }
#else
        public ThreadPoolWorker()
        {
        }

        [Obsolete("Use ParallelFor(Action<T,int,int> action, IEnumerable<T> list) instead")]
        public void ParralelFor(Action<T> action, List<T> list)
        {
            for (var i = 0; i < list.Count; i++)
                action(list[i]);
        }

        public void ParallelFor(Action<T, int, int> action, IEnumerable<T> list)
        {
            ParallelFor(action, list, list.Count());
        }

        public void ParallelFor(Action<T, int, int> action, IEnumerable<T> list, int elementsCount)
        {
            for (int i = 0; i < elementsCount; i++)
                action(list.ElementAt(i), i, elementsCount);
        }

        public void Dispose()
        {
        }
#endif
    }

    internal class SimplePool<T> where T : new()
    {
        private readonly List<T> freeItemsBackfield;
#if ENABLE_IL2CPP == false
        private static readonly Func<T> OptimizedInstantiator = Expression.Lambda<Func<T>>(
            Expression.New(typeof(T))
        ).Compile();
#endif

        public SimplePool(int preCreatedElementsCount)
        {
            freeItemsBackfield = new List<T>();
            for (int i = 0; i < preCreatedElementsCount; i++)
                freeItemsBackfield.Add(
#if ENABLE_IL2CPP == false
                    OptimizedInstantiator.Invoke()
#else
                    new T()
#endif
                    );
        }

        public T GetItem()
        {
            T item;
            if (freeItemsBackfield.Count == 0)
                item =
#if ENABLE_IL2CPP == false
                    OptimizedInstantiator.Invoke()
#else
                    new T()
#endif
                    ;
            else
            {
                int lastIndex = freeItemsBackfield.Count - 1;
                item = freeItemsBackfield[lastIndex];
                freeItemsBackfield.RemoveAt(lastIndex);
            }
            return item;
        }

        public void ReleaseItem(T item)
        {
            freeItemsBackfield.Add(item);
        }
    }

#if !UNITY_WSA && !UNITY_WEBGL
    class QueuedCallback
    {
        public WaitCallback Callback;
        public object State;
    }

    class LoopState<T>
    {
        public short StartIndex { get; private set; }
        public short EndIndex { get; private set; }
        public IEnumerable<T> Items { get; private set; }
        public int ItemsCount { get; private set; }
        public Action<T, int, int> Action { get; private set; }

        public LoopState()
        {
        }

        public LoopState(short startIndex, short endIndex, IEnumerable<T> items, int itemsCount, Action<T, int, int> action)
        {
            Set(startIndex, endIndex, items, itemsCount, action);
        }

        public void Set(short startIndex, short endIndex, IEnumerable<T> items, int itemsCount, Action<T, int, int> action)
        {
            StartIndex = startIndex;
            EndIndex = endIndex;
            Items = items;
            ItemsCount = itemsCount;
            Action = action;
        }
    }
#endif


    /// <summary>
    /// This class is not very optimized. For better performance, use the generic version of ThreadPoolWorker instead
    /// </summary>
#if !UNITY_WSA && !UNITY_WEBGL
    [Obsolete("Use ThreadPoolWorker<T> instead")]
    public class ThreadPoolWorker : IDisposable
    {
        private int _remainingWorkItems = 1;
        private ManualResetEvent _done = new ManualResetEvent(false);

        public void QueueWorkItem(WaitCallback callback)
        {
            QueueWorkItem(callback, null);
        }

        public void QueueWorkItem(Action act)
        {
            QueueWorkItem(act, null);
        }

        public void ParralelFor<T>(Action<T> action, List<T> list)
        {
            int threadsToUseCount;
            {
                int availableThreads;
#if NET_4_6
                int temp;
                ThreadPool.GetAvailableThreads(out availableThreads, out temp);
#else
                availableThreads = Environment.ProcessorCount - 1;
#endif
                threadsToUseCount = 1 /*main thread*/ + Math.Min(availableThreads, Environment.ProcessorCount - 1 /*keep one processor for the main thead*/);
            }
            int iterationsCount = list.Count;
            if (threadsToUseCount == 1 || iterationsCount == 1)
            {
                for (int i = 0; i < iterationsCount; i++)
                {
                    action(list[i]);
                }
            }
            else
            {
                int iterationPerThread = (int)Math.Ceiling((float)iterationsCount / threadsToUseCount);
                int currentIndex = 0;
                while (currentIndex < iterationsCount)
                {
                    QueuedCallback queuedCallback = new QueuedCallback();

                    int endEndex = Math.Min(currentIndex + iterationPerThread, iterationsCount - 1);

                    LoopState<T> loopState = new LoopState<T>((short)currentIndex,
                        (short)endEndex,
                        list,
                        iterationsCount,
                        (item,
                            itemIndex,
                            itemsCount) => action(item));
                    queuedCallback.State = loopState;

                    queuedCallback.Callback = state =>
                    {
                        LoopState<T> loopS = (LoopState<T>)state;
                        for (int i = loopS.StartIndex; i <= loopS.EndIndex; i++)
                        {
                            loopS.Action(loopS.Items.ElementAt(i), i, iterationsCount);
                        }
                    };


                    QueueWorkItem(queuedCallback);

                    currentIndex = endEndex + 1;
                }
            }
        }

        private void QueueWorkItem(QueuedCallback callback)
        {
            ThrowIfDisposed();
            lock (_done)
                _remainingWorkItems++;
            ThreadPool.QueueUserWorkItem(new WaitCallback(HandleWorkItem), callback);
        }

        public void QueueWorkItem(WaitCallback callback, object state)
        {
            QueuedCallback qc = new QueuedCallback();
            qc.Callback = callback;
            qc.State = state;
            QueueWorkItem(qc);
        }

        public void QueueWorkItem(Action act, object state)
        {
            QueuedCallback qc = new QueuedCallback();
            qc.Callback = (x => act());
            qc.State = state;
            QueueWorkItem(qc);
        }

        public bool WaitAll()
        {
            return WaitAll(-1, false);
        }

        public bool WaitAll(TimeSpan timeout, bool exitContext)
        {
            return WaitAll((int)timeout.TotalMilliseconds, exitContext);
        }

        public bool WaitAll(int millisecondsTimeout, bool exitContext)
        {
            ThrowIfDisposed();
            DoneWorkItem();
            bool rv = _done.WaitOne(millisecondsTimeout, exitContext);
            lock (_done)
            {
                if (rv)
                {
                    _remainingWorkItems = 1;
                    _done.Reset();
                }
                else
                    _remainingWorkItems++;
            }
            return rv;
        }

        private void HandleWorkItem(object state)
        {
            QueuedCallback qc = (QueuedCallback)state;
            try
            {
                qc.Callback(qc.State);
            }
            finally
            {
                DoneWorkItem();
            }
        }

        private void DoneWorkItem()
        {
            lock (_done)
            {
                --_remainingWorkItems;
                if (_remainingWorkItems == 0)
                    _done.Set();
            }
        }

        private void ThrowIfDisposed()
        {
            if (_done == null)
                throw new ObjectDisposedException(GetType().Name);
        }

        public void Dispose()
        {
            if (_done != null)
            {
                ((IDisposable)_done).Dispose();
                _done = null;
            }
        }
    }
#else
    public class ThreadPoolWorker{}
#endif

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/ThreadPoolWorker.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/ComponentPool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 62f98941b92097f49bd5ff480ec47122
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.DevTools.Extensions;
#if CURVY_SANITY_CHECKS_PRIVATE
using UnityEngine.Assertions;
#endif
using UnityEngine.SceneManagement;

namespace FluffyUnderware.DevTools
{
    /// <summary>
    /// A pool of instances of the UnityEngine.Component class
    /// </summary>
    [HelpURL(DTUtility.HelpUrlBase + "dtcomponentpool")]
    public class ComponentPool : DTVersionedMonoBehaviour, IPool, ISerializationCallbackReceiver
    {
        [SerializeField, HideInInspector]
        private string m_Identifier;

        [Inline]
        [SerializeField]
        private PoolSettings m_Settings;

        public PoolSettings Settings
        {
            get { return m_Settings; }
            set
            {
                if (m_Settings != value)
                    m_Settings = value;
                if (m_Settings != null)
                    m_Settings.OnValidate();
            }
        }

        private PoolManager mManager;

        public PoolManager Manager
        {
            get
            {
                if (mManager == null)
                    mManager = GetComponent<PoolManager>();
                return mManager;
            }
        }

        /// <summary>
        /// Due to bad design decisions, Identifier is used to store the type of the pooled objects. And the setter does nothing
        /// </summary>
        public string Identifier
        {
            get
            {
#if CURVY_SANITY_CHECKS_PRIVATE
                Assert.IsNotNull(m_Identifier);
#endif
                return m_Identifier;
            }
            set
            {
                throw new InvalidOperationException("Component pool's identifier should always indicate the pooled type's assembly qualified name");
                /*Here is why:
                In the Initialize method, m_Identifier is set as a fully qualified type name.
                The Type getter uses m_Identifier as a fully qualified type name.
                If needed, add a field that contains the pooled type name, and use it instead of Identifier when you need to find the right pool for the right component type*/
            }
        }

        /// <summary>
        /// The type of the pooled objects
        /// </summary>
        public Type Type
        {
            get
            {
                Type type = Type.GetType(Identifier);
                if (type == null)
                    DTLog.LogWarning("[DevTools] ComponentPool's Type is an unknown type " + m_Identifier, this);
                return type;
            }
        }


        public int Count
        {
            get { return mObjects.Count; }
        }

        private readonly List<Component> mObjects = new List<Component>();

        private double mLastTime;
        private double mDeltaTime;

        public void Initialize(Type type, PoolSettings settings)
        {
            m_Identifier = type.AssemblyQualifiedName;
#if CURVY_SANITY_CHECKS_PRIVATE
            Assert.IsNotNull(m_Identifier);
#endif
            m_Settings = settings;
            mLastTime = DTTime.TimeSinceStartup + UnityEngine.Random.Range(0, Settings.Speed);
            if (Settings.Prewarm)
                Reset();
        }

        private void Start()
        {
            if (Settings.Prewarm)
                Reset();
        }

#if UNITY_EDITOR
        private void OnValidate()
        {
            Settings = m_Settings;
        }
#endif

        private void OnEnable()
        {
            SceneManager.sceneLoaded += OnSceneLoaded;
        }

        public void Update()
        {
            if (Application.isPlaying)
            {
                mDeltaTime += DTTime.TimeSinceStartup - mLastTime;
                mLastTime = DTTime.TimeSinceStartup;

                if (Settings.Speed > 0)
                {
                    int c = (int)(mDeltaTime / Settings.Speed);
                    mDeltaTime -= c;

                    if (Count > Settings.Threshold)
                    {
                        c = Mathf.Min(c, Count - Settings.Threshold);
                        while (c-- > 0)
                        {
                            if (Settings.Debug)
                                log("Threshold exceeded: Deleting item");
                            destroy(mObjects[0]);
                            mObjects.RemoveAt(0);
                        }
                    }
                    else if (Count < Settings.MinItems)
                    {
                        c = Mathf.Min(c, Settings.MinItems - Count);
                        while (c-- > 0)
                        {
                            if (Settings.Debug)
                                log("Below MinItems: Adding item");
                            mObjects.Add(create());
                        }
                    }
                }
                else
                    mDeltaTime = 0;
            }
        }

        public void Reset()
        {
            if (Application.isPlaying)
            {
                while (Count < Settings.MinItems)
                {
                    mObjects.Add(create());
                }
                while (Count > Settings.Threshold)
                {
                    destroy(mObjects[0]);
                    mObjects.RemoveAt(0);
                }
                if (Settings.Debug)
                    log("Prewarm/Reset");
            }
        }

        public void OnSceneLoaded(Scene scn, LoadSceneMode mode)
        {
            for (int i = mObjects.Count - 1; i >= 0; i--)
                if (mObjects[i] == null)
                    mObjects.RemoveAt(i);
        }

        public void Clear()
        {
            if (Settings.Debug)
                log("Clear");
            for (int i = 0; i < Count; i++)
                destroy(mObjects[i]);
            mObjects.Clear();
        }

        public void Push(Component item)
        {
            sendBeforePush(item);
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                item.gameObject.Destroy(false, true);
            }
            else
#endif
                if (item != null)
            {
                mObjects.Add(item);
                item.transform.parent = Manager.transform;
                item.gameObject.hideFlags = (Settings.Debug)
                    ? HideFlags.DontSave
                    : HideFlags.HideAndDontSave;
                if (Settings.AutoEnableDisable)
                    item.gameObject.SetActive(false);
            }
        }

        public Component Pop(Transform parent = null)
        {
            Component item = null;
            if (Count > 0)
            {
                item = mObjects[0];
                mObjects.RemoveAt(0);
            }
            else
            {
                if (Settings.AutoCreate || !Application.isPlaying)
                {
                    if (Settings.Debug)
                        log("Auto create item");
                    item = create();
                }
            }
            if (item)
            {
                item.gameObject.hideFlags = HideFlags.None;
                item.transform.parent = parent;
                if (Settings.AutoEnableDisable)
                    item.gameObject.SetActive(true);
                sendAfterPop(item);
                if (Settings.Debug)
                    log("Pop " + item);
            }

            return item;
        }

        public T Pop<T>(Transform parent) where T : Component
        {
            return Pop(parent) as T;
        }

        private Component create()
        {
            GameObject go = new GameObject();
            go.name = Identifier;
            go.transform.parent = Manager.transform;
            if (Settings.AutoEnableDisable)
                go.SetActive(false);
            Type componentType = Type;
            Component component = null;
            if (componentType != null)
                component = go.AddComponent(componentType);
            else
                DTLog.LogError(String.Format("[DevTools] ComponentPool {0} could not create component because the associated type is null", m_Identifier), this);
            return component;
        }

        private void destroy(Component item)
        {
            if (item != null)
                item.gameObject.Destroy(false, true);
        }

        private void setParent(Component item, Transform parent)
        {
            if (item != null)
                item.transform.parent = parent;
        }

        private void sendAfterPop(Component item)
        {
            GameObject itemGameObject = item.gameObject;
            if (itemGameObject.activeSelf && itemGameObject.activeInHierarchy)
                //Send message works only for active game objects. Source: https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html
                itemGameObject.SendMessage(nameof(IPoolable.OnAfterPop), SendMessageOptions.DontRequireReceiver);
            else
            {
                if (item is IPoolable)
                    ((IPoolable)item).OnAfterPop();
                else
                    DTLog.LogWarning("[Curvy] sendAfterPop could not send message because the receiver " + item.name + " is not active", this);
            }
        }

        private void sendBeforePush(Component item)
        {
            GameObject itemGameObject = item.gameObject;
            if (itemGameObject.activeSelf && itemGameObject.activeInHierarchy)
                //Send message works only for active game objects. Source: https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html
                itemGameObject.SendMessage(nameof(IPoolable.OnBeforePush), SendMessageOptions.DontRequireReceiver);
            else
            {
                if (item is IPoolable)
                    ((IPoolable)item).OnBeforePush();
                else
                    DTLog.LogWarning("[Curvy] sendBeforePush could not send message because the receiver " + item.name + " is not active", this);
            }
        }

        private void log(string msg)
        {
            Debug.Log(string.Format("[{0}] ({1} items) {2}", Identifier, Count, msg));
        }

        #region ISerializationCallbackReceiver
        /*! \cond PRIVATE */
        /// <summary>
        /// Implementation of UnityEngine.ISerializationCallbackReceiver
        /// Called automatically by Unity, is not meant to be called by Curvy's users
        /// </summary>
        public void OnBeforeSerialize()
        {
        }

        /// <summary>
        /// Implementation of UnityEngine.ISerializationCallbackReceiver
        /// Called automatically by Unity, is not meant to be called by Curvy's users
        /// </summary>
        public void OnAfterDeserialize()
        {
            if (Type.GetType(m_Identifier) == null)
            {

                //Handles cases where the component is migrated to another assembly (for example if using Unity's Assembly Definitions feature

                const char separator = ',';
                const string separatorString = ",";
                string[] splittedAssemblyQualifiedName = m_Identifier.Split(separator);
                if (splittedAssemblyQualifiedName.Length >= 5)
                {
                    string typeName = String.Join(separatorString, splittedAssemblyQualifiedName.SubArray(0, splittedAssemblyQualifiedName.Length - 4));
                    //As you can see with this example: 
                    //"FluffyUnderware.Curvy.CurvySplineSegment, ToolBuddy.Curvy, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null"
                    //the 4 last elements do not contain the type name. Keep in mind that a type name can include a ',' like  Dictionary<int, List<double>>

#if UNITY_EDITOR
                    var knownTypes = UnityEditor.TypeCache.GetTypesDerivedFrom(typeof(System.Object));
#else

                    Type[] knownTypes = TypeExt.GetLoadedTypes();

#endif
                    Type type = knownTypes.FirstOrDefault(t => t.FullName == typeName);
                    if (type != null)
                    {
                        m_Identifier = type.AssemblyQualifiedName;
#if CURVY_SANITY_CHECKS_PRIVATE
                        Assert.IsNotNull(m_Identifier);
#endif
                    }
                }
            }
        }
        /*! \endcond */
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/ComponentPool.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DTSingleton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: be97567edb4b04d4b864736d9e10f36f
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.DevTools.Extensions;
using UnityEngine;

namespace FluffyUnderware.DevTools
{

    public class DTSingleton<T> : MonoBehaviour, IDTSingleton where T : MonoBehaviour, IDTSingleton
    {
        static T _instance;
        static readonly object _lock = new object();
        static bool applicationIsQuitting = false;
        bool isDuplicateInstance = false;

        public static bool HasInstance
        {
            get { return _instance != null; }
        }

        public static T Instance
        {
            get
            {
                if (!Application.isPlaying)
                    applicationIsQuitting = false;
                if (applicationIsQuitting)
                    return null;

                if (_instance == null)
                    lock (_lock)
                        if (_instance == null)
                        {
                            IEnumerable<Object> objectsOfTypeT = FindObjectsOfType(typeof(T)).Where(o => o != null);
#if CURVY_SANITY_CHECKS
                            if (objectsOfTypeT.Count() != FindObjectsOfType(typeof(T)).Length)
                                DTLog.LogError("[Curvy] DTSingleton.Instance : FindObjectsOfType " + typeof(T).FullName + " returned at least one null reference");
#endif                              

                            _instance = objectsOfTypeT.Any()
                                ? (T)objectsOfTypeT.ElementAt(0)
                                : new GameObject().AddComponent<T>();
                        }

                return _instance;
            }
        }

        public virtual void Awake()
        {
            T instance = Instance;
            lock (_lock)
            {
                if (instance == null)
                    DTLog.LogError("[DevTools] DTSingleton instance was null. This happens if the instance is destroyed by the user, which is not a supported operation. If you did not destroy the singleton's instance, then please fill a bug report.", this);
                else
                    if (GetInstanceID() != instance.GetInstanceID())
                    {
                        instance.MergeDoubleLoaded((IDTSingleton)this);
                        this.isDuplicateInstance = true;
                        this.Invoke(nameof(DestroySelf), 0);
                    }
            }
        }

        protected virtual void OnDestroy()
        {
            lock (_lock)
                if (Application.isPlaying && !isDuplicateInstance)
                {
                    applicationIsQuitting = true;
                    _instance = null;
                }
        }

        public virtual void MergeDoubleLoaded(IDTSingleton newInstance)
        {
        }

        void DestroySelf()
        {
            gameObject.Destroy(false, true);
        }

    }

    public interface IDTSingleton
    {
        void MergeDoubleLoaded(IDTSingleton newInstance);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DTSingleton.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DTVersionedMonoBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b3c2cf93621e06d43b51fbde3128ce03
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools.Extensions;

namespace FluffyUnderware.DevTools
{
    /// <summary>
    /// A MonoBehaviour with a version number, useful to handle upgrades if needed
    /// </summary>
    public abstract class DTVersionedMonoBehaviour : MonoBehaviour
    {
        [SerializeField, HideInInspector]
        string m_Version;

        /// <summary>
        /// Gets the version of this component
        /// </summary>
        public string Version
        {
            get { return m_Version; }
            protected set { m_Version = value; }
        }

        /// <summary>
        /// Destroys the gameobject
        /// </summary>
        [Obsolete("Use ObjectExt.Destroy(...) instead")]
        public void Destroy()
        {
            gameObject.Destroy(false, true);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DTVersionedMonoBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DuplicateEditorMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a648044f27666564a9cf38d201465713
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;


namespace FluffyUnderware.DevTools
{
    /// <summary>
    /// Add this script to a GameObject with a MeshFilter to ensure it will be properly duplicated in the editor!
    /// </summary>
    /// <remarks>On Duplicating, Awake() checks if the sharedMesh is already used in the scene. If yes, a new mesh will be created to ensure that each sharedMesh is unique</remarks>
    [ExecuteAlways]
    [RequireComponent(typeof(MeshFilter))]
    public abstract class DuplicateEditorMesh : DTVersionedMonoBehaviour
    {
        MeshFilter mFilter;

        public MeshFilter Filter
        {
            get {
                if (mFilter == null)
                    mFilter = GetComponent<MeshFilter>();
                return mFilter; 
            }
        }

        protected virtual void Awake()
        {
            if (!Application.isPlaying)
            {
                MeshFilter meshFilter = Filter;
                if (meshFilter && meshFilter.sharedMesh != null)
                {
                    DuplicateEditorMesh[] otherWatchdogs = GameObject.FindObjectsOfType<DuplicateEditorMesh>();
                    foreach (DuplicateEditorMesh dog in otherWatchdogs)
                    {
                        if (dog != this)
                        {
                            MeshFilter otherMF = dog.Filter;
                            if (otherMF && otherMF.sharedMesh == meshFilter.sharedMesh)
                            {
                                Mesh m = new Mesh();
                                m.name = otherMF.sharedMesh.name;
                                meshFilter.mesh = m;
                            }
                        }
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DuplicateEditorMesh.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/InspectorNote.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eed5f71264f54224aaf071d6a2e69915
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;

namespace FluffyUnderware.DevTools
{
    /// <summary>
    /// A component to display notes in the inspector
    /// </summary>
    [HelpURL(DTUtility.HelpUrlBase + "dtinspectornode")]
    public class InspectorNote : DTVersionedMonoBehaviour
    {

        [TextArea(5,20)]
        [SerializeField]
        string m_Note;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/InspectorNote.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/PoolManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3d8a3277e999b164d99f199328dc5d2d
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;

namespace FluffyUnderware.DevTools
{
    /// <summary>
    /// Manages the object's pools components
    /// </summary>
    [HelpURL(DTUtility.HelpUrlBase + "dtpoolmanager")]
    [ExecuteAlways]
    [DisallowMultipleComponent]
    public class PoolManager : DTVersionedMonoBehaviour
    {
        [Section("General")]
        [SerializeField]
        bool m_AutoCreatePools = true;

        [AsGroup(Expanded = false)]
        [SerializeField]
        PoolSettings m_DefaultSettings = new PoolSettings();

        public bool AutoCreatePools
        {
            get { return m_AutoCreatePools; }
            set
            {
                if (m_AutoCreatePools != value)
                    m_AutoCreatePools = value;
            }
        }

        public PoolSettings DefaultSettings
        {
            get { return m_DefaultSettings; }
            set
            {
                if (m_DefaultSettings != value)
                    m_DefaultSettings = value;
                if (m_DefaultSettings != null)
                    m_DefaultSettings.OnValidate();
            }
        }

        public bool IsInitialized { get; private set; }
        public int Count { get { return Pools.Count + TypePools.Count; } }

        public Dictionary<string, IPool> Pools = new Dictionary<string, IPool>();

        public Dictionary<Type, IPool> TypePools = new Dictionary<Type, IPool>();

        IPool[] mPools = new IPool[0];

#if UNITY_EDITOR
        void OnValidate()
        {
            DefaultSettings = m_DefaultSettings;
        }
#endif

        void OnDisable()
        {
            IsInitialized = false;
        }

        void Update()
        {
            bool initialize;
#if UNITY_EDITOR
            //this forces the pool manager to initialize every frame. Not a good idea.
            //I assume it was done to force the checks done in the Initialize method to be executed every frame, to handle pools duplication for example.
            //A better way to do this would be to separate initialization with checks, and execute the checks only when needed
            initialize = !Application.isPlaying;
#else
            initialize = !IsInitialized;
#endif
            if (initialize)
                Initialize();

            if (mPools.Length != TypePools.Count)
            {
                System.Array.Resize(ref mPools, TypePools.Count);
                TypePools.Values.CopyTo(mPools, 0);
            }
            for (int i = 0; i < mPools.Length; i++)
                mPools[i].Update();
        }

        void Initialize()
        {
            Pools.Clear();
            IPool[] goPools = GetComponents<IPool>();
            foreach (IPool p in goPools)
            {
                if (p is ComponentPool)
                {
                    if (Pools.ContainsKey(p.Identifier) == false)
                        Pools.Add(p.Identifier, p);
                    else
                    {
                        DTLog.Log("[DevTools] Found a duplicated ComponentPool for type " + p.Identifier + ". The duplicated pool will be destroyed", this);
                        (p as ComponentPool).Destroy(false, false);
                    }
                }
                else
                {
                    p.Identifier = GetUniqueIdentifier(p.Identifier);
                    Pools.Add(p.Identifier, p);
                }
            }

            IsInitialized = true;
        }

        [NotNull]
        public string GetUniqueIdentifier([NotNull] string ident)
        {
            int num = 0;
            string id = ident;
            while (Pools.ContainsKey(id))
                id = ident + (++num).ToString();
            return id;
        }


        public Pool<T> GetTypePool<T>()
        {
            IPool res;
            if (!TypePools.TryGetValue(typeof(T), out res))
            {
                if (AutoCreatePools)
                {
                    res = CreateTypePool<T>();
                }
            }
            return (Pool<T>)res;
        }

        public ComponentPool GetComponentPool<T>() where T : Component
        {
            if (!IsInitialized)
                Initialize();
            IPool res;
            if (!Pools.TryGetValue(typeof(T).AssemblyQualifiedName, out res))
            {
                if (AutoCreatePools)
                {
                    res = CreateComponentPool<T>();
                }
            }
            return (ComponentPool)res;
        }

        public PrefabPool GetPrefabPool([NotNull] string identifier, params GameObject[] prefabs)
        {
            if (!IsInitialized)
                Initialize();
            IPool pool;
            if (!Pools.TryGetValue(identifier, out pool))
            {
                if (AutoCreatePools)
                    pool = CreatePrefabPool(identifier, null, prefabs);
            }
            return (PrefabPool)pool;
        }

        public Pool<T> CreateTypePool<T>(PoolSettings settings = null)
        {
            PoolSettings s = settings ?? new PoolSettings(DefaultSettings);
            IPool res;
            if (!TypePools.TryGetValue(typeof(T), out res))
            {
                res = new Pool<T>(s);
                TypePools.Add(typeof(T), res);
            }
            return (Pool<T>)res;
        }

        public ComponentPool CreateComponentPool<T>(PoolSettings settings = null) where T : Component
        {
            if (!IsInitialized)
                Initialize();
            PoolSettings s = settings ?? new PoolSettings(DefaultSettings);
            IPool res;
            if (!Pools.TryGetValue(typeof(T).AssemblyQualifiedName, out res))
            {
                res = gameObject.AddComponent<ComponentPool>();
                ((ComponentPool)res).Initialize(typeof(T), s);
                Pools.Add(res.Identifier, res);
            }
            return (ComponentPool)res;
        }

        public PrefabPool CreatePrefabPool([NotNull] string name, PoolSettings settings = null, params GameObject[] prefabs)
        {
            if (!IsInitialized)
                Initialize();
            PoolSettings s = settings ?? new PoolSettings(DefaultSettings);

            IPool pool;
            if (!Pools.TryGetValue(name, out pool))
            {
                PrefabPool p = gameObject.AddComponent<PrefabPool>();
                p.Initialize(name, s, prefabs);
                Pools.Add(name, p);
                return p;
            }
            return (PrefabPool)pool;
        }

        public List<IPool> FindPools(string identifierStartsWith)
        {
            List<IPool> res = new List<IPool>();
            foreach (KeyValuePair<string, IPool> kv in Pools)
                if (kv.Key.StartsWith(identifierStartsWith))
                    res.Add(kv.Value);
            return res;
        }

        public void DeletePools(string startsWith)
        {
            List<IPool> toDelete = FindPools(startsWith);
            for (int i = toDelete.Count - 1; i >= 0; i--)
                DeletePool(toDelete[i]);

        }

        public void DeletePool(IPool pool)
        {
            if (pool is PrefabPool || pool is ComponentPool)
            {
                ((MonoBehaviour)pool).Destroy(false, false);
                Pools.Remove(pool.Identifier);
            }
        }

        public void DeletePool<T>()
        {
            TypePools.Remove(typeof(T));
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/PoolManager.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/PrefabPool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4f3bdfa960a223645a04f11686263106
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System.Collections;
using System;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;

namespace FluffyUnderware.DevTools
{
    /// <summary>
    /// A pool of instances of a prefab GameObject
    /// </summary>
    [RequireComponent(typeof(PoolManager))]
    [HelpURL(DTUtility.HelpUrlBase + "dtprefabpool")]
    public class PrefabPool : DTVersionedMonoBehaviour, IPool
    {
        [FieldCondition(nameof(m_Identifier), "", false, ActionAttribute.ActionEnum.ShowWarning, "Please enter an identifier! (Select a prefab to set automatically)")]
        [SerializeField]
        string m_Identifier = String.Empty;

        [SerializeField]
        List<GameObject> m_Prefabs = new List<GameObject>();

        [Inline]
        [SerializeField]
        PoolSettings m_Settings;



        PoolManager mManager;

        public string Identifier
        {
            get { return m_Identifier; }
            set
            {
                if (m_Identifier != value)
                {
                    m_Identifier = value;
                }
            }

        }
        public List<GameObject> Prefabs
        {
            get { return m_Prefabs; }
            set
            {
                if (m_Prefabs != value)
                    m_Prefabs = value;
            }
        }


        public PoolSettings Settings
        {
            get { return m_Settings; }
            set
            {
                if (m_Settings != value)
                    m_Settings = value;
                if (m_Settings != null)
                    m_Settings.OnValidate();
            }
        }

        [Obsolete("This member is no more used by Curvy Splines, and will get removed in a future update. Use GetComponent<PoolManager>() instead")]
        public PoolManager Manager
        {
            get
            {
                if (mManager == null)
                    mManager = GetComponent<PoolManager>();
                return mManager;
            }
        }

        List<GameObject> mObjects = new List<GameObject>();

        double mLastTime;
        double mDeltaTime;

        void Start()
        {
            if (Settings.Prewarm)
                Reset();
        }

#if UNITY_EDITOR
        void OnValidate()
        {
            Settings = m_Settings;
            if (m_Identifier == String.Empty && Prefabs.Any(p => p != null))
                Identifier = Prefabs.First().name;
        }
#endif

        public void Initialize([NotNull] string ident, PoolSettings settings, params GameObject[] prefabs)
        {
            Identifier = ident;
            m_Settings = settings;
            Prefabs = new List<GameObject>(prefabs);
            mLastTime = DTTime.TimeSinceStartup + UnityEngine.Random.Range(0, Settings.Speed);
            if (Settings.Prewarm)
                Reset();
        }

        public void Update()
        {
            if (Application.isPlaying)
            {
                mDeltaTime += DTTime.TimeSinceStartup - mLastTime;
                mLastTime = DTTime.TimeSinceStartup;

                if (Settings.Speed > 0)
                {
                    int c = (int)(mDeltaTime / Settings.Speed);
                    mDeltaTime -= c;

                    if (Count > Settings.Threshold)
                    {
                        c = Mathf.Min(c, Count - Settings.Threshold);
                        while (c-- > 0)
                        {
                            if (Settings.Debug)
                                log("Threshold exceeded: Deleting item");
                            destroy(mObjects[0]);
                            mObjects.RemoveAt(0);
                        }
                    }
                    else if (Count < Settings.MinItems)
                    {
                        c = Mathf.Min(c, Settings.MinItems - Count);
                        while (c-- > 0)
                        {
                            if (Settings.Debug)
                                log("Below MinItems: Adding item");
                            mObjects.Add(create());
                        }
                    }
                }
                else
                    mDeltaTime = 0;
            }
        }

        public void Reset()
        {
            if (Application.isPlaying)
            {
                while (Count < Settings.MinItems)
                {
                    mObjects.Add(create());
                }
                while (Count > Settings.Threshold)
                {
                    destroy(mObjects[0]);
                    mObjects.RemoveAt(0);
                }
                if (Settings.Debug)
                    log("Prewarm/Reset");
            }
        }

        public void Clear()
        {
            if (Settings.Debug)
                log("Clear");
            for (int i = 0; i < Count; i++)
                destroy(mObjects[i]);
            mObjects.Clear();
        }

        public int Count
        {
            get { return mObjects.Count; }
        }

        public GameObject Pop(Transform parent = null)
        {
            GameObject item = null;
            if (Count > 0)
            {
                item = mObjects[0];
                mObjects.RemoveAt(0);
            }
            else
            {
                if (Settings.AutoCreate || !Application.isPlaying)
                {
                    if (Settings.Debug)
                        log("Auto create item");
                    item = create();
                }
            }
            if (item)
            {
                item.hideFlags = HideFlags.None;
                item.transform.parent = parent;
                if (Settings.AutoEnableDisable)
                    item.SetActive(true);
                sendAfterPop(item);
                if (Settings.Debug)
                    log("Pop " + item);
            }

            return item;
        }

        public virtual void Push(GameObject item)
        {
            if (Settings.Debug)
                log("Push " + item);
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                item.Destroy(false, true);
            }
            else
#endif
            if (item != null)
            {
                sendBeforePush(item);
                mObjects.Add(item);
                item.transform.parent = transform;
                item.hideFlags = (Settings.Debug) ? HideFlags.DontSave : HideFlags.HideAndDontSave;
                if (Settings.AutoEnableDisable)
                    item.SetActive(false);
            }
        }

        GameObject create()
        {
            if (Prefabs.Count == 0)
                throw new InvalidOperationException(String.Format("[Curvy] The Prefab Pool '{0}' in game object '{1}' could not create a pool element because its Prefabs list is empty", this.Identifier, this.gameObject.name));

            //TODO should this Random.Range call be deterministic?
            GameObject prefab = Prefabs[UnityEngine.Random.Range(0, Prefabs.Count)];
            GameObject result;
            {
#if UNITY_EDITOR
                bool isPrefabAsset;
                //We have to check GetPrefabInstanceStatus first, because GetPrefabAssetType returns (as far as I understand) the same thing for both a prefab asset and a prefab instance
                if (PrefabUtility.GetPrefabInstanceStatus(prefab) == PrefabInstanceStatus.NotAPrefab)
                {
                    PrefabAssetType prefabAssetType = PrefabUtility.GetPrefabAssetType(prefab);
                    isPrefabAsset = prefabAssetType == PrefabAssetType.Regular || prefabAssetType == PrefabAssetType.Variant;
                }
                else
                    isPrefabAsset = false;

                result = isPrefabAsset
                    ? PrefabUtility.InstantiatePrefab(prefab) as GameObject
                    : Instantiate(prefab);
#else
                result = Instantiate(prefab);
#endif
            }

            result.name = prefab.name;
            result.transform.parent = transform;
            if (Settings.AutoEnableDisable)
                result.SetActive(false);
            return result;
        }

        void destroy(GameObject go)
        {
            go.Destroy(false, true);
        }

        void log(string msg)
        {
            Debug.Log(string.Format("[{0}] ({1} items) {2}", Identifier, Count, msg));
        }

        void setParent(Transform item, Transform parent)
        {
            if (item != null)
                item.parent = parent;
        }

        void sendAfterPop(GameObject item)
        {
            item.SendMessage(nameof(IPoolable.OnAfterPop), SendMessageOptions.DontRequireReceiver);
        }

        void sendBeforePush(GameObject item)
        {
            item.SendMessage(nameof(IPoolable.OnBeforePush), SendMessageOptions.DontRequireReceiver);
        }


    }


}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/PrefabPool.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Extensions/Extensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c750636a308f02746931c9fd1a75c27a
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================
using UnityEngine;
using System.Collections;
using System;
using System.Reflection;
using System.Collections.Generic;
using UnityEngine.Events;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System.Text;
using System.IO;
using System.Linq;
using Object = UnityEngine.Object;

namespace FluffyUnderware.DevTools.Extensions
{
    public static class AnimationCurveExt
    {
        /// <summary>
        /// Returns true if all the values on the curve are equal to 1
        /// </summary>
        public static bool ValueIsOne(this AnimationCurve curve)
        {
            bool result = true;

            const float comparisonMargin = 8 * Single.Epsilon; //Same margin as in Mathf.Approximately
            int keysLength = curve.keys.Length;
            for (int index = 0;
                 index < keysLength;
                 index++)
            {
                Keyframe k = curve.keys[index];

                if (k.inTangent != 0 ||
                    k.outTangent != 0 ||
                    Math.Abs(k.value - 1) > comparisonMargin)
                {
                    result = false;
                    break;
                }
            }

            return result;
        }
    }

    public static class ObjectExt
    {

        /// <summary>
        /// Calls the proper destruction method based on whether we are in Edit mode or not
        /// Will show a display dialogue if attempting to destroy a GameObject part of a prefab instance
        /// </summary>
        /// <param name="object">The object to destroy</param>
        [Obsolete("Use the other overload of this method")]
        public static bool Destroy(this UnityEngine.Object @object)
        {
            return Destroy(@object, true, true);
        }

        /// <summary>
        /// Calls the proper destruction method based on whether we are in Edit mode or not
        /// Will show a display dialogue if attempting to destroy a GameObject part of a prefab instance
        /// </summary>
        /// <param name="object">The object to destroy</param>
        /// <param name="isUndoable">Should the object destruction be undoable</param>
        /// <param name="doPrefabCheck">Should this method check that the object destruction is valid, i.e. not deleting a game object that is part of a prefab instance</param>
        public static bool Destroy(this UnityEngine.Object @object, bool isUndoable, bool doPrefabCheck)
        {
            bool wasDestroyed;

            bool isInEditMode = DTUtility.IsInEditMode;

            if (isInEditMode)
            {
#if UNITY_EDITOR
                string errorMessage = string.Empty;
                bool needsPrefabModification = doPrefabCheck && DTUtility.DoesPrefabStatusAllowDeletion(@object, out errorMessage) == false;
                if (needsPrefabModification)
                {
                    EditorUtility.DisplayDialog($"Cannot delete Game Object '{@object.name}'", errorMessage, "Ok");
                    DTLog.LogError("[Curvy] Invalid operation:" + errorMessage.Replace("\n", String.Empty), @object);

                    wasDestroyed = false;
                }
                else
                {
                    if (isUndoable)
                        Undo.DestroyObjectImmediate(@object);
                    else
                        Object.DestroyImmediate(@object);
                    wasDestroyed = true;
                }
#else
            wasDestroyed = false;
#endif
            }
            else
            {
                if (@object is Component)
                    Object.DestroyImmediate(@object);
                else
                    Object.Destroy(@object);
                wasDestroyed = true;
            }

            return wasDestroyed;
        }

        public static string ToDumpString(this object o)
        {
            return new DTObjectDump(o).ToString();
        }
    }

    public static class FloatExt
    {
        /// <summary>
        /// Return true if v is between 0 and 1 inclusive
        /// </summary>
        public static bool IsBetween0And1(this float v)
        {
            return v >= 0 && v <= 1;
        }

        /// <summary>
        /// Return true if v is between a and b inclusive
        /// </summary>
        public static bool IsBetween(this float v, float a, float b)
        {
            return v >= a && v <= b
                || v >= b && v <= a;
        }
    }

    public static class Vector2Ext
    {
        public static Vector2 Snap(this Vector2 v, float snapX, float snapY = -1)
        {
            if (snapY == -1)
                snapY = snapX;
            return (new Vector2(v.x - v.x % snapX, v.y - v.y % snapY));
        }

        public static float AngleSigned(this Vector2 a, Vector2 b)
        {
            float sign = Mathf.Sign(a.x * b.y - a.y * b.x);
            return Vector2.Angle(a, b) * sign;
        }

        public static Vector2 LeftNormal(this Vector2 v)
        {
            return new Vector2(-v.y, v.x);
        }
        public static Vector2 RightNormal(this Vector2 v)
        {
            return new Vector2(v.y, -v.x);
        }

        public static Vector2 Rotate(this Vector2 v, float degree)
        {
            float rad = degree * Mathf.Deg2Rad;
            float c = Mathf.Cos(rad);
            float s = Mathf.Sin(rad);
            return new Vector2(c * v.x - s * v.y, s * v.x + c * v.y);
        }

        public static Vector2 ToVector3(this Vector2 v)
        {
            return new Vector3(v.x, v.y, 0);
        }


    }

    public static class Vector3Ext
    {
        public static float AngleSigned(this Vector3 a, Vector3 b, Vector3 normal)
        {
            return Mathf.Atan2(Vector3.Dot(normal, Vector3.Cross(a, b)), Vector3.Dot(a, b)) * Mathf.Rad2Deg;
        }

        public static Vector3 RotateAround(this Vector3 point, Vector3 origin, Quaternion rotation)
        {
            Vector3 dir = point - origin;
            dir = rotation * dir;
            return origin + dir;
        }

        public static Vector2 ToVector2(this Vector3 v)
        {
            Vector2 result;
            result.x = v.x;
            result.y = v.y;
            return result;
        }


        /// <summary>
        /// Return true if v1 and v2 are equal, or different but very close.
        /// </summary>
        /// <param name="v1"></param>
        /// <param name="v2"></param>
        /// <returns></returns>
        public static bool Approximately(this Vector3 v1, Vector3 v2)
        {
            Vector3 v1MinusV2 = v1;
            v1MinusV2.x -= v2.x;
            v1MinusV2.y -= v2.y;
            v1MinusV2.z -= v2.z;
            if (Vector3.SqrMagnitude(v1MinusV2) < 0.000001f)
                return true;

            if (Mathf.Approximately(v1.x, v2.x)
                && Mathf.Approximately(v1.y, v2.y)
                && Mathf.Approximately(v1.z, v2.z))
            {
#if CURVY_SANITY_CHECKS_PRIVATE
                Debug.LogWarning("Approximately went in the third branch");
#endif
                return true;
            }

            return false;
        }

        /// <summary>
        /// The opposite of <see cref="Approximately"/>
        /// </summary>
        /// <param name="v1"></param>
        /// <param name="v2"></param>
        /// <returns></returns>
        public static bool NotApproximately(this Vector3 v1, Vector3 v2)
        {
            return Approximately(v1, v2) == false;
        }
    }

    /// <summary>
    /// Extension methods for quaternions
    /// </summary>
    static public class QuaternionExt
    {
        /// <summary>
        /// Two quaternions can represent different rotations that lead to the same final orientation (one rotating around Axis with Angle, the other around -Axis with 2Pi-Angle). In this case, the quaternion == operator will return false. This method will return true.
        /// </summary>
        /// <param name="q1"></param>
        /// <param name="q2"></param>
        /// <returns></returns>
        public static bool SameOrientation(this Quaternion q1, Quaternion q2)
        {
            return Math.Abs((double)Quaternion.Dot(q1, q2)) > 0.999998986721039;
        }

        /// <summary>
        /// Two quaternions can represent different rotations that lead to the same final orientation (one rotating around Axis with Angle, the other around -Axis with 2Pi-Angle). In this case, the quaternion != operator will return true. This method will return false.
        /// </summary>
        /// <param name="q1"></param>
        /// <param name="q2"></param>
        /// <returns></returns>
        public static bool DifferentOrientation(this Quaternion q1, Quaternion q2)
        {
            return Math.Abs((double)Quaternion.Dot(q1, q2)) <= 0.999998986721039;
        }
    }

    public static class GameObjectExt
    {
        /// <summary>
        /// Duplicates a GameObject
        /// </summary>
        /// <param name="source">a component being part of the source GameObject</param>
        /// <returns>the component from the cloned GameObject</returns>
        public static GameObject DuplicateGameObject(this GameObject source, Transform newParent, bool keepPrefabReference = false)
        {
            if (!source)
                return null;

            GameObject newGO;
#if UNITY_EDITOR
            UnityEngine.Object prefabRoot = PrefabUtility.GetCorrespondingObjectFromSource(source.gameObject);

            if (prefabRoot != null && keepPrefabReference)
                newGO = PrefabUtility.InstantiatePrefab(prefabRoot) as GameObject;
            else
#endif
                newGO = Object.Instantiate(source.gameObject) as GameObject;

            if (newGO)
                newGO.transform.parent = newParent;

            return newGO;
        }

        public static void StripComponents(this GameObject go, params Type[] toKeep)
        {
            List<Type> keep = new List<Type>(toKeep)
            {
                typeof(Transform),
                typeof(RectTransform)
            };
            Component[] cmps = go.GetComponents<Component>();
            for (int i = 0; i < cmps.Length; i++)
                if (!keep.Contains(cmps[i].GetType()))
                    cmps[i].Destroy(false, false);
        }
    }

    public static class ComponentExt
    {
        public static void StripComponents(this Component c, params Type[] toKeep)
        {
            if (toKeep.Length == 0)
                c.gameObject.StripComponents(c.GetType());
            else
                c.gameObject.StripComponents(toKeep);
        }

        public static GameObject AddChildGameObject(this Component c, string name)
        {
            GameObject go = new GameObject(name);
            go.transform.SetParent(c.transform);
            return go;
        }

        public static T AddChildGameObject<T>(this Component c, string name) where T : Component
        {
            GameObject go = new GameObject(name);
            if (go)
            {
                go.transform.SetParent(c.transform);
                return go.AddComponent<T>();
            }
            else
                return null;
        }

        /// <summary>
        /// Duplicates the GameObject of a component, returning the component
        /// </summary>
        /// <param name="source">a component being part of the source GameObject</param>
        /// <returns>the component from the cloned GameObject</returns>
        public static T DuplicateGameObject<T>(this Component source, Transform newParent, bool keepPrefabConnection = false) where T : Component
        {
            if (!source || !source.gameObject)
                return null;

            List<Component> cmps = new List<Component>(source.gameObject.GetComponents<Component>());
            int sourceIdx = cmps.IndexOf(source);
            GameObject newGO;
#if UNITY_EDITOR
            UnityEngine.Object prefabRoot = PrefabUtility.GetCorrespondingObjectFromSource(source.gameObject);

            if (prefabRoot != null && keepPrefabConnection)
                newGO = PrefabUtility.InstantiatePrefab(prefabRoot) as GameObject;
            else
#endif
                newGO = Object.Instantiate(source.gameObject);

            if (newGO)
            {
                newGO.transform.SetParent(newParent, false);
                Component[] newCmps = newGO.GetComponents<Component>();
                return newCmps[sourceIdx] as T;
            }
            else
                return null;
        }

        /// <summary>
        /// Duplicates the GameObject of a component, returning the component
        /// </summary>
        /// <param name="source">a component being part of the source GameObject</param>
        /// <returns>the component from the cloned GameObject</returns>
        public static Component DuplicateGameObject(this Component source, Transform newParent, bool keepPrefabConnection = false)
        {
            if (!source || !source.gameObject || !newParent)
                return null;

            List<Component> cmps = new List<Component>(source.gameObject.GetComponents<Component>());
            int sourceIdx = cmps.IndexOf(source);
            GameObject newGO;
#if UNITY_EDITOR
            UnityEngine.Object prefabRoot = PrefabUtility.GetCorrespondingObjectFromSource(source.gameObject);

            if (prefabRoot != null && keepPrefabConnection)
                newGO = PrefabUtility.InstantiatePrefab(prefabRoot) as GameObject;
            else
#endif
                newGO = Object.Instantiate(source.gameObject);

            if (newGO)
            {
                newGO.transform.SetParent(newParent, false);
                Component[] newCmps = newGO.GetComponents<Component>();
                return newCmps[sourceIdx];
            }
            else
                return null;
        }

    }

    public static class ColorExt
    {
        public static string ToHtml(this Color c)
        {
            Color32 col = c;
            return string.Format("#{0:X2}{1:X2}{2:X2}{3:X2}", new object[] { col.r, col.g, col.b, col.a });
        }


    }

    public static class EnumExt
    {

        /// <summary>
        /// Checks if at least one of the provided flags is set in variable
        /// </summary>
        public static bool HasFlag(this Enum variable, params Enum[] flags)
        {
            if (flags.Length == 0)
                throw new ArgumentNullException("flags");

            int varInt = Convert.ToInt32(variable);

            Type T = variable.GetType();
            for (int i = 0; i < flags.Length; i++)
            {
                if (!Enum.IsDefined(T, flags[i]))
                {
                    throw new ArgumentException(string.Format(
                    "Enumeration type mismatch.  The flag is of type '{0}', was expecting '{1}'.",
                    flags[i].GetType(), T));
                }
                int num = Convert.ToInt32(flags[i]);
                if ((varInt & num) == num)
                    return true;
            }
            return false;
        }

        public static bool HasFlag<T>(this T value, T flag) where T : struct
        {
            long lValue = Convert.ToInt64(value);
            long lFlag = Convert.ToInt64(flag);
            return (lValue & lFlag) != 0;
        }

        /// <summary>
        /// Sets a flag
        /// </summary>
        public static T Set<T>(this Enum value, T append) { return Set(value, append, true); }
        /// <summary>
        /// Sets a flag
        /// </summary>
        /// <param name="OnOff">whether to set or unset the value</param>
        public static T Set<T>(this Enum value, T append, bool OnOff)
        {
            if (append == null)
                throw new ArgumentNullException("append");

            Type type = value.GetType();
            //return the final value
            if (OnOff)
                return (T)Enum.Parse(type, (Convert.ToUInt64(value) | Convert.ToUInt64(append)).ToString());
            else
                return (T)Enum.Parse(type, (Convert.ToUInt64(value) & ~Convert.ToUInt64(append)).ToString());
        }
    }

    public static class RectExt
    {

        public static Rect Set(this Rect rect, Vector2 pos, Vector2 size)
        {
            rect.Set(pos.x, pos.y, size.x, size.y);
            return new Rect(rect);
        }

        public static Rect SetBetween(this Rect rect, Vector2 pos, Vector2 pos2)
        {
            rect.Set(pos.x, pos.y, pos2.x - pos.x, pos2.y - pos.y);
            return new Rect(rect);
        }

        /// <summary>
        /// Sets x/y
        /// </summary>
        public static Rect SetPosition(this Rect rect, Vector2 pos)
        {
            rect.x = pos.x;
            rect.y = pos.y;
            return new Rect(rect);
        }

        /// <summary>
        /// Sets x/y
        /// </summary>
        public static Rect SetPosition(this Rect rect, float x, float y)
        {
            rect.x = x;
            rect.y = y;
            return new Rect(rect);
        }

        /// <summary>
        /// gets width/height as Vector2
        /// </summary>
        public static Vector2 GetSize(this Rect rect)
        {
            return new Vector2(rect.width, rect.height);
        }
        /// <summary>
        /// Sets width/height
        /// </summary>
        public static Rect SetSize(this Rect rect, Vector2 size)
        {
            rect.width = size.x;
            rect.height = size.y;
            return new Rect(rect);
        }


        /// <summary>
        /// Grow/Shrink a rect
        /// </summary>
        public static Rect ScaleBy(this Rect rect, int pixel) { return ScaleBy(rect, pixel, pixel); }
        /// <summary>
        /// Grow/Shrink a rect
        /// </summary>
        public static Rect ScaleBy(this Rect rect, int x, int y)
        {
            rect.x -= (float)x;
            rect.y -= (float)y;
            rect.width += (float)x * 2;
            rect.height += (float)y * 2;
            return new Rect(rect);
        }

        public static Rect ShiftBy(this Rect rect, int x, int y)
        {
            rect.x += (float)x;
            rect.y += (float)y;
            return new Rect(rect);
        }

        public static Rect Include(this Rect rect, Rect other)
        {
            Rect r = new Rect();
            r.xMin = Mathf.Min(rect.xMin, other.xMin);
            r.xMax = Mathf.Max(rect.xMax, other.xMax);
            r.yMin = Mathf.Min(rect.yMin, other.yMin);
            r.yMax = Mathf.Max(rect.yMax, other.yMax);
            return r;
        }

    }

    public static class StringExt
    {
        /// <summary>
        /// Converts a HTML color endcoded string int a color
        /// </summary>
        /// <param name="hexString">html color of type [#]rrggbb[aa]</param>
        /// <returns>a Color</returns>
        public static Color ColorFromHtml(this string hexString)
        {
            if (hexString.Length < 9)
                hexString += "FF";
            if (hexString.StartsWith("#") && hexString.Length == 9)
            {
                int[] rgba = new int[4];
                try
                {
                    rgba[0] = int.Parse(hexString.Substring(1, 2), System.Globalization.NumberStyles.HexNumber);
                    rgba[1] = int.Parse(hexString.Substring(3, 2), System.Globalization.NumberStyles.HexNumber);
                    rgba[2] = int.Parse(hexString.Substring(5, 2), System.Globalization.NumberStyles.HexNumber);
                    rgba[3] = int.Parse(hexString.Substring(7, 2), System.Globalization.NumberStyles.HexNumber);
                    return new Color(rgba[0] / 255f, rgba[1] / 255f, rgba[2] / 255f, rgba[3] / 255f);
                }
                catch (Exception e)
                {
                    Debug.LogException(e);
                    return Color.white;
                }
            }
            return Color.white;
        }

        public static string TrimStart(this string s, string trim, StringComparison compare = StringComparison.CurrentCultureIgnoreCase)
        {
            if (!s.StartsWith(trim, compare))
                return s;
            else
            {
                return s.Substring(trim.Length);
            }
        }

        public static string TrimEnd(this string s, string trim, StringComparison compare = StringComparison.CurrentCultureIgnoreCase)
        {
            if (!s.EndsWith(trim, compare))
                return s;
            else
            {
                return s.Substring(0, s.Length - trim.Length);
            }
        }


    }

    public static class IEnumerableExt
    {
        public static void ForEach<T>(this IEnumerable<T> ie, Action<T> action)
        {
            foreach (T i in ie)
            {
                action(i);
            }
        }
    }

    public static class ArrayExt
    {
        public static T[] SubArray<T>(this T[] data, int index, int length)
        {
            length = Mathf.Clamp(length, 0, data.Length - index);
            T[] result = new T[length];
            if (length > 0)
                Array.Copy(data, index, result, 0, length);
            return result;
        }

        public static T[] RemoveAt<T>(this T[] source, int index)
        {
            T[] dest = new T[source.Length - 1];
            if (index > 0)
                Array.Copy(source, 0, dest, 0, index);

            if (index < source.Length - 1)
                Array.Copy(source, index + 1, dest, index, source.Length - index - 1);

            return dest;
        }

        public static T[] InsertAt<T>(this T[] source, int index)
        {
            T[] dest = new T[source.Length + 1];
            index = Mathf.Clamp(index, 0, source.Length - 1);

            if (index > 0)
                Array.Copy(source, 0, dest, 0, index);

            Array.Copy(source, index, dest, index + 1, source.Length - index);

            return dest;
        }

        public static T[] Swap<T>(this T[] source, int index, int with)
        {
            index = Mathf.Clamp(index, 0, source.Length - 1);
            with = Mathf.Clamp(index, 0, source.Length - 1);
            (source[with], source[index]) = (source[index], source[with]);
            return source;
        }

        public static T[] Add<T>(this T[] source, T item)
        {
            Array.Resize(ref source, source.Length + 1);
            source[source.Length - 1] = item;
            return source;
        }

        public static T[] AddRange<T>(this T[] source, T[] items)
        {
            Array.Resize(ref source, source.Length + items.Length);
            Array.Copy(items, 0, source, source.Length - items.Length, items.Length);
            return source;
        }

        public static T[] RemoveDuplicates<T>(this T[] source)
        {
            List<T> res = new List<T>();
            HashSet<T> hash = new HashSet<T>();
            foreach (T p in source)
            {
                if (hash.Add(p))
                {
                    res.Add(p);
                }
            }
            return res.ToArray();
        }

        public static int IndexOf<T>(this T[] source, T item)
        {
            for (int i = 0; i < source.Length; i++)
                if (source[i].Equals(item))
                    return i;
            return -1;
        }

        public static T[] Remove<T>(this T[] source, T item)
        {
            int idx = source.IndexOf<T>(item);
            if (idx > -1)
                return source.RemoveAt<T>(idx);
            else
                return source;
        }
    }

    public static class MeshFilterExt
    {
        /// <summary>
        /// Returns a shared mesh to work with. If existing, it will be cleared
        /// </summary>
        public static Mesh PrepareNewShared(this MeshFilter m, string name = "Mesh")
        {
            if (m == null)
                return null;
            if (m.sharedMesh == null)
            {
                Mesh msh = new Mesh();
                msh.MarkDynamic();
                msh.name = name;
                m.sharedMesh = msh;
            }
            else
            {
                m.sharedMesh.Clear();
                m.sharedMesh.name = name;
                m.sharedMesh.subMeshCount = 0;
            }
            return m.sharedMesh;
        }

        [Obsolete("No more used in Curvy. Will get removed. Copy it if you still need it")]
        public static void CalculateTangents(this MeshFilter m)
        {
            //speed up math by copying the mesh arrays
            int[] triangles = m.sharedMesh.triangles;
            Vector3[] vertices = m.sharedMesh.vertices;
            Vector2[] uv = m.sharedMesh.uv;
            Vector3[] normals = m.sharedMesh.normals;

            if (uv.Length == 0)
                return;

            //variable definitions
            int triangleCount = triangles.Length;
            int vertexCount = vertices.Length;

            Vector3[] tan1 = new Vector3[vertexCount];
            Vector3[] tan2 = new Vector3[vertexCount];

            Vector4[] tangents = new Vector4[vertexCount];

            for (int a = 0; a < triangleCount; a += 3)
            {
                int i1 = triangles[a + 0];
                int i2 = triangles[a + 1];
                int i3 = triangles[a + 2];

                Vector3 v1 = vertices[i1];
                Vector3 v2 = vertices[i2];
                Vector3 v3 = vertices[i3];

                Vector2 w1 = uv[i1];
                Vector2 w2 = uv[i2];
                Vector2 w3 = uv[i3];

                float x1 = v2.x - v1.x;
                float x2 = v3.x - v1.x;
                float y1 = v2.y - v1.y;
                float y2 = v3.y - v1.y;
                float z1 = v2.z - v1.z;
                float z2 = v3.z - v1.z;

                float s1 = w2.x - w1.x;
                float s2 = w3.x - w1.x;
                float t1 = w2.y - w1.y;
                float t2 = w3.y - w1.y;

                float div = s1 * t2 - s2 * t1;
                float r = div == 0.0f ? 0.0f : 1.0f / div;

                float sdirX = (t2 * x1 - t1 * x2) * r;
                float sdirY = (t2 * y1 - t1 * y2) * r;
                float sdirZ = (t2 * z1 - t1 * z2) * r;
                float tdirX = (s1 * x2 - s2 * x1) * r;
                float tdirY = (s1 * y2 - s2 * y1) * r;
                float tdirZ = (s1 * z2 - s2 * z1) * r;

                tan1[i1].x += sdirX;
                tan1[i1].y += sdirY;
                tan1[i1].z += sdirZ;

                tan1[i2].x += sdirX;
                tan1[i2].y += sdirY;
                tan1[i2].z += sdirZ;

                tan1[i3].x += sdirX;
                tan1[i3].y += sdirY;
                tan1[i3].z += sdirZ;


                tan2[i1].x += tdirX;
                tan2[i1].y += tdirY;
                tan2[i1].z += tdirZ;

                tan2[i2].x += tdirX;
                tan2[i2].y += tdirY;
                tan2[i2].z += tdirZ;

                tan2[i3].x += tdirX;
                tan2[i3].y += tdirY;
                tan2[i3].z += tdirZ;
            }


            for (int a = 0; a < vertexCount; ++a)
            {
                Vector3 n = normals[a];
                Vector3 t = tan1[a];
                Vector3.OrthoNormalize(ref n, ref t);
                tangents[a].x = t.x;
                tangents[a].y = t.y;
                tangents[a].z = t.z;

                //inlined version of float dotOfCross = (Vector3.Dot(Vector3.Cross(n, t), tan2[a]) < 0.0f)
                float dotOfCross = ((n.y * t.z - n.z * t.y) * tan2[a].x + (n.z * t.x - n.x * t.z) * tan2[a].y + (n.x * t.y - n.y * t.x) * tan2[a].z);
                tangents[a].w = (dotOfCross < 0.0f) ? -1.0f : 1.0f;
            }

            m.sharedMesh.tangents = tangents;
        }
    }

    public static class TypeExt
    {

        /// <summary>
        /// Gets all types loaded in the current domain.
        /// </summary>
        public static Type[] GetLoadedTypes()
        {
#if UNITY_EDITOR
            return TypeCache.GetTypesDerivedFrom(typeof(System.Object)).ToArray();
#else
            IEnumerable<Assembly> loadedAssemblies = GetLoadedAssemblies();
            List<Type> types = new List<Type>(loadedAssemblies.Count() * 100);//An estimation of 100 type per assembly. This is based on no statistical analysis, just a guess.
            foreach (Assembly assembly in loadedAssemblies)
            {
                try
                {
                    types.AddRange(assembly.GetTypes());
                }
                catch (ReflectionTypeLoadException exception)
                {
                    for (int index = 0; index < exception.Types.Length; index++)
                    {
                        Type type = exception.Types[index];
                        if (type != null)
                            types.Add(type);
                    }
                }
            }
            return types.ToArray();
#endif
        }

        /// <summary>
        /// Gets all types loaded assemblies in the current domain.
        /// </summary>
        static public IEnumerable<Assembly> GetLoadedAssemblies()
        {
            //OPTIM use .Where(a => a.GlobalAssemblyCache == false)?
            return AppDomain.CurrentDomain.GetAssemblies();
        }

        /// <summary>
        /// Gets all Types T that have an attribute U
        /// </summary>
        public static Dictionary<U, Type> GetAllTypesWithAttribute<U>(this Type type)
        {
            Dictionary<U, Type> res = new Dictionary<U, Type>();

            IEnumerable<Type> loadedTypes;
#if UNITY_EDITOR
            loadedTypes = TypeCache.GetTypesDerivedFrom(type);
#else
            loadedTypes = GetLoadedTypes();
#endif

            foreach (Type t in loadedTypes)
            {
#if UNITY_EDITOR == false
                if (t.IsSubclassOf(type))
#endif
                {
                    object[] attribs = t.GetCustomAttributes(typeof(U), false);

                    if (attribs.Length > 0)
                    {
                        res.Add((U)attribs[0], t);
                    }
                }
            }
            return res;
        }

        /// <summary>
        /// Gets all fields of a type that have a certain attribute
        /// </summary>
        public static List<FieldInfo> GetFieldsWithAttribute<T>(this Type type, bool includeInherited = false, bool includePrivate = false) where T : Attribute
        {
            FieldInfo[] flds = type.GetAllFields(includeInherited, includePrivate);
            List<FieldInfo> res = new List<FieldInfo>();
            foreach (FieldInfo fi in flds)
            {
                if (fi.GetCustomAttribute<T>() != null)
                    res.Add(fi);
            }
            return res;
        }

        /// <summary>
        /// Gets a custom attribute from a type (Crossplatform)
        /// </summary>
        public static T GetCustomAttribute<T>(this Type type) where T : Attribute
        {
            object[] at = (object[])type.GetCustomAttributes(typeof(T), true);
            return (at.Length > 0) ? (T)at[0] : null;

        }

        /// <summary>
        /// Finds a Method (Crossplatform)
        /// </summary>
        /// <param name="type">type containing the method</param>
        /// <param name="name">Name of method</param>
        /// <param name="includeInherited">Whether methods of base classes should be returned as well</param>
        /// <param name="includePrivate">Whether private methods should be returned as well</param>
        public static MethodInfo MethodByName(this Type type, string name, bool includeInherited = false, bool includePrivate = false)
        {
            BindingFlags flags = BindingFlags.Public | BindingFlags.Instance;
            if (includePrivate)
                flags = flags | BindingFlags.NonPublic;

            if (includeInherited)
                return type.GetMethodIncludingBaseClasses(name, flags);
            else
                return type.GetMethod(name, flags);
        }
        /// <summary>
        /// Finds a Field (Crossplatform)
        /// </summary>
        /// <param name="type">type containing the field</param>
        /// <param name="name">Name of field</param>
        /// <param name="includeInherited">Whether fields of base classes should be returned as well</param>
        /// <param name="includePrivate">Whether private fields should be returned as well</param>
        public static FieldInfo FieldByName(this Type type, string name, bool includeInherited = false, bool includePrivate = false)
        {
            BindingFlags flags = BindingFlags.Public | BindingFlags.Instance;
            if (includePrivate)
                flags = flags | BindingFlags.NonPublic;

            if (includeInherited)
                return type.GetFieldIncludingBaseClasses(name, flags);
            else
                return type.GetField(name, flags);
        }
        /// <summary>
        /// Finds a Property (Crossplatform)
        /// </summary>
        /// <param name="type">type containing the property</param>
        /// <param name="name">Name of property</param>
        /// <param name="includeInherited">Whether properties of base classes should be returned as well</param>
        /// <param name="includePrivate">Whether private properties should be returned as well</param>
        public static PropertyInfo PropertyByName(this Type type, string name, bool includeInherited = false, bool includePrivate = false)
        {

            BindingFlags flags = BindingFlags.Public | BindingFlags.Instance;
            if (includePrivate)
                flags = flags | BindingFlags.NonPublic;

            if (includeInherited)
                return type.GetPropertyIncludingBaseClasses(name, flags);
            else
                return type.GetProperty(name, flags);
        }
        /// <summary>
        /// Gets all fields (Crossplatform)
        /// </summary>
        /// <param name="type">type to reflect</param>
        /// <param name="includeInherited">Whether fields of base classes should be returned as well</param>
        /// <param name="includePrivate">Whether private fields should be returned as well</param>
        public static FieldInfo[] GetAllFields(this Type type, bool includeInherited = false, bool includePrivate = false)
        {
            BindingFlags flags = BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly;
            if (includePrivate)
                flags = flags | BindingFlags.NonPublic;

            if (includeInherited)
            {
                Type currentType = type;
                List<FieldInfo> res = new List<FieldInfo>();
                while (currentType != typeof(object))
                {
                    res.AddRange(currentType.GetFields(flags));
                    currentType = currentType.BaseType;
                }
                return res.ToArray();
            }
            else
                return type.GetFields(flags);
        }
        /// <summary>
        /// Gets all properties (Crossplatform)
        /// </summary>
        /// <param name="type">type to reflect</param>
        /// <param name="includeInherited">Whether properties of base classes should be returned as well</param>
        /// <param name="includePrivate">Whether private properties should be returned as well</param>
        public static PropertyInfo[] GetAllProperties(this Type type, bool includeInherited = false, bool includePrivate = false)
        {
            BindingFlags flags = BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly;
            if (includePrivate)
                flags = flags | BindingFlags.NonPublic;

            if (includeInherited)
            {
                Type currentType = type;
                List<PropertyInfo> res = new List<PropertyInfo>();
                while (currentType != typeof(object))
                {
                    res.AddRange(currentType.GetProperties(flags));
                    currentType = currentType.BaseType;
                }
                return res.ToArray();
            }
            else
                return type.GetProperties(flags);
        }

        /// <summary>
        /// Whether the type is a framework type, i.e. a primitive, string or DateTime (Crossplatform)
        /// </summary>
        public static bool IsFrameworkType(this Type type)
        {
            return type.IsPrimitive || type.Equals(typeof(string)) || type.Equals(typeof(DateTime));
        }

        public static bool IsArrayOrList(this Type type)
        {
            return (type.IsArray || (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>)));
        }


        public static Type GetEnumerableType(this Type t)
        {
            Type ienum = FindIEnumerable(t);
            if (ienum == null) return t;
            return ienum.GetGenericArguments()[0];
        }

        static Type FindIEnumerable(Type seqType)
        {
            if (seqType == null || seqType == typeof(string))
                return null;
            if (seqType.IsArray)
                return typeof(IEnumerable<>).MakeGenericType(seqType.GetElementType());

            if (seqType.IsGenericType)
            {
                foreach (Type arg in seqType.GetGenericArguments())
                {
                    Type ienum = typeof(IEnumerable<>).MakeGenericType(arg);
                    if (ienum.IsAssignableFrom(seqType))
                    {
                        return ienum;
                    }
                }
            }
            Type[] ifaces = seqType.GetInterfaces();
            if (ifaces != null && ifaces.Length > 0)
            {
                foreach (Type iface in ifaces)
                {
                    Type ienum = FindIEnumerable(iface);
                    if (ienum != null) return ienum;
                }
            }

            if (seqType.BaseType != null && seqType.BaseType != typeof(object))
            {
                return FindIEnumerable(seqType.BaseType);
            }
            return null;
        }

        static MethodInfo GetMethodIncludingBaseClasses(this Type type, string name, BindingFlags bindingFlags)
        {
            // If this class doesn't have a base, don't waste any time
            MethodInfo mi = type.GetMethod(name, bindingFlags);
            if (type.BaseType == typeof(object))
            {
                return mi;
            }
            else
            {   // Otherwise, collect all types up to the furthest base class
                Type currentType = type;
                while (currentType != typeof(object))
                {
                    mi = currentType.GetMethod(name, bindingFlags);
                    if (mi != null)
                        return mi;
                    currentType = currentType.BaseType;
                }
                return null;
            }
        }
        static FieldInfo GetFieldIncludingBaseClasses(this Type type, string name, BindingFlags bindingFlags)
        {
            FieldInfo fieldInfo = type.GetField(name, bindingFlags);

            // If this class doesn't have a base, don't waste any time
            if (type.BaseType == typeof(object))
            {
                return fieldInfo;
            }
            else
            {   // Otherwise, collect all types up to the furthest base class
                Type currentType = type;
                while (currentType != typeof(object))
                {
                    fieldInfo = currentType.GetField(name, bindingFlags);
                    if (fieldInfo != null)
                        return fieldInfo;
                    currentType = currentType.BaseType;
                }
                return null;
            }
        }
        static PropertyInfo GetPropertyIncludingBaseClasses(this Type type, string name, BindingFlags bindingFlags)
        {
            PropertyInfo propertyInfo = type.GetProperty(name, bindingFlags);

            // If this class doesn't have a base, don't waste any time
            if (type.BaseType == typeof(object))
            {
                return propertyInfo;
            }
            else
            {   // Otherwise, collect all types up to the furthest base class
                Type currentType = type;
                while (currentType != typeof(object))
                {
                    propertyInfo = currentType.GetProperty(name, bindingFlags);
                    if (propertyInfo != null)
                        return propertyInfo;
                    currentType = currentType.BaseType;
                }
                return null;
            }
        }

        public static bool Matches(this Type type, params Type[] types)
        {
            foreach (Type t in types)
                if (type == t || type.IsAssignableFrom(t))
                    return true;

            return false;
        }




    }

    public static class FieldInfoExt
    {
        /// <summary>
        /// Gets a custom attribute (CrossPlatform)
        /// </summary>
        public static T GetCustomAttribute<T>(this FieldInfo field) where T : Attribute
        {
            object[] at = field.GetCustomAttributes(typeof(T), true);
            return (at.Length > 0) ? (T)at[0] : null;

        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Extensions/Extensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Dict.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3102f422c6eae044d9449fcda12bf2a8
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    internal class Dict<TValue> where TValue : class
    {
        public class Node
        {
            internal TValue _key;
            internal Node _prev, _next;

            public TValue Key { get { return _key; } }
            public Node Prev { get { return _prev; } }
            public Node Next { get { return _next; } }
        }

        public delegate bool LessOrEqual(TValue lhs, TValue rhs);

        private LessOrEqual _leq;
        Node _head;

        public Dict(LessOrEqual leq)
        {
            _leq = leq;

            _head = new Node { _key = null };
            _head._prev = _head;
            _head._next = _head;
        }

        public Node Insert(TValue key)
        {
            return InsertBefore(_head, key);
        }

        public Node InsertBefore(Node node, TValue key)
        {
            do {
                node = node._prev;
            } while (node._key != null && !_leq(node._key, key));

            var newNode = new Node { _key = key };
            newNode._next = node._next;
            node._next._prev = newNode;
            newNode._prev = node;
            node._next = newNode;

            return newNode;
        }

        public Node Find(TValue key)
        {
            var node = _head;
            do {
                node = node._next;
            } while (node._key != null && !_leq(key, node._key));
            return node;
        }

        public Node Min()
        {
            return _head._next;
        }

        public void Remove(Node node)
        {
            node._next._prev = node._prev;
            node._prev._next = node._next;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Dict.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Geom.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0414da14dce5a6c4382f13dd89869f01
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

using System;
using System.Diagnostics;

using Real = System.Single;
namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    internal static class Geom
    {
        public static bool IsWindingInside(WindingRule rule, int n)
        {
            switch (rule)
            {
                case WindingRule.EvenOdd:
                    return (n & 1) == 1;
                case WindingRule.NonZero:
                    return n != 0;
                case WindingRule.Positive:
                    return n > 0;
                case WindingRule.Negative:
                    return n < 0;
                case WindingRule.AbsGeqTwo:
                    return n >= 2 || n <= -2;
            }
            throw new Exception("Wrong winding rule");
        }

        public static bool VertCCW(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
        {
            return (u._s * (v._t - w._t) + v._s * (w._t - u._t) + w._s * (u._t - v._t)) >= 0.0f;
        }
        public static bool VertEq(MeshUtils.Vertex lhs, MeshUtils.Vertex rhs)
        {
            return lhs._s == rhs._s && lhs._t == rhs._t;
        }
        public static bool VertLeq(MeshUtils.Vertex lhs, MeshUtils.Vertex rhs)
        {
            return (lhs._s < rhs._s) || (lhs._s == rhs._s && lhs._t <= rhs._t);
        }

        /// <summary>
        /// Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),
        /// evaluates the t-coord of the edge uw at the s-coord of the vertex v.
        /// Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.
        /// If uw is vertical (and thus passes thru v), the result is zero.
        /// 
        /// The calculation is extremely accurate and stable, even when v
        /// is very close to u or w.  In particular if we set v->t = 0 and
        /// let r be the negated result (this evaluates (uw)(v->s)), then
        /// r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).
        /// </summary>
        public static Real EdgeEval(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
        {
            Debug.Assert(VertLeq(u, v) && VertLeq(v, w));

            var gapL = v._s - u._s;
            var gapR = w._s - v._s;

            if (gapL + gapR > 0.0f)
            {
                if (gapL < gapR)
                {
                    return (v._t - u._t) + (u._t - w._t) * (gapL / (gapL + gapR));
                }
                else
                {
                    return (v._t - w._t) + (w._t - u._t) * (gapR / (gapL + gapR));
                }
            }
            /* vertical line */
            return 0;
        }

        /// <summary>
        /// Returns a number whose sign matches EdgeEval(u,v,w) but which
        /// is cheaper to evaluate. Returns > 0, == 0 , or < 0
        /// as v is above, on, or below the edge uw.
        /// </summary>
        public static Real EdgeSign(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
        {
            Debug.Assert(VertLeq(u, v) && VertLeq(v, w));

            var gapL = v._s - u._s;
            var gapR = w._s - v._s;

            if (gapL + gapR > 0.0f)
            {
                return (v._t - w._t) * gapL + (v._t - u._t) * gapR;
            }
            /* vertical line */
            return 0;
        }

        public static bool TransLeq(MeshUtils.Vertex lhs, MeshUtils.Vertex rhs)
        {
            return (lhs._t < rhs._t) || (lhs._t == rhs._t && lhs._s <= rhs._s);
        }

        public static Real TransEval(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
        {
            Debug.Assert(TransLeq(u, v) && TransLeq(v, w));

            var gapL = v._t - u._t;
            var gapR = w._t - v._t;

            if (gapL + gapR > 0.0f)
            {
                if (gapL < gapR)
                {
                    return (v._s - u._s) + (u._s - w._s) * (gapL / (gapL + gapR));
                }
                else
                {
                    return (v._s - w._s) + (w._s - u._s) * (gapR / (gapL + gapR));
                }
            }
            /* vertical line */
            return 0;
        }

        public static Real TransSign(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
        {
            Debug.Assert(TransLeq(u, v) && TransLeq(v, w));

            var gapL = v._t - u._t;
            var gapR = w._t - v._t;

            if (gapL + gapR > 0.0f)
            {
                return (v._s - w._s) * gapL + (v._s - u._s) * gapR;
            }
            /* vertical line */
            return 0;
        }

        public static bool EdgeGoesLeft(MeshUtils.Edge e)
        {
            return VertLeq(e._Dst, e._Org);
        }

        public static bool EdgeGoesRight(MeshUtils.Edge e)
        {
            return VertLeq(e._Org, e._Dst);
        }

        public static Real VertL1dist(MeshUtils.Vertex u, MeshUtils.Vertex v)
        {
            return Math.Abs(u._s - v._s) + Math.Abs(u._t - v._t);
        }

        public static void AddWinding(MeshUtils.Edge eDst, MeshUtils.Edge eSrc)
        {
            eDst._winding += eSrc._winding;
            eDst._Sym._winding += eSrc._Sym._winding;
        }

        public static Real Interpolate(Real a, Real x, Real b, Real y)
        {
            if (a < 0.0f)
            {
                a = 0.0f;
            }
            if (b < 0.0f)
            {
                b = 0.0f;
            }
            return ((a <= b) ? ((b == 0.0f) ? ((x+y) / 2.0f)
                    : (x + (y-x) * (a/(a+b))))
                    : (y + (x-y) * (b/(a+b))));
        }

        static void Swap(ref MeshUtils.Vertex a, ref MeshUtils.Vertex b)
        {
            (b, a) = (a, b);
        }

        /// <summary>
        /// Given edges (o1,d1) and (o2,d2), compute their point of intersection.
        /// The computed point is guaranteed to lie in the intersection of the
        /// bounding rectangles defined by each edge.
        /// </summary>
        public static void EdgeIntersect(MeshUtils.Vertex o1, MeshUtils.Vertex d1, MeshUtils.Vertex o2, MeshUtils.Vertex d2, MeshUtils.Vertex v)
        {
            // This is certainly not the most efficient way to find the intersection
            // of two line segments, but it is very numerically stable.
            // 
            // Strategy: find the two middle vertices in the VertLeq ordering,
            // and interpolate the intersection s-value from these.  Then repeat
            // using the TransLeq ordering to find the intersection t-value.

            if (!VertLeq(o1, d1)) { Swap(ref o1, ref d1); }
            if (!VertLeq(o2, d2)) { Swap(ref o2, ref d2); }
            if (!VertLeq(o1, o2)) { Swap(ref o1, ref o2); Swap(ref d1, ref d2); }

            if (!VertLeq(o2, d1))
            {
                // Technically, no intersection -- do our best
                v._s = (o2._s + d1._s) / 2.0f;
            }
            else if (VertLeq(d1, d2))
            {
                // Interpolate between o2 and d1
                var z1 = EdgeEval(o1, o2, d1);
                var z2 = EdgeEval(o2, d1, d2);
                if (z1 + z2 < 0.0f)
                {
                    z1 = -z1;
                    z2 = -z2;
                }
                v._s = Interpolate(z1, o2._s, z2, d1._s);
            }
            else
            {
                // Interpolate between o2 and d2
                var z1 = EdgeSign(o1, o2, d1);
                var z2 = -EdgeSign(o1, d2, d1);
                if (z1 + z2 < 0.0f)
                {
                    z1 = -z1;
                    z2 = -z2;
                }
                v._s = Interpolate(z1, o2._s, z2, d2._s);
            }

            // Now repeat the process for t

            if (!TransLeq(o1, d1)) { Swap(ref o1, ref d1); }
            if (!TransLeq(o2, d2)) { Swap(ref o2, ref d2); }
            if (!TransLeq(o1, o2)) { Swap(ref o1, ref o2); Swap(ref d1, ref d2); }

            if (!TransLeq(o2, d1))
            {
                // Technically, no intersection -- do our best
                v._t = (o2._t + d1._t) / 2.0f;
            }
            else if (TransLeq(d1, d2))
            {
                // Interpolate between o2 and d1
                var z1 = TransEval(o1, o2, d1);
                var z2 = TransEval(o2, d1, d2);
                if (z1 + z2 < 0.0f)
                {
                    z1 = -z1;
                    z2 = -z2;
                }
                v._t = Interpolate(z1, o2._t, z2, d1._t);
            }
            else
            {
                // Interpolate between o2 and d2
                var z1 = TransSign(o1, o2, d1);
                var z2 = -TransSign(o1, d2, d1);
                if (z1 + z2 < 0.0f)
                {
                    z1 = -z1;
                    z2 = -z2;
                }
                v._t = Interpolate(z1, o2._t, z2, d2._t);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Geom.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/LTMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 71c6f8ed26841f945bf72bd9a722a62c
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

using System;
using System.Diagnostics;

namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    internal class LTMesh : MeshUtils.Pooled<LTMesh>
    {
        internal MeshUtils.Vertex _vHead;
        internal MeshUtils.Face _fHead;
        internal MeshUtils.Edge _eHead, _eHeadSym;

        public LTMesh()
        {
            var v = _vHead = MeshUtils.Vertex.Create();
            var f = _fHead = MeshUtils.Face.Create();

            var pair = MeshUtils.EdgePair.Create();
            var e = _eHead = pair._e;
            var eSym = _eHeadSym = pair._eSym;

            v._next = v._prev = v;
            v._anEdge = null;

            f._next = f._prev = f;
            f._anEdge = null;
            f._trail = null;
            f._marked = false;
            f._inside = false;

            e._next = e;
            e._Sym = eSym;
            e._Onext = null;
            e._Lnext = null;
            e._Org = null;
            e._Lface = null;
            e._winding = 0;
            e._activeRegion = null;

            eSym._next = eSym;
            eSym._Sym = e;
            eSym._Onext = null;
            eSym._Lnext = null;
            eSym._Org = null;
            eSym._Lface = null;
            eSym._winding = 0;
            eSym._activeRegion = null;
        }

        public override void Reset()
        {
            _vHead = null;
            _fHead = null;
            _eHead = _eHeadSym = null;
        }

        public override void OnFree()
        {
            for (MeshUtils.Face f = _fHead._next, fNext = _fHead; f != _fHead; f = fNext)
            {
                fNext = f._next;
                f.Free();
            }
            for (MeshUtils.Vertex v = _vHead._next, vNext = _vHead; v != _vHead; v = vNext)
            {
                vNext = v._next;
                v.Free();
            }
            for (MeshUtils.Edge e = _eHead._next, eNext = _eHead; e != _eHead; e = eNext)
            {
                eNext = e._next;
                e.Free();
            }
        }

        /// <summary>
        /// Creates one edge, two vertices and a loop (face).
        /// The loop consists of the two new half-edges.
        /// </summary>
        public MeshUtils.Edge MakeEdge()
        {
            var e = MeshUtils.MakeEdge(_eHead);

            MeshUtils.MakeVertex(e, _vHead);
            MeshUtils.MakeVertex(e._Sym, _vHead);
            MeshUtils.MakeFace(e, _fHead);

            return e;
        }

        /// <summary>
        /// Splice is the basic operation for changing the
        /// mesh connectivity and topology.  It changes the mesh so that
        ///     eOrg->Onext = OLD( eDst->Onext )
        ///     eDst->Onext = OLD( eOrg->Onext )
        /// where OLD(...) means the value before the meshSplice operation.
        /// 
        /// This can have two effects on the vertex structure:
        ///  - if eOrg->Org != eDst->Org, the two vertices are merged together
        ///  - if eOrg->Org == eDst->Org, the origin is split into two vertices
        /// In both cases, eDst->Org is changed and eOrg->Org is untouched.
        /// 
        /// Similarly (and independently) for the face structure,
        ///  - if eOrg->Lface == eDst->Lface, one loop is split into two
        ///  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
        /// In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
        /// 
        /// Some special cases:
        /// If eDst == eOrg, the operation has no effect.
        /// If eDst == eOrg->Lnext, the new face will have a single edge.
        /// If eDst == eOrg->Lprev, the old face will have a single edge.
        /// If eDst == eOrg->Onext, the new vertex will have a single edge.
        /// If eDst == eOrg->Oprev, the old vertex will have a single edge.
        /// </summary>
        public void Splice(MeshUtils.Edge eOrg, MeshUtils.Edge eDst)
        {
            if (eOrg == eDst)
            {
                return;
            }

            bool joiningVertices = false;
            if (eDst._Org != eOrg._Org)
            {
                // We are merging two disjoint vertices -- destroy eDst->Org
                joiningVertices = true;
                MeshUtils.KillVertex(eDst._Org, eOrg._Org);
            }
            bool joiningLoops = false;
            if (eDst._Lface != eOrg._Lface)
            {
                // We are connecting two disjoint loops -- destroy eDst->Lface
                joiningLoops = true;
                MeshUtils.KillFace(eDst._Lface, eOrg._Lface);
            }

            // Change the edge structure
            MeshUtils.Splice(eDst, eOrg);

            if (!joiningVertices)
            {
                // We split one vertex into two -- the new vertex is eDst->Org.
                // Make sure the old vertex points to a valid half-edge.
                MeshUtils.MakeVertex(eDst, eOrg._Org);
                eOrg._Org._anEdge = eOrg;
            }
            if (!joiningLoops)
            {
                // We split one loop into two -- the new loop is eDst->Lface.
                // Make sure the old face points to a valid half-edge.
                MeshUtils.MakeFace(eDst, eOrg._Lface);
                eOrg._Lface._anEdge = eOrg;
            }
        }

        /// <summary>
        /// Removes the edge eDel. There are several cases:
        /// if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
        /// eDel->Lface is deleted. Otherwise, we are splitting one loop into two;
        /// the newly created loop will contain eDel->Dst. If the deletion of eDel
        /// would create isolated vertices, those are deleted as well.
        /// </summary>
        public void Delete(MeshUtils.Edge eDel)
        {
            var eDelSym = eDel._Sym;

            // First step: disconnect the origin vertex eDel->Org.  We make all
            // changes to get a consistent mesh in this "intermediate" state.

            bool joiningLoops = false;
            if (eDel._Lface != eDel._Rface)
            {
                // We are joining two loops into one -- remove the left face
                joiningLoops = true;
                MeshUtils.KillFace(eDel._Lface, eDel._Rface);
            }

            if (eDel._Onext == eDel)
            {
                MeshUtils.KillVertex(eDel._Org, null);
            }
            else
            {
                // Make sure that eDel->Org and eDel->Rface point to valid half-edges
                eDel._Rface._anEdge = eDel._Oprev;
                eDel._Org._anEdge = eDel._Onext;

                MeshUtils.Splice(eDel, eDel._Oprev);

                if (!joiningLoops)
                {
                    // We are splitting one loop into two -- create a new loop for eDel.
                    MeshUtils.MakeFace(eDel, eDel._Lface);
                }
            }

            // Claim: the mesh is now in a consistent state, except that eDel->Org
            // may have been deleted.  Now we disconnect eDel->Dst.

            if (eDelSym._Onext == eDelSym)
            {
                MeshUtils.KillVertex(eDelSym._Org, null);
                MeshUtils.KillFace(eDelSym._Lface, null);
            }
            else
            {
                // Make sure that eDel->Dst and eDel->Lface point to valid half-edges
                eDel._Lface._anEdge = eDelSym._Oprev;
                eDelSym._Org._anEdge = eDelSym._Onext;
                MeshUtils.Splice(eDelSym, eDelSym._Oprev);
            }

            // Any isolated vertices or faces have already been freed.
            MeshUtils.KillEdge(eDel);
        }

        /// <summary>
        /// Creates a new edge such that eNew == eOrg.Lnext and eNew.Dst is a newly created vertex.
        /// eOrg and eNew will have the same left face.
        /// </summary>
        public MeshUtils.Edge AddEdgeVertex(MeshUtils.Edge eOrg)
        {
            var eNew = MeshUtils.MakeEdge(eOrg);
            var eNewSym = eNew._Sym;

            // Connect the new edge appropriately
            MeshUtils.Splice(eNew, eOrg._Lnext);

            // Set vertex and face information
            eNew._Org = eOrg._Dst;
            MeshUtils.MakeVertex(eNewSym, eNew._Org);
            eNew._Lface = eNewSym._Lface = eOrg._Lface;

            return eNew;
        }

        /// <summary>
        /// Splits eOrg into two edges eOrg and eNew such that eNew == eOrg.Lnext.
        /// The new vertex is eOrg.Dst == eNew.Org.
        /// eOrg and eNew will have the same left face.
        /// </summary>
        public MeshUtils.Edge SplitEdge(MeshUtils.Edge eOrg)
        {
            var eTmp = AddEdgeVertex(eOrg);
            var eNew = eTmp._Sym;

            // Disconnect eOrg from eOrg->Dst and connect it to eNew->Org
            MeshUtils.Splice(eOrg._Sym, eOrg._Sym._Oprev);
            MeshUtils.Splice(eOrg._Sym, eNew);

            // Set the vertex and face information
            eOrg._Dst = eNew._Org;
            eNew._Dst._anEdge = eNew._Sym; // may have pointed to eOrg->Sym
            eNew._Rface = eOrg._Rface;
            eNew._winding = eOrg._winding; // copy old winding information
            eNew._Sym._winding = eOrg._Sym._winding;

            return eNew;
        }

        /// <summary>
        /// Creates a new edge from eOrg->Dst to eDst->Org, and returns the corresponding half-edge eNew.
        /// If eOrg->Lface == eDst->Lface, this splits one loop into two,
        /// and the newly created loop is eNew->Lface.  Otherwise, two disjoint
        /// loops are merged into one, and the loop eDst->Lface is destroyed.
        /// 
        /// If (eOrg == eDst), the new face will have only two edges.
        /// If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
        /// If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
        /// </summary>
        public MeshUtils.Edge Connect(MeshUtils.Edge eOrg, MeshUtils.Edge eDst)
        {
            var eNew = MeshUtils.MakeEdge(eOrg);
            var eNewSym = eNew._Sym;

            bool joiningLoops = false;
            if (eDst._Lface != eOrg._Lface)
            {
                // We are connecting two disjoint loops -- destroy eDst->Lface
                joiningLoops = true;
                MeshUtils.KillFace(eDst._Lface, eOrg._Lface);
            }

            // Connect the new edge appropriately
            MeshUtils.Splice(eNew, eOrg._Lnext);
            MeshUtils.Splice(eNewSym, eDst);

            // Set the vertex and face information
            eNew._Org = eOrg._Dst;
            eNewSym._Org = eDst._Org;
            eNew._Lface = eNewSym._Lface = eOrg._Lface;

            // Make sure the old face points to a valid half-edge
            eOrg._Lface._anEdge = eNewSym;

            if (!joiningLoops)
            {
                MeshUtils.MakeFace(eNew, eOrg._Lface);
            }

            return eNew;
        }

        /// <summary>
        /// Destroys a face and removes it from the global face list. All edges of
        /// fZap will have a NULL pointer as their left face. Any edges which
        /// also have a NULL pointer as their right face are deleted entirely
        /// (along with any isolated vertices this produces).
        /// An entire mesh can be deleted by zapping its faces, one at a time,
        /// in any order. Zapped faces cannot be used in further mesh operations!
        /// </summary>
        public void ZapFace(MeshUtils.Face fZap)
        {
            var eStart = fZap._anEdge;

            // walk around face, deleting edges whose right face is also NULL
            var eNext = eStart._Lnext;
            MeshUtils.Edge e, eSym;
            do {
                e = eNext;
                eNext = e._Lnext;

                e._Lface = null;
                if (e._Rface == null)
                {
                    // delete the edge -- see TESSmeshDelete above

                    if (e._Onext == e)
                    {
                        MeshUtils.KillVertex(e._Org, null);
                    }
                    else
                    {
                        // Make sure that e._Org points to a valid half-edge
                        e._Org._anEdge = e._Onext;
                        MeshUtils.Splice(e, e._Oprev);
                    }
                    eSym = e._Sym;
                    if (eSym._Onext == eSym)
                    {
                        MeshUtils.KillVertex(eSym._Org, null);
                    }
                    else
                    {
                        // Make sure that eSym._Org points to a valid half-edge
                        eSym._Org._anEdge = eSym._Onext;
                        MeshUtils.Splice(eSym, eSym._Oprev);
                    }
                    MeshUtils.KillEdge(e);
                }
            } while (e != eStart);

            /* delete from circular doubly-linked list */
            var fPrev = fZap._prev;
            var fNext = fZap._next;
            fNext._prev = fPrev;
            fPrev._next = fNext;

            fZap.Free();
        }

        public void MergeConvexFaces(int maxVertsPerFace)
        {
            for (var f = _fHead._next; f != _fHead; f = f._next)
            {
                // Skip faces which are outside the result
                if (!f._inside)
                {
                    continue;
                }

                var eCur = f._anEdge;
                var vStart = eCur._Org;

                while (true)
                {
                    var eNext = eCur._Lnext;
                    var eSym = eCur._Sym;

                    if (eSym != null && eSym._Lface != null && eSym._Lface._inside)
                    {
                        // Try to merge the neighbour faces if the resulting polygons
                        // does not exceed maximum number of vertices.
                        int curNv = f.VertsCount;
                        int symNv = eSym._Lface.VertsCount;
                        if ((curNv + symNv - 2) <= maxVertsPerFace)
                        {
                            // Merge if the resulting poly is convex.
                            if (Geom.VertCCW(eCur._Lprev._Org, eCur._Org, eSym._Lnext._Lnext._Org) &&
                                Geom.VertCCW(eSym._Lprev._Org, eSym._Org, eCur._Lnext._Lnext._Org))
                            {
                                eNext = eSym._Lnext;
                                Delete(eSym);
                                eCur = null;
                            }
                        }
                    }

                    if (eCur != null && eCur._Lnext._Org == vStart)
                        break;

                    // Continue to next edge.
                    eCur = eNext;
                }
            }
        }

        [Conditional("DEBUG")]
        public void Check()
        {
            MeshUtils.Edge e;

            MeshUtils.Face fPrev = _fHead, f;
            for (fPrev = _fHead; (f = fPrev._next) != _fHead; fPrev = f)
            {
                e = f._anEdge;
                do {
                    Debug.Assert(e._Sym != e);
                    Debug.Assert(e._Sym._Sym == e);
                    Debug.Assert(e._Lnext._Onext._Sym == e);
                    Debug.Assert(e._Onext._Sym._Lnext == e);
                    Debug.Assert(e._Lface == f);
                    e = e._Lnext;
                } while (e != f._anEdge);
            }
            Debug.Assert(f._prev == fPrev && f._anEdge == null);

            MeshUtils.Vertex vPrev = _vHead, v;
            for (vPrev = _vHead; (v = vPrev._next) != _vHead; vPrev = v)
            {
                Debug.Assert(v._prev == vPrev);
                e = v._anEdge;
                do
                {
                    Debug.Assert(e._Sym != e);
                    Debug.Assert(e._Sym._Sym == e);
                    Debug.Assert(e._Lnext._Onext._Sym == e);
                    Debug.Assert(e._Onext._Sym._Lnext == e);
                    Debug.Assert(e._Org == v);
                    e = e._Onext;
                } while (e != v._anEdge);
            }
            Debug.Assert(v._prev == vPrev && v._anEdge == null);

            MeshUtils.Edge ePrev = _eHead;
            for (ePrev = _eHead; (e = ePrev._next) != _eHead; ePrev = e)
            {
                Debug.Assert(e._Sym._next == ePrev._Sym);
                Debug.Assert(e._Sym != e);
                Debug.Assert(e._Sym._Sym == e);
                Debug.Assert(e._Org != null);
                Debug.Assert(e._Dst != null);
                Debug.Assert(e._Lnext._Onext._Sym == e);
                Debug.Assert(e._Onext._Sym._Lnext == e);
            }
            Debug.Assert(e._Sym._next == ePrev._Sym
                && e._Sym == _eHeadSym
                && e._Sym._Sym == e
                && e._Org == null && e._Dst == null
                && e._Lface == null && e._Rface == null);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/LTMesh.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/MeshUtils.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1906f51f269f2e8408b7aa54e1c8f10e
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

using System;
using System.Collections.Generic;
using System.Diagnostics;
#if ENABLE_IL2CPP == false
using System.Linq.Expressions;
#endif
using Real = System.Single;
namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    public struct Vec3
    {
        public readonly static Vec3 Zero = new Vec3();

        public Real X, Y, Z;

        public Real this[int index]
        {
            get
            {
                if (index == 0) return X;
                if (index == 1) return Y;
                if (index == 2) return Z;
                throw new IndexOutOfRangeException();
            }
            set
            {
                if (index == 0) X = value;
                else if (index == 1) Y = value;
                else if (index == 2) Z = value;
                else throw new IndexOutOfRangeException();
            }
        }

        public static void Sub(ref Vec3 lhs, ref Vec3 rhs, out Vec3 result)
        {
            result.X = lhs.X - rhs.X;
            result.Y = lhs.Y - rhs.Y;
            result.Z = lhs.Z - rhs.Z;
        }

        public static void Neg(ref Vec3 v)
        {
            v.X = -v.X;
            v.Y = -v.Y;
            v.Z = -v.Z;
        }

        public static void Dot(ref Vec3 u, ref Vec3 v, out Real dot)
        {
            dot = u.X * v.X + u.Y * v.Y + u.Z * v.Z;
        }

        public static void Normalize(ref Vec3 v)
        {
            var len = v.X * v.X + v.Y * v.Y + v.Z * v.Z;
            Debug.Assert(len >= 0.0f);
            len = 1.0f / (Real)Math.Sqrt(len);
            v.X *= len;
            v.Y *= len;
            v.Z *= len;
        }

        public static int LongAxis(ref Vec3 v)
        {
            int i = 0;
            if (Math.Abs(v.Y) > Math.Abs(v.X)) i = 1;
            if (Math.Abs(v.Z) > Math.Abs(i == 0 ? v.X : v.Y)) i = 2;
            return i;
        }

        public override string ToString()
        {
            return string.Format("{0}, {1}, {2}", X, Y, Z);
        }
    }

    internal static class MeshUtils
    {
        public const int Undef = ~0;

        public abstract class Pooled<T> where T : Pooled<T>, new()
        {
            private static Stack<T> _stack;

            public abstract void Reset();
            public virtual void OnFree() {}

#if ENABLE_IL2CPP == false
            private static readonly Func<T> OptimizedInstantiator = Expression.Lambda<Func<T>>(
                Expression.New(typeof(T))
            ).Compile();
#endif

            public static T Create()
            {
                if (_stack != null && _stack.Count > 0)
                {
                    return _stack.Pop();
                }
                return
#if ENABLE_IL2CPP == false
                    OptimizedInstantiator.Invoke()
#else
                    new T()
#endif
                    ;
            }

            public void Free()
            {
                OnFree();
                Reset();
                if (_stack == null)
                {
                    _stack = new Stack<T>();
                }
                _stack.Push((T)this);
            }
        }

        public class Vertex : Pooled<Vertex>
        {
            internal Vertex _prev, _next;
            internal Edge _anEdge;

            internal Vec3 _coords;
            internal Real _s, _t;
            internal PQHandle _pqHandle;
            internal int _n;
            internal object _data;

            public override void Reset()
            {
                _prev = _next = null;
                _anEdge = null;
                _coords = Vec3.Zero;
                _s = 0;
                _t = 0;
                _pqHandle = new PQHandle();
                _n = 0;
                _data = null;
            }
        }

        public class Face : Pooled<Face>
        {
            internal Face _prev, _next;
            internal Edge _anEdge;

            internal Face _trail;
            internal int _n;
            internal bool _marked, _inside;

            internal int VertsCount
            {
                get
                {
                    int n = 0;
                    var eCur = _anEdge;
                    do {
                        n++;
                        eCur = eCur._Lnext;
                    } while (eCur != _anEdge);
                    return n;
                }
            }

            public override void Reset()
            {
                _prev = _next = null;
                _anEdge = null;
                _trail = null;
                _n = 0;
                _marked = false;
                _inside = false;
            }
        }

        public struct EdgePair
        {
            internal Edge _e, _eSym;

            public static EdgePair Create()
            {
                var pair = new MeshUtils.EdgePair();
                pair._e = MeshUtils.Edge.Create();
                pair._e._pair = pair;
                pair._eSym = MeshUtils.Edge.Create();
                pair._eSym._pair = pair;
                return pair;
            }

            public void Reset()
            {
                _e = _eSym = null;
            }
        }

        public class Edge : Pooled<Edge>
        {
            internal EdgePair _pair;
            internal Edge _next, _Sym, _Onext, _Lnext;
            internal Vertex _Org;
            internal Face _Lface;
            internal Tess.ActiveRegion _activeRegion;
            internal int _winding;

            internal Face _Rface { get { return _Sym._Lface; } set { _Sym._Lface = value; } }
            internal Vertex _Dst { get { return _Sym._Org; }  set { _Sym._Org = value; } }

            internal Edge _Oprev { get { return _Sym._Lnext; } set { _Sym._Lnext = value; } }
            internal Edge _Lprev { get { return _Onext._Sym; } set { _Onext._Sym = value; } }
            internal Edge _Dprev { get { return _Lnext._Sym; } set { _Lnext._Sym = value; } }
            internal Edge _Rprev { get { return _Sym._Onext; } set { _Sym._Onext = value; } }
            internal Edge _Dnext { get { return _Rprev._Sym; } set { _Rprev._Sym = value; } }
            internal Edge _Rnext { get { return _Oprev._Sym; } set { _Oprev._Sym = value; } }

            internal static void EnsureFirst(ref Edge e)
            {
                if (e == e._pair._eSym)
                {
                    e = e._Sym;
                }
            }

            public override void Reset()
            {
                _pair.Reset();
                _next = _Sym = _Onext = _Lnext = null;
                _Org = null;
                _Lface = null;
                _activeRegion = null;
                _winding = 0;
            }
        }

        /// <summary>
        /// MakeEdge creates a new pair of half-edges which form their own loop.
        /// No vertex or face structures are allocated, but these must be assigned
        /// before the current edge operation is completed.
        /// </summary>
        public static Edge MakeEdge(Edge eNext)
        {
            Debug.Assert(eNext != null);

            var pair = EdgePair.Create();
            var e = pair._e;
            var eSym = pair._eSym;

            // Make sure eNext points to the first edge of the edge pair
            Edge.EnsureFirst(ref eNext);

            // Insert in circular doubly-linked list before eNext.
            // Note that the prev pointer is stored in Sym->next.
            var ePrev = eNext._Sym._next;
            eSym._next = ePrev;
            ePrev._Sym._next = e;
            e._next = eNext;
            eNext._Sym._next = eSym;

            e._Sym = eSym;
            e._Onext = e;
            e._Lnext = eSym;
            e._Org = null;
            e._Lface = null;
            e._winding = 0;
            e._activeRegion = null;

            eSym._Sym = e;
            eSym._Onext = eSym;
            eSym._Lnext = e;
            eSym._Org = null;
            eSym._Lface = null;
            eSym._winding = 0;
            eSym._activeRegion = null;

            return e;
        }

        /// <summary>
        /// Splice( a, b ) is best described by the Guibas/Stolfi paper or the
        /// CS348a notes (see Mesh.cs). Basically it modifies the mesh so that
        /// a->Onext and b->Onext are exchanged. This can have various effects
        /// depending on whether a and b belong to different face or vertex rings.
        /// For more explanation see Mesh.Splice().
        /// </summary>
        public static void Splice(Edge a, Edge b)
        {
            var aOnext = a._Onext;
            var bOnext = b._Onext;

            aOnext._Sym._Lnext = b;
            bOnext._Sym._Lnext = a;
            a._Onext = bOnext;
            b._Onext = aOnext;
        }

        /// <summary>
        /// MakeVertex( eOrig, vNext ) attaches a new vertex and makes it the
        /// origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
        /// a place to insert the new vertex in the global vertex list. We insert
        /// the new vertex *before* vNext so that algorithms which walk the vertex
        /// list will not see the newly created vertices.
        /// </summary>
        public static void MakeVertex(Edge eOrig, Vertex vNext)
        {
            var vNew = MeshUtils.Vertex.Create();

            // insert in circular doubly-linked list before vNext
            var vPrev = vNext._prev;
            vNew._prev = vPrev;
            vPrev._next = vNew;
            vNew._next = vNext;
            vNext._prev = vNew;

            vNew._anEdge = eOrig;
            // leave coords, s, t undefined

            // fix other edges on this vertex loop
            var e = eOrig;
            do {
                e._Org = vNew;
                e = e._Onext;
            } while (e != eOrig);
        }

        /// <summary>
        /// MakeFace( eOrig, fNext ) attaches a new face and makes it the left
        /// face of all edges in the face loop to which eOrig belongs. "fNext" gives
        /// a place to insert the new face in the global face list. We insert
        /// the new face *before* fNext so that algorithms which walk the face
        /// list will not see the newly created faces.
        /// </summary>
        public static void MakeFace(Edge eOrig, Face fNext)
        {
            var fNew = MeshUtils.Face.Create();

            // insert in circular doubly-linked list before fNext
            var fPrev = fNext._prev;
            fNew._prev = fPrev;
            fPrev._next = fNew;
            fNew._next = fNext;
            fNext._prev = fNew;

            fNew._anEdge = eOrig;
            fNew._trail = null;
            fNew._marked = false;

            // The new face is marked "inside" if the old one was. This is a
            // convenience for the common case where a face has been split in two.
            fNew._inside = fNext._inside;

            // fix other edges on this face loop
            var e = eOrig;
            do {
                e._Lface = fNew;
                e = e._Lnext;
            } while (e != eOrig);
        }

        /// <summary>
        /// KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
        /// and removes from the global edge list.
        /// </summary>
        public static void KillEdge(Edge eDel)
        {
            // Half-edges are allocated in pairs, see EdgePair above
            Edge.EnsureFirst(ref eDel);

            // delete from circular doubly-linked list
            var eNext = eDel._next;
            var ePrev = eDel._Sym._next;
            eNext._Sym._next = ePrev;
            ePrev._Sym._next = eNext;

            eDel.Free();
        }

        /// <summary>
        /// KillVertex( vDel ) destroys a vertex and removes it from the global
        /// vertex list. It updates the vertex loop to point to a given new vertex.
        /// </summary>
        public static void KillVertex(Vertex vDel, Vertex newOrg)
        {
            var eStart = vDel._anEdge;

            // change the origin of all affected edges
            var e = eStart;
            do {
                e._Org = newOrg;
                e = e._Onext;
            } while (e != eStart);

            // delete from circular doubly-linked list
            var vPrev = vDel._prev;
            var vNext = vDel._next;
            vNext._prev = vPrev;
            vPrev._next = vNext;

            vDel.Free();
        }

        /// <summary>
        /// KillFace( fDel ) destroys a face and removes it from the global face
        /// list. It updates the face loop to point to a given new face.
        /// </summary>
        public static void KillFace(Face fDel, Face newLFace)
        {
            var eStart = fDel._anEdge;

            // change the left face of all affected edges
            var e = eStart;
            do {
                e._Lface = newLFace;
                e = e._Lnext;
            } while (e != eStart);

            // delete from circular doubly-linked list
            var fPrev = fDel._prev;
            var fNext = fDel._next;
            fNext._prev = fPrev;
            fPrev._next = fNext;

            fDel.Free();
        }

        /// <summary>
        /// Return signed area of face.
        /// </summary>
        public static Real FaceArea(Face f)
        {
            Real area = 0;
            var e = f._anEdge;
            do
            {
                area += (e._Org._s - e._Dst._s) * (e._Org._t + e._Dst._t);
                e = e._Lnext;
            } while (e != f._anEdge);
            return area;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/MeshUtils.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/PriorityHeap.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e673e736d2b91564b83bbdcb63f296b7
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

using System;
using System.Diagnostics;

namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    internal struct PQHandle
    {
        public static readonly int Invalid = 0x0fffffff;
        internal int _handle;
    }

    internal class PriorityHeap<TValue> where TValue : class
    {
        public delegate bool LessOrEqual(TValue lhs, TValue rhs);

        protected class HandleElem
        {
            internal TValue _key;
            internal int _node;
        }

        private readonly LessOrEqual _leq;
        private int[] _nodes;
        private HandleElem[] _handles;
        private int _size, _max;
        private int _freeList;
        private bool _initialized;

        public bool Empty { get { return _size == 0; } }

        public PriorityHeap(int initialSize, LessOrEqual leq)
        {
            _leq = leq;

            _nodes = new int[initialSize + 1];
            _handles = new HandleElem[initialSize + 1];

            _size = 0;
            _max = initialSize;
            _freeList = 0;
            _initialized = false;

            _nodes[1] = 1;
            _handles[1] = new HandleElem { _key = null };
        }

        private void FloatDown(int curr)
        {
            int child;
            int hCurr, hChild;

            hCurr = _nodes[curr];
            while (true)
            {
                child = curr << 1;
                if (child < _size && _leq(_handles[_nodes[child + 1]]._key, _handles[_nodes[child]]._key))
                {
                    ++child;
                }

                Debug.Assert(child <= _max);

                hChild = _nodes[child];
                if (child > _size || _leq(_handles[hCurr]._key, _handles[hChild]._key))
                {
                    _nodes[curr] = hCurr;
                    _handles[hCurr]._node = curr;
                    break;
                }

                _nodes[curr] = hChild;
                _handles[hChild]._node = curr;
                curr = child;
            }
        }

        private void FloatUp(int curr)
        {
            int parent;
            int hCurr, hParent;

            hCurr = _nodes[curr];
            while (true)
            {
                parent = curr >> 1;
                hParent = _nodes[parent];
                if (parent == 0 || _leq(_handles[hParent]._key, _handles[hCurr]._key))
                {
                    _nodes[curr] = hCurr;
                    _handles[hCurr]._node = curr;
                    break;
                }
                _nodes[curr] = hParent;
                _handles[hParent]._node = curr;
                curr = parent;
            }
        }

        public void Init()
        {
            for (int i = _size; i >= 1; --i)
            {
                FloatDown(i);
            }
            _initialized = true;
        }

        public PQHandle Insert(TValue value)
        {
            int curr = ++_size;
            if ((curr * 2) > _max)
            {
                _max <<= 1;
                Array.Resize(ref _nodes, _max + 1);
                Array.Resize(ref _handles, _max + 1);
            }

            int free;
            if (_freeList == 0)
            {
                free = curr;
            }
            else
            {
                free = _freeList;
                _freeList = _handles[free]._node;
            }

            _nodes[curr] = free;
            if (_handles[free] == null)
            {
                _handles[free] = new HandleElem { _key = value, _node = curr };
            }
            else
            {
                _handles[free]._node = curr;
                _handles[free]._key = value;
            }

            if (_initialized)
            {
                FloatUp(curr);
            }

            Debug.Assert(free != PQHandle.Invalid);
            return new PQHandle { _handle = free };
        }

        public TValue ExtractMin()
        {
            Debug.Assert(_initialized);

            int hMin = _nodes[1];
            TValue min = _handles[hMin]._key;

            if (_size > 0)
            {
                _nodes[1] = _nodes[_size];
                _handles[_nodes[1]]._node = 1;

                _handles[hMin]._key = null;
                _handles[hMin]._node = _freeList;
                _freeList = hMin;

                if (--_size > 0)
                {
                    FloatDown(1);
                }
            }

            return min;
        }

        public TValue Minimum()
        {
            Debug.Assert(_initialized);
            return _handles[_nodes[1]]._key;
        }

        public void Remove(PQHandle handle)
        {
            Debug.Assert(_initialized);

            int hCurr = handle._handle;
            Debug.Assert(hCurr >= 1 && hCurr <= _max && _handles[hCurr]._key != null);

            int curr = _handles[hCurr]._node;
            _nodes[curr] = _nodes[_size];
            _handles[_nodes[curr]]._node = curr;

            if (curr <= --_size)
            {
                if (curr <= 1 || _leq(_handles[_nodes[curr >> 1]]._key, _handles[_nodes[curr]]._key))
                {
                    FloatDown(curr);
                }
                else
                {
                    FloatUp(curr);
                }
            }

            _handles[hCurr]._key = null;
            _handles[hCurr]._node = _freeList;
            _freeList = hCurr;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/PriorityHeap.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/PriorityQueue.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 82a1a0638ccce9f42acb7e3e0c3134ba
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    internal class PriorityQueue<TValue> where TValue : class
    {
        private PriorityHeap<TValue>.LessOrEqual _leq;
        private PriorityHeap<TValue> _heap;
        private TValue[] _keys;
        private int[] _order;

        private int _size, _max;
        private bool _initialized;

        public bool Empty { get { return _size == 0 && _heap.Empty; } }

        public PriorityQueue(int initialSize, PriorityHeap<TValue>.LessOrEqual leq)
        {
            _leq = leq;
            _heap = new PriorityHeap<TValue>(initialSize, leq);

            _keys = new TValue[initialSize];

            _size = 0;
            _max = initialSize;
            _initialized = false;
        }

        class StackItem
        {
            internal int p, r;
        };

        static void Swap(ref int a, ref int b)
        {
            (b, a) = (a, b);
        }

        public void Init()
        {
            var stack = new Stack<StackItem>();
            int p, r, i, j, piv;
            uint seed = 2016473283;

            p = 0;
            r = _size - 1;
            _order = new int[_size + 1];
            for (piv = 0, i = p; i <= r; ++piv, ++i)
            {
                _order[i] = piv;
            }

            stack.Push(new StackItem { p = p, r = r });
            while (stack.Count > 0)
            {
                var top = stack.Pop();
                p = top.p;
                r = top.r;

                while (r > p + 10)
                {
                    seed = seed * 1539415821 + 1;
                    i = p + (int)(seed % (r - p + 1));
                    piv = _order[i];
                    _order[i] = _order[p];
                    _order[p] = piv;
                    i = p - 1;
                    j = r + 1;
                    do {
                        do { ++i; } while (!_leq(_keys[_order[i]], _keys[piv]));
                        do { --j; } while (!_leq(_keys[piv], _keys[_order[j]]));
                        Swap(ref _order[i], ref _order[j]);
                    } while (i < j);
                    Swap(ref _order[i], ref _order[j]);
                    if (i - p < r - j)
                    {
                        stack.Push(new StackItem { p = j + 1, r = r });
                        r = i - 1;
                    }
                    else
                    {
                        stack.Push(new StackItem { p = p, r = i - 1 });
                        p = j + 1;
                    }
                }
                for (i = p + 1; i <= r; ++i)
                {
                    piv = _order[i];
                    for (j = i; j > p && !_leq(_keys[piv], _keys[_order[j - 1]]); --j)
                    {
                        _order[j] = _order[j - 1];
                    }
                    _order[j] = piv;
                }
            }

#if DEBUG
            p = 0;
            r = _size - 1;
            for (i = p; i < r; ++i)
            {
                Debug.Assert(_leq(_keys[_order[i + 1]], _keys[_order[i]]), "Wrong sort");
            }
#endif

            _max = _size;
            _initialized = true;
            _heap.Init();
        }

        public PQHandle Insert(TValue value)
        {
            if (_initialized)
            {
                return _heap.Insert(value);
            }

            int curr = _size;
            if (++_size >= _max)
            {
                _max <<= 1;
                Array.Resize(ref _keys, _max);
            }

            _keys[curr] = value;
            return new PQHandle { _handle = -(curr + 1) };
        }

        public TValue ExtractMin()
        {
            Debug.Assert(_initialized);

            if (_size == 0)
            {
                return _heap.ExtractMin();
            }
            TValue sortMin = _keys[_order[_size - 1]];
            if (!_heap.Empty)
            {
                TValue heapMin = _heap.Minimum();
                if (_leq(heapMin, sortMin))
                    return _heap.ExtractMin();
            }
            do {
                --_size;
            } while (_size > 0 && _keys[_order[_size - 1]] == null);

            return sortMin;
        }

        public TValue Minimum()
        {
            Debug.Assert(_initialized);

            if (_size == 0)
            {
                return _heap.Minimum();
            }
            TValue sortMin = _keys[_order[_size - 1]];
            if (!_heap.Empty)
            {
                TValue heapMin = _heap.Minimum();
                if (_leq(heapMin, sortMin))
                    return heapMin;
            }
            return sortMin;
        }

        public void Remove(PQHandle handle)
        {
            Debug.Assert(_initialized);

            int curr = handle._handle;
            if (curr >= 0)
            {
                _heap.Remove(handle);
                return;
            }
            curr = -(curr + 1);
            Debug.Assert(curr < _max && _keys[curr] != null);

            _keys[curr] = null;
            while (_size > 0 && _keys[_order[_size - 1]] == null)
            {
                --_size;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/PriorityQueue.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Sweep.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eef0fc2628b35374394c6de7d1de2c34
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

using System;
using System.Diagnostics;

using Real = System.Single;
namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    public partial class Tess
    {
        internal class ActiveRegion
        {
            internal MeshUtils.Edge _eUp;
            internal Dict<ActiveRegion>.Node _nodeUp;
            internal int _windingNumber;
            internal bool _inside, _sentinel, _dirty, _fixUpperEdge;
        }

        private ActiveRegion RegionBelow(ActiveRegion reg)
        {
            return reg._nodeUp._prev._key;
        }

        private ActiveRegion RegionAbove(ActiveRegion reg)
        {
            return reg._nodeUp._next._key;
        }

        /// <summary>
        /// Both edges must be directed from right to left (this is the canonical
        /// direction for the upper edge of each region).
        /// 
        /// The strategy is to evaluate a "t" value for each edge at the
        /// current sweep line position, given by tess->event. The calculations
        /// are designed to be very stable, but of course they are not perfect.
        /// 
        /// Special case: if both edge destinations are at the sweep event,
        /// we sort the edges by slope (they would otherwise compare equally).
        /// </summary>
        private bool EdgeLeq(ActiveRegion reg1, ActiveRegion reg2)
        {
            var e1 = reg1._eUp;
            var e2 = reg2._eUp;

            if (e1._Dst == _event)
            {
                if (e2._Dst == _event)
                {
                    // Two edges right of the sweep line which meet at the sweep event.
                    // Sort them by slope.
                    if (Geom.VertLeq(e1._Org, e2._Org))
                    {
                        return Geom.EdgeSign(e2._Dst, e1._Org, e2._Org) <= 0.0f;
                    }
                    return Geom.EdgeSign(e1._Dst, e2._Org, e1._Org) >= 0.0f;
                }
                return Geom.EdgeSign(e2._Dst, _event, e2._Org) <= 0.0f;
            }
            if (e2._Dst == _event)
            {
                return Geom.EdgeSign(e1._Dst, _event, e1._Org) >= 0.0f;
            }

            // General case - compute signed distance *from* e1, e2 to event
            var t1 = Geom.EdgeEval(e1._Dst, _event, e1._Org);
            var t2 = Geom.EdgeEval(e2._Dst, _event, e2._Org);
            return (t1 >= t2);
        }

        private void DeleteRegion(ActiveRegion reg)
        {
            if (reg._fixUpperEdge)
            {
                // It was created with zero winding number, so it better be
                // deleted with zero winding number (ie. it better not get merged
                // with a real edge).
                Debug.Assert(reg._eUp._winding == 0);
            }
            reg._eUp._activeRegion = null;
            _dict.Remove(reg._nodeUp);
        }

        /// <summary>
        /// Replace an upper edge which needs fixing (see ConnectRightVertex).
        /// </summary>
        private void FixUpperEdge(ActiveRegion reg, MeshUtils.Edge newEdge)
        {
            Debug.Assert(reg._fixUpperEdge);
            _mesh.Delete(reg._eUp);
            reg._fixUpperEdge = false;
            reg._eUp = newEdge;
            newEdge._activeRegion = reg;
        }

        private ActiveRegion TopLeftRegion(ActiveRegion reg)
        {
            var org = reg._eUp._Org;

            // Find the region above the uppermost edge with the same origin
            do {
                reg = RegionAbove(reg);
            } while (reg._eUp._Org == org);

            // If the edge above was a temporary edge introduced by ConnectRightVertex,
            // now is the time to fix it.
            if (reg._fixUpperEdge)
            {
                var e = _mesh.Connect(RegionBelow(reg)._eUp._Sym, reg._eUp._Lnext);
                FixUpperEdge(reg, e);
                reg = RegionAbove(reg);
            }

            return reg;
        }

        private ActiveRegion TopRightRegion(ActiveRegion reg)
        {
            var dst = reg._eUp._Dst;

            // Find the region above the uppermost edge with the same destination
            do {
                reg = RegionAbove(reg);
            } while (reg._eUp._Dst == dst);

            return reg;
        }

        /// <summary>
        /// Add a new active region to the sweep line, *somewhere* below "regAbove"
        /// (according to where the new edge belongs in the sweep-line dictionary).
        /// The upper edge of the new region will be "eNewUp".
        /// Winding number and "inside" flag are not updated.
        /// </summary>
        private ActiveRegion AddRegionBelow(ActiveRegion regAbove, MeshUtils.Edge eNewUp)
        {
            var regNew = new ActiveRegion();

            regNew._eUp = eNewUp;
            regNew._nodeUp = _dict.InsertBefore(regAbove._nodeUp, regNew);
            regNew._fixUpperEdge = false;
            regNew._sentinel = false;
            regNew._dirty = false;

            eNewUp._activeRegion = regNew;

            return regNew;
        }

        private void ComputeWinding(ActiveRegion reg)
        {
            reg._windingNumber = RegionAbove(reg)._windingNumber + reg._eUp._winding;
            reg._inside = Geom.IsWindingInside(_windingRule, reg._windingNumber);
        }

        /// <summary>
        /// Delete a region from the sweep line. This happens when the upper
        /// and lower chains of a region meet (at a vertex on the sweep line).
        /// The "inside" flag is copied to the appropriate mesh face (we could
        /// not do this before -- since the structure of the mesh is always
        /// changing, this face may not have even existed until now).
        /// </summary>
        private void FinishRegion(ActiveRegion reg)
        {
            var e = reg._eUp;
            var f = e._Lface;

            f._inside = reg._inside;
            f._anEdge = e;
            DeleteRegion(reg);
        }

        /// <summary>
        /// We are given a vertex with one or more left-going edges.  All affected
        /// edges should be in the edge dictionary.  Starting at regFirst->eUp,
        /// we walk down deleting all regions where both edges have the same
        /// origin vOrg.  At the same time we copy the "inside" flag from the
        /// active region to the face, since at this point each face will belong
        /// to at most one region (this was not necessarily true until this point
        /// in the sweep).  The walk stops at the region above regLast; if regLast
        /// is null we walk as far as possible.  At the same time we relink the
        /// mesh if necessary, so that the ordering of edges around vOrg is the
        /// same as in the dictionary.
        /// </summary>
        private MeshUtils.Edge FinishLeftRegions(ActiveRegion regFirst, ActiveRegion regLast)
        {
            var regPrev = regFirst;
            var ePrev = regFirst._eUp;

            while (regPrev != regLast)
            {
                regPrev._fixUpperEdge = false;	// placement was OK
                var reg = RegionBelow(regPrev);
                var e = reg._eUp;
                if (e._Org != ePrev._Org)
                {
                    if (!reg._fixUpperEdge)
                    {
                        // Remove the last left-going edge.  Even though there are no further
                        // edges in the dictionary with this origin, there may be further
                        // such edges in the mesh (if we are adding left edges to a vertex
                        // that has already been processed).  Thus it is important to call
                        // FinishRegion rather than just DeleteRegion.
                        FinishRegion(regPrev);
                        break;
                    }
                    // If the edge below was a temporary edge introduced by
                    // ConnectRightVertex, now is the time to fix it.
                    e = _mesh.Connect(ePrev._Lprev, e._Sym);
                    FixUpperEdge(reg, e);
                }

                // Relink edges so that ePrev.Onext == e
                if (ePrev._Onext != e)
                {
                    _mesh.Splice(e._Oprev, e);
                    _mesh.Splice(ePrev, e);
                }
                FinishRegion(regPrev); // may change reg.eUp
                ePrev = reg._eUp;
                regPrev = reg;
            }

            return ePrev;
        }

        /// <summary>
        /// Purpose: insert right-going edges into the edge dictionary, and update
        /// winding numbers and mesh connectivity appropriately.  All right-going
        /// edges share a common origin vOrg.  Edges are inserted CCW starting at
        /// eFirst; the last edge inserted is eLast.Oprev.  If vOrg has any
        /// left-going edges already processed, then eTopLeft must be the edge
        /// such that an imaginary upward vertical segment from vOrg would be
        /// contained between eTopLeft.Oprev and eTopLeft; otherwise eTopLeft
        /// should be null.
        /// </summary>
        private void AddRightEdges(ActiveRegion regUp, MeshUtils.Edge eFirst, MeshUtils.Edge eLast, MeshUtils.Edge eTopLeft, bool cleanUp)
        {
            bool firstTime = true;

            var e = eFirst; do
            {
                Debug.Assert(Geom.VertLeq(e._Org, e._Dst));
                AddRegionBelow(regUp, e._Sym);
                e = e._Onext;
            } while (e != eLast);

            // Walk *all* right-going edges from e.Org, in the dictionary order,
            // updating the winding numbers of each region, and re-linking the mesh
            // edges to match the dictionary ordering (if necessary).
            if (eTopLeft == null)
            {
                eTopLeft = RegionBelow(regUp)._eUp._Rprev;
            }

            ActiveRegion regPrev = regUp, reg;
            var ePrev = eTopLeft;
            while (true)
            {
                reg = RegionBelow(regPrev);
                e = reg._eUp._Sym;
                if (e._Org != ePrev._Org) break;

                if (e._Onext != ePrev)
                {
                    // Unlink e from its current position, and relink below ePrev
                    _mesh.Splice(e._Oprev, e);
                    _mesh.Splice(ePrev._Oprev, e);
                }
                // Compute the winding number and "inside" flag for the new regions
                reg._windingNumber = regPrev._windingNumber - e._winding;
                reg._inside = Geom.IsWindingInside(_windingRule, reg._windingNumber);

                // Check for two outgoing edges with same slope -- process these
                // before any intersection tests (see example in tessComputeInterior).
                regPrev._dirty = true;
                if (!firstTime && CheckForRightSplice(regPrev))
                {
                    Geom.AddWinding(e, ePrev);
                    DeleteRegion(regPrev);
                    _mesh.Delete(ePrev);
                }
                firstTime = false;
                regPrev = reg;
                ePrev = e;
            }
            regPrev._dirty = true;
            Debug.Assert(regPrev._windingNumber - e._winding == reg._windingNumber);

            if (cleanUp)
            {
                // Check for intersections between newly adjacent edges.
                WalkDirtyRegions(regPrev);
            }
        }

        /// <summary>
        /// Two vertices with idential coordinates are combined into one.
        /// e1.Org is kept, while e2.Org is discarded.
        /// </summary>
        private void SpliceMergeVertices(MeshUtils.Edge e1, MeshUtils.Edge e2)
        {
            _mesh.Splice(e1, e2);
        }

        /// <summary>
        /// Find some weights which describe how the intersection vertex is
        /// a linear combination of "org" and "dest".  Each of the two edges
        /// which generated "isect" is allocated 50% of the weight; each edge
        /// splits the weight between its org and dst according to the
        /// relative distance to "isect".
        /// </summary>
        private void VertexWeights(MeshUtils.Vertex isect, MeshUtils.Vertex org, MeshUtils.Vertex dst, out Real w0, out Real w1)
        {
            var t1 = Geom.VertL1dist(org, isect);
            var t2 = Geom.VertL1dist(dst, isect);

            w0 = (t2 / (t1 + t2)) / 2.0f;
            w1 = (t1 / (t1 + t2)) / 2.0f;

            isect._coords.X += w0 * org._coords.X + w1 * dst._coords.X;
            isect._coords.Y += w0 * org._coords.Y + w1 * dst._coords.Y;
            isect._coords.Z += w0 * org._coords.Z + w1 * dst._coords.Z;
        }

        /// <summary>
        /// We've computed a new intersection point, now we need a "data" pointer
        /// from the user so that we can refer to this new vertex in the
        /// rendering callbacks.
        /// </summary>
        private void GetIntersectData(MeshUtils.Vertex isect, MeshUtils.Vertex orgUp, MeshUtils.Vertex dstUp, MeshUtils.Vertex orgLo, MeshUtils.Vertex dstLo)
        {
            isect._coords = Vec3.Zero;
            Real w0, w1, w2, w3;
            VertexWeights(isect, orgUp, dstUp, out w0, out w1);
            VertexWeights(isect, orgLo, dstLo, out w2, out w3);

            if (_combineCallback != null)
            {
                isect._data = _combineCallback(
                    isect._coords,
                    new object[] { orgUp._data, dstUp._data, orgLo._data, dstLo._data },
                    new Real[] { w0, w1, w2, w3 }
                );
            }
        }

        /// <summary>
        /// Check the upper and lower edge of "regUp", to make sure that the
        /// eUp->Org is above eLo, or eLo->Org is below eUp (depending on which
        /// origin is leftmost).
        /// 
        /// The main purpose is to splice right-going edges with the same
        /// dest vertex and nearly identical slopes (ie. we can't distinguish
        /// the slopes numerically).  However the splicing can also help us
        /// to recover from numerical errors.  For example, suppose at one
        /// point we checked eUp and eLo, and decided that eUp->Org is barely
        /// above eLo.  Then later, we split eLo into two edges (eg. from
        /// a splice operation like this one).  This can change the result of
        /// our test so that now eUp->Org is incident to eLo, or barely below it.
        /// We must correct this condition to maintain the dictionary invariants.
        /// 
        /// One possibility is to check these edges for intersection again
        /// (ie. CheckForIntersect).  This is what we do if possible.  However
        /// CheckForIntersect requires that tess->event lies between eUp and eLo,
        /// so that it has something to fall back on when the intersection
        /// calculation gives us an unusable answer.  So, for those cases where
        /// we can't check for intersection, this routine fixes the problem
        /// by just splicing the offending vertex into the other edge.
        /// This is a guaranteed solution, no matter how degenerate things get.
        /// Basically this is a combinatorial solution to a numerical problem.
        /// </summary>
        private bool CheckForRightSplice(ActiveRegion regUp)
        {
            var regLo = RegionBelow(regUp);
            var eUp = regUp._eUp;
            var eLo = regLo._eUp;

            if (Geom.VertLeq(eUp._Org, eLo._Org))
            {
                if (Geom.EdgeSign(eLo._Dst, eUp._Org, eLo._Org) > 0.0f)
                {
                    return false;
                }

                // eUp.Org appears to be below eLo
                if (!Geom.VertEq(eUp._Org, eLo._Org))
                {
                    // Splice eUp._Org into eLo
                    _mesh.SplitEdge(eLo._Sym);
                    _mesh.Splice(eUp, eLo._Oprev);
                    regUp._dirty = regLo._dirty = true;
                }
                else if (eUp._Org != eLo._Org)
                {
                    // merge the two vertices, discarding eUp.Org
                    _pq.Remove(eUp._Org._pqHandle);
                    SpliceMergeVertices(eLo._Oprev, eUp);
                }
            }
            else
            {
                if (Geom.EdgeSign(eUp._Dst, eLo._Org, eUp._Org) < 0.0f)
                {
                    return false;
                }

                // eLo.Org appears to be above eUp, so splice eLo.Org into eUp
                RegionAbove(regUp)._dirty = regUp._dirty = true;
                _mesh.SplitEdge(eUp._Sym);
                _mesh.Splice(eLo._Oprev, eUp);
            }
            return true;
        }
        
        /// <summary>
        /// Check the upper and lower edge of "regUp", to make sure that the
        /// eUp->Dst is above eLo, or eLo->Dst is below eUp (depending on which
        /// destination is rightmost).
        /// 
        /// Theoretically, this should always be true.  However, splitting an edge
        /// into two pieces can change the results of previous tests.  For example,
        /// suppose at one point we checked eUp and eLo, and decided that eUp->Dst
        /// is barely above eLo.  Then later, we split eLo into two edges (eg. from
        /// a splice operation like this one).  This can change the result of
        /// the test so that now eUp->Dst is incident to eLo, or barely below it.
        /// We must correct this condition to maintain the dictionary invariants
        /// (otherwise new edges might get inserted in the wrong place in the
        /// dictionary, and bad stuff will happen).
        /// 
        /// We fix the problem by just splicing the offending vertex into the
        /// other edge.
        /// </summary>
        private bool CheckForLeftSplice(ActiveRegion regUp)
        {
            var regLo = RegionBelow(regUp);
            var eUp = regUp._eUp;
            var eLo = regLo._eUp;

            Debug.Assert(!Geom.VertEq(eUp._Dst, eLo._Dst));

            if (Geom.VertLeq(eUp._Dst, eLo._Dst))
            {
                if (Geom.EdgeSign(eUp._Dst, eLo._Dst, eUp._Org) < 0.0f)
                {
                    return false;
                }

                // eLo.Dst is above eUp, so splice eLo.Dst into eUp
                RegionAbove(regUp)._dirty = regUp._dirty = true;
                var e = _mesh.SplitEdge(eUp);
                _mesh.Splice(eLo._Sym, e);
                e._Lface._inside = regUp._inside;
            }
            else
            {
                if (Geom.EdgeSign(eLo._Dst, eUp._Dst, eLo._Org) > 0.0f)
                {
                    return false;
                }

                // eUp.Dst is below eLo, so splice eUp.Dst into eLo
                regUp._dirty = regLo._dirty = true;
                var e = _mesh.SplitEdge(eLo);
                _mesh.Splice(eUp._Lnext, eLo._Sym);
                e._Rface._inside = regUp._inside;
            }
            return true;
        }

        /// <summary>
        /// Check the upper and lower edges of the given region to see if
        /// they intersect.  If so, create the intersection and add it
        /// to the data structures.
        /// 
        /// Returns TRUE if adding the new intersection resulted in a recursive
        /// call to AddRightEdges(); in this case all "dirty" regions have been
        /// checked for intersections, and possibly regUp has been deleted.
        /// </summary>
        private bool CheckForIntersect(ActiveRegion regUp)
        {
            var regLo = RegionBelow(regUp);
            var eUp = regUp._eUp;
            var eLo = regLo._eUp;
            var orgUp = eUp._Org;
            var orgLo = eLo._Org;
            var dstUp = eUp._Dst;
            var dstLo = eLo._Dst;

            Debug.Assert(!Geom.VertEq(dstLo, dstUp));
            Debug.Assert(Geom.EdgeSign(dstUp, _event, orgUp) <= 0.0f);
            Debug.Assert(Geom.EdgeSign(dstLo, _event, orgLo) >= 0.0f);
            Debug.Assert(orgUp != _event && orgLo != _event);
            Debug.Assert(!regUp._fixUpperEdge && !regLo._fixUpperEdge);

            if( orgUp == orgLo )
            {
                // right endpoints are the same
                return false;
            }

            var tMinUp = Math.Min(orgUp._t, dstUp._t);
            var tMaxLo = Math.Max(orgLo._t, dstLo._t);
            if( tMinUp > tMaxLo )
            {
                // t ranges do not overlap
                return false;
            }

            if (Geom.VertLeq(orgUp, orgLo))
            {
                if (Geom.EdgeSign( dstLo, orgUp, orgLo ) > 0.0f)
                {
                    return false;
                }
            }
            else
            {
                if (Geom.EdgeSign( dstUp, orgLo, orgUp ) < 0.0f)
                {
                    return false;
                }
            }

            // At this point the edges intersect, at least marginally

            var isect = MeshUtils.Vertex.Create();
            Geom.EdgeIntersect(dstUp, orgUp, dstLo, orgLo, isect);
            // The following properties are guaranteed:
            Debug.Assert(Math.Min(orgUp._t, dstUp._t) <= isect._t);
            Debug.Assert(isect._t <= Math.Max(orgLo._t, dstLo._t));
            Debug.Assert(Math.Min(dstLo._s, dstUp._s) <= isect._s);
            Debug.Assert(isect._s <= Math.Max(orgLo._s, orgUp._s));

            if (Geom.VertLeq(isect, _event))
            {
                // The intersection point lies slightly to the left of the sweep line,
                // so move it until it''s slightly to the right of the sweep line.
                // (If we had perfect numerical precision, this would never happen
                // in the first place). The easiest and safest thing to do is
                // replace the intersection by tess._event.
                isect._s = _event._s;
                isect._t = _event._t;
            }
            // Similarly, if the computed intersection lies to the right of the
            // rightmost origin (which should rarely happen), it can cause
            // unbelievable inefficiency on sufficiently degenerate inputs.
            // (If you have the test program, try running test54.d with the
            // "X zoom" option turned on).
            var orgMin = Geom.VertLeq(orgUp, orgLo) ? orgUp : orgLo;
            if (Geom.VertLeq(orgMin, isect))
            {
                isect._s = orgMin._s;
                isect._t = orgMin._t;
            }

            if (Geom.VertEq(isect, orgUp) || Geom.VertEq(isect, orgLo))
            {
                // Easy case -- intersection at one of the right endpoints
                CheckForRightSplice(regUp);
                return false;
            }

            if (   (! Geom.VertEq(dstUp, _event)
                && Geom.EdgeSign(dstUp, _event, isect) >= 0.0f)
                || (! Geom.VertEq(dstLo, _event)
                && Geom.EdgeSign(dstLo, _event, isect) <= 0.0f))
            {
                // Very unusual -- the new upper or lower edge would pass on the
                // wrong side of the sweep event, or through it. This can happen
                // due to very small numerical errors in the intersection calculation.
                if (dstLo == _event)
                {
                    // Splice dstLo into eUp, and process the new region(s)
                    _mesh.SplitEdge(eUp._Sym);
                    _mesh.Splice(eLo._Sym, eUp);
                    regUp = TopLeftRegion(regUp);
                    eUp = RegionBelow(regUp)._eUp;
                    FinishLeftRegions(RegionBelow(regUp), regLo);
                    AddRightEdges(regUp, eUp._Oprev, eUp, eUp, true);
                    return true;
                }
                if( dstUp == _event ) {
                    /* Splice dstUp into eLo, and process the new region(s) */
                    _mesh.SplitEdge(eLo._Sym);
                    _mesh.Splice(eUp._Lnext, eLo._Oprev);
                    regLo = regUp;
                    regUp = TopRightRegion(regUp);
                    var e = RegionBelow(regUp)._eUp._Rprev;
                    regLo._eUp = eLo._Oprev;
                    eLo = FinishLeftRegions(regLo, null);
                    AddRightEdges(regUp, eLo._Onext, eUp._Rprev, e, true);
                    return true;
                }
                // Special case: called from ConnectRightVertex. If either
                // edge passes on the wrong side of tess._event, split it
                // (and wait for ConnectRightVertex to splice it appropriately).
                if (Geom.EdgeSign( dstUp, _event, isect ) >= 0.0f)
                {
                    RegionAbove(regUp)._dirty = regUp._dirty = true;
                    _mesh.SplitEdge(eUp._Sym);
                    eUp._Org._s = _event._s;
                    eUp._Org._t = _event._t;
                }
                if (Geom.EdgeSign(dstLo, _event, isect) <= 0.0f)
                {
                    regUp._dirty = regLo._dirty = true;
                    _mesh.SplitEdge(eLo._Sym);
                    eLo._Org._s = _event._s;
                    eLo._Org._t = _event._t;
                }
                // leave the rest for ConnectRightVertex
                return false;
            }

            // General case -- split both edges, splice into new vertex.
            // When we do the splice operation, the order of the arguments is
            // arbitrary as far as correctness goes. However, when the operation
            // creates a new face, the work done is proportional to the size of
            // the new face.  We expect the faces in the processed part of
            // the mesh (ie. eUp._Lface) to be smaller than the faces in the
            // unprocessed original contours (which will be eLo._Oprev._Lface).
            _mesh.SplitEdge(eUp._Sym);
            _mesh.SplitEdge(eLo._Sym);
            _mesh.Splice(eLo._Oprev, eUp);
            eUp._Org._s = isect._s;
            eUp._Org._t = isect._t;
            eUp._Org._pqHandle = _pq.Insert(eUp._Org);
            if (eUp._Org._pqHandle._handle == PQHandle.Invalid)
            {
                throw new InvalidOperationException("PQHandle should not be invalid");
            }
            GetIntersectData(eUp._Org, orgUp, dstUp, orgLo, dstLo);
            RegionAbove(regUp)._dirty = regUp._dirty = regLo._dirty = true;
            return false;
        }

        /// <summary>
        /// When the upper or lower edge of any region changes, the region is
        /// marked "dirty".  This routine walks through all the dirty regions
        /// and makes sure that the dictionary invariants are satisfied
        /// (see the comments at the beginning of this file).  Of course
        /// new dirty regions can be created as we make changes to restore
        /// the invariants.
        /// </summary>
        private void WalkDirtyRegions(ActiveRegion regUp)
        {
            var regLo = RegionBelow(regUp);
            MeshUtils.Edge eUp, eLo;

            while (true)
            {
                // Find the lowest dirty region (we walk from the bottom up).
                while (regLo._dirty)
                {
                    regUp = regLo;
                    regLo = RegionBelow(regLo);
                }
                if (!regUp._dirty)
                {
                    regLo = regUp;
                    regUp = RegionAbove( regUp );
                    if(regUp == null || !regUp._dirty)
                    {
                        // We've walked all the dirty regions
                        return;
                    }
                }
                regUp._dirty = false;
                eUp = regUp._eUp;
                eLo = regLo._eUp;

                if (eUp._Dst != eLo._Dst)
                {
                    // Check that the edge ordering is obeyed at the Dst vertices.
                    if (CheckForLeftSplice(regUp))
                    {

                        // If the upper or lower edge was marked fixUpperEdge, then
                        // we no longer need it (since these edges are needed only for
                        // vertices which otherwise have no right-going edges).
                        if (regLo._fixUpperEdge)
                        {
                            DeleteRegion(regLo);
                            _mesh.Delete(eLo);
                            regLo = RegionBelow(regUp);
                            eLo = regLo._eUp;
                        }
                        else if( regUp._fixUpperEdge )
                        {
                            DeleteRegion(regUp);
                            _mesh.Delete(eUp);
                            regUp = RegionAbove(regLo);
                            eUp = regUp._eUp;
                        }
                    }
                }
                if (eUp._Org != eLo._Org)
                {
                    if(    eUp._Dst != eLo._Dst
                        && ! regUp._fixUpperEdge && ! regLo._fixUpperEdge
                        && (eUp._Dst == _event || eLo._Dst == _event) )
                    {
                        // When all else fails in CheckForIntersect(), it uses tess._event
                        // as the intersection location. To make this possible, it requires
                        // that tess._event lie between the upper and lower edges, and also
                        // that neither of these is marked fixUpperEdge (since in the worst
                        // case it might splice one of these edges into tess.event, and
                        // violate the invariant that fixable edges are the only right-going
                        // edge from their associated vertex).
                        if (CheckForIntersect(regUp))
                        {
                            // WalkDirtyRegions() was called recursively; we're done
                            return;
                        }
                    }
                    else
                    {
                        // Even though we can't use CheckForIntersect(), the Org vertices
                        // may violate the dictionary edge ordering. Check and correct this.
                        CheckForRightSplice(regUp);
                    }
                }
                if (eUp._Org == eLo._Org && eUp._Dst == eLo._Dst)
                {
                    // A degenerate loop consisting of only two edges -- delete it.
                    Geom.AddWinding(eLo, eUp);
                    DeleteRegion(regUp);
                    _mesh.Delete(eUp);
                    regUp = RegionAbove(regLo);
                }
            }
        }

        /// <summary>
        /// Purpose: connect a "right" vertex vEvent (one where all edges go left)
        /// to the unprocessed portion of the mesh.  Since there are no right-going
        /// edges, two regions (one above vEvent and one below) are being merged
        /// into one.  "regUp" is the upper of these two regions.
        /// 
        /// There are two reasons for doing this (adding a right-going edge):
        ///  - if the two regions being merged are "inside", we must add an edge
        ///    to keep them separated (the combined region would not be monotone).
        ///  - in any case, we must leave some record of vEvent in the dictionary,
        ///    so that we can merge vEvent with features that we have not seen yet.
        ///    For example, maybe there is a vertical edge which passes just to
        ///    the right of vEvent; we would like to splice vEvent into this edge.
        /// 
        /// However, we don't want to connect vEvent to just any vertex.  We don''t
        /// want the new edge to cross any other edges; otherwise we will create
        /// intersection vertices even when the input data had no self-intersections.
        /// (This is a bad thing; if the user's input data has no intersections,
        /// we don't want to generate any false intersections ourselves.)
        /// 
        /// Our eventual goal is to connect vEvent to the leftmost unprocessed
        /// vertex of the combined region (the union of regUp and regLo).
        /// But because of unseen vertices with all right-going edges, and also
        /// new vertices which may be created by edge intersections, we don''t
        /// know where that leftmost unprocessed vertex is.  In the meantime, we
        /// connect vEvent to the closest vertex of either chain, and mark the region
        /// as "fixUpperEdge".  This flag says to delete and reconnect this edge
        /// to the next processed vertex on the boundary of the combined region.
        /// Quite possibly the vertex we connected to will turn out to be the
        /// closest one, in which case we won''t need to make any changes.
        /// </summary>
        private void ConnectRightVertex(ActiveRegion regUp, MeshUtils.Edge eBottomLeft)
        {
            var eTopLeft = eBottomLeft._Onext;
            var regLo = RegionBelow(regUp);
            var eUp = regUp._eUp;
            var eLo = regLo._eUp;
            bool degenerate = false;

            if (eUp._Dst != eLo._Dst)
            {
                CheckForIntersect(regUp);
            }

            // Possible new degeneracies: upper or lower edge of regUp may pass
            // through vEvent, or may coincide with new intersection vertex
            if (Geom.VertEq(eUp._Org, _event))
            {
                _mesh.Splice(eTopLeft._Oprev, eUp);
                regUp = TopLeftRegion(regUp);
                eTopLeft = RegionBelow(regUp)._eUp;
                FinishLeftRegions(RegionBelow(regUp), regLo);
                degenerate = true;
            }
            if (Geom.VertEq(eLo._Org, _event))
            {
                _mesh.Splice(eBottomLeft, eLo._Oprev);
                eBottomLeft = FinishLeftRegions(regLo, null);
                degenerate = true;
            }
            if (degenerate)
            {
                AddRightEdges(regUp, eBottomLeft._Onext, eTopLeft, eTopLeft, true);
                return;
            }

            // Non-degenerate situation -- need to add a temporary, fixable edge.
            // Connect to the closer of eLo.Org, eUp.Org.
            MeshUtils.Edge eNew;
            if (Geom.VertLeq(eLo._Org, eUp._Org))
            {
                eNew = eLo._Oprev;
            }
            else
            {
                eNew = eUp;
            }
            eNew = _mesh.Connect(eBottomLeft._Lprev, eNew);

            // Prevent cleanup, otherwise eNew might disappear before we've even
            // had a chance to mark it as a temporary edge.
            AddRightEdges(regUp, eNew, eNew._Onext, eNew._Onext, false);
            eNew._Sym._activeRegion._fixUpperEdge = true;
            WalkDirtyRegions(regUp);
        }

        /// <summary>
        /// The event vertex lies exacty on an already-processed edge or vertex.
        /// Adding the new vertex involves splicing it into the already-processed
        /// part of the mesh.
        /// </summary>
        private void ConnectLeftDegenerate(ActiveRegion regUp, MeshUtils.Vertex vEvent)
        {
            var e = regUp._eUp;
            if (Geom.VertEq(e._Org, vEvent))
            {
                // e.Org is an unprocessed vertex - just combine them, and wait
                // for e.Org to be pulled from the queue
                // C# : in the C version, there is a flag but it was never implemented
                // the vertices are before beginning the tesselation
                throw new InvalidOperationException("Vertices should have been merged before");
            }

            if (!Geom.VertEq(e._Dst, vEvent))
            {
                // General case -- splice vEvent into edge e which passes through it
                _mesh.SplitEdge(e._Sym);
                if (regUp._fixUpperEdge)
                {
                    // This edge was fixable -- delete unused portion of original edge
                    _mesh.Delete(e._Onext);
                    regUp._fixUpperEdge = false;
                }
                _mesh.Splice(vEvent._anEdge, e);
                SweepEvent(vEvent);	// recurse
                return;
            }

            // See above
            throw new InvalidOperationException("Vertices should have been merged before");
        }

        /// <summary>
        /// Purpose: connect a "left" vertex (one where both edges go right)
        /// to the processed portion of the mesh.  Let R be the active region
        /// containing vEvent, and let U and L be the upper and lower edge
        /// chains of R.  There are two possibilities:
        /// 
        /// - the normal case: split R into two regions, by connecting vEvent to
        ///   the rightmost vertex of U or L lying to the left of the sweep line
        /// 
        /// - the degenerate case: if vEvent is close enough to U or L, we
        ///   merge vEvent into that edge chain.  The subcases are:
        ///     - merging with the rightmost vertex of U or L
        ///     - merging with the active edge of U or L
        ///     - merging with an already-processed portion of U or L
        /// </summary>
        private void ConnectLeftVertex(MeshUtils.Vertex vEvent)
        {
            var tmp = new ActiveRegion();

            // Get a pointer to the active region containing vEvent
            tmp._eUp = vEvent._anEdge._Sym;
            var regUp = _dict.Find(tmp).Key;
            var regLo = RegionBelow(regUp);
            if (regLo == null)
            {
                // This may happen if the input polygon is coplanar.
                return;
            }
            var eUp = regUp._eUp;
            var eLo = regLo._eUp;

            // Try merging with U or L first
            if (Geom.EdgeSign(eUp._Dst, vEvent, eUp._Org) == 0.0f)
            {
                ConnectLeftDegenerate(regUp, vEvent);
                return;
            }

            // Connect vEvent to rightmost processed vertex of either chain.
            // e._Dst is the vertex that we will connect to vEvent.
            var reg = Geom.VertLeq(eLo._Dst, eUp._Dst) ? regUp : regLo;

            if (regUp._inside || reg._fixUpperEdge)
            {
                MeshUtils.Edge eNew;
                if (reg == regUp)
                {
                    eNew = _mesh.Connect(vEvent._anEdge._Sym, eUp._Lnext);
                }
                else
                {
                    eNew = _mesh.Connect(eLo._Dnext, vEvent._anEdge)._Sym;
                }
                if (reg._fixUpperEdge)
                {
                    FixUpperEdge(reg, eNew);
                }
                else
                {
                    ComputeWinding(AddRegionBelow(regUp, eNew));
                }
                SweepEvent(vEvent);
            }
            else
            {
                // The new vertex is in a region which does not belong to the polygon.
                // We don't need to connect this vertex to the rest of the mesh.
                AddRightEdges(regUp, vEvent._anEdge, vEvent._anEdge, null, true);
            }
        }

        /// <summary>
        /// Does everything necessary when the sweep line crosses a vertex.
        /// Updates the mesh and the edge dictionary.
        /// </summary>
        private void SweepEvent(MeshUtils.Vertex vEvent)
        {
            _event = vEvent;

            // Check if this vertex is the right endpoint of an edge that is
            // already in the dictionary. In this case we don't need to waste
            // time searching for the location to insert new edges.
            var e = vEvent._anEdge;
            while (e._activeRegion == null)
            {
                e = e._Onext;
                if (e == vEvent._anEdge)
                {
                    // All edges go right -- not incident to any processed edges
                    ConnectLeftVertex(vEvent);
                    return;
                }
            }

            // Processing consists of two phases: first we "finish" all the
            // active regions where both the upper and lower edges terminate
            // at vEvent (ie. vEvent is closing off these regions).
            // We mark these faces "inside" or "outside" the polygon according
            // to their winding number, and delete the edges from the dictionary.
            // This takes care of all the left-going edges from vEvent.
            var regUp = TopLeftRegion(e._activeRegion);
            var reg = RegionBelow(regUp);
            var eTopLeft = reg._eUp;
            var eBottomLeft = FinishLeftRegions(reg, null);

            // Next we process all the right-going edges from vEvent. This
            // involves adding the edges to the dictionary, and creating the
            // associated "active regions" which record information about the
            // regions between adjacent dictionary edges.
            if (eBottomLeft._Onext == eTopLeft)
            {
                // No right-going edges -- add a temporary "fixable" edge
                ConnectRightVertex(regUp, eBottomLeft);
            }
            else
            {
                AddRightEdges(regUp, eBottomLeft._Onext, eTopLeft, eTopLeft, true);
            }
        }

        /// <summary>
        /// Make the sentinel coordinates big enough that they will never be
        /// merged with real input features.
        /// 
        /// We add two sentinel edges above and below all other edges,
        /// to avoid special cases at the top and bottom.
        /// </summary>
        private void AddSentinel(Real smin, Real smax, Real t)
        {
            var e = _mesh.MakeEdge();
            e._Org._s = smax;
            e._Org._t = t;
            e._Dst._s = smin;
            e._Dst._t = t;
            _event = e._Dst; // initialize it

            var reg = new ActiveRegion();
            reg._eUp = e;
            reg._windingNumber = 0;
            reg._inside = false;
            reg._fixUpperEdge = false;
            reg._sentinel = true;
            reg._dirty = false;
            reg._nodeUp = _dict.Insert(reg);
        }

        /// <summary>
        /// We maintain an ordering of edge intersections with the sweep line.
        /// This order is maintained in a dynamic dictionary.
        /// </summary>
        private void InitEdgeDict()
        {
            _dict = new Dict<ActiveRegion>(EdgeLeq);

            AddSentinel(-SentinelCoord, SentinelCoord, -SentinelCoord);
            AddSentinel(-SentinelCoord, SentinelCoord, +SentinelCoord);
        }

        private void DoneEdgeDict()
        {
            int fixedEdges = 0;

            ActiveRegion reg;
            while ((reg = _dict.Min().Key) != null)
            {
                // At the end of all processing, the dictionary should contain
                // only the two sentinel edges, plus at most one "fixable" edge
                // created by ConnectRightVertex().
                if (!reg._sentinel)
                {
                    Debug.Assert(reg._fixUpperEdge);
                    Debug.Assert(++fixedEdges == 1);
                }
                Debug.Assert(reg._windingNumber == 0);
                DeleteRegion(reg);
            }

            _dict = null;
        }

        /// <summary>
        /// Remove zero-length edges, and contours with fewer than 3 vertices.
        /// </summary>
        private void RemoveDegenerateEdges()
        {
            MeshUtils.Edge eHead = _mesh._eHead, e, eNext, eLnext;

            for (e = eHead._next; e != eHead; e = eNext)
            {
                eNext = e._next;
                eLnext = e._Lnext;

                if (Geom.VertEq(e._Org, e._Dst) && e._Lnext._Lnext != e)
                {
                    // Zero-length edge, contour has at least 3 edges

                    SpliceMergeVertices(eLnext, e);	// deletes e.Org
                    _mesh.Delete(e); // e is a self-loop
                    e = eLnext;
                    eLnext = e._Lnext;
                }
                if (eLnext._Lnext == e)
                {
                    // Degenerate contour (one or two edges)

                    if (eLnext != e)
                    {
                        if (eLnext == eNext || eLnext == eNext._Sym)
                        {
                            eNext = eNext._next;
                        }
                        _mesh.Delete(eLnext);
                    }
                    if (e == eNext || e == eNext._Sym)
                    {
                        eNext = eNext._next;
                    }
                    _mesh.Delete(e);
                }
            }
        }

        /// <summary>
        /// Insert all vertices into the priority queue which determines the
        /// order in which vertices cross the sweep line.
        /// </summary>
        private void InitPriorityQ()
        {
            MeshUtils.Vertex vHead = _mesh._vHead, v;
            int vertexCount = 0;

            for (v = vHead._next; v != vHead; v = v._next)
            {
                vertexCount++;
            }
            // Make sure there is enough space for sentinels.
            vertexCount += 8;
    
            _pq = new PriorityQueue<MeshUtils.Vertex>(vertexCount, Geom.VertLeq);

            vHead = _mesh._vHead;
            for( v = vHead._next; v != vHead; v = v._next ) {
                v._pqHandle = _pq.Insert(v);
                if (v._pqHandle._handle == PQHandle.Invalid)
                {
                    throw new InvalidOperationException("PQHandle should not be invalid");
                }
            }
            _pq.Init();
        }

        private void DonePriorityQ()
        {
            _pq = null;
        }

        /// <summary>
        /// Delete any degenerate faces with only two edges.  WalkDirtyRegions()
        /// will catch almost all of these, but it won't catch degenerate faces
        /// produced by splice operations on already-processed edges.
        /// The two places this can happen are in FinishLeftRegions(), when
        /// we splice in a "temporary" edge produced by ConnectRightVertex(),
        /// and in CheckForLeftSplice(), where we splice already-processed
        /// edges to ensure that our dictionary invariants are not violated
        /// by numerical errors.
        /// 
        /// In both these cases it is *very* dangerous to delete the offending
        /// edge at the time, since one of the routines further up the stack
        /// will sometimes be keeping a pointer to that edge.
        /// </summary>
        private void RemoveDegenerateFaces()
        {
            MeshUtils.Face f, fNext;
            MeshUtils.Edge e;

            for (f = _mesh._fHead._next; f != _mesh._fHead; f = fNext)
            {
                fNext = f._next;
                e = f._anEdge;
                Debug.Assert(e._Lnext != e);

                if (e._Lnext._Lnext == e)
                {
                    // A face with only two edges
                    Geom.AddWinding(e._Onext, e);
                    _mesh.Delete(e);
                }
            }
        }

        /// <summary>
        /// ComputeInterior computes the planar arrangement specified
        /// by the given contours, and further subdivides this arrangement
        /// into regions.  Each region is marked "inside" if it belongs
        /// to the polygon, according to the rule given by windingRule.
        /// Each interior region is guaranteed to be monotone.
        /// </summary>
        protected void ComputeInterior()
        {
            // Each vertex defines an event for our sweep line. Start by inserting
            // all the vertices in a priority queue. Events are processed in
            // lexicographic order, ie.
            // 
            // e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)
            RemoveDegenerateEdges();
            InitPriorityQ();
            RemoveDegenerateFaces();
            InitEdgeDict();

            MeshUtils.Vertex v, vNext;
            while ((v = _pq.ExtractMin()) != null)
            {
                 while (true)
                 {
                    vNext = _pq.Minimum();
                    if (vNext == null || !Geom.VertEq(vNext, v))
                    {
                        break;
                    }

                    // Merge together all vertices at exactly the same location.
                    // This is more efficient than processing them one at a time,
                    // simplifies the code (see ConnectLeftDegenerate), and is also
                    // important for correct handling of certain degenerate cases.
                    // For example, suppose there are two identical edges A and B
                    // that belong to different contours (so without this code they would
                    // be processed by separate sweep events). Suppose another edge C
                    // crosses A and B from above. When A is processed, we split it
                    // at its intersection point with C. However this also splits C,
                    // so when we insert B we may compute a slightly different
                    // intersection point. This might leave two edges with a small
                    // gap between them. This kind of error is especially obvious
                    // when using boundary extraction (BoundaryOnly).
                    vNext = _pq.ExtractMin();
                    SpliceMergeVertices(v._anEdge, vNext._anEdge);
                }
                SweepEvent(v);
            }

            DoneEdgeDict();
            DonePriorityQ();

            RemoveDegenerateFaces();
            _mesh.Check();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Sweep.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Tess.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9bec9383a2ce0664baaa05ed927186d6
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

using System;
using System.Collections.Generic;
using System.Diagnostics;
using ToolBuddy.Pooling;
using ToolBuddy.Pooling.Collections;
using ToolBuddy.Pooling.Pools;
using Real = System.Single;
namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    public enum WindingRule
    {
        EvenOdd,
        NonZero,
        Positive,
        Negative,
        AbsGeqTwo
    }

    public enum ElementType
    {
        Polygons,
        ConnectedPolygons,
        BoundaryContours
    }

    public enum ContourOrientation
    {
        Original,
        Clockwise,
        CounterClockwise
    }

    public struct ContourVertex
    {
        public Vec3 Position;
        public object Data;

        public override string ToString()
        {
            return string.Format("{0}, {1}", Position, Data);
        }
    }

    public delegate object CombineCallback(Vec3 position, object[] data, Real[] weights);

    public partial class Tess

    {
        private LTMesh _mesh;
        private Vec3 _normal;
        private Vec3 _sUnit;
        private Vec3 _tUnit;

        private Real _bminX, _bminY, _bmaxX, _bmaxY;

        private WindingRule _windingRule;

        private Dict<ActiveRegion> _dict;
        private PriorityQueue<MeshUtils.Vertex> _pq;
        private MeshUtils.Vertex _event;

        private CombineCallback _combineCallback;

        private ContourVertex[] _vertices;

        private int _vertexCount;

        private SubArray<int>? elementsList;
        private int _elementCount;

        public Vec3 Normal { get { return _normal; } set { _normal = value; } }

        public Real SUnitX = 1;
        public Real SUnitY = 0;
        public Real SentinelCoord = 4e30f;

        /// <summary>
        /// If true, will remove empty (zero area) polygons.
        /// </summary>
        public bool NoEmptyPolygons = false;

        /// <summary>
        /// If true, will use pooling to reduce GC (compare performance with/without, can vary wildly).
        /// </summary>
        public bool UsePooling = false;

        public ContourVertex[] Vertices { get { return _vertices; } }
        public int VertexCount { get { return _vertexCount; } }


        /// <summary>
        /// The elements list
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use ElementsArray instead")]
        public int[] Elements
        {
            get { return elementsList?.CopyToArray(ArrayPoolsProvider.GetPool<int>()); }
        }

        /// <summary>
        /// The elements list
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use ElementsArray instead")]
        public IList<int> ElementsList
        {
            get { return Elements; }
        }

        /// <summary>
        /// The elements list
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<int>? ElementsArray
        {
            get { return elementsList; }
        }

        public int ElementCount
        {
            get { return _elementCount; }
        }

        public Tess()
        {
            _normal = Vec3.Zero;
            _bminX = _bminY = _bmaxX = _bmaxY = 0;

            _windingRule = WindingRule.EvenOdd;
            _mesh = null;

            _vertices = null;
            _vertexCount = 0;
            elementsList = null;
            _elementCount = 0;
        }

        private void ComputeNormal(ref Vec3 norm)
        {
            var v = _mesh._vHead._next;

            var minVal = new Real[3] { v._coords.X, v._coords.Y, v._coords.Z };
            var minVert = new MeshUtils.Vertex[3] { v, v, v };
            var maxVal = new Real[3] { v._coords.X, v._coords.Y, v._coords.Z };
            var maxVert = new MeshUtils.Vertex[3] { v, v, v };

            for (; v != _mesh._vHead; v = v._next)
            {
                if (v._coords.X < minVal[0]) { minVal[0] = v._coords.X; minVert[0] = v; }
                if (v._coords.Y < minVal[1]) { minVal[1] = v._coords.Y; minVert[1] = v; }
                if (v._coords.Z < minVal[2]) { minVal[2] = v._coords.Z; minVert[2] = v; }
                if (v._coords.X > maxVal[0]) { maxVal[0] = v._coords.X; maxVert[0] = v; }
                if (v._coords.Y > maxVal[1]) { maxVal[1] = v._coords.Y; maxVert[1] = v; }
                if (v._coords.Z > maxVal[2]) { maxVal[2] = v._coords.Z; maxVert[2] = v; }
            }

            // Find two vertices separated by at least 1/sqrt(3) of the maximum
            // distance between any two vertices
            int i = 0;
            if (maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) { i = 1; }
            if (maxVal[2] - minVal[2] > maxVal[i] - minVal[i]) { i = 2; }
            if (minVal[i] >= maxVal[i])
            {
                // All vertices are the same -- normal doesn't matter
                norm = new Vec3 { X = 0, Y = 0, Z = 1 };
                return;
            }

            // Look for a third vertex which forms the triangle with maximum area
            // (Length of normal == twice the triangle area)
            Real maxLen2 = 0, tLen2;
            var v1 = minVert[i];
            var v2 = maxVert[i];
            Vec3 d1, d2, tNorm;
            Vec3.Sub(ref v1._coords, ref v2._coords, out d1);
            for (v = _mesh._vHead._next; v != _mesh._vHead; v = v._next)
            {
                Vec3.Sub(ref v._coords, ref v2._coords, out d2);
                tNorm.X = d1.Y * d2.Z - d1.Z * d2.Y;
                tNorm.Y = d1.Z * d2.X - d1.X * d2.Z;
                tNorm.Z = d1.X * d2.Y - d1.Y * d2.X;
                tLen2 = tNorm.X * tNorm.X + tNorm.Y * tNorm.Y + tNorm.Z * tNorm.Z;
                if (tLen2 > maxLen2)
                {
                    maxLen2 = tLen2;
                    norm = tNorm;
                }
            }

            if (maxLen2 <= 0.0f)
            {
                // All points lie on a single line -- any decent normal will do
                norm = Vec3.Zero;
                i = Vec3.LongAxis(ref d1);
                norm[i] = 1;
            }
        }

        private void CheckOrientation()
        {
            // When we compute the normal automatically, we choose the orientation
            // so that the the sum of the signed areas of all contours is non-negative.
            Real area = 0.0f;
            for (var f = _mesh._fHead._next; f != _mesh._fHead; f = f._next)
            {
                if (f._anEdge._winding <= 0)
                {
                    continue;
                }

                area += MeshUtils.FaceArea(f);
            }

            if (area < 0.0f)
            {
                // Reverse the orientation by flipping all the t-coordinates
                for (var v = _mesh._vHead._next; v != _mesh._vHead; v = v._next)
                {
                    v._t = -v._t;
                }

                Vec3.Neg(ref _tUnit);
            }
        }

        private void ProjectPolygon()
        {
            var norm = _normal;

            bool computedNormal = false;
            if (norm.X == 0.0f && norm.Y == 0.0f && norm.Z == 0.0f)
            {
                ComputeNormal(ref norm);
                _normal = norm;
                computedNormal = true;
            }

            int i = Vec3.LongAxis(ref norm);

            _sUnit[i] = 0;
            _sUnit[(i + 1) % 3] = SUnitX;
            _sUnit[(i + 2) % 3] = SUnitY;

            _tUnit[i] = 0;
            _tUnit[(i + 1) % 3] = norm[i] > 0.0f ? -SUnitY : SUnitY;
            _tUnit[(i + 2) % 3] = norm[i] > 0.0f ? SUnitX : -SUnitX;

            // Project the vertices onto the sweep plane
            for (var v = _mesh._vHead._next; v != _mesh._vHead; v = v._next)
            {
                Vec3.Dot(ref v._coords, ref _sUnit, out v._s);
                Vec3.Dot(ref v._coords, ref _tUnit, out v._t);
            }

            if (computedNormal)
            {
                CheckOrientation();
            }

            // Compute ST bounds.
            bool first = true;
            for (var v = _mesh._vHead._next; v != _mesh._vHead; v = v._next)
            {
                if (first)
                {
                    _bminX = _bmaxX = v._s;
                    _bminY = _bmaxY = v._t;
                    first = false;
                }
                else
                {
                    if (v._s < _bminX) _bminX = v._s;
                    if (v._s > _bmaxX) _bmaxX = v._s;
                    if (v._t < _bminY) _bminY = v._t;
                    if (v._t > _bmaxY) _bmaxY = v._t;
                }
            }
        }

        /// <summary>
        /// TessellateMonoRegion( face ) tessellates a monotone region
        /// (what else would it do??)  The region must consist of a single
        /// loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
        /// case means that any vertical line intersects the interior of the
        /// region in a single interval.  
        /// 
        /// Tessellation consists of adding interior edges (actually pairs of
        /// half-edges), to split the region into non-overlapping triangles.
        /// 
        /// The basic idea is explained in Preparata and Shamos (which I don't
        /// have handy right now), although their implementation is more
        /// complicated than this one.  The are two edge chains, an upper chain
        /// and a lower chain.  We process all vertices from both chains in order,
        /// from right to left.
        /// 
        /// The algorithm ensures that the following invariant holds after each
        /// vertex is processed: the untessellated region consists of two
        /// chains, where one chain (say the upper) is a single edge, and
        /// the other chain is concave.  The left vertex of the single edge
        /// is always to the left of all vertices in the concave chain.
        /// 
        /// Each step consists of adding the rightmost unprocessed vertex to one
        /// of the two chains, and forming a fan of triangles from the rightmost
        /// of two chain endpoints.  Determining whether we can add each triangle
        /// to the fan is a simple orientation test.  By making the fan as large
        /// as possible, we restore the invariant (check it yourself).
        /// </summary>
        private void TessellateMonoRegion(MeshUtils.Face face)
        {
            // All edges are oriented CCW around the boundary of the region.
            // First, find the half-edge whose origin vertex is rightmost.
            // Since the sweep goes from left to right, face->anEdge should
            // be close to the edge we want.
            var up = face._anEdge;
            Debug.Assert(up._Lnext != up && up._Lnext._Lnext != up);

            for (; Geom.VertLeq(up._Dst, up._Org); up = up._Lprev) ;
            for (; Geom.VertLeq(up._Org, up._Dst); up = up._Lnext) ;

            var lo = up._Lprev;

            while (up._Lnext != lo)
            {
                if (Geom.VertLeq(up._Dst, lo._Org))
                {
                    // up.Dst is on the left. It is safe to form triangles from lo.Org.
                    // The EdgeGoesLeft test guarantees progress even when some triangles
                    // are CW, given that the upper and lower chains are truly monotone.
                    while (lo._Lnext != up && (Geom.EdgeGoesLeft(lo._Lnext)
                                               || Geom.EdgeSign(lo._Org, lo._Dst, lo._Lnext._Dst) <= 0.0f))
                    {
                        lo = _mesh.Connect(lo._Lnext, lo)._Sym;
                    }

                    lo = lo._Lprev;
                }
                else
                {
                    // lo.Org is on the left.  We can make CCW triangles from up.Dst.
                    while (lo._Lnext != up && (Geom.EdgeGoesRight(up._Lprev)
                                               || Geom.EdgeSign(up._Dst, up._Org, up._Lprev._Org) >= 0.0f))
                    {
                        up = _mesh.Connect(up, up._Lprev)._Sym;
                    }

                    up = up._Lnext;
                }
            }

            // Now lo.Org == up.Dst == the leftmost vertex.  The remaining region
            // can be tessellated in a fan from this leftmost vertex.
            Debug.Assert(lo._Lnext != up);
            while (lo._Lnext._Lnext != up)
            {
                lo = _mesh.Connect(lo._Lnext, lo)._Sym;
            }
        }

        /// <summary>
        /// TessellateInterior( mesh ) tessellates each region of
        /// the mesh which is marked "inside" the polygon. Each such region
        /// must be monotone.
        /// </summary>
        private void TessellateInterior()
        {
            MeshUtils.Face f, next;
            for (f = _mesh._fHead._next; f != _mesh._fHead; f = next)
            {
                // Make sure we don't try to tessellate the new triangles.
                next = f._next;
                if (f._inside)
                {
                    TessellateMonoRegion(f);
                }
            }
        }

        /// <summary>
        /// DiscardExterior zaps (ie. sets to null) all faces
        /// which are not marked "inside" the polygon.  Since further mesh operations
        /// on NULL faces are not allowed, the main purpose is to clean up the
        /// mesh so that exterior loops are not represented in the data structure.
        /// </summary>
        private void DiscardExterior()
        {
            MeshUtils.Face f, next;

            for (f = _mesh._fHead._next; f != _mesh._fHead; f = next)
            {
                // Since f will be destroyed, save its next pointer.
                next = f._next;
                if( ! f._inside ) {
                    _mesh.ZapFace(f);
                }
            }
        }

        /// <summary>
        /// SetWindingNumber( value, keepOnlyBoundary ) resets the
        /// winding numbers on all edges so that regions marked "inside" the
        /// polygon have a winding number of "value", and regions outside
        /// have a winding number of 0.
        /// 
        /// If keepOnlyBoundary is TRUE, it also deletes all edges which do not
        /// separate an interior region from an exterior one.
        /// </summary>
        private void SetWindingNumber(int value, bool keepOnlyBoundary)
        {
            MeshUtils.Edge e, eNext;

            for (e = _mesh._eHead._next; e != _mesh._eHead; e = eNext)
            {
                eNext = e._next;
                if (e._Rface._inside != e._Lface._inside)
                {

                    /* This is a boundary edge (one side is interior, one is exterior). */
                    e._winding = (e._Lface._inside) ? value : -value;
                }
                else
                {

                    /* Both regions are interior, or both are exterior. */
                    if (!keepOnlyBoundary)
                    {
                        e._winding = 0;
                    }
                    else
                    {
                        _mesh.Delete(e);
                    }
                }
            }

        }

        private int GetNeighbourFace(MeshUtils.Edge edge)
        {
            if (edge._Rface == null)
                return MeshUtils.Undef;
            if (!edge._Rface._inside)
                return MeshUtils.Undef;
            return edge._Rface._n;
        }

        private void OutputPolymesh(ElementType elementType, int polySize)
        {
            MeshUtils.Vertex v;
            MeshUtils.Face f;
            MeshUtils.Edge edge;
            int maxFaceCount = 0;
            int maxVertexCount = 0;
            int faceVerts, i;

            if (polySize < 3)
            {
                polySize = 3;
            }

            // Assume that the input data is triangles now.
            // Try to merge as many polygons as possible
            if (polySize > 3)
            {
                _mesh.MergeConvexFaces(polySize);
            }

            // Mark unused
            for (v = _mesh._vHead._next; v != _mesh._vHead; v = v._next)
                v._n = MeshUtils.Undef;

            // Create unique IDs for all vertices and faces.
            for (f = _mesh._fHead._next; f != _mesh._fHead; f = f._next)
            {
                f._n = MeshUtils.Undef;
                if (!f._inside) continue;

                if (NoEmptyPolygons)
                {
                    var area = MeshUtils.FaceArea(f);
                    if (Math.Abs(area) < Real.Epsilon)
                    {
                        continue;
                    }
                }

                edge = f._anEdge;
                faceVerts = 0;
                do {
                    v = edge._Org;
                    if (v._n == MeshUtils.Undef)
                    {
                        v._n = maxVertexCount;
                        maxVertexCount++;
                    }

                    faceVerts++;
                    edge = edge._Lnext;
                }
                while (edge != f._anEdge);

                Debug.Assert(faceVerts <= polySize);

                f._n = maxFaceCount;
                ++maxFaceCount;
            }

            _elementCount = maxFaceCount;
            if (elementType == ElementType.ConnectedPolygons)
                maxFaceCount *= 2;

            ArrayPool<int> arrayPool = ArrayPoolsProvider.GetPool<Int32>();
            if (elementsList != null)
                arrayPool.Free(elementsList.Value);
            elementsList = arrayPool.Allocate(maxFaceCount * polySize);

            _vertexCount = maxVertexCount;
            _vertices = new ContourVertex[_vertexCount];

            // Output vertices.
            for (v = _mesh._vHead._next; v != _mesh._vHead; v = v._next)
            {
                if (v._n != MeshUtils.Undef)
                {
                    // Store coordinate
                    _vertices[v._n].Position = v._coords;
                    _vertices[v._n].Data = v._data;
                }
            }

            // Output indices.
            int elementIndex = 0;
            for (f = _mesh._fHead._next; f != _mesh._fHead; f = f._next)
            {
                if (!f._inside) continue;

                if (NoEmptyPolygons)
                {
                    var area = MeshUtils.FaceArea(f);
                    if (Math.Abs(area) < Real.Epsilon)
                    {
                        continue;
                    }
                }

                // Store polygon
                edge = f._anEdge;
                faceVerts = 0;
                do {
                    v = edge._Org;
                    elementsList.Value.Array[elementIndex++] = v._n;
                    faceVerts++;
                    edge = edge._Lnext;
                } while (edge != f._anEdge);

                // Fill unused.
                for (i = faceVerts; i < polySize; ++i)
                {
                    elementsList.Value.Array[elementIndex++] = MeshUtils.Undef;
                }

                // Store polygon connectivity
                if (elementType == ElementType.ConnectedPolygons)
                {
                    edge = f._anEdge;
                    do
                    {
                        elementsList.Value.Array[elementIndex++] = GetNeighbourFace(edge);
                        edge = edge._Lnext;
                    } while (edge != f._anEdge);

                    // Fill unused.
                    for (i = faceVerts; i < polySize; ++i)
                    {
                        elementsList.Value.Array[elementIndex++] = MeshUtils.Undef;
                    }
                }
            }
        }

        private void OutputContours()
        {
            MeshUtils.Face f;
            MeshUtils.Edge edge, start;
            int startVert = 0;
            int vertCount = 0;

            _vertexCount = 0;
            _elementCount = 0;

            for (f = _mesh._fHead._next; f != _mesh._fHead; f = f._next)
            {
                if (!f._inside) continue;

                start = edge = f._anEdge;
                do
                {
                    ++_vertexCount;
                    edge = edge._Lnext;
                }
                while (edge != start);

                ++_elementCount;
            }

            ArrayPool<int> arrayPool = ArrayPoolsProvider.GetPool<Int32>();
            if (elementsList != null)
                arrayPool.Free(elementsList.Value);
            elementsList = arrayPool.Allocate(_elementCount * 2);

            _vertices = new ContourVertex[_vertexCount];

            int vertIndex = 0;
            int elementIndex = 0;

            startVert = 0;

            for (f = _mesh._fHead._next; f != _mesh._fHead; f = f._next)
            {
                if (!f._inside) continue;

                vertCount = 0;
                start = edge = f._anEdge;
                do {
                    _vertices[vertIndex].Position = edge._Org._coords;
                    _vertices[vertIndex].Data = edge._Org._data;
                    ++vertIndex;
                    ++vertCount;
                    edge = edge._Lnext;
                } while (edge != start);

                elementsList.Value.Array[elementIndex++] = startVert;
                elementsList.Value.Array[elementIndex++] = vertCount;

                startVert += vertCount;
            }
        }

        private Real SignedArea(ContourVertex[] vertices)
        {
            Real area = 0.0f;

            for (int i = 0; i < vertices.Length; i++)
            {
                var v0 = vertices[i];
                var v1 = vertices[(i + 1) % vertices.Length];

                area += v0.Position.X * v1.Position.Y;
                area -= v0.Position.Y * v1.Position.X;
            }

            return 0.5f * area;
        }

        public void AddContour(ContourVertex[] vertices)
        {
            AddContour(vertices, ContourOrientation.Original);
        }

        public void AddContour(ContourVertex[] vertices, ContourOrientation forceOrientation)
        {
            if (_mesh == null)
            {
                _mesh = new LTMesh();
            }

            bool reverse = false;
            if (forceOrientation != ContourOrientation.Original)
            {
                var area = SignedArea(vertices);
                reverse = (forceOrientation == ContourOrientation.Clockwise && area < 0.0f) || (forceOrientation == ContourOrientation.CounterClockwise && area > 0.0f);
            }

            MeshUtils.Edge e = null;
            for (int i = 0; i < vertices.Length; ++i)
            {
                if (e == null)
                {
                    e = _mesh.MakeEdge();
                    _mesh.Splice(e, e._Sym);
                }
                else
                {
                    // Create a new vertex and edge which immediately follow e
                    // in the ordering around the left face.
                    _mesh.SplitEdge(e);
                    e = e._Lnext;
                }

                int index = reverse ? vertices.Length - 1 - i : i;
                // The new vertex is now e._Org.
                e._Org._coords = vertices[index].Position;
                e._Org._data = vertices[index].Data;

                // The winding of an edge says how the winding number changes as we
                // cross from the edge's right face to its left face.  We add the
                // vertices in such an order that a CCW contour will add +1 to
                // the winding number of the region inside the contour.
                e._winding = 1;
                e._Sym._winding = -1;
            }
        }

        public void Tessellate(WindingRule windingRule, ElementType elementType, int polySize)
        {
            Tessellate(windingRule, elementType, polySize, null);
        }

        public void Tessellate(WindingRule windingRule, ElementType elementType, int polySize, CombineCallback combineCallback)
        {
            _normal = Vec3.Zero;
            _vertices = null;
            elementsList = null;

            _windingRule = windingRule;
            _combineCallback = combineCallback;

            if (_mesh == null)
            {
                return;
            }

            // Determine the polygon normal and project vertices onto the plane
            // of the polygon.
            ProjectPolygon();

            // ComputeInterior computes the planar arrangement specified
            // by the given contours, and further subdivides this arrangement
            // into regions.  Each region is marked "inside" if it belongs
            // to the polygon, according to the rule given by windingRule.
            // Each interior region is guaranteed be monotone.
            ComputeInterior();

            // If the user wants only the boundary contours, we throw away all edges
            // except those which separate the interior from the exterior.
            // Otherwise we tessellate all the regions marked "inside".
            if (elementType == ElementType.BoundaryContours)
            {
                SetWindingNumber(1, true);
            }
            else
            {
                TessellateInterior();
            }

            _mesh.Check();

            if (elementType == ElementType.BoundaryContours)
            {
                OutputContours();
            }
            else
            {
                OutputPolymesh(elementType, polySize);
            }

            if (UsePooling)
            {
                _mesh.Free();
            }

            _mesh = null;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Tess.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/UnityUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 568ec354b4db48d418238be196862ce5
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections.Generic;
using ToolBuddy.Pooling;
using ToolBuddy.Pooling.Collections;
using UnityEngine;


namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    public static class LibTessVector3Extension
    {
        public static Vec3 Vec3(this Vector3 v)
        {
            return new Vec3() { X = v.x, Y = v.y, Z = v.z };
        }

        public static ContourVertex ContourVertex(this Vector3 v)
        {
            var r = new ContourVertex();
            r.Position = v.Vec3();
            return r;
        }

    }

    [Obsolete("No more used in Curvy. Will get removed. Copy it if you still need it")]
    public static class LibTessV3Extension
    {
        public static Vector3 Vector3(this Vec3 v)
        {
            return new Vector3(v.X, v.Y, v.Z);
        }
    }




    public static class UnityLibTessUtility
    {
        [Obsolete("No more used in Curvy. Will get removed. Copy it if you still need it")]
        public static ContourVertex[] ToContourVertex(Vector3[] v, bool zeroZ = false)
        {
            var res = new ContourVertex[v.Length];
            for (int i = 0; i < v.Length; i++)
            {
                res[i].Position.X = v[i].x;
                res[i].Position.Y = v[i].y;
                res[i].Position.Z = (zeroZ) ? 0 : v[i].z;
            }
            return res;
        }

        public static ContourVertex[] ToContourVertex(SubArray<Vector3> v, bool zeroZ = false)
        {
            int count = v.Count;
            Vector3[] vArray = v.Array;
            ContourVertex[] res = new ContourVertex[count];
            for (int i = 0; i < count; i++)
            {
                res[i].Position.X = vArray[i].x;
                res[i].Position.Y = vArray[i].y;
                res[i].Position.Z = (zeroZ) ? 0 : vArray[i].z;
            }
            return res;
        }

        public static void FromContourVertex(ContourVertex[] v, SubArray<Vector3> output)
        {
            var count = output.Count;
            var array = output.Array;

            for (int i = 0; i < count; i++)
            {
                array[i].x = v[i].Position.X;
                array[i].y = v[i].Position.Y;
                array[i].z = v[i].Position.Z;
            }
        }

        public static SubArray<Vector3> ContourVerticesToPositions(ContourVertex[] v)
        {
            var result = ArrayPoolsProvider.GetPool<Vector3>().Allocate(v.Length);
            var res = result.Array;
            for (int i = 0; i < result.Count; i++)
            {
                res[i].x = v[i].Position.X;
                res[i].y = v[i].Position.Y;
                res[i].z = v[i].Position.Z;
            }

            return result;
        }

        [Obsolete("No more used in Curvy. Will get removed. Copy it if you still need it")]
        public static void SetFromContourVertex(ref Vector3[] v3Array, ref ContourVertex[] cvArray)
        {
            System.Array.Resize(ref v3Array, cvArray.Length);
            for (int i = 0; i < v3Array.Length; i++)
            {
                v3Array[i].x = cvArray[i].Position.X;
                v3Array[i].y = cvArray[i].Position.Y;
                v3Array[i].z = cvArray[i].Position.Z;
            }
        }

        [Obsolete("No more used in Curvy. Will get removed. Copy it if you still need it")]
        public static void SetToContourVertex(ref ContourVertex[] cvArray, ref Vector3[] v3Array)
        {
            System.Array.Resize(ref cvArray, v3Array.Length);
            for (int i = 0; i < cvArray.Length; i++)
            {
                cvArray[i].Position.X = v3Array[i].x;
                cvArray[i].Position.Y = v3Array[i].y;
                cvArray[i].Position.Z = v3Array[i].z;
            }
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/UnityUtility.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/Matrix2D.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 600ae451aa325bb479e48e4f91cf17e1
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using UnityEngine;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    /// <summary>A 2x3 transformation matrix used for 2D operations.</summary>
    public struct Matrix2D
    {
        // memory layout:
        //
        //                row no (=vertical)
        //               |  0   1   2
        //            ---+------------
        //            0  | m00 m10  0
        // column no  1  | m01 m11  0
        // (=horiz)   2  | m02 m12  1

        /// <summary>The matrix member at (0,0)</summary>
        public float m00;
        /// <summary>The matrix member at (1,0)</summary>
        public float m10;

        /// <summary>The matrix member at (0,1)</summary>
        public float m01;
        /// <summary>The matrix member at (1,1)</summary>
        public float m11;

        /// <summary>The matrix member at (0,2)</summary>
        public float m02;
        /// <summary>The matrix member at (1,2)</summary>
        public float m12;

        /// <summary>Initializes a Matrix2D with column vectors</summary>
        /// <param name="column0">The first column</param>
        /// <param name="column1">The second column</param>
        /// <param name="column2">The third column</param>
        public Matrix2D(Vector2 column0, Vector2 column1, Vector2 column2)
        {
            this.m00 = column0.x; this.m01 = column1.x; this.m02 = column2.x;
            this.m10 = column0.y; this.m11 = column1.y; this.m12 = column2.y;
        }

        /// <summary>Access element at [row, column].</summary>
        /// <returns>The value at [row, column]</returns>
        public float this[int row, int column]
        {
            get
            {
                return this[row + column * 2];
            }

            set
            {
                this[row + column * 2] = value;
            }
        }

        /// <summary>Access element at sequential index (0..5 inclusive).</summary>
        /// <returns>The value at [index]</returns>
        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return m00;
                    case 1: return m10;
                    case 2: return m01;
                    case 3: return m11;
                    case 4: return m02;
                    case 5: return m12;
                    default:
                        throw new IndexOutOfRangeException("Invalid matrix index!");
                }
            }

            set
            {
                switch (index)
                {
                    case 0: m00 = value; break;
                    case 1: m10 = value; break;
                    case 2: m01 = value; break;
                    case 3: m11 = value; break;
                    case 4: m02 = value; break;
                    case 5: m12 = value; break;

                    default:
                        throw new IndexOutOfRangeException("Invalid matrix index!");
                }
            }
        }

        /// <summary>Gets a hashcode of the matrix.</summary>
        /// <remarks>Used to allow Matrix3x3s to be used as keys in hash tables.</remarks>
        /// <returns>The hashcode of the matrix</returns>
        public override int GetHashCode()
        {
            return GetColumn(0).GetHashCode() ^ (GetColumn(1).GetHashCode() << 2) ^ (GetColumn(2).GetHashCode() >> 2);
        }

        /// <summary>Checks if two matrices are equal.</summary>
        /// <param name="other">The other matrix to compare with</param>
        /// <remarks>Used to allow Matrix3x3s to be used as keys in hash tables.</remarks>
        /// <returns>True when the matrix is equal to "other"</returns>
        public override bool Equals(object other)
        {
            if (!(other is Matrix2D)) return false;

            Matrix2D rhs = (Matrix2D)other;
            return GetColumn(0).Equals(rhs.GetColumn(0))
                && GetColumn(1).Equals(rhs.GetColumn(1))
                && GetColumn(2).Equals(rhs.GetColumn(2));
        }

        /// <summary>Multiplies two matrices.</summary>
        /// <param name="lhs">The left hand side matrix of the operation</param>
        /// <param name="rhs">The right hand side matrix of the operation</param>
        /// <returns>The multiplied matrix</returns>
        public static Matrix2D operator*(Matrix2D lhs, Matrix2D rhs)
        {
            Matrix2D res;
            res.m00 = lhs.m00 * rhs.m00 + lhs.m01 * rhs.m10;
            res.m01 = lhs.m00 * rhs.m01 + lhs.m01 * rhs.m11;
            res.m02 = lhs.m00 * rhs.m02 + lhs.m01 * rhs.m12 + lhs.m02;

            res.m10 = lhs.m10 * rhs.m00 + lhs.m11 * rhs.m10;
            res.m11 = lhs.m10 * rhs.m01 + lhs.m11 * rhs.m11;
            res.m12 = lhs.m10 * rhs.m02 + lhs.m11 * rhs.m12 + lhs.m12;

            return res;
        }

        /// <summary>Transforms a Vector2 by a matrix.</summary>
        /// <param name="lhs">The left hand side matrix of the operation</param>
        /// <param name="vector">The vector the matrix will be multiplied with</param>
        /// <returns>The transformed vector</returns>
        public static Vector2 operator*(Matrix2D lhs, Vector2 vector)
        {
            Vector2 res;
            res.x = lhs.m00 * vector.x + lhs.m01 * vector.y + lhs.m02;
            res.y = lhs.m10 * vector.x + lhs.m11 * vector.y + lhs.m12;
            return res;
        }

        /// <summary>Checks if two matrices are equal.</summary>
        /// <param name="lhs">The left hand side matrix of the comparison</param>
        /// <param name="rhs">The right hand side matrix of the comparison</param>
        /// <returns>True if "lhs" and "rhs" are equal, or false otherwise.</returns>
        public static bool operator==(Matrix2D lhs, Matrix2D rhs)
        {
            // Returns false in the presence of NaN values.
            return lhs.GetColumn(0) == rhs.GetColumn(0)
                && lhs.GetColumn(1) == rhs.GetColumn(1)
                && lhs.GetColumn(2) == rhs.GetColumn(2);
        }

        /// <summary>Checks if two matrices are not equal.</summary>
        /// <param name="lhs">The left hand side matrix of the comparison</param>
        /// <param name="rhs">The right hand side matrix of the comparison</param>
        /// <returns>True if "lhs" and "rhs" not are equal, or false otherwise.</returns>
        public static bool operator!=(Matrix2D lhs, Matrix2D rhs)
        {
            // Returns true in the presence of NaN values.
            return !(lhs == rhs);
        }

        /// <summary>Gets a column of the matrix.</summary>
        /// <param name="index">The column index, between 0 and 2 inclusively</param>
        /// <returns>The column at "index"</returns>
        public Vector2 GetColumn(int index)
        {
            switch (index)
            {
                case 0: return new Vector2(m00, m10);
                case 1: return new Vector2(m01, m11);
                case 2: return new Vector2(m02, m12);
                default:
                    throw new IndexOutOfRangeException("Invalid column index!");
            }
        }

        /// <summary>Gets a row of the matrix.</summary>
        /// <param name="index">The row index, between 0 and 1 inclusively</param>
        /// <returns>The row at "index"</returns>
        public Vector3 GetRow(int index)
        {
            switch (index)
            {
                case 0: return new Vector3(m00, m01, m02);
                case 1: return new Vector3(m10, m11, m12);
                default:
                    throw new IndexOutOfRangeException("Invalid row index!");
            }
        }

        /// <summary>Sets a column of the matrix.</summary>
        /// <param name="index">The column index, between 0 and 2 inclusively</param>
        /// <param name="column">The column</param>
        public void SetColumn(int index, Vector2 column)
        {
            this[0, index] = column.x;
            this[1, index] = column.y;
        }

        /// <summary>Sets a row of the matrix.</summary>
        /// <param name="index">The column index, between 0 and 1 inclusively</param>
        /// <param name="row">The row</param>
        public void SetRow(int index, Vector3 row)
        {
            this[index, 0] = row.x;
            this[index, 1] = row.y;
            this[index, 2] = row.z;
        }

        /// <summary>Transforms a position by this matrix (effectively by 2x3).</summary>
        /// <param name="point">The point to multiply with this matrix</param>
        /// <returns>The multiplied point</returns>
        public Vector2 MultiplyPoint(Vector2 point)
        {
            Vector2 res;
            res.x = this.m00 * point.x + this.m01 * point.y + this.m02;
            res.y = this.m10 * point.x + this.m11 * point.y + this.m12;
            return res;
        }

        /// <summary>Transforms a direction by this matrix.</summary>
        /// <param name="vector">The direction to multiply with this matrix</param>
        /// <returns>The multiplied direction</returns>
        public Vector2 MultiplyVector(Vector2 vector)
        {
            Vector2 res;
            res.x = this.m00 * vector.x + this.m01 * vector.y;
            res.y = this.m10 * vector.x + this.m11 * vector.y;
            return res;
        }

        /// <summary>Computes the inverse of the matrix.</summary>
        /// <returns>The inverse matrix</returns>
        public Matrix2D Inverse()
        {
            Matrix2D invMat = new Matrix2D();

            float det = this[0, 0] * this[1, 1] - this[0, 1] * this[1, 0];
            if (Mathf.Approximately(0.0f, det))
                return zero;

            float invDet = 1.0F / det;

            invMat[0, 0] = this[1, 1] * invDet;
            invMat[0, 1] = -this[0, 1] * invDet;
            invMat[1, 0] = -this[1, 0] * invDet;
            invMat[1, 1] = this[0, 0] * invDet;

            // Do the translation part
            invMat[0, 2] = -(this[0, 2] * invMat[0, 0] + this[1, 2] * invMat[0, 1]);
            invMat[1, 2] = -(this[0, 2] * invMat[1, 0] + this[1, 2] * invMat[1, 1]);

            return invMat;
        }

        /// <summary>Creates a scaling matrix.</summary>
        /// <param name="vector">The scaling vector</param>
        /// <returns>The scaling matrix</returns>
        public static Matrix2D Scale(Vector2 vector)
        {
            Matrix2D m;
            m.m00 = vector.x; m.m01 = 0F; m.m02 = 0F;
            m.m10 = 0F; m.m11 = vector.y; m.m12 = 0F;
            return m;
        }

        /// <summary>Creates a translation matrix.</summary>
        /// <param name="vector">The translation vector</param>
        /// <returns>The translation matrix</returns>
        public static Matrix2D Translate(Vector2 vector)
        {
            Matrix2D m;
            m.m00 = 1F; m.m01 = 0F; m.m02 = vector.x;
            m.m10 = 0F; m.m11 = 1F; m.m12 = vector.y;
            return m;
        }

        /// <summary>Creates a right-hand side rotation matrix.</summary>
        /// <param name="angleRadians">The rotation angle, in radians</param>
        /// <returns>The rotation matrix</returns>
        public static Matrix2D RotateRH(float angleRadians)
        {
            return RotateLH(-angleRadians);
        }

        /// <summary>Creates a left-hand side rotation matrix.</summary>
        /// <param name="angleRadians">The rotation angle, in radians</param>
        /// <returns>The rotation matrix</returns>
        public static Matrix2D RotateLH(float angleRadians)
        {
            // No SinCos? I hope the compiler optimizes this
            float s = Mathf.Sin(angleRadians);
            float c = Mathf.Cos(angleRadians);

            Matrix2D m;
            m.m00 = c; m.m10 = -s;
            m.m01 = s; m.m11 = c;
            m.m02 = 0.0F; m.m12 = 0.0F;
            return m;
        }

        /// <summary>Creates a skew matrix on X.</summary>
        /// <param name="angleRadians">The skew angle, in radians</param>
        /// <returns>The skew matrix</returns>        
        public static Matrix2D SkewX(float angleRadians)
        {
            Matrix2D m;
            m.m00 = 1.0f; m.m01 = Mathf.Tan(angleRadians); m.m02 = 0F;
            m.m10 = 0F; m.m11 = 1.0f; m.m12 = 0F;
            return m;
        }

        /// <summary>Creates a skew matrix on U.</summary>
        /// <param name="angleRadians">The skew angle, in radians</param>
        /// <returns>The skew matrix</returns>        
        public static Matrix2D SkewY(float angleRadians)
        {
            Matrix2D m;
            m.m00 = 1.0f; m.m01 = 0F; m.m02 = 0F;
            m.m10 = Mathf.Tan(angleRadians); m.m11 = 1.0f; m.m12 = 0F;
            return m;
        }

        static readonly Matrix2D zeroMatrix = new Matrix2D(new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0));

        /// <summary>Returns a matrix with all elements set to zero (read-only).</summary>
        /// <returns>The zero matrix</returns>
        public static Matrix2D zero { get { return zeroMatrix; } }

        static readonly Matrix2D identityMatrix = new Matrix2D(new Vector2(1, 0), new Vector2(0, 1), new Vector2(0, 0));

        /// <summary>Returns the identity matrix (read-only).</summary>
        /// <returns>The identity matrix</returns>
        public static Matrix2D identity { get { return identityMatrix; } }

        /// <summary>Returns a string representation of the matrix.</summary>
        /// <returns>The matrix string representation</returns>
        public override string ToString()
        {
            return string.Format("{0:F5}\t{1:F5}\t{2:F5}\n{3:F5}\t{4:F5}\t{5:F5}\n", m00, m01, m02, m10, m11, m12);
        }

        /// <summary>Returns a string representation of the matrix using a format.</summary>
        /// <param name="format">The format to be used for the matrix components</param>
        /// <returns>The matrix string representation</returns>
        public string ToString(string format)
        {
            return string.Format("{0}\t{1}\t{2}\n{3}\t{4}\t{5}\n",
                m00.ToString(format), m01.ToString(format), m02.ToString(format),
                m10.ToString(format), m11.ToString(format), m12.ToString(format));
        }
    }
} //namespace
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/Matrix2D.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/SVGParser.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: aa2162f8539d856468fef95fc49e02e8
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.IO;
using System.Collections.Generic;
using System.Globalization;
using System.Xml;
using System.Linq;
using UnityEngine;
using UnityEngine.Networking;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    /// <summary>An enum describing the viewport options to use when importing the SVG document.</summary>
    public enum ViewportOptions
    {
        /// <summary>Don't preserve the viewport defined in the SVG document.</summary>
        DontPreserve,

        /// <summary>Preserves the viewport defined in the SVG document.</summary>
        PreserveViewport,

        /// <summary>Applies the root view-box defined in the SVG document (if any).</summary>
        /// <remarks>
        /// This option will rescale the SVG asset to a unit size if a view-box is defined in the SVG document.
        /// If no view-box is defined, this option will have the same behavior as `DontPreserve`.
        /// It has limited use and is only available for legacy reasons.
        /// </remarks>
        OnlyApplyRootViewBox
    }

    /// <summary>Reads an SVG document and builds a vector scene.</summary>
    public class SVGParser
    {
        /// <summary>A structure containing the SVG scene data.</summary>
        public struct SceneInfo
        {
            internal SceneInfo(Scene scene, Rect sceneViewport, Dictionary<SceneNode, float> nodeOpacities, Dictionary<string, SceneNode> nodeIDs)
            {
                Scene = scene;
                SceneViewport = sceneViewport;
                NodeOpacity = nodeOpacities;
                NodeIDs = nodeIDs;
            }
        
            /// <summary>The vector scene.</summary>
            public Scene Scene { get; }

            /// <summary>The position and size of the SVG document</summary>
            public Rect SceneViewport { get; }

            /// <summary>A dictionary containing the opacity of the scene nodes.</summary>
            public Dictionary<SceneNode, float> NodeOpacity { get; }

            /// <summary>A dictionary containing the scene node for a given ID</summary>
            public Dictionary<string, SceneNode> NodeIDs { get; }
        }

        /// <summary>Kicks off an SVG file import.</summary>
        /// <param name="textReader">The reader object containing the SVG file data</param>
        /// <param name="dpi">The DPI of the SVG file, or 0 to use the device's DPI</param>
        /// <param name="pixelsPerUnit">How many SVG units fit in a Unity unit</param>
        /// <param name="windowWidth">The default with of the viewport, may be 0</param>
        /// <param name="windowHeight">The default height of the viewport, may be 0</param>
        /// <param name="clipViewport">Whether the vector scene should be clipped by the SVG document's viewport</param>
        /// <returns>A SceneInfo object containing the scene data</returns>
        public static SceneInfo ImportSVG(TextReader textReader, float dpi = 0.0f, float pixelsPerUnit = 1.0f, int windowWidth = 0, int windowHeight = 0, bool clipViewport = false)
        {
            var viewportOptions = clipViewport ? ViewportOptions.PreserveViewport : ViewportOptions.DontPreserve;
            return ImportSVG(textReader, viewportOptions, dpi, pixelsPerUnit, windowWidth, windowHeight);
        }

        /// <summary>Kicks off an SVG file import.</summary>
        /// <param name="textReader">The reader object containing the SVG file data</param>
        /// <param name="viewportOptions">The viewport options to use</param>
        /// <param name="dpi">The DPI of the SVG file, or 0 to use the device's DPI</param>
        /// <param name="pixelsPerUnit">How many SVG units fit in a Unity unit</param>
        /// <param name="windowWidth">The default with of the viewport, may be 0</param>
        /// <param name="windowHeight">The default height of the viewport, may be 0</param>
        /// <returns>A SceneInfo object containing the scene data</returns>
        public static SceneInfo ImportSVG(TextReader textReader, ViewportOptions viewportOptions, float dpi = 0.0f, float pixelsPerUnit = 1.0f, int windowWidth = 0, int windowHeight = 0)
        {
            var scene = new Scene();
            var settings = new XmlReaderSettings();
            settings.IgnoreComments = true;
            settings.IgnoreProcessingInstructions = true;
            settings.IgnoreWhitespace = true;

            // Validation and resolving can reach through HTTP to fetch and validate against schemas/DTDs, which could take ages
#if (NET_STANDARD_2_0 || NET_4_6)
            settings.DtdProcessing = System.Xml.DtdProcessing.Ignore;
#else
            settings.ProhibitDtd = false;
#endif
            settings.ValidationFlags = System.Xml.Schema.XmlSchemaValidationFlags.None;
            settings.ValidationType = ValidationType.None;
            settings.XmlResolver = null;

            if (dpi == 0.0f)
                dpi = Screen.dpi;

            Dictionary<SceneNode, float> nodeOpacities;
            Dictionary<string, SceneNode> nodeIDs;

            SVGDocument doc;
            using (var reader = XmlReader.Create(textReader, settings))
            {
                bool applyRootViewBox =
                    (viewportOptions == ViewportOptions.PreserveViewport) ||
                    (viewportOptions == ViewportOptions.OnlyApplyRootViewBox);
                doc = new SVGDocument(reader, dpi, scene, windowWidth, windowHeight, applyRootViewBox);
                doc.Import();
                nodeOpacities = doc.NodeOpacities;
                nodeIDs = doc.NodeIDs;
            }

            float scale = 1.0f / pixelsPerUnit;
            if ((scale != 1.0f) && (scene != null) && (scene.Root != null))
                scene.Root.Transform = scene.Root.Transform * Matrix2D.Scale(new Vector2(scale, scale));

            if ((viewportOptions == ViewportOptions.PreserveViewport) && (scene != null) && (scene.Root != null))
            {
                // Only add clipper if the scene isn't entirely contained in the viewport
                var sceneBounds = VectorUtils.SceneNodeBounds(scene.Root);
                if (!doc.sceneViewport.Contains(sceneBounds.min) || !doc.sceneViewport.Contains(sceneBounds.max))
                {
                    var rectClip = new Shape();
                    VectorUtils.MakeRectangleShape(rectClip, doc.sceneViewport);

                    // We cannot add the clipper directly on scene.Root since it may have a viewbox transform applied.
                    // The simplest is to replace the root node with the new "clipped" one, then the clipping
                    // rectangle can stay in the viewport space (no need to take the viewbox transform into account).
                    scene.Root = new SceneNode()
                    {
                        Children = new List<SceneNode> { scene.Root },
                        Clipper = new SceneNode() { Shapes = new List<Shape>() { rectClip } }
                    };
                }
            }
            
            return new SceneInfo(scene, doc.sceneViewport, nodeOpacities, nodeIDs);
        }
    }

    internal class XmlReaderIterator
    {
        internal class Node
        {
            public Node(XmlReader reader) { this.reader = reader; name = reader.Name; depth = reader.Depth; }
            public string Name { get { return name; } }
            public string this[string attrib] { get { return reader.GetAttribute(attrib); } }
            public SVGPropertySheet GetAttributes()
            {
                var atts = new SVGPropertySheet();
                for (int i = 0; i < reader.AttributeCount; ++i)
                {
                    reader.MoveToAttribute(i);
                    atts[reader.Name] = reader.Value;
                }
                reader.MoveToElement();
                return atts;
            }
            public SVGFormatException GetException(string message) { return new SVGFormatException(reader, message); }
            public SVGFormatException GetUnsupportedAttribValException(string attrib)
            {
                return new SVGFormatException(reader, "Value '" + this[attrib] + "' is invalid for attribute '" + attrib + "'");
            }

            public int Depth { get { return depth; } }
            XmlReader reader;
            int depth;
            string name;
        }

        public XmlReaderIterator(XmlReader reader) { this.reader = reader; }
        public bool GoToRoot(string tagName) { return reader.ReadToFollowing(tagName) && reader.Depth == 0; }
        public Node VisitCurrent() { currentElementVisited = true; return new Node(reader); }
        public bool IsEmptyElement() { return reader.IsEmptyElement; }

        public bool GoToNextChild(Node node)
        {
            if (!currentElementVisited)
                return reader.Depth == node.Depth + 1;

            reader.Read();
            while ((reader.NodeType != XmlNodeType.None) && (reader.NodeType != XmlNodeType.Element))
                reader.Read();
            if (reader.NodeType != XmlNodeType.Element)
                return false;

            currentElementVisited = false;
            return reader.Depth == node.Depth + 1;
        }

        public void SkipCurrentChildTree(Node node)
        {
            while (GoToNextChild(node))
                SkipCurrentChildTree(VisitCurrent());
        }

        public string ReadTextWithinElement()
        {
            if (reader.IsEmptyElement)
                return "";
            
            var text = "";
            while (reader.Read() && reader.NodeType != XmlNodeType.EndElement)
                text += reader.Value;

            return text;
        }

        XmlReader reader;
        bool currentElementVisited;
    }

    internal class SVGFormatException : Exception
    {
        public SVGFormatException() {}
        public SVGFormatException(string message) : base(ComposeMessage(null, message)) {}
        public SVGFormatException(XmlReader reader, string message) : base(ComposeMessage(reader, message)) {}

        public static SVGFormatException StackError { get { return new SVGFormatException("Vector scene construction mismatch"); } }

        static string ComposeMessage(XmlReader reader, string message)
        {
            IXmlLineInfo li = reader as IXmlLineInfo;
            if (li != null)
                return "SVG Error (line " + li.LineNumber + ", character " + li.LinePosition + "): " + message;
            return "SVG Error: " + message;
        }
    }

    internal class SVGDictionary : Dictionary<string, object> {}
    internal class SVGPostponedFills : Dictionary<IFill, string> { }

    internal class SVGDocument
    {
        public SVGDocument(XmlReader docReader, float dpi, Scene scene, int windowWidth, int windowHeight, bool applyRootViewBox)
        {
            allElems = new ElemHandler[]
            { circle, defs, ellipse, g, image, line, linearGradient, path, polygon, polyline, radialGradient, clipPath, pattern, mask, rect, symbol, use, style };

            // These elements excluded below should not be immediatelly part of the hierarchy and can only be referenced
            elemsToAddToHierarchy = new HashSet<ElemHandler>(new ElemHandler[]
                    { circle, /*defs,*/ ellipse, g, image, line, path, polygon, polyline, rect, /*symbol,*/ svg, use });

            this.docReader = new XmlReaderIterator(docReader);
            this.scene = scene;
            this.dpiScale = dpi / 90.0f; // SVG specs assume 90DPI but this machine might use something else
            this.windowWidth = windowWidth;
            this.windowHeight = windowHeight;
            this.applyRootViewBox = applyRootViewBox;
            this.svgObjects[StockBlackNonZeroFillName] = new SolidFill() { Color = new Color(0, 0, 0), Mode = FillMode.NonZero };
            this.svgObjects[StockBlackOddEvenFillName] = new SolidFill() { Color = new Color(0, 0, 0), Mode = FillMode.OddEven };
        }

        public void Import()
        {
            if (scene == null) throw new ArgumentNullException();
            if (!docReader.GoToRoot("svg"))
                throw new SVGFormatException("Document doesn't have 'svg' root");

            currentContainerSize.Push(new Vector2(windowWidth, windowHeight));

            svg();

            currentContainerSize.Pop();
            if (currentContainerSize.Count > 0)
                throw SVGFormatException.StackError;

            PostProcess(scene.Root);
            RemoveInvisibleNodes();
        }

        public Dictionary<SceneNode, float> NodeOpacities { get { return nodeOpacity; } }
        public Dictionary<string, SceneNode> NodeIDs { get { return nodeIDs; } }

        internal const float SVGLengthFactor = 1.41421356f; // Used when calculating relative lengths. See http://www.w3.org/TR/SVG/coords.html#Units
        static internal string StockBlackNonZeroFillName { get { return "unity_internal_black_nz"; } }
        static internal string StockBlackOddEvenFillName { get { return "unity_internal_black_oe"; } }

        void ParseChildren(XmlReaderIterator.Node node, string nodeName)
        {
            var sceneNode = currentSceneNode.Peek();

            var supportedChildren = subTags[nodeName];
            while (docReader.GoToNextChild(node))
            {
                var child = docReader.VisitCurrent();

                ElemHandler handler;
                if (!supportedChildren.TryGetValue(child.Name, out handler))
                {
                    System.Diagnostics.Debug.WriteLine("Skipping over unsupported child (" + child.Name + ") of a (" + node.Name + ")");
                    docReader.SkipCurrentChildTree(child);
                    continue;
                }

                bool addToSceneHierarchy = elemsToAddToHierarchy.Contains(handler);
                SceneNode childVectorNode = null;
                if (addToSceneHierarchy)
                {
                    if (sceneNode.Children == null)
                        sceneNode.Children = new List<SceneNode>();
                    childVectorNode = new SceneNode();
                    nodeGlobalSceneState[childVectorNode] = new NodeGlobalSceneState() { ContainerSize = currentContainerSize.Peek() };
                    sceneNode.Children.Add(childVectorNode);
                    currentSceneNode.Push(childVectorNode);
                }

                styles.PushNode(child);

                if (childVectorNode != null)
                {
                    styles.SaveLayerForSceneNode(childVectorNode);
                    if (styles.Evaluate("display") == "none")
                        invisibleNodes.Add(new NodeWithParent() { node = childVectorNode, parent = sceneNode });
                }

                handler();
                ParseChildren(child, child.Name); // Recurse

                styles.PopNode();

                if (addToSceneHierarchy && currentSceneNode.Pop() != childVectorNode)
                    throw SVGFormatException.StackError;
            }
        }

        #region Tag handling
        void circle()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            var fill = SVGAttribParser.ParseFill(node, svgObjects, postponedFills, styles);
            PathCorner strokeCorner;
            PathEnding strokeEnding;
            var stroke = ParseStrokeAttributeSet(node, out strokeCorner, out strokeEnding);

            float cx = AttribLengthVal(node, "cx", 0.0f, DimType.Width);
            float cy = AttribLengthVal(node, "cy", 0.0f, DimType.Height);
            float r = AttribLengthVal(node, "r", 0.0f, DimType.Length);

            var circle = new Shape();
            VectorUtils.MakeCircleShape(circle, new Vector2(cx, cy), r);
            circle.PathProps = new PathProperties() { Stroke = stroke, Head = strokeEnding, Tail = strokeEnding, Corners = strokeCorner };
            circle.Fill = fill;

            sceneNode.Shapes = new List<Shape>(1);
            sceneNode.Shapes.Add(circle);

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void defs()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = new SceneNode(); // A new scene node instead of one precreated for us
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, allElems);

            currentSceneNode.Push(sceneNode);
            ParseChildren(node, node.Name);
            if (currentSceneNode.Pop() != sceneNode)
                throw SVGFormatException.StackError;
        }

        void ellipse()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            var fill = SVGAttribParser.ParseFill(node, svgObjects, postponedFills, styles);
            PathCorner strokeCorner;
            PathEnding strokeEnding;
            var stroke = ParseStrokeAttributeSet(node, out strokeCorner, out strokeEnding);

            float cx = AttribLengthVal(node, "cx", 0.0f, DimType.Width);
            float cy = AttribLengthVal(node, "cy", 0.0f, DimType.Height);
            float rx = AttribLengthVal(node, "rx", 0.0f, DimType.Length);
            float ry = AttribLengthVal(node, "ry", 0.0f, DimType.Length);

            var ellipse = new Shape();
            VectorUtils.MakeEllipseShape(ellipse, new Vector2(cx, cy), rx, ry);
            ellipse.PathProps = new PathProperties() { Stroke = stroke, Corners = strokeCorner, Head = strokeEnding, Tail = strokeEnding };
            ellipse.Fill = fill;

            sceneNode.Shapes = new List<Shape>(1);
            sceneNode.Shapes.Add(ellipse);

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void g()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, allElems);
        }

        void image()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            // Try to get the referenced image first, if we fail, we just ignore the whole thing
            var url = node["xlink:href"];
            if (url != null)
            {
                var textureFill = new TextureFill();
                textureFill.Mode = FillMode.NonZero;
                textureFill.Addressing = AddressMode.Clamp;

                var lowercaseURL = url.ToLower();
                if (lowercaseURL.StartsWith("data:"))
                {
                    textureFill.Texture = DecodeTextureData(url);
                }
                else
                {
                    if (!lowercaseURL.Contains("://"))
                    {
                        #if UNITY_EDITOR
                        textureFill.Texture = UnityEditor.AssetDatabase.LoadAssetAtPath<Texture2D>("Assets/" + url);
                        #endif
                    }
                    else if (lowercaseURL.StartsWith("http://") || lowercaseURL.StartsWith("https://"))
                    {
                        #pragma warning disable 618
                        // WWW is obsolete (replaced with UnityWebRequest), but this is the class that works best
                        // with editor code. We will continue to use WWW until UnityWebRequest works better in an editor
                        // environment.
                        using (WWW www = new WWW(url))
                        {
                            while (www.keepWaiting)
                                System.Threading.Thread.Sleep(10); // Progress bar please...
                            textureFill.Texture = www.texture;
                        }
                        #pragma warning restore 618
                    }
                    else
                    {
                        Debug.LogWarning("Unsupported URL scheme for <image> (only http/https is supported): " + url);
                    }
                }

                if (textureFill.Texture != null)
                {
                    // Fills and strokes don't seem to apply to image despite what the specs say
                    // All browsers and editing tools seem to ignore them, so we'll just do as well
                    ParseID(node, sceneNode);
                    ParseOpacity(sceneNode);
                    sceneNode.Transform = SVGAttribParser.ParseTransform(node);

                    var viewPort = ParseViewport(node, sceneNode, currentContainerSize.Peek());
                    sceneNode.Transform = sceneNode.Transform * Matrix2D.Translate(viewPort.position);
                    var viewBoxInfo = new ViewBoxInfo();
                    viewBoxInfo.ViewBox = new Rect(0, 0, textureFill.Texture.width, textureFill.Texture.height);
                    ParseViewBoxAspectRatio(node, ref viewBoxInfo);
                    ApplyViewBox(sceneNode, viewBoxInfo, viewPort);

                    var rect = new Shape();
                    VectorUtils.MakeRectangleShape(rect, new Rect(0, 0, textureFill.Texture.width, textureFill.Texture.height));
                    rect.Fill = textureFill;
                    sceneNode.Shapes = new List<Shape>(1);
                    sceneNode.Shapes.Add(rect);

                    ParseClipAndMask(node, sceneNode);
                }
            }

            // Resolve any previous node that was referencing this image
            string id = node["id"];
            if (!string.IsNullOrEmpty(id))
            {
                List<NodeReferenceData> refList;
                if (postponedSymbolData.TryGetValue(id, out refList))
                {
                    foreach (var refData in refList)
                        ResolveReferencedNode(sceneNode, refData, true);
                }
            }

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void line()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            PathCorner strokeCorner;
            PathEnding strokeEnding;
            var stroke = ParseStrokeAttributeSet(node, out strokeCorner, out strokeEnding);

            float x1 = AttribLengthVal(node, "x1", 0.0f, DimType.Width);
            float y1 = AttribLengthVal(node, "y1", 0.0f, DimType.Height);
            float x2 = AttribLengthVal(node, "x2", 0.0f, DimType.Width);
            float y2 = AttribLengthVal(node, "y2", 0.0f, DimType.Height);

            var path = new Shape();
            path.PathProps = new PathProperties() { Stroke = stroke, Head = strokeEnding, Tail = strokeEnding };
            path.Contours = new BezierContour[] {
                new BezierContour() { Segments = VectorUtils.BezierSegmentToPath(VectorUtils.MakeLine(new Vector2(x1, y1), new Vector2(x2, y2))) }
            };
            sceneNode.Shapes = new List<Shape>(1);
            sceneNode.Shapes.Add(path);

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void linearGradient()
        {
            var node = docReader.VisitCurrent();

            var link = node["xlink:href"];
            var refFill = SVGAttribParser.ParseRelativeRef(link, svgObjects) as GradientFill;
            var refFillData = refFill != null ? gradientExInfo[refFill] as LinearGradientExData : null;

            bool relativeToWorld = refFillData != null ? refFillData.WorldRelative : false;
            switch (node["gradientUnits"])
            {
                case null:
                    break;

                case "objectBoundingBox":
                    relativeToWorld = false;
                    break;

                case "userSpaceOnUse":
                    relativeToWorld = true;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("gradientUnits");
            }

            AddressMode addressing = refFill != null ? refFill.Addressing : AddressMode.Clamp;
            switch (node["spreadMethod"])
            {
                case null:
                    break;

                case "pad":
                    addressing = AddressMode.Clamp;
                    break;

                case "reflect":
                    addressing = AddressMode.Mirror;
                    break;

                case "repeat":
                    addressing = AddressMode.Wrap;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("spreadMethod");
            }

            var gradientTransform = SVGAttribParser.ParseTransform(node, "gradientTransform");

            GradientFill fill = CloneGradientFill(refFill);
            if (fill == null)
                fill = new GradientFill() { Addressing = addressing, Type = GradientFillType.Linear };

            LinearGradientExData fillExData = new LinearGradientExData() { WorldRelative = relativeToWorld, FillTransform = gradientTransform };
            gradientExInfo[fill] = fillExData;

            // Fills are defined outside of a shape scope, so we can't resolve relative coordinates here.
            // We defer this entire operation to AdjustFills pass, but we still do value validation here
            // nonetheless to give meaningful error messages to the user if any.
            currentContainerSize.Push(Vector2.one);

            fillExData.X1 = node["x1"];
            fillExData.Y1 = node["y1"];
            fillExData.X2 = node["x2"];
            fillExData.Y2 = node["y2"];

            // The calls below are ineffective but they validate the inputs and throw an error if wrong values are specified, so don't remove them
            AttribLengthVal(fillExData.X1, node, "x1", 0.0f, DimType.Width);
            AttribLengthVal(fillExData.Y1, node, "y1", 0.0f, DimType.Height);
            AttribLengthVal(fillExData.X2, node, "x2", 1.0f, DimType.Width);
            AttribLengthVal(fillExData.Y2, node, "y2", 0.0f, DimType.Height);

            currentContainerSize.Pop();
            currentGradientFill = fill; // Children stops will register to this fill now
            currentGradientId = node["id"];
            currentGradientLink = SVGAttribParser.CleanIri(link);

            if (!string.IsNullOrEmpty(link) && !svgObjects.ContainsKey(link))
            {
                // Reference may be defined later in the file. Save for postponed processing.
                if (!postponedStopData.ContainsKey(currentGradientLink))
                    postponedStopData.Add(currentGradientLink, new List<PostponedStopData>());
                postponedStopData[currentGradientLink].Add(new PostponedStopData() { fill = fill });
            }

            AddToSVGDictionaryIfPossible(node, fill);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, stop);
        }

        void path()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            var fill = SVGAttribParser.ParseFill(node, svgObjects, postponedFills, styles);
            PathCorner strokeCorner;
            PathEnding strokeEnding;
            var stroke = ParseStrokeAttributeSet(node, out strokeCorner, out strokeEnding);
            var pathProps = new PathProperties() { Stroke = stroke, Corners = strokeCorner, Head = strokeEnding, Tail = strokeEnding };

            // A path may have 1 or more sub paths. Each for us is an individual vector path.
            var contours = SVGAttribParser.ParsePath(node);
            if ((contours != null) && (contours.Count > 0))
            {
                //float pathLength = AttribFloatVal(node, "pathLength"); // This is useful for animation purposes mostly

                sceneNode.Shapes = new List<Shape>(1);
                sceneNode.Shapes.Add(new Shape() { Contours = contours.ToArray(), Fill = fill, PathProps = pathProps });

                AddToSVGDictionaryIfPossible(node, sceneNode);
            }

            ParseClipAndMask(node, sceneNode);

            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void polygon()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            var fill = SVGAttribParser.ParseFill(node, svgObjects, postponedFills, styles);
            PathCorner strokeCorner;
            PathEnding strokeEnding;
            var stroke = ParseStrokeAttributeSet(node, out strokeCorner, out strokeEnding);

            var pointsAttribVal = node["points"];
            var pointsString = (pointsAttribVal != null) ? pointsAttribVal.Split(whiteSpaceNumberChars, StringSplitOptions.RemoveEmptyEntries) : null;
            if (pointsString != null)
            {
                if ((pointsString.Length & 1) == 1)
                    throw node.GetException("polygon 'points' must specify x,y for each coordinate");
                if (pointsString.Length < 4)
                    throw node.GetException("polygon 'points' do not even specify one triangle");

                var pathProps = new PathProperties() { Stroke = stroke, Corners = strokeCorner, Head = strokeEnding, Tail = strokeEnding };
                var contour = new BezierContour() { Closed = true };
                var lastPoint = new Vector2(
                        AttribLengthVal(pointsString[0], node, "points", 0.0f, DimType.Width),
                        AttribLengthVal(pointsString[1], node, "points", 0.0f, DimType.Height));
                int maxSegments = pointsString.Length / 2;
                var segments = new List<BezierPathSegment>(maxSegments);
                for (int i = 1; i < maxSegments; i++)
                {
                    var newPoint = new Vector2(
                            AttribLengthVal(pointsString[i * 2 + 0], node, "points", 0.0f, DimType.Width),
                            AttribLengthVal(pointsString[i * 2 + 1], node, "points", 0.0f, DimType.Height));
                    if (newPoint == lastPoint)
                        continue;
                    var seg = VectorUtils.MakeLine(lastPoint, newPoint);
                    segments.Add(new BezierPathSegment() { P0 = seg.P0, P1 = seg.P1, P2 = seg.P2 });
                    lastPoint = newPoint;
                }

                if (segments.Count > 0)
                {
                    var connect = VectorUtils.MakeLine(lastPoint, segments[0].P0);
                    segments.Add(new BezierPathSegment() { P0 = connect.P0, P1 = connect.P1, P2 = connect.P2 });
                    contour.Segments = segments.ToArray();

                    var shape = new Shape() { Contours = new BezierContour[] { contour }, PathProps = pathProps, Fill = fill };
                    sceneNode.Shapes = new List<Shape>(1);
                    sceneNode.Shapes.Add(shape);
                }
            }

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void polyline()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            var fill = SVGAttribParser.ParseFill(node, svgObjects, postponedFills, styles);
            PathCorner strokeCorner;
            PathEnding strokeEnding;
            var stroke = ParseStrokeAttributeSet(node, out strokeCorner, out strokeEnding);

            var pointsAttribVal = node["points"];
            var pointsString = (pointsAttribVal != null) ? pointsAttribVal.Split(whiteSpaceNumberChars, StringSplitOptions.RemoveEmptyEntries) : null;
            if (pointsString != null)
            {
                if ((pointsString.Length & 1) == 1)
                    throw node.GetException("polyline 'points' must specify x,y for each coordinate");
                if (pointsString.Length < 4)
                    throw node.GetException("polyline 'points' do not even specify one line");

                var shape = new Shape() { Fill = fill };
                shape.PathProps = new PathProperties() { Stroke = stroke, Corners = strokeCorner, Head = strokeEnding, Tail = strokeEnding };
                var lastPoint = new Vector2(
                        AttribLengthVal(pointsString[0], node, "points", 0.0f, DimType.Width),
                        AttribLengthVal(pointsString[1], node, "points", 0.0f, DimType.Height));
                int maxSegments = pointsString.Length / 2;
                var segments = new List<BezierPathSegment>(maxSegments);
                for (int i = 1; i < maxSegments; i++)
                {
                    var newPoint = new Vector2(
                            AttribLengthVal(pointsString[i * 2 + 0], node, "points", 0.0f, DimType.Width),
                            AttribLengthVal(pointsString[i * 2 + 1], node, "points", 0.0f, DimType.Height));
                    if (newPoint == lastPoint)
                        continue;
                    var seg = VectorUtils.MakeLine(lastPoint, newPoint);
                    segments.Add(new BezierPathSegment() { P0 = seg.P0, P1 = seg.P1, P2 = seg.P2 });
                    lastPoint = newPoint;
                }
                if (segments.Count > 0 )
                {
                    var connect = VectorUtils.MakeLine(lastPoint, segments[0].P0);
                    segments.Add(new BezierPathSegment() { P0 = connect.P0, P1 = connect.P1, P2 = connect.P2 });
                    shape.Contours = new BezierContour[] {
                         new BezierContour() { Segments = segments.ToArray() }
                    };
                    sceneNode.Shapes = new List<Shape>(1);
                    sceneNode.Shapes.Add(shape);
                }
            }

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void radialGradient()
        {
            var node = docReader.VisitCurrent();

            var link = node["xlink:href"];
            var refFill = SVGAttribParser.ParseRelativeRef(link, svgObjects) as GradientFill;
            var refFillData = refFill != null ? gradientExInfo[refFill] as RadialGradientExData : null;

            bool relativeToWorld = refFillData != null ? refFillData.WorldRelative : false;
            switch (node["gradientUnits"])
            {
                case null:
                    break;

                case "objectBoundingBox":
                    relativeToWorld = false;
                    break;

                case "userSpaceOnUse":
                    relativeToWorld = true;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("gradientUnits");
            }

            AddressMode addressing = refFill != null ? refFill.Addressing : AddressMode.Clamp;
            switch (node["spreadMethod"])
            {
                case null:
                    break;

                case "pad":
                    addressing = AddressMode.Clamp;
                    break;

                case "reflect":
                    addressing = AddressMode.Mirror;
                    break;

                case "repeat":
                    addressing = AddressMode.Wrap;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("spreadMethod");
            }

            var gradientTransform = SVGAttribParser.ParseTransform(node, "gradientTransform");

            GradientFill fill = CloneGradientFill(refFill);
            if (fill == null)
                fill = new GradientFill() { Addressing = addressing, Type = GradientFillType.Radial };

            RadialGradientExData fillExData = new RadialGradientExData() { WorldRelative = relativeToWorld, FillTransform = gradientTransform };
            gradientExInfo[fill] = fillExData;

            // Fills are defined outside of a shape scope, so we can't resolve relative coordinates here.
            // We defer this entire operation to AdjustFills pass, but we still do value validation here
            // nonetheless to give meaningful error messages to the user if any.
            currentContainerSize.Push(Vector2.one);

            fillExData.Cx = node["cx"];
            fillExData.Cy = node["cy"];
            fillExData.Fx = node["fx"];
            fillExData.Fy = node["fy"];
            fillExData.R = node["r"];

            // The calls below are ineffective but they validate the inputs and throw an error if wrong values are specified, so don't remove them
            AttribLengthVal(fillExData.Cx, node, "cx", 0.5f, DimType.Width);
            AttribLengthVal(fillExData.Cy, node, "cy", 0.5f, DimType.Height);
            AttribLengthVal(fillExData.Fx, node, "fx", 0.5f, DimType.Width);
            AttribLengthVal(fillExData.Fy, node, "fy", 0.5f, DimType.Height);
            AttribLengthVal(fillExData.R, node, "r", 0.5f, DimType.Length);

            currentContainerSize.Pop();
            currentGradientFill = fill; // Children stops will register to this fill now
            currentGradientId = node["id"];
            currentGradientLink = SVGAttribParser.CleanIri(link);

            if (!string.IsNullOrEmpty(link) && !svgObjects.ContainsKey(link))
            {
                // Reference may be defined later in the file. Save for postponed processing.
                if (!postponedStopData.ContainsKey(currentGradientLink))
                    postponedStopData.Add(currentGradientLink, new List<PostponedStopData>());
                postponedStopData[currentGradientLink].Add(new PostponedStopData() { fill = fill });
            }

            AddToSVGDictionaryIfPossible(node, fill);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, stop);
        }

        void clipPath()
        {
            var node = docReader.VisitCurrent();
            string id = node["id"];

             // A new scene node instead of one precreated for us
            var clipRoot = new SceneNode() {
                Transform = SVGAttribParser.ParseTransform(node)
            };

            bool relativeToWorld;
            switch (node["clipPathUnits"])
            {
                case null:
                case "userSpaceOnUse":
                    relativeToWorld = true;
                    break;

                case "objectBoundingBox":
                    relativeToWorld = false;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("clipPathUnits");
            }

            clipData[clipRoot] = new ClipData() { WorldRelative = relativeToWorld };

            AddToSVGDictionaryIfPossible(node, clipRoot);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, allElems);

            currentSceneNode.Push(clipRoot);
            ParseChildren(node, node.Name);
            if (currentSceneNode.Pop() != clipRoot)
                throw SVGFormatException.StackError;
            
            // Resolve any previous node that was referencing this clipping path
            if (!string.IsNullOrEmpty(id))
            {
                List<PostponedClip> clips;
                if (postponedClip.TryGetValue(id, out clips))
                {
                    foreach (var clip in clips)
                        ApplyClipper(clipRoot, clip.node, relativeToWorld);
                }
            }

        }

        void pattern()
        {
            var node = docReader.VisitCurrent();

            // A new scene node instead of one precreated for us
            var patternRoot = new SceneNode() {
                Transform = Matrix2D.identity
            };

            bool relativeToWorld = false;
            switch (node["patternUnits"])
            {
                case null:
                case "objectBoundingBox":
                    relativeToWorld = false;
                    break;

                case "userSpaceOnUse":
                    relativeToWorld = true;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("patternUnits");
            }

            bool contentRelativeToWorld = true;
            switch (node["patternContentUnits"])
            {
                case null:
                case "userSpaceOnUse":
                    contentRelativeToWorld = true;
                    break;

                case "objectBoundingBox":
                    contentRelativeToWorld = false;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("patternContentUnits");
            }

            var x = AttribLengthVal(node["x"], node, "x", 0.0f, DimType.Width);
            var y = AttribLengthVal(node["y"], node, "y", 0.0f, DimType.Height);
            var w = AttribLengthVal(node["width"], node, "width", 0.0f, DimType.Width);
            var h = AttribLengthVal(node["height"], node, "height", 0.0f, DimType.Height);

            var patternTransform = SVGAttribParser.ParseTransform(node, "patternTransform");

            patternData[patternRoot] = new PatternData() {
                WorldRelative = relativeToWorld,
                ContentWorldRelative = contentRelativeToWorld,
                PatternTransform = patternTransform
            };

            var fill = new PatternFill() { 
                Pattern = patternRoot,
                Rect = new Rect(x, y, w, h)
            };

            AddToSVGDictionaryIfPossible(node, fill);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, allElems);

            currentSceneNode.Push(patternRoot);
            ParseChildren(node, node.Name);
            if (currentSceneNode.Pop() != patternRoot)
                throw SVGFormatException.StackError;
        }

        void mask()
        {
            var node = docReader.VisitCurrent();

            // A new scene node instead of one precreated for us
            var maskRoot = new SceneNode() {
                Transform = Matrix2D.identity
            };

            bool relativeToWorld;
            switch (node["maskUnits"])
            {
                case null:
                case "userSpaceOnUse":
                    relativeToWorld = true;
                    break;

                case "objectBoundingBox":
                    relativeToWorld = false;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("maskUnits");
            }

            bool contentRelativeToWorld;
            switch (node["maskContentUnits"])
            {
                case null:
                case "userSpaceOnUse":
                    contentRelativeToWorld = true;
                    break;

                case "objectBoundingBox":
                    contentRelativeToWorld = false;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("maskContentUnits");
            }

            maskData[maskRoot] = new MaskData() {
                WorldRelative = relativeToWorld,
                ContentWorldRelative = contentRelativeToWorld,
            };

            AddToSVGDictionaryIfPossible(node, maskRoot);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, allElems);

            currentSceneNode.Push(maskRoot);
            ParseChildren(node, node.Name);
            if (currentSceneNode.Pop() != maskRoot)
                throw SVGFormatException.StackError;
        }

        void rect()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            var fill = SVGAttribParser.ParseFill(node, svgObjects, postponedFills, styles);
            PathCorner strokeCorner;
            PathEnding strokeEnding;
            var stroke = ParseStrokeAttributeSet(node, out strokeCorner, out strokeEnding);

            float x = AttribLengthVal(node, "x", 0.0f, DimType.Width);
            float y = AttribLengthVal(node, "y", 0.0f, DimType.Height);
            float rx = AttribLengthVal(node, "rx", -1.0f, DimType.Length);
            float ry = AttribLengthVal(node, "ry", -1.0f, DimType.Length);
            float width = AttribLengthVal(node, "width", 0.0f, DimType.Length);
            float height = AttribLengthVal(node, "height", 0.0f, DimType.Length);

            if ((rx < 0.0f) && (ry >= 0.0f))
                rx = ry;
            else if ((ry < 0.0f) && (rx >= 0.0f))
                ry = rx;
            else if ((ry < 0.0f) && (rx < 0.0f))
                rx = ry = 0.0f;
            rx = Mathf.Min(rx, width * 0.5f);
            ry = Mathf.Min(ry, height * 0.5f);

            var rad = new Vector2(rx, ry);
            var rect = new Shape();
            VectorUtils.MakeRectangleShape(rect, new Rect(x, y, width, height), rad, rad, rad, rad);
            rect.Fill = fill;
            rect.PathProps = new PathProperties() { Stroke = stroke, Head = strokeEnding, Tail = strokeEnding, Corners = strokeCorner };
            sceneNode.Shapes = new List<Shape>(1);
            sceneNode.Shapes.Add(rect);

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void stop()
        {
            var node = docReader.VisitCurrent();
            System.Diagnostics.Debug.Assert(currentGradientFill != null);

            GradientStop stop = new GradientStop();

            string stopColor = styles.Evaluate("stop-color");
            Color color = stopColor != null ? SVGAttribParser.ParseColor(stopColor) : Color.black;

            color.a = AttribFloatVal("stop-opacity", 1.0f);
            stop.Color = color;

            string offsetString = styles.Evaluate("offset");
            if (!string.IsNullOrEmpty(offsetString))
            {
                bool percentage = offsetString.EndsWith("%");
                if (percentage)
                    offsetString = offsetString.Substring(0, offsetString.Length - 1);
                stop.StopPercentage = SVGAttribParser.ParseFloat(offsetString);
                if (percentage)
                    stop.StopPercentage /= 100.0f;

                stop.StopPercentage = Mathf.Max(0.0f, stop.StopPercentage);
                stop.StopPercentage = Mathf.Min(1.0f, stop.StopPercentage);
            }

            // I don't like this, but hopefully there aren't many stops in a gradient
            GradientStop[] newStops;
            if (currentGradientFill.Stops == null || currentGradientFill.Stops.Length == 0)
                newStops = new GradientStop[1];
            else
            {
                newStops = new GradientStop[currentGradientFill.Stops.Length + 1];
                currentGradientFill.Stops.CopyTo(newStops, 0);
            }
            newStops[newStops.Length - 1] = stop;
            currentGradientFill.Stops = newStops;

            // Apply postponed stops if this was defined later in the file
            if (!string.IsNullOrEmpty(currentGradientId) && postponedStopData.ContainsKey(currentGradientId))
            {
                foreach (var postponedStop in postponedStopData[currentGradientId])
                    postponedStop.fill.Stops = newStops;
            }

            // Local stops overrides referenced ones
            if (!string.IsNullOrEmpty(currentGradientLink) && postponedStopData.ContainsKey(currentGradientLink))
            {
                var stopDataList = postponedStopData[currentGradientLink];
                foreach (var postponedStop in stopDataList)
                {
                    if (postponedStop.fill == currentGradientFill)
                    {
                        stopDataList.Remove(postponedStop);
                        break;
                    }
                }
            }

            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void svg()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = new SceneNode();
            if (scene.Root == null) // If this is the root SVG element, then we set the vector scene root as well
            {
                System.Diagnostics.Debug.Assert(currentSceneNode.Count == 0);
                scene.Root = sceneNode;
            }

            styles.PushNode(node);

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);

            sceneViewport = ParseViewport(node, sceneNode, new Vector2(windowWidth, windowHeight));
            var viewBoxInfo = ParseViewBox(node, sceneNode, sceneViewport);
            if (applyRootViewBox)
                ApplyViewBox(sceneNode, viewBoxInfo, sceneViewport);

            currentContainerSize.Push(sceneViewport.size);
            if (!viewBoxInfo.IsEmpty)
                currentViewBoxSize.Push(viewBoxInfo.ViewBox.size);

            currentSceneNode.Push(sceneNode);
            nodeGlobalSceneState[sceneNode] = new NodeGlobalSceneState() { ContainerSize = currentContainerSize.Peek() };

            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, allElems);
            ParseChildren(node, "svg");

            if (currentSceneNode.Pop() != sceneNode)
                throw SVGFormatException.StackError;

            if (!viewBoxInfo.IsEmpty)
                currentViewBoxSize.Pop();
            currentContainerSize.Pop();

            styles.PopNode();
        }

        void symbol()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = new SceneNode(); // A new scene node instead of one precreated for us
            string id = node["id"];

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = Matrix2D.identity;

            Rect viewportRect = new Rect(Vector2.zero, currentContainerSize.Peek());
            var viewBoxInfo = ParseViewBox(node, sceneNode, viewportRect);
            if (!viewBoxInfo.IsEmpty)
                currentViewBoxSize.Push(viewBoxInfo.ViewBox.size);

            symbolViewBoxes[sceneNode] = viewBoxInfo;

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, allElems);

            currentSceneNode.Push(sceneNode);
            ParseChildren(node, node.Name);
            if (currentSceneNode.Pop() != sceneNode)
                throw SVGFormatException.StackError;

            if (!viewBoxInfo.IsEmpty)
                currentViewBoxSize.Pop();

            ParseClipAndMask(node, sceneNode);

            // Resolve any previous node that was referencing this symbol
            if (!string.IsNullOrEmpty(id))
            {
                List<NodeReferenceData> refList;
                if (postponedSymbolData.TryGetValue(id, out refList))
                {
                    foreach (var refData in refList)
                        ResolveReferencedNode(sceneNode, refData, true);
                }
            }
        }

        void use()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseOpacity(sceneNode);

            var sceneViewport = ParseViewport(node, sceneNode, Vector2.zero);
            var refData = new NodeReferenceData() {
                node = sceneNode,
                viewport = sceneViewport,
                id = node["id"]
            };

            var iri = node["xlink:href"];
            var referencedNode = SVGAttribParser.ParseRelativeRef(iri, svgObjects) as SceneNode;
            if (referencedNode == null && !string.IsNullOrEmpty(iri) && iri.StartsWith("#"))
            {
                // The referenced node may be defined later in the file, save it for later
                iri = iri.Substring(1);
                List<NodeReferenceData> refList;
                if (!postponedSymbolData.TryGetValue(iri, out refList))
                {
                    refList = new List<NodeReferenceData>();
                    postponedSymbolData[iri] = refList;
                }
                refList.Add(refData);
            }

            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            sceneNode.Transform = sceneNode.Transform * Matrix2D.Translate(sceneViewport.position);

            if (referencedNode != null)
                ResolveReferencedNode(referencedNode, refData, false);

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void style()
        {
            var node = docReader.VisitCurrent();
            var text = docReader.ReadTextWithinElement();

            if (text.Length > 0)
                styles.SetGlobalStyleSheet(SVGStyleSheetUtils.Parse(text));

            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }
        #endregion

        #region Symbol Reference Processing
        private void ResolveReferencedNode(SceneNode referencedNode, NodeReferenceData refData, bool isDeferred)
        {
            // Note we don't use the viewport size because the <use> element doesn't establish a viewport for its referenced elements
            ViewBoxInfo viewBoxInfo;
            if (symbolViewBoxes.TryGetValue(referencedNode, out viewBoxInfo))
                ApplyViewBox(refData.node, viewBoxInfo, refData.viewport); // When using a symbol we need to apply the symbol's view box

            if (refData.node.Children == null)
                refData.node.Children = new List<SceneNode>();

            SVGStyleResolver.StyleLayer rootLayer = null;
            if (isDeferred)
            {
                // If deferred, push back the original <use> tag style layer to be in the same "style environment"
                rootLayer = styles.GetLayerForScenNode(refData.node);
                if (rootLayer != null)
                    styles.PushLayer(rootLayer);
            }

            // Activate the styles of the referenced node
            var styleLayer = nodeStyleLayers[referencedNode];
            if (styleLayer != null)
                styles.PushLayer(styleLayer);

            // Build a map to be able to retrieve the original node's style layer
            var originalNodes = new List<SceneNode>(10);
            foreach (var child in VectorUtils.SceneNodes(referencedNode))
                originalNodes.Add(child);

            var node = CloneSceneNode(referencedNode);

            int originalIndex = 0;
            foreach (var child in VectorUtils.SceneNodes(node))
            {
                var nodeIndex = originalIndex++;
                if (child.Shapes == null)
                    continue;

                var originalNode = originalNodes[nodeIndex];
                var layer = styles.GetLayerForScenNode(originalNode);
                if (layer != null)
                    styles.PushLayer(layer);

                bool isDefaultFill;
                var fill = SVGAttribParser.ParseFill(null, svgObjects, postponedFills, styles, Inheritance.Inherited, out isDefaultFill);
                PathCorner strokeCorner;
                PathEnding strokeEnding;
                var stroke = ParseStrokeAttributeSet(null, out strokeCorner, out strokeEnding);

                foreach (var shape in child.Shapes)
                {
                    var pathProps = shape.PathProps;
                    pathProps.Stroke = stroke;
                    pathProps.Corners = strokeCorner;
                    pathProps.Head = strokeEnding;
                    shape.PathProps = pathProps;
                    shape.Fill = isDefaultFill ? shape.Fill : fill;
                }

                if (layer != null)
                    styles.PopLayer();
            }

            if (styleLayer != null)
                styles.PopLayer();

            if (rootLayer != null)
                styles.PopLayer();

            // We process the node ID here to refer to the proper scene node
            if (!string.IsNullOrEmpty(refData.id))
                nodeIDs[refData.id] = node;

            refData.node.Children.Add(node);
        }
        #endregion

        #region Scene Node Cloning
        // This is a poor man's cloning system, until we have proper serialization in VectorScene.
        private SceneNode CloneSceneNode(SceneNode node)
        {
            if (node == null)
                return null;

            List<SceneNode> children = null;
            if (node.Children != null)
            {
                children = new List<SceneNode>(node.Children.Count);
                foreach (var c in node.Children)
                    children.Add(CloneSceneNode(c));
            }

            List<Shape> shapes = null;
            if (node.Shapes != null)
            {
                shapes = new List<Shape>(node.Shapes.Count);
                foreach (var d in node.Shapes)
                    shapes.Add(CloneShape(d));
            }

            var n = new SceneNode() {
                Children = children,
                Shapes = shapes,
                Transform = node.Transform,
                Clipper = CloneSceneNode(node.Clipper)
            };

            if (nodeGlobalSceneState.ContainsKey(node))
                nodeGlobalSceneState[n] = nodeGlobalSceneState[node];
            if (nodeOpacity.ContainsKey(node))
                nodeOpacity[n] = nodeOpacity[node];

            return n;
        }

        private Shape CloneShape(Shape shape)
        {
            if (shape == null)
                return null;

            BezierContour[] contours = null;
            if (shape.Contours != null)
            {
                contours = new BezierContour[shape.Contours.Length];
                for (int i = 0; i < contours.Length; ++i)
                    contours[i] = CloneContour(shape.Contours[i]);
            }
            return new Shape() {
                Fill = CloneFill(shape.Fill),
                FillTransform = shape.FillTransform,
                PathProps = ClonePathProps(shape.PathProps),
                Contours = contours,
                IsConvex = shape.IsConvex
            };
        }

        private BezierContour CloneContour(BezierContour c)
        {
            BezierPathSegment[] segs = null;
            if (c.Segments != null)
            {
                segs = new BezierPathSegment[c.Segments.Length];
                for (int i = 0; i < segs.Length; ++i)
                {
                    var s = c.Segments[i];
                    segs[i] = new BezierPathSegment() { P0 = s.P0, P1 = s.P1, P2 = s.P2 };
                }
            }
            return new BezierContour() { Segments = segs, Closed = c.Closed };
        }

        private IFill CloneFill(IFill fill)
        {
            if (fill == null)
                return null;

            IFill f = null;
            if (fill is SolidFill)
            {
                var solid = fill as SolidFill;
                f = new SolidFill() {
                    Color = solid.Color,
                    Opacity = solid.Opacity,
                    Mode = solid.Mode
                };
            }
            else if (fill is GradientFill)
            {
                var grad = fill as GradientFill;
                GradientStop[] stops = null;
                if (grad.Stops != null)
                {
                    stops = new GradientStop[grad.Stops.Length];
                    for (int i = 0; i < stops.Length; ++i)
                    {
                        var stop = grad.Stops[i];
                        stops[i] = new GradientStop() { Color = stop.Color, StopPercentage = stop.StopPercentage };
                    }
                }
                var gradientFill = new GradientFill() {
                    Type = grad.Type,
                    Stops = stops,
                    Mode = grad.Mode,
                    Opacity = grad.Opacity,
                    Addressing = grad.Addressing,
                    RadialFocus = grad.RadialFocus
                };
                gradientExInfo[gradientFill] = gradientExInfo[grad];
                f = gradientFill;
            }
            else if (fill is TextureFill)
            {
                var tex = fill as TextureFill;
                f = new TextureFill() {
                    Texture = tex.Texture,
                    Mode = tex.Mode,
                    Opacity = tex.Opacity,
                    Addressing = tex.Addressing
                };
            }
            else if (fill is PatternFill)
            {
                var pat = fill as PatternFill;
                f = new PatternFill() {
                    Mode = pat.Mode,
                    Opacity = pat.Opacity,
                    Pattern = CloneSceneNode(pat.Pattern),
                    Rect = pat.Rect
                };
            }
            return f;
        }

        private PathProperties ClonePathProps(PathProperties props)
        {
            Stroke stroke = null;
            if (props.Stroke != null)
            {
                float[] pattern = null;
                if (props.Stroke.Pattern != null)
                {
                    pattern = new float[props.Stroke.Pattern.Length];
                    for (int i = 0; i < pattern.Length; ++i)
                        pattern[i] = props.Stroke.Pattern[i];
                }
                stroke = new Stroke() {
                    Fill = CloneFill(props.Stroke.Fill),
                    FillTransform = props.Stroke.FillTransform,
                    HalfThickness = props.Stroke.HalfThickness,
                    Pattern = pattern,
                    PatternOffset = props.Stroke.PatternOffset,
                    TippedCornerLimit = props.Stroke.TippedCornerLimit
                };
            }

            return new PathProperties() {
                Stroke = stroke,
                Head = props.Head,
                Tail = props.Tail,
                Corners = props.Corners
            };
        }
        #endregion

        #region Utilities
        private GradientFill CloneGradientFill(GradientFill other)
        {
            if (other == null)
                return null;

            // This is a very fragile gradient fill cloning used since Illustrator
            // will sometimes refer to another fill using a "xlink:href" attribute.
            return new GradientFill() {
                Type = other.Type,
                Stops = other.Stops,
                Mode = other.Mode,
                Opacity = other.Opacity,
                Addressing = other.Addressing,
                RadialFocus = other.RadialFocus
            };
        }
        #endregion

        #region Simple Attribute Handling
        int AttribIntVal(string attribName) { return AttribIntVal(attribName, 0); }
        int AttribIntVal(string attribName, int defaultVal)
        {
            string val = styles.Evaluate(attribName);
            return (val != null) ? int.Parse(val) : defaultVal;
        }

        float AttribFloatVal(string attribName) { return AttribFloatVal(attribName, 0.0f); }
        float AttribFloatVal(string attribName, float defaultVal)
        {
            string val = styles.Evaluate(attribName);
            return (val != null) ? SVGAttribParser.ParseFloat(val) : defaultVal;
        }

        float AttribLengthVal(XmlReaderIterator.Node node, string attribName, DimType dimType) { return AttribLengthVal(node, attribName, 0.0f, dimType); }
        float AttribLengthVal(XmlReaderIterator.Node node, string attribName, float defaultUnitVal, DimType dimType)
        {
            var val = styles.Evaluate(attribName);
            return AttribLengthVal(val, node, attribName, defaultUnitVal, dimType);
        }

        float AttribLengthVal(string val, XmlReaderIterator.Node node, string attribName, float defaultUnitVal, DimType dimType)
        {
            // For reference: http://www.w3.org/TR/SVG/coords.html#Units
            if (val == null) return defaultUnitVal;
            val = val.Trim();
            string unitType = "px";
            char lastChar = val[val.Length - 1];
            if (lastChar == '%')
            {
                float number = SVGAttribParser.ParseFloat(val.Substring(0, val.Length - 1));
                if (number < 0)
                    throw node.GetException("Number in " + attribName + " cannot be negative");
                number /= 100.0f;

                // If there's an active viewbox, this should be used as the reference size for relative coordinates.
                // See https://www.w3.org/TR/SVG/coords.html#Units
                Vector2 vpSize = currentViewBoxSize.Count > 0 ? currentViewBoxSize.Peek() : currentContainerSize.Peek();

                switch (dimType)
                {
                    case DimType.Width: return number * vpSize.x;
                    case DimType.Height: return number * vpSize.y;
                    case DimType.Length: return (number * vpSize.magnitude / SVGLengthFactor); // See http://www.w3.org/TR/SVG/coords.html#Units
                }
            }
            else if (val.Length >= 2)
            {
                unitType = val.Substring(val.Length - 2);
            }

            if (char.IsDigit(lastChar) || (lastChar == '.'))
                return SVGAttribParser.ParseFloat(val); // No unit specified.. assume pixels (one px unit is defined to be equal to one user unit)

            float length = SVGAttribParser.ParseFloat(val.Substring(0, val.Length - 2));
            switch (unitType)
            {
                case "em": throw new NotImplementedException();
                case "ex": throw new NotImplementedException();
                case "px": return length;
                case "in": return 90.0f * length * dpiScale;       // "1in" equals "90px" (and therefore 90 user units)
                case "cm": return 35.43307f * length * dpiScale;   // "1cm" equals "35.43307px" (and therefore 35.43307 user units)
                case "mm": return 3.543307f * length * dpiScale;   // "1mm" would be "3.543307px" (3.543307 user units)
                case "pt": return 1.25f * length * dpiScale;       // "1pt" equals "1.25px" (and therefore 1.25 user units)
                case "pc": return 15.0f * length * dpiScale;       // "1pc" equals "15px" (and therefore 15 user units)
                default:
                    throw new FormatException("Unknown length unit type (" + unitType + ")");
            }
        }

        #endregion

        #region Attribute Set Handling
        void AddToSVGDictionaryIfPossible(XmlReaderIterator.Node node, object vectorElement)
        {
            string id = node["id"];
            if (!string.IsNullOrEmpty(id))
                svgObjects[id] = vectorElement;
        }

        Rect ParseViewport(XmlReaderIterator.Node node, SceneNode sceneNode, Vector2 defaultViewportSize)
        {
            scenePos.x = AttribLengthVal(node, "x", DimType.Width);
            scenePos.y = AttribLengthVal(node, "y", DimType.Height);
            sceneSize.x = AttribLengthVal(node, "width", defaultViewportSize.x, DimType.Width);
            sceneSize.y = AttribLengthVal(node, "height", defaultViewportSize.y, DimType.Height);

            // The size could be all 0, in which case we should ignore the viewport sizing logic altogether
            return new Rect(scenePos, sceneSize);
        }

        enum ViewBoxAlign { Min, Mid, Max }
        enum ViewBoxAspectRatio { DontPreserve, FitLargestDim, FitSmallestDim }
        struct ViewBoxInfo { public Rect ViewBox; public ViewBoxAspectRatio AspectRatio; public ViewBoxAlign AlignX, AlignY; public bool IsEmpty; }
        ViewBoxInfo ParseViewBox(XmlReaderIterator.Node node, SceneNode sceneNode, Rect sceneViewport)
        {
            var viewBoxInfo = new ViewBoxInfo() { IsEmpty = true };
            string viewBoxString = node["viewBox"];
            viewBoxString = viewBoxString != null ? viewBoxString.Trim() : null;
            if (string.IsNullOrEmpty(viewBoxString))
                return viewBoxInfo;

            var viewBoxValues = viewBoxString.Split(new char[] { ' ', ',' }, StringSplitOptions.RemoveEmptyEntries);
            if (viewBoxValues.Length != 4)
                throw node.GetException("Invalid viewBox specification");
            Vector2 viewBoxMin = new Vector2(
                    AttribLengthVal(viewBoxValues[0], node, "viewBox", 0.0f, DimType.Width),
                    AttribLengthVal(viewBoxValues[1], node, "viewBox", 0.0f, DimType.Height));
            Vector2 viewBoxSize = new Vector2(
                    AttribLengthVal(viewBoxValues[2], node, "viewBox", sceneViewport.width, DimType.Width),
                    AttribLengthVal(viewBoxValues[3], node, "viewBox", sceneViewport.height, DimType.Height));

            viewBoxInfo.ViewBox = new Rect(viewBoxMin, viewBoxSize);
            ParseViewBoxAspectRatio(node, ref viewBoxInfo);

            viewBoxInfo.IsEmpty = false;
            return viewBoxInfo;
        }

        void ParseViewBoxAspectRatio(XmlReaderIterator.Node node, ref ViewBoxInfo viewBoxInfo)
        {
            viewBoxInfo.AspectRatio = ViewBoxAspectRatio.FitLargestDim;
            viewBoxInfo.AlignX = ViewBoxAlign.Mid;
            viewBoxInfo.AlignY = ViewBoxAlign.Mid;

            string preserveAspectRatioString = node["preserveAspectRatio"];
            preserveAspectRatioString = preserveAspectRatioString != null ? preserveAspectRatioString.Trim() : null;
            bool wantNone = false;
            if (!string.IsNullOrEmpty(preserveAspectRatioString))
            {
                var preserveAspectRatioValues = preserveAspectRatioString.Split(new char[] { ' ', ',' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var value in preserveAspectRatioValues)
                {
                    switch (value)
                    {
                        case "defer": break; // This is only meaningful on <image> that references another SVG, we don't support that
                        case "none": wantNone = true; break;
                        case "xMinYMin": viewBoxInfo.AlignX = ViewBoxAlign.Min; viewBoxInfo.AlignY = ViewBoxAlign.Min; break;
                        case "xMidYMin": viewBoxInfo.AlignX = ViewBoxAlign.Mid; viewBoxInfo.AlignY = ViewBoxAlign.Min; break;
                        case "xMaxYMin": viewBoxInfo.AlignX = ViewBoxAlign.Max; viewBoxInfo.AlignY = ViewBoxAlign.Min; break;
                        case "xMinYMid": viewBoxInfo.AlignX = ViewBoxAlign.Min; viewBoxInfo.AlignY = ViewBoxAlign.Mid; break;
                        case "xMidYMid": viewBoxInfo.AlignX = ViewBoxAlign.Mid; viewBoxInfo.AlignY = ViewBoxAlign.Mid; break;
                        case "xMaxYMid": viewBoxInfo.AlignX = ViewBoxAlign.Max; viewBoxInfo.AlignY = ViewBoxAlign.Mid; break;
                        case "xMinYMax": viewBoxInfo.AlignX = ViewBoxAlign.Min; viewBoxInfo.AlignY = ViewBoxAlign.Max; break;
                        case "xMidYMax": viewBoxInfo.AlignX = ViewBoxAlign.Mid; viewBoxInfo.AlignY = ViewBoxAlign.Max; break;
                        case "xMaxYMax": viewBoxInfo.AlignX = ViewBoxAlign.Max; viewBoxInfo.AlignY = ViewBoxAlign.Max; break;
                        case "meet": viewBoxInfo.AspectRatio = ViewBoxAspectRatio.FitLargestDim; break;
                        case "slice": viewBoxInfo.AspectRatio = ViewBoxAspectRatio.FitSmallestDim; break;
                    }
                }
            }

            if (wantNone) // Override aspect ratio no matter what other modes are chosen (meet/slice)
                viewBoxInfo.AspectRatio = ViewBoxAspectRatio.DontPreserve;
        }

        void ApplyViewBox(SceneNode sceneNode, ViewBoxInfo viewBoxInfo, Rect sceneViewport)
        {
            if ((viewBoxInfo.ViewBox.size == Vector2.zero) || (sceneViewport.size == Vector2.zero))
                return;

            Vector2 scale = Vector2.one, offset = -viewBoxInfo.ViewBox.position;
            if (viewBoxInfo.AspectRatio == ViewBoxAspectRatio.DontPreserve)
            {
                scale = sceneViewport.size / viewBoxInfo.ViewBox.size;
            }
            else
            {
                scale.x = scale.y = sceneViewport.width / viewBoxInfo.ViewBox.width;
                bool fitsOnWidth;
                if (viewBoxInfo.AspectRatio == ViewBoxAspectRatio.FitLargestDim)
                    fitsOnWidth = viewBoxInfo.ViewBox.height * scale.y <= sceneViewport.height;
                else fitsOnWidth = viewBoxInfo.ViewBox.height * scale.y > sceneViewport.height;

                Vector2 alignOffset = Vector2.zero;
                if (fitsOnWidth)
                {
                    // We fit on the width, so apply the vertical alignment rules
                    if (viewBoxInfo.AlignY == ViewBoxAlign.Mid)
                        alignOffset.y = (sceneViewport.height - viewBoxInfo.ViewBox.height * scale.y) * 0.5f;
                    else if (viewBoxInfo.AlignY == ViewBoxAlign.Max)
                        alignOffset.y = sceneViewport.height - viewBoxInfo.ViewBox.height * scale.y;
                }
                else
                {
                    // We didn't fit on width, meaning we should fit on height and use the wiggle room on width
                    scale.x = scale.y = sceneViewport.height / viewBoxInfo.ViewBox.height;

                    // Apply the horizontal alignment rules
                    if (viewBoxInfo.AlignX == ViewBoxAlign.Mid)
                        alignOffset.x = (sceneViewport.width - viewBoxInfo.ViewBox.width * scale.x) * 0.5f;
                    else if (viewBoxInfo.AlignX == ViewBoxAlign.Max)
                        alignOffset.x = sceneViewport.width - viewBoxInfo.ViewBox.width * scale.x;
                }

                offset += alignOffset / scale;
            }

            // Aaaaand finally, the transform
            sceneNode.Transform = sceneNode.Transform * Matrix2D.Scale(scale) * Matrix2D.Translate(offset);
        }

        Stroke ParseStrokeAttributeSet(XmlReaderIterator.Node node, out PathCorner strokeCorner, out PathEnding strokeEnding, Inheritance inheritance = Inheritance.Inherited)
        {
            var stroke = SVGAttribParser.ParseStrokeAndOpacity(node, svgObjects, styles, inheritance);
            strokeCorner = PathCorner.Tipped;
            strokeEnding = PathEnding.Chop;
            if (stroke != null)
            {
                string strokeWidth = styles.Evaluate("stroke-width", inheritance);
                stroke.HalfThickness = AttribLengthVal(strokeWidth, node, "stroke-width", 1.0f, DimType.Length) * 0.5f;
                switch (styles.Evaluate("stroke-linecap", inheritance))
                {
                    case "butt": strokeEnding = PathEnding.Chop; break;
                    case "square": strokeEnding = PathEnding.Square; break;
                    case "round": strokeEnding = PathEnding.Round; break;
                }
                switch (styles.Evaluate("stroke-linejoin", inheritance))
                {
                    case "miter": strokeCorner = PathCorner.Tipped; break;
                    case "round": strokeCorner = PathCorner.Round; break;
                    case "bevel": strokeCorner = PathCorner.Beveled; break;
                }

                string pattern = styles.Evaluate("stroke-dasharray", inheritance);
                if (pattern != null && pattern != "none")
                {
                    string[] entries = pattern.Split(whiteSpaceNumberChars, StringSplitOptions.RemoveEmptyEntries);
                    // If the pattern is odd, then we duplicate it to make it even as per the spec
                    int totalCount = (entries.Length & 1) == 1 ? entries.Length * 2 : entries.Length;
                    stroke.Pattern = new float[totalCount];
                    for (int i = 0; i < entries.Length; i++)
                        stroke.Pattern[i] = AttribLengthVal(entries[i], node, "stroke-dasharray", 0.0f, DimType.Length);

                    // Duplicate the pattern
                    if (totalCount > entries.Length)
                    {
                        for (int i = 0; i < entries.Length; i++)
                            stroke.Pattern[i + entries.Length] = stroke.Pattern[i];
                    }

                    var dashOffset = styles.Evaluate("stroke-dashoffset", inheritance);
                    stroke.PatternOffset = AttribLengthVal(dashOffset, node, "stroke-dashoffset", 0.0f, DimType.Length);
                }

                var strokeMiterLimit = styles.Evaluate("stroke-miterlimit", inheritance);
                stroke.TippedCornerLimit = AttribLengthVal(strokeMiterLimit, node, "stroke-miterlimit", 4.0f, DimType.Length);
                if (stroke.TippedCornerLimit < 1.0f)
                    throw node.GetException("'stroke-miterlimit' should be greater or equal to 1");
            } // If stroke is specified
            return stroke;
        }

        void ParseID(XmlReaderIterator.Node node, SceneNode sceneNode)
        {
            string id = node["id"];
            if (!string.IsNullOrEmpty(id))
            {
                nodeIDs[id] = sceneNode;

                // Store the style layer of this node since it can be referenced later by a <use> tag
                nodeStyleLayers[sceneNode] = styles.PeekLayer();
            }
        }

        float ParseOpacity(SceneNode sceneNode)
        {
            float opacity = AttribFloatVal("opacity", 1.0f);
            if (opacity != 1.0f && sceneNode != null)
                nodeOpacity[sceneNode] = opacity;
            return opacity;
        }

        void ParseClipAndMask(XmlReaderIterator.Node node, SceneNode sceneNode)
        {
            ParseClip(node, sceneNode);
            ParseMask(node, sceneNode);
        }

        void ParseClip(XmlReaderIterator.Node node, SceneNode sceneNode)
        {
            string reference = null;
            string clipPath = styles.Evaluate("clip-path");
            if (clipPath != null)
                reference = SVGAttribParser.ParseURLRef(clipPath);

            if (reference == null)
                return;

            var clipper = SVGAttribParser.ParseRelativeRef(reference, svgObjects) as SceneNode;
            if (clipper == null && reference.Length > 1 && reference.StartsWith("#"))
            {
                // Clipper may be defined later in the file
                List<PostponedClip> clips;
                if (!postponedClip.TryGetValue(reference, out clips))
                    clips = new List<PostponedClip>(1);
                clips.Add(new PostponedClip() { node = sceneNode });
                postponedClip[reference.Substring(1)] = clips;
                return;
            }
            var clipperRoot = clipper;

            bool worldRelative = true;
            ClipData data;
            if (clipData.TryGetValue(clipper, out data))
                worldRelative = data.WorldRelative;

            ApplyClipper(clipper, sceneNode, worldRelative);
        }

        void ApplyClipper(SceneNode clipper, SceneNode target, bool worldRelative)
        {
            SceneNode clipperRoot = clipper;
            if (!worldRelative)
            {
                // If the referenced clip path units is in bounding-box space, we add an intermediate
                // node to scale the content to the correct size.
                var rect = VectorUtils.SceneNodeBounds(target);
                var transform = Matrix2D.Translate(rect.position) * Matrix2D.Scale(rect.size);

                clipperRoot = new SceneNode() {
                    Children = new List<SceneNode> { clipper },
                    Transform = transform
                };
            }
            target.Clipper = clipperRoot;
        }

        void ParseMask(XmlReaderIterator.Node node, SceneNode sceneNode)
        {
            string reference = null;
            string maskRef = node["mask"];
            if (maskRef != null)
                reference = SVGAttribParser.ParseURLRef(maskRef);

            if (reference == null)
                return;

            var maskPath = SVGAttribParser.ParseRelativeRef(reference, svgObjects) as SceneNode;
            var maskRoot = maskPath;

            MaskData data;
            if (maskData.TryGetValue(maskPath, out data) && !data.ContentWorldRelative)
            {
                // If the referenced mask units is in bounding-box space, we add an intermediate
                // node to scale the content to the correct size.
                var rect = VectorUtils.SceneNodeBounds(sceneNode);
                var transform = Matrix2D.Translate(rect.position) * Matrix2D.Scale(rect.size);

                maskRoot = new SceneNode() {
                    Children = new List<SceneNode> { maskPath },
                    Transform = transform
                };
            }

            sceneNode.Clipper = maskRoot;
        }

        #endregion

        #region Textures
        Texture2D DecodeTextureData(string dataURI)
        {
            int pos = 5; // Skip "data:"
            int length = dataURI.Length;

            int startPos = pos;
            while (pos < length && dataURI[pos] != ';' && dataURI[pos] != ',')
                ++pos;

            var mediaType = dataURI.Substring(startPos, pos-startPos);
            if (mediaType != "image/png" && mediaType != "image/jpeg")
                return null;

            while (pos < length && dataURI[pos] != ',')
                ++pos;

            ++pos; // Skip ','

            if (pos >= length)
                return null;

            var data = Convert.FromBase64String(dataURI.Substring(pos));

            var tex = new Texture2D(1, 1);
            if (tex.LoadImage(data))
                return tex;

            return null;
        }
        #endregion

        #region Post-processing

        void PostProcess(SceneNode root)
        {
            AdjustFills(root);
        }

        struct HierarchyUpdate
        {
            public SceneNode Parent;
            public SceneNode NewNode;
            public SceneNode ReplaceNode;
        }

        void AdjustFills(SceneNode root)
        {
            var hierarchyUpdates = new List<HierarchyUpdate>();

            // Adjust fills on all objects
            foreach (var nodeInfo in VectorUtils.WorldTransformedSceneNodes(root, nodeOpacity))
            {
                if (nodeInfo.Node.Shapes == null)
                    continue;
                foreach (var shape in nodeInfo.Node.Shapes)
                {
                    if (shape.Fill != null)
                    {
                        // This fill may be a placeholder for postponed reference, try to resolve it here.
                        string reference;
                        if (postponedFills.TryGetValue(shape.Fill, out reference))
                        {
                            var fill = SVGAttribParser.ParseRelativeRef(reference, svgObjects) as IFill;
                            if (fill != null)
                                shape.Fill = fill;
                        }
                    }

                    var stroke = shape.PathProps.Stroke;
                    if (stroke != null && stroke.Fill is GradientFill)
                    {
                        var fillTransform = Matrix2D.identity;
                        AdjustGradientFill(nodeInfo.Node, nodeInfo.WorldTransform, stroke.Fill, shape.Contours, ref fillTransform);
                        stroke.FillTransform = fillTransform;
                    }

                    if (shape.Fill is GradientFill)
                    {
                        var fillTransform = Matrix2D.identity;
                        AdjustGradientFill(nodeInfo.Node, nodeInfo.WorldTransform, shape.Fill, shape.Contours, ref fillTransform);
                        shape.FillTransform = fillTransform;
                    }
                    else if (shape.Fill is PatternFill)
                    {
                        var fillNode = AdjustPatternFill(nodeInfo.Node, nodeInfo.WorldTransform, shape);
                        if (fillNode != null)
                        {
                            hierarchyUpdates.Add(new HierarchyUpdate()
                            {
                                Parent = nodeInfo.Parent,
                                NewNode = fillNode,
                                ReplaceNode = nodeInfo.Node
                            });
                        }
                    }
                }
            }

            foreach (var update in hierarchyUpdates)
            {
                var index = update.Parent.Children.IndexOf(update.ReplaceNode);
                update.Parent.Children.RemoveAt(index);
                update.Parent.Children.Insert(index, update.NewNode);
            }
        }

        void AdjustGradientFill(SceneNode node, Matrix2D worldTransform, IFill fill, BezierContour[] contours, ref Matrix2D computedTransform)
        {
            var gradientFill = fill as GradientFill;
            if (fill == null || contours == null || contours.Length == 0)
                return;

            var min = new Vector2(float.MaxValue, float.MaxValue);
            var max = new Vector2(-float.MaxValue, -float.MaxValue);
            foreach (var contour in contours)
            {
                var bbox = VectorUtils.Bounds(contour.Segments);
                min = Vector2.Min(min, bbox.min);
                max = Vector2.Max(max, bbox.max);
            }

            Rect bounds = new Rect(min, max - min);

            GradientExData extInfo = (GradientExData)gradientExInfo[gradientFill];
            var containerSize = nodeGlobalSceneState[node].ContainerSize;
            Matrix2D gradTransform = Matrix2D.identity;

            currentContainerSize.Push(extInfo.WorldRelative ? containerSize : Vector2.one);

            // If the fill is object relative, then the dimensions will come to us in
            // a normalized space, we must adjust those to the object's dimensions
            if (extInfo is LinearGradientExData)
            {
                // In SVG, linear gradients are expressed using two vectors. A vector and normal. The vector determines
                // the direction where the gradient increases. The normal determines the slant of the gradient along the vector.
                // Due to transformations, it is possible that those two vectors (the gradient vector and its normal) are not
                // actually perpendicular. That's why a skew transformation is involved here.
                // VectorScene just maps linear gradients from 0 to 1 across the entire bounding box width, so we
                // need to figure out a super transformation that takes those simply-mapped UVs and have them express
                // the linear gradient with its slant and all the fun involved.
                var linGradEx = (LinearGradientExData)extInfo;
                Vector2 lineStart = new Vector2(
                        AttribLengthVal(linGradEx.X1, null, null, 0.0f, DimType.Width),
                        AttribLengthVal(linGradEx.Y1, null, null, 0.0f, DimType.Height));
                Vector2 lineEnd = new Vector2(
                        AttribLengthVal(linGradEx.X2, null, null, currentContainerSize.Peek().x, DimType.Width),
                        AttribLengthVal(linGradEx.Y2, null, null, 0.0f, DimType.Height));

                var gradientVector = lineEnd - lineStart;
                float gradientVectorInvLength = 1.0f / gradientVector.magnitude;
                var scale = Matrix2D.Scale(new Vector2(bounds.width * gradientVectorInvLength, bounds.height * gradientVectorInvLength));
                var rotation = Matrix2D.RotateLH(Mathf.Atan2(gradientVector.y, gradientVector.x));
                var offset = Matrix2D.Translate(-lineStart);
                gradTransform = scale * rotation * offset;
            }
            else if (extInfo is RadialGradientExData)
            {
                // VectorScene positions radial gradiants at the center of the bbox, and picks the radii (not one radius, but two)
                // to fill the space between the center and the two edges (horizontal and vertical). So in the general case
                // the radial is actually an ellipsoid. So we need to do an SRT transformation to position the radial gradient according
                // to the SVG center point and radius
                var radGradEx = (RadialGradientExData)extInfo;
                Vector2 halfCurrentContainerSize = currentContainerSize.Peek() * 0.5f;
                Vector2 center = new Vector2(
                        AttribLengthVal(radGradEx.Cx, null, null, halfCurrentContainerSize.x, DimType.Width),
                        AttribLengthVal(radGradEx.Cy, null, null, halfCurrentContainerSize.y, DimType.Height));
                Vector2 focus = new Vector2(
                        AttribLengthVal(radGradEx.Fx, null, null, center.x, DimType.Width),
                        AttribLengthVal(radGradEx.Fy, null, null, center.y, DimType.Height));
                float radius = AttribLengthVal(radGradEx.R, null, null, halfCurrentContainerSize.magnitude / SVGLengthFactor, DimType.Length);

                // This block below tells that radial focus cannot change per object, but is realized correctly for the first object
                // that requests this gradient. If the gradient is using object-relative coordinates to specify the focus location,
                // then only the first object will look correct, and the rest will potentially not look right. The alternative is
                // to detect if it is necessary and generate a new atlas entry for it
                if (!radGradEx.Parsed)
                {
                    // VectorGradientFill radialFocus is (-1,1) relative to the outer circle
                    gradientFill.RadialFocus = (focus - center) / radius;
                    if (gradientFill.RadialFocus.sqrMagnitude > 1.0f - VectorUtils.Epsilon)
                        gradientFill.RadialFocus = gradientFill.RadialFocus.normalized * (1.0f - VectorUtils.Epsilon); // Stick within the unit circle

                    radGradEx.Parsed = true;
                }

                gradTransform =
                    Matrix2D.Scale(bounds.size * 0.5f / radius) *
                    Matrix2D.Translate(new Vector2(radius, radius) - center);
            }
            else
            {
                Debug.LogError("Unsupported gradient type: " + extInfo);
            }

            currentContainerSize.Pop();

            var uvToWorld = extInfo.WorldRelative ? Matrix2D.Translate(bounds.min) * Matrix2D.Scale(bounds.size) : Matrix2D.identity;
            var boundsInv = new Vector2(1.0f / bounds.width, 1.0f / bounds.height);
            computedTransform = Matrix2D.Scale(boundsInv) * gradTransform * extInfo.FillTransform.Inverse() * uvToWorld;
        }

        SceneNode AdjustPatternFill(SceneNode node, Matrix2D worldTransform, Shape shape)
        {
            PatternFill patternFill = shape.Fill as PatternFill;
            if (patternFill == null ||
                Mathf.Abs(patternFill.Rect.width) < VectorUtils.Epsilon ||
                Mathf.Abs(patternFill.Rect.height) < VectorUtils.Epsilon)
            {
                return null;
            }
            
            var data = patternData[patternFill.Pattern];

            var nodeBounds = VectorUtils.SceneNodeBounds(node);
            var patternRect = patternFill.Rect;
            if (!data.WorldRelative)
            {
                patternRect.position *= nodeBounds.size;
                patternRect.size *= nodeBounds.size;
            }

            // The pattern fill will create a new clipped node containing the repeating pattern
            // as well as a sibling containing the original node. This will replace the original node.
            var replacementNode = new SceneNode() {
                Transform = node.Transform,
                Children = new List<SceneNode>(2)
            };
            node.Transform = Matrix2D.identity;

            // The pattern node will be wrapped in a scaling node if content isn't world relative
            var patternNode = patternFill.Pattern;
            if (!data.ContentWorldRelative)
            {
                patternNode = new SceneNode() {
                    Transform = Matrix2D.Scale(nodeBounds.size),
                    Children = new List<SceneNode> { patternFill.Pattern }
                };
            }

            PostProcess(patternNode); // This will take care of adjusting gradients/inner-patterns

            // Duplicate the filling pattern
            var grid = new SceneNode() {
                Transform = data.PatternTransform,
                Children = new List<SceneNode>(20)
            };

            var fill = new SceneNode() {
                Transform = Matrix2D.identity,
                Children = new List<SceneNode> { grid },
                Clipper = node
            };

            // SVG patterns are clipped in their respective "boxes"
            var clippingBox = new Shape();
            VectorUtils.MakeRectangleShape(clippingBox,  new Rect(0,0,patternRect.width, patternRect.height));

            var box = new SceneNode() {
                Transform = Matrix2D.identity,
                Shapes = new List<Shape> { clippingBox }
            };

            // Compute the bounds of the shape to be filled, taking into account the pattern transform
            var bounds = VectorUtils.SceneNodeBounds(node);
            var invPatternTransform = data.PatternTransform.Inverse();
            var boundVerts = new Vector2[] {
                invPatternTransform * new Vector2(bounds.xMin, bounds.yMin),
                invPatternTransform * new Vector2(bounds.xMax, bounds.yMin),
                invPatternTransform * new Vector2(bounds.xMax, bounds.yMax),
                invPatternTransform * new Vector2(bounds.xMin, bounds.yMax)
            };
            bounds = VectorUtils.Bounds(boundVerts);

            const int kMaxReps = 5000;
            float xCount = bounds.xMax / patternRect.width;
            float yCount = bounds.yMax / patternRect.height;
            if (Mathf.Abs(patternRect.width) < VectorUtils.Epsilon ||
                Mathf.Abs(patternRect.height) < VectorUtils.Epsilon ||
                (xCount*yCount) > kMaxReps)
            {
                Debug.LogWarning("Ignoring pattern which would result in too many repetitions");
                return null;
            }

            // Start the pattern filling process
            var offset = patternRect.position;
            float xStart = (int)(bounds.x / patternRect.width) * patternRect.width - patternRect.width;
            float yStart = (int)(bounds.y / patternRect.height) * patternRect.height - patternRect.height;

            for (float y = yStart; y < bounds.yMax; y += patternRect.height)
            {
                for (float x = xStart; x < bounds.xMax; x += patternRect.width)
                {
                    var pattern = new SceneNode() {
                        Transform = Matrix2D.Translate(new Vector2(x, y) + offset),
                        Children = new List<SceneNode> { patternNode },
                        Clipper = box
                    };
                    grid.Children.Add(pattern);
                }
            }

            replacementNode.Children.Add(fill);
            replacementNode.Children.Add(node);

            return replacementNode;
        }

        void RemoveInvisibleNodes()
        {
            foreach (var n in invisibleNodes)
            {
                if (n.parent.Children != null)
                    n.parent.Children.Remove(n.node);
            }
        }

        #endregion

        delegate void ElemHandler();
        class Handlers : Dictionary<string, ElemHandler>
        {
            public Handlers(int capacity) : base(capacity) {}
        }
        bool ShouldDeclareSupportedChildren(XmlReaderIterator.Node node) { return !subTags.ContainsKey(node.Name); }
        void SupportElems(XmlReaderIterator.Node node, params ElemHandler[] handlers)
        {
            var elems = new Handlers(handlers.Length);
            foreach (var h in handlers)
                elems[h.Method.Name] = h;
            subTags[node.Name] = elems;
        }

        static char[] whiteSpaceNumberChars = " \r\n\t,".ToCharArray();
        enum DimType { Width, Height, Length };
        XmlReaderIterator docReader;
        Scene scene;
        float dpiScale;
        int windowWidth, windowHeight;
        Vector2 scenePos, sceneSize;
        SVGDictionary svgObjects = new SVGDictionary(); // Named elements are looked up in this
        Dictionary<string, Handlers> subTags = new Dictionary<string, Handlers>(); // For each element, the set of elements supported as its children
        Dictionary<GradientFill, GradientExData> gradientExInfo = new Dictionary<GradientFill, GradientExData>();
        Dictionary<SceneNode, ViewBoxInfo> symbolViewBoxes = new Dictionary<SceneNode, ViewBoxInfo>();
        Dictionary<SceneNode, NodeGlobalSceneState> nodeGlobalSceneState = new Dictionary<SceneNode, NodeGlobalSceneState>();
        Dictionary<SceneNode, float> nodeOpacity = new Dictionary<SceneNode, float>();
        Dictionary<string, SceneNode> nodeIDs = new Dictionary<string, SceneNode>();
        Dictionary<SceneNode, SVGStyleResolver.StyleLayer> nodeStyleLayers = new Dictionary<SceneNode, SVGStyleResolver.StyleLayer>();
        Dictionary<SceneNode, ClipData> clipData = new Dictionary<SceneNode, ClipData>();
        Dictionary<SceneNode, PatternData> patternData = new Dictionary<SceneNode, PatternData>();
        Dictionary<SceneNode, MaskData> maskData = new Dictionary<SceneNode, MaskData>();
        Dictionary<string, List<NodeReferenceData>> postponedSymbolData = new Dictionary<string, List<NodeReferenceData>>();
        Dictionary<string, List<PostponedStopData>> postponedStopData = new Dictionary<string, List<PostponedStopData>>();
        Dictionary<string, List<PostponedClip>> postponedClip = new Dictionary<string, List<PostponedClip>>();
        SVGPostponedFills postponedFills = new SVGPostponedFills();
        List<NodeWithParent> invisibleNodes = new List<NodeWithParent>();
        Stack<Vector2> currentContainerSize = new Stack<Vector2>();
        Stack<Vector2> currentViewBoxSize = new Stack<Vector2>();
        Stack<SceneNode> currentSceneNode = new Stack<SceneNode>();
        GradientFill currentGradientFill;
        string currentGradientId;
        string currentGradientLink;
        ElemHandler[] allElems;
        HashSet<ElemHandler> elemsToAddToHierarchy;
        SVGStyleResolver styles = new SVGStyleResolver();
        bool applyRootViewBox;

        internal Rect sceneViewport;

        struct NodeGlobalSceneState
        {
            public Vector2 ContainerSize;
        }

        class GradientExData
        {
            public bool WorldRelative;
            public Matrix2D FillTransform;
        }

        class LinearGradientExData : GradientExData
        {
            public string X1, Y1, X2, Y2;
        }

        class RadialGradientExData : GradientExData
        {
            public bool Parsed;
            public string Cx, Cy, Fx, Fy, R;
        }

        struct ClipData
        {
            public bool WorldRelative;
        }

        struct PatternData
        {
            public bool WorldRelative;
            public bool ContentWorldRelative;
            public Matrix2D PatternTransform;
        }

        struct MaskData
        {
            public bool WorldRelative;
            public bool ContentWorldRelative;
        }

        struct NodeWithParent
        {
            public SceneNode node;
            public SceneNode parent;
        }

        struct NodeReferenceData
        {
            public SceneNode node;
            public Rect viewport;
            public string id;
        }

        struct PostponedStopData
        {
            public GradientFill fill;
        }

        struct PostponedClip
        {
            public SceneNode node;
        }
    }

    internal enum Inheritance
    {
        None,
        Inherited
    }

    internal class SVGStyleResolver
    {
        public void PushNode(XmlReaderIterator.Node node)
        {
            var nodeData = new NodeData();
            nodeData.node = node;
            nodeData.name = node.Name;
            var klass = node["class"];
            if (klass != null)
                nodeData.classes = node["class"].Split(' ').Select(x => x.Trim()).ToList();
            else
                nodeData.classes = new List<string>();
            nodeData.classes = SortedClasses(nodeData.classes).ToList();
            nodeData.id = node["id"];

            var layer = new StyleLayer();
            layer.nodeData = nodeData;
            layer.attributeSheet = node.GetAttributes();
            layer.styleSheet = new SVGStyleSheet();

            var cssText = node["style"];
            if (cssText != null)
            {
                var props = SVGStyleSheetUtils.ParseInline(cssText);
                layer.styleSheet[node.Name] = props;
            }

            PushLayer(layer);
        }

        public void PopNode()
        {
            PopLayer();
        }

        public void PushLayer(StyleLayer layer)
        {
            layers.Add(layer);
        }

        public void PopLayer()
        {
            if (layers.Count == 0)
                throw SVGFormatException.StackError;

            layers.RemoveAt(layers.Count - 1);
        }

        public StyleLayer PeekLayer()
        {
            if (layers.Count == 0)
                return null;
            return layers[layers.Count-1];
        }

        public void SaveLayerForSceneNode(SceneNode node)
        {
            nodeLayers[node] = PeekLayer();
        }

        public StyleLayer GetLayerForScenNode(SceneNode node)
        {
            if (!nodeLayers.ContainsKey(node))
                return null;
            return nodeLayers[node];
        }

        public void SetGlobalStyleSheet(SVGStyleSheet sheet)
        {
            foreach (var sel in sheet.selectors)
                globalStyleSheet[sel] = sheet[sel];
        }

        public string Evaluate(string attribName, Inheritance inheritance = Inheritance.None)
        {
            for (int i = layers.Count-1; i >= 0; --i)
            {
                string attrib = null;
                if (LookupStyleOrAttribute(layers[i], attribName, inheritance, out attrib))
                    return attrib;
                
                if (inheritance == Inheritance.None)
                    break;
            }
            return null;
        }

        private bool LookupStyleOrAttribute(StyleLayer layer, string attribName, Inheritance inheritance, out string attrib)
        {
            // Try to match a CSS style first
            if (LookupProperty(layer.nodeData, attribName, layer.styleSheet, out attrib))
                return true;

            // Try to match a global CSS style
            if (LookupProperty(layer.nodeData, attribName, globalStyleSheet, out attrib))
                return true;

            // Else, fallback on attribute
            if (layer.attributeSheet.ContainsKey(attribName))
            {
                attrib = layer.attributeSheet[attribName];
                return true;
            }

            return false;
        }

        private bool LookupProperty(NodeData nodeData, string attribName, SVGStyleSheet sheet, out string val)
        {
            var id = string.IsNullOrEmpty(nodeData.id) ? null : "#" + nodeData.id;
            var name = string.IsNullOrEmpty(nodeData.name) ? null : nodeData.name;

            if (LookupPropertyInSheet(sheet, attribName, id, out val))
                return true;

            foreach (var c in nodeData.classes)
            {
                var klass = "." + c;
                if (LookupPropertyInSheet(sheet, attribName, klass, out val))
                    return true;
            }

            if (LookupPropertyInSheet(sheet, attribName, name, out val))
                return true;

            if (LookupPropertyInSheet(sheet, attribName, "*", out val))
                return true;

            val = null;
            return false;
        }

        private bool LookupPropertyInSheet(SVGStyleSheet sheet, string attribName, string selector, out string val)
        {
            if (selector == null)
            {
                val = null;
                return false;
            }

            if (sheet.selectors.Contains(selector))
            {
                var props = sheet[selector];
                if (props.ContainsKey(attribName))
                {
                    val = props[attribName];
                    return true;
                }
            }

            val = null;
            return false;
        }

        private IEnumerable<string> SortedClasses(List<string> classes)
        {
            // We may not have parsed the global sheets yet (happens when setting a class on the root <svg> element).
            if (globalStyleSheet.selectors.Count() == 0)
            {
                foreach (var klass in classes)
                    yield return klass;
            }

            // We match classes in reverse order of their appearance. This isn't conformant to CSS selectors priority,
            // but this works well enough for auto-generated CSS styles.
            foreach (var sel in globalStyleSheet.selectors.Reverse())
            {
                if (sel[0] != '.')
                    continue;
                var klass = sel.Substring(1);
                if (classes.Contains(klass))
                    yield return klass;
            }
        }

        public struct NodeData
        {
            public XmlReaderIterator.Node node;
            public string name;
            public List<string> classes;
            public string id;
        }

        public class StyleLayer
        {
            public SVGStyleSheet styleSheet;
            public SVGPropertySheet attributeSheet;
            public NodeData nodeData;
        }

        private List<StyleLayer> layers = new List<StyleLayer>();
        private SVGStyleSheet globalStyleSheet = new SVGStyleSheet();
        private Dictionary<SceneNode, StyleLayer> nodeLayers = new Dictionary<SceneNode, StyleLayer>();
    }

    internal class SVGAttribParser
    {
        public static List<BezierContour> ParsePath(XmlReaderIterator.Node node)
        {
            string path = node["d"];
            if (string.IsNullOrEmpty(path))
                return null;

            try
            {
                return (new SVGAttribParser(path, AttribPath.Path)).contours;
            }
            catch (Exception e)
            {
                throw node.GetException(e.Message);
            }
        }

        public static Matrix2D ParseTransform(XmlReaderIterator.Node node)
        {
            return ParseTransform(node, "transform");
        }

        public static Matrix2D ParseTransform(XmlReaderIterator.Node node, string attribName)
        {
            // Transforms aren't part of styling and shouldn't be evaluated,
            // they have to be specified as node attributes
            string transform = node[attribName];
            if (string.IsNullOrEmpty(transform))
                return Matrix2D.identity;
            try
            {
                return (new SVGAttribParser(transform, attribName, AttribTransform.Transform)).transform;
            }
            catch (Exception e)
            {
                throw node.GetException(e.Message);
            }
        }

        public static IFill ParseFill(XmlReaderIterator.Node node, SVGDictionary dict, SVGPostponedFills postponedFills, SVGStyleResolver styles, Inheritance inheritance = Inheritance.Inherited)
        {
            bool isDefaultFill;
            return ParseFill(node, dict, postponedFills, styles, inheritance, out isDefaultFill);
        }

        public static IFill ParseFill(XmlReaderIterator.Node node, SVGDictionary dict, SVGPostponedFills postponedFills, SVGStyleResolver styles, Inheritance inheritance, out bool isDefaultFill)
        {
            string opacityAttrib = styles.Evaluate("fill-opacity", inheritance);
            float opacity = (opacityAttrib != null) ? ParseFloat(opacityAttrib) : 1.0f;
            string fillMode = styles.Evaluate("fill-rule", inheritance);
            FillMode mode = FillMode.NonZero;
            if (fillMode != null)
            {
                if (fillMode == "nonzero")
                    mode = FillMode.NonZero;
                else if (fillMode == "evenodd")
                    mode = FillMode.OddEven;
                else throw new Exception("Unknown fill-rule: " + fillMode);
            }

            try
            {
                var fill = styles.Evaluate("fill", inheritance);
                isDefaultFill = (fill == null && opacityAttrib == null);
                return (new SVGAttribParser(fill, "fill", opacity, mode, dict, postponedFills)).fill;
            }
            catch (Exception e)
            {
                throw node.GetException(e.Message);
            }
        }

        public static Stroke ParseStrokeAndOpacity(XmlReaderIterator.Node node, SVGDictionary dict, SVGStyleResolver styles, Inheritance inheritance = Inheritance.Inherited)
        {
            string strokeAttrib = styles.Evaluate("stroke", inheritance);
            if (string.IsNullOrEmpty(strokeAttrib))
                return null; // If stroke is not specified, no other stroke properties matter

            string opacityAttrib = styles.Evaluate("stroke-opacity", inheritance);
            float opacity = (opacityAttrib != null) ? ParseFloat(opacityAttrib) : 1.0f;

            IFill strokeFill = null;
            try
            {
                strokeFill = (new SVGAttribParser(strokeAttrib, "stroke", opacity, FillMode.NonZero, dict, null)).fill;
            }
            catch (Exception e)
            {
                throw node.GetException(e.Message);
            }

            if (strokeFill == null)
                return null;

            return new Stroke() { Fill = strokeFill };
        }

        public static Color ParseColor(string colorString)
        {
            if (colorString[0] == '#')
            {
                // Hex format
                var hexVal = UInt32.Parse(colorString.Substring(1), NumberStyles.HexNumber);
                if (colorString.Length == 4)
                {
                    // #ABC >> #AABBCC
                    return new Color(
                        ((((hexVal >> 8) & 0xF) << 0) | (((hexVal >> 8) & 0xF) << 4)) / 255.0f,
                        ((((hexVal >> 4) & 0xF) << 0) | (((hexVal >> 4) & 0xF) << 4)) / 255.0f,
                        ((((hexVal >> 0) & 0xF) << 0) | (((hexVal >> 0) & 0xF) << 4)) / 255.0f);
                }
                else
                {
                    // #ABCDEF
                    return new Color(
                        ((hexVal >> 16) & 0xFF) / 255.0f,
                        ((hexVal >> 8) & 0xFF) / 255.0f,
                        ((hexVal >> 0) & 0xFF) / 255.0f);
                }
            }
            if (colorString.StartsWith("rgb(") && colorString.EndsWith(")"))
            {
                string numbersString = colorString.Substring(4, colorString.Length-5);
                string[] numbers = numbersString.Split(new char[] { ',', '%' }, StringSplitOptions.RemoveEmptyEntries);
                if (numbers.Length != 3)
                    throw new Exception("Invalid rgb() color specification");
                float divisor = colorString.Contains("%") ? 100.0f : 255.0f;
                return new Color(Byte.Parse(numbers[0]) / divisor, Byte.Parse(numbers[1]) / divisor, Byte.Parse(numbers[2]) / divisor);
            }
            else if (colorString.StartsWith("rgba(") && colorString.EndsWith(")"))
            {
                string numbersString = colorString.Substring(5, colorString.Length-6);
                string[] numbers = numbersString.Split(new char[] { ',', '%' }, StringSplitOptions.RemoveEmptyEntries);
                if (numbers.Length != 4)
                    throw new Exception("Invalid rgba() color specification");
                float divisor = colorString.Contains("%") ? 100.0f : 255.0f;
                return new Color(
                    Byte.Parse(numbers[0]) / divisor,
                    Byte.Parse(numbers[1]) / divisor,
                    Byte.Parse(numbers[2]) / divisor,
                    divisor == 100.0f ? Byte.Parse(numbers[3]) / divisor : ParseFloat(numbers[3]));
            }

            // Named color
            if (namedColors == null)
                namedColors = new NamedWebColorDictionary();
            return namedColors[colorString.ToLower()];
        }

        public static string ParseURLRef(string url)
        {
            if (url.StartsWith("url(") && url.EndsWith(")"))
                return url.Substring(4, url.Length - 5);
            return null;
        }

        public static object ParseRelativeRef(string iri, SVGDictionary dict)
        {
            if (iri == null)
                return null;

            if (!iri.StartsWith("#"))
                throw new Exception("Unsupported reference type (" + iri + ")");
            iri = iri.Substring(1);
            object obj;
            dict.TryGetValue(iri, out obj);
            return obj;
        }

        public static string CleanIri(string iri)
        {
            if (iri == null)
                return null;
            if (!iri.StartsWith("#"))
                throw new Exception("Unsupported reference type (" + iri + ")");
            iri = iri.Substring(1);
            return iri;
        }

        SVGAttribParser(string attrib, AttribPath attribPath)
        {
            attribName = "path";
            attribString = attrib;
            NextPathCommand(true);
            if (pathCommand != 'm' && pathCommand != 'M')
                throw new Exception("Path must start with a MoveTo pathCommand");

            char lastCmdNoCase = '\0';
            Vector2 lastQCtrlPoint = Vector2.zero;

            while (NextPathCommand() != (char)0)
            {
                bool relative = (pathCommand >= 'a') && (pathCommand <= 'z');
                char cmdNoCase = char.ToLower(pathCommand);
                if (cmdNoCase == 'm') // Move-to
                {
                    penPos = NextVector2(relative);
                    pathCommand = relative ? 'l' : 'L'; // After a move-to, we automatically switch to a line-to of the same relativity
                    ConcludePath(false);
                }
                else if (cmdNoCase == 'z') // ClosePath
                {
                    if (currentContour.First != null)
                        penPos = currentContour.First.Value.P0;
                    ConcludePath(true);
                }
                else if (cmdNoCase == 'l') // Line-to
                {
                    var to = NextVector2(relative);
                    if ((to - penPos).magnitude > VectorUtils.Epsilon)
                        currentContour.AddLast(VectorUtils.MakeLine(penPos, to));
                    penPos = to;
                }
                else if (cmdNoCase == 'h') // Horizontal-line-to
                {
                    float x = relative ? penPos.x + NextFloat() : NextFloat();
                    var to = new Vector2(x, penPos.y);
                    if ((to - penPos).magnitude > VectorUtils.Epsilon)
                        currentContour.AddLast(VectorUtils.MakeLine(penPos, to));
                    penPos = to;
                }
                else if (cmdNoCase == 'v') // Vertical-line-to
                {
                    float y = relative ? penPos.y + NextFloat() : NextFloat();
                    var to = new Vector2(penPos.x, y);
                    if ((to - penPos).magnitude > VectorUtils.Epsilon)
                        currentContour.AddLast(VectorUtils.MakeLine(penPos, to));
                    penPos = to;
                }
                else if (cmdNoCase == 'c' || cmdNoCase == 'q') // Cubic-bezier-curve or quadratic-bezier-curve
                {
                    // If relative, the pen position is on P0 and is only moved to P3
                    BezierSegment bs = new BezierSegment();
                    bs.P0 = penPos;
                    bs.P1 = NextVector2(relative);
                    if (cmdNoCase == 'c')
                        bs.P2 = NextVector2(relative);
                    bs.P3 = NextVector2(relative);

                    if (cmdNoCase == 'q')
                    {
                        lastQCtrlPoint = bs.P1;
                        var t = 2.0f/3.0f;
                        bs.P1 = bs.P0 + t * (lastQCtrlPoint - bs.P0);
                        bs.P2 = bs.P3 + t * (lastQCtrlPoint - bs.P3);
                    }

                    penPos = bs.P3;

                    if (!VectorUtils.IsEmptySegment(bs))
                        currentContour.AddLast(bs);
                }
                else if (cmdNoCase == 's' || cmdNoCase == 't') // Smooth cubic-bezier-curve or smooth quadratic-bezier-curve
                {
                    Vector2 reflectedP1 = penPos;
                    if (currentContour.Count > 0 && (lastCmdNoCase == 'c' || lastCmdNoCase == 'q' || lastCmdNoCase == 's' || lastCmdNoCase == 't'))
                        reflectedP1 += currentContour.Last.Value.P3 - ((lastCmdNoCase == 'q' || lastCmdNoCase == 't') ? lastQCtrlPoint : currentContour.Last.Value.P2);

                    // If relative, the pen position is on P0 and is only moved to P3
                    BezierSegment bs = new BezierSegment();
                    bs.P0 = penPos;
                    bs.P1 = reflectedP1;
                    if (cmdNoCase == 's')
                        bs.P2 = NextVector2(relative);
                    bs.P3 = NextVector2(relative);

                    if (cmdNoCase == 't')
                    {
                        lastQCtrlPoint = bs.P1;
                        var t = 2.0f / 3.0f;
                        bs.P1 = bs.P0 + t * (lastQCtrlPoint - bs.P0);
                        bs.P2 = bs.P3 + t * (lastQCtrlPoint - bs.P3);
                    }

                    penPos = bs.P3;

                    if (!VectorUtils.IsEmptySegment(bs))
                        currentContour.AddLast(bs);
                }
                else if (cmdNoCase == 'a') // Elliptical-arc-to
                {
                    Vector2 radii = NextVector2();
                    float xAxisRotation = NextFloat();
                    bool largeArcFlag = NextBool();
                    bool sweepFlag = NextBool();
                    Vector2 to = NextVector2(relative);

                    if (radii.magnitude <= VectorUtils.Epsilon)
                    {
                        if ((to - penPos).magnitude > VectorUtils.Epsilon)
                            currentContour.AddLast(VectorUtils.MakeLine(penPos, to));
                    }
                    else
                    {
                        var ellipsePath = VectorUtils.BuildEllipsePath(penPos, to, -xAxisRotation * Mathf.Deg2Rad, radii.x, radii.y, largeArcFlag, sweepFlag);
                        foreach (var seg in VectorUtils.SegmentsInPath(ellipsePath))
                            currentContour.AddLast(seg);
                    }

                    penPos = to;
                }

                lastCmdNoCase = cmdNoCase;

            } // While commands exist in the string

            ConcludePath(false);
        }

        SVGAttribParser(string attrib, string attribNameVal, AttribTransform attribTransform)
        {
            attribString = attrib;
            attribName = attribNameVal;
            transform = Matrix2D.identity;
            while (stringPos < attribString.Length)
            {
                int cmdPos = stringPos;
                var trasformCommand = NextStringCommand();
                if (string.IsNullOrEmpty(trasformCommand))
                    return;
                SkipSymbol('(');

                if (trasformCommand == "matrix")
                {
                    Matrix2D mat = new Matrix2D();
                    mat.m00 = NextFloat();
                    mat.m10 = NextFloat();
                    mat.m01 = NextFloat();
                    mat.m11 = NextFloat();
                    mat.m02 = NextFloat();
                    mat.m12 = NextFloat();
                    transform *= mat;
                }
                else if (trasformCommand == "translate")
                {
                    float x = NextFloat();
                    float y = 0;
                    if (!PeekSymbol(')'))
                        y = NextFloat();
                    transform *= Matrix2D.Translate(new Vector2(x, y));
                }
                else if (trasformCommand == "scale")
                {
                    float x = NextFloat();
                    float y = x;
                    if (!PeekSymbol(')'))
                        y = NextFloat();
                    transform *= Matrix2D.Scale(new Vector2(x, y));
                }
                else if (trasformCommand == "rotate")
                {
                    float a = NextFloat() * Mathf.Deg2Rad;
                    float cx = 0, cy = 0;
                    if (!PeekSymbol(')'))
                    {
                        cx = NextFloat();
                        cy = NextFloat();
                    }
                    transform *= Matrix2D.Translate(new Vector2(cx, cy)) * Matrix2D.RotateLH(-a) * Matrix2D.Translate(new Vector2(-cx, -cy));
                }
                else if ((trasformCommand == "skewX") || (trasformCommand == "skewY"))
                {
                    float a = Mathf.Tan(NextFloat() * Mathf.Deg2Rad);
                    Matrix2D mat = Matrix2D.identity;
                    if (trasformCommand == "skewY")
                        mat.m10 = a;
                    else mat.m01 = a;
                    transform *= mat;
                }
                else throw new Exception("Unknown transform command at " + cmdPos + " in trasform specification");

                SkipSymbol(')');
            }
        }

        SVGAttribParser(string attrib, string attribName, float opacity, FillMode mode, SVGDictionary dict, SVGPostponedFills postponedFills, bool allowReference = true)
        {
            this.attribName = attribName;
            if (string.IsNullOrEmpty(attrib))
            {
                if (opacity < 1.0f)
                    fill = new SolidFill() { Color = new Color(0, 0, 0, opacity) };
                else
                    fill = dict[mode == FillMode.NonZero ?
                                SVGDocument.StockBlackNonZeroFillName :
                                SVGDocument.StockBlackOddEvenFillName] as IFill;
                return;
            }

            if (attrib == "none" || attrib == "transparent")
                return;

            if (attrib == "currentColor")
            {
                Debug.LogError("currentColor is not supported as a " + attribName + " value");
                return;
            }

            string[] paintParts = attrib.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            if (allowReference)
            {
                string reference = ParseURLRef(paintParts[0]);
                if (reference != null)
                {
                    fill = ParseRelativeRef(reference, dict) as IFill;
                    if (fill == null)
                    {
                        if (paintParts.Length > 1)
                        {
                            fill = (new SVGAttribParser(paintParts[1], attribName, opacity, mode, dict, postponedFills, false)).fill;
                        }
                        else if (postponedFills != null)
                        {
                            // The reference doesn't exist, but may be defined later in the file.
                            // Make a dummy fill to be replaced later.
                            fill = new SolidFill() { Color = Color.clear };
                            postponedFills[fill] = reference;
                        }
                    }

                    if (fill != null)
                        fill.Opacity = opacity;
    
                    return;
                }
            }

            var clr = ParseColor(string.Join("", paintParts));
            clr.a *= opacity;
            if (paintParts.Length > 1)
            {
                // TODO: Support ICC-Color
            }
            fill = new SolidFill() { Color = clr, Mode = mode };
        }

        void ConcludePath(bool joinEnds)
        {
            // No need to manually close the path with the last line. It is implied.
            //if (joinEnds && currentPath.Count >= 2)
            //{
            //    BezierSegment bs = new BezierSegment();
            //    bs.MakeLine(currentPath.Last.Value.P3, currentPath.First.Value.P0);
            //    currentPath.AddLast(bs);
            //}
            if (currentContour.Count > 0)
            {
                BezierContour contour = new BezierContour();
                contour.Closed = joinEnds && (currentContour.Count >= 1);
                contour.Segments = new BezierPathSegment[currentContour.Count + 1];
                int index = 0;
                foreach (var bs in currentContour)
                    contour.Segments[index++] = new BezierPathSegment() { P0 = bs.P0, P1 = bs.P1, P2 = bs.P2  };
                var connect = VectorUtils.MakeLine(currentContour.Last.Value.P3, contour.Segments[0].P0);
                contour.Segments[index] = new BezierPathSegment() { P0 = connect.P0, P1 = connect.P1, P2 = connect.P2 };
                contours.Add(contour);
            }
            currentContour.Clear(); // Restart a new path
        }

        Vector2 NextVector2(bool relative = false)
        {
            var v = new Vector2(NextFloat(), NextFloat());
            return relative ? v + penPos : v;
        }

        float NextFloat()
        {
            SkipWhitespaces();
            if (stringPos >= attribString.Length)
                throw new Exception(attribName + " specification ended before sufficing numbers required by the last pathCommand");

            int startPos = stringPos;
            if (attribString[stringPos] == '-')
                stringPos++; // Skip over the negative sign if it exists

            bool gotPeriod = false;
            bool gotE = false;
            while (stringPos < attribString.Length)
            {
                char c = attribString[stringPos];
                if (!gotPeriod && (c == '.'))
                {
                    gotPeriod = true;
                    stringPos++;
                    continue;
                }
                if (!gotE && ((c == 'e') || (c == 'E')))
                {
                    gotE = true;
                    stringPos++;
                    if ((stringPos < attribString.Length) && (attribString[stringPos] == '-'))
                        stringPos++; // Skip over the negative sign if it exists for the e
                    continue;
                }
                if (!char.IsDigit(c))
                    break;
                stringPos++;
            }

            if ((stringPos - startPos == 0) ||
                ((stringPos - startPos == 1) && attribString[startPos] == '-'))
                throw new Exception("Missing number at " + startPos + " in " + attribName + " specification");

            return ParseFloat(attribString.Substring(startPos, stringPos - startPos));
        }

        internal static float ParseFloat(string s)
        {
            return float.Parse(s, NumberStyles.Number | NumberStyles.AllowExponent, CultureInfo.InvariantCulture);
        }

        bool NextBool()
        {
            return Mathf.Abs(NextFloat()) > VectorUtils.Epsilon;
        }

        char NextPathCommand(bool noCommandInheritance = false)
        {
            SkipWhitespaces();
            if (stringPos >= attribString.Length)
                return (char)0;

            char newCmd = attribString[stringPos];
            if ((newCmd >= 'a' && newCmd <= 'z') || (newCmd >= 'A' && newCmd <= 'Z'))
            {
                pathCommand = newCmd;
                stringPos++;
                return newCmd;
            }

            if (!noCommandInheritance && (char.IsDigit(newCmd) || (newCmd == '.') || (newCmd == '-')))
                return pathCommand; // Stepped onto a number, which means we keep the last pathCommand
            throw new Exception("Unexpected character at " + stringPos + " in path specification");
        }

        string NextStringCommand()
        {
            SkipWhitespaces();
            if (stringPos >= attribString.Length)
                return null;

            int startPos = stringPos;
            while (stringPos < attribString.Length)
            {
                char c = attribString[stringPos];
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
                    stringPos++;
                else break;
            }

            if (stringPos - startPos == 0)
                throw new Exception("Unexpected character at " + stringPos + " in " + attribName + " specification");

            return attribString.Substring(startPos, stringPos - startPos);
        }

        void SkipSymbol(char s)
        {
            SkipWhitespaces();
            if (stringPos >= attribString.Length || (attribString[stringPos] != s))
                throw new Exception("Expected " + s + " at " + stringPos + " of " + attribName + " specification");
            stringPos++;
        }

        bool PeekSymbol(char s)
        {
            SkipWhitespaces();
            return (stringPos < attribString.Length) && (attribString[stringPos] == s);
        }

        void SkipWhitespaces()
        {
            while (stringPos < attribString.Length)
            {
                switch (attribString[stringPos])
                {
                    case ' ':
                    case '\r':
                    case '\n':
                    case '\t':
                    case ',':
                        stringPos++;
                        break;
                    default:
                        return;
                }
            }
        }

        enum AttribPath { Path };
        enum AttribTransform { Transform };
        enum AttribStroke { Stroke };

        // Path data
        LinkedList<BezierSegment> currentContour = new LinkedList<BezierSegment>();
        List<BezierContour> contours = new List<BezierContour>();
        Vector2 penPos;
        string attribString;
        char pathCommand;

        // Transform data
        Matrix2D transform;

        // Fill data
        IFill fill;

        // Parsing data
        string attribName;
        int stringPos;

        static NamedWebColorDictionary namedColors;
    }

    class NamedWebColorDictionary : Dictionary<string, Color>
    {
        public NamedWebColorDictionary()
        {
            this["aliceblue"] = new Color(240.0f / 255.0f, 248.0f / 255.0f, 255.0f / 255.0f);
            this["antiquewhite"] = new Color(250.0f / 255.0f, 235.0f / 255.0f, 215.0f / 255.0f);
            this["aqua"] = new Color(0.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f);
            this["aquamarine"] = new Color(127.0f / 255.0f, 255.0f / 255.0f, 212.0f / 255.0f);
            this["azure"] = new Color(240.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f);
            this["beige"] = new Color(245.0f / 255.0f, 245.0f / 255.0f, 220.0f / 255.0f);
            this["bisque"] = new Color(255.0f / 255.0f, 228.0f / 255.0f, 196.0f / 255.0f);
            this["black"] = new Color(0.0f / 255.0f, 0.0f / 255.0f, 0.0f / 255.0f);
            this["blanchedalmond"] = new Color(255.0f / 255.0f, 235.0f / 255.0f, 205.0f / 255.0f);
            this["blue"] = new Color(0.0f / 255.0f, 0.0f / 255.0f, 255.0f / 255.0f);
            this["blueviolet"] = new Color(138.0f / 255.0f, 43.0f / 255.0f, 226.0f / 255.0f);
            this["brown"] = new Color(165.0f / 255.0f, 42.0f / 255.0f, 42.0f / 255.0f);
            this["burlywood"] = new Color(222.0f / 255.0f, 184.0f / 255.0f, 135.0f / 255.0f);
            this["cadetblue"] = new Color(95.0f / 255.0f, 158.0f / 255.0f, 160.0f / 255.0f);
            this["chartreuse"] = new Color(127.0f / 255.0f, 255.0f / 255.0f, 0.0f / 255.0f);
            this["chocolate"] = new Color(210.0f / 255.0f, 105.0f / 255.0f, 30.0f / 255.0f);
            this["coral"] = new Color(255.0f / 255.0f, 127.0f / 255.0f, 80.0f / 255.0f);
            this["cornflowerblue"] = new Color(100.0f / 255.0f, 149.0f / 255.0f, 237.0f / 255.0f);
            this["cornsilk"] = new Color(255.0f / 255.0f, 248.0f / 255.0f, 220.0f / 255.0f);
            this["crimson"] = new Color(220.0f / 255.0f, 20.0f / 255.0f, 60.0f / 255.0f);
            this["cyan"] = new Color(0.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f);
            this["darkblue"] = new Color(0.0f / 255.0f, 0.0f / 255.0f, 139.0f / 255.0f);
            this["darkcyan"] = new Color(0.0f / 255.0f, 139.0f / 255.0f, 139.0f / 255.0f);
            this["darkgoldenrod"] = new Color(184.0f / 255.0f, 134.0f / 255.0f, 11.0f / 255.0f);
            this["darkgray"] = new Color(169.0f / 255.0f, 169.0f / 255.0f, 169.0f / 255.0f);
            this["darkgrey"] = new Color(169.0f / 255.0f, 169.0f / 255.0f, 169.0f / 255.0f);
            this["darkgreen"] = new Color(0.0f / 255.0f, 100.0f / 255.0f, 0.0f / 255.0f);
            this["darkkhaki"] = new Color(189.0f / 255.0f, 183.0f / 255.0f, 107.0f / 255.0f);
            this["darkmagenta"] = new Color(139.0f / 255.0f, 0.0f / 255.0f, 139.0f / 255.0f);
            this["darkolivegreen"] = new Color(85.0f / 255.0f, 107.0f / 255.0f, 47.0f / 255.0f);
            this["darkorange"] = new Color(255.0f / 255.0f, 140.0f / 255.0f, 0.0f / 255.0f);
            this["darkorchid"] = new Color(153.0f / 255.0f, 50.0f / 255.0f, 204.0f / 255.0f);
            this["darkred"] = new Color(139.0f / 255.0f, 0.0f / 255.0f, 0.0f / 255.0f);
            this["darksalmon"] = new Color(233.0f / 255.0f, 150.0f / 255.0f, 122.0f / 255.0f);
            this["darkseagreen"] = new Color(143.0f / 255.0f, 188.0f / 255.0f, 143.0f / 255.0f);
            this["darkslateblue"] = new Color(72.0f / 255.0f, 61.0f / 255.0f, 139.0f / 255.0f);
            this["darkslategray"] = new Color(47.0f / 255.0f, 79.0f / 255.0f, 79.0f / 255.0f);
            this["darkslategrey"] = new Color(47.0f / 255.0f, 79.0f / 255.0f, 79.0f / 255.0f);
            this["darkturquoise"] = new Color(0.0f / 255.0f, 206.0f / 255.0f, 209.0f / 255.0f);
            this["darkviolet"] = new Color(148.0f / 255.0f, 0.0f / 255.0f, 211.0f / 255.0f);
            this["deeppink"] = new Color(255.0f / 255.0f, 20.0f / 255.0f, 147.0f / 255.0f);
            this["deepskyblue"] = new Color(0.0f / 255.0f, 191.0f / 255.0f, 255.0f / 255.0f);
            this["dimgray"] = new Color(105.0f / 255.0f, 105.0f / 255.0f, 105.0f / 255.0f);
            this["dimgrey"] = new Color(105.0f / 255.0f, 105.0f / 255.0f, 105.0f / 255.0f);
            this["dodgerblue"] = new Color(30.0f / 255.0f, 144.0f / 255.0f, 255.0f / 255.0f);
            this["firebrick"] = new Color(178.0f / 255.0f, 34.0f / 255.0f, 34.0f / 255.0f);
            this["floralwhite"] = new Color(255.0f / 255.0f, 250.0f / 255.0f, 240.0f / 255.0f);
            this["forestgreen"] = new Color(34.0f / 255.0f, 139.0f / 255.0f, 34.0f / 255.0f);
            this["fuchsia"] = new Color(255.0f / 255.0f, 0.0f / 255.0f, 255.0f / 255.0f);
            this["gainsboro"] = new Color(220.0f / 255.0f, 220.0f / 255.0f, 220.0f / 255.0f);
            this["ghostwhite"] = new Color(248.0f / 255.0f, 248.0f / 255.0f, 255.0f / 255.0f);
            this["gold"] = new Color(255.0f / 255.0f, 215.0f / 255.0f, 0.0f / 255.0f);
            this["goldenrod"] = new Color(218.0f / 255.0f, 165.0f / 255.0f, 32.0f / 255.0f);
            this["gray"] = new Color(128.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f);
            this["grey"] = new Color(128.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f);
            this["green"] = new Color(0.0f / 255.0f, 128.0f / 255.0f, 0.0f / 255.0f);
            this["greenyellow"] = new Color(173.0f / 255.0f, 255.0f / 255.0f, 47.0f / 255.0f);
            this["honeydew"] = new Color(240.0f / 255.0f, 255.0f / 255.0f, 240.0f / 255.0f);
            this["hotpink"] = new Color(255.0f / 255.0f, 105.0f / 255.0f, 180.0f / 255.0f);
            this["indianred"] = new Color(205.0f / 255.0f, 92.0f / 255.0f, 92.0f / 255.0f);
            this["indigo"] = new Color(75.0f / 255.0f, 0.0f / 255.0f, 130.0f / 255.0f);
            this["ivory"] = new Color(255.0f / 255.0f, 255.0f / 255.0f, 240.0f / 255.0f);
            this["khaki"] = new Color(240.0f / 255.0f, 230.0f / 255.0f, 140.0f / 255.0f);
            this["lavender"] = new Color(230.0f / 255.0f, 230.0f / 255.0f, 250.0f / 255.0f);
            this["lavenderblush"] = new Color(255.0f / 255.0f, 240.0f / 255.0f, 245.0f / 255.0f);
            this["lawngreen"] = new Color(124.0f / 255.0f, 252.0f / 255.0f, 0.0f / 255.0f);
            this["lemonchiffon"] = new Color(255.0f / 255.0f, 250.0f / 255.0f, 205.0f / 255.0f);
            this["lightblue"] = new Color(173.0f / 255.0f, 216.0f / 255.0f, 230.0f / 255.0f);
            this["lightcoral"] = new Color(240.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f);
            this["lightcyan"] = new Color(224.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f);
            this["lightgoldenrodyellow"] = new Color(250.0f / 255.0f, 250.0f / 255.0f, 210.0f / 255.0f);
            this["lightgray"] = new Color(211.0f / 255.0f, 211.0f / 255.0f, 211.0f / 255.0f);
            this["lightgrey"] = new Color(211.0f / 255.0f, 211.0f / 255.0f, 211.0f / 255.0f);
            this["lightgreen"] = new Color(144.0f / 255.0f, 238.0f / 255.0f, 144.0f / 255.0f);
            this["lightpink"] = new Color(255.0f / 255.0f, 182.0f / 255.0f, 193.0f / 255.0f);
            this["lightsalmon"] = new Color(255.0f / 255.0f, 160.0f / 255.0f, 122.0f / 255.0f);
            this["lightseagreen"] = new Color(32.0f / 255.0f, 178.0f / 255.0f, 170.0f / 255.0f);
            this["lightskyblue"] = new Color(135.0f / 255.0f, 206.0f / 255.0f, 250.0f / 255.0f);
            this["lightslategray"] = new Color(119.0f / 255.0f, 136.0f / 255.0f, 153.0f / 255.0f);
            this["lightslategrey"] = new Color(119.0f / 255.0f, 136.0f / 255.0f, 153.0f / 255.0f);
            this["lightsteelblue"] = new Color(176.0f / 255.0f, 196.0f / 255.0f, 222.0f / 255.0f);
            this["lightyellow"] = new Color(255.0f / 255.0f, 255.0f / 255.0f, 224.0f / 255.0f);
            this["lime"] = new Color(0.0f / 255.0f, 255.0f / 255.0f, 0.0f / 255.0f);
            this["limegreen"] = new Color(50.0f / 255.0f, 205.0f / 255.0f, 50.0f / 255.0f);
            this["linen"] = new Color(250.0f / 255.0f, 240.0f / 255.0f, 230.0f / 255.0f);
            this["magenta"] = new Color(255.0f / 255.0f, 0.0f / 255.0f, 255.0f / 255.0f);
            this["maroon"] = new Color(128.0f / 255.0f, 0.0f / 255.0f, 0.0f / 255.0f);
            this["mediumaquamarine"] = new Color(102.0f / 255.0f, 205.0f / 255.0f, 170.0f / 255.0f);
            this["mediumblue"] = new Color(0.0f / 255.0f, 0.0f / 255.0f, 205.0f / 255.0f);
            this["mediumorchid"] = new Color(186.0f / 255.0f, 85.0f / 255.0f, 211.0f / 255.0f);
            this["mediumpurple"] = new Color(147.0f / 255.0f, 112.0f / 255.0f, 219.0f / 255.0f);
            this["mediumseagreen"] = new Color(60.0f / 255.0f, 179.0f / 255.0f, 113.0f / 255.0f);
            this["mediumslateblue"] = new Color(123.0f / 255.0f, 104.0f / 255.0f, 238.0f / 255.0f);
            this["mediumspringgreen"] = new Color(0.0f / 255.0f, 250.0f / 255.0f, 154.0f / 255.0f);
            this["mediumturquoise"] = new Color(72.0f / 255.0f, 209.0f / 255.0f, 204.0f / 255.0f);
            this["mediumvioletred"] = new Color(199.0f / 255.0f, 21.0f / 255.0f, 133.0f / 255.0f);
            this["midnightblue"] = new Color(25.0f / 255.0f, 25.0f / 255.0f, 112.0f / 255.0f);
            this["mintcream"] = new Color(245.0f / 255.0f, 255.0f / 255.0f, 250.0f / 255.0f);
            this["mistyrose"] = new Color(255.0f / 255.0f, 228.0f / 255.0f, 225.0f / 255.0f);
            this["moccasin"] = new Color(255.0f / 255.0f, 228.0f / 255.0f, 181.0f / 255.0f);
            this["navajowhite"] = new Color(255.0f / 255.0f, 222.0f / 255.0f, 173.0f / 255.0f);
            this["navy"] = new Color(0.0f / 255.0f, 0.0f / 255.0f, 128.0f / 255.0f);
            this["oldlace"] = new Color(253.0f / 255.0f, 245.0f / 255.0f, 230.0f / 255.0f);
            this["olive"] = new Color(128.0f / 255.0f, 128.0f / 255.0f, 0.0f / 255.0f);
            this["olivedrab"] = new Color(107.0f / 255.0f, 142.0f / 255.0f, 35.0f / 255.0f);
            this["orange"] = new Color(255.0f / 255.0f, 165.0f / 255.0f, 0.0f / 255.0f);
            this["orangered"] = new Color(255.0f / 255.0f, 69.0f / 255.0f, 0.0f / 255.0f);
            this["orchid"] = new Color(218.0f / 255.0f, 112.0f / 255.0f, 214.0f / 255.0f);
            this["palegoldenrod"] = new Color(238.0f / 255.0f, 232.0f / 255.0f, 170.0f / 255.0f);
            this["palegreen"] = new Color(152.0f / 255.0f, 251.0f / 255.0f, 152.0f / 255.0f);
            this["paleturquoise"] = new Color(175.0f / 255.0f, 238.0f / 255.0f, 238.0f / 255.0f);
            this["palevioletred"] = new Color(219.0f / 255.0f, 112.0f / 255.0f, 147.0f / 255.0f);
            this["papayawhip"] = new Color(255.0f / 255.0f, 239.0f / 255.0f, 213.0f / 255.0f);
            this["peachpuff"] = new Color(255.0f / 255.0f, 218.0f / 255.0f, 185.0f / 255.0f);
            this["peru"] = new Color(205.0f / 255.0f, 133.0f / 255.0f, 63.0f / 255.0f);
            this["pink"] = new Color(255.0f / 255.0f, 192.0f / 255.0f, 203.0f / 255.0f);
            this["plum"] = new Color(221.0f / 255.0f, 160.0f / 255.0f, 221.0f / 255.0f);
            this["powderblue"] = new Color(176.0f / 255.0f, 224.0f / 255.0f, 230.0f / 255.0f);
            this["purple"] = new Color(128.0f / 255.0f, 0.0f / 255.0f, 128.0f / 255.0f);
            this["rebeccapurple"] = new Color(102.0f / 255.0f, 51.0f / 255.0f, 153.0f / 255.0f);
            this["red"] = new Color(255.0f / 255.0f, 0.0f / 255.0f, 0.0f / 255.0f);
            this["rosybrown"] = new Color(188.0f / 255.0f, 143.0f / 255.0f, 143.0f / 255.0f);
            this["royalblue"] = new Color(65.0f / 255.0f, 105.0f / 255.0f, 225.0f / 255.0f);
            this["saddlebrown"] = new Color(139.0f / 255.0f, 69.0f / 255.0f, 19.0f / 255.0f);
            this["salmon"] = new Color(250.0f / 255.0f, 128.0f / 255.0f, 114.0f / 255.0f);
            this["sandybrown"] = new Color(244.0f / 255.0f, 164.0f / 255.0f, 96.0f / 255.0f);
            this["seagreen"] = new Color(46.0f / 255.0f, 139.0f / 255.0f, 87.0f / 255.0f);
            this["seashell"] = new Color(255.0f / 255.0f, 245.0f / 255.0f, 238.0f / 255.0f);
            this["sienna"] = new Color(160.0f / 255.0f, 82.0f / 255.0f, 45.0f / 255.0f);
            this["silver"] = new Color(192.0f / 255.0f, 192.0f / 255.0f, 192.0f / 255.0f);
            this["skyblue"] = new Color(135.0f / 255.0f, 206.0f / 255.0f, 235.0f / 255.0f);
            this["slateblue"] = new Color(106.0f / 255.0f, 90.0f / 255.0f, 205.0f / 255.0f);
            this["slategray"] = new Color(112.0f / 255.0f, 128.0f / 255.0f, 144.0f / 255.0f);
            this["slategrey"] = new Color(112.0f / 255.0f, 128.0f / 255.0f, 144.0f / 255.0f);
            this["snow"] = new Color(255.0f / 255.0f, 250.0f / 255.0f, 250.0f / 255.0f);
            this["springgreen"] = new Color(0.0f / 255.0f, 255.0f / 255.0f, 127.0f / 255.0f);
            this["steelblue"] = new Color(70.0f / 255.0f, 130.0f / 255.0f, 180.0f / 255.0f);
            this["tan"] = new Color(210.0f / 255.0f, 180.0f / 255.0f, 140.0f / 255.0f);
            this["teal"] = new Color(0.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f);
            this["thistle"] = new Color(216.0f / 255.0f, 191.0f / 255.0f, 216.0f / 255.0f);
            this["tomato"] = new Color(255.0f / 255.0f, 99.0f / 255.0f, 71.0f / 255.0f);
            this["turquoise"] = new Color(64.0f / 255.0f, 224.0f / 255.0f, 208.0f / 255.0f);
            this["violet"] = new Color(238.0f / 255.0f, 130.0f / 255.0f, 238.0f / 255.0f);
            this["wheat"] = new Color(245.0f / 255.0f, 222.0f / 255.0f, 179.0f / 255.0f);
            this["white"] = new Color(255.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f);
            this["whitesmoke"] = new Color(245.0f / 255.0f, 245.0f / 255.0f, 245.0f / 255.0f);
            this["yellow"] = new Color(255.0f / 255.0f, 255.0f / 255.0f, 0.0f / 255.0f);
            this["yellowgreen"] = new Color(154.0f / 255.0f, 205.0f / 255.0f, 50.0f / 255.0f);
        }
    } // The boring NamedWebColorDictionary class
} // namespace
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/SVGParser.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/SVGStyleSheet.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ad42887d8ca6e094093524d976e32104
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Linq;
using UnityEngine;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    internal class SVGPropertySheet : Dictionary<string, string> { }

    internal class SVGStyleSheet
    {
        private List<KeyValuePair<string, SVGPropertySheet>> m_Selectors = new List<KeyValuePair<string, SVGPropertySheet>>();

        public SVGPropertySheet this[string key]
        {
            get
            {
                int i = m_Selectors.FindIndex(x => x.Key == key);
                if (i != -1)
                    return m_Selectors[i].Value;
                return null;
            }
            set
            {
                var v = new KeyValuePair<string, SVGPropertySheet>(key, value);
                int i = m_Selectors.FindIndex(x => x.Key == key);
                if (i != -1)
                    m_Selectors[i] = v;
                m_Selectors.Add(v);
            }
        }

        public IEnumerable<string> selectors
        {
            get { return m_Selectors.Select(x => x.Key); }
        }

        public int Count
        {
            get { return m_Selectors.Count; }
        }

        public void Clear()
        {
            m_Selectors.Clear();
        }
    };

    internal static class SVGStyleSheetUtils
    {
        public static SVGStyleSheet Parse(string cssText)
        {
            var result = new SVGStyleSheet();
            var tokens = Tokenize(cssText);

            var sheet = new SVGStyleSheet();
            while (ParseSelector(tokens, sheet))
            {
                foreach (var sel in sheet.selectors)
                {
                    if (result.selectors.Contains(sel))
                        CombineProperties(result[sel], sheet[sel]);
                    else
                        result[sel] = sheet[sel];
                }
                sheet.Clear();
            }

            return result;
        }

        public static SVGPropertySheet ParseInline(string cssText)
        {
            var tokens = Tokenize(cssText);
            var props = new SVGPropertySheet();
            ParseProperties(tokens, props);
            return props;
        }

        private static bool ParseSelector(List<string> tokens, SVGStyleSheet sheet)
        {
            if (tokens.Count == 0)
                return false;

            var newSheet = new SVGStyleSheet();
            while (true)
            {
                var selectorName = PopToken(tokens);
                newSheet[selectorName] = new SVGPropertySheet();

                while (PeekToken(tokens) == ",")
                    PopToken(tokens);
                
                if (PeekToken(tokens) == "" || PeekToken(tokens) == "{")
                    break;
            }

            var sep = PopToken(tokens);
            if (sep != "{")
            {
                Debug.LogError("Invalid CSS selector opening bracket: \"" + sep + "\"");
                return false;
            }

            var props = new SVGPropertySheet();
            ParseProperties(tokens, props);

            // Transfer properties to the new selectors
            foreach (var key in newSheet.selectors)
                sheet[key] = CopyProperties(props);
            
            sep = PopToken(tokens);
            if (sep != "}")
            {
                Debug.LogError("Invalid CSS selector closing bracket: \"" + sep + "\"");
                return false;
            }
            
            return true;
        }

        private static void CombineProperties(SVGPropertySheet first, SVGPropertySheet second)
        {
            foreach (var key in second.Keys)
                first[key] = second[key];
        }

        private static SVGPropertySheet CopyProperties(SVGPropertySheet props)
        {
            var newProps = new SVGPropertySheet();
            foreach (var v in props)
                newProps[v.Key] = v.Value;
            return newProps;
        }

        private static bool ParseProperties(List<string> tokens, SVGPropertySheet props)
        {
            string name;
            string value;
            while (ParseProperty(tokens, out name, out value))
            {
                props[name] = value;
                while (PeekToken(tokens) == ";")
                    PopToken(tokens);
            }
            return true;
        }

        private static bool ParseProperty(List<string> tokens, out string name, out string value)
        {
            name = null;
            value = null;

            if (PeekToken(tokens) == "" || PeekToken(tokens) == "}")
                return false;

            name = PopToken(tokens);

            var sep = PopToken(tokens);
            if (sep != ":")
            {
                Debug.LogError("Invalid CSS property separator: \"" + sep + "\"");
                return false;
            }

            value = "";
            while (PeekToken(tokens) != "" && PeekToken(tokens) != ";" && PeekToken(tokens) != "}")
            {
                value = (value == "") ? PopToken(tokens) : value + " " + PopToken(tokens);
                if (PeekToken(tokens) == "(")
                    value += ParseParenValue(tokens);
            }

            return true;
        }

        private static string ParseParenValue(List<string> tokens)
        {
            var opening = PopToken(tokens);
            if (opening != "(")
            {
                Debug.LogError("Invaid CSS value opening");
                return "";
            }

            var value = opening;
            while (PeekToken(tokens) != "" && PeekToken(tokens) != ")")
                value += PopToken(tokens);
            
            if (PeekToken(tokens) != ")")
            {
                Debug.LogError("Invaid CSS value closing");
                return "";
            }

            value += PopToken(tokens);
            return value;
        }

        /// <summary>Breaks a CSS input into tokens</summary>
        /// <param name="cssText">The CSS text</param>
        /// <returns>A list of tokens</returns>
        public static List<string> Tokenize(string cssText)
        {
            var tokens = new List<string>();

            cssText = cssText.Replace(System.Environment.NewLine, ""); // Remove newlines
            cssText = Regex.Replace(cssText, @"/\*.*?\*/", ""); // Remove CSS comments
            cssText = Regex.Replace(cssText, @"<!--.*?-->", ""); // Remove XML comments

            int from = 0;
            int to = 0;

            while (from < cssText.Length)
            {
                while (from < cssText.Length && IsWhitespace(cssText[from]))
                    ++from;

                to = from;

                while (to < cssText.Length && !IsSeparator(cssText[to]))
                    ++to;

                if (from == to)
                {
                    if (from < cssText.Length)
                        tokens.Add(cssText[from].ToString());
                    ++to;
                }
                else
                {
                    tokens.Add(cssText.Substring(from, to-from));
                }

                from = to;
            }
            
            return tokens;
        }

        private static string PeekToken(List<string> tokens)
        {
            if (tokens.Count == 0)
                return "";
            return tokens[0];
        }

        private static string PopToken(List<string> tokens)
        {
            if (tokens.Count == 0)
                return "";
            var tok = tokens[0];
            tokens.RemoveAt(0);
            return tok;
        }

        private static bool IsSeparator(char ch)
        {
            return IsWhitespace(ch) || ch == ';' || ch == ':' || ch == '{' || ch == '}' || ch == '(' || ch == ')' || ch == ',';
        }

        private static bool IsWhitespace(char ch)
        {
            return ch == ' ' || ch == '\n' || ch == '\t';
        }
    }
} // namespace
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/SVGStyleSheet.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorEllipse.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e5c16ccd991535447911bd905325bbc0
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    public partial class VectorUtils
    {
        internal static BezierPathSegment[] BuildEllipsePath(Vector2 p0, Vector2 p1, float rotation, float rx, float ry, bool largeArc, bool sweep)
        {
            if ((p1-p0).magnitude < VectorUtils.Epsilon)
                return new BezierPathSegment[0];

            Vector2 c;
            float theta1;
            float sweepTheta;
            float adjustedRx;
            float adjustedRy;
            ComputeEllipseParameters(p0, p1, rotation, rx, ry, largeArc, sweep, out c, out theta1, out sweepTheta, out adjustedRx, out adjustedRy);

            BezierPathSegment[] path;
            if (Mathf.Abs(sweepTheta) <= Mathf.Epsilon)
            {
                // Use a straight line if the sweep angle is tiny
                path = VectorUtils.BezierSegmentToPath(VectorUtils.MakeLine(p0, p1));
            }
            else
            {
                path = VectorUtils.MakeArc(Vector2.zero, theta1, sweepTheta, 1.0f);

                var scaling = new Vector2(adjustedRx, adjustedRy);
                path = VectorUtils.TransformBezierPath(path, c, rotation, scaling);                
            }


            return path;
        }

        private static void ComputeEllipseParameters(Vector2 p0, Vector2 p1, float phi, float rx, float ry, bool fa, bool fs, out Vector2 c, out float theta1, out float sweepTheta, out float adjustedRx, out float adjustedRy)
        {
            // See https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
            var cosPhi = Mathf.Cos(phi);
            var sinPhi = Mathf.Sin(phi);

            var m0 = Matrix2D.identity;
            m0.m00 = cosPhi;
            m0.m01 = -sinPhi;
            m0.m10 = sinPhi;
            m0.m11 = cosPhi;

            var m1 = m0;
            m1.m01 = -m1.m01;
            m1.m10 = -m1.m10;

            var pp = m0 * new Vector2((p0.x - p1.x) / 2.0f, (p0.y - p1.y) / 2.0f);

            rx = Mathf.Abs(rx);
            ry = Mathf.Abs(ry);
            EnsureRadiiAreLargeEnough(pp, ref rx, ref ry);
            adjustedRx = rx;
            adjustedRy = ry;

            var ppx2 = pp.x * pp.x;
            var ppy2 = pp.y * pp.y;
            var rx2 = rx * rx;
            var ry2 = ry * ry;
            var cp = new Vector2((rx * pp.y) / ry, -(ry * pp.x) / rx);
            cp *= Mathf.Sqrt(Mathf.Abs((rx2 * ry2 - rx2 * ppy2 - ry2 * ppx2) / (rx2 * ppy2 + ry2 * ppx2)));
            if (fa == fs)
                cp = -cp;

            c = (m1 * cp) + new Vector2((p0.x + p1.x) / 2.0f, (p0.y + p1.y) / 2.0f);

            theta1 = Vector2.SignedAngle(new Vector2(1, 0), new Vector2((pp.x - cp.x) / rx, (pp.y - cp.y) / ry)) % 360.0f;
            sweepTheta = Vector2.SignedAngle(new Vector2((pp.x - cp.x) / rx, (pp.y - cp.y) / ry), new Vector2((-pp.x - cp.x) / rx, (-pp.y - cp.y) / ry));

            if (!fs && sweepTheta > 0)
                sweepTheta -= 360;
            if (fs && sweepTheta < 0)
                sweepTheta += 360;

            theta1 *= Mathf.Deg2Rad;
            sweepTheta *= Mathf.Deg2Rad;
        }

        private static void EnsureRadiiAreLargeEnough(Vector2 p, ref float rx, ref float ry)
        {
            var d = (p.x * p.x) / (rx * rx) + (p.y * p.y) / (ry * ry);
            if (d > 1.0f)
            {
                var sqrtD = Mathf.Sqrt(d);
                rx *= sqrtD;
                ry *= sqrtD;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorEllipse.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorRectangle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5ab9bcde9af121f45a0d120f28f80d7c
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    public partial class VectorUtils
    {
        /// <summary>Builds a BezierContour from a Rectangle.</summary>
        /// <param name="rect">The rectangle to build the contour from</param>
        /// <param name="radiusTL">The top-left radius of the rectangle</param>
        /// <param name="radiusTR">The top-right radius of the rectangle</param>
        /// <param name="radiusBR">The bottom-right radius of the rectangle</param>
        /// <param name="radiusBL">The bottom-left radius of the rectangle</param>
        /// <returns>A BezierContour that follows the rectangle contour</returns>
        public static BezierContour BuildRectangleContour(Rect rect, Vector2 radiusTL, Vector2 radiusTR, Vector2 radiusBR, Vector2 radiusBL)
        {
            var width = rect.size.x;
            var height = rect.size.y;

            var halfSize = new Vector2(width / 2.0f, height / 2.0f);
            radiusTL = Vector2.Max(Vector2.Min(radiusTL, halfSize), Vector2.zero);
            radiusTR = Vector2.Max(Vector2.Min(radiusTR, halfSize), Vector2.zero);
            radiusBR = Vector2.Max(Vector2.Min(radiusBR, halfSize), Vector2.zero);
            radiusBL = Vector2.Max(Vector2.Min(radiusBL, halfSize), Vector2.zero);

            var leftSegmentSize = height - (radiusBL.y + radiusTL.y);
            var topSegmentSize = width - (radiusTL.x + radiusTR.x);
            var rightSegmentSize = height - (radiusBR.y + radiusTR.y);
            var bottomSegmentSize = width - (radiusBL.x + radiusBR.x);

            var segments = new List<BezierPathSegment>(8);
            BezierPathSegment seg;

            if (leftSegmentSize > VectorUtils.Epsilon)
            {
                seg = MakePathLine(new Vector2(0.0f, radiusTL.y + leftSegmentSize), new Vector2(0.0f, radiusTL.y))[0];
                segments.Add(seg);
            }

            if (radiusTL.magnitude > VectorUtils.Epsilon)
            {
                var circleArc = VectorUtils.MakeArc(Vector2.zero, -Mathf.PI, Mathf.PI / 2.0f, 1.0f);
                circleArc = VectorUtils.TransformBezierPath(circleArc, radiusTL, 0.0f, radiusTL);
                segments.Add(circleArc[0]);
            }

            if (topSegmentSize > VectorUtils.Epsilon)
            {
                seg = MakePathLine(new Vector2(radiusTL.x, 0.0f), new Vector2(radiusTL.x + topSegmentSize, 0.0f))[0];
                segments.Add(seg);
            }

            if (radiusTR.magnitude > VectorUtils.Epsilon)
            {
                var topRight = new Vector2(width - radiusTR.x, radiusTR.y);
                var circleArc = VectorUtils.MakeArc(Vector2.zero, -Mathf.PI / 2.0f, Mathf.PI / 2.0f, 1.0f);
                circleArc = VectorUtils.TransformBezierPath(circleArc, topRight, 0.0f, radiusTR);
                segments.Add(circleArc[0]);
            }

            if (rightSegmentSize > VectorUtils.Epsilon)
            {
                seg = MakePathLine(new Vector2(width, radiusTR.y), new Vector2(width, radiusTR.y + rightSegmentSize))[0];
                segments.Add(seg);
            }

            if (radiusBR.magnitude > VectorUtils.Epsilon)
            {
                var bottomRight = new Vector2(width - radiusBR.x, height - radiusBR.y);
                var circleArc = VectorUtils.MakeArc(Vector2.zero, 0.0f, Mathf.PI / 2.0f, 1.0f);
                circleArc = VectorUtils.TransformBezierPath(circleArc, bottomRight, 0.0f, radiusBR);
                segments.Add(circleArc[0]);
            }

            if (bottomSegmentSize > VectorUtils.Epsilon)
            {
                seg = MakePathLine(new Vector2(width - radiusBR.x, height), new Vector2(width - (radiusBR.x + bottomSegmentSize), height))[0];
                segments.Add(seg);
            }

            if (radiusBL.magnitude > VectorUtils.Epsilon)
            {
                var bottomLeft = new Vector2(radiusBL.x, height - radiusBL.y);
                var circleArc = VectorUtils.MakeArc(Vector2.zero, Mathf.PI / 2.0f, Mathf.PI / 2.0f, 1.0f);
                circleArc = VectorUtils.TransformBezierPath(circleArc, bottomLeft, 0.0f, radiusBL);
                segments.Add(circleArc[0]);
            }

            // Offset segments to position
            for (int i = 0; i < segments.Count; ++i)
            {
                var s = segments[i];
                s.P0 += rect.position;
                s.P1 += rect.position;
                s.P2 += rect.position;
                segments[i] = s;
            }

            return new BezierContour() { Segments = segments.ToArray(), Closed = true };
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorRectangle.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorScene.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6317336283684d540b187222a9055e78
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    /// <summary>The gradient fill types.</summary>
    public enum GradientFillType
    {
        /// <summary>A linear gradient.</summary>
        Linear,

        /// <summary>A radial gradient, centered at the radial focus of the gradient fill.</summary>
        Radial
    }

    /// <summary>The path corner types, for joining path segments together.</summary>
    public enum PathCorner
    {
        /// <summary>A tipped corner with a sharp edge.</summary>
        Tipped,

        /// <summary>A rounded corner.</summary>
        Round,

        /// <summary>A beveled corner.</summary>
        Beveled
    }

    /// <summary>The path ending types.</summary>
    public enum PathEnding
    {
        /// <summary>A square path ending.</summary>
        Chop,

        /// <summary>A square path ending with a small extrusion.</summary>
        Square,

        /// <summary>A rounded path ending.</summary>
        Round
    }

    /// <summary>The fill mode types.</summary>
    public enum FillMode
    {
        /// <summary>Determines the "insideness" of the shape by evaluating the direction of the edges crossed.</summary>
        NonZero,

        /// <summary>Determines the "insideness" of the shape by counting the number of edges crossed.</summary>
        OddEven
    }

    /// <summary>The addressing mode, defining how textures or gradients behave when being addressed outside their unit range.</summary>
    public enum AddressMode
    {
        /// <summary>Textures/gradients are wrapping around with a repeating pattern.</summary>
        Wrap,

        /// <summary>Textures/gradients are clamped on the borders.</summary>
        Clamp,

        /// <summary>Textures/gradients are repeated with a mirroring pattern.</summary>
        Mirror
    }

    /// <summary>The gradient stops used for gradient fills.</summary>
    public struct GradientStop
    {
        /// <summary>The color of the stop.</summary>
        public Color Color { get; set; }

        /// <summary>At which percentage this stop applies. Should be between 0 and 1, inclusively.</summary>
        public float StopPercentage { get; set; }
    }

    /// <summary>A bezier segment.</summary>
    /// <remarks>
    /// Cubic Bezier segment starts from P0, flies in tangent to direction from P0 to P1,
    /// then lands in direction from P2 to P3, to finally end exactly at P3.
    /// </remarks>
    public struct BezierSegment
    {
        /// <summary>Origin point of the segment.</summary>
        public Vector2 P0;

        /// <summary>First control point of the segment.</summary>
        public Vector2 P1;

        /// <summary>Second control point of the segment.</summary>
        public Vector2 P2;

        /// <summary>Ending point of the segment.</summary>
        public Vector2 P3;
    }

    /// <summary>A bezier path segment.</summary>
    /// <remarks>
    /// Like BezierSegment but implies connectivity of segments, where segments[0].P3 is actually segments[1].P0
    /// </remarks>
    public struct BezierPathSegment
    {
        /// <summary>Origin point of the segment.</summary>
        public Vector2 P0;

        /// <summary>First control point of the segment.</summary>
        public Vector2 P1;

        /// <summary>Second control point of the segment.</summary>
        public Vector2 P2;
    }

    /// <summary>A chain of bezier paths, optionnally closed.</summary>
    public struct BezierContour
    {
        /// <summary>An array of every path segments on the contour.</summary>
        /// <remarks>Closed paths should not add a dedicated closing segment. It is implied by the 'closed' property.</remarks>
        public BezierPathSegment[] Segments { get; set; }

        /// <summary>A boolean indicating if the contour should be closed.</summary>
        /// <remarks>
        ///  When set to true, closed path will connect the last path segment to the first path segment, by using the
        ///  last path segment's P1 and P2 as control points.
        /// </remarks>
        public bool Closed { get; set; }
    }

    /// <summary>The IFill interface is implemented by filling techniques (solid, texture or gradient).</summary>
    public interface IFill
    {
        /// <summary>The filling method (non-zero or even-odd) of the fill.</summary>
        FillMode Mode { get; set; }

        /// <summary>The opacity of the fill.</summary>
        float Opacity { get; set; }
    }

    /// <summary>Fills a shape with a single color.</summary>
    public class SolidFill : IFill
    {
        /// <summary>The color of the fill.</summary>
        public Color Color { get; set; }

        /// <summary>The opacity of the fill.</summary>
        public float Opacity { get { return m_Opacity; } set { m_Opacity = value; } }
        private float m_Opacity = 1.0f;

        /// <summary>The filling method (non-zero or even-odd) of the fill.</summary>
        public FillMode Mode { get; set; }
    }

    /// <summary>Fills a shape with a gradient.</summary>
    /// <remarks>
    /// Size of the fill is always assumed to cover the entire element's bounding box.
    /// Radial fills are centered in the element's bounding box. Its radii are half the bounding box dimensions in each direction.
    /// Linear fills start from the left edge to the right edge of the element's bounding box.
    /// </remarks>
    public class GradientFill : IFill
    {
        /// <summary>The fill type (linear or gradient).</summary>
        public GradientFillType Type { get; set; }

        /// <summary>An array of stops defining the gradient colors.</summary>
        public GradientStop[] Stops { get; set; }

        /// <summary>The filling method (non-zero or even-odd) of the fill.</summary>
        public FillMode Mode { get; set; }

        /// <summary>The opacity of the fill.</summary>
        public float Opacity { get { return m_Opacity; } set { m_Opacity = value; } }
        private float m_Opacity = 1.0f;

        /// <summary>The adressing mode (wrap, clamp or mirror) of this fill.</summary>
        public AddressMode Addressing { get; set; }

        /// <summary>A position within the unit circle (-1,1) where 0 falls in the middle of the fill.</summary>
        public Vector2 RadialFocus { get; set; }
    }

    /// <summary>Fills a shape with a texture.</summary>
    public class TextureFill : IFill 
    {
        /// <summary>The texture to fill the shape with.</summary>
        public Texture2D Texture { get; set; }

        /// <summary>The filling method (non-zero or even-odd) of the fill.</summary>
        public FillMode Mode { get; set; }

        /// <summary>The opacity of the fill.</summary>
        public float Opacity { get { return m_Opacity; } set { m_Opacity = value; } }
        private float m_Opacity = 1.0f;

        /// <summary>The adressing mode (wrap, clamp or mirror) of this fill.</summary>
        public AddressMode Addressing { get; set; }
    }

    /// <summary>Fills a shape with a pattern.</summary>
    public class PatternFill : IFill
    {
        /// <summary>The filling method (non-zero or even-odd) of the fill.</summary>
        public FillMode Mode { get; set; }

        /// <summary>The opacity of the fill.</summary>
        public float Opacity { get { return m_Opacity; } set { m_Opacity = value; } }
        private float m_Opacity = 1.0f;

        /// <summary>The root node of the pattern</summary>
        public SceneNode Pattern { get; set; }

        /// <summary>The rectangle that is repeated</summary>
        public Rect Rect { get; set; }
    }

    /// <summary>Defines how strokes should be rendered.</summary>
    public class Stroke
    {
        /// <summary>The stroke color.</summary>
        public Color Color {
            get {
                var solidFill = Fill as SolidFill;
                if (solidFill == null) return new Color();
                return solidFill.Color;
            }
            set {
                Fill = new SolidFill() { Color = value };
            }
        }

        /// <summary>The stroke fill.</summary>
        public IFill Fill { get; set; }

        /// <summary>A transformation specific to the fill.</summary>
        public Matrix2D FillTransform { get { return m_FillTransform; } set { m_FillTransform = value; } }
        private Matrix2D m_FillTransform = Matrix2D.identity;

        /// <summary>The stroke half-thickness.</summary>
        public float HalfThickness { get; set; }

        /// <summary>The stroke pattern (dashes).</summary>
        /// <remarks>Even entries mark a fill and odd entries mark void</remarks>
        public float[] Pattern { get; set; }

        /// <summary>An offset to where the pattern should start.</summary>
        public float PatternOffset { get; set; }

        /// <summary>How far the tipped corners may extrude.</summary>
        public float TippedCornerLimit { get; set; }
    }

    /// <summary>Defines properties of paths.</summary>
    public struct PathProperties
    {
        /// <summary>The stroke used to render the path.</summary>
        public Stroke Stroke { get; set; }

        /// <summary>How the beginning of the path should be displayed.</summary>
        public PathEnding Head { get; set; }

        /// <summary>How the end of the path should be displayed.</summary>
        public PathEnding Tail { get; set; }

        /// <summary>How the corners of the path should be displayed.</summary>
        public PathCorner Corners { get; set; }
    }

    /// <summary>A generic filled shape.</summary>
    public class Shape
    {
        /// <summary>All the contours defining the shape.</summary>
        /// <remarks>
        /// Some of these coutours may be holes in the shape, depending on the fill mode used <see cref="FillMode"/>.
        /// </remarks>
        public BezierContour[] Contours { get; set; }

        /// <summary>The fill used on the shape.</summary>
        public IFill Fill { get; set; }

        /// <summary>A transformation specific to the fill.</summary>
        public Matrix2D FillTransform { get { return m_FillTransform; } set { m_FillTransform = value; } }
        private Matrix2D m_FillTransform = Matrix2D.identity;

        /// <summary>The path properties.</summary>
        public PathProperties PathProps { get; set; }

        /// <summary>Whether the specified contours are convex or not</summary>
        /// <remarks>
        /// Set this to true when you know the shape contours are convex.
        /// This will allow for a faster tessellation process in some circumstances.
        /// </remarks>
        public bool IsConvex { get; set; }
    }

    /// <summary>A node inside a hierarchy.</summary>
    public class SceneNode
    {
        /// <summary>The list of children nodes.</summary>
        public List<SceneNode> Children { get; set; }

        /// <summary>The list of shapes inside this node.</summary>
        public List<Shape> Shapes { get; set; }

        /// <summary>The transform of the node.</summary>
        public Matrix2D Transform { get { return m_Transform; } set { m_Transform = value; } }
        private Matrix2D m_Transform = Matrix2D.identity;

        /// <summary>A clipper hierarchy that will clip this node.</summary>
        public SceneNode Clipper { get; set; }
    }

    /// <summary>A scene contains the whole node hierarchy.</summary>
    public class Scene
    {
        /// <summary>The root of the node hierarchy.</summary>
        public SceneNode Root { get; set; }
    }
} // namespace
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorScene.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorSprite.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c138b02f3c416c146aa000916ae2f816
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.U2D;
#if !(UNITY_2019_3_OR_NEWER)
using UnityEngine.Experimental.U2D;
#endif
using UnityEngine.Experimental.Rendering;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    public static partial class VectorUtils
    {
        /// <summary>The alignement of the sprite, to determine the location of the pivot.</summary>
        public enum Alignment
        {
            /// <summary>Center alignment.</summary>
            Center = 0,

            /// <summary>Top-left alignment.</summary>
            TopLeft = 1,

            /// <summary>Top-center alignment.</summary>
            TopCenter = 2,

            /// <summary>Top-right alignment.</summary>
            TopRight = 3,

            /// <summary>Left-center alignment.</summary>
            LeftCenter = 4,

            /// <summary>Right-center alignment.</summary>
            RightCenter = 5,

            /// <summary>Bottom-left alignment.</summary>
            BottomLeft = 6,

            /// <summary>Bottom-center alignment.</summary>
            BottomCenter = 7,

            /// <summary>Bottom-right alignment.</summary>
            BottomRight = 8,

            /// <summary>Custom alignment.</summary>
            /// <remarks>
            /// Uses a custom alignment that will be used when building the sprite using the <see cref="BuildSprite"/> method.
            /// </remarks>
            Custom = 9,

            /// <summary>SVG origin alignment.</summary>
            /// <remarks>
            /// This will use the origin of the SVG document as the origin of the sprite.
            /// </remarks>
            SVGOrigin = 10
        }

        private static void FlipYAxis(IList<Vector2> vertices)
        {
            var bbox = Bounds(vertices);
            var h = bbox.height;
            for (int i = 0; i < vertices.Count; ++i)
            {
                var v = vertices[i];
                v.y -= bbox.position.y;
                v.y = h - v.y;
                v.y += bbox.position.y;
                vertices[i] = v;
            }
        }
   
        internal enum WindingDir
        {
            CW,
            CCW
        }

        internal static void AdjustWinding(Vector2[] vertices, UInt16[] indices, WindingDir dir)
        {
            bool shouldFlip = false;
            var length = indices.Length;
            for (int i = 0; i < (length - 2); i += 3)
            {
                var v0 = (Vector3)vertices[indices[i]];
                var v1 = (Vector3)vertices[indices[i+1]];
                var v2 = (Vector3)vertices[indices[i+2]];
                var s = (v1 - v0).normalized;
                var t = (v2 - v0).normalized;
                float dot = Vector3.Dot(s, t);
                if (s == Vector3.zero || t == Vector3.zero || dot > 0.9999f || dot < -0.9999f)
                    continue;
                var n = Vector3.Cross(s, t);
                if (n.sqrMagnitude < 0.0001f)
                    continue;
                shouldFlip = dir == WindingDir.CCW ? n.z < 0.0f : n.z > 0.0f;
                break;
            }
            if (shouldFlip)
            {
                for (int i = 0; i < (length - 2); i += 3)
                {
                    var tmp = indices[i];
                    indices[i] = indices[i+1];
                    indices[i+1] = tmp;
                }
            }
        }

        private static void FlipRangeIfNecessary(List<Vector2> vertices, List<UInt16> indices, int indexStart, int indexEnd, bool flipYAxis)
        {
            // For the range, find the first valid triangle and check its winding order. If that triangle needs flipping, then flip the whole range.
            bool shouldFlip = false;
            for (int i = indexStart; i < (indexEnd - 2); i += 3)
            {
                var v0 = (Vector3)vertices[indices[i]];
                var v1 = (Vector3)vertices[indices[i + 1]];
                var v2 = (Vector3)vertices[indices[i + 2]];
                var s = (v1 - v0).normalized;
                var t = (v2 - v0).normalized;
                float dot = Vector3.Dot(s, t);
                if (s == Vector3.zero || t == Vector3.zero || dot > 0.99f || dot < -0.99f)
                    continue;
                var n = Vector3.Cross(s, t);
                if (n.sqrMagnitude < 0.001f)
                    continue;
                shouldFlip = flipYAxis ? n.z < 0.0f : n.z > 0.0f;
                break;
            }
            if (shouldFlip)
            {
                for (int i = indexStart; i < (indexEnd - 2); i += 3)
                {
                    var tmp = indices[i + 1];
                    indices[i + 1] = indices[i + 2];
                    indices[i + 2] = tmp;
                }
            }
        }

        internal static void RenderFromArrays(Vector2[] vertices, UInt16[] indices, Vector2[] uvs, Color[] colors, Vector2[] settings, Texture2D texture, Material mat, bool clear = true)
        {
            mat.SetTexture("_MainTex", texture);
            mat.SetPass(0);

            if (clear)
                GL.Clear(true, true, Color.clear);

            GL.PushMatrix();
            GL.LoadOrtho();
            GL.Color(new Color(1, 1, 1, 1));
            GL.Begin(GL.TRIANGLES);
            for (int i = 0; i < indices.Length; ++i)
            {
                ushort index = indices[i];
                Vector2 vertex = vertices[index];
                Vector2 uv = uvs[index];
                GL.TexCoord2(uv.x, uv.y);
                if (settings != null)
                {
                    var setting = settings[index];
                    GL.MultiTexCoord2(2, setting.x, setting.y);
                }
                if (colors != null)
                    GL.Color(colors[index]);
                GL.Vertex3(vertex.x, vertex.y, 0);
            }
            GL.End();
            GL.PopMatrix();

            mat.SetTexture("_MainTex", null);
        }

        /// <summary>Draws a vector sprite using the provided material.</summary>
        /// <param name="sprite">The sprite to render</param>
        /// <param name="mat">The material used for rendering</param>
        /// <param name="clear">If true, clear the render target before rendering</param>
        public static void RenderSprite(Sprite sprite, Material mat, bool clear = true) 
        {
            float spriteWidth = sprite.rect.width;
            float spriteHeight = sprite.rect.height;
            float pixelsToUnits = sprite.rect.width / sprite.bounds.size.x;

            var uvs = sprite.uv;
            var triangles = sprite.triangles;
            var pivot = sprite.pivot;

            var vertices = sprite.vertices.Select(v => 
                new Vector2((v.x * pixelsToUnits + pivot.x)/spriteWidth,
                            (v.y * pixelsToUnits + pivot.y)/spriteHeight)
            ).ToArray();

            Color[] colors = null;
            if (sprite.HasVertexAttribute(VertexAttribute.Color))
                colors = sprite.GetVertexAttribute<Color32>(VertexAttribute.Color).Select(c => (Color)c).ToArray();

            Vector2[] settings = null;
            if (sprite.HasVertexAttribute(VertexAttribute.TexCoord2))
                settings = sprite.GetVertexAttribute<Vector2>(VertexAttribute.TexCoord2).ToArray();

            RenderFromArrays(vertices, sprite.triangles, sprite.uv, colors, settings, sprite.texture, mat, clear);
        }

        private static Material s_ExpandEdgesMat;

        /// <summary>Renders a vector sprite to Texture2D.</summary>
        /// <param name="sprite">The sprite to render</param>
        /// <param name="width">The desired width of the resulting texture</param>
        /// <param name="height">The desired height of the resulting texture</param>
        /// <param name="mat">The material used to render the sprite</param>
        /// <param name="antiAliasing">The number of samples per pixel for anti-aliasing</param>
        /// <param name="expandEdges">When true, expand the edges to avoid a dark banding effect caused by filtering. This is slower to render and uses more graphics memory.</param>
        /// <returns>A Texture2D object containing the rendered vector sprite</returns>
        public static Texture2D RenderSpriteToTexture2D(Sprite sprite, int width, int height, Material mat, int antiAliasing = 1, bool expandEdges = false)
        {
            if (width <= 0 || height <= 0)
                return null;

            RenderTexture tex = null;
            var oldActive = RenderTexture.active;

            var desc = new RenderTextureDescriptor(width, height, RenderTextureFormat.ARGB32, 0) {
                msaaSamples = 1,
                sRGB = QualitySettings.activeColorSpace == ColorSpace.Linear
            };

            if (expandEdges)
            {
                // Draw the sprite normally to be used as a background, no-antialiasing
                var normalTex = RenderTexture.GetTemporary(desc);
                RenderTexture.active = normalTex;
                RenderSprite(sprite, mat);

                // Expand the edges and make completely transparent
                if (s_ExpandEdgesMat == null)
                {
                    var shader = Shader.Find("Hidden/VectorExpandEdges");
                    if (shader == null)
                    {
#if UNITY_EDITOR
                        // Workaround for case 1167309.
                        // Shader.Find() seems to fail on the package shader when doing a fresh import with a clean Library folder,
                        // but AssetDatabase.LoadAssetAtPath() works fine though.
                        shader = UnityEditor.AssetDatabase.LoadAssetAtPath<Shader>("Packages/com.unity.vectorgraphics/Runtime/Shaders/VectorExpandEdges.shader");
#else
                        return null;
#endif
                    }
                    s_ExpandEdgesMat = new Material(shader);
                }

                var expandTex = RenderTexture.GetTemporary(desc);
                RenderTexture.active = expandTex;
                GL.Clear(false, true, Color.clear);
                Graphics.Blit(normalTex, expandTex, s_ExpandEdgesMat, 0);
                RenderTexture.ReleaseTemporary(normalTex);

                // Draw the sprite again, but clear with the texture rendered in the previous step,
                // this will make the bilinear filter to interpolate the colors with values different
                // than "transparent black", which causes black-ish outlines around the shape.
                desc.msaaSamples = antiAliasing;
                tex = RenderTexture.GetTemporary(desc);
                RenderTexture.active = tex;
                Graphics.Blit(expandTex, tex);
                RenderTexture.ReleaseTemporary(expandTex); // Use the expanded texture to clear the buffer

                RenderTexture.active = tex;
                RenderSprite(sprite, mat, false);
            }
            else
            {
                desc.msaaSamples = antiAliasing;
                tex = RenderTexture.GetTemporary(desc);
                RenderTexture.active = tex;
                RenderSprite(sprite, mat);
            }

            Texture2D copy = new Texture2D(width, height, TextureFormat.RGBA32, false);
            copy.hideFlags = HideFlags.HideAndDontSave;
            copy.ReadPixels(new Rect(0, 0, width, height), 0, 0);
            copy.Apply();

            RenderTexture.active = oldActive;
            RenderTexture.ReleaseTemporary(tex);

            return copy;
        }

        internal static Vector2 GetPivot(Alignment alignment, Vector2 customPivot, Rect bbox, bool flipYAxis)
        {
            switch (alignment)
            {
                case Alignment.Center: return new Vector2(0.5f, 0.5f);
                case Alignment.TopLeft: return new Vector2(0.0f, 1.0f);
                case Alignment.TopCenter: return new Vector2(0.5f, 1.0f);
                case Alignment.TopRight: return new Vector2(1.0f, 1.0f);
                case Alignment.LeftCenter: return new Vector2(0.0f, 0.5f);
                case Alignment.RightCenter: return new Vector2(1.0f, 0.5f);
                case Alignment.BottomLeft: return new Vector2(0.0f, 0.0f);
                case Alignment.BottomCenter: return new Vector2(0.5f, 0.0f);
                case Alignment.BottomRight: return new Vector2(1.0f, 0.0f);
                case Alignment.SVGOrigin: 
                {
                     var p = -bbox.position / bbox.size;
                     if (flipYAxis)
                        p.y = 1.0f - p.y;
                    return p;
                }
                case Alignment.Custom: return customPivot;
            }
            return Vector2.zero;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorSprite.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorTessellation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7946c79a48c418944bb4ac48df97c4be
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    public static partial class VectorUtils
    {
        /// <summary>
        /// Structure to store the tessellation options.
        /// </summary>
        public struct TessellationOptions
        {
            private float m_MaxCordDev, m_MaxCordDevSq, m_MaxTanAngleDev, m_MaxTanAngleDevCosine, m_StepSize;

            /// <summary>
            /// The uniform tessellation step distance.
            /// </summary>
            public float StepDistance { get; set; } // A split to happen uniformly at fixed distances

            /// <summary>
            /// The maximum distance on the cord to a straight line between to points after which more tessellation will be generated.
            /// To disable, specify float.MaxValue.
            /// </summary>
            public float MaxCordDeviation  // Maximum distance allowed between a cord and its line projection
            {
                get { return m_MaxCordDev; }
                set
                {
                    m_MaxCordDev = Mathf.Max(value, 0.0f);
                    m_MaxCordDevSq = (m_MaxCordDev == float.MaxValue) ? float.MaxValue : m_MaxCordDev * m_MaxCordDev;
                }
            }
            internal float MaxCordDeviationSquared { get { return m_MaxCordDevSq; } }

            /// <summary>
            /// The maximum angle (in degrees) between the curve tangent and the next point after which more tessellation will be generated.
            /// To disable, specify float.MaxValue.
            /// </summary>
            public float MaxTanAngleDeviation // The maximum angle allowed (in radians) between tangents before a split happens
            {
                get { return m_MaxTanAngleDev; }
                set
                {
                    m_MaxTanAngleDev = Mathf.Clamp(value, VectorUtils.Epsilon, Mathf.PI * 0.5f);
                    m_MaxTanAngleDevCosine = Mathf.Cos(m_MaxTanAngleDev);
                }
            }
            internal float MaxTanAngleDeviationCosine { get { return m_MaxTanAngleDevCosine; } } // Cosine of the maximum angle allowed between tangents before a split happens

            /// <summary>
            /// The number of samples used internally to evaluate the curves. More samples = higher quality.
            /// Should be between 0 and 1 (inclusive).
            /// </summary>
            public float SamplingStepSize
            {
                get { return m_StepSize; }
                set { m_StepSize = Mathf.Clamp(value, Epsilon, 1.0f); }
            }
        }

        /// <summary>
        /// Tessellates a path.
        /// </summary>
        /// <param name="contour">The path to tessellate</param>
        /// <param name="pathProps">The path properties</param>
        /// <param name="tessellateOptions">The tessellation options</param>
        /// <param name="vertices">The resulting vertices</param>
        /// <param name="indices">The resulting triangles</param>
        /// <remarks>
        /// The individual line segments generated during tessellation are made out of a set of ordered vertices. It is important
        /// to honor this ordering so joining and and capping connect properly with the existing vertices without generating dupes.
        /// The ordering assumed is as follows:
        /// The last two vertices of a piece must be such that the first is generated at the end with a positive half-thickness
        /// while the second vertex is at the end too but at a negative half-thickness.
        /// No assumptions are enforced for other vertices before the two last vertices.
        /// </remarks>
        public static void TessellatePath(BezierContour contour, PathProperties pathProps, TessellationOptions tessellateOptions, out Vector2[] vertices, out UInt16[] indices)
        {
            if (tessellateOptions.StepDistance < Epsilon)
                throw new Exception("stepDistance too small");

            if (contour.Segments.Length < 2)
            {
                vertices = new Vector2[0];
                indices = new UInt16[0];
                return;
            }

            tessellateOptions.MaxCordDeviation = Mathf.Max(0.0001f, tessellateOptions.MaxCordDeviation);
            tessellateOptions.MaxTanAngleDeviation = Mathf.Max(0.0001f, tessellateOptions.MaxTanAngleDeviation);

            UnityEngine.Profiling.Profiler.BeginSample("TessellatePath");

            float[] segmentLengths = VectorUtils.SegmentsLengths(contour.Segments, contour.Closed);

            // Approximate the number of vertices/indices we need to store the results so we reduce memory reallocations during work
            float approxTotalLength = 0.0f;
            foreach (var s in segmentLengths)
                approxTotalLength += s;

            int approxStepCount = Math.Max((int)(approxTotalLength / tessellateOptions.StepDistance + 0.5f), 2);
            if (pathProps.Stroke.Pattern != null)
                approxStepCount += pathProps.Stroke.Pattern.Length * 2;

            List<Vector2> verts = new List<Vector2>(approxStepCount * 2 + 32); // A little bit possibly for the endings
            List<UInt16> inds = new List<UInt16>((int)(verts.Capacity * 1.5f)); // Usually every 4 verts represent a quad that uses 6 indices

            var patternIt = new PathPatternIterator(pathProps.Stroke.Pattern, pathProps.Stroke.PatternOffset);
            var pathIt = new PathDistanceForwardIterator(contour.Segments, contour.Closed, tessellateOptions.MaxCordDeviationSquared, tessellateOptions.MaxTanAngleDeviationCosine, tessellateOptions.SamplingStepSize);

            JoiningInfo[] joiningInfo = new JoiningInfo[2];
            HandleNewSegmentJoining(pathIt, patternIt, joiningInfo, pathProps.Stroke.HalfThickness, segmentLengths);

            int rangeIndex = 0;
            while (!pathIt.Ended)
            {
                if (patternIt.IsSolid)
                    TessellateRange(patternIt.SegmentLength, pathIt, patternIt, pathProps, tessellateOptions, joiningInfo, segmentLengths, approxTotalLength, rangeIndex++, verts, inds);
                else
                    SkipRange(patternIt.SegmentLength, pathIt, patternIt, pathProps, joiningInfo, segmentLengths);
                patternIt.Advance();
            }

            vertices = verts.ToArray();
            indices = inds.ToArray();

            UnityEngine.Profiling.Profiler.EndSample();
        }

        static Vector2[] TraceShape(BezierContour contour, Stroke stroke, TessellationOptions tessellateOptions)
        {
            if (tessellateOptions.StepDistance < Epsilon)
                throw new Exception("stepDistance too small");

            if (contour.Segments.Length < 2)
                return new Vector2[0];

            float[] segmentLengths = VectorUtils.SegmentsLengths(contour.Segments, contour.Closed);

            // Approximate the number of vertices/indices we need to store the results so we reduce memory reallocations during work
            float approxTotalLength = 0.0f;
            foreach (var s in segmentLengths)
                approxTotalLength += s;

            int approxStepCount = Math.Max((int)(approxTotalLength / tessellateOptions.StepDistance + 0.5f), 2);
            var strokePattern = stroke != null ? stroke.Pattern : null;
            var strokePatternOffset = stroke != null ? stroke.PatternOffset : 0.0f;
            if (strokePattern != null)
                approxStepCount += strokePattern.Length * 2;

            List<Vector2> verts = new List<Vector2>(approxStepCount); // A little bit possibly for the endings

            var patternIt = new PathPatternIterator(strokePattern, strokePatternOffset);
            var pathIt = new PathDistanceForwardIterator(contour.Segments, true, tessellateOptions.MaxCordDeviationSquared, tessellateOptions.MaxTanAngleDeviationCosine, tessellateOptions.SamplingStepSize);
            verts.Add(pathIt.EvalCurrent());

            while (!pathIt.Ended)
            {
                float distance = patternIt.SegmentLength;
                float startingLength = pathIt.LengthSoFar;
                float unitsRemaining = Mathf.Min(tessellateOptions.StepDistance, distance);
                bool endedEntirePath = false;
                for (;;)
                {
                    var result = pathIt.AdvanceBy(unitsRemaining, out unitsRemaining);
                    if (result == PathDistanceForwardIterator.Result.Ended)
                    {
                        endedEntirePath = true;
                        break;
                    }
                    else if (result == PathDistanceForwardIterator.Result.NewSegment)
                        verts.Add(pathIt.EvalCurrent());

                    if ((unitsRemaining <= Epsilon) &&
                        !TryGetMoreRemainingUnits(ref unitsRemaining, pathIt, startingLength, distance, tessellateOptions.StepDistance))
                    {
                        break;
                    }

                    if (result == PathDistanceForwardIterator.Result.Stepped)
                        verts.Add(pathIt.EvalCurrent());
                }

                // Ending
                if (endedEntirePath)
                    break;
                else verts.Add(pathIt.EvalCurrent());
                patternIt.Advance();
            }

            if ((verts[0] - verts[verts.Count - 1]).sqrMagnitude < Epsilon)
                verts.RemoveAt(verts.Count - 1);
            return verts.ToArray(); // Why not return verts itself?
        }

        static bool TryGetMoreRemainingUnits(ref float unitsRemaining, PathDistanceForwardIterator pathIt, float startingLength, float distance, float stepDistance)
        {
            float distanceCrossedSoFar = pathIt.LengthSoFar - startingLength;
            float epsilon = Math.Max(Epsilon, distance * Epsilon * 100.0f);
            if ((distance - distanceCrossedSoFar) <= epsilon)
                return false;
            if (distanceCrossedSoFar + stepDistance > distance)
                unitsRemaining = distance - distanceCrossedSoFar;
            else unitsRemaining = stepDistance;
            return true;
        }

        static void HandleNewSegmentJoining(PathDistanceForwardIterator pathIt, PathPatternIterator patternIt, JoiningInfo[] joiningInfo, float halfThickness, float[] segmentLengths)
        {
            joiningInfo[0] = joiningInfo[1];
            joiningInfo[1] = null;

            if (!patternIt.IsSolidAt(pathIt.LengthSoFar + segmentLengths[pathIt.CurrentSegment]))
                return; // The joining center falls outside the pattern, so don't join... period

            if (pathIt.Closed && pathIt.Segments.Count <= 2)
                return; // Not enough segments to do proper closing

            if (pathIt.Closed)
            {
                JoiningInfo closing;
                if ((pathIt.CurrentSegment == 0) || (pathIt.CurrentSegment == pathIt.Segments.Count - 2))
                {
                    closing = ForeseeJoining(
                            VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.Segments.Count - 2),
                            VectorUtils.PathSegmentAtIndex(pathIt.Segments, 0),
                            halfThickness, segmentLengths[pathIt.Segments.Count - 2]);

                    if (pathIt.CurrentSegment == 0)
                        joiningInfo[0] = closing;
                    else
                    {
                        joiningInfo[1] = closing;
                        return;
                    }
                }
                else if (pathIt.CurrentSegment > pathIt.Segments.Count - 2)
                    return;
            }
            else if (pathIt.CurrentSegment >= pathIt.Segments.Count - 2)
                return;

            joiningInfo[1] = ForeseeJoining(
                    VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.CurrentSegment),
                    VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.CurrentSegment + 1),
                    halfThickness, segmentLengths[pathIt.CurrentSegment]);
        }

        static void SkipRange(
            float distance, PathDistanceForwardIterator pathIt, PathPatternIterator patternIt,
            PathProperties pathProps, JoiningInfo[] joiningInfo, float[] segmentLengths)
        {
            float unitsRemaining = distance;
            while (unitsRemaining > Epsilon)
            {
                var result = pathIt.AdvanceBy(unitsRemaining, out unitsRemaining);
                switch (result)
                {
                    case PathDistanceForwardIterator.Result.Ended:
                        return;
                    case PathDistanceForwardIterator.Result.Stepped:
                        if (unitsRemaining < Epsilon)
                            return;
                        break;
                    case PathDistanceForwardIterator.Result.NewSegment:
                        HandleNewSegmentJoining(pathIt, patternIt, joiningInfo, pathProps.Stroke.HalfThickness, segmentLengths);
                        break;
                }
            }
        }

        static void TessellateRange(
            float distance, PathDistanceForwardIterator pathIt, PathPatternIterator patternIt, PathProperties pathProps,
            TessellationOptions tessellateOptions, JoiningInfo[] joiningInfo, float[] segmentLengths, float totalLength, int rangeIndex, List<Vector2> verts, List<UInt16> inds)
        {
            bool startOfLoop = pathIt.Closed && (pathIt.CurrentSegment == 0) && (pathIt.CurrentT == 0.0f);
            if (startOfLoop && (joiningInfo[0] != null))
            {
                GenerateJoining(joiningInfo[0], pathProps.Corners, pathProps.Stroke.HalfThickness, pathProps.Stroke.TippedCornerLimit, tessellateOptions, verts, inds);
            }
            else
            {
                var pathEnding = pathProps.Head;

                // If pattern at the end will overlap with beginning, use a chopped ending to allow merging
                if (pathIt.Closed && rangeIndex == 0 && patternIt.IsSolidAt(pathIt.CurrentT) && patternIt.IsSolidAt(totalLength))
                    pathEnding = PathEnding.Chop;

                GenerateTip(VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.CurrentSegment), true, pathIt.CurrentT, pathEnding, pathProps.Stroke.HalfThickness, tessellateOptions, verts, inds);
            }

            float startingLength = pathIt.LengthSoFar;
            float unitsRemaining = Mathf.Min(tessellateOptions.StepDistance, distance);
            bool endedEntirePath = false;
            for (;;)
            {
                var result = pathIt.AdvanceBy(unitsRemaining, out unitsRemaining);
                if (result == PathDistanceForwardIterator.Result.Ended)
                {
                    endedEntirePath = true;
                    break;
                }
                else if (result == PathDistanceForwardIterator.Result.NewSegment)
                {
                    if (joiningInfo[1] != null)
                        GenerateJoining(joiningInfo[1], pathProps.Corners, pathProps.Stroke.HalfThickness, pathProps.Stroke.TippedCornerLimit, tessellateOptions, verts, inds);
                    else AddSegment(VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.CurrentSegment), pathIt.CurrentT, pathProps.Stroke.HalfThickness, null, pathIt.SegmentLengthSoFar, verts, inds);
                    HandleNewSegmentJoining(pathIt, patternIt, joiningInfo, pathProps.Stroke.HalfThickness, segmentLengths);
                }

                if ((unitsRemaining <= Epsilon) &&
                    !TryGetMoreRemainingUnits(ref unitsRemaining, pathIt, startingLength, distance, tessellateOptions.StepDistance))
                {
                    break;
                }

                if (result == PathDistanceForwardIterator.Result.Stepped)
                    AddSegment(VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.CurrentSegment), pathIt.CurrentT, pathProps.Stroke.HalfThickness, joiningInfo, pathIt.SegmentLengthSoFar, verts, inds);
            }

            // Ending
            if (endedEntirePath && pathIt.Closed)
            {
                // No joining needed, the start and end of the path should just connect
                inds.Add(0);
                inds.Add(1);
                inds.Add((UInt16)(verts.Count - 2));
                inds.Add((UInt16)(verts.Count - 1));
                inds.Add((UInt16)(verts.Count - 2));
                inds.Add(1);
            }
            else
            {
                AddSegment(VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.CurrentSegment), pathIt.CurrentT, pathProps.Stroke.HalfThickness, joiningInfo, pathIt.SegmentLengthSoFar, verts, inds);
                GenerateTip(VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.CurrentSegment), false, pathIt.CurrentT, pathProps.Tail, pathProps.Stroke.HalfThickness, tessellateOptions, verts, inds);
            }
        }

        static void AddSegment(BezierSegment segment, float toT, float halfThickness, JoiningInfo[] joinInfo, float segmentLengthSoFar, List<Vector2> verts, List<UInt16> inds)
        {
            Vector2 tanTo, normTo;
            Vector2 posTo = VectorUtils.EvalFull(segment, toT, out tanTo, out normTo);

            Vector2 posThickness = posTo + normTo * halfThickness;
            Vector2 negThickness = posTo + normTo * -halfThickness;

            if (joinInfo != null)
            {
                if ((joinInfo[0] != null) && (segmentLengthSoFar < joinInfo[0].InnerCornerDistFromStart))
                {
                    if (joinInfo[0].RoundPosThickness)
                        negThickness = joinInfo[0].InnerCornerVertex;
                    else posThickness = joinInfo[0].InnerCornerVertex;
                }

                if ((joinInfo[1] != null) && (segmentLengthSoFar > joinInfo[1].InnerCornerDistToEnd))
                {
                    if (joinInfo[1].RoundPosThickness)
                        negThickness = joinInfo[1].InnerCornerVertex;
                    else posThickness = joinInfo[1].InnerCornerVertex;
                }
            }

            System.Diagnostics.Debug.Assert(verts.Count >= 2);
            int indexStart = verts.Count - 2;
            verts.Add(posThickness);
            verts.Add(negThickness);
            inds.Add((UInt16)(indexStart + 0));
            inds.Add((UInt16)(indexStart + 3));
            inds.Add((UInt16)(indexStart + 1));
            inds.Add((UInt16)(indexStart + 0));
            inds.Add((UInt16)(indexStart + 2));
            inds.Add((UInt16)(indexStart + 3));
        }

        class JoiningInfo
        {
            public Vector2 JoinPos;
            public Vector2 TanAtEnd, TanAtStart;
            public Vector2 NormAtEnd, NormAtStart;
            public Vector2 PosThicknessStart, NegThicknessStart;
            public Vector2 PosThicknessEnd, NegThicknessEnd;
            public Vector2 PosThicknessClosingPoint, NegThicknessClosingPoint;
            public bool RoundPosThickness;
            public bool SimpleJoin;
            public Vector2 InnerCornerVertex;
            public float InnerCornerDistToEnd, InnerCornerDistFromStart;
        }

        static JoiningInfo ForeseeJoining(BezierSegment end, BezierSegment start, float halfThickness, float endSegmentLength)
        {
            JoiningInfo joinInfo = new JoiningInfo();

            // The joining generates the vertices at both ends as well as the joining itself
            joinInfo.JoinPos = end.P3;
            joinInfo.TanAtEnd = VectorUtils.EvalTangent(end, 1.0f);
            joinInfo.NormAtEnd = Vector2.Perpendicular(joinInfo.TanAtEnd);
            joinInfo.TanAtStart = VectorUtils.EvalTangent(start, 0.0f);
            joinInfo.NormAtStart = Vector2.Perpendicular(joinInfo.TanAtStart);

            // If the tangents are continuous at the join location, we don't have
            // to generate a corner, we do a "simple" join by just connecting the vertices
            // from the two segments directly
            float cosAngleBetweenTans = Vector2.Dot(joinInfo.TanAtEnd, joinInfo.TanAtStart);
            joinInfo.SimpleJoin = Mathf.Approximately(Mathf.Abs(cosAngleBetweenTans), 1.0f);
            if (joinInfo.SimpleJoin)
                return null;

            joinInfo.PosThicknessEnd = joinInfo.JoinPos + joinInfo.NormAtEnd * halfThickness;
            joinInfo.NegThicknessEnd = joinInfo.JoinPos - joinInfo.NormAtEnd * halfThickness;
            joinInfo.PosThicknessStart = joinInfo.JoinPos + joinInfo.NormAtStart * halfThickness;
            joinInfo.NegThicknessStart = joinInfo.JoinPos - joinInfo.NormAtStart * halfThickness;

            if (joinInfo.SimpleJoin)
            {
                joinInfo.PosThicknessClosingPoint = Vector2.LerpUnclamped(joinInfo.PosThicknessEnd, joinInfo.PosThicknessStart, 0.5f);
                joinInfo.NegThicknessClosingPoint = Vector2.LerpUnclamped(joinInfo.NegThicknessEnd, joinInfo.NegThicknessStart, 0.5f);
            }
            else
            {
                joinInfo.PosThicknessClosingPoint = VectorUtils.IntersectLines(joinInfo.PosThicknessEnd, joinInfo.PosThicknessEnd + joinInfo.TanAtEnd, joinInfo.PosThicknessStart, joinInfo.PosThicknessStart + joinInfo.TanAtStart);
                joinInfo.NegThicknessClosingPoint = VectorUtils.IntersectLines(joinInfo.NegThicknessEnd, joinInfo.NegThicknessEnd + joinInfo.TanAtEnd, joinInfo.NegThicknessStart, joinInfo.NegThicknessStart + joinInfo.TanAtStart);

                if (float.IsInfinity(joinInfo.PosThicknessClosingPoint.x) || float.IsInfinity(joinInfo.PosThicknessClosingPoint.y))
                    joinInfo.PosThicknessClosingPoint = joinInfo.JoinPos;
                if (float.IsInfinity(joinInfo.NegThicknessClosingPoint.x) || float.IsInfinity(joinInfo.NegThicknessClosingPoint.y))
                    joinInfo.NegThicknessClosingPoint = joinInfo.JoinPos;
            }

            // Should we round the positive thickness side or the negative thickness side?
            joinInfo.RoundPosThickness = PointOnTheLeftOfLine(Vector2.zero, joinInfo.TanAtEnd, joinInfo.TanAtStart);

            // Inner corner vertex should be calculated by intersection of the inner segments
            Vector2[] startTrail = null, endTrail = null;
            Vector2 intersectionOnStart = Vector2.zero, intersectionOnEnd = Vector2.zero;
            if (!joinInfo.SimpleJoin)
            {
                BezierSegment endFlipped = VectorUtils.FlipSegment(end);
                Vector2 thicknessClosingPoint = joinInfo.RoundPosThickness ? joinInfo.PosThicknessClosingPoint : joinInfo.NegThicknessClosingPoint;
                Vector2 meetingPoint = end.P3;
                Vector2 thicknessDiagonalEnd = meetingPoint + (thicknessClosingPoint - meetingPoint) * 10.0f;
                startTrail = LineBezierThicknessIntersect(
                        start, joinInfo.RoundPosThickness ? -halfThickness : halfThickness, meetingPoint, thicknessDiagonalEnd,
                        out joinInfo.InnerCornerDistFromStart, out intersectionOnStart);
                endTrail = LineBezierThicknessIntersect(
                        endFlipped, joinInfo.RoundPosThickness ? halfThickness : -halfThickness, meetingPoint, thicknessDiagonalEnd,
                        out joinInfo.InnerCornerDistToEnd, out intersectionOnEnd);
            }

            bool intersectionFound = false;
            if ((startTrail != null) && (endTrail != null))
            {
                var intersect = VectorUtils.IntersectLines(startTrail[0], startTrail[1], endTrail[0], endTrail[1]);
                var isOnStartTrail = PointOnLineIsWithinSegment(startTrail[0], startTrail[1], intersect);
                var isOnEndTrail = PointOnLineIsWithinSegment(endTrail[0], endTrail[1], intersect);
                if (!float.IsInfinity(intersect.x) && isOnStartTrail && isOnEndTrail)
                {
                    var vStart = intersectionOnStart - intersect;
                    var vEnd = intersectionOnEnd - intersect;
                    joinInfo.InnerCornerDistFromStart += (vStart == Vector2.zero) ? 0.0f : vStart.magnitude;
                    joinInfo.InnerCornerDistToEnd += (vEnd == Vector2.zero) ? 0.0f : vEnd.magnitude;
                    joinInfo.InnerCornerDistToEnd = endSegmentLength - joinInfo.InnerCornerDistToEnd;
                    joinInfo.InnerCornerVertex = intersect; // Found it!
                    intersectionFound = true;
                }
            }

            if (!intersectionFound)
            {
                joinInfo.InnerCornerVertex = joinInfo.JoinPos + ((joinInfo.TanAtStart - joinInfo.TanAtEnd) / 2.0f).normalized * halfThickness;
                joinInfo.InnerCornerDistFromStart = 0;
                joinInfo.InnerCornerDistToEnd = endSegmentLength;
            }
            return joinInfo;
        }

        static Vector2[] LineBezierThicknessIntersect(BezierSegment seg, float thickness, Vector2 lineFrom, Vector2 lineTo, out float distanceToIntersection, out Vector2 intersection)
        {
            Vector2 tan = VectorUtils.EvalTangent(seg, 0.0f);
            Vector2 nrm = Vector2.Perpendicular(tan);
            Vector2 lastPoint = seg.P0 + nrm * thickness;
            distanceToIntersection = 0.0f;
            intersection = new Vector2(float.PositiveInfinity, float.PositiveInfinity);
            float stepT = 0.01f;
            float t = 0;
            while (t < 1.0f)
            {
                t += stepT;
                var point = VectorUtils.EvalFull(seg, t, out tan, out nrm) + nrm * thickness;
                intersection = VectorUtils.IntersectLines(lineFrom, lineTo, lastPoint, point);
                if (PointOnLineIsWithinSegment(lastPoint, point, intersection))
                {
                    distanceToIntersection += (lastPoint - intersection).magnitude;
                    return new Vector2[] { lastPoint, point };
                }
                distanceToIntersection += (lastPoint - point).magnitude;
                lastPoint = point;
            }
            return null;
        }

        static bool PointOnLineIsWithinSegment(Vector2 lineFrom, Vector2 lineTo, Vector2 point)
        {
            // Point is assumed to be already on the line, but we would like to know if it is within the segment specified
            var v = (lineTo - lineFrom).normalized;
            if (Vector2.Dot(point - lineFrom,  v) < -Epsilon)
                return false;
            if (Vector2.Dot(point - lineTo, v) > Epsilon)
                return false;
            return true;
        }

        static void GenerateJoining(JoiningInfo joinInfo, PathCorner corner, float halfThickness, float tippedCornerLimit, TessellationOptions tessellateOptions, List<Vector2> verts, List<UInt16> inds)
        {
            // The joining generates the vertices at both ends as well as the joining itself
            if (verts.Count == 0)
            {
                // Starting a path with a joining (meaning a loop)
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.PosThicknessEnd : joinInfo.InnerCornerVertex);
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.InnerCornerVertex : joinInfo.NegThicknessEnd);
            }

            System.Diagnostics.Debug.Assert(verts.Count >= 2);
            int indexStart = verts.Count - 2; // Using the last two vertices

            // Convert a tipped corner to a beveled one if tippedCornerLimit ratio is reached
            if (corner == PathCorner.Tipped && tippedCornerLimit >= 1.0f)
            {
                var theta = Vector2.Angle(-joinInfo.TanAtEnd, joinInfo.TanAtStart) * Mathf.Deg2Rad;
                var ratio = 1.0f / Mathf.Sin(theta / 2.0f);
                if (ratio > tippedCornerLimit)
                    corner = PathCorner.Beveled;
            }

            if (joinInfo.SimpleJoin)
            {
                // TODO
            }
            else if (corner == PathCorner.Tipped)
            {
                verts.Add(joinInfo.PosThicknessClosingPoint);
                verts.Add(joinInfo.NegThicknessClosingPoint);
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.PosThicknessStart : joinInfo.InnerCornerVertex);
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.InnerCornerVertex : joinInfo.NegThicknessStart);

                // Ending to tip
                inds.Add((UInt16)(indexStart + 0));
                inds.Add((UInt16)(indexStart + 3));
                inds.Add((UInt16)(indexStart + 1));
                inds.Add((UInt16)(indexStart + 0));
                inds.Add((UInt16)(indexStart + 2));
                inds.Add((UInt16)(indexStart + 3));

                // Tip to starting
                inds.Add((UInt16)(indexStart + 4));
                inds.Add((UInt16)(indexStart + 3));
                inds.Add((UInt16)(indexStart + 2));
                inds.Add((UInt16)(indexStart + 4));
                inds.Add((UInt16)(indexStart + 5));
                inds.Add((UInt16)(indexStart + 3));

                return;
            }
            else if (corner == PathCorner.Beveled)
            {
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.PosThicknessEnd : joinInfo.InnerCornerVertex); // 2
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.InnerCornerVertex : joinInfo.NegThicknessEnd); // 3
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.PosThicknessStart : joinInfo.InnerCornerVertex); // 4
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.InnerCornerVertex : joinInfo.NegThicknessStart); // 5

                // Ending to tip
                inds.Add((UInt16)(indexStart + 0));
                inds.Add((UInt16)(indexStart + 2));
                inds.Add((UInt16)(indexStart + 1));
                inds.Add((UInt16)(indexStart + 1));
                inds.Add((UInt16)(indexStart + 2));
                inds.Add((UInt16)(indexStart + 3));

                // Bevel
                if (joinInfo.RoundPosThickness)
                {
                    inds.Add((UInt16)(indexStart + 2));
                    inds.Add((UInt16)(indexStart + 4));
                    inds.Add((UInt16)(indexStart + 3));
                }
                else
                {
                    inds.Add((UInt16)(indexStart + 3));
                    inds.Add((UInt16)(indexStart + 2));
                    inds.Add((UInt16)(indexStart + 5));
                }

                return;
            }

            if (corner == PathCorner.Round)
            {
                float sweepAngle = Mathf.Acos(Vector2.Dot(joinInfo.NormAtEnd, joinInfo.NormAtStart));
                bool flipArc = false;
                if (!PointOnTheLeftOfLine(Vector2.zero, joinInfo.NormAtEnd, joinInfo.NormAtStart))
                {
                    sweepAngle = -sweepAngle;
                    flipArc = true;
                }

                UInt16 innerCornerVertexIndex = (UInt16)verts.Count;
                verts.Add(joinInfo.InnerCornerVertex);

                int arcSegments = CalculateArcSteps(halfThickness, 0, sweepAngle, tessellateOptions);
                for (int i = 0; i <= arcSegments; i++)
                {
                    float angle = sweepAngle * (i / (float)arcSegments);
                    Vector2 nrm = Matrix2D.RotateLH(angle) * joinInfo.NormAtEnd;
                    if (flipArc) nrm = -nrm;
                    verts.Add(nrm * halfThickness + joinInfo.JoinPos);

                    if (i == 0)
                    {
                        inds.Add((UInt16)(indexStart + 0));
                        inds.Add((UInt16)(indexStart + 3));
                        inds.Add((UInt16)(indexStart + (joinInfo.RoundPosThickness ? 2 : 1)));

                        inds.Add((UInt16)(indexStart + 0));
                        inds.Add((UInt16)(indexStart + 2));
                        inds.Add((UInt16)(indexStart + (joinInfo.RoundPosThickness ? 1 : 3)));
                    }
                    else
                    {
                        if (joinInfo.RoundPosThickness)
                        {
                            inds.Add((UInt16)(indexStart + i + (flipArc ? 3 : 2)));
                            inds.Add((UInt16)(indexStart + i + (flipArc ? 2 : 3)));
                            inds.Add(innerCornerVertexIndex);
                        }
                        else
                        {
                            inds.Add((UInt16)(indexStart + i + (flipArc ? 3 : 2)));
                            inds.Add((UInt16)(indexStart + i + (flipArc ? 2 : 3)));
                            inds.Add(innerCornerVertexIndex);
                        }
                    }
                }

                // Manually add the last segment, maintain the expected vertex positioning
                int endingVerticesIndex = verts.Count;
                if (joinInfo.RoundPosThickness)
                {
                    verts.Add(joinInfo.PosThicknessStart);
                    verts.Add(joinInfo.InnerCornerVertex);
                }
                else
                {
                    verts.Add(joinInfo.InnerCornerVertex);
                    verts.Add(joinInfo.NegThicknessStart);
                }
                inds.Add((UInt16)(endingVerticesIndex - 1));
                inds.Add((UInt16)(endingVerticesIndex + 0));
                inds.Add(innerCornerVertexIndex);
            }
        }

        static void GenerateTip(BezierSegment segment, bool atStart, float t, PathEnding ending, float halfThickness, TessellationOptions tessellateOptions, List<Vector2> verts, List<UInt16> inds)
        {
            // The tip includes the vertices at the end itself
            Vector2 tan, nrm;
            var pos = VectorUtils.EvalFull(segment, t, out tan, out nrm);
            int indexStart = verts.Count;

            switch (ending)
            {
                case PathEnding.Chop:
                    if (atStart)
                    {
                        verts.Add(pos + nrm * halfThickness);
                        verts.Add(pos - nrm * halfThickness);
                    }
                    else
                    {
                        // Not much, path segments are always expected to be generated perpendicular to the path
                        // at the segment point location, so we don't have to do anything for the ending
                    }
                    break;

                case PathEnding.Square:
                    if (atStart)
                    {
                        verts.Add(pos + nrm * halfThickness - tan * halfThickness);
                        verts.Add(pos - nrm * halfThickness - tan * halfThickness);
                        verts.Add(pos + nrm * halfThickness);
                        verts.Add(pos - nrm * halfThickness);

                        inds.Add((UInt16)(indexStart + 0));
                        inds.Add((UInt16)(indexStart + 3));
                        inds.Add((UInt16)(indexStart + 1));
                        inds.Add((UInt16)(indexStart + 0));
                        inds.Add((UInt16)(indexStart + 2));
                        inds.Add((UInt16)(indexStart + 3));
                    }
                    else
                    {
                        // Relying on the last two vertices, and just adding two of our own here
                        verts.Add(pos + nrm * halfThickness + tan * halfThickness);
                        verts.Add(pos - nrm * halfThickness + tan * halfThickness);

                        inds.Add((UInt16)(indexStart + 0 - 2));
                        inds.Add((UInt16)(indexStart + 3 - 2));
                        inds.Add((UInt16)(indexStart + 1 - 2));
                        inds.Add((UInt16)(indexStart + 0 - 2));
                        inds.Add((UInt16)(indexStart + 2 - 2));
                        inds.Add((UInt16)(indexStart + 3 - 2));
                    }
                    break;

                case PathEnding.Round:
                    float arcSign = atStart ? -1 : 1;
                    int arcSegments = CalculateArcSteps(halfThickness, 0, Mathf.PI, tessellateOptions);
                    for (int i = 1; i < arcSegments; i++)
                    {
                        float angle = Mathf.PI * (i / (float)arcSegments);
                        verts.Add(pos + Matrix2D.RotateLH(angle) * nrm * halfThickness * arcSign);
                    }

                    if (atStart)
                    {
                        // Note how we maintain the last two vertices being setup for connection by the rest of the path vertices
                        int indexTipStart = verts.Count;
                        verts.Add(pos + nrm * halfThickness);
                        verts.Add(pos - nrm * halfThickness);

                        for (int i = 1; i < arcSegments; i++)
                        {
                            inds.Add((UInt16)(indexTipStart + 1));
                            inds.Add((UInt16)(indexStart + i - 1));
                            inds.Add((UInt16)(indexStart + i));
                        }
                    }
                    else
                    {
                        inds.Add((UInt16)(indexStart - 1));
                        inds.Add((UInt16)(indexStart - 2));
                        inds.Add((UInt16)(indexStart + 0));
                        for (int i = 1; i < arcSegments - 1; i++)
                        {
                            inds.Add((UInt16)(indexStart - 1));
                            inds.Add((UInt16)(indexStart + i - 1));
                            inds.Add((UInt16)(indexStart + i));
                        }
                    }
                    break;

                default:
                    System.Diagnostics.Debug.Assert(false); // Joining has its own function
                    break;
            }
        }

        static int CalculateArcSteps(float radius, float fromAngle, float toAngle, TessellationOptions tessellateOptions)
        {
            float stepDivisor = float.MaxValue;

            if (tessellateOptions.StepDistance != float.MaxValue)
                stepDivisor = tessellateOptions.StepDistance / radius;

            if (tessellateOptions.MaxCordDeviation != float.MaxValue)
            {
                float y = radius - tessellateOptions.MaxCordDeviation;
                float cordHalfLength = Mathf.Sqrt(radius * radius - y * y);
                float div = Mathf.Min(stepDivisor, Mathf.Asin(cordHalfLength / radius));
                if (div > VectorUtils.Epsilon)
                    stepDivisor = div;
            }

            if (tessellateOptions.MaxTanAngleDeviation < Mathf.PI * 0.5f)
                stepDivisor = Mathf.Min(stepDivisor, tessellateOptions.MaxTanAngleDeviation * 2.0f);

            float stepsInFullCircle = (Mathf.PI * 2.0f) / stepDivisor;
            float arcPercentage = Mathf.Abs(fromAngle - toAngle) / (Mathf.PI * 2.0f);
            return (int)Mathf.Max(stepsInFullCircle * arcPercentage + 0.5f, 3); // Never less than 3 segments
        }

        /// <summary>Tessellates a rectangle.</summary>
        /// <param name="rect">Rectangle to tessellate</param>
        /// <param name="vertices">The output vertices</param>
        /// <param name="indices">The output triangles</param>
        public static void TessellateRect(Rect rect, out Vector2[] vertices, out UInt16[] indices)
        {
            vertices = new Vector2[] {
                new Vector2(rect.xMin, rect.yMin),
                new Vector2(rect.xMax, rect.yMin),
                new Vector2(rect.xMax, rect.yMax),
                new Vector2(rect.xMin, rect.yMax)
            };
            indices = new UInt16[] {
                1, 0, 2, 2, 0, 3
            };
        }

        /// <summary>Tessellates a rectangle border.</summary>
        /// <param name="rect">Rectangle to tessellate</param>
        /// <param name="halfThickness">The half-thickness of the border</param>
        /// <param name="vertices">The output vertices</param>
        /// <param name="indices">The output triangles</param>
        public static void TessellateRectBorder(Rect rect, float halfThickness, out Vector2[] vertices, out UInt16[] indices)
        {
            var verts = new List<Vector2>(16);
            var inds = new List<UInt16>(24);

            // Left edge
            var p0 = new Vector2(rect.x, rect.y + rect.height);
            var p1 = new Vector2(rect.x, rect.y);

            var q0 = p0 + new Vector2(-halfThickness, halfThickness);
            var q1 = p1 + new Vector2(-halfThickness, -halfThickness);
            var q2 = p1 + new Vector2(halfThickness, halfThickness);
            var q3 = p0 + new Vector2(halfThickness, -halfThickness);

            verts.Add(q0); verts.Add(q1); verts.Add(q2); verts.Add(q3);
            inds.Add(0); inds.Add(3); inds.Add(2); inds.Add(2); inds.Add(1); inds.Add(0);

            // Top edge
            p0 = new Vector2(rect.x, rect.y);
            p1 = new Vector2(rect.x + rect.width, rect.y);

            q0 = p0 + new Vector2(-halfThickness, -halfThickness);
            q1 = p1 + new Vector2(halfThickness, -halfThickness);
            q2 = p1 + new Vector2(-halfThickness, halfThickness);
            q3 = p0 + new Vector2(halfThickness, halfThickness);

            verts.Add(q0); verts.Add(q1); verts.Add(q2); verts.Add(q3);
            inds.Add(4); inds.Add(7); inds.Add(6); inds.Add(6); inds.Add(5); inds.Add(4);

            // Right edge
            p0 = new Vector2(rect.x + rect.width, rect.y);
            p1 = new Vector2(rect.x + rect.width, rect.y + rect.height);

            q0 = p0 + new Vector2(halfThickness, -halfThickness);
            q1 = p1 + new Vector2(halfThickness, halfThickness);
            q2 = p1 + new Vector2(-halfThickness, -halfThickness);
            q3 = p0 + new Vector2(-halfThickness, halfThickness);

            verts.Add(q0); verts.Add(q1); verts.Add(q2); verts.Add(q3);
            inds.Add(8); inds.Add(11); inds.Add(10); inds.Add(10); inds.Add(9); inds.Add(8);

            // Bottom edge
            p0 = new Vector2(rect.x + rect.width, rect.y + rect.height);
            p1 = new Vector2(rect.x, rect.y + rect.height);

            q0 = p0 + new Vector2(halfThickness, halfThickness);
            q1 = p1 + new Vector2(-halfThickness, halfThickness);
            q2 = p1 + new Vector2(halfThickness, -halfThickness);
            q3 = p0 + new Vector2(-halfThickness, -halfThickness);

            verts.Add(q0); verts.Add(q1); verts.Add(q2); verts.Add(q3);
            inds.Add(12); inds.Add(15); inds.Add(14); inds.Add(14); inds.Add(13); inds.Add(12);

            vertices = verts.ToArray();
            indices = inds.ToArray();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorTessellation.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorUtils.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bc6ce72ebfec4b24faaee0fa9df6a984
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    /// <summary>
    /// Provides various tools to work with vector graphics.
    /// </summary>
    public static partial class VectorUtils
    {
        /// <summary>A small value used everywhere by the vector graphics package.</summary>
        public static readonly float Epsilon = 0.000001f;

        /// <summary>Convert a segments into a path.</summary>
        /// <param name="segment">The BezierSegment</param>
        /// <returns>An array of two path segments</returns>
        /// <remarks>The second path segment will hold the ending position of the curve.</remarks>
        public static BezierPathSegment[] BezierSegmentToPath(BezierSegment segment)
        {
            return new BezierPathSegment[] {
                new BezierPathSegment() { P0 = segment.P0, P1 = segment.P1, P2 = segment.P2 },
                new BezierPathSegment() { P0 = segment.P3 }
            };
        }

        /// <summary>Converts an array of BezierSegments into a connected path.</summary>
        /// <param name="segments">An array of BezierSegment</param>
        /// <returns>An array of path segments</returns>
        /// <remarks>If two consecutive segments are disconnected, a straight line will be added between the two endpoints.</remarks>
        public static BezierPathSegment[] BezierSegmentsToPath(BezierSegment[] segments)
        {
            if (segments.Count() == 0)
                return new BezierPathSegment[0];

            int segmentCount = segments.Length;
            var path = new List<BezierPathSegment>(segments.Length*2 + 1);
            for (int i = 0; i < segmentCount; ++i)
            {
                var seg = segments[i];
                path.Add(new BezierPathSegment() { P0 = seg.P0, P1 = seg.P1, P2 = seg.P2 });

                if (i == (segmentCount-1))
                {
                    // Last segment, close the path
                    path.Add(new BezierPathSegment() { P0 = seg.P3 });
                }
                else
                {
                    // Check for connectivity, insert path to connect the endpoints when needed
                    var nextSeg = segments[i+1];
                    if (seg.P3 != nextSeg.P0)
                    {
                        var line = VectorUtils.MakeLine(seg.P3, nextSeg.P0);
                        path.Add(new BezierPathSegment() { P0 = line.P0, P1 = line.P1, P2 = line.P2 });
                    }
                }
            }

            return path.ToArray();
        }

        /// <summary>
        /// Computes the BezierSegment at a given index from a list of BezierPathSegments.
        /// </summary>
        /// <param name="path">The chain of BezierPathSegments</param>
        /// <param name="index">The segment index</param>
        /// <returns>The BezierSegment at the given index</returns>
        public static BezierSegment PathSegmentAtIndex(IList<BezierPathSegment> path, int index)
        {
            if (index < 0 || index >= (path.Count-1))
                throw new IndexOutOfRangeException("Invalid index passed to PathSegmentAtIndex");

            return new BezierSegment() { P0 = path[index].P0, P1 = path[index].P1, P2 = path[index].P2, P3 = path[index + 1].P0 };
        }

        /// <summary>
        /// Checks if the two ends of a BezierPathSegment chain are at the same location.
        /// </summary>
        /// <param name="path">The chain of BezierPathSegments</param>
        /// <returns>True if the two ends of the chain are at the same location, false otherwise</returns>
        public static bool PathEndsPerfectlyMatch(IList<BezierPathSegment> path)
        {
            if (path.Count < 2)
                return false;

            if ((path[0].P0 - path[path.Count - 1].P0).sqrMagnitude > Epsilon)
                return false;

            return true;
        }

        /// <summary>Builds a rectangle shape.</summary>
        /// <param name="rectShape">The shape object that will be filled with a rectangle.</param>
        /// <param name="rect">The position and dimensions of the rectangle.</param>
        public static void MakeRectangleShape(Shape rectShape, Rect rect)
        {
            MakeRectangleShape(rectShape, rect, Vector2.zero, Vector2.zero, Vector2.zero, Vector2.zero);
        }

        /// <summary>Builds a rectangle shape.</summary>
        /// <param name="rectShape">The shape object that will be filled with a rectangle.</param>
        /// <param name="rect">The position and dimensions of the rectangle.</param>
        /// <param name="radiusTL">The top-left radius of the rectangle</param>
        /// <param name="radiusTR">The top-right radius of the rectangle</param>
        /// <param name="radiusBR">The bottom-right radius of the rectangle</param>
        /// <param name="radiusBL">The bottom-left radius of the rectangle</param>
        public static void MakeRectangleShape(Shape rectShape, Rect rect, Vector2 radiusTL, Vector2 radiusTR, Vector2 radiusBR, Vector2 radiusBL)
        {
            var contour = BuildRectangleContour(rect, radiusTL, radiusTR, radiusBR, radiusBL);
            if (rectShape.Contours == null || rectShape.Contours.Length != 1)
                rectShape.Contours = new BezierContour[1];
            rectShape.Contours[0] = contour;
            rectShape.IsConvex = true;
        }

        /// <summary>Builds an ellipse shape.</summary>
        /// <param name="ellipseShape">The shape object that will be filled with an ellipse.</param>
        /// <param name="pos">The position of the circle, relative to its center.</param>
        /// <param name="radiusX">The x component of the radius of the circle.</param>
        /// <param name="radiusY">The y component of the radius of the circle.</param>
        public static void MakeEllipseShape(Shape ellipseShape, Vector2 pos, float radiusX, float radiusY)
        {
            var rect = new Rect(pos.x-radiusX, pos.y-radiusY, radiusX+radiusX, radiusY+radiusY);
            var rad = new Vector2(radiusX, radiusY);
            MakeRectangleShape(ellipseShape, rect, rad, rad, rad, rad);
        }

        /// <summary>Builds a circle shape.</summary>
        /// <param name="circleShape">The shape object that will be filled with a circle.</param>
        /// <param name="pos">The position of the circle, relative to its center.</param>
        /// <param name="radius">The radius of the circle.</param>
        public static void MakeCircleShape(Shape circleShape, Vector2 pos, float radius)
        {
            MakeEllipseShape(circleShape, pos, radius, radius);
        }

        /// <summary>Computes the bounds of a bezier path.</summary>
        /// <param name="path">The path to compute the bounds from</param>
        /// <returns>A Rect containing the axis-aligned bounding-box of the contour</returns>
        public static Rect Bounds(BezierPathSegment[] path)
        {
            var min = new Vector2(float.MaxValue, float.MaxValue);
            var max = new Vector2(-float.MaxValue, -float.MaxValue);
            foreach (var s in VectorUtils.SegmentsInPath(path))
            {
                Vector2 segMin, segMax;
                Bounds(s, out segMin, out segMax);
                min = Vector2.Min(min, segMin);
                max = Vector2.Max(max, segMax);
            }
            return (min.x != float.MaxValue) ? new Rect(min, max - min) : Rect.zero;
        }

        /// <summary>Computes the bounds of a list of vertices.</summary>
        /// <param name="vertices">The list of vertices to compute the bounds from</param>
        /// <returns>A Rect containing the axis-aligned bounding-box of the vertices</returns>
        public static Rect Bounds(IEnumerable<Vector2> vertices)
        {
            var min = new Vector2(float.MaxValue, float.MaxValue);
            var max = new Vector2(-float.MaxValue, -float.MaxValue);
            foreach (var v in vertices)
            {
                min = Vector2.Min(min, v);
                max = Vector2.Max(max, v);
            }
            return (min.x != float.MaxValue) ? new Rect(min, max - min) : Rect.zero;
        }

        /// <summary>Builds a line segment.</summary>
        /// <param name="from">The starting position of the line segment</param>
        /// <param name="to">The ending position of the line segment</param>
        /// <returns>A straight line BezierSegment</returns>
        /// <remarks>The control points are spaced out equally to maintain a constant speed on t</remarks>
        public static BezierSegment MakeLine(Vector2 from, Vector2 to)
        {
            return new BezierSegment()
            {
                P0 = from,
                P1 = (to - from) / 3.0f + from,
                P2 = (to - from) * 2.0f / 3.0f + from,
                P3 = to
            };
        }

        /// <summary>Converts a quadratic bezier to a cubic bezier</summary>
        /// <param name="p0">The starting position of the quadratic segment</param>
        /// <param name="p1">The control position of the quadratic segment</param>
        /// <param name="p2">The ending position of the quadratic segment</param>
        /// <returns>The resulting BezierSegment</returns>
        public static BezierSegment QuadraticToCubic(Vector2 p0, Vector2 p1, Vector2 p2)
        {
            var p = p1;
            var t = 2.0f / 3.0f;
            return new BezierSegment() {
                P0 = p0,
                P1 = p0 + t * (p - p0),
                P2 = p2 + t * (p - p2),
                P3 = p2,
            };
        }

        /// <summary>Builds a line path segment.</summary>
        /// <param name="from">The starting position of the line segment</param>
        /// <param name="to">The ending position of the line segment</param>
        /// <returns>A BezierPathSegment array of two elements, configured in a straight line</returns>
        /// <remarks>The control points are spaced out equally to maintain a constant speed on t</remarks>
        public static BezierPathSegment[] MakePathLine(Vector2 from, Vector2 to)
        {
            return new BezierPathSegment[] {
                new BezierPathSegment() { P0 = from, P1 = (to - from) / 3.0f + from, P2 = (to - from) * 2.0f / 3.0f + from },
                new BezierPathSegment() { P0 = to }
            };
        }

        internal static BezierSegment MakeArcQuarter(Vector2 center, float startAngleRads, float sweepAngleRads)
        {
            // Approximation adapted from http://spencermortensen.com/articles/bezier-circle/
            float s = Mathf.Sin(sweepAngleRads);
            float c = Mathf.Cos(sweepAngleRads);
            Matrix2D m = Matrix2D.RotateLH(startAngleRads);
            m.m02 = center.x;
            m.m12 = center.y;
            float f = 0.551915024494f;
            return new BezierSegment()
            {
                P0 = m * new Vector2(1, 0),
                P1 = m * new Vector2(1, f),
                P2 = m * new Vector2(c + f * s, s),
                P3 = m * new Vector2(c, s)
            };
        }

        /// <summary>Approximates a circle arc with up to 4 segments.</summary>
        /// <param name="center">The center of the arc</param>
        /// <param name="startAngleRads">The starting angle of the arc, in radians</param>
        /// <param name="sweepAngleRads">The "length" of the arc, in radians</param>
        /// <param name="radius">The radius of the arc</param>
        /// <returns>An array of up to four BezierSegments holding the arc</returns>
        public static BezierPathSegment[] MakeArc(Vector2 center, float startAngleRads, float sweepAngleRads, float radius)
        {
            bool shouldFlip = false;
            if (sweepAngleRads < 0.0f)
            {
                startAngleRads += sweepAngleRads;
                sweepAngleRads = -sweepAngleRads;
                shouldFlip = true;
            }

            sweepAngleRads = Mathf.Min(sweepAngleRads, Mathf.PI * 2);

            BezierSegment subSeg1;
            BezierSegment subSeg2;

            var segments = new List<BezierSegment>();
            int endQuadrant = QuadrantAtAngle(sweepAngleRads);

            for (int quadrant = 0; quadrant <= endQuadrant; ++quadrant)
            {
                var seg = ArcSegmentForQuadrant(quadrant);

                // Check if we need to split the segment
                var p0 = Vector2.zero;
                var p1 = new Vector2(2.0f, 0.0f);
                var intersects = FindBezierLineIntersections(seg, p0, p1);
                if (quadrant != 3 && intersects.Length > 0)
                {
                    VectorUtils.SplitSegment(seg, intersects[0], out subSeg1, out subSeg2);
                    seg = subSeg2;
                }

                p1 = new Vector2(Mathf.Cos(sweepAngleRads), Mathf.Sin(sweepAngleRads)) * 2.0f;
                intersects = FindBezierLineIntersections(seg, p0, p1);
                if (intersects.Length > 0)
                {
                    VectorUtils.SplitSegment(seg, intersects[0], out subSeg1, out subSeg2);
                    seg = subSeg1;
                }

                if (!VectorUtils.IsEmptySegment(seg))
                    segments.Add(seg);
            }

            for (int i = 0; i < segments.Count; ++i)
                segments[i] = TransformSegment(segments[i], center, -startAngleRads, Vector2.one * radius);

            if (shouldFlip)
            {
                // Path is reversed, so we should flip it now
                for (int i = 0; i < segments.Count / 2; ++i)
                {
                    int j = segments.Count - i - 1;
                    var seg0 = VectorUtils.FlipSegment(segments[i]);
                    var seg1 = VectorUtils.FlipSegment(segments[j]);
                    segments[i] = seg1;
                    segments[j] = seg0;
                }
                if ((segments.Count % 2) == 1)
                {
                    int i = segments.Count / 2;
                    segments[i] = VectorUtils.FlipSegment(segments[i]);
                }
            }

            return VectorUtils.BezierSegmentsToPath(segments.ToArray());
        }

        internal static int QuadrantAtAngle(float angle)
        {
            angle = angle % (Mathf.PI * 2);
            if (angle < 0.0f)
                angle = Mathf.PI * 2 + angle;
            if (angle <= Mathf.PI / 2.0f)
                return 0;
            else if (angle <= Mathf.PI)
                return 1;
            else if (angle <= Mathf.PI / 2.0f * 3.0f)
                return 2;
            else
                return 3;
        }

        internal static BezierSegment ArcSegmentForQuadrant(int quadrant)
        {
            switch (quadrant)
            {
                case 0: return VectorUtils.MakeArcQuarter(Vector2.zero, 0.0f, Mathf.PI / 2.0f);
                case 1: return VectorUtils.MakeArcQuarter(Vector2.zero, -Mathf.PI / 2.0f, Mathf.PI / 2.0f);
                case 2: return VectorUtils.MakeArcQuarter(Vector2.zero, -Mathf.PI, Mathf.PI / 2.0f);
                case 3: return VectorUtils.MakeArcQuarter(Vector2.zero, -Mathf.PI / 2.0f * 3.0f, Mathf.PI / 2.0f);
                default: return new BezierSegment();
            }
        }

        /// <summary>Flips a segment direction.</summary>
        /// <param name="segment">The segment to flip</param>
        /// <returns>The flipped segment</returns>
        public static BezierSegment FlipSegment(BezierSegment segment)
        {
            var s = segment;

            var tmp = s.P0;
            s.P0 = s.P3;
            s.P3 = tmp;

            tmp = s.P1;
            s.P1 = s.P2;
            s.P2 = tmp;

            return s;
        }

        /// <summary>Computes the bounds of a segment.</summary>
        /// <param name="segment">The segment to flip</param>
        /// <param name="min">The output min value of the segment</param>
        /// <param name="max">The output max value of the segment</param>
        public static void Bounds(BezierSegment segment, out Vector2 min, out Vector2 max)
        {
            min = Vector2.Min(segment.P0, segment.P3);
            max = Vector2.Max(segment.P0, segment.P3);

            Vector2 a = 3.0f * segment.P3 - 9.0f * segment.P2 + 9.0f * segment.P1 - 3.0f * segment.P0;
            Vector2 b = 6.0f * segment.P2 - 12.0f * segment.P1 + 6.0f * segment.P0;
            Vector2 c = 3.0f * segment.P1 - 3.0f * segment.P0;

            float[] solutions = new float[4];
            SolveQuadratic(a.x, b.x, c.x, out solutions[0], out solutions[1]);
            SolveQuadratic(a.y, b.y, c.y, out solutions[2], out solutions[3]);
            foreach (var s in solutions)
            {
                if (float.IsNaN(s) || (s < 0.0f) || (s > 1.0f))
                    continue;
                Vector2 v = Eval(segment, s);
                min = Vector2.Min(min, v);
                max = Vector2.Max(max, v);
            }
        }

        /// <summary>Evaluates the position on a curve segment.</summary>
        /// <param name="segment">The curve segment on which to evaluate the position</param>
        /// <param name="t">The parametric location on the curve</param>
        /// <returns>The position on the curve at parametric location "t"</returns>
        public static Vector2 Eval(BezierSegment segment, float t)
        {
            float t2 = t * t;
            float t3 = t2 * t;
            return
                (segment.P3 - 3.0f * segment.P2 + 3.0f * segment.P1 - segment.P0) * t3
                + (3.0f * segment.P2 - 6.0f * segment.P1 + 3.0f * segment.P0) * t2
                + (3.0f * segment.P1 - 3.0f * segment.P0) * t
                + segment.P0;
        }

        /// <summary>Evaluates the tangent on a curve segment.</summary>
        /// <param name="segment">The curve segment on which to evaluate the tangent</param>
        /// <param name="t">The parametric location on the curve</param>
        /// <returns>The tangent of the curve at parametric location "t"</returns>
        public static Vector2 EvalTangent(BezierSegment segment, float t)
        {
            var tan = (segment.P3 - 3.0f * segment.P2 + 3.0f * segment.P1 - segment.P0) * 3.0f * t * t
                + (3.0f * segment.P2 - 6.0f * segment.P1 + 3.0f * segment.P0) * 2.0f * t
                + (3.0f * segment.P1 - 3.0f * segment.P0);

            // If the result is a zero vector (happens at coincident p0 and p1 or p2 and p3) try again by manual stepping
            if (tan.sqrMagnitude < Epsilon)
            {
                if (t > 0.5f)
                    tan = Eval(segment, t) - Eval(segment, t - 0.01f);
                else tan = Eval(segment, t + 0.01f) - Eval(segment, t);
            }
            return tan.normalized;
        }

        /// <summary>Evalutes the normal on a curve segment.</summary>
        /// <param name="segment">The curve segment on which to evaluate the normal</param>
        /// <param name="t">The parametric location on the curve</param>
        /// <returns>The normal of the curve at parametric location "t"</returns>
        /// <remarks>
        /// A positive normal at a point on the bezier curve is always on the
        /// right side of the forward direction (tangent) of the curve at that point.
        /// </remarks>
        public static Vector2 EvalNormal(BezierSegment segment, float t)
        {
            return Vector2.Perpendicular(EvalTangent(segment, t));
        }

        /// <summary>Evalutes both the position and tangent on a curve segment.</summary>
        /// <param name="segment">The curve segment on which to evaluate the normal</param>
        /// <param name="t">The parametric location on the curve</param>
        /// <param name="tangent">The output tangent at parametric location "t"</param>
        /// <returns>The position on the curve at parametric location "t"</returns>
        /// <remarks>
        /// This is more efficient than calling "Eval" and "EvalTangent" successively.
        /// </remarks>
        public static Vector2 EvalFull(BezierSegment segment, float t, out Vector2 tangent)
        {
            float t2 = t * t;
            float t3 = t2 * t;
            Vector2 C1 = segment.P3 - 3.0f * segment.P2 + 3.0f * segment.P1 - segment.P0;
            Vector2 C2 = 3.0f * segment.P2 - 6.0f * segment.P1 + 3.0f * segment.P0;
            Vector2 C3 = 3.0f * segment.P1 - 3.0f * segment.P0;
            Vector2 C4 = segment.P0;

            var pos = C1 * t3 + C2 * t2 + C3 * t + C4;
            tangent = ((3.0f * C1 * t2) + (2.0f * C2 * t) + C3);

            // If the result is a zero vector (happens at coincident p0 and p1 or p2 and p3) try again by manual stepping
            if (tangent.sqrMagnitude < Epsilon)
            {
                if (t > 0.5f)
                    tangent = pos - Eval(segment, t - 0.01f);
                else tangent = Eval(segment, t + 0.01f) - pos;
            }

            tangent = tangent.normalized;
            return pos;
        }

        /// <summary>Evalutes the position, tangent and normal on a curve segment.</summary>
        /// <param name="segment">The curve segment on which to evaluate the normal</param>
        /// <param name="t">The parametric location on the curve</param>
        /// <param name="tangent">The output tangent at parametric location "t"</param>
        /// <param name="normal">The output normal at parametric location "t"</param>
        /// <returns>The position on the curve at parametric location "t"</returns>
        /// <remarks>
        /// This is more efficient than calling "Eval", "EvalTangent" and "EvalNormal" successively.
        /// </remarks>
        public static Vector2 EvalFull(BezierSegment segment, float t, out Vector2 tangent, out Vector2 normal)
        {
            Vector2 pos = EvalFull(segment, t, out tangent);
            normal = Vector2.Perpendicular(tangent);
            return pos;
        }

        /// <summary>Computes the individual lengths of a segment chain.</summary>
        /// <param name="segments">The segments on which to compute the lengths</param>
        /// <param name="closed">A boolean indicating if the length of the segment joining the first and last points should be computed</param>
        /// <param name="precision">The precision of the lengths computation</param>
        /// <returns>An array containing the lenghts of the segments</returns>
        public static float[] SegmentsLengths(IList<BezierPathSegment> segments, bool closed, float precision = 0.001f)
        {
            float[] segmentLengths = new float[segments.Count - 1 + (closed ? 1 : 0)];
            int i = 0;
            foreach (var segment in SegmentsInPath(segments, closed))
                segmentLengths[i++] = SegmentLength(segment, precision);
            return segmentLengths;
        }

        /// <summary>Computes the combined length of a segment chain.</summary>
        /// <param name="segments">The curve segments on which to evaluate the length</param>
        /// <param name="closed">A boolean indicating if the length of the segment joining the first and last points should be computed</param>
        /// <param name="precision">The precision of the length computation</param>
        /// <returns>The combined length of the segment chain</returns>
        public static float SegmentsLength(IList<BezierPathSegment> segments, bool closed, float precision = 0.001f)
        {
            if (segments.Count < 2)
                return 0.0f;

            float length = 0.0f;
            foreach (var segment in SegmentsInPath(segments))
                length += SegmentLength(segment, precision);
            if (closed)
                length += (segments[segments.Count - 1].P0 - segments[0].P0).magnitude;
            return length;
        }

        /// <summary>Computes the length of a single curve segment.</summary>
        /// <param name="segment">The curve segment on which to evaluate the length</param>
        /// <param name="precision">The precision of the length computation</param>
        /// <returns>The length of the segment</returns>
        public static float SegmentLength(BezierSegment segment, float precision = 0.001f)
        {
            // This adaptive algorithm doesn't behave well at the limit of float precision,
            // so we revert to a dummy iterative approach in this case
            if (VectorUtils.HasLargeCoordinates(segment))
            {
                int steps = Math.Min(100, (int)(1.0f/precision));
                return SegmentLengthIterative(segment, steps);
            }

            float tmax = 0.0f;
            float length = 0.0f;
            while ((tmax = AdaptiveQuadraticApproxSplitPoint(segment, precision)) < 1.0f)
            {
                BezierSegment b1, b2;
                SplitSegment(segment, tmax, out b1, out b2);
                float midPointLength = MidPointQuadraticApproxLength(b1);
                if (float.IsNaN(midPointLength)) // Could happen because of float precision issues
                    midPointLength = SegmentLengthIterative(b1);
                length += midPointLength;
                segment = b2;
            }
            length += MidPointQuadraticApproxLength(segment);
            return length;
        }

        internal static float SegmentLengthIterative(BezierSegment segment, int steps = 10)
        {
            if (steps <= 2)
                return (segment.P3 - segment.P0).magnitude;

            float length = 0.0f;
            var p = segment.P0;
            for (int i = 1; i <= steps; ++i)
            {
                float t = (float)i/steps;
                var q = VectorUtils.Eval(segment, t);
                length += (q-p).magnitude;
                p = q;
            }
            return length;
        }

        internal static bool HasLargeCoordinates(BezierSegment segment)
        {
            const float kMaxCoord = 10000.0f;
            return
                segment.P0.x > kMaxCoord || segment.P0.y > kMaxCoord ||
                segment.P1.x > kMaxCoord || segment.P1.y > kMaxCoord ||
                segment.P2.x > kMaxCoord || segment.P2.y > kMaxCoord ||
                segment.P3.x > kMaxCoord || segment.P3.y > kMaxCoord;
        }

        static float AdaptiveQuadraticApproxSplitPoint(BezierSegment segment, float precision)
        {
            float quadraticApproxDist = (segment.P3 - 3.0f * segment.P2 + 3.0f * segment.P1 - segment.P0).magnitude * 0.5f;
            return Mathf.Pow((18.0f / Mathf.Sqrt(3.0f)) * precision / quadraticApproxDist, 1.0f / 3.0f);
        }

        static float MidPointQuadraticApproxLength(BezierSegment segment)
        {
            var A = segment.P0;
            var B = (3.0f * segment.P2 - segment.P3 + 3.0f * segment.P1 - segment.P0) / 4.0f;
            var C = segment.P3;

            if (A == C)
                return (A == B) ? 0.0f : (A - B).magnitude;

            if (B == A || B == C)
                return (A - C).magnitude;

            var A0 = B - A;
            var A1 = A - 2.0f * B + C;

            if (A1 != Vector2.zero)
            {
                double c = 4.0f * Vector2.Dot(A1, A1);
                double b = 8.0f * Vector2.Dot(A0, A1);
                double a = 4.0f * Vector2.Dot(A0, A0);
                double q = 4.0f * a * c - b * b;

                double twoCpB = 2.0f * c + b;
                double sumCBA = c + b + a;

                var l0 = (0.25f / c) * (twoCpB * Math.Sqrt(sumCBA) - b * Math.Sqrt(a));
                if (Math.Abs(q) <= VectorUtils.Epsilon)
                    return (float)l0;

                var l1 = (q / (8.0f * Math.Pow(c, 1.5f))) * (Math.Log(2.0f * Math.Sqrt(c * sumCBA) + twoCpB) - Math.Log(2.0f * Math.Sqrt(c * a) + b));
                return (float)(l0 + l1);
            }
            else return 2.0f * A0.magnitude;
        }

        /// <summary>Splits a curve segment at a given parametric location.</summary>
        /// <param name="segment">The curve segment to split</param>
        /// <param name="t">The parametric location at which the segment will be split</param>
        /// <param name="b1">The output of the first segment</param>
        /// <param name="b2">The output of the second segment</param>
        public static void SplitSegment(BezierSegment segment, float t, out BezierSegment b1, out BezierSegment b2)
        {
            var a = Vector2.LerpUnclamped(segment.P0, segment.P1, t);
            var b = Vector2.LerpUnclamped(segment.P1, segment.P2, t);
            var c = Vector2.LerpUnclamped(segment.P2, segment.P3, t);
            var m = Vector2.LerpUnclamped(a, b, t);
            var n = Vector2.LerpUnclamped(b, c, t);
            var p = Eval(segment, t);

            b1 = new BezierSegment() { P0 = segment.P0, P1 = a, P2 = m, P3 = p };
            b2 = new BezierSegment() { P0 = p, P1 = n, P2 = c, P3 = segment.P3 };
        }

        /// <summary>Transforms a curve segment by a translation, rotation and scaling.</summary>
        /// <param name="segment">The curve segment to transform</param>
        /// <param name="translation">The translation to apply on the curve segment</param>
        /// <param name="rotation">The rotation to apply on the curve segment</param>
        /// <param name="scaling">The scaling to apply on the curve segment</param>
        /// <returns>The transformed curve segment</returns>
        public static BezierSegment TransformSegment(BezierSegment segment, Vector2 translation, float rotation, Vector2 scaling)
        {
            var m = Matrix2D.RotateLH(rotation);
            var newSeg = new BezierSegment() {
                P0 = m * Vector2.Scale(segment.P0, scaling) + translation,
                P1 = m * Vector2.Scale(segment.P1, scaling) + translation,
                P2 = m * Vector2.Scale(segment.P2, scaling) + translation,
                P3 = m * Vector2.Scale(segment.P3, scaling) + translation
            };
            return newSeg;
        }

        /// <summary>Transforms a curve segment by a transformation matrix.</summary>
        /// <param name="segment">The curve segment to transform</param>
        /// <param name="matrix">The transformation matrix to apply on the curve segment</param>
        /// <returns>The transformed curve segment</returns>
        public static BezierSegment TransformSegment(BezierSegment segment, Matrix2D matrix)
        {
            var newSeg = new BezierSegment() {
                P0 = matrix * segment.P0,
                P1 = matrix * segment.P1,
                P2 = matrix * segment.P2,
                P3 = matrix * segment.P3
            };
            return newSeg;
        }

        /// <summary>Transforms a path by a transformation matrix.</summary>
        /// <param name="path">The path to transform</param>
        /// <param name="translation">The translation to apply</param>
        /// <param name="rotation">The rotation to apply, in radians</param>
        /// <param name="scaling">The scaling to apply</param>
        /// <returns>The transformed path</returns>
        public static BezierPathSegment[] TransformBezierPath(BezierPathSegment[] path, Vector2 translation, float rotation, Vector2 scaling)
        {
            var m = Matrix2D.RotateLH(rotation);
            var newPath = new BezierPathSegment[path.Length];
            for (int i = 0; i < newPath.Length; ++i)
            {
                var seg = path[i];
                newPath[i] = new BezierPathSegment()
                {
                    P0 = m * Vector2.Scale(seg.P0, scaling) + translation,
                    P1 = m * Vector2.Scale(seg.P1, scaling) + translation,
                    P2 = m * Vector2.Scale(seg.P2, scaling) + translation
                };
            }
            return newPath;
        }

        /// <summary>Transforms a path by a transformation matrix.</summary>
        /// <param name="path">The path to transform</param>
        /// <param name="matrix">The transformation matrix to apply on the curve segment</param>
        /// <returns>The transformed path</returns>
        public static BezierPathSegment[] TransformBezierPath(BezierPathSegment[] path, Matrix2D matrix)
        {
            var newPath = new BezierPathSegment[path.Length];
            for (int i = 0; i < newPath.Length; ++i)
            {
                var seg = path[i];
                newPath[i] = new BezierPathSegment() {
                    P0 = matrix * seg.P0,
                    P1 = matrix * seg.P1,
                    P2 = matrix * seg.P2
                };
            }
            return newPath;
        }

        /// <summary>Lists every nodes under a root node.</summary>
        /// <param name="root">The root node</param>
        /// <returns>The enumerable listing every nodes under "root", including the root itself.</returns>
        public static IEnumerable<SceneNode> SceneNodes(SceneNode root)
        {
            yield return root;
            if (root.Children != null)
            {
                foreach (var c in root.Children)
                {
                    foreach (var n in SceneNodes(c))
                        yield return n;
                }
            }
        }

        /// <summary>Structure holding the SceneNode computed transforms, opacities and enumeration path.</summary>
        /// <remarks>This helper structure is used by the WorldTransformedSceneNodes method.</remarks>
        public struct SceneNodeWorldTransform
        {
            /// <summary>The node we are currently visiting.</summary>
            public SceneNode Node;

            /// <summary>The parent of the node we are currently visiting.</summary>
            public SceneNode Parent;

            /// <summary>The accumulated world transform of this node.</summary>
            public Matrix2D WorldTransform;

            /// <summary>The accumulated world opacity of this node.</summary>
            public float WorldOpacity;
        }

        static IEnumerable<SceneNodeWorldTransform> WorldTransformedSceneNodes(SceneNode child, Dictionary<SceneNode, float> nodeOpacities, SceneNodeWorldTransform parent)
        {
            var childOpacity = 1.0f;
            if (nodeOpacities == null || !nodeOpacities.TryGetValue(child, out childOpacity))
                childOpacity = 1.0f;

            var childWorldTransform = new SceneNodeWorldTransform()
            {
                Node = child,
                WorldTransform = parent.WorldTransform * child.Transform,
                WorldOpacity = parent.WorldOpacity * childOpacity,
                Parent = parent.Node
            };

            yield return childWorldTransform;

            if (child.Children != null)
            {
                foreach (var c in child.Children)
                {
                    foreach (var n in WorldTransformedSceneNodes(c, nodeOpacities, childWorldTransform))
                        yield return n;
                }
            }
        }

        /// <summary>Iterates through every nodes under a root with computed transform and opacities.</summary>
        /// <param name="root">The starting node of the hierarchy</param>
        /// <param name="nodeOpacities">Storage for the resulting node opacities, may be null</param>
        /// <returns>An enumeration of every node with their pre-computed world transforms, opacities and paths.</returns>
        public static IEnumerable<SceneNodeWorldTransform> WorldTransformedSceneNodes(SceneNode root, Dictionary<SceneNode, float> nodeOpacities)
        {
            var rootNodeWorldTransform = new SceneNodeWorldTransform() {
                Node = root,
                WorldTransform = Matrix2D.identity,
                WorldOpacity = 1,
                Parent = null
            };
            return WorldTransformedSceneNodes(root, nodeOpacities, rootNodeWorldTransform);
        }

        /// <summary>Realigns the vertices (in-place) inside their axis-aligned bounding-box.</summary>
        /// <param name="vertices">The vertices to realign</param>
        /// <param name="bounds">The bounds into which the vertices will be realigned</param>
        /// <param name="flip">A boolean indicating whether to flip the coordinates on the Y axis</param>
        public static void RealignVerticesInBounds(IList<Vector2> vertices, Rect bounds, bool flip)
        {
            var p = bounds.position;
            var h = bounds.height;
            for (int i = 0; i < vertices.Count; ++i)
            {
                var v = vertices[i];
                v -= p;
                if (flip)
                    v.y = h - v.y;
                vertices[i] = v;
            }
        }

        /// <summary>Flip the vertices (in-place) inside their axis-aligned bounding-box.</summary>
        /// <param name="vertices">The vertices to realign</param>
        /// <param name="bounds">The bounds into which the vertices will be realigned</param>
        public static void FlipVerticesInBounds(IList<Vector2> vertices, Rect bounds)
        {
            var h = bounds.height;
            for (int i = 0; i < vertices.Count; ++i)
            {
                var v = vertices[i];
                v.y = h - v.y;
                vertices[i] = v;
            }
        }

        internal static void ClampVerticesInBounds(IList<Vector2> vertices, Rect bounds)
        {
            for (int i = 0; i < vertices.Count; ++i)
                vertices[i] = Vector2.Max(bounds.min, Vector2.Min(bounds.max, vertices[i]));
        }

        /// <summary>Iterates through every segment in a list of path segments.</summary>
        /// <param name="segments">The path segments to iterate from</param>
        /// <param name="closed">Whether to return the segment connecting the last point to the beginning of the path</param>
        /// <returns>An enumerable of every segments in the path</returns>
        public static IEnumerable<BezierSegment> SegmentsInPath(IEnumerable<BezierPathSegment> segments, bool closed = false)
        {
            var e = segments.GetEnumerator();
            if (!e.MoveNext())
                yield break;

            var s1 = e.Current;
            if (!e.MoveNext())
                yield break;

            do
            {
                var s2 = e.Current;
                yield return new BezierSegment { P0 = s1.P0, P1 = s1.P1, P2 = s1.P2, P3 = s2.P0 };
                s1 = s2;
            }
            while (e.MoveNext());

            if (closed)
                yield return new BezierSegment { P0 = s1.P0, P1 = s1.P1, P2 = s1.P2, P3 = segments.First().P0 };
        }

        static void SolveQuadratic(float a, float b, float c, out float s1, out float s2)
        {
            float det = b * b - 4.0f * a * c;
            if (det < 0.0f)
            {
                s1 = s2 = float.NaN;
                return;
            }

            float detSqrt = Mathf.Sqrt(det);
            s1 = (-b + detSqrt) / 2.0f * a;
            if (Mathf.Abs(a) > float.Epsilon)
                s2 = (-b - detSqrt) / 2.0f * a;
            else s2 = float.NaN;
        }

        /// <summary>Finds the intersection between two infinite lines</summary>
        /// <param name="line1Pt1">The first point of the first line</param>
        /// <param name="line1Pt2">The second point of the first line</param>
        /// <param name="line2Pt1">The first point of the second line</param>
        /// <param name="line2Pt2">The second point of the second line</param>
        /// <returns>The intersection point, or (float.PositiveInfinity, float.PositiveInfinity) if the lines are parallel</returns>
        public static Vector2 IntersectLines(Vector2 line1Pt1, Vector2 line1Pt2, Vector2 line2Pt1, Vector2 line2Pt2)
        {
            var a1 = line1Pt2.y - line1Pt1.y;
            var b1 = line1Pt1.x - line1Pt2.x;

            var a2 = line2Pt2.y - line2Pt1.y;
            var b2 = line2Pt1.x - line2Pt2.x;

            var det = a1 * b2 - a2 * b1;
            if (Mathf.Abs(det) <= Epsilon)
                return new Vector2(float.PositiveInfinity, float.PositiveInfinity); // Parallel, no intersection

            var c1 = a1 * line1Pt1.x + b1 * line1Pt1.y;
            var c2 = a2 * line2Pt1.x + b2 * line2Pt1.y;
            var detInv = 1.0f / det;
            return new Vector2((b2 * c1 - b1 * c2) * detInv, (a1 * c2 - a2 * c1) * detInv);
        }

        /// <summary>Finds the intersection between two line segments</summary>
        /// <param name="line1Pt1">The first point of the first line</param>
        /// <param name="line1Pt2">The second point of the first line</param>
        /// <param name="line2Pt1">The first point of the second line</param>
        /// <param name="line2Pt2">The second point of the second line</param>
        /// <returns>The intersection point, or (float.PositiveInfinity, float.PositiveInfinity) if the lines are parallel</returns>
        public static Vector2 IntersectLineSegments(Vector2 line1Pt1, Vector2 line1Pt2, Vector2 line2Pt1, Vector2 line2Pt2)
        {
            var a1 = (line1Pt1.x - line2Pt2.x) * (line1Pt2.y - line2Pt2.y) - (line1Pt1.y - line2Pt2.y) * (line1Pt2.x - line2Pt2.x);
            var a2 = (line1Pt1.x - line2Pt1.x) * (line1Pt2.y - line2Pt1.y) - (line1Pt1.y - line2Pt1.y) * (line1Pt2.x - line2Pt1.x);
            if (a1 * a2 <= 0.0f)
            {
                var a3 = (line2Pt1.x - line1Pt1.x) * (line2Pt2.y - line1Pt1.y) - (line2Pt1.y - line1Pt1.y) * (line2Pt2.x - line1Pt1.x);
                var a4 = a3 + a2 - a1;
                if (a3 * a4 <= 0.0f)
                {
                    float t = a3 / (a3 - a4);
                    var p = line1Pt1 + t * (line1Pt2 - line1Pt1);
                    return p;
                }
            }
            return new Vector2(float.PositiveInfinity, float.PositiveInfinity);
        }

        static bool PointOnTheLeftOfLine(Vector2 lineFrom, Vector2 lineTo, Vector2 point)
        {
            return ((lineFrom.x - lineTo.x) * (point.y - lineTo.y) - (lineFrom.y - lineTo.y) * (point.x - lineTo.x)) > 0;
        }

        /// <summary>Find the intersections (up to three) between a line and a curve segment.</summary>
        /// <param name="segment">The curve segment</param>
        /// <param name="p0">The first point</param>
        /// <param name="p1">The second point</param>
        /// <returns>Returns the Bezier's 't' parametric values where the line p0-p1 intersects the segment, up to 3 values</returns>
        public static float[] FindBezierLineIntersections(BezierSegment segment, Vector2 p0, Vector2 p1)
        {
            var A = p1.y - p0.y;
            var B = p0.x - p1.x;
            var C = p0.x * (p0.y - p1.y) + p0.y * (p1.x - p0.x);
            var coeffs = BezierCoefficients(segment);

            var P = new float[4];
            P[0] = A * coeffs[0].x + B * coeffs[0].y;
            P[1] = A * coeffs[1].x + B * coeffs[1].y;
            P[2] = A * coeffs[2].x + B * coeffs[2].y;
            P[3] = A * coeffs[3].x + B * coeffs[3].y + C;

            var roots = CubicRoots(P[0], P[1], P[2], P[3]);
            var validRoots = new List<float>(roots.Length);

            foreach (var t in roots)
            {
                var t2 = t * t;
                var t3 = t2 * t;
                var p = coeffs[0] * t3 + coeffs[1] * t2 + coeffs[2] * t + coeffs[3];

                var s = 0.0f;
                if (Mathf.Abs(p1.x - p0.x) > VectorUtils.Epsilon)
                    s = (p.x - p0.x) / (p1.x - p0.x);
                else
                    s = (p.y - p0.y) / (p1.y - p0.y);

                if (t >= 0.0f && t <= 1.0f && s >= 0.0f && s <= 1.0f)
                    validRoots.Add(t);
            }

            return validRoots.ToArray();
        }

        private static float[] CubicRoots(double a, double b, double c, double d)
        {
            var A = b / a;
            var B = c / a;
            var C = d / a;
            var Q = (3 * B - Math.Pow(A, 2)) / 9;
            var R = (9 * A * B - 27 * C - 2 * Math.Pow(A, 3)) / 54;
            var D = Math.Pow(Q, 3) + Math.Pow(R, 2);
            var Im = 0.0;
            var t = new List<double>(3);
            t.AddRange(new double[] { -1.0, -1.0, -1.0 });

            if (D >= 0)
            {
                var sqrtD = Math.Sqrt(D);
                var S = Math.Sign(R + sqrtD) * Math.Pow(Math.Abs(R + sqrtD), 1.0 / 3.0);
                var T = Math.Sign(R - sqrtD) * Math.Pow(Math.Abs(R - sqrtD), 1.0 / 3.0);

                t[0] = -A / 3 + (S + T);
                t[1] = -A / 3 - (S + T) / 2;
                t[2] = t[1];
                Im = Math.Abs(Math.Sqrt(3.0) * (S - T) / 2);

                if (Math.Abs(Im) > VectorUtils.Epsilon)
                {
                    t[1] = -1;
                    t[2] = -1;
                }
            }
            else
            {
                var th = Math.Acos(R / Math.Sqrt(-Math.Pow(Q, 3)));
                var sqrtMinusQ = Math.Sqrt(-Q);
                t[0] = 2 * sqrtMinusQ * Math.Cos(th / 3) - A / 3;
                t[1] = 2 * sqrtMinusQ * Math.Cos((th + 2 * Math.PI) / 3) - A / 3;
                t[2] = 2 * sqrtMinusQ * Math.Cos((th + 4 * Math.PI) / 3) - A / 3;
            }

            for (int i = 0; i < 3; ++i)
            {
                if (t[i] < 0.0 || t[i] > 1.0)
                    t[i] = -1;
            }

            // Remove -1 values which means no root was found
            t.RemoveAll(x => Math.Abs(x + 1.0) < (double)Epsilon);

            return t.Select(x => (float)x).ToArray();
        }

        private static Vector2[] BezierCoefficients(BezierSegment segment)
        {
            var coeffs = new Vector2[4];
            coeffs[0] = -segment.P0 + 3 * segment.P1 + -3 * segment.P2 + segment.P3;
            coeffs[1] = 3 * segment.P0 - 6 * segment.P1 + 3 * segment.P2;
            coeffs[2] = -3 * segment.P0 + 3 * segment.P1;
            coeffs[3] = segment.P0;
            return coeffs;
        }

        /// <summary>Computes a pretty accurate approximation of the scene bounds.</summary>
        /// <param name="root">The root node of the hierarchy to computes the bounds from</param>
        /// <returns>An approximation of the node hierarchy axis-aligned bounding-box</returns>
        /// <remarks>
        /// This will properly evaluate the bounds of the paths and shapes, but will ignore the paths stroke widths.
        /// </remarks>
        #pragma warning disable 612, 618 // Silence use of deprecated IDrawable
        public static Rect SceneNodeBounds(SceneNode root)
        {
            var min = new Vector2(float.MaxValue, float.MaxValue);
            var max = new Vector2(-float.MaxValue, -float.MaxValue);
            foreach (var tnode in WorldTransformedSceneNodes(root, null))
            {
                var shapeMin = new Vector2(float.MaxValue, float.MaxValue);
                var shapeMax = new Vector2(-float.MaxValue, -float.MaxValue);

                if (tnode.Node.Shapes != null)
                {
                    foreach (var shape in tnode.Node.Shapes)
                    {
                        foreach (var contour in shape.Contours)
                        {
                            var bbox = Bounds(TransformBezierPath(contour.Segments, tnode.WorldTransform));
                            shapeMin = Vector2.Min(shapeMin, bbox.min);
                            shapeMax = Vector2.Max(shapeMax, bbox.max);
                        }
                    }
                }

                if (shapeMin.x != float.MaxValue)
                {
                    min = Vector2.Min(min, shapeMin);
                    max = Vector2.Max(max, shapeMax);
                }
            }
            return (min.x != float.MaxValue) ? new Rect(min, max - min) : Rect.zero;
        }

        /// <summary>Computes a rough approximation of the node hierarchy bounds.</summary>
        /// <param name="root">The root node of the hierarchy to computes the bounds from</param>
        /// <returns>An approximation of the root hierarchy axis-aligned bounding-box</returns>
        /// <remarks>
        /// This will use the control point positions as a rough estimate of the bounds for the paths and shapes.
        /// </remarks>
        public static Rect ApproximateSceneNodeBounds(SceneNode root)
        {
            var vertices = new List<Vector2>(100);

            foreach (var tnode in WorldTransformedSceneNodes(root, null))
            {
                if (tnode.Node.Shapes != null)
                {
                    foreach (var shape in tnode.Node.Shapes)
                    {
                        foreach (var contour in shape.Contours)
                        {
                            foreach (var seg in TransformBezierPath(contour.Segments, tnode.WorldTransform))
                            {
                                vertices.Add(seg.P0);
                                vertices.Add(seg.P1);
                                vertices.Add(seg.P2);
                            }
                        }
                    }
                }
            }

            return Bounds(vertices);
        }
        #pragma warning restore 612, 618

        internal static bool IsEmptySegment(BezierSegment bs)
        {
            return (bs.P0 - bs.P1).sqrMagnitude <= Epsilon && (bs.P0 - bs.P2).sqrMagnitude <= Epsilon && (bs.P0 - bs.P3).sqrMagnitude <= Epsilon;
        }
    } // VectorUtils class

    internal class PathDistanceForwardIterator
    {
        class BezierLoop : IList<BezierPathSegment>
        {
            IList<BezierPathSegment> OpenPath;

            public BezierLoop(IList<BezierPathSegment> openPath)
            {
                this.OpenPath = openPath;
            }

            public BezierPathSegment this[int index]
            {
                get
                {
                    if (index == OpenPath.Count)
                        return OpenPath[0];
                    return OpenPath[index];
                }
                set { throw new NotSupportedException(); }
            }

            public int Count { get { return OpenPath.Count + 1; } }
            public bool IsReadOnly { get { return true; } }
            public void Add(BezierPathSegment item) { throw new NotSupportedException(); }
            public void Clear() {}
            public bool Contains(BezierPathSegment item) { throw new NotImplementedException(); }
            public void CopyTo(BezierPathSegment[] array, int arrayIndex) { throw new NotImplementedException(); }
            public IEnumerator<BezierPathSegment> GetEnumerator() { throw new NotImplementedException(); }
            public int IndexOf(BezierPathSegment item) { throw new NotImplementedException(); }
            public void Insert(int index, BezierPathSegment item) { throw new NotSupportedException(); }
            public bool Remove(BezierPathSegment item) { throw new NotSupportedException(); }
            public void RemoveAt(int index) { throw new NotSupportedException(); }
            IEnumerator IEnumerable.GetEnumerator() { throw new NotImplementedException(); }
        }

        public enum Result { Stepped, NewSegment, Ended };
        public PathDistanceForwardIterator(IList<BezierPathSegment> pathSegments, bool closed, float maxCordDeviationSq, float maxTanAngleDevCosine, float stepSizeT)
        {
            if (pathSegments.Count < 2)
                throw new Exception("Cannot iterate a path with no segments in it");

            Segments = closed && !VectorUtils.PathEndsPerfectlyMatch(pathSegments) ? new BezierLoop(pathSegments) : pathSegments;
            this.closed = closed;
            this.needTangentsDuringEval = maxTanAngleDevCosine < 1.0f;
            this.maxCordDeviationSq = maxCordDeviationSq;
            this.maxTanAngleDevCosine = maxTanAngleDevCosine;
            this.stepSizeT = stepSizeT;
            currentBezSeg = new BezierSegment() { P0 = pathSegments[0].P0, P1 = pathSegments[0].P1, P2 = pathSegments[0].P2, P3 = pathSegments[1].P0 };
            lastPointEval = pathSegments[0].P0;
            currentTTangent = needTangentsDuringEval ? VectorUtils.EvalTangent(currentBezSeg, 0.0f) : Vector2.zero;
        }

        float PointToLineDistanceSq(Vector2 point, Vector2 lineStart, Vector2 lineEnd)
        {
            float lineMagSq = (lineEnd - lineStart).sqrMagnitude;
            if (lineMagSq < VectorUtils.Epsilon)
                return (point - lineStart).sqrMagnitude;
            float num = (lineEnd.y - lineStart.y) * point.x - (lineEnd.x - lineStart.x) * point.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x;
            return (num * num) / lineMagSq;
        }

        public Result AdvanceBy(float units, out float unitsRemaining)
        {
            unitsRemaining = units;
            if (Ended)
                return Result.Ended; // Reached the end

            float t = currentT;
            Vector2 currentTPosition = lastPointEval;
            for (;;)
            {
                float nextT = Mathf.Min(t + stepSizeT, 1.0f);
                Vector2 tangent = Vector2.zero;
                Vector2 point = needTangentsDuringEval ? VectorUtils.EvalFull(currentBezSeg, nextT, out tangent) : VectorUtils.Eval(currentBezSeg, nextT);

                bool generateStepHere = false;
                if (needTangentsDuringEval)
                {
                    float tangentDiffCosAngle = Vector2.Dot(tangent, currentTTangent);
                    generateStepHere = tangentDiffCosAngle < this.maxTanAngleDevCosine;
                }

                if (!generateStepHere && (maxCordDeviationSq != float.MaxValue))
                {
                    Vector2 firstPoint = currentTPosition;
                    float distPtToFirstSq = (point - firstPoint).sqrMagnitude;
                    if (distPtToFirstSq > VectorUtils.Epsilon)
                    {
                        Vector2 secondPoint = VectorUtils.Eval(currentBezSeg, Mathf.Min((nextT - currentT) * 2.0f + currentT, 1.0f));
                        float midPointDistSq = PointToLineDistanceSq(point, firstPoint, secondPoint);
                        generateStepHere = midPointDistSq >= maxCordDeviationSq;
                    }
                }

                float dist = (point - lastPointEval).magnitude;
                if (dist > unitsRemaining)
                {
                    nextT = t + stepSizeT * (unitsRemaining / dist); // A linear approximation, not too bad for small step sizes
                    dist = unitsRemaining;
                    point = VectorUtils.Eval(currentBezSeg, nextT);
                }

                segmentLengthSoFar += dist;
                lengthSoFar += dist;
                unitsRemaining -= dist;
                lastPointEval = point;
                t = nextT;

                if (nextT < 1.0f)
                {
                    if ((unitsRemaining > 0) && !generateStepHere)
                        continue;

                    currentT = nextT;
                    currentTTangent = tangent;

                    return Result.Stepped;
                }

                // Crossing to a new segment
                if (currentSegment + 1 == Segments.Count - 1)
                {
                    currentT = 1.0f;
                    return Result.Ended; // Reached the end
                }

                currentSegment++;
                currentBezSeg = new BezierSegment()
                {
                    P0 = Segments[currentSegment].P0,
                    P1 = Segments[currentSegment].P1,
                    P2 = Segments[currentSegment].P2,
                    P3 = Segments[currentSegment + 1].P0
                };
                segmentLengthSoFar = 0.0f;
                currentT = 0.0f;
                currentTTangent = tangent;
                lastPointEval = currentBezSeg.P0;

                return Result.NewSegment;
            }
        }

        public IList<BezierPathSegment> Segments { get; }
        public bool Closed { get { return closed; } }
        public int CurrentSegment { get { return currentSegment; } }
        public float CurrentT { get { return currentT; } }
        public float LengthSoFar { get { return lengthSoFar; } }
        public float SegmentLengthSoFar { get { return segmentLengthSoFar; } }
        public bool Ended { get { return (currentT == 1.0f) && (currentSegment + 1 == Segments.Count - 1); } }
        public Vector2 EvalCurrent() { return VectorUtils.Eval(currentBezSeg, currentT); }

        // Path data and settings
        readonly bool closed, needTangentsDuringEval;
        readonly float maxCordDeviationSq, maxTanAngleDevCosine, stepSizeT; // Quality control variables

        // State
        int currentSegment;
        float currentT;
        float segmentLengthSoFar; // For user's tracking purposes, not really used in our calculations
        float lengthSoFar; // For user's tracking purposes, not really used in our calculations
        Vector2 lastPointEval, currentTTangent;
        BezierSegment currentBezSeg;
    }

    internal class PathPatternIterator
    {
        public PathPatternIterator(float[] pattern, float patternOffset = 0.0f)
        {
            if (pattern != null)
            {
                foreach (var l in pattern)
                    patternLength += l;
            }

            if (patternLength < VectorUtils.Epsilon)
            {
                segmentLength = float.MaxValue;
                return;
            }

            this.pattern = pattern;
            this.patternOffset = patternOffset;
            if (patternOffset == 0.0f)
                segmentLength = pattern[0];
            else this.solid = IsSolidAt(0.0f, out currentSegment, out segmentLength);
        }

        public void Advance()
        {
            if (pattern == null)
                return;

            currentSegment++;
            if (currentSegment >= pattern.Length)
                currentSegment = 0;

            solid = !solid;
            segmentLength = pattern[currentSegment];
        }

        public bool IsSolidAt(float unitsFromPathStart)
        {
            int patternSegmentIndex;
            float patternSegmentLength;
            return IsSolidAt(unitsFromPathStart, out patternSegmentIndex, out patternSegmentLength);
        }

        public bool IsSolidAt(float unitsFromPathStart, out int patternSegmentIndex, out float patternSegmentLength)
        {
            patternSegmentIndex = 0;
            patternSegmentLength = 0;
            if (pattern == null)
                return true;

            bool isSolid = true;
            unitsFromPathStart += patternOffset;
            int hops = (int)(Mathf.Abs(unitsFromPathStart) / patternLength);
            if (unitsFromPathStart < 0.0f)
            {
                unitsFromPathStart = patternLength - ((-unitsFromPathStart) % patternLength);
                if ((pattern.Length & 1) == 1)
                    isSolid = (hops & 1) == 0;
            }
            else
            {
                unitsFromPathStart = unitsFromPathStart % patternLength;
                if ((pattern.Length & 1) == 1)
                    isSolid = (hops & 1) == 1;
            }

            while (unitsFromPathStart > pattern[patternSegmentIndex])
            {
                unitsFromPathStart -= pattern[patternSegmentIndex++];
                isSolid = !isSolid;
            }
            patternSegmentLength = pattern[patternSegmentIndex] - unitsFromPathStart;
            return isSolid;
        }

        public float SegmentLength { get { return segmentLength; } }
        public bool IsSolid { get { return solid; } }

        float[] pattern;

        int currentSegment;
        bool solid = true;
        float segmentLength;
        float patternLength;
        float patternOffset;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorUtils.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/DestroyHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 374d389d769fe864c8aa8eccfa70b0b2
# ASMDEF: Nobi.UiRoundedCorners.dll
# ---
using UnityEngine;

namespace Nobi.UiRoundedCorners {
	internal static class DestroyHelper {
		internal static void Destroy(Object @object) {
#if UNITY_EDITOR
		if (Application.isPlaying) {
			Object.Destroy(@object);
		} else {
			Object.DestroyImmediate(@object);
		}
#else
			Object.Destroy(@object);
#endif
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/DestroyHelper.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/ImageWithIndependentRoundedCorners.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 109c41f08973846429af681aea0a30c4
# ASMDEF: Nobi.UiRoundedCorners.dll
# ---
using UnityEngine;
using UnityEngine.UI;

namespace Nobi.UiRoundedCorners {
	[RequireComponent(typeof(RectTransform))]
	public class ImageWithIndependentRoundedCorners : MonoBehaviour {
		private static readonly int prop_halfSize = Shader.PropertyToID("_halfSize");
		private static readonly int prop_radiuses = Shader.PropertyToID("_r");
		private static readonly int prop_rect2props = Shader.PropertyToID("_rect2props");

		// Vector2.right rotated clockwise by 45 degrees
		private static readonly Vector2 wNorm = new Vector2(.7071068f, -.7071068f);
		// Vector2.right rotated counter-clockwise by 45 degrees
		private static readonly Vector2 hNorm = new Vector2(.7071068f, .7071068f);

		public Vector4 r;
		private Material material;

		// xy - position,
		// zw - halfSize
		[HideInInspector, SerializeField] private Vector4 rect2props;
		[HideInInspector, SerializeField] private MaskableGraphic image;

		private void OnValidate() {
			Validate();
			Refresh();
		}

		private void OnEnable() {
			Validate();
			Refresh();
		}

		private void OnRectTransformDimensionsChange() {
			if (enabled && material != null) {
				Refresh();
			}
		}

		private void OnDestroy() {
			DestroyHelper.Destroy(material);
			image = null;
			material = null;
		}

		public void Validate() {
			if (material == null) {
				material = new Material(Shader.Find("UI/RoundedCorners/IndependentRoundedCorners"));
			}

			if (image == null) {
				TryGetComponent(out image);
			}

			if (image != null) {
				image.material = material;
			}
		}

		public void Refresh() {
			var rect = ((RectTransform)transform).rect;
			RecalculateProps(rect.size);
			material.SetVector(prop_rect2props, rect2props);
			material.SetVector(prop_halfSize, rect.size * .5f);
			material.SetVector(prop_radiuses, r);
		}

		private void RecalculateProps(Vector2 size) {
			// Vector that goes from left to right sides of rect2
			var aVec = new Vector2(size.x, -size.y + r.x + r.z);

			// Project vector aVec to wNorm to get magnitude of rect2 width vector
			var halfWidth = Vector2.Dot(aVec, wNorm) * .5f;
			rect2props.z = halfWidth;


			// Vector that goes from bottom to top sides of rect2
			var bVec = new Vector2(size.x, size.y - r.w - r.y);

			// Project vector bVec to hNorm to get magnitude of rect2 height vector
			var halfHeight = Vector2.Dot(bVec, hNorm) * .5f;
			rect2props.w = halfHeight;


			// Vector that goes from left to top sides of rect2
			var efVec = new Vector2(size.x - r.x - r.y, 0);

			// Vector that goes from point E to point G, which is top-left of rect2
			var egVec = hNorm * Vector2.Dot(efVec, hNorm);

			// Position of point E relative to center of coord system
			var ePoint = new Vector2(r.x - (size.x / 2), size.y / 2);

			// Origin of rect2 relative to center of coord system
			// ePoint + egVec == vector to top-left corner of rect2
			// wNorm * halfWidth + hNorm * -halfHeight == vector from top-left corner to center
			var origin = ePoint + egVec + wNorm * halfWidth + hNorm * -halfHeight;
			rect2props.x = origin.x;
			rect2props.y = origin.y;
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/ImageWithIndependentRoundedCorners.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/ImageWithRoundedCorners.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: adb30198aa32dd140b5750692dd48104
# ASMDEF: Nobi.UiRoundedCorners.dll
# ---
using UnityEngine;
using UnityEngine.UI;

namespace Nobi.UiRoundedCorners {
	[RequireComponent(typeof(RectTransform))]
	public class ImageWithRoundedCorners : MonoBehaviour {
		private static readonly int Props = Shader.PropertyToID("_WidthHeightRadius");

		public float radius;
		private Material material;

		[HideInInspector, SerializeField] private MaskableGraphic image;

		private void OnValidate() {
			Validate();
			Refresh();
		}

		private void OnDestroy() {
			DestroyHelper.Destroy(material);
			image = null;
			material = null;
		}

		private void OnEnable() {
			Validate();
			Refresh();
		}

		private void OnRectTransformDimensionsChange() {
			if (enabled && material != null) {
				Refresh();
			}
		}

		public void Validate() {
			if (material == null) {
				material = new Material(Shader.Find("UI/RoundedCorners/RoundedCorners"));
			}

			if (image == null) {
				TryGetComponent(out image);
			}

			if (image != null) {
				image.material = material;
			}
		}

		public void Refresh() {
			var rect = ((RectTransform)transform).rect;
			material.SetVector(Props, new Vector4(rect.width, rect.height, radius, 0));
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/ImageWithRoundedCorners.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn13dShaderDemoController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 412bc66d707f9c54e9f47717d21f77ae
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.SceneManagement;
#endif

using UnityEngine;
using UnityEngine.EventSystems;

namespace AllIn13DShader
{
    public class AllIn13dShaderDemoController : MonoBehaviour
    {
		public DemoExpositor CurrentExpositor
		{
			get
			{
				return demoExpositors[currentExpositorIndex];
			}
		}

		public DemoElement CurrentDemoElement
		{
			get
			{
				return CurrentExpositor.CurrentDemoElement;
			}
		}


		public DemoSceneConfiguration demoSceneConfig;
		public DemoUI demoUI;
		public Transform initPosition;

		[SerializeField] private SkyController skyController;
		[SerializeField] private AllIn1MainLightController mainLightController;

		[SerializeField] private DemoExpositor[] demoExpositors;
		[SerializeField] private GameObject expositorNameGo;

		[SerializeField] private DemoCameraController cameraController;

		[SerializeField] private GameObject environmentsParentGo;


		//private DemoElement currentDemoElement;
		private DemoElement previousDemoElement;

        [Space, Header("Start Index")]
        [SerializeField] private int startExpositorIndex;
        [SerializeField] private int startDemoIndex;

        [Space, Header("Event Systems")]
        [SerializeField] private EventSystem oldInputEventSystem;
        [SerializeField] private EventSystem newInputEventSystem;

        [Space, Header("Input Handlers")]
		[SerializeField] private InputHandler showDemoInfoHandler;
		
		[Space, Header("Scale Tweens")]
		[SerializeField] private AllIn1DemoScaleTween demoLabelScaleTween;
		[SerializeField] private AllIn1DemoScaleTween expositorLabelScaleTween;
		[SerializeField] private AllIn1DemoScaleTween infoPanelScaleTween;
		
		private int currentExpositorIndex;
        private Vector3 targetCameraPosition;

		private EnvironmentController currentEnvironmentController;
		private bool moveCurrentEnvironment;

        private void Start()
        {
			for(int i = 0; i < demoExpositors.Length; i++)
			{
				demoExpositors[i].Init(demoSceneConfig);
			}
			
			int childCount = environmentsParentGo.transform.childCount;
			for(int i = childCount - 1; i >= 0; i--) Destroy(environmentsParentGo.transform.GetChild(i).gameObject);

            EnableCorrectInputSystem();
            demoExpositors[startExpositorIndex].SetDemoExpositor(startDemoIndex);

			demoUI.Refresh(CurrentExpositor);

			previousDemoElement = null;

			skyController.Init();

			cameraController.Init(demoSceneConfig);
			
			DemoChanged();

			CurrentDemoElement.Show();

			expositorNameGo.SetActive(demoExpositors.Length > 1);
        }
        
        private void Update()
        {
			if (showDemoInfoHandler.IsKeyPressed())
			{
				demoUI.ShowOrHideDemoInfo();
			}
		}
        
        public void NavigateToNextExpositor()
        {
	        previousDemoElement = CurrentDemoElement;
	        Vector3 nextDemoPos = previousDemoElement.transform.position + cameraController.cam.transform.up * demoSceneConfig.distanceBetweenDemos;

	        CurrentDemoElement.Hide();
	        ChangeExpositor(1);

	        moveCurrentEnvironment = false;

	        CurrentDemoElement.transform.position = nextDemoPos;
	        CurrentDemoElement.Show();

	        expositorLabelScaleTween.ScaleDownTween();
	        infoPanelScaleTween.ScaleUpTween();
	        DemoChanged();
        }

        public void NavigateToPreviousExpositor()
        {
	        previousDemoElement = CurrentDemoElement;
	        Vector3 nextDemoPos = previousDemoElement.transform.position - cameraController.cam.transform.up * demoSceneConfig.distanceBetweenDemos;

	        CurrentDemoElement.Hide();
	        ChangeExpositor(-1);

	        moveCurrentEnvironment = false;

	        CurrentDemoElement.transform.position = nextDemoPos;
	        CurrentDemoElement.Show();

	        expositorLabelScaleTween.ScaleDownTween();
	        infoPanelScaleTween.ScaleUpTween();
	        DemoChanged();
        }
        
        public void NavigateToPreviousDemo()
        {
	        previousDemoElement = CurrentDemoElement;

	        DemoElement nextDemoElement = demoExpositors[currentExpositorIndex].GetPreviousDemoElement();
	        Vector3 nextDemoPos = GetNextDemoPos(previousDemoElement, nextDemoElement, -cameraController.cam.transform.right);

	        moveCurrentEnvironment = previousDemoElement.demoElementData.environment == nextDemoElement.demoElementData.environment;

	        demoExpositors[currentExpositorIndex].PreviousDemoElement(nextDemoPos);
	        demoLabelScaleTween.ScaleDownTween();
	        infoPanelScaleTween.ScaleUpTween();
	        DemoChanged();
        }

        public void NavigateToNextDemo()
        {
	        previousDemoElement = CurrentDemoElement;

	        DemoElement nextDemoElement = demoExpositors[currentExpositorIndex].GetNextDemoElement();
	        Vector3 nextDemoPos = GetNextDemoPos(previousDemoElement, nextDemoElement, cameraController.cam.transform.right);

	        moveCurrentEnvironment = previousDemoElement.demoElementData.environment == nextDemoElement.demoElementData.environment;

	        demoExpositors[currentExpositorIndex].NextDemoElement(nextDemoPos);
	        demoLabelScaleTween.ScaleDownTween();
	        infoPanelScaleTween.ScaleUpTween();
	        DemoChanged();
        }
        

		private void LateUpdate()
		{
			if (moveCurrentEnvironment && currentEnvironmentController != null)
			{
				currentEnvironmentController.transform.position += cameraController.GetDeltaMovement();
			}
		}

		private void DemoChanged()
		{
			demoUI.Refresh(CurrentExpositor);

			mainLightController.DemoChanged(CurrentDemoElement.demoElementData);
			skyController.DemoChanged(CurrentDemoElement.demoElementData);

			cameraController.DemoChanged(CurrentDemoElement);

			CheckCurrentEnvironment();
		}

		private Vector3 GetNextDemoPos(DemoElement previousDemo, DemoElement nextDemo, Vector3 dir)
		{
			//Vector3 res = previousDemo.transform.position;

			//if(previousDemo.demoElementData.environment != nextDemo.demoElementData.environment)
			//{
			//	res += dir * demoSceneConfig.distanceBetweenDemos;
			//}

			Vector3 res = previousDemo.transform.position + dir * demoSceneConfig.distanceBetweenDemos;
			return res;
		}

		private void CheckCurrentEnvironment()
		{
			DemoEnvironment currentEnvironment = CurrentDemoElement.demoElementData.environment;

			DemoEnvironment previousEnvironment = previousDemoElement?.demoElementData.environment;

			if(currentEnvironment != previousEnvironment)
			{
				if (currentEnvironmentController != null)
				{
					currentEnvironmentController.Hide();
				}

				if(currentEnvironment != null)
				{
					ChangeEnvironment(currentEnvironment);
				}

				moveCurrentEnvironment = false;
			}
			else
			{
				moveCurrentEnvironment = true;
			}
		}

		private void ChangeEnvironment(DemoEnvironment environment)
		{
			GameObject newEnvironmentGo = Instantiate(environment.prefab);
			newEnvironmentGo.transform.parent = environmentsParentGo.transform;
			newEnvironmentGo.transform.position = CurrentDemoElement.transform.position;
			newEnvironmentGo.transform.rotation = Quaternion.identity;
			newEnvironmentGo.transform.localScale = Vector3.zero;


			currentEnvironmentController = newEnvironmentGo.GetComponent<EnvironmentController>();
			currentEnvironmentController.Init(demoSceneConfig);

			currentEnvironmentController.Show(CurrentDemoElement);
		}

#if UNITY_EDITOR
		[ContextMenu("Setup Demo Scene")]
		public void Setup()
		{
			RemoveOldElements();

			for(int i = 0; i < demoSceneConfig.expositors.Length; i++)
			{
				DemoExpositorData expositorData = demoSceneConfig.expositors[i];

				GameObject goExpositor = new GameObject($"Expositor {i + 1}");
				goExpositor.transform.parent = transform;
				goExpositor.transform.localPosition = new Vector3(0f, i * -25f, 0f);
				goExpositor.transform.localRotation = Quaternion.identity;

				DemoExpositor expositor = goExpositor.AddComponent<DemoExpositor>();
				expositor.Setup(expositorData, demoSceneConfig);

				ArrayUtility.Add(ref demoExpositors, expositor);
			}

			currentExpositorIndex = 0;

			EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
		}

		private void RemoveOldElements()
		{
			DemoExpositor[] expositorsToDestroy = transform.GetComponentsInChildren<DemoExpositor>();
			for(int i = 0; i < expositorsToDestroy.Length; i++)
			{
				DestroyImmediate(expositorsToDestroy[i].gameObject);
			}

			ArrayUtility.Clear(ref demoExpositors);
		}
#endif

		private void ChangeExpositor(int changeAmount)
        {
			currentExpositorIndex += changeAmount;
            if(currentExpositorIndex >= demoExpositors.Length) currentExpositorIndex = 0;
            if(currentExpositorIndex < 0) currentExpositorIndex = demoExpositors.Length - 1;
		}
		
		public int GetCurrentExpositorIndex() => currentExpositorIndex;
        
        private void EnableCorrectInputSystem()
        {
            bool newInputSystemEnabled = false;
#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
            newInputSystemEnabled = true;
#endif
            oldInputEventSystem.gameObject.SetActive(!newInputSystemEnabled);
            newInputEventSystem.gameObject.SetActive(newInputSystemEnabled);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn13dShaderDemoController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn13DShaderShaderPropertyCurveAnim.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a847b867911545f42a402db444415b1f
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;
using System.Collections.Generic;

namespace AllIn13DShader
{
    public class AllIn13DShaderShaderPropertyCurveAnim : MonoBehaviour
    {
        [SerializeField] private string numericPropertyName = "_HsvShift";
        
        [SerializeField] private AnimationCurve animationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);
        [SerializeField] private float animationDuration = 1f;
        [SerializeField] private float waitDuration = 0.5f;
        [SerializeField] private float minValue = 0f;
        [SerializeField] private float maxValue = 1f;
        
        [Space, SerializeField, Header("If empty uses instances of currently used Materials")]
        private Material[] materials;
        private Material[] originalMaterials;
        private bool restoreMaterialsOnDisable = false;

        private int propertyShaderID;
        private float timer = 0f;
        private bool isAnimating = true;
        private bool isValid = true;

        private void Start()
        {
            if(materials == null || materials.Length == 0)
            {
                Renderer renderer = GetComponent<Renderer>();
                if(renderer != null) materials = renderer.materials;
            }
            else
            {
                originalMaterials = new Material[materials.Length];
                for(int i = 0; i < materials.Length; i++)
                    if(materials[i] != null) originalMaterials[i] = new Material(materials[i]);
                restoreMaterialsOnDisable = true;
            }

            if(materials == null || materials.Length == 0) DestroyComponentAndLogError(gameObject.name + " has no valid Materials, deleting AllIn1VfxScrollShaderProperty component");
            else
            {
                bool allValid = true;
                for(int i = 0; i < materials.Length; i++)
                {
                    if(materials[i] == null || !materials[i].HasProperty(numericPropertyName))
                    {
                        allValid = false;
                        break;
                    }
                }
                
                if(allValid) 
                    propertyShaderID = Shader.PropertyToID(numericPropertyName);
                else 
                    DestroyComponentAndLogError(gameObject.name + "'s Material(s) don't all have a " + numericPropertyName + " property");
            }
        }

        private void Update()
        {
            if(materials == null || materials.Length == 0)
            {
                if(isValid)
                {
                    Debug.LogError("The object " + gameObject.name + " has no Materials and you are trying to access them. Please take a look");
                    isValid = false;   
                }
                return;
            }
            
            timer += Time.deltaTime;
            
            if(isAnimating)
            {
                if(timer < animationDuration)
                {
                    float normalizedTime = timer / animationDuration;
                    float curveValue = animationCurve.Evaluate(normalizedTime);
                    float remappedValue = Mathf.Lerp(minValue, maxValue, curveValue);
                    
                    for(int i = 0; i < materials.Length; i++)
                        if(materials[i] != null) materials[i].SetFloat(propertyShaderID, remappedValue);
                }
                else
                {
                    isAnimating = false;
                    timer = 0f;
                }
            }
            else
            {
                if(timer >= waitDuration)
                {
                    isAnimating = true;
                    timer = 0f;
                }
            }
        }

        private void DestroyComponentAndLogError(string logError)
        {
            Debug.LogError(logError);
            Destroy(this);
        }

        private void OnDisable()
        {
            if(restoreMaterialsOnDisable && materials != null && originalMaterials != null)
            {
                for(int i = 0; i < materials.Length; i++)
                    if(materials[i] != null && originalMaterials[i] != null)
                        materials[i].CopyPropertiesFromMaterial(originalMaterials[i]);
            }
        }

        private void OnDestroy()
        {
            if(originalMaterials != null)
                for(int i = 0; i < originalMaterials.Length; i++)
                    if(originalMaterials[i] != null) Destroy(originalMaterials[i]);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn13DShaderShaderPropertyCurveAnim.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1AutoRotate.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c87fcb4b45b61be46bdb72dcaa09c6f2
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
    public class AllIn1AutoRotate : MonoBehaviour
    {
        [SerializeField] private float rotationSpeed = 30f;
        [SerializeField] private Vector3 rotationAxis = Vector3.up;

        private void Update()
        {
            transform.Rotate(rotationAxis * (rotationSpeed * Time.deltaTime), Space.Self);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1AutoRotate.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1CanvasFader.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 82afebb9958e7ff4b817915f67b326af
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
    public class AllIn1CanvasFader : MonoBehaviour
    {
        [SerializeField] private KeyCode fadeToggleKey = KeyCode.U;
        [SerializeField] private float tweenSpeed = 1f;
        [SerializeField] private AllIn1DemoScaleTween hideUiButtonTween;
        
        private bool isTweening = false;
        private float currentAlpha = 1f;
        private float targetAlpha = 1f;
        private CanvasGroup canvasGroup;
        private bool hideUiButtonTweenNotNull;

        private void Start()
        {
            canvasGroup = GetComponent<CanvasGroup>();
            canvasGroup.alpha = 1f;
            hideUiButtonTweenNotNull = hideUiButtonTween != null;
        }

        private void Update()
        {
            if(Input.GetKeyDown(fadeToggleKey)) HideUiButtonPressed();
            
            if(!isTweening) return;
            currentAlpha = Mathf.MoveTowards(currentAlpha, targetAlpha, Time.unscaledDeltaTime * tweenSpeed);
            canvasGroup.alpha = currentAlpha;
            if(targetAlpha == currentAlpha) isTweening = false;
        }

        public void HideUiButtonPressed()
        {
            if(currentAlpha < 0.01f) MakeCanvasVisibleTween();
            else MakeCanvasInvisibleTween();
            if(hideUiButtonTweenNotNull) hideUiButtonTween.ScaleUpTween();
        }

        private void MakeCanvasVisibleTween()
        {
            isTweening = true;
            targetAlpha = 1f;
        }

        private void MakeCanvasInvisibleTween()
        {
            isTweening = true;
            targetAlpha = 0f;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1CanvasFader.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1DemoButtonPress.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b0e6b5525608b2546bdd773ea2bdc6b8
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using TMPro;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

namespace AllIn13DShader
{
    [RequireComponent(typeof(InputHandler))]
    public class AllIn1DemoButtonPress : MonoBehaviour
    {
        [SerializeField] private InputHandler inputHandler;
        [SerializeField] private AllIn1DemoScaleTween scaleTween;
        [SerializeField] private Button button;

        [Space, Header("Label Settings")]
        [SerializeField] private bool completelyIgnoreLabel;
        [SerializeField] private bool showKeyLabel = true;
        [SerializeField] private TextMeshProUGUI keyLabel;
        
        private Coroutine resetButtonColorCr;

        private void Start()
        {
            if(!completelyIgnoreLabel)
            {
                if(!showKeyLabel)
                {
                    keyLabel.enabled = false;
                    enabled = false;
                }
                else
                {
                    keyLabel.text = $"(Key {inputHandler.GetTargetKey().ToString()})";
                }
            }
        }

        private void Update()
        {
            if(inputHandler.IsKeyPressed())
            {
                SimulateClick();
            }
        }

        private void SimulateClick()
        {
            if(button != null)
            {
                ColorBlock colors = button.colors;
                button.targetGraphic.color = colors.pressedColor;
                button.onClick.Invoke();
        
                if(resetButtonColorCr != null) StopCoroutine(resetButtonColorCr);
                resetButtonColorCr = StartCoroutine(ResetButtonColor());
            }
        }

        private IEnumerator ResetButtonColor()
        {
            yield return new WaitForSeconds(0.1f);
            button.targetGraphic.color = button.colors.normalColor;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1DemoButtonPress.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1DemoScaleTween.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3d8639573e99fb143ab0f4e90c44e1e7
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
    public class AllIn1DemoScaleTween : MonoBehaviour
    {
        [SerializeField] private float maxTweenScale = 1.25f;
        [SerializeField] private float minTweenScale = 0.5f;
        [SerializeField] private float tweenSpeed = 15f;
        
        private bool isTweening = false;
        private float currentScale = 1f;
        private Vector3 scaleToApply = Vector3.one;

        private void Update()
        {
            if(!isTweening) return;
            currentScale = Mathf.Lerp(currentScale, 1f, Time.unscaledDeltaTime * tweenSpeed);
            UpdateScaleToApply();
            ApplyScale();
            if(Mathf.Abs(currentScale - 1f) < 0.02f) isTweening = false;
        }

        private void UpdateScaleToApply()
        {
            scaleToApply.x = currentScale;
            scaleToApply.y = currentScale;
        }
        
        private void ApplyScale()
        {
            transform.localScale = scaleToApply;
        }

        public void ScaleUpTween()
        {
            isTweening = true;
            currentScale = maxTweenScale;
            UpdateScaleToApply();
        }
        
        public void ScaleDownTween()
        {
            isTweening = true;
            currentScale = minTweenScale;
            UpdateScaleToApply();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1DemoScaleTween.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1FadeLight.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 558b99d21ed97e74b91d33cbf6d03183
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
    [RequireComponent(typeof(Light))]
    public class AllIn1FadeLight : MonoBehaviour
    {
        [SerializeField] private float fadeDuration = 0.1f;
        [SerializeField] private bool destroyWhenFaded = true;
        private Light targetLight;
        private float animationRatioRemaining = 1f;
        private float iniLightIntensity;

        private void Start()
        {
            targetLight = GetComponent<Light>();
            iniLightIntensity = targetLight.intensity;
        }

        private void Update()
        {
            targetLight.intensity = Mathf.Lerp(0f, iniLightIntensity, animationRatioRemaining);
            animationRatioRemaining -= Time.deltaTime / fadeDuration;
            if(destroyWhenFaded && animationRatioRemaining <= 0f) Destroy(gameObject);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1FadeLight.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1MainLightController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 706d6c9c96c757141aab2f13eaf4c90f
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class AllIn1MainLightController : MonoBehaviour
	{
		public Light mainDirectionalLight;
		
		public void DemoChanged(DemoElementData demoElementData)
		{
			mainDirectionalLight.enabled = demoElementData.directionalLightEnabled;
			mainDirectionalLight.intensity = demoElementData.mainLightIntensity;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1MainLightController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1MouseTransformRotator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b9e8e28469a910c418e1840fabdaab78
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;
#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
using UnityEngine.InputSystem;
#endif

namespace AllIn13DShader
{
    public class AllIn1MouseTransformRotator : MonoBehaviour
    {
        [SerializeField] private float rotationSpeedHorizontal = 10f;
        [SerializeField] private float verticalSpeed = 5f;
        [SerializeField] private bool rightClickRequired = true;
        
        [Header("Movement Constraints")]
        [SerializeField] private float maxVerticalAngle = 80f;
        [SerializeField] private float minVerticalAngle = -60f;

        [Space, Header("Zoom")]
        [SerializeField] private bool enableZoom = true;
        [SerializeField] private float zoomSpeed = 5f;
        [SerializeField] private float maxZoomDistance = 20f;
        [SerializeField] private float minZoomDistance = 2f;

        private Transform zoomTargetTransform;
        private float currentVerticalRotation = 0f;
        private float currentHorizontalRotation = 0f;
        private float currentZoomDistance = 10f;
        private float dt;

#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
        private Mouse mouse;
        
        private void Awake()
        {
            mouse = Mouse.current;
            Initialize();
        }
#else
        private void Awake()
        {
            Initialize();
        }
#endif

        private void Initialize()
        {
            Vector3 currentRotation = transform.eulerAngles;
            currentHorizontalRotation = currentRotation.y;
            currentVerticalRotation = currentRotation.x;
            zoomTargetTransform = transform.GetChild(0);
            currentZoomDistance = zoomTargetTransform.localPosition.z;
        }

        private void Update()
        {
            dt = Time.deltaTime;
            HandleRotation();
            if(enableZoom) HandleZoom();
        }
    
        private void HandleRotation()
        {
#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
            if(mouse == null) return;
            float mouseX = mouse.delta.ReadValue().x * dt * rotationSpeedHorizontal;
            float mouseY = mouse.delta.ReadValue().y * dt * verticalSpeed;
            bool isRightMousePressed = mouse.rightButton.isPressed;
#else
            float mouseX = Input.GetAxis("Mouse X") * dt * rotationSpeedHorizontal;
            float mouseY = Input.GetAxis("Mouse Y") * dt * verticalSpeed;
            bool isRightMousePressed = Input.GetMouseButton(1);
#endif
            if((!rightClickRequired && !isRightMousePressed) || (rightClickRequired && isRightMousePressed))
            {
                // Update rotations
                currentHorizontalRotation += mouseX;
                currentVerticalRotation += mouseY;
                
                // Clamp vertical rotation
                currentVerticalRotation = Mathf.Clamp(currentVerticalRotation, minVerticalAngle, maxVerticalAngle);
                
                // Apply rotations
                transform.rotation = Quaternion.Euler(currentVerticalRotation, currentHorizontalRotation, 0f);
            }
        }

        private void HandleZoom()
        {
#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
            if(mouse == null) return;
            float scrollDelta = mouse.scroll.ReadValue().y * dt * zoomSpeed;
#else
            float scrollDelta = Input.GetAxis("Mouse ScrollWheel") * dt * zoomSpeed * 100f;
#endif
            // Update zoom distance
            currentZoomDistance = Mathf.Clamp(currentZoomDistance + scrollDelta, minZoomDistance, maxZoomDistance);
            
            // Apply new position
            Vector3 localPos = zoomTargetTransform.localPosition;
            localPos.z = currentZoomDistance;
            zoomTargetTransform.localPosition = localPos;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1MouseTransformRotator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1TimeControl.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 55cb4f27152d94a4890b9107d0da14f2
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;
using UnityEngine.UI;

namespace AllIn13DShader
{
    public class AllIn1TimeControl : MonoBehaviour
    {
        [SerializeField] private KeyCode increaseTimeScale = KeyCode.UpArrow;
        [SerializeField] private KeyCode increaseTimeScaleAlt = KeyCode.W;
        [SerializeField] private KeyCode decreaseTimeScale = KeyCode.DownArrow;
        [SerializeField] private KeyCode decreaseTimeScaleAlt = KeyCode.S;
        [SerializeField] private KeyCode pauseKey = KeyCode.P;
        [SerializeField, Range(0f, 1f)] private float timeScaleInterval = 0.05f;
        [SerializeField] private Slider timeScaleSlider;
        [SerializeField] private Image pausedButtonImage;
        [SerializeField] private Color pausedButtonColor;
        private bool timeScaleSliderNotNull;
        private float lastChangeTime;
        private AllIn1DemoScaleTween pausedButtonTween;
        private Text pausedButtonText;

        private void Start()
        {
            timeScaleSliderNotNull = timeScaleSlider != null;
            pausedButtonTween = pausedButtonImage.GetComponent<AllIn1DemoScaleTween>();
            pausedButtonText = pausedButtonImage.GetComponentInChildren<Text>();
            UpdateTimeScaleUI();
            if(timeScaleSliderNotNull) timeScaleSlider.onValueChanged.AddListener(delegate { ChangeTimeScale(timeScaleSlider.value - Time.timeScale); });
        }

        private void Update()
        {
            if(Input.GetKeyDown(increaseTimeScale) || Input.GetKeyDown(increaseTimeScaleAlt)) ChangeTimeScale(timeScaleInterval);
            if(Input.GetKeyDown(decreaseTimeScale) || Input.GetKeyDown(decreaseTimeScaleAlt)) ChangeTimeScale(-timeScaleInterval);
            if(Input.GetKeyDown(pauseKey))
            {
                if(Time.timeScale < 0.01f) ChangeTimeScale(1f - Time.timeScale);
                else ChangeTimeScale(-Time.timeScale);
                pausedButtonTween.ScaleUpTween();
            }

            float timeScaleChangeInterval = 0.1f;
            if(!(Time.unscaledTime - lastChangeTime > timeScaleChangeInterval)) return;
            if(Input.GetKey(increaseTimeScale) || Input.GetKey(increaseTimeScaleAlt)) ChangeTimeScale(timeScaleInterval);
            if(Input.GetKey(decreaseTimeScale) || Input.GetKey(decreaseTimeScaleAlt)) ChangeTimeScale(-timeScaleInterval);
        }

        private void ChangeTimeScale(float changeAmount)
        {
            Time.timeScale = Mathf.Clamp(Time.timeScale + changeAmount, 0.0f, 1f);
            lastChangeTime = Time.unscaledTime;
            UpdateTimeScaleUI();
        }

        private void UpdateTimeScaleUI()
        {
            if(timeScaleSliderNotNull) timeScaleSlider.value = Time.timeScale;
            if(Time.timeScale < 0.01f)
            {
                pausedButtonText.text = "Unpause";
                pausedButtonImage.color = pausedButtonColor;
            }
            else
            {
                pausedButtonText.text = "Pause";
                pausedButtonImage.color = Color.white;
            }
        }

        public void PauseUiButton()
        {
            if(Time.timeScale < 0.01f) Time.timeScale = 1f;
            else Time.timeScale = 0f;

            UpdateTimeScaleUI();
        }

        public void CurrentEffectChanged()
        {
            if(Time.timeScale < 0.01f)
            {
                Time.timeScale = 0.1f;
                UpdateTimeScaleUI();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1TimeControl.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Billboard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7ed080149842b6b44bb6eec1735711ba
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
    /// <summary>
    /// Handles billboard behavior to face camera either on Y-axis only or all axes
    /// Can follow either editor scene view camera or main camera with cached reference
    /// </summary>
    [ExecuteAlways]
    public class Billboard : MonoBehaviour
    {
        [SerializeField] 
        private bool yAxisOnly = true;
    
        [SerializeField, Tooltip("If true, will update rotation every frame. If false, only on camera movement")]
        private bool continuousUpdate = true;

        [SerializeField, Tooltip("If true, follows editor scene view camera. If false, follows main camera")]
        private bool useEditorCamera = false;

        private Transform targetCameraTransform;
        private Vector3 previousCameraPosition;
        private Quaternion initialRotation;
        private bool wasUsingEditorCamera;
    
        // Static cached reference to main camera
        private static Camera mainCameraCache;
        private static bool mainCameraSearched = false;

        private void OnEnable()
        {
            // Reset camera search if re-enabled
            if (!useEditorCamera && !mainCameraSearched)
            {
                UpdateCameraReference();
            }
        }

        private void Update()
        {
            bool shouldUpdateCamera = targetCameraTransform == null || wasUsingEditorCamera != useEditorCamera;
        
            if(shouldUpdateCamera)
            {
                UpdateCameraReference();
            }

            if(targetCameraTransform == null) return;

            if(!continuousUpdate && previousCameraPosition == targetCameraTransform.position)
            {
                return;
            }

            if(yAxisOnly)
            {
                // Only rotate around Y axis
                Vector3 directionToCamera = targetCameraTransform.position - transform.position;
                directionToCamera.y = 0;

                if(directionToCamera != Vector3.zero)
                {
                    transform.rotation = Quaternion.LookRotation(directionToCamera) * initialRotation;
                }
            }
            else
            {
                // Full billboard - face camera completely
                transform.LookAt(transform.position + targetCameraTransform.rotation * Vector3.forward,
                    targetCameraTransform.rotation * Vector3.up);
            }

            previousCameraPosition = targetCameraTransform.position;
        }

        private void UpdateCameraReference()
        {
#if UNITY_EDITOR
            if(useEditorCamera)
            {
                SceneView sceneView = SceneView.lastActiveSceneView;
                if(sceneView == null || sceneView.camera == null) return;
                
                targetCameraTransform = sceneView.camera.transform;
                wasUsingEditorCamera = true;
            }
            else
#endif
            {
                // Use cached camera reference if available
                if (mainCameraCache == null || !mainCameraCache.isActiveAndEnabled)
                {
                    mainCameraCache = Camera.main;
                    mainCameraSearched = true;
                }
            
                if(mainCameraCache == null) return;
                targetCameraTransform = mainCameraCache.transform;
                wasUsingEditorCamera = false;
            }

            initialRotation = Quaternion.identity;
        }

        // Handle scene changes or camera destruction
        private void OnValidate()
        {
            // Force update of camera reference when properties change in inspector
            targetCameraTransform = null;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Billboard.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoCameraController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 559c47b838b33484d9e24d155c754de2
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

#if ALLIN13DSHADER_BIRP && UNITY_POST_PROCESSING_STACK_V2
using UnityEngine.Rendering.PostProcessing;
#endif

namespace AllIn13DShader
{
	public class DemoCameraController : MonoBehaviour
	{
		public enum TransitionState
		{
			NONE = 0,
			MOVING = 1,
		}

		private Vector3 srcPosition;
		private Quaternion srcRotation;

		private Vector3 dstPosition;
		private Quaternion dstRotation;

		private AnimationCurve cameraCurve;

		private TransitionState transitionState;
		private float timer;
		private float transitionDuration;

		private Vector3 deltaMovement;

		public Transform target;
		public float lerpSpeed;

		[Header("Camera")]
		public Camera cam;

#if ALLIN13DSHADER_BIRP && UNITY_POST_PROCESSING_STACK_V2
		[Header("Postprocess")]
		public PostProcessLayer postProcessLayer;
		public PostProcessVolume postProcessVolume;
#endif

		public void Init(DemoSceneConfiguration demoSceneConfig)
		{
			this.cameraCurve = demoSceneConfig.cameraCurve;
			this.transitionState = TransitionState.NONE;
			this.transitionDuration = demoSceneConfig.cameraTransitionDuration;
		}

		public void DemoChanged(DemoElement demoElement)
		{
			transitionState = TransitionState.MOVING; 

			srcPosition = target.position;
			srcRotation = target.rotation;

			dstPosition = demoElement.transform.position;
			dstRotation = Quaternion.identity;

#if ALLIN13DSHADER_BIRP && UNITY_POST_PROCESSING_STACK_V2
			if (postProcessLayer != null)
			{
				postProcessLayer.enabled = demoElement.demoElementData.postProcessEnabled;
			}
			
			if(postProcessVolume != null)
			{
				postProcessVolume.enabled = demoElement.demoElementData.postProcessEnabled;
			}
#endif
		}

		public void GoTo(Transform tr)
		{
			transitionState = TransitionState.MOVING;

			dstPosition = tr.position;
			dstRotation = tr.rotation;

			srcPosition = target.position;
			srcRotation = target.rotation;
		}

		public Vector3 GetDeltaMovement()
		{
			return deltaMovement;
		}

		private void Update()
		{
			if(transitionState == TransitionState.MOVING)
			{
				Update_Moving();
			}
			else
			{
				deltaMovement = Vector3.zero;
			}
		}

		private void Update_Moving()
		{
			timer += Time.deltaTime;
			float t = timer / transitionDuration;
			float curveT = cameraCurve.Evaluate(t);

			Vector3 newPosition = Vector3.LerpUnclamped(srcPosition, dstPosition, curveT);
			deltaMovement = newPosition - target.transform.position;

			target.transform.position = newPosition;
			target.transform.rotation = Quaternion.SlerpUnclamped(srcRotation, dstRotation, curveT);

			if(t >= 1f)
			{
				transitionState = TransitionState.NONE;
				timer = 0f;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoCameraController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElement.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1698d847b7bb109498dbc7867667a6f6
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using System;
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoElement : MonoBehaviour
	{
		public MeshRenderer[] renderers;

		public DemoElementData demoElementData;

		public TransformScaler transformScaler;

		public PropertyTweenCollection tweenCollection;

		public int demoIndex { get; private set; }


		public virtual void Init(DemoSceneConfiguration demoSceneConfig, int demoIndex)
		{
			transform.localScale = Vector3.zero;
			gameObject.SetActive(false);

			transformScaler.Init(demoSceneConfig, ScaleFinishedCallback);

			tweenCollection.Init();

			this.demoIndex = demoIndex;
		}

		public virtual void Update()
		{
			tweenCollection.Update(Time.deltaTime);
		}

		public void Show()
		{
			gameObject.SetActive(true);
			transformScaler.ScaleUp();
		}

		public void Hide()
		{
			transformScaler.ScaleDown();
		}

		public void ScaleFinishedCallback(TransformScaler.ScalingType scalingOperation)
		{
			if(scalingOperation == TransformScaler.ScalingType.SCALING_DOWN)
			{
				gameObject.SetActive(false);
			}
		}

		public bool IsScaling()
		{
			bool res = transformScaler.IsScaling();
			return res;
		}
		
		// #if UNITY_EDITOR
		// private void OnValidate()
		// {
		// 	if(demoElementData == null)
		// 	{
		// 		string goName = gameObject.name;
		// 		if(goName.StartsWith("P_Demo_")) goName = goName.Substring(7);
		// 		
		// 		string[] guids = UnityEditor.AssetDatabase.FindAssets("t:DemoElementData");
		// 		foreach(string guid in guids)
		// 		{
		// 			string path = UnityEditor.AssetDatabase.GUIDToAssetPath(guid);
		// 			DemoElementData data = UnityEditor.AssetDatabase.LoadAssetAtPath<DemoElementData>(path);
		// 			if(data != null && data.prefab != null && data.prefab.name.Contains(goName))
		// 			{
		// 				demoElementData = data;
		// 				UnityEditor.EditorUtility.SetDirty(this);
		// 				break;
		// 			}
		// 		}
		// 	}
		// }
		// #endif
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElement.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementColorRamp.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0453bc847f79848469a4203b1ce8b7cf
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoElementColorRamp : DemoElement
	{
		private static int COLOR_RAMP_MATPROP_ID = Shader.PropertyToID("_ColorRampTex"); 

		private float timer;
		private int currentTextureIndex;

		public Texture[] colorRamps;
		public float timeBetweenTextures;

		public Material mat;

		public override void Update()
		{
			base.Update();

			timer += Time.deltaTime;

			if(timer >= timeBetweenTextures)
			{
				timer = 0f;
				currentTextureIndex = currentTextureIndex < colorRamps.Length - 1 ? currentTextureIndex + 1 : 0;

				mat.SetTexture(COLOR_RAMP_MATPROP_ID, colorRamps[currentTextureIndex]);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementColorRamp.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 94ddca8ef013926408780e6e292bad16
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using System;
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoElementData : ScriptableObject
	{
		public string demoName;
		public GameObject prefab;
		public DemoEnvironment environment;

		[Header("Info")]
		[TextArea] public string info;

		[Header("Min Directional Light")]
		public bool directionalLightEnabled = true;
		public float mainLightIntensity = 1.0f;

		[Header("Skybox")]
		public bool skyboxEnabled = true;

		[Header("Postprocess")]
		public bool postProcessEnabled = false;

		// private void OnValidate()
		// {
		// 	if(string.IsNullOrEmpty(demoName)) demoName = GetFormattedName();
		// }
		//
		// private string GetFormattedName()
		// {
		// 	if(prefab == null) return string.Empty;
  //   
		// 	string prefabName = prefab.name;
		// 	if(prefabName.StartsWith("P_Demo_")) prefabName = prefabName.Substring(7);
  //   
		// 	if(prefabName.Length > 1)
		// 	{
		// 		int i = 1;
		// 		while(i < prefabName.Length)
		// 		{
		// 			if(char.IsUpper(prefabName[i]) && !char.IsWhiteSpace(prefabName[i-1]))
		// 			{
		// 				prefabName = prefabName.Insert(i, " ");
		// 				i++;
		// 			}
		// 			i++;
		// 		}
		// 	}
  //   
		// 	return prefabName;
		// }
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementData.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementIntersectionGlow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3bdcc7aefbba4b1428221d91f5435083
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoElementIntersectionGlow : DemoElement
	{
		private float timer;

		public float speed;
		public float minY;
		public float maxY;

		public Transform target;

		private void OnEnable()
		{
			timer = 0f;
		}

		private void OnDisable()
		{
			timer = 0f;
		}

		public override void Update()
		{
			base.Update();

			timer += Time.deltaTime;

			float sin01 = (Mathf.Sin(timer * speed) + 1f) * 0.5f;
			Vector3 localPos = target.localPosition;
			localPos.y = Mathf.Lerp(minY, maxY, sin01);

			target.localPosition = localPos;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementIntersectionGlow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoEnvironment.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c4205413819227748acd4e41a3ce684e
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoEnvironment : ScriptableObject
	{
		public GameObject prefab;
		public int sceneIndex;
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoEnvironment.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoExpositor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 684c2ea481da2714ea0aed60ea54c2fe
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
#if UNITY_EDITOR
using UnityEditor;
#endif

using UnityEngine;

namespace AllIn13DShader
{
    public class DemoExpositor : MonoBehaviour
    {
		public DemoExpositorData expositorData;
        [SerializeField] private DemoElement[] demoElements;
        
        private int currentDemoIndex;

		public DemoElement CurrentDemoElement => demoElements[currentDemoIndex];
		public int CurrentDemoElementIndex => currentDemoIndex;

		public void Init(DemoSceneConfiguration demoSceneConfig)
		{
			for (int i = 0; i < demoElements.Length; i++)
			{
				demoElements[i].Init(demoSceneConfig, i);
			}
		}

        public void SetDemoExpositor(int newIndex)
        {
            currentDemoIndex = newIndex;
        }

		public DemoElement GetNextDemoElement()
		{
			int nextIndex = currentDemoIndex + 1;
			if (nextIndex >= demoElements.Length)
			{
				nextIndex = 0;
			}

			DemoElement res = demoElements[nextIndex];
			return res;
		}

		public DemoElement GetPreviousDemoElement()
		{
			int nextIndex = currentDemoIndex - 1;
			if (nextIndex < 0)
			{
				nextIndex = demoElements.Length - 1;
			}

			DemoElement res = demoElements[nextIndex];
			return res;
		}

		public void NextDemoElement(Vector3 demoPos)
        {
			CurrentDemoElement.Hide();

			currentDemoIndex++;
			if (currentDemoIndex >= demoElements.Length)
			{
				currentDemoIndex = 0;
			}

			CurrentDemoElement.transform.position = demoPos;
			CurrentDemoElement.Show();
        }
        
        public void PreviousDemoElement(Vector3 demoPos)
        {
			CurrentDemoElement.Hide();

			currentDemoIndex--;
			if (currentDemoIndex < 0)
			{
				currentDemoIndex = demoElements.Length - 1;
			}

			CurrentDemoElement.transform.position = demoPos;
			CurrentDemoElement.Show();
		}
        
		public void SetElementDemoIndex(int demoIndex)
		{
			currentDemoIndex = Mathf.Min(demoIndex, demoElements.Length - 1);
		}

		public DemoElement FindNearestElement(Vector3 referencePosition, out int demoIndex)
		{
			DemoElement res = null;

			float minSqrDistance = float.MaxValue;
			demoIndex = 0;

			Vector3 referencePositionWithoutY = referencePosition;
			referencePositionWithoutY.y = 0f;


			for (int i = 0; i < demoElements.Length; i++)
			{
				Vector3 demoElementWithoutY = demoElements[i].transform.position;
				demoElementWithoutY.y = 0f;

				float sqrDistance = (referencePositionWithoutY - demoElementWithoutY).sqrMagnitude;
				if (sqrDistance <= minSqrDistance)
				{
					minSqrDistance = sqrDistance;
					res = demoElements[i];
					demoIndex = i;
				}
			}

			if(CurrentDemoElement.demoElementData.environment == res.demoElementData.environment &&
				res.demoElementData.environment != null)
			{
				res = CurrentDemoElement;
				demoIndex = CurrentDemoElement.demoIndex;
			}

			return res;
		}


#if UNITY_EDITOR
		public void Setup(DemoExpositorData expositorData, DemoSceneConfiguration demoSceneConfig)
		{
			this.expositorData = expositorData;

			if (demoElements != null)
			{
				ArrayUtility.Clear(ref demoElements);
			}
			else
			{
				demoElements = new DemoElement[0];
			}

			DemoEnvironment lastEnvironment = null;
			Vector3 lastLocalPosition = new Vector3(-demoSceneConfig.distanceBetweenDemos, 0f, 0f);
			for (int i = 0; i < expositorData.demos.Length; i++)
			{
				DemoElementData demoElementData = expositorData.demos[i];
				GameObject demoElementGo = (GameObject)PrefabUtility.InstantiatePrefab(demoElementData.prefab, transform);

				lastLocalPosition.x += demoSceneConfig.distanceBetweenDemos;
				lastEnvironment = demoElementData.environment;

				demoElementGo.transform.localPosition = lastLocalPosition;
				demoElementGo.transform.localRotation = Quaternion.identity;
				Debug.LogError($"{gameObject.name} - {demoElementGo.name} at {demoElementGo.transform.localPosition} -t:{Time.time}", demoElementGo);

				DemoElement demoElement = demoElementGo.GetComponent<DemoElement>();

				ArrayUtility.Add(ref demoElements, demoElement);
			}

			currentDemoIndex = 0;
		}
#endif
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoExpositor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoExpositorData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e717b5696b9da764094cc1b224cb9b72
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoExpositorData : ScriptableObject
	{
		public string expositorName;
		public DemoElementData[] demos;
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoExpositorData.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoInfoUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 43bb1bdec3d56ff44ab3d28f90bfbf76
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using System;
using TMPro;
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoInfoUI : MonoBehaviour
	{
		[SerializeField] private RectTransform offScreenT, initialT;
		[SerializeField] private float smoothingAmount;
		[SerializeField] private TMP_Text txtDemoInfo;
		
		private RectTransform myT, currentTargetT;
		private bool isClosed;

		private void Start()
		{
			myT = transform as RectTransform;
			CopyRectTransform(myT, initialT);
			currentTargetT = offScreenT;
			myT.position = currentTargetT.position;
			isClosed = true;
		}

		private void Update()
		{
			if(currentTargetT == null) return;
			myT.position = Vector3.Lerp(myT.position, currentTargetT.position, smoothingAmount * Time.deltaTime);
		}

		public void DemoChanged(DemoElementData demoElementdata)
		{
			txtDemoInfo.text = demoElementdata.info;
		}
		
		public void ShowHideToggle()
		{
			isClosed = !isClosed;
			currentTargetT = isClosed ? offScreenT : initialT;
		}

		private void CopyRectTransform(RectTransform source, RectTransform target)
		{
			if(source == null || target == null)
			{
				Debug.LogError("Source or target RectTransform is null");
				return;
			}
    
			// Copy anchoring
			target.anchorMin = source.anchorMin;
			target.anchorMax = source.anchorMax;
			target.pivot = source.pivot;
    
			// Copy positioning
			target.anchoredPosition = source.anchoredPosition;
			target.anchoredPosition3D = source.anchoredPosition3D;
			target.sizeDelta = source.sizeDelta;
    
			// Copy rotation and scale
			target.rotation = source.rotation;
			target.localRotation = source.localRotation;
			target.localScale = source.localScale;
    
			// Copy offset values
			target.offsetMin = source.offsetMin;
			target.offsetMax = source.offsetMax;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoInfoUI.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoLightUrpIntensity.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: afc39b4cbc1e00449b2ff0c95caeba62
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
    public class DemoLightUrpIntensity : MonoBehaviour
    {
        [SerializeField] private Light thisLight;
        [SerializeField] private float urpIntensityMultiplier = 5f;

#if ALLIN13DSHADER_URP
        private void Start()
        {
            thisLight.intensity *= urpIntensityMultiplier;
        }
#endif

        private void Reset()
        {
            if(thisLight == null) 
            {
                thisLight = GetComponent<Light>();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoLightUrpIntensity.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoSceneConfiguration.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ff5f3343548edfb4687065aa80ba2a44
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoSceneConfiguration : ScriptableObject
	{
		public float scaleDuration = 0.4f;
		public float distanceBetweenDemos = 25f;
		public float cameraTransitionDuration = 1f;
		public float alphaDuration = 0.25f;

		[Header("Curves")]
		public AnimationCurve scalingCurve;
		public AnimationCurve cameraCurve;
		public AnimationCurve alphaCurve;

		[Header("Expositors")]
		public DemoExpositorData[] expositors;
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoSceneConfiguration.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 192a33b5e551b1a4bad83252c99ec644
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using TMPro;
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoUI : MonoBehaviour
	{
		public AllIn13dShaderDemoController demoController;
		public TMP_Text txtExpositorName, txtDemoName, txtDemoViewing;
		public AllIn1DemoScaleTween viewingTween;

		public DemoInfoUI demoInfoUI;

		public void Refresh(DemoExpositor currentExpositor)
		{
			Refresh(currentExpositor.expositorData, currentExpositor.CurrentDemoElement.demoElementData);
		}

		private void Refresh(DemoExpositorData expositorData, DemoElementData demoElementData)
		{
			int currentExpositorIndex = demoController.GetCurrentExpositorIndex() + 1;
			int currentDemoElementIndex = demoController.CurrentExpositor.CurrentDemoElementIndex + 1;
			txtExpositorName.text = $"{currentExpositorIndex}. {expositorData.expositorName}";
			txtDemoName.text = $"{currentDemoElementIndex}. {demoElementData.demoName}";

			demoInfoUI.DemoChanged(demoElementData);
			
			txtDemoViewing.text = $"Viewing: {currentExpositorIndex} - {currentDemoElementIndex}";
			viewingTween.ScaleUpTween();
		}

		public void ShowOrHideDemoInfo()
		{
			demoInfoUI.ShowHideToggle();
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoUI.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoUtils.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 96ac2215b217c5c42994dd053daf7e27
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public static class DemoUtils
	{
		public static float EaseOutBack(float progress)
		{
			const float overshootBase = 2.7f;
			float overshootModifier = overshootBase + 1f;

			float res = 1f + overshootModifier * Mathf.Pow(progress - 1f, 3f) + overshootBase * Mathf.Pow(progress - 1f, 2f);
			return res;
		}

		public static void SetMaterialTransparent(Material mat)
		{
			mat.renderQueue = 3000;
			mat.SetFloat("_BlendSrc", (float)UnityEngine.Rendering.BlendMode.SrcAlpha);
			mat.SetFloat("_BlendDst", (float)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
		}

		public static void SetMaterialOpaque(Material mat)
		{
			mat.renderQueue = 2000;
			mat.SetFloat("_BlendSrc", (float)UnityEngine.Rendering.BlendMode.One);
			mat.SetFloat("_BlendDst", (float)UnityEngine.Rendering.BlendMode.Zero);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoUtils.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/EnvironmentController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1cc14354005b97848bd03e676e4e2f75
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
#if UNITY_EDITOR
using UnityEditor.SceneManagement;
#endif

using UnityEngine;

namespace AllIn13DShader
{
	public class EnvironmentController : MonoBehaviour
	{
		public DemoElement linkedDemoElement;
		public TransformScaler transformScaler;
		public AlphaTween alphaTween;

		public MeshRenderer[] renderers;

		public void Init(DemoSceneConfiguration demoSceneConfig)
		{
			transformScaler.Init(demoSceneConfig, ScaleFinishedCallback);
			alphaTween.Init(demoSceneConfig, renderers);
		}

		private void ScaleFinishedCallback(TransformScaler.ScalingType scalingOperation)
		{
			if(scalingOperation == TransformScaler.ScalingType.SCALING_DOWN)
			{
				Destroy(gameObject);
			}
		}
		public void Show(DemoElement linkedDemoElement)
		{
			gameObject.SetActive(true);
			this.linkedDemoElement = linkedDemoElement;

			transformScaler.ScaleUp();
			alphaTween.FadeIn();
		}

		public void Hide()
		{
			for(int i = 0; i < renderers.Length; i++)
			{
				Material mat = renderers[i].material;
				DemoUtils.SetMaterialTransparent(mat);
			}

			transformScaler.ScaleDown();
			alphaTween.FadeOut();
		}

		protected virtual void Update()
		{

		}

#if UNITY_EDITOR
		[ContextMenu("Setup Renderers")]
		public void SetupRenderers()
		{

			PrefabStage prefabStage = PrefabStageUtility.GetPrefabStage(gameObject);

			if(prefabStage != null)
			{
				this.renderers = transform.GetComponentsInChildren<MeshRenderer>(true);
				EditorSceneManager.MarkSceneDirty(prefabStage.scene);
			}
		}
#endif
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/EnvironmentController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/EnvironmentSpotlightController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d3a1024b9f4c6f140b730bdc467420cc
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class EnvironmentSpotlightController : EnvironmentController
	{
		public Transform lightsParent;
		public float rotationSpeed;

		protected override void Update()
		{
			base.Update();

			Quaternion quat = lightsParent.rotation;
			lightsParent.rotation = quat * Quaternion.AngleAxis(rotationSpeed * Time.deltaTime, lightsParent.up);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/EnvironmentSpotlightController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/InputHandler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8d1c3e379bdb46340b44363dd6b8800a
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;
#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
using UnityEngine.InputSystem;
#endif

namespace AllIn13DShader
{
    public class InputHandler : MonoBehaviour
    {
        [SerializeField] private KeyCode targetKey = KeyCode.A;
        [SerializeField] private KeyCode altKey = KeyCode.None;

#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
        private Key targetNewInputKey;
        private Key altNewInputKey;
        
        private void Awake()
        {
            targetNewInputKey = ConvertKeyCodeToKey(targetKey);
            altNewInputKey = ConvertKeyCodeToKey(altKey);
        }
#endif

        public bool IsKeyPressed()
        {
#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
            if(altKey == KeyCode.None)
            {
                return Keyboard.current != null && Keyboard.current[targetNewInputKey].wasPressedThisFrame;
            }
            return Keyboard.current != null && (Keyboard.current[targetNewInputKey].wasPressedThisFrame || 
                                              Keyboard.current[altNewInputKey].wasPressedThisFrame);
#else
            if(altKey == KeyCode.None)
            {
                return Input.GetKeyDown(targetKey);
            }
            return Input.GetKeyDown(targetKey) || Input.GetKeyDown(altKey);
#endif
        }

        public KeyCode GetTargetKey() => targetKey;
        public KeyCode GetAltKey() => altKey;

#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
        private Key ConvertKeyCodeToKey(KeyCode keyCode)
        {
            switch(keyCode)
            {
                case KeyCode.None: return Key.None;
                case KeyCode.Return: return Key.Enter;
                case KeyCode.KeypadEnter: return Key.NumpadEnter;
            }
            
            if(System.Enum.TryParse(keyCode.ToString(), true, out Key key))
            {
                return key;
            }

            Debug.LogWarning($"Failed to convert KeyCode {keyCode} to Key. Using default Key.None.");
            return Key.None;
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/InputHandler.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/MaterialPrewarmer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e4e063f035a58d54ab72254372789149
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using System.Collections;
using UnityEngine;

namespace AllIn13DShader
{
    public class MaterialPrewarmer : MonoBehaviour
    {
        [SerializeField] private Material[] materialsToPrewarm;
        [SerializeField] private Renderer rendererPrefab;
        [SerializeField] private GameObject[] objectsToPrewarm;
    
        private void Start()
        {
            StartCoroutine(PrewarmMaterials());
        }
    
        private IEnumerator PrewarmMaterials()
        {
            if(materialsToPrewarm == null || materialsToPrewarm.Length == 0)
            {
                Debug.LogWarning("No materials assigned for prewarming.");
                Destroy(gameObject);
                yield break;
            }
        
            if(rendererPrefab == null)
            {
                Debug.LogError("Renderer prefab is not assigned for prewarming.");
                Destroy(gameObject);
                yield break;
            }
            
            Vector3 spawnPos = Vector3.down * 1000f;
        
            // Spawn renderers and assign materials
            for(int i = 0; i < materialsToPrewarm.Length; i++)
            {
                if(materialsToPrewarm[i] == null) continue;
            
                Renderer instance = Instantiate(rendererPrefab, spawnPos, Quaternion.identity, transform);
                instance.material = materialsToPrewarm[i];
            }
            
            for(int i = 0; i < objectsToPrewarm.Length; i++)
            {
                Instantiate(objectsToPrewarm[i], spawnPos, Quaternion.identity, transform);
            }
        
            // Give the GPU a frame to process everything
            yield return new WaitForEndOfFrame();
            yield return null;
        
            Destroy(gameObject);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/MaterialPrewarmer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/OptionsDemo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6388e133eaa564a4ebfa90fcbd40c6f1
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace AllIn13DShader
{
    public class OptionsDemo : MonoBehaviour
    {
        [SerializeField] private Color lockedColor = Color.red;

        [Space, Header("Lock Camera")]
        [SerializeField] private AllIn1MouseTransformRotator allIn1MouseRotate;
        [SerializeField] private TextMeshProUGUI lockCamText;
        [SerializeField] private Image lockCamButtonImage;
        
        [Space, Header("Lock Cursor")]
        [SerializeField] private bool lockCursor = true;
        [SerializeField] private TextMeshProUGUI lockCursorText;
        [SerializeField] private Image lockCursorButtonImage;
        
        [Space, Header("Hide Ui")]
        [SerializeField] private CanvasGroup uiCanvasGroup;
        [SerializeField] private float uiCanvasSmoothing = 5f;

		[Space, Header("Demo Info")]
		[SerializeField] private bool showingDemoInfo = false;
		[SerializeField] private Image showDemoInfoButtonImage;

		private bool cursorIsLocked, camIsLocked, uiIsHidden;
        private float uiCanvasAlpha;

        private void Start()
        {
            cursorIsLocked = lockCursor;
            SetCursorLock();
            
            camIsLocked = false;
            SetCamLock();
        }

        private void Update()
        {
            uiCanvasGroup.alpha = Mathf.Lerp(uiCanvasGroup.alpha, uiIsHidden ? 0f : 1f, Time.unscaledDeltaTime * uiCanvasSmoothing);
        }
        
        public void ToggleCursorButtonPress()
        {
            cursorIsLocked = !cursorIsLocked;
            SetCursorLock();
		}

		public void ToggleShowInfo()
		{
			showingDemoInfo = !showingDemoInfo;
			showDemoInfoButtonImage.color = showingDemoInfo ? lockedColor : Color.clear;
		}

        private void SetCursorLock()
        {
            if(cursorIsLocked)
            {
                Cursor.lockState = CursorLockMode.Locked;
                Cursor.visible = false;
                lockCursorText.text = "Unlock Cursor";
                lockCursorButtonImage.color = lockedColor;
            }
            else
            {
                Cursor.lockState = CursorLockMode.None;
                Cursor.visible = true;
                lockCursorText.text = "Lock Cursor";
                lockCursorButtonImage.color = Color.clear;
            }
        }
        
        public void CamLockButtonPress()
        {
            camIsLocked = !camIsLocked;
            SetCamLock();
        }
        
        
        private void SetCamLock()
        {
            allIn1MouseRotate.enabled = !camIsLocked;
            if(camIsLocked)
            {
                lockCamText.text = "Unlock Camera";
                lockCamButtonImage.color = lockedColor;
            }
            else
            {
                lockCamText.text = "Lock Camera";
                lockCamButtonImage.color = Color.clear;
            }
        }
        
        public void HideUiButtonPress()
        {
            uiIsHidden = !uiIsHidden;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/OptionsDemo.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/PostProcessConfigurator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cb8522dc440232841aa60648309c8fd7
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.SceneManagement;
#endif

using System.IO;
using UnityEngine;

#if ALLIN13DSHADER_BIRP && UNITY_POST_PROCESSING_STACK_V2
using UnityEngine.Rendering.PostProcessing;
#elif ALLIN13DSHADER_URP
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
#endif

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	public class PostProcessConfigurator : MonoBehaviour
	{
		private Camera cam;

#if ALLIN13DSHADER_BIRP && UNITY_POST_PROCESSING_STACK_V2
		public PostProcessProfile postProcessProfileBIRP;
#elif ALLIN13DSHADER_URP
		public VolumeProfile postProcessProfileURP;
#endif

		private void Awake()
		{
			cam = GetComponent<Camera>();

			if(cam == null)
			{
				Debug.LogError("Camera not found in this object!", gameObject);
				return;
			}

#if UNITY_EDITOR
			if (!Application.isPlaying)
			{
				GameObjectUtility.RemoveMonoBehavioursWithMissingScript(gameObject);
#if ALLIN13DSHADER_BIRP && UNITY_POST_PROCESSING_STACK_V2
			ConfigurePostprocessBIRP();
#elif ALLIN13DSHADER_URP
				ConfigurePostprocessURP();
#endif
			}
#endif
		}

#if UNITY_EDITOR
	#if ALLIN13DSHADER_BIRP && UNITY_POST_PROCESSING_STACK_V2
		private void ConfigurePostprocessBIRP()
		{
			PostProcessLayer postProcessLayer;
			if (!cam.gameObject.TryGetComponent<PostProcessLayer>(out postProcessLayer))
			{
				postProcessLayer = cam.gameObject.AddComponent<PostProcessLayer>();
			}

			PostProcessVolume volume;
			if(!cam.gameObject.TryGetComponent<PostProcessVolume>(out volume))
			{
				volume = cam.gameObject.AddComponent<PostProcessVolume>();
			}
			
			postProcessLayer.volumeTrigger = cam.transform;

			if(postProcessProfileBIRP == null)
			{
				string rootFolder = EditorPrefs.GetString("AllIn13DShader_RootPluginFolder", "Assets/AllIn13DShader");
				string profilePath = Path.Combine(rootFolder, "Demo/PostProcessingProfile/3DShaderPP.asset");
				postProcessProfileBIRP = AssetDatabase.LoadAssetAtPath<PostProcessProfile>(profilePath);
			}

			postProcessLayer.volumeLayer = ~0;
			volume.profile = postProcessProfileBIRP;
			volume.isGlobal = true;

			EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
		}
#endif

#if ALLIN13DSHADER_URP
		private void ConfigurePostprocessURP()
		{
			Volume volume;
			if (!cam.gameObject.TryGetComponent<Volume>(out volume))
			{
				volume = cam.gameObject.AddComponent<Volume>();
			}

			if(postProcessProfileURP == null)
			{
				string rootFolder = EditorPrefs.GetString("AllIn13DShader_RootPluginFolder", "Assets/AllIn13DShader");
				string profilePath = Path.Combine(rootFolder, "Demo/PostProcessingProfile/3DShaderPP_URP.asset");
				postProcessProfileURP = AssetDatabase.LoadAssetAtPath<VolumeProfile>(profilePath);
			}

			volume.sharedProfile = (VolumeProfile)postProcessProfileURP;
			EditorUtility.SetDirty(volume);

			UniversalAdditionalCameraData cameraData;
			if(!cam.gameObject.TryGetComponent<UniversalAdditionalCameraData>(out cameraData))
			{
				cameraData = cam.gameObject.AddComponent<UniversalAdditionalCameraData>();
			}
			cameraData.renderPostProcessing = true;

			EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
		}
#endif
#endif
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/PostProcessConfigurator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/SkyController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cc976fd2f3a5382418cd80faae769e86
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
    public class SkyController : MonoBehaviour
    {
        [SerializeField] private Material[] skyMaterials;
        [SerializeField] private int firstSkyIndex = 0;
        [SerializeField] private InputHandler skyChangeInputHandler;

        private int currentSkyIndex;

        public void Init()
        {
            currentSkyIndex = firstSkyIndex;
            
            RenderSettings.defaultReflectionMode = UnityEngine.Rendering.DefaultReflectionMode.Skybox;
            RenderSettings.skybox = skyMaterials[currentSkyIndex];
        }

        public void NextSky()
        {
            currentSkyIndex++;
            if(currentSkyIndex >= skyMaterials.Length)
            {
                currentSkyIndex = 0;
            }

            // Directly set the skybox to the new material
            RenderSettings.skybox = skyMaterials[currentSkyIndex];
            DynamicGI.UpdateEnvironment();
        }

        public void DemoChanged(DemoElementData demoElementData)
        {
            if(demoElementData.skyboxEnabled)
            {
                RenderSettings.skybox = skyMaterials[currentSkyIndex];
            }
            else
            {
                RenderSettings.skybox = null;
            }

            DynamicGI.UpdateEnvironment();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/SkyController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/AlphaTween.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9808fa4c0fb72f24992e04c8617c3cf6
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class AlphaTween : MonoBehaviour
	{
		private static int MATPROP_ID_GENERAL_ALPHA = Shader.PropertyToID("_GeneralAlpha");

		public enum State
		{
			NONE = 0,
			FADE_IN = 1,
			FADE_OUT = 2,
		}

		private MeshRenderer[] meshRenderers;

		private bool IsTweening
		{
			get
			{
				bool res = state != State.NONE;
				return res;
			}
		}

		private AnimationCurve alphaCurve;
		private float duration;
		private float timer;

		private State state;

		private float alphaSrc;
		private float alphaDst;

		public void Init(DemoSceneConfiguration demoSceneConfig, MeshRenderer[] meshRenderers)
		{
			alphaCurve = demoSceneConfig.alphaCurve;
			duration = demoSceneConfig.alphaDuration;
			timer = 0f;

			this.meshRenderers = meshRenderers;

			state = State.NONE;
		}

		public void FadeIn()
		{
			timer = 0f;
			state = State.FADE_IN;

			alphaSrc = 0f;
			alphaDst = 1f;
		}

		public void FadeOut()
		{
			timer = 0f;
			state = State.FADE_OUT;

			alphaSrc = 1f;
			alphaDst = 0f;
		}

		public void Update()
		{
			if (IsTweening)
			{
				UpdateTweening();
			}
		}

		private void UpdateTweening()
		{
			timer += Time.deltaTime;
			float t = timer / duration;
			float curveT = alphaCurve.Evaluate(t);

			float alpha = Mathf.Lerp(alphaSrc, alphaDst, curveT);

			for(int i = 0; i < meshRenderers.Length; i++)
			{
				meshRenderers[i].sharedMaterial.SetFloat(MATPROP_ID_GENERAL_ALPHA, alpha);
			}

			if(t >= 1f)
			{
				state = State.NONE;
				timer = 0f;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/AlphaTween.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PositionTween.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 55365ba5f8752694da63758c0d7d993f
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace AllIn13DShader
{
	public class PositionTween : MonoBehaviour
	{
		// Start is called before the first frame update
		void Start()
		{

		}

		// Update is called once per frame
		void Update()
		{

		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PositionTween.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTween.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c901b6122eaa4db44878b49f5d994634
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class PropertyTween
	{
		protected int propID;
		protected Material mat;
		protected float currentValue;

		[SerializeField] protected string propertyName;

		public virtual void Init(Material mat)
		{
			this.mat = mat;
			propID = Shader.PropertyToID(propertyName);
		}

		public virtual void Update(float deltaTime)
		{
			Tween(deltaTime);
			UpdateMaterial();
		}

		protected virtual void Tween(float deltaTime)
		{

		}

		private void UpdateMaterial()
		{
			mat.SetFloat(propID, currentValue);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTween.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenCollection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eab8b01b4c9522440b3c4c308e49ae16
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[System.Serializable]
	public class PropertyTweenCollection
	{
		public Material mat;

		public PropertyTweenFader[] faderTweens;
		public PropertyTweenSinWave[] sinWaveTweens;

		public void Init()
		{
			if(mat == null) return;
			
			for (int i = 0; i < faderTweens.Length; i++)
			{
				faderTweens[i].Init(mat);
			}

			for (int i = 0; i < sinWaveTweens.Length; i++)
			{
				sinWaveTweens[i].Init(mat);
			}
		}

		public void Update(float deltaTime)
		{
			if(mat == null) return;
			
			for(int i = 0; i < faderTweens.Length; i++)
			{
				faderTweens[i].Update(deltaTime);
			}

			for (int i = 0; i < sinWaveTweens.Length; i++)
			{
				sinWaveTweens[i].Update(deltaTime);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenCollection.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenFader.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 977c8373a22e2be4b8f17402a41cf8e0
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[System.Serializable]
	public class PropertyTweenFader : PropertyTween
	{
		public enum State
		{
			WAITING_FOR_FADE_IN = 0,
			FADING_IN = 1,
			WAITING_FOR_FADE_OUT = 2,
			FADING_OUT = 3,
		}

		private float timer;
		private State state;
		
		[Header("Config")]
		public float waitingForFadeInTime;
		public float fadeInDuration;
		public float waitingForFadeOutTime;
		public float fadeOutDuration;

		public override void Init(Material mat)
		{
			base.Init(mat);

			state = State.WAITING_FOR_FADE_IN;
			timer = 0f;
		}

		protected override void Tween(float deltaTime)
		{
			switch (state)
			{
				case State.WAITING_FOR_FADE_IN:
					UpdateWaitingForFadeIn();
					break;
				case State.FADING_IN:
					UpdateFadingIn();
					break;
				case State.WAITING_FOR_FADE_OUT:
					UpdateWaitingForFadeOut();
					break;
				case State.FADING_OUT:
					UpdateFadingOut();
					break;
			}
		}

		private void UpdateWaitingForFadeIn()
		{
			timer += Time.deltaTime;

			if (timer >= waitingForFadeInTime)
			{
				state = State.FADING_IN;
				timer = 0f;
			}
		}

		private void UpdateFadingIn()
		{
			timer += Time.deltaTime;

			float t = timer / fadeInDuration;
			currentValue = t;

			if (timer >= fadeInDuration)
			{
				state = State.WAITING_FOR_FADE_OUT;
				timer = 0f;
			}
		}

		private void UpdateWaitingForFadeOut()
		{
			timer += Time.deltaTime;

			if (timer >= waitingForFadeOutTime)
			{
				state = State.FADING_OUT;
				timer = 0f;
			}
		}

		private void UpdateFadingOut()
		{
			timer += Time.deltaTime;

			float t = timer / fadeOutDuration;
			currentValue = 1 - t;

			if (timer >= fadeOutDuration)
			{
				state = State.WAITING_FOR_FADE_IN;
				timer = 0f;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenFader.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenSinWave.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 109d7bd9dbc4170448a098f3590a932c
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[System.Serializable]
	public class PropertyTweenSinWave : PropertyTween
	{
		[Header("Configuration")]
		public float minValue;
		public float maxValue;
		public float speed;

		protected override void Tween(float deltaTime)
		{
			float sin01 = (Mathf.Sin(Time.time * speed) + 1f) * 0.5f;

			currentValue = Mathf.Lerp(minValue, maxValue, sin01);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenSinWave.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/SinVerticalPositionTween.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bfd62d9a148e2cf47ad5cddb1f76c278
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using System;
using UnityEngine;

namespace AllIn13DShader
{
	public class SinVerticalPositionTween : MonoBehaviour
	{
		private float timer;

		public float speed = 5;
		public float minY = -1;
		public float maxY = 1;

		public Transform target;

		private void OnEnable()
		{
			timer = 0f;
		}

		private void OnDisable()
		{
			timer = 0f;
		}

		public void Update()
		{
			timer += Time.deltaTime;

			float sin01 = (Mathf.Sin(timer * speed) + 1f) * 0.5f;
			Vector3 localPos = target.localPosition;
			localPos.y = Mathf.Lerp(minY, maxY, sin01);

			target.localPosition = localPos;
		}

		private void Reset()
		{
			if(target == null) target = transform;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/SinVerticalPositionTween.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/TransformScaler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 71c6c2d242f3c2243bf1fcaa88c90071
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using System;
using UnityEngine;

namespace AllIn13DShader
{
	public class TransformScaler : MonoBehaviour
	{
		public enum ScalingType
		{
			NONE,
			SCALING_UP,
			SCALING_DOWN,
		}

		private float scaleDuration;
		private AnimationCurve scaleCurve;

		private Vector3 localScaleSrc;
		private Vector3 localScaleDst;

		private float timer;
		private ScalingType scalingType;

		private Action<ScalingType> scaleFinishedCallback;

		public void Init(DemoSceneConfiguration demoSceneConfig)
		{
			Init(demoSceneConfig, null);
		}

		public void Init(DemoSceneConfiguration demoSceneConfig, Action<ScalingType> scaleFinishedCallback)
		{
			scaleDuration = demoSceneConfig.scaleDuration;
			scaleCurve = demoSceneConfig.scalingCurve;

			this.scaleFinishedCallback = scaleFinishedCallback;
		}

		public void ScaleUp()
		{
			transform.localScale = Vector3.zero;
			timer = 0f;
			scalingType = ScalingType.SCALING_UP;

			localScaleSrc = Vector3.zero;
			localScaleDst = Vector3.one;
		}

		public void ScaleDown()
		{
			transform.localScale = Vector3.one;
			timer = 0f;
			scalingType = ScalingType.SCALING_DOWN;

			localScaleSrc = Vector3.one;
			localScaleDst = Vector3.zero;
		}

		private void Update()
		{
			if (IsScaling())
			{
				UpdateScaling();
			}
		}

		private void UpdateScaling()
		{
			timer += Time.deltaTime;
			float t = timer / scaleDuration;
			float curveT = t;

			if (scalingType == ScalingType.SCALING_UP)
			{
				curveT = scaleCurve.Evaluate(t);
			}
			else if (scalingType == ScalingType.SCALING_DOWN)
			{
				curveT = 1 - scaleCurve.Evaluate(1 - t);
			}

			float scale = Mathf.LerpUnclamped(localScaleSrc.x, localScaleDst.x, curveT);
			scale = Mathf.Max(0f, scale);

			transform.localScale = Vector3.one * scale;

			if (t >= 1f)
			{
				timer = 0f;

				if (scalingType == ScalingType.SCALING_DOWN)
				{
					gameObject.SetActive(false);
				}

				if(scaleFinishedCallback != null)
				{
					scaleFinishedCallback(scalingType);
				}

				scalingType = ScalingType.NONE;
			}
		}

		public bool IsScaling()
		{
			return scalingType != ScalingType.NONE;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/TransformScaler.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn13DShaderComponent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 09fb2c5f145047846ac8e94ce0994dbb
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
#if UNITY_EDITOR
using UnityEditor;
#endif

using UnityEngine;

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	[AddComponentMenu("AllIn13DShader/AddAllIn13DShader")]
	public class AllIn13DShaderComponent : MonoBehaviour
	{
		public Renderer currRenderer;
		public Material currMaterial
		{
			get
			{
				return currRenderer.sharedMaterial;
			}
			set
			{
				currRenderer.sharedMaterial = value;
			}
		}

#if UNITY_EDITOR
		public void NewCleanMaterial(Shader shader, Material matPreset)
		{
			Material previousMat = currMaterial;

			currMaterial = new Material(shader);
			currMaterial.CopyMatchingPropertiesFromMaterial(matPreset);

			string materialName = currMaterial.name;
			int nameStartIndex = materialName.LastIndexOf("/");
			if(nameStartIndex >= 0)
			{
				materialName = materialName.Substring(nameStartIndex + 1);
			}

			currMaterial.name = $"MAT_{materialName}";
		}

		public void CleanMaterial()
		{
			currMaterial = new Material(Shader.Find(ConstantsRuntime.STANDARD_SHADER_NAME));
		}
		 
		public bool CheckValidComponent()
		{
			bool res = true;

			bool dirty = false;
			if (currRenderer == null || currMaterial == null)
			{
				res = res && TryGetComponent<Renderer>(out currRenderer);
				dirty = true;
			}

			if (dirty && res)
			{
				currRenderer = GetComponent<Renderer>();
				
				EditorUtility.SetDirty(this);

				if(currMaterial != null)
				{
					EditorUtility.SetDirty(currMaterial);
				}
			}

			return res;
		}

		public void ApplyMaterialToChildren()
		{
			ApplyMaterialRecursively(transform, currMaterial);
		}

		public Material DuplicateCurrentMaterial()
		{
			currMaterial = new Material(currMaterial);
			return currMaterial;
		}

		private void ApplyMaterialRecursively(Transform tr, Material mat)
		{
			bool existsMeshRenderer = tr.TryGetComponent<Renderer>(out currRenderer);

			if (existsMeshRenderer)
			{
				currRenderer.sharedMaterial = mat;
			}

			int childCount = tr.childCount;
			for(int i = 0; i < childCount; i++)
			{
				ApplyMaterialRecursively(tr.GetChild(i), mat);
			}
		}
#endif
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn13DShaderComponent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn13DShaderRandomTimeSeed.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8302f7da0ee1d6848bcadb44b88c6626
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	public class AllIn13DShaderRandomTimeSeed : MonoBehaviour
	{
		[SerializeField] private float minSeedValue = 0;
		[SerializeField] private float maxSeedValue = 100f;

		private void Start()
		{
			RefreshTimingSeed();
		}

		[ContextMenu("Refresh Timing Seed")]
		private void RefreshTimingSeed()
		{
			MaterialPropertyBlock properties = new MaterialPropertyBlock();
			properties.SetFloat("_TimingSeed", Random.Range(minSeedValue, maxSeedValue));
			GetComponent<Renderer>().SetPropertyBlock(properties);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn13DShaderRandomTimeSeed.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn1DepthColoringProperties.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 550a4f83cc82e43499a5efe7e94a4f5a
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[CreateAssetMenu(menuName = "AllIn13DShader/Others/Depth Coloring Properties", fileName = "DepthColoringProperties.asset")]
	public class AllIn1DepthColoringProperties : ScriptableObject
	{
		public float depthColoringMinDepth;
		public float depthZoneLength;
		public float fallOff;
		public Texture2D depthColoringGradientTex;
		
		private readonly int globalMinDepth = Shader.PropertyToID("global_MinDepth");
		private readonly int globalDepthZoneLength = Shader.PropertyToID("global_DepthZoneLength");
		private readonly int globalDepthGradient = Shader.PropertyToID("global_DepthGradient");
		private readonly int globalDepthGradientFallOff = Shader.PropertyToID("global_DepthGradientFallOff");

		private void OnEnable()
		{
			ApplyValues();
		}

		public void ApplyValues()
		{
			ApplyValues(depthColoringGradientTex);
		}

		public void ApplyValues(Texture gradientTex)
		{
			Shader.SetGlobalFloat(globalMinDepth, depthColoringMinDepth);
			Shader.SetGlobalFloat(globalDepthZoneLength, depthZoneLength);
			Shader.SetGlobalFloat(globalDepthGradientFallOff, fallOff);
			Shader.SetGlobalTexture(globalDepthGradient, gradientTex);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn1DepthColoringProperties.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ConstantsRuntime.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3ea460bdd0e63b64e8d01c3ed5f2d97e
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
namespace AllIn13DShader
{
	public static class ConstantsRuntime
	{
		//Special Properties
		public const string GLOBAL_PROPERTY_GLOBAL_TIME = "allIn13DShader_globalTime";

#if UNITY_EDITOR
		//Standard Shader
#if ALLIN13DSHADER_BIRP
		public const string STANDARD_SHADER_NAME = "Standard";
#elif ALLIN13DSHADER_URP
		public const string STANDARD_SHADER_NAME = "Universal Render Pipeline/Lit";
#else
		public const string STANDARD_SHADER_NAME = "Standard";
#endif

#endif 
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ConstantsRuntime.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/DepthColoringCamera.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bb429cb35d67af14c998db9b8ff58396
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	public class DepthColoringCamera : MonoBehaviour
	{
		[SerializeField] private Camera cam;
		[SerializeField] private AllIn1DepthColoringProperties allIn1DepthColoringProperties;

		[ContextMenu("Enable Depth Texture")]
		public void EnableDepthTexture()
		{
			cam.depthTextureMode = DepthTextureMode.Depth;
		}

#if UNITY_EDITOR
		private void Update()
		{
			Update_Editor();
		}

		private void Reset()
		{
			cam = GetComponent<Camera>();
		}

		private void Update_Editor()
		{
			if(cam != null)
			{
				cam.depthTextureMode = DepthTextureMode.Depth;
			}
		}

		private void OnDrawGizmosSelected()
		{
			if(cam == null || allIn1DepthColoringProperties == null) { return; }

			Vector3 position = Vector3.zero;
			position.z = cam.nearClipPlane + allIn1DepthColoringProperties.depthColoringMinDepth;

			float size = allIn1DepthColoringProperties.depthZoneLength;
			position.z += size * 0.5f;

			Color gizmosColor = Color.blue;
			gizmosColor.a = 0.25f;

			Gizmos.matrix = cam.transform.localToWorldMatrix;
			Gizmos.color = gizmosColor;

			float height = Mathf.Tan(0.5f * cam.fieldOfView * Mathf.Deg2Rad) * cam.farClipPlane * 2f;
			float width = height * cam.aspect;
			Gizmos.DrawCube(position, new Vector3(width, height, size));
		}
#endif
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/DepthColoringCamera.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/FakeLightConfigurator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f2320e0acfff0d641b0ab90e09eef23c
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
using System;
using UnityEngine;

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	public class FakeLightConfigurator : MonoBehaviour
	{
		private readonly int global_lightDirection = Shader.PropertyToID("global_lightDirection");
		private readonly int global_lightColor = Shader.PropertyToID("global_lightColor");

		public Color lightColor = Color.white;

		private void Update()
		{
			Shader.SetGlobalVector(global_lightDirection, -transform.forward);
			Shader.SetGlobalColor(global_lightColor, lightColor);
		}

		private void OnDrawGizmosSelected()
		{
			Vector3 initPos = transform.position;
			Vector3 endPos = initPos + transform.forward * 5f;

			Gizmos.DrawLine(initPos, endPos);
			Gizmos.DrawSphere(endPos, 0.5f);
		}

		private void Reset()
		{
			Light thisLight = GetComponent<Light>();
			if(thisLight != null) lightColor = thisLight.color;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/FakeLightConfigurator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/FastLightingConfigurator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1353b4ef6dd0a1b42968af0266f3e789
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	public class FastLightingConfigurator : MonoBehaviour
	{
		private int globalLightDirectionPropID = Shader.PropertyToID("global_lightDirection");

		public Vector3 globalLightDirection;

		private void Update()
		{
			Shader.SetGlobalVector(globalLightDirectionPropID, globalLightDirection.normalized);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/FastLightingConfigurator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ShaderGlobalTimeController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 736e2efc20149b14183cb7af7a304732
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	public class ShaderGlobalTimeController : MonoBehaviour
	{
		private readonly int globalTimePropertyID = Shader.PropertyToID(ConstantsRuntime.GLOBAL_PROPERTY_GLOBAL_TIME);
		private Vector4 timeVector;

		private void Update()
		{
			timeVector.x = Time.unscaledTime / 20f;
			timeVector.y = Time.unscaledTime;
			timeVector.z = Time.unscaledTime * 2f;
			timeVector.w = Time.unscaledTime * 3f;
			Shader.SetGlobalVector(globalTimePropertyID, timeVector);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ShaderGlobalTimeController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ShadowsConfigurator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 74c2a9bafe054594dba7f6110a0e0fa3
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	public class ShadowsConfigurator : MonoBehaviour
	{
		public Color shadowColor;

		private readonly int shadowColorPropID = Shader.PropertyToID("global_shadowColor");

#if UNITY_EDITOR
		public void Update()
		{
			SetupShadowColor();
		}
#endif

		public void SetupShadowColor()
		{
			Shader.SetGlobalColor(shadowColorPropID, shadowColor);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ShadowsConfigurator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/Desktop/HandDesktopControllerLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f64a1c82ed6e468468d3396fc8f0ecae
# ASMDEF: NONE
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {

    public class HandDesktopControllerLink : MonoBehaviour {
        [Header("Input References")]
        public Hand handRight;
        public Transform handRightFollow;
        public BoxCollider handRightBound;
        [Space]
        public Hand handLeft;
        public Transform handLeftFollow;
        public BoxCollider handLeftBound;
        [Space]
        public Camera headCamera;
        public Transform trackingContainer;
        [Space]
        public AutoHandPlayer player;

        [Header("Input Settings")]
        public float mouseHandMovementSpeed = 0.5f;
        public float mouseHandRotationSpeed = 10;
        public float mouseLookRotationSpeed = 15;
        public float handReturnSpeed = 1f;

        public KeyCode grabKey = KeyCode.Space;
        public KeyCode rightHandSelection = KeyCode.Mouse1;
        public KeyCode leftHandSelection = KeyCode.Mouse0;
        public KeyCode rotationKeycode = KeyCode.Mouse2;

        bool headRoationActive = false;
        bool rightHandSelected = false;
        bool leftHandSelected = false;
        bool rotationSelected = false;

        Vector3 handRightStartPosition;
        Vector3 handLeftStartPosition;

        private void Awake() {
            if(handRight != null) {
                handRight.follow = handRightFollow;
                handRightStartPosition = handRightFollow.localPosition;
            }

            if(handLeft != null) {
                handLeft.follow = handLeftFollow;
                handLeftStartPosition = handLeftFollow.localPosition;
            }
        }

        void Update() {
            CheckSelectionInput();
            CheckMovementInput();
        }

        void OnGUI() {
            ShowInputStates();
        }

        void ShowInputStates() {
            int x = Screen.width - 300;
            int y = 10;
            int width = 280;
            int height = 44;

            GUIStyle redStyle = new GUIStyle(GUI.skin.label);
            redStyle.normal.textColor = Color.red;
            redStyle.fontSize = 16;

            GUIStyle greenStyle = new GUIStyle(GUI.skin.label);
            greenStyle.normal.textColor = Color.green;
            greenStyle.fontSize = 16;

            GUI.Label(new Rect(x, y, width, height), $"Head Rotation Active (Default Selected)", headRoationActive ? greenStyle : redStyle);
            y += height + 5;
            GUI.Label(new Rect(x, y, width, height), $"Right Hand Selected (Press {rightHandSelection})", rightHandSelected ? greenStyle : redStyle);
            y += height + 5;
            GUI.Label(new Rect(x, y, width, height), $"Left Hand Selected (Press {leftHandSelection})", leftHandSelected ? greenStyle : redStyle);
            y += height + 5;
            GUI.Label(new Rect(x, y, width, height), $"Grab (Press {grabKey})", Input.GetKey(grabKey) ? greenStyle : redStyle);
            y += height + 5;
            GUI.Label(new Rect(x, y, width, height), $"Rotation Selected (Press {rotationKeycode})", rotationSelected ? greenStyle : redStyle);
        }

        void CheckSelectionInput() {
            if(handRight != null) {
                rightHandSelected = Input.GetKey(rightHandSelection);
            }

            if(handLeft != null) {
                leftHandSelected = Input.GetKey(leftHandSelection);
            }

            rotationSelected = Input.GetKey(rotationKeycode);
            headRoationActive = !rightHandSelected && !leftHandSelected;

        }
        float xRotation = 0f;
        void CheckMovementInput() {
            Vector2 mousePositionDelta = new Vector2(Input.GetAxis("Mouse X"), Input.GetAxis("Mouse Y")) * Time.deltaTime * 4;

            if(Input.GetKeyDown(KeyCode.LeftControl))
                UnityEngine.Cursor.lockState = UnityEngine.Cursor.lockState == CursorLockMode.Locked ? CursorLockMode.None : CursorLockMode.Locked;

            if(rightHandSelected) {
                if(rotationSelected) {
                    handRightFollow.Rotate(handRightFollow.forward, -mousePositionDelta.x * mouseHandRotationSpeed);
                    handRightFollow.Rotate(handRightFollow.right, mousePositionDelta.y * mouseHandRotationSpeed);
                    handRightBound.transform.Rotate(handRightFollow.forward, -mousePositionDelta.x * mouseHandRotationSpeed);
                    handRightBound.transform.Rotate(handRightFollow.right, mousePositionDelta.y * mouseHandRotationSpeed);

                }
                else {
                    handRightFollow.position += handRightFollow.right * mousePositionDelta.x * mouseHandMovementSpeed;
                    handRightFollow.position += handRightFollow.forward * mousePositionDelta.y * mouseHandMovementSpeed;
                }

                if(handRightBound != null) {
                    handRightFollow.position = handRightBound.ClosestPoint(handRightFollow.position);
                }
            }
            else {
                var handReturnSpeed = this.handReturnSpeed * Time.deltaTime * 60;
                handReturnSpeed = handReturnSpeed * Vector3.Distance(handRightFollow.localPosition, handRightStartPosition) > 0.001f ? handReturnSpeed : 0;
                if(handReturnSpeed > 0)
                    handRightFollow.localPosition = Vector3.MoveTowards(handRightFollow.localPosition, handRightStartPosition, handReturnSpeed + 0.001f);
            }

            if(leftHandSelected) {
                if(rotationSelected) {
                    handLeftFollow.Rotate(handLeftFollow.forward, mousePositionDelta.x * mouseHandRotationSpeed);
                    handLeftFollow.Rotate(handLeftFollow.right, mousePositionDelta.y * mouseHandRotationSpeed);
                    handLeftBound.transform.Rotate(handLeftFollow.forward, mousePositionDelta.x * mouseHandRotationSpeed);
                    handLeftBound.transform.Rotate(handLeftFollow.right, mousePositionDelta.y * mouseHandRotationSpeed);
                }
                else {
                    handLeftFollow.position += handLeftFollow.right * mousePositionDelta.x * mouseHandMovementSpeed;
                    handLeftFollow.position += handLeftFollow.forward * mousePositionDelta.y * mouseHandMovementSpeed;
                }

                if(handLeftBound != null) {
                    handLeftFollow.position = handLeftBound.ClosestPoint(handLeftFollow.position);
                }
            }
            else {
                var handReturnSpeed = this.handReturnSpeed * Time.deltaTime * 60;
                handReturnSpeed = handReturnSpeed * Vector3.Distance(handLeftFollow.localPosition, handLeftStartPosition) > 0.001f ? handReturnSpeed : 0;
                if(handReturnSpeed > 0)
                    handLeftFollow.localPosition = Vector3.MoveTowards(handLeftFollow.localPosition, handLeftStartPosition, handReturnSpeed + 0.001f);
            }

            if(headRoationActive) {
                if(rotationSelected) {
                    xRotation -= mouseLookRotationSpeed * 3 * mousePositionDelta.y;
                    xRotation = Mathf.Clamp(xRotation, -15f, 45f);
                    headCamera.transform.localRotation = Quaternion.Euler(xRotation, 0f, 0f);
                }

                trackingContainer.transform.Rotate(Vector3.up * mouseLookRotationSpeed * 10 * mousePositionDelta.x);
            }

            if(Input.GetKeyDown(grabKey)) {
                if(rightHandSelected) {
                    if(handRight.IsHolding())
                        handRight.Release();
                    else
                        handRight.Grab();
                }

                if(leftHandSelected) {
                    if(handLeft.IsHolding())
                        handLeft.Release();
                    else
                        handLeft.Grab();
                }
            }

            var fowardAxis = Input.GetAxis("Vertical");
            var rightAxis = Input.GetAxis("Horizontal");
            player.Move(new Vector2(rightAxis, fowardAxis));
        }

        void KeepPointWithinBox(Transform point, BoxCollider box) {
            if(box == null) return;

            Vector3 localPos = box.transform.InverseTransformPoint(transform.position);
            Vector3 halfExtents = box.size * 0.5f;

            localPos.x = Mathf.Clamp(localPos.x, -halfExtents.x, halfExtents.x);
            localPos.y = Mathf.Clamp(localPos.y, -halfExtents.y, halfExtents.y);
            localPos.z = Mathf.Clamp(localPos.z, -halfExtents.z, halfExtents.z);

            point.position = box.transform.TransformPoint(localPos);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/Desktop/HandDesktopControllerLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandFingerGestureEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ec8d79f2013f4354eaa4caec5e959e57
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand {
    public class HandFingerGestureEvent : MonoBehaviour {
        public HandFingerGestureTracker handFingerGestureTracker;
        public FingerEnum finger1;
        public FingerEnum[] finger2;

        public UnityEvent<HandFingerGestureTracker, FingerEnum, FingerEnum> OnFingerTouchStartEvent;
        public UnityEvent<HandFingerGestureTracker, FingerEnum, FingerEnum> OnFingerTouchStopEvent;

            void OnEnable() {
            handFingerGestureTracker.OnFingerTouchStart += OnFingerTouchStart;
            handFingerGestureTracker.OnFingerTouchStop += OnFingerTouchStop;
        }

        void OnDisable() {
            handFingerGestureTracker.OnFingerTouchStart -= OnFingerTouchStart;
            handFingerGestureTracker.OnFingerTouchStop -= OnFingerTouchStop;
        }

        void OnFingerTouchStart(OpenXRAutoHandTracking hand, HandFingerGestureTracker gestureTracker, FingerTouchEventArgs e) {
            if (e.finger1 == finger1 && finger2.Contains(e.finger2)) {
                OnFingerTouchStartEvent?.Invoke(gestureTracker, e.finger1, e.finger2);
            }
        }

        void OnFingerTouchStop(OpenXRAutoHandTracking hand, HandFingerGestureTracker gestureTracker, FingerTouchEventArgs e) {
            if (e.finger1 == finger1 && finger2.Contains(e.finger2)) {
                OnFingerTouchStopEvent?.Invoke(handFingerGestureTracker, e.finger1, e.finger2);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandFingerGestureEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandFingerGestureTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 611bae9934a88e64f963d2d0a46d97b2
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {

    public struct FingerTouchEventArgs {
        public FingerEnum finger1;
        public FingerEnum finger2;
    }

    public delegate void FingerTouchStartEvent(OpenXRAutoHandTracking hand, HandFingerGestureTracker gestureTracker, FingerTouchEventArgs e);
    public delegate void FingerTouchStopEvent(OpenXRAutoHandTracking hand, HandFingerGestureTracker gestureTracker, FingerTouchEventArgs e);

    public class HandFingerGestureTracker : MonoBehaviour {
        public OpenXRAutoHandTracking handTracking;
        public float fingerTipScale = 1.5f;
        public float fingerTouchEventDelay = 0.1f;

        bool[][] fingerTouchState;
        bool[][] lastFingerTouchState;
        float[][] lastFingerTouchStateChangeTime;



        public event FingerTouchStartEvent OnFingerTouchStart;
        public event FingerTouchStopEvent OnFingerTouchStop;

        void OnEnable() {
            fingerTouchState = new bool[handTracking.hand.fingers.Length][];
            lastFingerTouchState = new bool[handTracking.hand.fingers.Length][];
            lastFingerTouchStateChangeTime = new float[handTracking.hand.fingers.Length][];

            foreach(var finger in handTracking.hand.fingers) {
                var fingerIndex = (int)finger.fingerType;
                fingerTouchState[fingerIndex] = new bool[handTracking.hand.fingers.Length];
                lastFingerTouchState[fingerIndex] = new bool[handTracking.hand.fingers.Length];
                lastFingerTouchStateChangeTime[fingerIndex] = new float[handTracking.hand.fingers.Length];
            }
        }

        private void FixedUpdate() {
            for (int i = 0; i < handTracking.hand.fingers.Length; i++) {
                for (int j = 0; j < handTracking.hand.fingers.Length; j++) {
                    var finger1 = handTracking.hand.fingers[i];
                    var finger2 = handTracking.hand.fingers[j];

                    var finger1Index = (int)finger1.fingerType;
                    var finger2Index = (int)finger2.fingerType;

                    var distance = Vector3.Distance(finger1.tip.position, finger2.tip.position);
                    var radius = finger1.tipRadius * fingerTipScale + finger2.tipRadius * fingerTipScale;

                    fingerTouchState[finger1Index][finger2Index] = distance < radius;

                    if(fingerTouchState[finger1Index][finger2Index] != lastFingerTouchState[finger1Index][finger2Index] ) {
                        if(Time.fixedTime - lastFingerTouchStateChangeTime[finger1Index][finger2Index] < fingerTouchEventDelay) {
                            continue;
                        }

                        if(fingerTouchState[finger1Index][finger2Index]) {
                            OnFingerTouchStart?.Invoke(handTracking, this, new FingerTouchEventArgs { finger1 = finger1.fingerType, finger2 = finger2.fingerType });
                        }
                        else {
                            OnFingerTouchStop?.Invoke(handTracking, this, new FingerTouchEventArgs { finger1 = finger1.fingerType, finger2 = finger2.fingerType });
                        }

                        lastFingerTouchState[finger1Index][finger2Index] = fingerTouchState[finger1Index][finger2Index];
                        lastFingerTouchStateChangeTime[finger1Index][finger2Index] = Time.fixedTime;
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandFingerGestureTracker.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandGestureEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 01e00988dd614a0408eff7ba7d686db4
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Animations;
using UnityEngine.Events;

namespace Autohand {
    public class HandPoseGestureData {
        public float currentPoseDifference;
        public float[] fingerPoseDifference = new float[5];
        public bool currentPoseState;
        public bool currentActivatedPoseState;
        public bool validPoseDirection;
        public float validDirectionAngleDistance;
        public float gestureStartTime;
        public float gestureStopTime;

        public void UpdatePoseDifferenceValues(Hand hand, ref HandPoseData poseData, FingerMask[] fingerMasks) {
            if(hand == null || hand.handAnimator.currentHandPose.fingerPoses == null)
                return;

            currentPoseDifference = 0f;
            int fingerCount = 0;
            for(int i = 0; i < hand.fingers.Length; i++) {
                var finger = hand.fingers[i];
                var fingerIndex = (int)finger.fingerType;

                float fingerWeight = 1f;
                if(fingerMasks != null) {
                    for(int j = 0; j < fingerMasks.Length; j++) { 
                        if(fingerMasks[j].finger == finger.fingerType) {
                            fingerWeight = fingerMasks[j].weight;
                            break;
                        }
                    }
                }

                fingerPoseDifference[fingerIndex] = Mathf.Clamp(hand.handAnimator.currentHandPose.fingerPoses[fingerIndex].GetPoseDifferenceByAngle(ref poseData.fingerPoses[fingerIndex]) / 90f, 0, 3) * fingerWeight;
                currentPoseDifference += fingerPoseDifference[fingerIndex] ;

                if(fingerWeight > 0)
                    fingerCount++;
            }

            currentPoseDifference /= fingerCount;
        }

        internal void SetInvalidData() {
            if(currentPoseState)
                gestureStopTime = Time.time;
            currentPoseState = false;
            currentActivatedPoseState = false;
            validPoseDirection = false;
        }
    }



    public class HandGestureEvent : HandPoseDataContainer {
        [Header("Gesture Event Settings")]
        public List<OpenXRAutoHandTracking> trackingHands;
        public float minimumPoseDistance = 0.85f;
        public float requiredPoseHoldActivationTime = 0.1f;
        public float requiredPoseStopActivationTime = 0.2f;

        [Header("(Optional) Finger Mask Settings")]
        public FingerMask[] fingerMasks = new FingerMask[0];

        [Header("(Optional) Directional Requirements")]
        [Tooltip("The angle distance required to ACTIVATE the pose, relative to the given axis and relative transform settings")]
        public float requiredActivationAngle = 25f;
        [Tooltip("The angle distance required to MAINTAIN the pose, relative to the given axis and relative transform settings")]
        public float requiredMaintainActivationAngle = 80f;
        public Axis palmAxis = Axis.None;
        public Axis targetAxis = Axis.None;
        public Transform relativeTransform;

        [Header("Gesture Events")]
        public UnityEvent<Hand, HandPoseGestureData> OnGestureStartEvent;
        public UnityEvent<Hand, HandPoseGestureData> OnGestureStopEvent;


        Dictionary<Hand, HandPoseGestureData> currentHandGestureData = new Dictionary<Hand, HandPoseGestureData>();
        int lastHandCount = 0;



        protected virtual void Start() {
            if(requiredActivationAngle > requiredMaintainActivationAngle)
                requiredActivationAngle = requiredMaintainActivationAngle;
        }

        protected virtual void LateUpdate() {
            if (trackingHands == null || trackingHands.Count == 0)
                return;

            CheckForHandListChanges();
            UpdatePoseDifferenceValues();
            CheckGestureEventState();
        }

        public bool IsTrackingActive() {
            foreach(OpenXRAutoHandTracking hand in trackingHands) {
                if(hand.hand == null)
                    return false;
                if(hand.handTrackingActive)
                    return true;
            }

            return false;
        }

        public HandPoseGestureData GetCurrentGestureData(Hand hand) {
            if (currentHandGestureData.ContainsKey(hand))
                return currentHandGestureData[hand];
            return null;
        }

        public bool IsGestureActive(Hand hand) {
            if(currentHandGestureData.ContainsKey(hand))
                return currentHandGestureData[hand].currentPoseState;
            return false;
        }

        public float GetCurrentGestureActivationAmount(Hand hand) {
            if(currentHandGestureData.ContainsKey(hand)) {
                var handGestureData = currentHandGestureData[hand];
                if(!handGestureData.currentPoseState)
                    return Mathf.Clamp01((Time.time - handGestureData.gestureStartTime)/requiredPoseHoldActivationTime);
                else
                    return Mathf.Clamp01(1f-(Time.time - handGestureData.gestureStopTime)/requiredPoseStopActivationTime);
            }
            return 0;
        }

        protected void CheckForHandListChanges() {
            if (trackingHands.Count != lastHandCount) {
                lastHandCount = trackingHands.Count;
                currentHandGestureData.Clear();
                foreach(OpenXRAutoHandTracking hand in trackingHands) {
                    currentHandGestureData.Add(hand.hand, new HandPoseGestureData());
                }
            }
        }

        protected virtual void UpdatePoseDifferenceValues() {

            foreach (OpenXRAutoHandTracking handTracking in trackingHands) {
                var hand = handTracking.hand;
                if (hand == null || (hand.left && !leftPose.isSet) || (!hand.left && !rightPose.isSet)) 
                    continue;

                HandPoseGestureData gestureData = currentHandGestureData[hand];

                if(hand.left)
                    gestureData.UpdatePoseDifferenceValues(hand, ref leftPose, fingerMasks);
                else
                    gestureData.UpdatePoseDifferenceValues(hand, ref rightPose, fingerMasks);

                if(IsGestureActive(handTracking.hand))
                    gestureData.validPoseDirection = IsValidPoseDirection(hand, ref gestureData);
                else
                    gestureData.validPoseDirection = IsValidActivationPoseDirection(hand, ref gestureData);

            }

        }
        protected bool IsValidPoseState(Hand hand, ref HandPoseGestureData gestureData) {
            return gestureData.currentPoseDifference < minimumPoseDistance && gestureData.validPoseDirection && hand.holdingObj == null;
        }

        protected void CheckGestureEventState() {
            foreach (OpenXRAutoHandTracking handTracking in trackingHands) {
                var hand = handTracking.hand;
                var gestureData = currentHandGestureData[hand];
                if(IsValidPoseState(hand, ref gestureData)) 
                    OnGestureStart(hand, ref gestureData);
                else 
                    OnGestureStop(hand, ref gestureData);
            }
        }

        protected virtual void OnGestureStart(Hand hand, ref HandPoseGestureData gestureData) {
            if(!gestureData.currentPoseState) {
                gestureData.currentPoseState = true;
                gestureData.gestureStartTime = Time.time;
            }
            if((Time.time - gestureData.gestureStartTime < requiredPoseHoldActivationTime))
                return;

            if(!gestureData.currentActivatedPoseState) { 
                gestureData.currentActivatedPoseState = true;
                OnGestureStartEvent.Invoke(hand, gestureData);
            }
        }

        protected virtual void OnGestureStop(Hand hand, ref HandPoseGestureData gestureData) {
            if(gestureData.currentPoseState) {
                gestureData.currentPoseState = false;
                gestureData.gestureStopTime = Time.time;
            }

            if(Time.time - gestureData.gestureStopTime < requiredPoseStopActivationTime)
                return;

            if(gestureData.currentActivatedPoseState) {
                gestureData.currentActivatedPoseState = false;
                OnGestureStopEvent.Invoke(hand, gestureData);
            }
        }

        protected virtual bool IsValidActivationPoseDirection(Hand hand, ref HandPoseGestureData data) {
            if(!IsTrackingActive())
                return false;

            if(palmAxis == Axis.None || targetAxis == Axis.None) {
                data.validDirectionAngleDistance = 0;
                return true;
            }

            var angle = Vector3.Angle(GetPalmAxis(hand), GetTargetAxis());
            var angleDistance = angle - requiredActivationAngle;
            angleDistance = Mathf.Clamp(angleDistance, 0, angleDistance);
            data.validDirectionAngleDistance = angleDistance;
            return angleDistance == 0;
        }

        protected virtual bool IsValidPoseDirection(Hand hand, ref HandPoseGestureData data) {
            if(!IsTrackingActive())
                return false;

            if(palmAxis == Axis.None || targetAxis == Axis.None) {
                data.validDirectionAngleDistance = 0;
                return true;
            }

            var angle = Vector3.Angle(GetPalmAxis(hand), GetTargetAxis());
            var angleDistance = angle - requiredMaintainActivationAngle;
            angleDistance = Mathf.Clamp(angleDistance, 0, angleDistance);
            data.validDirectionAngleDistance = angleDistance;
            return angleDistance == 0;
        }



        Vector3 GetPalmAxis(Hand hand) {
            if(palmAxis == Axis.X)
                return hand.palmTransform.right;
            else if(palmAxis == Axis.Y)
                return hand.palmTransform.up;
            else if(palmAxis == Axis.Z)
                return hand.palmTransform.forward;
            return Vector3.zero;
        }

        Vector3 GetTargetAxis() {
            if(relativeTransform == null) {
                if(targetAxis == Axis.X)
                    return Vector3.right;
                else if(targetAxis == Axis.Y)
                    return Vector3.up;
                else if(targetAxis == Axis.Z)
                    return Vector3.forward;
            }
            
            if(targetAxis == Axis.X)
                return relativeTransform.right;
            else if(targetAxis == Axis.Y)
                return relativeTransform.up;
            else if(targetAxis == Axis.Z)
                return relativeTransform.forward;

            return Vector3.zero;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandGestureEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandGestureEventTextWriter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5a295687ecd9b8d49a6cdb452de1f48e
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HandGestureEventTextWriter : MonoBehaviour {
        public HandGestureEvent handGestureEvent;
        public TMPro.TextMeshPro currentPoseDistance;
        public TMPro.TextMeshPro currentPoseRequiredActivation;
        public TMPro.TextMeshPro currentPoseActivation;
        public string materialColorName = "_Color";
        public Renderer[] colorMaterials;
        public Gradient colorGradient;
        

        private void OnEnable() {
            handGestureEvent.OnGestureStartEvent.AddListener(OnGestureStart);
            handGestureEvent.OnGestureStopEvent.AddListener(OnGestureStop);
        }

        private void OnDisable() {
            handGestureEvent.OnGestureStartEvent.RemoveListener(OnGestureStart);
            handGestureEvent.OnGestureStopEvent.RemoveListener(OnGestureStop);
        }

        void OnGestureStart(Hand hand, HandPoseGestureData data) {
            currentPoseDistance.color = Color.green;
        }

        void OnGestureStop(Hand hand, HandPoseGestureData data) {
            currentPoseDistance.color = Color.red;
        }

        private void Update() {
            if(handGestureEvent != null) {
                var gesture = handGestureEvent.GetCurrentGestureData(handGestureEvent.trackingHands[0].hand);
                if(gesture == null)
                    return;

                float currentPoseDistanceValue = gesture.currentPoseDifference + gesture.validDirectionAngleDistance;

                if(currentPoseDistance != null)
                    currentPoseDistance.text = (currentPoseDistanceValue).ToString();
                if(currentPoseRequiredActivation != null)
                    currentPoseRequiredActivation.text = handGestureEvent.minimumPoseDistance.ToString();
                if(currentPoseActivation != null)
                    currentPoseActivation.text = handGestureEvent.GetCurrentGestureActivationAmount(handGestureEvent.trackingHands[0].hand).ToString();

                foreach(var rend in colorMaterials) {
                    if(rend != null && rend.material != null && colorGradient != null)
                        rend.material.SetColor(materialColorName, colorGradient.Evaluate(1f - (currentPoseDistanceValue - handGestureEvent.minimumPoseDistance)));
                }
            }
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandGestureEventTextWriter.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandMapper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: aa16e59d5c8dfd24e9403fac14ea42f3
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using System.Net.NetworkInformation;
using UnityEngine;
using UnityEngine.XR.Hands;

public class OpenXRAutoHandMapper : MonoBehaviour
{
    public Transform wrist;
    public Transform index;
    public Transform thumb;
    public Transform middle;
    public Transform ring;
    public Transform pinky;


    bool handTrackingSkeletonInitialized = false;
    Dictionary<XRHandJointID, Quaternion> _skeletonMap;
    public Dictionary<XRHandJointID, Quaternion> openHandReference {
        get {
            if(!handTrackingSkeletonInitialized) {
                _skeletonMap = new Dictionary<XRHandJointID, Quaternion>();
                var wrist = this.wrist;

                var indexProximal = index;
                var indexIntermediate = index.GetChild(0);
                var indexDistal = indexIntermediate.GetChild(0);
                var indexTip = indexDistal.GetChild(0);

                var middleProximal = middle;
                var middleIntermediate = middle.GetChild(0);
                var middleDistal = middleIntermediate.GetChild(0);
                var middleTip = middleDistal.GetChild(0);

                var ringProximal = ring;
                var ringIntermediate = ring.GetChild(0);
                var ringDistal = ringIntermediate.GetChild(0);
                var ringTip = ringDistal.GetChild(0);

                var littleProximal = pinky;
                var littleIntermediate = pinky.GetChild(0);
                var littleDistal = ringIntermediate.GetChild(0);
                var littleTip = ringDistal.GetChild(0);

                var thumbMetacarpal = thumb;
                var thumbProximal = thumb.GetChild(0);
                var thumbDistal = thumbProximal.GetChild(0);
                var thumbTip = thumbDistal.GetChild(0);

                _skeletonMap.Add(XRHandJointID.Wrist, wrist.rotation);
                _skeletonMap.Add(XRHandJointID.IndexProximal, indexProximal.rotation);
                _skeletonMap.Add(XRHandJointID.IndexIntermediate, indexIntermediate.rotation);
                _skeletonMap.Add(XRHandJointID.IndexDistal, indexDistal.rotation);
                _skeletonMap.Add(XRHandJointID.IndexTip, indexTip.rotation);

                _skeletonMap.Add(XRHandJointID.MiddleProximal, middleProximal.rotation);
                _skeletonMap.Add(XRHandJointID.MiddleIntermediate, middleIntermediate.rotation);
                _skeletonMap.Add(XRHandJointID.MiddleDistal, middleDistal.rotation);
                _skeletonMap.Add(XRHandJointID.MiddleTip, middleTip.rotation);

                _skeletonMap.Add(XRHandJointID.RingProximal, ringProximal.rotation);
                _skeletonMap.Add(XRHandJointID.RingIntermediate, ringIntermediate.rotation);
                _skeletonMap.Add(XRHandJointID.RingDistal, ringDistal.rotation);
                _skeletonMap.Add(XRHandJointID.RingTip, ringTip.rotation);

                _skeletonMap.Add(XRHandJointID.LittleProximal, littleProximal.rotation);
                _skeletonMap.Add(XRHandJointID.LittleIntermediate, littleIntermediate.rotation);
                _skeletonMap.Add(XRHandJointID.LittleDistal, littleDistal.rotation);
                _skeletonMap.Add(XRHandJointID.LittleTip, littleTip.rotation);

                _skeletonMap.Add(XRHandJointID.ThumbMetacarpal, thumbMetacarpal.rotation);
                _skeletonMap.Add(XRHandJointID.ThumbProximal, thumbProximal.rotation);
                _skeletonMap.Add(XRHandJointID.ThumbDistal, thumbDistal.rotation);
                _skeletonMap.Add(XRHandJointID.ThumbTip, thumbTip.rotation);
            }

            return _skeletonMap;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandMapper.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandTracking.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e9d4e856f5462c441b3f79b930e89638
# ASMDEF: Autohand.OpenXR.dll
# ---
using Autohand.Demo;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;
using UnityEngine.XR.Hands;
using UnityEngine.XR.Management;

namespace Autohand {
    public enum AxisEnum {
        right,
        up,
        forward,
        left,
        down,
        back
    }

    [System.Serializable]
    public struct HandPoseOffset {
        public XRHandJointID jointID;
        public Vector3 localPositionOffset;
        public Vector3 localEularRotationOffset;
    }

    [RequireComponent(typeof(XRHandTrackingEvents))]
    public class OpenXRAutoHandTracking : MonoBehaviour {
        [Header("Hand Settings")]
        public Hand hand;
        public OpenXRHandControllerLink controllerLink;
        public AxisEnum upAxis = AxisEnum.up;
        public AxisEnum forwardAxis = AxisEnum.right;
        public Vector3 handOffset = Vector3.zero;
        public Vector3 handRotationOffset = Vector3.zero;
        public float handPoseSmoothingSpeed = 0.5f;
        public List<HandPoseOffset> handPoseOffsets = new List<HandPoseOffset>();

        [Header("Follow Settings")]
        public float followPositionSmoothing = 1f;
        public float followRotationSmoothing = 1f;

        [Header("Gizmos")]
        public bool drawGizmos = true;
        public Color gizmoColor = Color.white;

        FingerPoseData[] _currentHandTrackingPose = new FingerPoseData[5];
        public FingerPoseData[] currentHandTrackingPose { get { return _currentHandTrackingPose; } }

        FingerPoseData[] _currentTargetPose = new FingerPoseData[5];
        public FingerPoseData[] currentTargetPose { get { return _currentTargetPose; } }

        public bool handTrackingActive { get; private set; }
        public bool controllerTrackingActive { get; private set; }

        XRHandTrackingEvents xrHandTrackingEvents;

        bool jointMapInitialized = false;
        XRHandJointID[] _jointIDMap;
        XRHandJointID[] jointIDMap {
            get {
                if(!jointMapInitialized) {
                    _jointIDMap = new XRHandJointID[20];
                    _jointIDMap[(int)FingerEnum.index * 4 + (int)FingerJointEnum.tip] = XRHandJointID.IndexTip;
                    _jointIDMap[(int)FingerEnum.index * 4 + (int)FingerJointEnum.distal] = XRHandJointID.IndexDistal;
                    _jointIDMap[(int)FingerEnum.index * 4 + (int)FingerJointEnum.middle] = XRHandJointID.IndexIntermediate;
                    _jointIDMap[(int)FingerEnum.index * 4 + (int)FingerJointEnum.knuckle] = XRHandJointID.IndexProximal;

                    _jointIDMap[(int)FingerEnum.middle * 4 + (int)FingerJointEnum.tip] = XRHandJointID.MiddleTip;
                    _jointIDMap[(int)FingerEnum.middle * 4 + (int)FingerJointEnum.distal] = XRHandJointID.MiddleDistal;
                    _jointIDMap[(int)FingerEnum.middle * 4 + (int)FingerJointEnum.middle] = XRHandJointID.MiddleIntermediate;
                    _jointIDMap[(int)FingerEnum.middle * 4 + (int)FingerJointEnum.knuckle] = XRHandJointID.MiddleProximal;

                    _jointIDMap[(int)FingerEnum.ring * 4 + (int)FingerJointEnum.tip] = XRHandJointID.RingTip;
                    _jointIDMap[(int)FingerEnum.ring * 4 + (int)FingerJointEnum.distal] = XRHandJointID.RingDistal;
                    _jointIDMap[(int)FingerEnum.ring * 4 + (int)FingerJointEnum.middle] = XRHandJointID.RingIntermediate;
                    _jointIDMap[(int)FingerEnum.ring * 4 + (int)FingerJointEnum.knuckle] = XRHandJointID.RingProximal;

                    _jointIDMap[(int)FingerEnum.pinky * 4 + (int)FingerJointEnum.tip] = XRHandJointID.LittleTip;
                    _jointIDMap[(int)FingerEnum.pinky * 4 + (int)FingerJointEnum.distal] = XRHandJointID.LittleDistal;
                    _jointIDMap[(int)FingerEnum.pinky * 4 + (int)FingerJointEnum.middle] = XRHandJointID.LittleIntermediate;
                    _jointIDMap[(int)FingerEnum.pinky * 4 + (int)FingerJointEnum.knuckle] = XRHandJointID.LittleProximal;

                    _jointIDMap[(int)FingerEnum.thumb * 4 + (int)FingerJointEnum.tip] = XRHandJointID.ThumbTip;
                    _jointIDMap[(int)FingerEnum.thumb * 4 + (int)FingerJointEnum.distal] = XRHandJointID.ThumbDistal;
                    _jointIDMap[(int)FingerEnum.thumb * 4 + (int)FingerJointEnum.middle] = XRHandJointID.ThumbProximal;
                    _jointIDMap[(int)FingerEnum.thumb * 4 + (int)FingerJointEnum.knuckle] = XRHandJointID.ThumbMetacarpal;

                    jointMapInitialized = true;
                }
                return _jointIDMap;
            }
        }

        bool handTrackingSkeletonInitialized = false;
        Dictionary<XRHandJointID, Transform> _skeletonMap;
        Dictionary<XRHandJointID, Transform> skeletonMap {
            get {
                if(!handTrackingSkeletonInitialized) {
                    _skeletonMap = new Dictionary<XRHandJointID, Transform>();
                    var wrist = new GameObject("Wrist").transform;
                    var indexProximal = new GameObject("IndexProximal").transform;
                    var indexIntermediate = new GameObject("IndexIntermediate").transform;
                    var indexDistal = new GameObject("IndexDistal").transform;
                    var indexTip = new GameObject("IndexTip").transform;

                    var middleProximal = new GameObject("MiddleProximal").transform;
                    var middleIntermediate = new GameObject("MiddleIntermediate").transform;
                    var middleDistal = new GameObject("MiddleDistal").transform;
                    var middleTip = new GameObject("MiddleTip").transform;

                    var ringProximal = new GameObject("RingProximal").transform;
                    var ringIntermediate = new GameObject("RingIntermediate").transform;
                    var ringDistal = new GameObject("RingDistal").transform;
                    var ringTip = new GameObject("RingTip").transform;

                    var littleProximal = new GameObject("LittleProximal").transform;
                    var littleIntermediate = new GameObject("LittleIntermediate").transform;
                    var littleDistal = new GameObject("LittleDistal").transform;
                    var littleTip = new GameObject("LittleTip").transform;

                    var thumbMetacarpal = new GameObject("ThumbMetacarpal").transform;
                    var thumbProximal = new GameObject("ThumbProximal").transform;
                    var thumbDistal = new GameObject("ThumbDistal").transform;
                    var thumbTip = new GameObject("ThumbTip").transform;
                    
                    wrist.SetParent(transform);

                    indexProximal.SetParent(wrist);
                    indexIntermediate.SetParent(indexProximal);
                    indexDistal.SetParent(indexIntermediate);
                    indexTip.SetParent(indexDistal);

                    middleProximal.SetParent(wrist);
                    middleIntermediate.SetParent(middleProximal);
                    middleDistal.SetParent(middleIntermediate);
                    middleTip.SetParent(middleDistal);

                    ringProximal.SetParent(wrist);
                    ringIntermediate.SetParent(ringProximal);
                    ringDistal.SetParent(ringIntermediate);
                    ringTip.SetParent(ringDistal);

                    littleProximal.SetParent(wrist);
                    littleIntermediate.SetParent(littleProximal);
                    littleDistal.SetParent(littleIntermediate);
                    littleTip.SetParent(littleDistal);

                    thumbMetacarpal.SetParent(wrist);
                    thumbProximal.SetParent(thumbMetacarpal);
                    thumbDistal.SetParent(thumbProximal);
                    thumbTip.SetParent(thumbDistal);

                    _skeletonMap.Add(XRHandJointID.Wrist, wrist);
                    _skeletonMap.Add(XRHandJointID.IndexProximal, indexProximal);
                    _skeletonMap.Add(XRHandJointID.IndexIntermediate, indexIntermediate);
                    _skeletonMap.Add(XRHandJointID.IndexDistal, indexDistal);
                    _skeletonMap.Add(XRHandJointID.IndexTip, indexTip);

                    _skeletonMap.Add(XRHandJointID.MiddleProximal, middleProximal);
                    _skeletonMap.Add(XRHandJointID.MiddleIntermediate, middleIntermediate);
                    _skeletonMap.Add(XRHandJointID.MiddleDistal, middleDistal);
                    _skeletonMap.Add(XRHandJointID.MiddleTip, middleTip);

                    _skeletonMap.Add(XRHandJointID.RingProximal, ringProximal);
                    _skeletonMap.Add(XRHandJointID.RingIntermediate, ringIntermediate);
                    _skeletonMap.Add(XRHandJointID.RingDistal, ringDistal);
                    _skeletonMap.Add(XRHandJointID.RingTip, ringTip);

                    _skeletonMap.Add(XRHandJointID.LittleProximal, littleProximal);
                    _skeletonMap.Add(XRHandJointID.LittleIntermediate, littleIntermediate);
                    _skeletonMap.Add(XRHandJointID.LittleDistal, littleDistal);
                    _skeletonMap.Add(XRHandJointID.LittleTip, littleTip);

                    _skeletonMap.Add(XRHandJointID.ThumbMetacarpal, thumbMetacarpal);
                    _skeletonMap.Add(XRHandJointID.ThumbProximal, thumbProximal);
                    _skeletonMap.Add(XRHandJointID.ThumbDistal, thumbDistal);
                    _skeletonMap.Add(XRHandJointID.ThumbTip, thumbTip);

                    handTrackingSkeletonInitialized = true;
                }
                return _skeletonMap;
            }
        }

        Transform handControllerFollow = null;

        Transform _handTrackingFollowOffset = null;
        public Transform handTrackingFollowOffset {
            get {
                if(_handTrackingFollowOffset == null) {
                    _handTrackingFollowOffset = new GameObject("HandFollowTrackingOffset").transform;
                    _handTrackingFollowOffset.parent = handTrackingFollow;
                    _handTrackingFollowOffset.localPosition = Vector3.zero;
                    _handTrackingFollowOffset.localRotation = Quaternion.identity;
                }
                return _handTrackingFollowOffset;
            }
        }

        Transform _handTrackingFollow = null;
        public Transform handTrackingFollow {
            get {
                if(_handTrackingFollow == null) {
                    _handTrackingFollow = new GameObject("HandFollowTracking").transform;
                    _handTrackingFollow.parent = hand.transform.parent;
                    _handTrackingFollow.localPosition = Vector3.zero;
                    _handTrackingFollow.localRotation = Quaternion.identity;
                    if(handControllerFollow == null) {
                        if(hand.follow != null)
                            handControllerFollow = hand.follow;
                        else
                            handControllerFollow = handTrackingFollowOffset;
                    }
                    hand.follow = handTrackingFollowOffset;
                }
                return _handTrackingFollow;
            }
        }

        public XRHandJointID GetHandJointID(FingerEnum fingerType, FingerJointEnum fingerJoint) => jointIDMap[(int)fingerType * 4 + (int)fingerJoint];

        public Transform GetHandTransform(XRHandJointID jointID) {
            switch(jointID) {
                case XRHandJointID.IndexProximal: return GetFinger(FingerEnum.index).knuckleJoint;
                case XRHandJointID.IndexIntermediate: return GetFinger(FingerEnum.index).middleJoint;
                case XRHandJointID.IndexDistal: return GetFinger(FingerEnum.index).distalJoint;
                case XRHandJointID.IndexTip: return GetFinger(FingerEnum.index).tip;
                case XRHandJointID.MiddleProximal: return GetFinger(FingerEnum.middle).knuckleJoint;
                case XRHandJointID.MiddleIntermediate: return GetFinger(FingerEnum.middle).middleJoint;
                case XRHandJointID.MiddleDistal: return GetFinger(FingerEnum.middle).distalJoint;
                case XRHandJointID.MiddleTip: return GetFinger(FingerEnum.middle).tip;
                case XRHandJointID.RingProximal: return GetFinger(FingerEnum.ring).knuckleJoint;
                case XRHandJointID.RingIntermediate: return GetFinger(FingerEnum.ring).middleJoint;
                case XRHandJointID.RingDistal: return GetFinger(FingerEnum.ring).distalJoint;
                case XRHandJointID.RingTip: return GetFinger(FingerEnum.ring).tip;
                case XRHandJointID.LittleProximal: return GetFinger(FingerEnum.pinky).knuckleJoint;
                case XRHandJointID.LittleIntermediate: return GetFinger(FingerEnum.pinky).middleJoint;
                case XRHandJointID.LittleDistal: return GetFinger(FingerEnum.pinky).distalJoint;
                case XRHandJointID.LittleTip: return GetFinger(FingerEnum.pinky).tip;
                case XRHandJointID.ThumbMetacarpal: return GetFinger(FingerEnum.thumb).knuckleJoint;
                case XRHandJointID.ThumbProximal: return GetFinger(FingerEnum.thumb).middleJoint;
                case XRHandJointID.ThumbDistal: return GetFinger(FingerEnum.thumb).distalJoint;
                case XRHandJointID.ThumbTip: return GetFinger(FingerEnum.thumb).tip;
            }
            return null;
        }

        Finger GetFinger(FingerEnum fingerType) {
            for(int i = 0; i < hand.fingers.Length; i++) {
                if(hand.fingers[i].fingerType == fingerType)
                    return hand.fingers[i];
            }
            return null;
        }

        Dictionary<XRHandJointID, Pose> handPoseOffsetDictionary;

        protected virtual void OnEnable() {
            xrHandTrackingEvents = GetComponent<XRHandTrackingEvents>();
            if(hand != null)
                xrHandTrackingEvents.handedness = hand.left ? Handedness.Left : Handedness.Right;

            hand.follow = handTrackingFollowOffset;

            for(int i = 0; i < _currentHandTrackingPose.Length; i++)
                _currentHandTrackingPose[i] = new FingerPoseData(hand, hand.fingers[i]);

            for(int i = 0; i < _currentTargetPose.Length; i++)
                _currentTargetPose[i] = new FingerPoseData(hand, hand.fingers[i]);

            if(controllerLink == null) {
                if(!hand.CanGetComponent(out controllerLink))
                    controllerLink = hand.gameObject.GetComponentInChildren<OpenXRHandControllerLink>();
            }

            handPoseOffsetDictionary = new Dictionary<XRHandJointID, Pose>();
            foreach(var poseOffset in handPoseOffsets) {
                var jointTransform = GetHandTransform(poseOffset.jointID);
                if(jointTransform != null) {
                    var basePos = jointTransform.localPosition;
                    var offset = new Pose(
                        basePos + poseOffset.localPositionOffset,
                        Quaternion.Euler(poseOffset.localEularRotationOffset)
                    );
                    handPoseOffsetDictionary.Add(poseOffset.jointID, offset);
                }
            }

            xrHandTrackingEvents.jointsUpdated.AddListener(UpdateSkeletonTransform);
        }

        protected virtual void OnDisable() {
            Debug.Log("OpenXRAutoHandTracking OnDisable");
            handPoseOffsetDictionary.Clear(); 
            xrHandTrackingEvents.jointsUpdated.RemoveListener(UpdateSkeletonTransform);

            hand.enableIK = true;
            hand.follow = handControllerFollow;
            if(controllerLink != null)
                controllerLink.enabled = true;
        }

        protected virtual void Update() {

            hand.enableIK = !xrHandTrackingEvents.handIsTracked;
            hand.follow = xrHandTrackingEvents.handIsTracked ? handTrackingFollowOffset : handControllerFollow;
            if(controllerLink != null) {
                controllerLink.enabled = !xrHandTrackingEvents.handIsTracked;
                controllerTrackingActive = controllerLink.enabled;
            }

            handTrackingActive = xrHandTrackingEvents.handIsTracked;
        }

        protected virtual void UpdateSkeletonTransform(XRHandJointsUpdatedEventArgs args) {
            if(controllerTrackingActive || !handTrackingActive)
                return;

            var xrHand = args.hand;
            if(xrHand == null)
                return;
            var map = skeletonMap;
            foreach(var bone in map) {
                var poseValue = xrHand.GetJoint(bone.Key);
                if(poseValue.TryGetPose(out var pose)) {
                    bone.Value.position = pose.position;
                    bone.Value.rotation = pose.rotation;
                }
            }

            var wristTransform = map[XRHandJointID.Wrist];
            var dist = Vector3.Distance(handTrackingFollow.position, wristTransform.position);
            var angleFrac = Quaternion.Angle(handTrackingFollow.rotation, wristTransform.rotation) / 180f;

            var movePos = dist * 60f * Time.deltaTime;
            movePos += 1f - (Time.deltaTime * 30f * followPositionSmoothing);

            var moveRot = angleFrac * 60f * Time.deltaTime;
            moveRot += 1f - (Time.deltaTime * 30f * followRotationSmoothing);

            handTrackingFollow.localPosition = Vector3.Lerp(handTrackingFollow.localPosition, wristTransform.position, movePos);
            handTrackingFollow.localRotation = Quaternion.Lerp(handTrackingFollow.localRotation, wristTransform.rotation, moveRot);
            handTrackingFollowOffset.localPosition = handOffset;
            handTrackingFollowOffset.localRotation = Quaternion.Euler(handRotationOffset);

            wristTransform.position = hand.transform.TransformPoint(-handOffset);
            wristTransform.rotation = hand.transform.rotation * Quaternion.Inverse(Quaternion.Euler(handRotationOffset));

            foreach(var finger in hand.fingers) {
                var fingerIndex = (int)finger.fingerType;
                if(hand.IsGrabbing() || hand.IsHolding())
                    _currentTargetPose[fingerIndex].SetPoseData(hand, finger);

                for(int i = 0; i < (int)FingerJointEnum.tip; i++) {
                    var jointID = GetHandJointID(finger.fingerType, (FingerJointEnum)i);
                    var skeletonJoint = map[jointID];
                    var fingerTransform = finger.FingerJoints[i];
                    var forward = GetTransformAxis(skeletonJoint, forwardAxis);
                    var up = GetTransformAxis(skeletonJoint, upAxis);
                    var targetRotation = Quaternion.LookRotation(forward, up);
                    var angleDiff = Quaternion.Angle(fingerTransform.rotation, targetRotation) / 180f;

                    var lerpPoint = angleDiff * 60f * Time.deltaTime;
                    lerpPoint += 1f - (Time.deltaTime * 30f * handPoseSmoothingSpeed);
                    fingerTransform.rotation = Quaternion.Lerp(fingerTransform.rotation, targetRotation, lerpPoint);

                    if(handPoseOffsetDictionary.TryGetValue(jointID, out var poseOffset)) {
                        fingerTransform.localPosition = poseOffset.position;
                        fingerTransform.localRotation *= poseOffset.rotation;
                    }
                }
                _currentHandTrackingPose[fingerIndex].SetPoseData(hand, finger);
                if(hand.IsGrabbing() || hand.IsHolding())
                    _currentTargetPose[fingerIndex].SetFingerPose(finger);
            }
        }




        public Vector3 GetTransformAxis(Transform t, AxisEnum axis) {
            switch(axis) {
                case AxisEnum.right: return t.right;
                case AxisEnum.up: return t.up;
                case AxisEnum.forward: return t.forward;
                case AxisEnum.down: return -t.up;
                case AxisEnum.left: return -t.right;
                case AxisEnum.back: return -t.forward;
            }
            return Vector3.zero;
        }

        protected virtual void OnDrawGizmos() {
            if(!Application.isPlaying) return;
            if(drawGizmos && skeletonMap != null) {
                Gizmos.color = gizmoColor;
                foreach(var bone in skeletonMap) {
                    if(bone.Key != XRHandJointID.Wrist) {
                        Gizmos.DrawLine(bone.Value.position, bone.Value.parent.position);
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandTracking.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandTrackingGrabber.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 36fbd61cbe0704849869518b8d6f40b7
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;

namespace Autohand {
    [DefaultExecutionOrder(10002)]
    public class OpenXRAutoHandTrackingGrabber : MonoBehaviour {
        [Tooltip("Reference to the hand tracker responsible for tracking hand movements and poses")]
        public OpenXRAutoHandTracking handTracker;
        [Header("Holding Settings")]
        public bool allowHeldFingerMovement = true;
        [Space]
        [Header("Touch Grab Settings")]
        [Tooltip("The delay in seconds before a grab is released after the grab condition is no longer met")]
        [Min(0)]
        public float releaseGrabDelay = 0.35f;
        [Tooltip("Multiplier for the radius of the finger tip detection spheres used in touch grabbing")]
        [Min(0)]
        public float fingerTipRadiusMultiplier = 2f;
        [Tooltip("Enables or disables grabbing objects by touching them with fingers")]
        public bool useFingerTouchGrabbing = true;
        [Tooltip("Enables or disables releasing objects by touching them with fingers")]
        public bool useFingerTouchReleasing = true;
        [Tooltip("Enables or disables maintaining a held pose while holding an object with finger touch grabbing")]
        public bool useTouchHoldingWithHeldPose = false;


        [Header("Pose Grab Settings")]
        [Tooltip("Enables or disables grabbing objects using predefined hand poses")]
        public bool usePoseGrabbing = true;
        [Tooltip("The minimum closeness required for the hand pose to initiate a grab - closeness is near 0 with open hand pose, near 1 with closed fist pose")]
        [Min(0)]
        public float minPoseGrabCloseness = 0.35f;
        [Tooltip("The maximum closeness allowed for the hand pose to initiate a grab - closeness is near 0 with open hand pose, near 1 with closed fist pose")]
        [Min(0)]
        public float maxPoseGrabCloseness = 0.9f;
        [Space]
        [Tooltip("The delta in the OpenCloseness value required to trigger any grab type. This happens when the hand is moving from open to closed pose, and helps prevent grabbing from triggering by just touching an object. Recommended value range of 0.03f-0.005f")]
        [Min(0)]
        public float minDeltaPoseActivation = 0.01f;

        [Tooltip("The required change in open to closed pose state to guarentee trigger a grab - this allows you to grab objects by quickly making a fist from an open state - this value will become harder to activated when a higher value")]
        [Min(0)]
        public float maxDeltaPoseActivation = 0.035f;


        [Header("Pose Release Settings")]
        [Tooltip("Enables or disables releasing objects using predefined hand poses")]
        public bool usePoseRelease = true; 
        [Tooltip("The minimum openness required for the hand pose to initiate a release")]
        [Min(0)]
        public float minPoseReleaseOpenness = 0f;
        [Tooltip("The maximum openness allowed for the hand pose to initiate a release")]
        [Min(0)]
        public float maxPoseReleaseOpenness = 0.5f;
        [Tooltip("The required change in openness to trigger a release - this allows you to release objects just by quickly making an open hand pose even if the other release condititions aren't met. Helps prevent hand from getting stuck holding something")]
        [Min(0)]
        public float requiredDeltaPoseReleaseOpenness = 0.07f;

        [Header("Pose Squeeze Settings")]
        [Tooltip("Enables or disables squeezing objects using predefined hand poses")]
        public bool usePoseSqueezing = true;
        [Tooltip("The delay in seconds before a squeeze is unsqueezed after the squeeze condition is no longer met")]
        [Min(0)]
        public float squeezeUnsqueezeDelay = 0.5f;
        [Tooltip("Multiplier for the sensitivity of the squeezing pose detection")]
        [Min(0)]
        public float squeezePoseSensitvityMultiplier = 1.5f;



        FingerPoseData[] startOpenPose = new FingerPoseData[5];
        FingerPoseData[] startClosedPose = new FingerPoseData[5];
        FingerPoseData[] currentFingerPoses = new FingerPoseData[5];
        FingerPoseData[] currentSmoothFingerPoses = new FingerPoseData[5];
        FingerPoseData[] grabPoseTarget = new FingerPoseData[5];


        float currentHandOpenCloseState = 0f;
        float[] fingerOpenDifferences = new float[5];
        float[] fingerCloseDifferences = new float[5];
        float[] fingerCurrentOpenClose = new float[5];
        float[] fingerCurrentOpenCloseLastFrame = new float[5];


        float currentHeldOpenState = 0f;
        float currentHeldCloseState = 0f;
        float[] fingerHeldDifferences = new float[5];
        float[] fingerCurrentHeldOpen = new float[5];
        float[] fingerCurrentHeldClose = new float[5];

        
        float currentHeldAnimationFromToState = 0f;
        float[] fingerHeldAnimationFromDifferences = new float[5];
        float[] fingerHeldAnimationToDifferences = new float[5];
        float[] fingerCurrentHeldAnimationFromTo = new float[5];

        
        float deltaCurrentHandOpenClosedState = 0f;


        Grabbable[] currentFingerTouch = new Grabbable[5];
        Collider[] overlapSphereResults = new Collider[128];
        int[] lastColliderLayer = new int[128];

        bool usingHeldPose;
        GrabbablePoseAnimaion heldPoseAnimation;

        float releaseTime;
        float grabTime;



        protected virtual void OnEnable() {
            for(int i = 0; i < currentFingerTouch.Length; i++) {
                currentFingerTouch[i] = null;
            }

            var hand = handTracker.hand;
            for(int i = 0; i < startOpenPose.Length; i++) {
                var finger = hand.fingers[i];
                var fingerIndex = (int)finger.fingerType;
                startOpenPose[fingerIndex] = new FingerPoseData(finger.poseData[(int)FingerPoseEnum.Open]);
                startClosedPose[fingerIndex] = new FingerPoseData(finger.poseData[(int)FingerPoseEnum.Closed]);
                currentFingerPoses[fingerIndex] = new FingerPoseData(finger.poseData[(int)FingerPoseEnum.Closed]);
                currentSmoothFingerPoses[fingerIndex] = new FingerPoseData(finger.poseData[(int)FingerPoseEnum.Closed]);
                grabPoseTarget[fingerIndex] = new FingerPoseData(finger.poseData[(int)FingerPoseEnum.Closed]);
            }

            hand.OnBeforeGrabbed += OnBeforeGrab;
            hand.OnGrabbed += OnGrab;
            hand.OnReleased += OnRelease;
            InputTracking.trackingAcquired += OnControllerTrackingAquired;
        }


        protected virtual void OnDisable() {
            var hand = handTracker.hand;
            hand.OnBeforeGrabbed -= OnBeforeGrab;
            hand.OnGrabbed -= OnGrab;
            hand.OnReleased -= OnRelease;
            InputTracking.trackingAcquired -= OnControllerTrackingAquired;
        }
        


        void OnControllerTrackingAquired(XRNodeState node) {
            var hand = handTracker.hand;
            if((node.nodeType == XRNode.LeftHand && hand.left) || (node.nodeType == XRNode.RightHand && !hand.left)) {
                ResetHandPoseData(hand);
            }
        }

        void ResetHandPoseData(Hand hand) {
            foreach(var finger in hand.fingers) {
                var fingerIndex = (int)finger.fingerType;
                finger.poseData[(int)FingerPoseEnum.Open].CopyFromData(ref startOpenPose[fingerIndex]);
                finger.poseData[(int)FingerPoseEnum.Closed].CopyFromData(ref startClosedPose[fingerIndex]);
            }
        }

        void OnBeforeGrab(Hand hand, Grabbable grab) {
            if(handTracker.controllerTrackingActive)
                return;

            //Physics.SyncTransforms();
            if(!handTracker.hand.usingHighlight || hand.highlighter.currentHighlightTarget == null || !hand.highlighter.currentHighlightTarget.Equals(grab)) {
                handTracker.hand.highlighter.UpdateHighlight(true, true);
                Debug.Log("Backup Highlight");
            }

            ResetHandPoseData(hand);
            for(int i = 0; i < hand.fingers.Length; i++) {
                var finger = hand.fingers[i];
                var fingerIndex = (int)finger.fingerType;
                currentSmoothFingerPoses[fingerIndex].CopyFromData(ref handTracker.currentHandTrackingPose[fingerIndex]);
            }
        }

        void OnGrab(Hand hand, Grabbable grab) {
            if(handTracker.controllerTrackingActive)
                return;

            if(!handTracker.hand.usingHighlight || hand.highlighter.currentHighlightTarget == null || !hand.highlighter.currentHighlightTarget.Equals(grab)) {
                handTracker.hand.highlighter.UpdateHighlight(true, true);
                Debug.Log("Backup Highlight");
            }

            if(grab.GetGrabPose(hand, out var grabPose)) {
                usingHeldPose = true;

                if(grabPose.CanGetComponent<GrabbablePoseAnimaion>(out var poseAnimation))
                    heldPoseAnimation = poseAnimation;
            }

            for(int i = 0; i < hand.fingers.Length; i++) {
                var finger = hand.fingers[i];
                var fingerIndex = (int)finger.fingerType;

                grabPoseTarget[fingerIndex].CopyFromData(ref hand.handAnimator.targetGrabPose.fingerPoses[fingerIndex]);
                currentSmoothFingerPoses[fingerIndex].CopyFromData(ref grabPoseTarget[fingerIndex]);
            }

            grabTime = Time.time;
        }


        void OnRelease(Hand hand, Grabbable grab) {
            if(handTracker.controllerTrackingActive)
                return;

            releaseTime = Time.time;
            usingHeldPose = false; 
            heldPoseAnimation = null;
        }







        public void FixedUpdate() {
            if(handTracker.controllerTrackingActive || !handTracker.enabled)
                return;

            CalculateHandPoseState();
            CheckSqueezeState();
            if(usingHeldPose)
                CalculateHeldPoseState();
        }


        public void LateUpdate() {
            if(handTracker.controllerTrackingActive)
                return;

            CheckSqueezeState();
            UpdateHandHeldPose();
            CheckCurrentFingerTouch();
            CheckForValidGrab();
            CheckForValidRelease();

            if(!handTracker.hand.IsGrabbing() && !handTracker.hand.holdingObj)
                handTracker.hand.handAnimator.currentHandPose.SavePose(handTracker.hand);
        }




        private void UpdateHandHeldPose() {

            var hand = handTracker.hand;
            if(hand.holdingObj != null && !hand.IsGrabbing()) {
                if(allowHeldFingerMovement) {
                    var grabbingLayer = LayerMask.NameToLayer(Hand.grabbingLayerName);
                    var grabbingMask = LayerMask.GetMask(Hand.grabbingLayerName);


                    for(int i = 0; i < hand.highlighter.highlightColliderNonAllocCount; i++) {
                        var collider = hand.highlighter.highlightCollidersNonAlloc[i];
                        if(collider == null)
                            continue;
                        lastColliderLayer[i] = collider.gameObject.layer;
                        collider.gameObject.layer = grabbingLayer;
                    }

                    for(int i = 0; i < hand.fingers.Length; i++) {
                        var finger = hand.fingers[i];
                        var fingerIndex = (int)finger.fingerType;

                        if(usingHeldPose) {
                            if(heldPoseAnimation != null) {
                                grabPoseTarget[fingerIndex].CopyFromData(ref heldPoseAnimation.currentAnimationPose.fingerPoses[fingerIndex]);
                            }

                            currentFingerPoses[fingerIndex].CopyFromData(ref grabPoseTarget[fingerIndex]);
                            if(fingerCurrentHeldOpen[fingerIndex] > fingerCurrentHeldClose[fingerIndex])
                                currentFingerPoses[fingerIndex].LerpDataTo(ref handTracker.currentHandTrackingPose[fingerIndex], (fingerCurrentHeldOpen[fingerIndex] - fingerCurrentHeldClose[fingerIndex])*2f);
                        }
                        else {
                            if(currentFingerTouch[fingerIndex] != null) {
                                currentFingerPoses[fingerIndex].CopyFromData(ref currentSmoothFingerPoses[fingerIndex]);

                                currentFingerPoses[fingerIndex].LerpDataTo(ref handTracker.currentHandTrackingPose[fingerIndex], (Mathf.Clamp01(1f-fingerCurrentOpenClose[fingerIndex])));
                                finger.BendFingerUntilNoHit(hand.fingerBendSteps, grabbingMask, ref currentFingerPoses[fingerIndex], ref startOpenPose[fingerIndex]);
                                currentFingerPoses[fingerIndex].SetPoseData(hand, finger);
                            }
                            else {
                                currentFingerPoses[fingerIndex].CopyFromData(ref handTracker.currentHandTrackingPose[fingerIndex]);
                                //currentFingerPoses[fingerIndex].SetPoseData(hand, finger);
                            }
                        }

                        var angleDiff = Mathf.Sqrt(currentSmoothFingerPoses[fingerIndex].GetPoseDifferenceByAngle(ref currentFingerPoses[fingerIndex]));
                        currentSmoothFingerPoses[fingerIndex].LerpDataTo(ref currentFingerPoses[fingerIndex], Time.deltaTime * angleDiff * 6f);
                        currentSmoothFingerPoses[fingerIndex].SetFingerPose(finger);
                    }

                    for(int i = 0; i < hand.highlighter.highlightColliderNonAllocCount; i++) {
                        if(hand.highlighter.highlightCollidersNonAlloc[i] != null)
                        hand.highlighter.highlightCollidersNonAlloc[i].gameObject.layer = lastColliderLayer[i];
                    }
                }
                else if(!hand.IsGrabbing()){

                    for(int i = 0; i < hand.fingers.Length; i++) {
                        var finger = hand.fingers[i];
                        var fingerIndex = (int)finger.fingerType;

                        if(heldPoseAnimation != null) {
                            grabPoseTarget[fingerIndex].CopyFromData(ref heldPoseAnimation.currentAnimationPose.fingerPoses[fingerIndex]);
                        }

                        currentFingerPoses[fingerIndex].CopyFromData(ref grabPoseTarget[fingerIndex]);
                        currentFingerPoses[fingerIndex].SetFingerPose(finger);
                    }
                }
            }
        }




        void CalculateHandPoseState() {
            var hand = handTracker.hand;

            var fingerCount = hand.fingers.Length;
            currentHandOpenCloseState = 0f;
            deltaCurrentHandOpenClosedState = 0f;

            for(int i = 0; i < fingerCount; i++) {
                var finger = hand.fingers[i];
                var fingerIndex = (int)finger.fingerType;
                fingerCurrentOpenCloseLastFrame[fingerIndex] = fingerCurrentOpenClose[fingerIndex];

                fingerOpenDifferences[fingerIndex] = handTracker.currentHandTrackingPose[fingerIndex].GetPoseDifferenceByAngle(ref startOpenPose[fingerIndex]);
                fingerCloseDifferences[fingerIndex] = handTracker.currentHandTrackingPose[fingerIndex].GetPoseDifferenceByAngle(ref startClosedPose[fingerIndex]);
                fingerCurrentOpenClose[fingerIndex] = CalculatePoseMatch(fingerOpenDifferences[fingerIndex], fingerCloseDifferences[fingerIndex]);

                if(!hand.IsGrabbing())
                    finger.poseData[(int)FingerPoseEnum.Open].CopyFromData(ref handTracker.currentHandTrackingPose[fingerIndex]);
            }

            for(int i = 0; i < fingerCurrentOpenClose.Length; i++) {
                currentHandOpenCloseState += fingerCurrentOpenClose[i];
                deltaCurrentHandOpenClosedState += fingerCurrentOpenClose[i] - fingerCurrentOpenCloseLastFrame[i];
            }
            currentHandOpenCloseState /= fingerCurrentOpenClose.Length;
            deltaCurrentHandOpenClosedState /= fingerCurrentOpenClose.Length;



            float CalculatePoseMatch(float openStateDistance, float closeStateDistance) {
                float openWeight = 1f / (openStateDistance + 1f);
                float closeWeight = 1f / (closeStateDistance + 1f);
                float normalizedValue = closeWeight / (openWeight + closeWeight);

                return normalizedValue;
            }
        }


        void CalculateHeldPoseState() {
            var hand = handTracker.hand;

            var fingerCount = hand.fingers.Length;
            currentHeldOpenState = 0f;
            currentHeldCloseState = 0f;

            for(int i = 0; i < fingerCount; i++) {
                var finger = hand.fingers[i];
                var fingerIndex = (int)finger.fingerType;
                fingerHeldDifferences[fingerIndex] = handTracker.currentHandTrackingPose[fingerIndex].GetPoseDifferenceByAngle(ref grabPoseTarget[fingerIndex]);
                fingerCurrentHeldOpen[fingerIndex] = CalculatePoseMatch(fingerHeldDifferences[fingerIndex], fingerOpenDifferences[fingerIndex]);
                fingerCurrentHeldClose[fingerIndex] = CalculatePoseMatch(fingerHeldDifferences[fingerIndex], fingerCloseDifferences[fingerIndex]);
            }

            for(int i = 0; i < fingerCurrentOpenClose.Length; i++) {
                currentHeldOpenState += fingerCurrentHeldOpen[i];
                currentHeldCloseState += fingerCurrentHeldClose[i];
            }
            currentHeldOpenState /= fingerCurrentHeldOpen.Length;
            currentHeldCloseState /= fingerCurrentHeldClose.Length;

            float CalculatePoseMatch(float openStateDistance, float closeStateDistance) {
                float openWeight = 1f / (openStateDistance + 1f);
                float closeWeight = 1f / (closeStateDistance + 1f);
                float normalizedValue = closeWeight / (openWeight + closeWeight);

                return normalizedValue;
            }
        }


        public void CheckSqueezeState() {
            if(usePoseSqueezing) {
                var hand = handTracker.hand;
                float squeezeState = 0f;
                if(usingHeldPose) {
                    if(heldPoseAnimation != null) {

                        var fingerCount = hand.fingers.Length;
                        currentHeldAnimationFromToState = 0f;

                        for(int i = 0; i < fingerCount; i++) {
                            var finger = hand.fingers[i];
                            var fingerIndex = (int)finger.fingerType;
                            fingerHeldAnimationFromDifferences[fingerIndex] = handTracker.currentHandTrackingPose[fingerIndex].GetPoseDifferenceByAngle(ref heldPoseAnimation.fromPose.GetHandPoseData(hand).fingerPoses[fingerIndex]);
                            fingerHeldAnimationToDifferences[fingerIndex] = handTracker.currentHandTrackingPose[fingerIndex].GetPoseDifferenceByAngle(ref heldPoseAnimation.toPose.GetHandPoseData(hand).fingerPoses[fingerIndex]);
                            fingerCurrentHeldAnimationFromTo[fingerIndex] = CalculatePoseMatch(fingerHeldAnimationFromDifferences[fingerIndex], fingerHeldAnimationToDifferences[fingerIndex]);
                        }

                        int addCount = 0;
                        for(int i = 0; i < fingerCurrentHeldAnimationFromTo.Length; i++) {
                            //If the value is 0.5f it means the fingers on each pose are in the same position
                            //so the squeeze state shouldn't be checking these fingers for the final squeeze amount
                            if(fingerCurrentHeldAnimationFromTo[i] != 0.5f) {
                                currentHeldAnimationFromToState += fingerCurrentHeldAnimationFromTo[i];
                                addCount++;
                            }

                        }
                        currentHeldAnimationFromToState /= addCount;

                        float CalculatePoseMatch(float openStateDistance, float closeStateDistance) {
                            float openWeight = 1 / (openStateDistance + 1);
                            float closeWeight = 1 / (closeStateDistance + 1);
                            float normalizedValue = closeWeight / (openWeight + closeWeight);

                            return normalizedValue;
                        }

                        squeezeState = currentHeldAnimationFromToState * squeezePoseSensitvityMultiplier * 1.25f;
                        hand.SetGrip(squeezeState, squeezeState);

                    }
                    else {
                        squeezeState = Mathf.Clamp01(currentHeldCloseState) * squeezePoseSensitvityMultiplier;
                        hand.SetGrip(squeezeState, squeezeState);
                    }
                }
                else {
                    squeezeState = currentHandOpenCloseState * squeezePoseSensitvityMultiplier;
                    hand.SetGrip(squeezeState, squeezeState);
                }

                if(squeezeState >= 1f && !hand.squeezing)
                    hand.Squeeze();
                else if(squeezeState < 1f && hand.squeezing)
                    hand.Unsqueeze();
            }
        }




        public void CheckCurrentFingerTouch() {
            if(!(useFingerTouchGrabbing && useFingerTouchReleasing))
                return;

            var hand = handTracker.hand;

            var grabbingLayer = LayerMask.NameToLayer(Hand.grabbingLayerName);
            var grabbingMask = LayerMask.GetMask(Hand.grabbingLayerName);
            for (int i = 0; i < hand.highlighter.highlightColliderNonAllocCount; i++) {
                if(hand.highlighter.highlightCollidersNonAlloc[i] == null)
                    continue;
                var collider = hand.highlighter.highlightCollidersNonAlloc[i].gameObject;
                lastColliderLayer[i] = collider.layer;
                collider.layer = grabbingLayer;
            }

            foreach (var finger in hand.fingers) {
                int fingerIndex = (int)finger.fingerType;
                var fingerTip = finger.tip;
                for (int i = 0; i < hand.highlighter.highlightColliderNonAllocCount; i++) {
                    var resultCount = Physics.OverlapSphereNonAlloc(fingerTip.position, finger.tipRadius*fingerTipRadiusMultiplier, overlapSphereResults, grabbingMask);
                    if (resultCount > 0) {
                        //Checks all the overlaps until it finds a grabbable object
                        int index = -1;
                        do {
                            index++;
                            if(index >= resultCount) break;
                        }
                        while(!AutoHandExtensions.HasGrabbable(overlapSphereResults[index], out currentFingerTouch[fingerIndex]) || (currentFingerTouch[fingerIndex] == null || !(currentFingerTouch[fingerIndex] is Grabbable)));
                    }
                    else {
                        currentFingerTouch[fingerIndex] = null;
                    }
                }
            }

            for (int i = 0; i < hand.highlighter.highlightColliderNonAllocCount; i++) {
                if(hand.highlighter.highlightCollidersNonAlloc[i] == null)
                    continue;
                hand.highlighter.highlightCollidersNonAlloc[i].gameObject.layer = lastColliderLayer[i];
            }
        }



        public void CheckForValidGrab() {
            var hand = handTracker.hand;
            if(hand.holdingObj != null || hand.IsGrabbing() || deltaCurrentHandOpenClosedState < minDeltaPoseActivation || Time.time - releaseTime < releaseGrabDelay)
                return;

            if(useFingerTouchGrabbing && GetValidFingerGrabState(out var touchingGrabbable)) {
                if(touchingGrabbable.GetGrabPose(hand, out _)) {
                    hand.Grab(GrabType.InstantGrab);
                }
                else if(touchingGrabbable.CanGrab(hand)) {
                    hand.CreateGrabConnection(touchingGrabbable, true);
                }
            }
            else if(usePoseRelease && currentHandOpenCloseState > minPoseGrabCloseness && currentHandOpenCloseState < maxPoseGrabCloseness && deltaCurrentHandOpenClosedState > maxDeltaPoseActivation) {
                hand.Grab();
            }
        }




        public void CheckForValidRelease() {
            var hand = handTracker.hand;
            if(hand.holdingObj == null || hand.IsGrabbing() || Time.time - grabTime < releaseGrabDelay)
                return;

            if(useFingerTouchReleasing && allowHeldFingerMovement) { 
                if(usingHeldPose && !GetValidFingerPoseHoldState()) {
                    hand.Release();
                }
                else if(!usingHeldPose && !GetValidFingerGrabState(out _)) {
                    hand.Release();
                }
            }
            
            if(usePoseGrabbing && (currentHandOpenCloseState > minPoseReleaseOpenness && currentHandOpenCloseState < maxPoseReleaseOpenness && deltaCurrentHandOpenClosedState < -requiredDeltaPoseReleaseOpenness)) {
                hand.Release();
            }
        }


        bool GetValidFingerGrabState(out Grabbable currentTouchingGrabbable) {
            //Making sure that all the fingers are touching the same object
            Grabbable firstFound = null;
            if(handTracker.hand.holdingObj != null)
                firstFound = handTracker.hand.holdingObj;
            else {
                for(int i = 0; i < currentFingerTouch.Length; i++) {
                    if(currentFingerTouch[i] == null)
                        continue;
                    if(firstFound == null)
                        firstFound = currentFingerTouch[i];
                }
            }

            bool thumbTouching = currentFingerTouch[(int)FingerEnum.thumb] != null;
            bool indexTouching = currentFingerTouch[(int)FingerEnum.index] != null && currentFingerTouch[(int)FingerEnum.index] == firstFound;
            bool middleTouching = currentFingerTouch[(int)FingerEnum.middle] != null && currentFingerTouch[(int)FingerEnum.middle] == firstFound;
            bool ringTouching = currentFingerTouch[(int)FingerEnum.ring] != null && currentFingerTouch[(int)FingerEnum.ring] == firstFound;
            bool pinkyTouching = currentFingerTouch[(int)FingerEnum.pinky] != null && currentFingerTouch[(int)FingerEnum.pinky] == firstFound;

            bool[] fingerTouchs = new bool[5];
            fingerTouchs[(int)FingerEnum.thumb] = thumbTouching;
            fingerTouchs[(int)FingerEnum.index] = indexTouching;
            fingerTouchs[(int)FingerEnum.middle] = middleTouching;
            fingerTouchs[(int)FingerEnum.ring] = ringTouching;
            fingerTouchs[(int)FingerEnum.pinky] = pinkyTouching;

            bool[] validGrabs = {
                thumbTouching && (indexTouching || middleTouching || ringTouching || pinkyTouching),
                (indexTouching || pinkyTouching) && middleTouching && ringTouching,
                (indexTouching && middleTouching),
                (middleTouching && ringTouching),
            };

            //This is an advanced requirement for grabbing,
            //It didn't feel right to grab objects with an almost fully open hand without using a thumb,
            //but it should be possible to hold an object without using the thumb when the fingers are more bent
            //This is a requirement for how much the fingers should be closed when grabbing for each of the above conditions
            float[][] validGrabClosedFingerRequirements = new float[validGrabs.Length][];
            validGrabClosedFingerRequirements[0] = new float[5];
            validGrabClosedFingerRequirements[0][(int)FingerEnum.thumb] = 0.1f;
            validGrabClosedFingerRequirements[0][(int)FingerEnum.index] = 0.1f;
            validGrabClosedFingerRequirements[0][(int)FingerEnum.middle] = 0.1f;
            validGrabClosedFingerRequirements[0][(int)FingerEnum.ring] = 0.1f;
            validGrabClosedFingerRequirements[0][(int)FingerEnum.pinky] = 0.1f;

            validGrabClosedFingerRequirements[1] = new float[5];
            validGrabClosedFingerRequirements[1][(int)FingerEnum.index] = 0.15f;
            validGrabClosedFingerRequirements[1][(int)FingerEnum.middle] = 0.15f;
            validGrabClosedFingerRequirements[1][(int)FingerEnum.ring] = 0.15f;
            validGrabClosedFingerRequirements[1][(int)FingerEnum.pinky] = 0.15f;

            validGrabClosedFingerRequirements[2] = new float[5];
            validGrabClosedFingerRequirements[2][(int)FingerEnum.index] = 0.3f;
            validGrabClosedFingerRequirements[2][(int)FingerEnum.middle] = 0.3f;

            validGrabClosedFingerRequirements[3] = new float[5];
            validGrabClosedFingerRequirements[3][(int)FingerEnum.middle] = 0.3f;
            validGrabClosedFingerRequirements[3][(int)FingerEnum.ring] = 0.3f;

            //As a part of checking the previous validGrabClosedFingerRequirements we need to know which finger bend values matter
            int[][] fingerIndecies = new int[][] {
                new int[] { (int)FingerEnum.thumb, (int)FingerEnum.index, (int)FingerEnum.middle, (int)FingerEnum.ring, (int)FingerEnum.pinky },
                new int[] { (int)FingerEnum.index, (int)FingerEnum.middle, (int)FingerEnum.ring, (int)FingerEnum.pinky },
                new int[] { (int)FingerEnum.index, (int)FingerEnum.middle },
                new int[] { (int)FingerEnum.middle, (int)FingerEnum.ring },
            };

            bool validGrabFound = false;
            int resultIndex = -1;
            for(int i = 0; i < validGrabs.Length; i++) {
                //Checking if the fingers are touching the same object
                if(validGrabs[i]) {
                    validGrabFound = true;
                    //Checking if the fingers are bent enough to hold the object
                    for(int j = 0; j < fingerIndecies[i].Length; j++) {
                        int fingerIndex = fingerIndecies[i][j];
                        if(fingerTouchs[fingerIndex] && fingerCurrentOpenClose[fingerIndex] < validGrabClosedFingerRequirements[i][fingerIndex]) {
                            validGrabFound = false;
                            break;
                        }
                    }

                    if(validGrabFound) {
                        resultIndex = i;
                        break;
                    }
                }
            }

            if(resultIndex != -1)
                currentTouchingGrabbable = firstFound;
            else
                currentTouchingGrabbable = null;

            var validFingerState = validGrabFound && (currentTouchingGrabbable != null);

            return validFingerState;
        }


        bool[] fingerTouchs = new bool[5];
        bool GetValidFingerPoseHoldState() {

            bool thumbTouching = fingerCurrentHeldOpen[(int)FingerEnum.thumb] < (fingerCurrentHeldClose[(int)FingerEnum.thumb] + 0.025f);
            bool indexTouching = fingerCurrentHeldOpen[(int)FingerEnum.index] < (fingerCurrentHeldClose[(int)FingerEnum.index] + 0.025f);
            bool middleTouching = fingerCurrentHeldOpen[(int)FingerEnum.middle] < (fingerCurrentHeldClose[(int)FingerEnum.middle] + 0.025f);
            bool ringTouching = fingerCurrentHeldOpen[(int)FingerEnum.ring] < (fingerCurrentHeldClose[(int)FingerEnum.ring] + 0.025f);
            bool pinkyTouching = fingerCurrentHeldOpen[(int)FingerEnum.pinky] < (fingerCurrentHeldClose[(int)FingerEnum.pinky] + 0.025f);

            fingerTouchs[(int)FingerEnum.thumb] = thumbTouching;
            fingerTouchs[(int)FingerEnum.index] = indexTouching;
            fingerTouchs[(int)FingerEnum.middle] = middleTouching;
            fingerTouchs[(int)FingerEnum.ring] = ringTouching;
            fingerTouchs[(int)FingerEnum.pinky] = pinkyTouching;

            bool[] validGrabs = {
                thumbTouching && (indexTouching || middleTouching || ringTouching || pinkyTouching),
                (indexTouching || pinkyTouching) && middleTouching && ringTouching,
                (indexTouching && middleTouching),
                (middleTouching && ringTouching)
            };

            bool validGrabFound = false;
            for(int i = 0; i < validGrabs.Length; i++)
                if(validGrabs[i]) {
                    validGrabFound = true;
                    break;
                }

            return validGrabFound;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandTrackingGrabber.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/InputActionEnabler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2fdbfe0f72b1c19428bfe6794d5b84bb
# ASMDEF: Autohand.OpenXR.dll
# ---
using UnityEngine;
using UnityEngine.InputSystem;

public class InputActionEnabler : MonoBehaviour
{
    [SerializeField]
    InputActionAsset m_ActionAsset;
    public InputActionAsset actionAsset
    {
        get => m_ActionAsset;
        set => m_ActionAsset = value;
    }

    private void OnEnable()
    {
        if (m_ActionAsset != null)
        {
            m_ActionAsset.Enable();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/InputActionEnabler.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRAutoHandAxisFingerBender.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ae318a94acdfcfc48a42e1a95918afbb
# ASMDEF: Autohand.OpenXR.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

public class OpenXRAutoHandAxisFingerBender : MonoBehaviour{
    public Hand hand;
    public InputActionProperty bendAction;

    [HideInInspector]
    public float[] bendOffsets;
    float lastAxis;

    public void OnEnable() {
        if(bendAction.action != null) bendAction.action.Enable();
    }

    void LateUpdate()
    {
        var currAxis = bendAction.action.ReadValue<float>();
        for (int i = 0; i < bendOffsets.Length; i++)
        {
            hand.fingers[i].bendOffset += (currAxis - lastAxis) * bendOffsets[i];
        }
        lastAxis = currAxis;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRAutoHandAxisFingerBender.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRAutoHandFingerBender.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 390319e4c7788aa4b830a191e6251b9e
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

namespace Autohand.Demo{
    public class OpenXRAutoHandFingerBender : MonoBehaviour{
        public Hand hand;
        public InputActionProperty bendAction;
        public InputActionProperty unbendAction;
        
        [HideInInspector]
        public float[] bendOffsets;

        bool pressed;

        private void OnEnable() {
            if (bendAction.action != null) bendAction.action.Enable();
            if (bendAction.action != null) bendAction.action.performed += BendAction;
            if (unbendAction.action != null) unbendAction.action.Enable();
            if (unbendAction.action != null) unbendAction.action.performed += UnbendAction;
        }
        private void OnDisable(){
            if (bendAction.action != null) bendAction.action.performed -= BendAction;
            if (unbendAction.action != null) unbendAction.action.performed -= UnbendAction;
        }

        void BendAction(InputAction.CallbackContext a) {
            if (!pressed) {
                pressed = true;
                for(int i = 0; i < hand.fingers.Length; i++) {
                    hand.fingers[i].bendOffset += bendOffsets[i];
                }
            }
        }

        void UnbendAction(InputAction.CallbackContext a) {
            if (pressed) {
                pressed = false;
                for(int i = 0; i < hand.fingers.Length; i++) {
                    hand.fingers[i].bendOffset -= bendOffsets[i];
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRAutoHandFingerBender.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRControllerEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 077b3010e24b7254cb82521764590177
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using UnityEngine.InputSystem;
using UnityEngine.Events;


public class OpenXRControllerEvent : MonoBehaviour{
    public InputActionProperty action;
    public UnityEvent inputEvent;

    protected virtual void OnEnable(){
        action.action.Enable();
        action.action.performed += OnInputEvent;
    }

    protected virtual void OnDisable(){
        action.action.performed -= OnInputEvent;
    }

    protected virtual void OnInputEvent(InputAction.CallbackContext context) {
        inputEvent?.Invoke();
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRControllerEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRGrabbableInput.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 47d70464fd5da414db30a6f057338aa3
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    //Coupled with the OpenXRHeldGrabbableInput script
    public class OpenXRGrabbableInput : MonoBehaviour {
        Grabbable grabbable;
        public bool inputReleaseOnHandRelease = true;
        public int inputLayer = 0;
        public UnityHandGrabEvent inputPressed;
        public UnityHandGrabEvent inputReleased;

        public bool inputActive { get; set; }

        private void OnEnable() {
            grabbable = GetComponent<Grabbable>();
            grabbable.onRelease.AddListener(OnRelease);
        }

        private void OnDisable() {
            grabbable.onRelease.RemoveListener(OnRelease);
        }

        public void OnRelease(Hand hand, Grabbable grab) {
            if(inputReleaseOnHandRelease)
                ReleaseInput(hand);
        }

        public void PressInput(Hand hand) {
            if(!inputActive)
                inputPressed.Invoke(hand, grabbable);
            inputActive = true;
        }

        public void ReleaseInput(Hand hand) {
            if(inputActive)
                inputReleased.Invoke(hand, grabbable);
            inputActive = false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRGrabbableInput.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandControllerLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e0a0b8441c4cca543a7a89c0403302ee
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections.Generic;
using System.Data;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.XR;
using InputDevice = UnityEngine.XR.InputDevice;
//using UnityEngine.XR.OpenXR.Input;

namespace Autohand.Demo {
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/controller-input")]
    public class OpenXRHandControllerLink : HandControllerLink {
        public InputActionProperty grabAxis;
        public InputActionProperty squeezeAxis;
        public InputActionProperty grabAction;
        public InputActionProperty releaseAction;
        public InputActionProperty squeezeAction;
        public InputActionProperty stopSqueezeAction;
        public InputActionProperty hapticAction;

        XRNode role;
        InputDevice device;
        List<InputDevice> devices = new List<InputDevice>();

        private bool squeezing;
        private bool grabbing;
        private void Start() {
            if(hand.left)
                handLeft = this;
            else
                handRight = this;
        }
            

        public void OnEnable(){
            if (grabAction == squeezeAction){
                Debug.LogError("AUTOHAND: You are using the same button for grab and squeeze on HAND CONTROLLER LINK, this will create conflict or errors", this);
            }

            if(grabAxis.action != null) grabAxis.action.Enable();
            if(squeezeAxis.action != null) squeezeAxis.action.Enable();
            if(hapticAction.action != null) hapticAction.action.Enable();
            if(grabAction.action != null) grabAction.action.performed += Grab;
            if (grabAction.action != null) grabAction.action.Enable();
            if (grabAction.action != null) grabAction.action.performed += Grab;
            if (releaseAction.action != null) releaseAction.action.Enable();
            if (releaseAction.action != null) releaseAction.action.performed += Release;
            if (squeezeAction.action != null) squeezeAction.action.Enable();
            if (squeezeAction.action != null) squeezeAction.action.performed += Squeeze;
            if (stopSqueezeAction.action != null) stopSqueezeAction.action.Enable();
            if (stopSqueezeAction.action != null) stopSqueezeAction.action.performed += StopSqueeze;


            if(hand.left)
                role = XRNode.LeftHand;
            else
                role = XRNode.RightHand;

        }


        void OnDisable() {
            if(grabAction.action != null) grabAction.action.performed -= Grab;
            if(releaseAction.action != null) releaseAction.action.performed -= Release;
            if(squeezeAction.action != null) squeezeAction.action.performed -= Squeeze;
            if(stopSqueezeAction.action != null) stopSqueezeAction.action.performed -= StopSqueeze;

        }




        private void Update() {
            hand.SetGrip(grabAxis.action.ReadValue<float>(), squeezeAxis.action.ReadValue<float>());
        }

        private void Grab(InputAction.CallbackContext grab){
            if (!grabbing){
                hand.Grab();
                grabbing = true;
            }
        }
        
        private void Release(InputAction.CallbackContext grab){
            if (grabbing){
                hand.Release();
                grabbing = false;
            }
        }

        private void Squeeze(InputAction.CallbackContext grab){
            if (!squeezing){
                hand.Squeeze();
                squeezing = true;
            }
        }
        
        private void StopSqueeze(InputAction.CallbackContext grab){
            if (squeezing){
                hand.Unsqueeze();
                squeezing = false;
            }
        }

        public override void TryHapticImpulse(float duration, float amp, float freq = 10) {

            InputDevices.GetDevicesAtXRNode(role, devices);
            //OpenXRInput.SendHapticImpulse(hapticAction.action, amp, duration, hand.left ? UnityEngine.InputSystem.XR.XRController.leftHand : UnityEngine.InputSystem.XR.XRController.rightHand);
            foreach(var device in devices) {
                if(device.TryGetHapticCapabilities(out var capabilities) && capabilities.supportsImpulse) {
                    device.SendHapticImpulse(0u, amp, duration);
                }
            }

            base.TryHapticImpulse(duration, amp, freq);
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandControllerLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandPlayerControllerLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3c2299af165ef2148b128cb7c00383bf
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Autohand.Demo;
using UnityEngine.InputSystem;

namespace Autohand.Demo {
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/controller-input")]
    public class OpenXRHandPlayerControllerLink : MonoBehaviour{
        public AutoHandPlayer player;

        [Header("Input")]
        public InputActionProperty moveAxis;
        public InputActionProperty turnAxis;
        
        private void OnEnable() {
            if (moveAxis.action != null) moveAxis.action.Enable();
            if (moveAxis.action != null) moveAxis.action.performed += MoveAction;
            if (turnAxis.action != null) turnAxis.action.Enable();
            if (turnAxis.action != null) turnAxis.action.performed += TurnAction;
        }

        private void OnDisable() {
            if (moveAxis.action != null) moveAxis.action.performed -= MoveAction;
            if (turnAxis.action != null) turnAxis.action.performed -= TurnAction;
        }

        private void FixedUpdate() {
            player.Move(moveAxis.action.ReadValue<Vector2>());
            player.Turn(turnAxis.action.ReadValue<Vector2>().x);
        }

        private void Update(){
            player.Move(moveAxis.action.ReadValue<Vector2>());
            player.Turn(turnAxis.action.ReadValue<Vector2>().x);
        }

        void MoveAction(InputAction.CallbackContext a) {
            var axis = a.ReadValue<Vector2>();
            player.Move(axis);
        }

        void TurnAction(InputAction.CallbackContext a) {
            var axis = a.ReadValue<Vector2>();
            player.Turn(axis.x);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandPlayerControllerLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandPointGrabLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 98115e9b7ea4ff3418caca71996011a4
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

namespace Autohand.Demo{
    public class OpenXRHandPointGrabLink : MonoBehaviour{
        public HandDistanceGrabber pointGrab;
        public InputActionProperty pointAction;
        public InputActionProperty stopPointAction;
        public InputActionProperty selectAction;
        public InputActionProperty stopSelectAction;

        void OnEnable(){
            if(pointAction.action != null) pointAction.action.Enable();
            if (pointAction.action != null) pointAction.action.performed += OnPoint;
            if (stopPointAction.action != null) stopPointAction.action.Enable();
            if (stopPointAction.action != null) stopPointAction.action.performed += OnStopPoint;

            if (selectAction.action != null) selectAction.action.Enable();
            if (selectAction.action != null) selectAction.action.performed += OnSelect;
            if (stopSelectAction.action != null) stopSelectAction.action.Enable();
            if (stopSelectAction.action != null) stopSelectAction.action.performed += OnDeselect;
        }
        
        private void OnDisable() {
            if (pointAction.action != null) pointAction.action.performed -= OnPoint;
            if (stopPointAction.action != null) stopPointAction.action.performed -= OnStopPoint;

            if (selectAction.action != null) selectAction.action.performed -= OnSelect;
            if (stopSelectAction.action != null) stopSelectAction.action.performed -= OnDeselect;
            
        }

        void OnPoint(InputAction.CallbackContext e) {
            pointGrab.StartPointing();
        }

        void OnStopPoint(InputAction.CallbackContext e) {
            pointGrab.StopPointing();
        }

        private void OnSelect(InputAction.CallbackContext e) {
            pointGrab.SelectTarget();
        }

        void OnDeselect(InputAction.CallbackContext e) {
            pointGrab.CancelSelect();
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandPointGrabLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHeldGrabbableInput.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 49804ac981381904fb9e99d1c6798795
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

namespace Autohand {
    //Coupled with the OpenXRGrabbableInput script
    public class OpenXRHeldGrabbableInput : MonoBehaviour {
        public Hand hand;
        public InputActionProperty startAction;
        public InputActionProperty stopAction;
        [Tooltip("Must match the input layer of the GrabbableInput layer value")]
        public int inputLayer = 0;

        [Space]
        [Tooltip("If false, the events will only trigger if the hand is holding a grabbable with a GrabbableInput script of the same input layer")]
        public bool alwaysTriggerEvents = false;
        public UnityHandGrabEvent startInput;
        public UnityHandGrabEvent stopInput;

        public bool inputActive { get; set; }


        public void OnEnable() {
            if(hand == null && !gameObject.CanGetComponent(out hand))
                Debug.LogError("AUTOHAND: Hand not found on OpenXRHeldGrabbableInput", this);

            if(startAction.action != null) startAction.action.Enable();
            if(stopAction.action != null) stopAction.action.Enable();
            if(startAction.action != null) startAction.action.performed += StartInput;
            if(stopAction.action != null) stopAction.action.performed += StopInput;
        }


        private void OnDisable() {
            if(startAction.action != null) startAction.action.performed -= StartInput;
            if(stopAction.action != null) stopAction.action.performed -= StopInput;
        }


        private void StartInput(InputAction.CallbackContext grab) {
            if(!inputActive) {
                if(alwaysTriggerEvents)
                    startInput.Invoke(hand, hand.holdingObj);
                
                if(hand.holdingObj != null) {
                    if(hand.holdingObj.CanGetComponent<OpenXRGrabbableInput>(out var grabbableInput) && grabbableInput.inputLayer == inputLayer) {
                        grabbableInput.PressInput(hand);
                        if(!alwaysTriggerEvents)
                            startInput.Invoke(hand, hand.holdingObj);
                    }
                }


                inputActive = true;
            }
        }

        private void StopInput(InputAction.CallbackContext grab) {
            if(inputActive) {
                if(alwaysTriggerEvents)
                    stopInput.Invoke(hand, hand.holdingObj);

                if(hand.holdingObj != null) {
                    if(hand.holdingObj.CanGetComponent<OpenXRGrabbableInput>(out var grabbableInput) && grabbableInput.inputLayer == inputLayer) {
                        grabbableInput.ReleaseInput(hand);
                        if(!alwaysTriggerEvents)
                            stopInput.Invoke(hand, hand.holdingObj);
                    }
                }
                inputActive = false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHeldGrabbableInput.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRMover.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dc47bd4a32ee65841818116665dacc30
# ASMDEF: Autohand.OpenXR.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

namespace Autohand.Demo
{
    public class OpenXRMover : MonoBehaviour
    {
        [Header("Input Actions")]
        public InputActionProperty moveAction;
        public InputActionProperty turnAction;

        [Header("Body")]
        public GameObject cam;
        private CharacterController controller;

        [Header("Settings")]
        public bool snapTurning;
        public float turnAngle;
        public float heightStep;
        public float minHeight, maxHeight;
        public float speed = 5;
        public float gravity = 1;

        private float currentGravity = 0;

        private bool turningReset = true, heightReset = true;

        private void Start(){
            controller = GetComponent<CharacterController>();
            gameObject.layer = LayerMask.NameToLayer("HandPlayer");

            moveAction.action.Enable();
            moveAction.action.performed += Move;
            turnAction.action.Enable();
            turnAction.action.performed += TurnAndHeight;
        }

        private void Move(InputAction.CallbackContext move){
            Vector3 headRotation = new Vector3(0, cam.transform.eulerAngles.y, 0);

            Vector2 moveAxis = move.ReadValue<Vector2>();

            if(Mathf.Abs(moveAxis.x) < 0.1f)
                moveAxis.x = 0;
            if(Mathf.Abs(moveAxis.y) < 0.1f)
                moveAxis.y = 0;

            Vector3 direction = new Vector3(moveAxis.x, 0, moveAxis.y);

            direction = Quaternion.Euler(headRotation) * direction;

            if (controller.isGrounded)
                currentGravity = 0;
            else
                currentGravity = Physics.gravity.y * gravity;

            controller.Move(new Vector3(direction.x * speed, currentGravity, direction.z * speed) * Time.deltaTime);
        }


        private void TurnAndHeight(InputAction.CallbackContext turn){
            Vector2 turningAxis = turn.ReadValue<Vector2>();

            //Snap turning
            if (snapTurning){
                if (turningAxis.x > 0.7f && turningReset){
                    transform.rotation *= Quaternion.Euler(0, turnAngle, 0);
                    turningReset = false;
                }
                else if (turningAxis.x < -0.7f && turningReset){
                    transform.rotation *= Quaternion.Euler(0, -turnAngle, 0);
                    turningReset = false;
                }
                else if (turningAxis.y > 0.7f && heightReset){
                    if (transform.position.y >= maxHeight){
                        transform.position = new Vector3(transform.position.x, maxHeight, transform.position.z);
                        SetControllerHeight(maxHeight);
                    }
                    else{
                        transform.position += new Vector3(0, heightStep, 0);
                        AddControllerHeight(heightStep);
                    }

                    heightReset = false;
                }
                else if (turningAxis.y < -0.7f && heightReset){
                    if (transform.position.y <= minHeight){
                        SetControllerHeight(maxHeight);
                        transform.position = new Vector3(transform.position.x, minHeight, transform.position.z);
                    }
                    else{
                        AddControllerHeight(-heightStep);
                        transform.position += new Vector3(0, -heightStep, 0);
                    }

                    heightReset = false;
                }

                if (Mathf.Abs(turningAxis.x) < 0.4f)
                    turningReset = true;
                if (Mathf.Abs(turningAxis.y) < 0.4f)
                    heightReset = true;
            }

            //Smooth turning
            else{
                transform.rotation *= Quaternion.Euler(0, Time.deltaTime * turnAngle * turningAxis.x, 0);
                transform.position += new Vector3(0, Time.deltaTime * heightStep * turningAxis.y, 0);

                AddControllerHeight(Time.deltaTime * heightStep * turningAxis.y);

                if (transform.position.y <= minHeight)
                    transform.position = new Vector3(transform.position.x, minHeight, transform.position.z);
                else if (transform.position.y >= maxHeight)
                    transform.position = new Vector3(transform.position.x, maxHeight, transform.position.z);
            }
        }

        private void AddControllerHeight(float height){
            controller.height += height;
            controller.center = new Vector3(0, controller.height / 2f, 0);
        }

        private void SetControllerHeight(float height){
            controller.height = height;
            controller.center = new Vector3(0, height / 2f, 0);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRMover.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRTeleporterLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3e61a6c754b32184fa0fac4b86d9ff14
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.XR;

namespace Autohand.Demo{
    public class OpenXRTeleporterLink : MonoBehaviour{
        public Teleporter hand;
        public InputActionProperty startTeleportAction;
        public InputActionProperty finishTeleportAction;
        
        bool teleporting = false;

        void OnEnable() {
            if(startTeleportAction.action != null) startTeleportAction.action.Enable();
            if (startTeleportAction.action != null) startTeleportAction.action.performed += StartTeleportAction;
            if (finishTeleportAction.action != null) finishTeleportAction.action.Enable();
            if (finishTeleportAction.action != null) finishTeleportAction.action.performed += FinishTeleportAction;
        }

        void OnDisable() { 
            if (startTeleportAction.action != null) startTeleportAction.action.performed -= StartTeleportAction;
            if (finishTeleportAction.action != null) finishTeleportAction.action.performed -= FinishTeleportAction;
        }


        void StartTeleportAction(InputAction.CallbackContext a) {
            if(!teleporting){
                hand.StartTeleport();
                teleporting = true;
            }
        }

        void FinishTeleportAction(InputAction.CallbackContext a) {
            if(teleporting){
                hand.Teleport();
                teleporting = false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRTeleporterLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/XRProviderPicker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: be0d1b15235da3647ae676669899705c
# ASMDEF: Autohand.OpenXR.dll
# ---
using UnityEngine;
using UnityEngine.XR.Management;

[DefaultExecutionOrder(-10000)]
public class XRProviderPicker : MonoBehaviour
{
    //This will disable this script unless the given loader name matches the loader
    //(XRGeneralSettings.Instance.Manager.activeLoaders) in the XR Plugin Management window.
    //This is because different providers give different tracked positions.
    //Shouldn't matter for distribution of build, but does matter for distribution of this asset
    public string providerName = "";
    public XRHandOffset enableMe;
    public XRHandOffset disableMe;

    bool hasProvider = false;

    // Start is called before the first frame update
    void OnEnable() {
        var loaders = XRGeneralSettings.Instance.Manager.activeLoaders;
        foreach(var loader in loaders) {
            Debug.Log(loader.name);
            if(providerName == "" || providerName == loader.name)
                hasProvider = true;
        }

        if (hasProvider)
        { 
           // enableMe.AdjustPositions(disableMe);
            enableMe.enabled = true;
            disableMe.enabled = false;
        }
        else
        {

            disableMe.AdjustPositions(enableMe);
            enableMe.enabled = false;
            disableMe.enabled = true;
        }
    }


}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/XRProviderPicker.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRAutoHandAxisFingerBender.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 855e1c3bb96607b46842d2505034e037
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class XRAutoHandAxisFingerBender : MonoBehaviour{
        public XRHandControllerLink controller;
        public CommonAxis axis;
        
        [HideInInspector]
        public float[] bendOffsets;
        float lastAxis;

        void LateUpdate(){
            var currAxis = controller.GetAxis(axis);
            for(int i = 0; i < controller.hand.fingers.Length; i++) {
                controller.hand.fingers[i].bendOffset += (currAxis-lastAxis)*bendOffsets[i];
            }
            lastAxis = currAxis;
        }
        
        
        private void OnDrawGizmosSelected() {
            if(controller == null && GetComponent<XRHandControllerLink>()){
                controller = GetComponent<XRHandControllerLink>();
                bendOffsets = new float[controller.hand.fingers.Length];
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRAutoHandAxisFingerBender.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRAutoHandFingerBender.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 782cb9720318e0c4ab7353bfc2181ad6
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class XRAutoHandFingerBender : MonoBehaviour{
        public XRHandControllerLink controller;
        public CommonButton button;
        
        [HideInInspector]
        public float[] bendOffsets;

        bool pressed;
        
        void Update(){
            if(!pressed && controller.ButtonPressed(button)) {
                pressed = true;
                for(int i = 0; i < controller.hand.fingers.Length; i++) {
                    controller.hand.fingers[i].bendOffset += bendOffsets[i];
                }
            }
            else if(pressed && !controller.ButtonPressed(button)) {
                pressed = false;
                for(int i = 0; i < controller.hand.fingers.Length; i++) {
                    controller.hand.fingers[i].bendOffset -= bendOffsets[i];
                }
            }
        }


        private void OnDrawGizmosSelected() {
            if(controller == null && GetComponent<XRHandControllerLink>()){
                controller = GetComponent<XRHandControllerLink>();
                bendOffsets = new float[controller.hand.fingers.Length];
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRAutoHandFingerBender.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRControllerEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7fbab967b03b78f4093d38ef2637575f
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand.Demo {
    public class XRControllerEvent : MonoBehaviour
    {
        public XRHandControllerLink link;
        public CommonButton button;
        public UnityEvent Pressed;
        public UnityEvent Released;
        bool pressed = false;

        protected virtual void Start() {
            if (link == null) {
                link = GetComponentInParent<XRHandControllerLink>();
                if (link == null)
                    Debug.LogError("No XRHandControllerLink connected - input will not work", this);
            }
        }

        protected virtual void Update()
        {
            if (link == null)
                return;

            if (link.ButtonPressed(button) && !pressed)
            {
                Pressed?.Invoke();
                pressed = true;
            }
            else if (!link.ButtonPressed(button) && pressed)
            {
                Released?.Invoke();
                pressed = false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRControllerEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandControllerLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 245bee9b113e7144cb3549484bae2a0c
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;

namespace Autohand.Demo{
    public enum CommonButton {
        gripButton,
        menuButton,
        primaryButton,
        secondaryButton,
        triggerButton,
        primary2DAxisClick,
        primary2DAxisTouch,
#if UNITY_2019_2_OR_NEWER
        secondary2DAxisClick,
        secondary2DAxisTouch,
#endif
        primaryTouch,
        secondaryTouch,
        none
    }
    
    public enum CommonAxis {
        trigger,
        grip,
        none
    }

    public enum Common2DAxis {
        primaryAxis,
        secondaryAxis,
        none
    }

    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/controller-input")]
    public class XRHandControllerLink : HandControllerLink {
        public CommonButton grabButton = CommonButton.triggerButton;
        [Tooltip("This axis will bend all the fingers on the hand -> replaced with finger bender scripts")]
        public CommonAxis grabAxis = CommonAxis.trigger;
        public CommonAxis squeezeAxis = CommonAxis.grip;
        public CommonButton squeezeButton = CommonButton.gripButton;

        bool squeezing;
        bool grabbing;

        XRNode role;
        InputDevice device;
        List<InputDevice> devices = new List<InputDevice>();

        private void Start(){
            if(grabButton == squeezeButton) {
                Debug.LogError("AUTOHAND: You are using the same button for grab and squeeze on HAND CONTROLLER LINK, this may create conflict or errors", this);
            }

            if(hand.left)
                role = XRNode.LeftHand;
            else
                role = XRNode.RightHand;

            if(hand.left)
                handLeft = this;
            else
                handRight = this;
        }

        void Update(){

            InputDevices.GetDevicesAtXRNode(role, devices);
            if(devices.Count > 0)
                device = devices[0];

            if(device != null && device.isValid){
                //Sets hand fingers wrap
                hand.SetGrip(GetAxis(grabAxis), GetAxis(squeezeAxis));

                //Grab input
                if(device.TryGetFeatureValue(GetCommonButton(grabButton), out bool grip)) {
                    if(grabbing && !grip){
                        hand.Release();
                        grabbing = false;
                    }
                    else if(!grabbing && grip){
                        hand.Grab();
                        grabbing = true;
                    }
                }
                //Squeeze input
                if(device.TryGetFeatureValue(GetCommonButton(squeezeButton), out bool squeeze)) {
                    if(squeezing && !squeeze){
                        hand.Unsqueeze();
                        squeezing = false;
                    }
                    else if(!squeezing && squeeze){
                        hand.Squeeze();
                        squeezing = true;
                    }
                }
            }
        }

        public List<InputDevice> Devices() { return devices; }


        public bool ButtonPressed(CommonButton button) {
            if (button == CommonButton.none)
                return false;

            if(device.TryGetFeatureValue(GetCommonButton(button), out bool pressed)) {
                return pressed;
            }

            return false;
        }


        public float GetAxis(CommonAxis axis){
            if (axis == CommonAxis.none)
                return 0;

            if(device.TryGetFeatureValue(GetCommonAxis(axis), out float axisValue)) {
                return axisValue;
            }
            return 0;
        }


        public Vector2 GetAxis2D(Common2DAxis axis) {
            if (axis == Common2DAxis.none)
                return Vector2.zero;

            if(device.TryGetFeatureValue(GetCommon2DAxis(axis), out Vector2 axisValue)) {
                return axisValue;
            }
            return Vector2.zero;
        }

        /// <param name="freq">not supported on XR?</param>
        public override void TryHapticImpulse(float duration, float amp, float freq = 0) {
            foreach(var device in Devices()) {
                if(device.TryGetHapticCapabilities(out var capabilities) && capabilities.supportsImpulse) {
                    device.SendHapticImpulse(0u, amp, duration);
                }
            }
        }


        public static InputFeatureUsage<bool> GetCommonButton(CommonButton button) {
            if(button == CommonButton.gripButton)
                return CommonUsages.gripButton;
            if(button == CommonButton.menuButton)
                return CommonUsages.menuButton;
            if(button == CommonButton.primary2DAxisClick)
                return CommonUsages.primary2DAxisClick;
            if(button == CommonButton.primary2DAxisTouch)
                return CommonUsages.primary2DAxisTouch;
            if(button == CommonButton.primaryButton)
                return CommonUsages.primaryButton;
            if(button == CommonButton.primaryTouch)
                return CommonUsages.primaryTouch;
#if UNITY_2019_2_OR_NEWER
            if (button == CommonButton.secondary2DAxisClick)
                return CommonUsages.secondary2DAxisClick;
            if(button == CommonButton.secondary2DAxisTouch)
                return CommonUsages.secondary2DAxisTouch;
#endif
            if(button == CommonButton.secondaryButton)
                return CommonUsages.secondaryButton;
            if(button == CommonButton.secondaryTouch)
                return CommonUsages.secondaryTouch;
            
            return CommonUsages.triggerButton;
        }

        public static InputFeatureUsage<float> GetCommonAxis(CommonAxis axis) {
            if(axis == CommonAxis.grip)
                return CommonUsages.grip;
            else
                return CommonUsages.trigger;
        }

        public static InputFeatureUsage<Vector2> GetCommon2DAxis(Common2DAxis axis) {
            if(axis == Common2DAxis.primaryAxis)
                return CommonUsages.primary2DAxis;
            else
                return CommonUsages.secondary2DAxis;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandControllerLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandOffset.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b661ef26e3b3e0c4ba5d9ecd8097bf6b
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;

[System.Serializable]
public struct DeviceData{
    public string[] deviceNames;
    public Vector3 position;
    public Vector3 rotation;

    public DeviceData(string name, Vector3 pos, Vector3 rot)
    {
        deviceNames = new string[] { name };
        position = pos;
        rotation = rot;
    }
    public DeviceData(string[] names, Vector3 pos, Vector3 rot)
    {
        deviceNames = names;
        position = pos;
        rotation = rot;
    }
};


public class XRHandOffset : MonoBehaviour {
    [Tooltip("DO NOT CHANGE THIS UNLESS YOU ARE REDOING THE RELATIVE POSITIONS. This is the device that you are using to setup the innital proper orientation of the hand, all offsets are relative to this device")]
    public string defaultDevice = "Oculus";


    [SerializeField]
    public Transform[] rightOffsets, leftOffsets;

    [SerializeField]
    public DeviceData[] devices = new DeviceData[] {
        new DeviceData("Oculus", new Vector3(0.005f, -0.016f, 0.014f), new Vector3(48, 0, 15)),
        new DeviceData("Windows MR", new Vector3(0.003f, -0.005f, -0.078f), new Vector3(36, -12, 2)),
        new DeviceData(new string[]{"Vive", "HTC", "Index", "Cosmos", "Elite" }, new Vector3(0.015f, 0, 0.0412f), new Vector3(30, -17, 0))
    };

    bool offsetDone = false;
    bool hasProvider = false;
    AutoHandSettings settings;

    void OnEnable(){
        settings = Resources.Load<AutoHandSettings>("AutoHandSettings");
        if(!settings.useAutomaticControllerOffset)
            return;

        InputDevices.deviceConnected += DeviceConnected;
        List<InputDevice> devices = new List<InputDevice>();
        InputDevices.GetDevices(devices);

        foreach(var device in devices) {
            DeviceConnected(device);
        }
    }

    void OnDisable() {
        if(hasProvider) {
            InputDevices.deviceConnected -= DeviceConnected;
        }
    }


    public void AdjustPositions(XRHandOffset otherOffset) {
        var defaultPos = GetDefaultPositionOffset() - otherOffset.GetDefaultPositionOffset();
        var defaultRot = GetDefaultRotationOffset() - otherOffset.GetDefaultRotationOffset();

        foreach(var leftOffset in leftOffsets) {
            leftOffset.localPosition += new Vector3(-defaultPos.x, defaultPos.y, defaultPos.z);
            leftOffset.localEulerAngles += new Vector3(defaultRot.x, -defaultRot.y, -defaultRot.z);
        }

        foreach(var rightOffset in rightOffsets) {
            rightOffset.localPosition += defaultPos;
            rightOffset.localEulerAngles += defaultRot;
        }
    }

    void DeviceConnected(InputDevice inputDevice) {
        if (inputDevice.characteristics != 0){
            foreach (var device in devices){
                if (offsetDone)
                    break;

                for (int i = 0; i < device.deviceNames.Length; i++){
                    Debug.Log(inputDevice.name, this);
                    if (inputDevice.name.Contains(device.deviceNames[i])){
                        var offsetPos = GetPositionOffset(defaultDevice, device.deviceNames[i]);
                        var offsetRot = GetRotationOffset(defaultDevice, device.deviceNames[i]);

                        foreach (var leftOffset in leftOffsets){
                            leftOffset.localPosition += new Vector3(-offsetPos.x, offsetPos.y, offsetPos.z);
                            leftOffset.localEulerAngles += new Vector3(offsetRot.x, -offsetRot.y, -offsetRot.z);
                        }

                        foreach (var rightOffset in rightOffsets){
                            rightOffset.localPosition += offsetPos;
                            rightOffset.localEulerAngles += offsetRot;
                        }

                        OnDisable();

                        offsetDone = true;
                        break;
                    }
                }
            }
        }
    }


    Vector3 GetPositionOffset(string from, string to) {
        if(from == to)
            return Vector3.zero;

        Vector3 fromPos, toPos = fromPos = Vector3.zero;
        foreach(var device in devices) {
            foreach(var deviceName in device.deviceNames) {
                if(deviceName == from)
                    fromPos = device.position;
                if(deviceName == to)
                    toPos = device.position;
            }
        }

        return (toPos - fromPos);
    }


    Vector3 GetRotationOffset(string from, string to) {
        if(from == to)
            return Vector3.zero;

        Vector3 fromPos, toPos = fromPos = Vector3.zero;
        foreach(var device in devices) {
            foreach(var deviceName in device.deviceNames) {
                if(deviceName == from)
                    fromPos = device.rotation;
                if(deviceName == to)
                    toPos = device.rotation;
            }
        }

        return (toPos - fromPos);
    }

    protected Vector3 GetDefaultPositionOffset() {

        Vector3 fromPos = Vector3.zero;
        foreach(var device in devices) {
            foreach(var deviceName in device.deviceNames) {
                if(deviceName == defaultDevice)
                    fromPos = device.position;
            }
        }

        return fromPos;
    }


    protected Vector3 GetDefaultRotationOffset() {
        Vector3 fromPos = Vector3.zero;
        foreach(var device in devices) {
            foreach(var deviceName in device.deviceNames) {
                if(deviceName == defaultDevice)
                    fromPos = device.rotation;
            }
        }

        return fromPos;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandOffset.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandPlayerControllerLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 09b6737f8be736a4ea7bb40614525174
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {

    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/controller-input")]
    public class XRHandPlayerControllerLink : MonoBehaviour{
        public XRHandControllerLink moveController;
        public XRHandControllerLink turnController;
        public AutoHandPlayer player;

        [Header("Input")]
        public Common2DAxis moveAxis;
        public Common2DAxis turnAxis;

        
        void Update(){
            player.Move(moveController.GetAxis2D(moveAxis));
            player.Turn(turnController.GetAxis2D(turnAxis).x);
        }
        void FixedUpdate(){
            player.Move(moveController.GetAxis2D(moveAxis));
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandPlayerControllerLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandPointGrabLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 347efddb19627c941bbe201c025bc04e
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class XRHandPointGrabLink : MonoBehaviour{
        public HandDistanceGrabber pointGrab;
        public XRHandControllerLink link;

        [Header("Input")]
        public CommonButton pointInput;
        public CommonButton selectInput;

        bool pointing;
        bool selecting;

        private void Start() {
            if(link == null) {
                link = GetComponentInParent<XRHandControllerLink>();
                if(link == null)
                    Debug.LogError("No XRHandControllerLink connected - input will not work", this);
            }

            if(pointGrab == null) {
                pointGrab = GetComponentInParent<HandDistanceGrabber>();
                if(pointGrab == null)
                    Debug.LogError("No HandDistanceGrabber connected - input will not work", this);
            }
        }

        void Update(){
            if(link == null || pointGrab == null)
                return;

            if (link.ButtonPressed(pointInput) && !pointing) {
                pointing = true;
                pointGrab.StartPointing();
            }

            if (!link.ButtonPressed(pointInput) && pointing){
                pointing = false;
                pointGrab.StopPointing();
            }

            
            if (link.ButtonPressed(selectInput) && !selecting) {
                selecting = true;
                pointGrab.SelectTarget();
            }
            
            if (!link.ButtonPressed(selectInput) && selecting){
                selecting = false;
                pointGrab.CancelSelect();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandPointGrabLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHeadTracking.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6d6e19972d8984547b7008d21841fe57
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;

namespace Autohand.Demo{
public class XRHeadTracking : MonoBehaviour{
#if UNITY_2020_3_OR_NEWER
        public TrackingOriginModeFlags mode = TrackingOriginModeFlags.TrackingReference;

    void Start(){
        List<XRInputSubsystem> subsystems = new List<XRInputSubsystem>();
        SubsystemManager.GetSubsystems(subsystems);
        for(int i = 0;  i < subsystems.Count; i++){
            subsystems[i].TrySetTrackingOriginMode(mode);
        }
    }
#endif
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHeadTracking.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRMover.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2e91c98879de4e040b0906bfe19ef7c5
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Autohand.Demo;

namespace Autohand{
    //THIS SCRIPT IS A TEMPORARY DEMO SCRIPT
    //BETTER MOVEMENT OPTIONS COMING SOON
    public class XRMover : MonoBehaviour{
        [Header("TEMP DEMO SCRIPT - Advanced script coming soon")]
        [Header("Controllers")]
        public XRHandControllerLink moverController;
        public XRHandControllerLink turningController;
        public Common2DAxis moverAxis;

        [Header("Body")]
        public GameObject cam;
        private CharacterController controller;
        private CapsuleCollider collisionCapsule;

        [Header("Settings")]
        public bool snapTurning;
        public float turnAngle;
        public float speed = 5;
        public float gravity = 1;

        private float currentGravity = 0;

        private bool axisReset = true;

        Vector3 moveAxis;
        Vector2 turningAxis;

        //Driver
        public void LateUpdate(){
            turningAxis = turningController.GetAxis2D(moverAxis);
            moveAxis = moverController.GetAxis2D(moverAxis);

            Move(moveAxis.x, moveAxis.z, moveAxis.y);
            Turning();
        }


        private void Awake(){
            gameObject.layer = LayerMask.NameToLayer("HandPlayer");
            controller = GetComponent<CharacterController>();
        }


        public void Move(float x, float y, float z){

            Vector3 direction = new Vector3(x, y, z);
            Vector3 headRotation = new Vector3(0, cam.transform.eulerAngles.y, 0);

            direction = Quaternion.Euler(headRotation) * direction;

            currentGravity = Physics.gravity.y * gravity;

            if (controller.isGrounded)
                currentGravity = 0;

            controller.Move(new Vector3(direction.x * speed, direction.y * speed + currentGravity, direction.z * speed) * Time.deltaTime);
        }


        void Turning(){
            //Snap turning
            if (snapTurning){
                if (turningAxis.x > 0.7f && axisReset){
                    transform.rotation *= Quaternion.Euler(0, turnAngle, 0);
                    axisReset = false;
                }
                else if (turningAxis.x < -0.7f && axisReset){
                    transform.rotation *= Quaternion.Euler(0, -turnAngle, 0);
                    axisReset = false;
                }

                if (Mathf.Abs(turningAxis.x) < 0.4f)
                    axisReset = true;
            }

            //Smooth turning
            else{
                transform.rotation *= Quaternion.Euler(0, Time.deltaTime * turnAngle * turningAxis.x, 0);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRMover.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRTeleporterLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c3bafe5313773b549b22ed738a6223b2
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;

namespace Autohand.Demo{
    public class XRTeleporterLink : MonoBehaviour{
        public Teleporter hand;
        public XRNode role;
        public CommonButton button;
        
        bool teleporting = false;
        InputDevice device;
        List<InputDevice> devices;

        void Start(){
            devices = new List<InputDevice>();
        }

        void FixedUpdate(){
            InputDevices.GetDevicesAtXRNode(role, devices);
            if(devices.Count > 0)
                device = devices[0];

            if(device != null && device.isValid){
                //Sets hand fingers wrap
                if(device.TryGetFeatureValue(XRHandControllerLink.GetCommonButton(button), out bool teleportButton)) {
                    if(teleporting && !teleportButton){
                        hand.Teleport();
                        teleporting = false;
                    }
                    else if(!teleporting && teleportButton){
                        hand.StartTeleport();
                        teleporting = true;
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRTeleporterLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/InteractionAnimation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f927734ec0a8dac44aae9f4e7ec65bba
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand {

    [System.Serializable]
    public struct AnimationTarget {
        public MeshRenderer renderer;
        public SpriteRenderer spriteRenderer;

        public bool ignoreColor;
        public bool ignorePosition;
        public bool ignoreScale;
        public bool ignoreRotation;

        public float colorDampener;
        public float positionDampener;
        public float scaleDampener;
        public float rotationDampener;
        public float waveOffset;

        private Vector3 startPosition;
        private Vector3 startRotation;
        private Vector3 startScale;
        [HideInInspector]
        public Transform transform;

        public Vector3 StartPosition => startPosition;
        public Vector3 StartRotation => startRotation;
        public Vector3 StartScale => startScale;

        public void SetStartValues() {
            if(renderer != null) {
                startPosition = renderer.transform.localPosition;
                startScale = renderer.transform.localScale;
                startRotation = renderer.transform.localEulerAngles;
                transform = renderer.transform;
            }
            else if(spriteRenderer != null) {
                startPosition = spriteRenderer.transform.localPosition;
                startScale = spriteRenderer.transform.localScale;
                startRotation = spriteRenderer.transform.localEulerAngles;
                transform = spriteRenderer.transform;
            }

        }

        public void SetColor(Color color) {
            if(renderer != null) {
                renderer.material.color = color;
            }
            else if(spriteRenderer != null) {
                spriteRenderer.color = color;
            }
        }
    }



    public class InteractionAnimations : MonoBehaviour {
        public AnimationTarget[] animationTargets;

        [Header("On Enable")]
        public bool onEnableTransition = false;
        public float onEnableTransitionTime = 0.15f;
        public AnimationCurve onEnableTransitionCurve = AnimationCurve.Linear(0, 0, 1, 1);

        [Header("Color")]
        public bool updateColor = true;
        public float highlightAnimationColorTime = 0.5f;
        public float unhighlightAnimationColorTime = 0.5f;
        public Color unhighlightColor = Color.grey;
        public Color highlightColor = Color.white;
        public Color activateColor = Color.white;
        public AnimationCurve highlightColorCurve = AnimationCurve.Linear(0, 0, 1, 1);
        public float colorWaveFrequency = 1;
        public float colorWaveAmplitude = 0f;
        public float colorWaveOffset = 0.5f;

        [Header("Position")]
        public bool updatePosition = true;
        public float highlightAnimationPositionTime = 0.5f;
        public float unhighlightAnimationPositionTime = 0.5f;
        public Vector3 highlightPosition;
        public Vector3 activatePosition;
        public AnimationCurve positionAnimationCurve = AnimationCurve.Linear(0, 0, 1, 1);
        public float positionWaveFrequency = 1;
        public float positionWaveAmplitude = 0f;
        public float positionWaveOffset = 0.5f;

        [Header("Scale")]
        public bool updateScale = true;
        public float highlightAnimationScaleTime = 0.5f;
        public float unhighlightAnimationScaleTime = 0.5f;
        public float highlightScaleOffset = 0.1f;
        public float activateScaleOffset = 0.1f;
        public AnimationCurve scaleAnimationCurve = AnimationCurve.Linear(0, 0, 1, 1);
        public float scaleWaveFrequency = 1;
        public float scaleWaveAmplitude = 0f;
        public float scaleWaveOffset = 0.5f;

        [Header("Rotation")]
        public bool updateRotation = true;
        public float highlightAnimationRotationTime = 0.5f;
        public float unhighlightAnimationRotationTime = 0.5f;
        public Vector3 highlightRotationOffset = Vector3.zero;
        public Vector3 activateRotationOffset = Vector3.zero;
        public AnimationCurve rotationAnimationCurve = AnimationCurve.Linear(0, 0, 1, 1);
        public float rotationWaveFrequency = 1;
        public float rotationWaveAmplitude = 0f;
        public float rotationWaveOffset = 0.5f;

        protected float enableState;

        protected bool highlighting;
        protected float highlightStartTime;
        protected float highlightStopTime;
        protected float highlightColorState;
        protected float highlightPositionState;
        protected float highlightRotationState;
        protected float highlightScaleState;

        protected bool activating;
        protected float activateStartTime;
        protected float activateStopTime;
        protected float activateColorState;
        protected float activatePositionState;
        protected float activateRotationState;
        protected float activateScaleState;

        Color currentHighlightColor;
        Color currentUnhighlightColor;
        Color currentActivateColor;

        bool finishedAnimation;
        bool useWave;
        bool startedValueSet = false;

        Coroutine enableAnimationRountine;

        protected virtual void OnEnable() {
            if(!startedValueSet) {
                for(int i = 0; i < animationTargets.Length; i++)
                    animationTargets[i].SetStartValues();
                startedValueSet = true;
            }

            useWave = colorWaveAmplitude > 0 || positionWaveAmplitude > 0 || scaleWaveAmplitude > 0 || rotationWaveAmplitude > 0;

            if(!onEnableTransition) {
                currentActivateColor = activateColor;
                currentHighlightColor = highlightColor;
                currentUnhighlightColor = unhighlightColor;
            }

            SetAnimation();
        }

        protected virtual void OnDisable() {
            enableState = 0;
            highlightColorState = 0;
            highlightPositionState = 0;
            highlightScaleState = 0;
            highlightRotationState = 0;
            activateColorState = 0;
            activatePositionState = 0;
            activateScaleState = 0;
            activateRotationState = 0;
            activateScaleState = 0;
            highlighting = false;
            activating = false;
            SetAnimation();
        }


        protected virtual void LateUpdate() {
            if(!enabled)
                return;

            UpdateAnimationState();

            if(!finishedAnimation)
                SetAnimation();

            finishedAnimation = !highlighting && !activating &&
                (highlightPositionState == 0) &&
                (highlightColorState == 0) &&
                (highlightRotationState == 0) &&
                (highlightScaleState == 0) &&
                (activatePositionState == 0) &&
                (activateColorState == 0) &&
                (activateRotationState == 0) &&
                (activateScaleState == 0);

            if(onEnableTransition)
                finishedAnimation = finishedAnimation && enableState == 1;
        }


        [ContextMenu("HIGHLIGHT")]
        public void Highlight() {
            highlighting = true;
            highlightStartTime = Time.time;
        }

        [ContextMenu("UNHIGHLIGHT")]
        public void Unhighlight() {
            highlighting = false;
            highlightStopTime = Time.time;
        }

        [ContextMenu("ACTIVATE")]
        public void Activate() {
            activating = true;
            activateStartTime = Time.time;
        }

        [ContextMenu("DEACTIVATE")]
        public void Deactivate() {
            activating = false;
            activateStopTime = Time.time;
        }


        protected virtual void UpdateAnimationState() {
            var deltaTime = Time.deltaTime;
            var time = Time.time;
            var offseTime = time - deltaTime;


            //ENABLED TRANSITION
            if(onEnableTransition && enableState < 1) {
                enableState += deltaTime / onEnableTransitionTime;
                enableState = Mathf.Clamp01(enableState);
            }

            if(updatePosition) {
                //UPDATE POSITON STATES
                if(highlighting && highlightStartTime + highlightAnimationPositionTime > offseTime) {
                    highlightPositionState += deltaTime / highlightAnimationPositionTime;
                    highlightPositionState = Mathf.Clamp01(highlightPositionState);
                }
                else if(!highlighting && highlightStopTime + unhighlightAnimationPositionTime > offseTime) {
                    highlightPositionState -= deltaTime / unhighlightAnimationPositionTime;
                    highlightPositionState = Mathf.Clamp01(highlightPositionState);
                }

                if(activating && activateStartTime + highlightAnimationPositionTime > offseTime) {
                    activatePositionState += deltaTime/ highlightAnimationPositionTime;
                    activatePositionState = Mathf.Clamp01(activatePositionState);
                }
                else if(!activating && activateStopTime + unhighlightAnimationPositionTime > offseTime) {
                    activatePositionState -= deltaTime / unhighlightAnimationPositionTime;
                    activatePositionState = Mathf.Clamp01(activatePositionState);
                }
            }

            //UPDATE COLOR STATES
            if(updateColor) {
                if(highlighting && highlightStartTime + highlightAnimationColorTime > offseTime) {
                    highlightColorState += deltaTime / highlightAnimationColorTime;
                    highlightColorState = Mathf.Clamp01(highlightColorState);
                }
                else if(!highlighting && highlightStopTime + unhighlightAnimationColorTime > offseTime) {
                    highlightColorState -= deltaTime / unhighlightAnimationColorTime;
                    highlightColorState = Mathf.Clamp01(highlightColorState);
                }

                if(activating && activateStartTime + highlightAnimationColorTime > offseTime) {
                    activateColorState += deltaTime / highlightAnimationColorTime;
                    activateColorState = Mathf.Clamp01(activateColorState);
                }
                else if(!activating && activateStopTime + unhighlightAnimationColorTime > offseTime) {
                    activateColorState -= deltaTime / unhighlightAnimationColorTime;
                    activateColorState = Mathf.Clamp01(activateColorState);
                }
            }


            //UPDATE SCALE STATES
            if(updateScale) {
                if(highlighting && highlightStartTime + highlightAnimationScaleTime > offseTime) {
                    highlightScaleState += deltaTime / highlightAnimationScaleTime;
                    highlightScaleState = Mathf.Clamp01(highlightScaleState);
                }
                else if(!highlighting && highlightStopTime + unhighlightAnimationScaleTime > offseTime) {
                    highlightScaleState -= deltaTime / unhighlightAnimationScaleTime;
                    highlightScaleState = Mathf.Clamp01(highlightScaleState);
                }

                if(activating && activateStartTime + highlightAnimationScaleTime > offseTime) {
                    activateScaleState += deltaTime / highlightAnimationScaleTime;
                    activateScaleState = Mathf.Clamp01(activateScaleState);
                }
                else if(!activating && activateStopTime + unhighlightAnimationScaleTime > offseTime) {
                    activateScaleState -= deltaTime / unhighlightAnimationScaleTime;
                    activateScaleState = Mathf.Clamp01(activateScaleState);
                }
            }


            //UPDATE ROTATION STATES
            if(updateRotation) {
                if(highlighting && highlightStartTime + highlightAnimationRotationTime > offseTime) {
                    highlightRotationState += deltaTime / highlightAnimationRotationTime;
                    highlightRotationState = Mathf.Clamp01(highlightRotationState);
                }
                else if(!highlighting && highlightStopTime + unhighlightAnimationRotationTime > offseTime) {
                    highlightRotationState -= deltaTime / unhighlightAnimationRotationTime;
                    highlightRotationState = Mathf.Clamp01(highlightRotationState);
                }

                if(activating && activateStartTime + highlightAnimationRotationTime > offseTime) {
                    activateRotationState += deltaTime / highlightAnimationRotationTime;
                    activateRotationState = Mathf.Clamp01(activateRotationState);
                }
                else if(!activating && activateStopTime + unhighlightAnimationRotationTime > offseTime) {
                    activateRotationState -= deltaTime / unhighlightAnimationRotationTime;
                    activateRotationState = Mathf.Clamp01(activateRotationState);
                }
            }
        }


        protected virtual void SetAnimation() {
            if(onEnableTransition) {
                var transparentUnhighlight = unhighlightColor;
                transparentUnhighlight.a = 0;
                var state = onEnableTransitionCurve.Evaluate(enableState);
                currentUnhighlightColor = Color.Lerp(transparentUnhighlight, unhighlightColor, state);

                var transparentHighlight = highlightColor;
                transparentHighlight.a = 0;
                currentHighlightColor = Color.Lerp(transparentHighlight, highlightColor, state);

                var transparentActivate = activateColor;
                transparentActivate.a = 0;
                currentActivateColor = Color.Lerp(transparentActivate, activateColor, state);
            }

            for(int i = 0; i < animationTargets.Length; i++) {
                var animationTarget = animationTargets[i];
                if(animationTarget.transform == null)
                    continue;

                var waveTime = Time.time - highlightStartTime;
                //var animationOffset = useWave && !animationTarget.ignoreWave ? ((Mathf.Sin(waveTime*Mathf.PI * waveFrequency + index*waveOffset*Mathf.PI)) + 1)/2f * waveAmplitude : 0;

                //UPDATE COLOR
                if(!animationTarget.ignoreColor) {
                    float waveOffset = 0;
                    if(!(colorWaveFrequency == 0) && !(colorWaveAmplitude == 0))
                        waveOffset = ((Mathf.Sin(waveTime*Mathf.PI * colorWaveFrequency + Mathf.PI*colorWaveOffset + animationTarget.waveOffset*Mathf.PI)) + 1)/2f * colorWaveAmplitude;

                    var targetColor = Color.Lerp(currentUnhighlightColor, currentHighlightColor, highlightColorCurve.Evaluate(highlightColorState * Mathf.Clamp01(1-animationTarget.colorDampener - waveOffset)));
                    targetColor = Color.Lerp(targetColor, currentActivateColor, highlightColorCurve.Evaluate(activateColorState * Mathf.Clamp01(1-animationTarget.colorDampener - waveOffset)));
                    animationTarget.SetColor(targetColor);
                }

                //UPDATE POSITIONS
                if(!animationTarget.ignorePosition) {
                    float waveOffset = 0;
                    if(!(positionWaveFrequency == 0) && !(positionWaveAmplitude == 0))
                        waveOffset = ((Mathf.Sin(waveTime*Mathf.PI * positionWaveFrequency + Mathf.PI*positionWaveOffset + animationTarget.waveOffset*Mathf.PI)) + 1)/2f * positionWaveAmplitude;

                    var targetPos = Vector3.Lerp(animationTarget.StartPosition, animationTarget.StartPosition + highlightPosition, positionAnimationCurve.Evaluate(highlightPositionState * Mathf.Clamp01(1 - animationTarget.positionDampener - waveOffset)));
                    targetPos = Vector3.Lerp(targetPos, activatePosition, positionAnimationCurve.Evaluate(activatePositionState* Mathf.Clamp01(1 - animationTarget.positionDampener - waveOffset)));
                    animationTarget.transform.localPosition = targetPos;
                }

                //UPDATE ROTATION
                if(!animationTarget.ignoreRotation) {
                    float waveOffset = 0;
                    if(!(rotationWaveFrequency == 0) && !(rotationWaveAmplitude == 0))
                        waveOffset = ((Mathf.Sin(waveTime*Mathf.PI * rotationWaveFrequency + Mathf.PI*rotationWaveOffset + animationTarget.waveOffset*Mathf.PI)) + 1)/2f * rotationWaveAmplitude;

                    var targetRotation = Vector3.Lerp(animationTarget.StartRotation, animationTarget.StartRotation + highlightRotationOffset, rotationAnimationCurve.Evaluate(highlightRotationState*Mathf.Clamp01(1-animationTarget.rotationDampener - waveOffset)));
                    targetRotation = Vector3.Lerp(targetRotation, activateRotationOffset, rotationAnimationCurve.Evaluate(activateRotationState * Mathf.Clamp01(1 - animationTarget.rotationDampener - waveOffset)));
                    animationTarget.transform.localEulerAngles =  targetRotation;
                }

                //UPDATE SCALE
                if(!animationTarget.ignoreScale) {
                    float waveOffset = 0;
                    if(!(scaleWaveFrequency == 0) && !(scaleWaveAmplitude == 0) && !activating)
                        waveOffset = ((Mathf.Sin(waveTime*Mathf.PI * scaleWaveFrequency + Mathf.PI*scaleWaveOffset + animationTarget.waveOffset*Mathf.PI)) + 1)/2f * scaleWaveAmplitude;

                    var targetScale = Vector3.Lerp(animationTarget.StartScale, animationTarget.StartScale * (1 + highlightScaleOffset), scaleAnimationCurve.Evaluate(highlightScaleState)*Mathf.Clamp01(1-animationTarget.scaleDampener - waveOffset));
                    targetScale = Vector3.Lerp(targetScale, animationTarget.StartScale * (1 + activateScaleOffset), scaleAnimationCurve.Evaluate(activateScaleState * Mathf.Clamp01(1 - animationTarget.scaleDampener - waveOffset)));
                    animationTarget.transform.localScale = targetScale;
                }
            }

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/InteractionAnimation.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/LineAnimation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0d0cb31f61727554fbdb16f3d7cb8aa8
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand
{
    public class LineAnimation : MonoBehaviour
    {
        public LineRenderer lineRenderer;
        public GameObject lineReticle;
        public float activateTime = 0.5f;
        public bool useColorCurve = true;
        public AnimationCurve colorCurve = AnimationCurve.Linear(0, 0, 1, 1);
        public AnimationCurve widthCurve = AnimationCurve.Linear(0, 0, 1, 1); 

        float startWidth;
        float currentWidth;
        bool activated;
        float state;
        bool wasLineEnabled;

        Vector3 startReticleScale;
        Vector3 lastPosition;


        GradientAlphaKey[] startAlphaKeys;
        Coroutine animationCoroutine;

        private void Start() {
            startWidth = lineRenderer.widthMultiplier;
            lineRenderer.widthMultiplier = 0;

            wasLineEnabled = lineRenderer.enabled;
            if(lineReticle != null) {
                startReticleScale = lineReticle.transform.localScale;
                lineReticle.transform.localScale = Vector3.zero;
            }
        }

        private void OnDisable() {
            if(animationCoroutine != null)
                StopCoroutine(animationCoroutine);
            animationCoroutine = null;
            state = 0;
        }

        private void LateUpdate() {
            if(!lineRenderer.enabled && wasLineEnabled) {
                lineRenderer.enabled = true;
                wasLineEnabled = false;
                Deactivate();
            }

            else if(lineRenderer.enabled && !wasLineEnabled && lineRenderer.positionCount > 0) {
                //Need to do additional check to see if the line has moved just in case someone enables the line while its being disabled
                if(animationCoroutine != null && lastPosition != lineRenderer.GetPosition(lineRenderer.positionCount-1)) {
                    StopCoroutine(animationCoroutine);
                    animationCoroutine = null;
                }

                if(animationCoroutine == null) {
                    //Initializing this here instead of start because it needs to fill when the line is enabled
                    if(state == 0 && startAlphaKeys == null) {
                        startAlphaKeys = new GradientAlphaKey[lineRenderer.colorGradient.alphaKeys.Length];
                        lineRenderer.colorGradient.alphaKeys.CopyTo(startAlphaKeys, 0);
                    }
                    wasLineEnabled = true;
                    Activate();

                }
            }
            if(lineRenderer.positionCount > 0)
                lastPosition = lineRenderer.GetPosition(lineRenderer.positionCount - 1);
            else
                lastPosition = Vector3.zero;
        }

        public void Activate() {
            activated = true;
            if(animationCoroutine == null)
                animationCoroutine = StartCoroutine(Animate());
        }

        public void Deactivate() {
            activated = false;
            if(animationCoroutine == null)
                animationCoroutine = StartCoroutine(Animate());
        }

         
        IEnumerator Animate() {
            while ((activated && state < 1) || (!activated && state > 0)) {
                state += Time.deltaTime / activateTime * (activated ? 1 : -1);
                state = Mathf.Clamp01(state);
                if(lineReticle != null)
                    lineReticle.transform.localScale = Vector3.Lerp(Vector3.zero, startReticleScale, state);
                lineRenderer.widthMultiplier = Mathf.Lerp(0, startWidth, state);

                if(useColorCurve)
                    for(int i = 0; i < startAlphaKeys.Length; i++) {
                        lineRenderer.colorGradient.alphaKeys[i] = new GradientAlphaKey(Mathf.Lerp(0, startAlphaKeys[i].alpha, colorCurve.Evaluate(state)), startAlphaKeys[i].time);
                    }
                yield return null;
            }

            lineRenderer.enabled = wasLineEnabled;
            animationCoroutine = null;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/LineAnimation.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/PlacePointAnimation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 313e47353b0f88446a5cd49c2c41577b
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class PlacePointAnimations : InteractionAnimations {
        [Header("Place Point")]
        public PlacePoint placePoint;

        protected override void OnEnable() {
            base.OnEnable();
            if(placePoint == null)
                placePoint = GetComponent<PlacePoint>();
            if(placePoint == null)
                placePoint = GetComponentInParent<PlacePoint>();

            placePoint.OnHighlight.AddListener(StartHighlight);
            placePoint.OnStopHighlight.AddListener(StopHighlight);
            placePoint.OnPlace.AddListener(OnPlace);
            placePoint.OnRemove.AddListener(OnRemove);
        }

        protected override void OnDisable() {
            base.OnDisable();
            placePoint.OnHighlight.RemoveListener(StartHighlight);
            placePoint.OnStopHighlight.RemoveListener(StopHighlight);
            placePoint.OnPlace.RemoveListener(OnPlace);
            placePoint.OnRemove.RemoveListener(OnRemove);
        }

        protected override void LateUpdate() {
            if(!placePoint.enabled)
                return;

            base.LateUpdate();
        }

        void StartHighlight(PlacePoint placePoint, Grabbable grabbable) {
            Highlight();
        }

        void StopHighlight(PlacePoint placePoint, Grabbable grabbable) {
            Unhighlight();
        }

        void OnPlace(PlacePoint placePoint, Grabbable grabbable) {
            Activate();
        }

        void OnRemove(PlacePoint placePoint, Grabbable grabbable) {
            Deactivate();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/PlacePointAnimation.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoHeaderAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 349372eb6797f054f99d44a16f633eaf
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using UnityEngine;
using System.Reflection;
using System.IO;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Autohand {
    public class AutoHeaderAttribute : PropertyAttribute {
        public int count;
        public int depth;

        public string label;
        public string tooltip;
        public string toggleBool;

        public System.Type type;

        /// <summary>
        /// Add a header above a field
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoHeaderAttribute(string label, int count = default, int depth = default) {
            this.count = count;
            this.depth = depth;
            this.label = label;
        }

        /// <summary>
        /// Add a header above a field with a tooltip
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="tooltip">A note or instruction shown when hovering over the header</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoHeaderAttribute(string label, string tooltip, string toggleName, System.Type classType, int count = default, int depth = default) {
            this.count = count;
            this.depth = depth;
            this.label = label;
            this.tooltip = tooltip;
        }
    }


#if UNITY_EDITOR
    [CustomPropertyDrawer(typeof(AutoHeaderAttribute))]
    public class AutoHeaderDrawer : PropertyDrawer {
        const float padding = 2f;
        const float margin = -20f;

        static Texture autohandlogo = null;
        static Font _labelFont = null;
        static Font labelFont {
            get {
                if(_labelFont == null)
                    _labelFont = Resources.Load<Font>("Righteous-Big");
                return _labelFont;
            }
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {

            position.yMax += position.height;

            var attr = (attribute as AutoHeaderAttribute);

            var newRect = position;
            newRect.position = new Vector2(newRect.x+newRect.width-18, newRect.y);


            // draw header background and label
            var headerRect = new Rect(position.x + margin, position.y, (position.width - margin) + (padding * 2), position.height);
            EditorGUI.DrawRect(headerRect, Constants.BackgroundColor);

            var labelStyle = Constants.HeaderStyle;
            labelStyle.font = labelFont;

            if(autohandlogo == null) {
                var assets = AssetDatabase.FindAssets("AutohandLogo");
                if(assets.Length > 0)
                    autohandlogo = AssetDatabase.LoadAssetAtPath<Texture>(AssetDatabase.GUIDToAssetPath(assets[0]));
            }

            EditorGUI.LabelField(headerRect, new GUIContent(" " + attr.label, autohandlogo, attr.tooltip), labelStyle);


            EditorGUILayout.Space();
            EditorGUILayout.Space();
            position.y += 2f;
        }
    }


    public static class Constants{
        private static readonly Color[] _barColors = new Color[5] {
            new Color(0.3411765f, 0.6039216f, 0.7803922f),
            new Color(0.145098f, 0.6f, 0.509804f),
            new Color(0.9215686f, 0.6431373f, 0.282353f),
            new Color(0.8823529f, 0.3529412f, 0.4039216f),
            new Color(0.9529412f, 0.9294118f, 0.682353f)
        };

        public static Color ColorForDepth(int depth) => _barColors[depth % _barColors.Length];

        public static Color BackgroundColor { get; } = EditorGUIUtility.isProSkin ? new Color(0.18f, 0.18f, 0.18f, 0.75f) : new Color(0.7f, 0.7f, 0.7f, 0.75f);
        
        public static GUIStyle LabelStyle { get; } = new GUIStyle(GUI.skin.label){
            alignment = TextAnchor.MiddleLeft,
            fontSize = 15
        };
        public static GUIStyle HeaderStyle { get; } = new GUIStyle(GUI.skin.label){
            alignment = TextAnchor.MiddleCenter,
            fontSize = 26
        };
    }
#endif
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoHeaderAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoLineAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 00c5387a69321f84aa2e86947b613fa3
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using UnityEngine;
using System.Reflection;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Autohand {
    public class AutoLineAttribute : PropertyAttribute {
        public int count;
        public int depth;

        public string tooltip;
        public string toggleBool;

        public System.Type type;

        /// <summary>
        /// Add a header above a field
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoLineAttribute(int count = default, int depth = default) {
            this.count = count;
            this.depth = depth;
        }

        /// <summary>
        /// Add a header above a field with a tooltip
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="tooltip">A note or instruction shown when hovering over the header</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoLineAttribute(string tooltip, string toggleName, System.Type classType, int count = default, int depth = default) {
            this.count = count;
            this.depth = depth;
            this.tooltip = tooltip;
        }
    }
#if UNITY_EDITOR
    [CustomPropertyDrawer(typeof(AutoLineAttribute))]
    public class AutoLineDrawer : PropertyDrawer {
        const float padding = 2f;
        const float margin = -20f;

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {



            // draw header background and label
            var headerRect = new Rect(position.x + margin, position.y+ 4, (position.width - margin) + (padding * 2), position.height);
            EditorGUI.DrawRect(headerRect, Constants.BackgroundColor);


            EditorGUILayout.Space();
        }

    }

#endif
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoLineAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoSmallHeaderAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2b0e1b365abb96f448b7dff928408fee
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using UnityEngine;
using System.Reflection;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Autohand
{
    public class AutoSmallHeaderAttribute : PropertyAttribute
    {
        public int count;
        public int depth;

        public string label;
        public string tooltip;
        public string toggleBool;

        public System.Type type;

        /// <summary>
        /// Add a header above a field
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoSmallHeaderAttribute(string label, int count = default, int depth = default)
        {
            this.count = count;
            this.depth = depth;
            this.label = label;
        }

        /// <summary>
        /// Add a header above a field with a tooltip
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="tooltip">A note or instruction shown when hovering over the header</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoSmallHeaderAttribute(string label, string tooltip, string toggleName, System.Type classType, int count = default, int depth = default)
        {
            this.count = count;
            this.depth = depth;
            this.label = label;
            this.tooltip = tooltip;
        }
    }

#if UNITY_EDITOR
    [CustomPropertyDrawer(typeof(AutoSmallHeaderAttribute))]
    public class AutoSmallHeaderDrawer : PropertyDrawer
    {
        const float padding = 2f;
        const float margin = -20f;

        static Font _labelFont = null;
        static Font labelFont
        {
            get {
                if(_labelFont == null)
                    _labelFont = Resources.Load<Font>("Righteous-Regular");
                return _labelFont;
            }
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {

            EditorGUILayout.Space();
            position.y += 14f;
            position.yMax += position.height/1.8f;

            var attr = (attribute as AutoSmallHeaderAttribute);

            var newRect = position;
            newRect.position = new Vector2(newRect.x+newRect.width-18, newRect.y);
            

            // draw header background and label
            var headerRect = new Rect(position.x + margin, position.y, (position.width - margin) + (padding * 2), position.height);
            EditorGUI.DrawRect(headerRect, Constants.BackgroundColor);


            var labelStyle = Constants.LabelStyle;
            labelStyle.font = labelFont;


            EditorGUI.LabelField(headerRect, new GUIContent(" " + attr.label, attr.tooltip), labelStyle);


            //var oldColor = GUI.color;
            //GUI.color = property.boolValue ? new Color(0.7f, 1f, 0.7f) : new Color(1f, 0.7f, 0.7f);

            //property.boolValue = EditorGUI.Toggle(newRect, property.boolValue);

            //GUI.color = oldColor;

            EditorGUILayout.Space();
            EditorGUILayout.Space();
            EditorGUILayout.Space();
            position.y += 2f;
        }

    }

#endif
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoSmallHeaderAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoToggleHeaderAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 89744b25182d72744b87abdce43cd5d3
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using UnityEngine;
using System.Reflection;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Autohand
{
    public class AutoToggleHeaderAttribute : PropertyAttribute
    {
        public int count;
        public int depth;

        public string label;
        public string tooltip;
        public string toggleBool;

        public System.Type type;

        /// <summary>
        /// Add a header above a field
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoToggleHeaderAttribute(string label, int count = default, int depth = default)
        {
            this.count = count;
            this.depth = depth;
            this.label = label;
        }

        /// <summary>
        /// Add a header above a field with a tooltip
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="tooltip">A note or instruction shown when hovering over the header</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoToggleHeaderAttribute(string label, string tooltip, string toggleName, System.Type classType, int count = default, int depth = default)
        {
            this.count = count;
            this.depth = depth;
            this.label = label;
            this.tooltip = tooltip;
        }
    }
#if UNITY_EDITOR
    [CustomPropertyDrawer(typeof(AutoToggleHeaderAttribute))]
    public class AutoToggleHeaderDrawer : PropertyDrawer
    {
        const float padding = 2f;
        const float margin = -20f;

        static Font _labelFont = null;
        static Font labelFont
        {
            get {
                if(_labelFont == null)
                    _labelFont = Resources.Load<Font>("Righteous-Regular");
                return _labelFont;
            }
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {

            EditorGUILayout.Space();
            position.y += 14f;
            position.yMax += position.height/1.8f;

            var attr = (attribute as AutoToggleHeaderAttribute);

            var newRect = position;
            newRect.position = new Vector2(newRect.x+newRect.width-18, newRect.y);
            

            // draw header background and label
            var headerRect = new Rect(position.x + margin, position.y, (position.width - margin) + (padding * 2), position.height);
            EditorGUI.DrawRect(headerRect, Constants.BackgroundColor);


            var oldColor1 = GUI.color;
            if (!property.boolValue)
            {
                var newColor = new Color(0.65f, 0.65f, 0.65f, 1f);
                newColor.a = 1;
                GUI.contentColor = newColor;
            }

            var labelStyle = Constants.LabelStyle;
            labelStyle.font = labelFont;


            EditorGUI.LabelField(headerRect, new GUIContent(" " + attr.label, attr.tooltip), labelStyle);

            GUI.contentColor = oldColor1;

            var oldColor = GUI.color;
            GUI.color = property.boolValue ? new Color(0.7f, 1f, 0.7f) : new Color(1f, 0.7f, 0.7f);

            property.boolValue = EditorGUI.Toggle(newRect, property.boolValue);

            GUI.color = oldColor;

            EditorGUILayout.Space();
            EditorGUILayout.Space();
            EditorGUILayout.Space();
            position.y += 2f;
        }

    }

#endif
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoToggleHeaderAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/AllowNestingAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 95b49d3abe880c044adbe7faf6b7b4ec
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class AllowNestingAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/AllowNestingAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/AnimatorParamAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7373332cb77b42744a415d6b4add445d
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;
using UnityEngine;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class AnimatorParamAttribute : DrawerAttribute
	{
		public string AnimatorName { get; private set; }
		public AnimatorControllerParameterType? AnimatorParamType { get; private set; }

		public AnimatorParamAttribute(string animatorName)
		{
			AnimatorName = animatorName;
			AnimatorParamType = null;
		}

		public AnimatorParamAttribute(string animatorName, AnimatorControllerParameterType animatorParamType)
		{
			AnimatorName = animatorName;
			AnimatorParamType = animatorParamType;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/AnimatorParamAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/CurveRangeAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bbdf3fb8882c7514c9a01108122cda7e
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;
using UnityEngine;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class CurveRangeAttribute : DrawerAttribute
	{
		public Vector2 Min { get; private set; }
		public Vector2 Max { get; private set; }
		public EColor Color { get; private set; }

		public CurveRangeAttribute(Vector2 min, Vector2 max, EColor color = EColor.Clear)
		{
			Min = min;
			Max = max;
			Color = color;
		}

		public CurveRangeAttribute(EColor color)
			: this(Vector2.zero, Vector2.one, color)
		{
		}

		public CurveRangeAttribute(float minX, float minY, float maxX, float maxY, EColor color = EColor.Clear)
			: this(new Vector2(minX, minY), new Vector2(maxX, maxY), color)
		{
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/CurveRangeAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/DrawerAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9df37fdebccf65c4da5b0a14f6dad5f5
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using UnityEngine;

namespace NaughtyAttributes
{
	/// <summary>
	/// Base class for all drawer attributes
	/// </summary>
	public class DrawerAttribute : PropertyAttribute, INaughtyAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/DrawerAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/DropdownAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2cb864a1092cec04f8a4dbb556e8ed31
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System.Collections;
using System;
using System.Collections.Generic;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class DropdownAttribute : DrawerAttribute
	{
		public string ValuesName { get; private set; }

		public DropdownAttribute(string valuesName)
		{
			ValuesName = valuesName;
		}
	}

	public interface IDropdownList : IEnumerable<KeyValuePair<string, object>>
	{
	}

	public class DropdownList<T> : IDropdownList
	{
		private List<KeyValuePair<string, object>> _values;

		public DropdownList()
		{
			_values = new List<KeyValuePair<string, object>>();
		}

		public void Add(string displayName, T value)
		{
			_values.Add(new KeyValuePair<string, object>(displayName, value));
		}

		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			return _values.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public static explicit operator DropdownList<object>(DropdownList<T> target)
		{
			DropdownList<object> result = new DropdownList<object>();
			foreach (var kvp in target)
			{
				result.Add(kvp.Key, kvp.Value);
			}

			return result;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/DropdownAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/EnumFlagsAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e8b31eb6d7299e54d89dcabc4cad0e6a
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class EnumFlagsAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/EnumFlagsAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/Expandable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 60926d6ca7f9ced469e9248ff1192da6
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ExpandableAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/Expandable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/HorizontalLineAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2fdd6f99acca2fd42a4f3162d585ce95
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = true)]
	public class HorizontalLineAttribute : DrawerAttribute
	{
		public const float DefaultHeight = 2.0f;
		public const EColor DefaultColor = EColor.Gray;

		public float Height { get; private set; }
		public EColor Color { get; private set; }

		public HorizontalLineAttribute(float height = DefaultHeight, EColor color = DefaultColor)
		{
			Height = height;
			Color = color;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/HorizontalLineAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/InfoBoxAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: afd1d6323740c734893fa8397c53113b
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public enum EInfoBoxType
	{
		Normal,
		Warning,
		Error
	}

	[AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = true)]
	public class InfoBoxAttribute : DrawerAttribute
	{
		public string Text { get; private set; }
		public EInfoBoxType Type { get; private set; }

		public InfoBoxAttribute(string text, EInfoBoxType type = EInfoBoxType.Normal)
		{
			Text = text;
			Type = type;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/InfoBoxAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/InputAxisAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 85033978c18810f46af271bbe94cf4aa
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class InputAxisAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/InputAxisAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/LayerAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 668d19ebe071176448d1af816a9a0ce0
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class LayerAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/LayerAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/MinMaxSliderAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4aaa73f574deaa54187cb54aae571b24
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class MinMaxSliderAttribute : DrawerAttribute
	{
		public float MinValue { get; private set; }
		public float MaxValue { get; private set; }

		public MinMaxSliderAttribute(float minValue, float maxValue)
		{
			MinValue = minValue;
			MaxValue = maxValue;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/MinMaxSliderAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ProgressBarAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e19e4db6f4d08f849aa8ea8155cd2760
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ProgressBarAttribute : DrawerAttribute
	{
		public string Name { get; private set; }
		public float MaxValue { get; set; }
		public string MaxValueName { get; private set; }
		public EColor Color { get; private set; }

		public ProgressBarAttribute(string name, float maxValue, EColor color = EColor.Blue)
		{
			Name = name;
			MaxValue = maxValue;
			Color = color;
		}

		public ProgressBarAttribute(string name, string maxValueName, EColor color = EColor.Blue)
		{
			Name = name;
			MaxValueName = maxValueName;
			Color = color;
		}

		public ProgressBarAttribute(float maxValue, EColor color = EColor.Blue)
			: this("", maxValue, color)
		{
		}

		public ProgressBarAttribute(string maxValueName, EColor color = EColor.Blue)
			: this("", maxValueName, color)
		{
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ProgressBarAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ResizableTextAreaAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 56d9a4b795ef4a94d86b94e55fb81240
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ResizableTextAreaAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ResizableTextAreaAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/SceneAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e054de18423364f4688b72a0f2a472b6
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class SceneAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/SceneAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ShowAssetPreviewAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4b7dd9b44abc0054cb5cd68d74be2c1a
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ShowAssetPreviewAttribute : DrawerAttribute
	{
		public const int DefaultWidth = 64;
		public const int DefaultHeight = 64;

		public int Width { get; private set; }
		public int Height { get; private set; }

		public ShowAssetPreviewAttribute(int width = DefaultWidth, int height = DefaultHeight)
		{
			Width = width;
			Height = height;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ShowAssetPreviewAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/TagAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8903399bbd7c9d745a7b9188ab6c8320
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class TagAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/TagAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ButtonAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e8fe363a25ec5e24a9dd510bb0b4a0d4
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public enum EButtonEnableMode
	{
		/// <summary>
		/// Button should be active always
		/// </summary>
		Always,
		/// <summary>
		/// Button should be active only in editor
		/// </summary>
		Editor,
		/// <summary>
		/// Button should be active only in playmode
		/// </summary>
		Playmode
	}

	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
	public class ButtonAttribute : SpecialCaseDrawerAttribute
	{
		public string Text { get; private set; }
		public EButtonEnableMode SelectedEnableMode { get; private set; }		

		public ButtonAttribute(string text = null, EButtonEnableMode enabledMode = EButtonEnableMode.Always)
		{
			this.Text = text;
			this.SelectedEnableMode = enabledMode;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ButtonAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ReorderableListAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6189b48f4055e6c47aa132632d898fa6
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ReorderableListAttribute : SpecialCaseDrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ReorderableListAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ShowNativePropertyAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a8e9b7b71c94a1f459336a24cfe04b1b
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
	public class ShowNativePropertyAttribute : SpecialCaseDrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ShowNativePropertyAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ShowNonSerializedFieldAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8ea09f60df536734184a8920ff8bda6f
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ShowNonSerializedFieldAttribute : SpecialCaseDrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ShowNonSerializedFieldAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/SpecialCaseDrawerAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 95a59093f8ed1af48a8be75fa3050a3c
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public class SpecialCaseDrawerAttribute : Attribute, INaughtyAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/SpecialCaseDrawerAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/INaughtyAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: edda855906d15e541b46efd812fd70f3
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public interface INaughtyAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/INaughtyAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/BoxGroupAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 07da8af1e3be52c4789678bf4138ae11
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class BoxGroupAttribute : MetaAttribute, IGroupAttribute
	{
		public string Name { get; private set; }

		public BoxGroupAttribute(string name = "")
		{
			Name = name;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/BoxGroupAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/DisableIfAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 52a0d5c249ac8fd42a4fb4d61bc2f797
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field | AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
	public class DisableIfAttribute : EnableIfAttributeBase
	{
		public DisableIfAttribute(string condition)
			: base(condition)
		{
			Inverted = true;
		}

		public DisableIfAttribute(EConditionOperator conditionOperator, params string[] conditions)
			: base(conditionOperator, conditions)
		{
			Inverted = true;
		}

		public DisableIfAttribute(string enumName, object enumValue)
			: base(enumName, enumValue as Enum)
		{
			Inverted = true;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/DisableIfAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/EnableIfAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a616ae826c8ebae45a89d6a8cb68a843
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field | AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
	public class EnableIfAttribute : EnableIfAttributeBase
	{
		public EnableIfAttribute(string condition)
			: base(condition)
		{
			Inverted = false;
		}

		public EnableIfAttribute(EConditionOperator conditionOperator, params string[] conditions)
			: base(conditionOperator, conditions)
		{
			Inverted = false;
		}

		public EnableIfAttribute(string enumName, object enumValue)
			: base(enumName, enumValue as Enum)
		{
			Inverted = false;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/EnableIfAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/EnableIfAttributeBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8ba6385cd022e164b89ead1937173ddc
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public abstract class EnableIfAttributeBase : MetaAttribute
	{
		public string[] Conditions { get; private set; }
		public EConditionOperator ConditionOperator { get; private set; }
		public bool Inverted { get; protected set; }

		/// <summary>
		///		If this not null, <see cref="Conditions"/>[0] is name of an enum variable.
		/// </summary>
		public Enum EnumValue { get; private set; }

		public EnableIfAttributeBase(string condition)
		{
			ConditionOperator = EConditionOperator.And;
			Conditions = new string[1] { condition };
		}

		public EnableIfAttributeBase(EConditionOperator conditionOperator, params string[] conditions)
		{
			ConditionOperator = conditionOperator;
			Conditions = conditions;
		}

		public EnableIfAttributeBase(string enumName, Enum enumValue)
			: this(enumName)
		{
			if (enumValue == null)
			{
				throw new ArgumentNullException(nameof(enumValue), "This parameter must be an enum value.");
			}

			EnumValue = enumValue;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/EnableIfAttributeBase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/FoldoutAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 95f184555d5079243b2d25b35a641a74
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class FoldoutAttribute : MetaAttribute, IGroupAttribute
	{
		public string Name { get; private set; }

		public FoldoutAttribute(string name)
		{
			Name = name;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/FoldoutAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/HideIfAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9ab2d0fcfb13a214ea6ef7629c96a761
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field | AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
	public class HideIfAttribute : ShowIfAttributeBase
	{
		public HideIfAttribute(string condition)
			: base(condition)
		{
			Inverted = true;
		}

		public HideIfAttribute(EConditionOperator conditionOperator, params string[] conditions)
			: base(conditionOperator, conditions)
		{
			Inverted = true;
		}

		public HideIfAttribute(string enumName, object enumValue)
			: base(enumName, enumValue as Enum)
		{
			Inverted = true;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/HideIfAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/IGroupAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7c437b9ac50575347a7b12520f37f9a2
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using UnityEngine;

namespace NaughtyAttributes
{
	public interface IGroupAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/IGroupAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/LabelAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 79e0e0c0a7c25ea4fbe8eecaa4d559a0
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class LabelAttribute : MetaAttribute
	{
		public string Label { get; private set; }

		public LabelAttribute(string label)
		{
			Label = label;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/LabelAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/MetaAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a482b4e0fbf0f4547a5d522182a68d24
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public class MetaAttribute : Attribute, INaughtyAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/MetaAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/OnValueChangedAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e16a27c5576022b4bbe997c7db9051f0
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = true)]
	public class OnValueChangedAttribute : MetaAttribute
	{
		public string CallbackName { get; private set; }

		public OnValueChangedAttribute(string callbackName)
		{
			CallbackName = callbackName;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/OnValueChangedAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ReadOnlyAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e57264747ba93b94fbff12733de29499
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ReadOnlyAttribute : MetaAttribute
	{

	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ReadOnlyAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ShowIfAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1ada427cfd2c9b04989d6d18dea27985
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field | AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
	public class ShowIfAttribute : ShowIfAttributeBase
	{
		public ShowIfAttribute(string condition)
			: base(condition)
		{
			Inverted = false;
		}

		public ShowIfAttribute(EConditionOperator conditionOperator, params string[] conditions)
			: base(conditionOperator, conditions)
		{
			Inverted = false;
		}

		public ShowIfAttribute(string enumName, object enumValue)
			: base(enumName, enumValue as Enum)
		{
			Inverted = false;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ShowIfAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ShowIfAttributeBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0532b1c4d8a9ccf4b9f98f0bbe4a6747
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public class ShowIfAttributeBase : MetaAttribute
	{
		public string[] Conditions { get; private set; }
		public EConditionOperator ConditionOperator { get; private set; }
		public bool Inverted { get; protected set; }

		/// <summary>
		///		If this not null, <see cref="Conditions"/>[0] is name of an enum variable.
		/// </summary>
		public Enum EnumValue { get; private set; }

		public ShowIfAttributeBase(string condition)
		{
			ConditionOperator = EConditionOperator.And;
			Conditions = new string[1] { condition };
		}

		public ShowIfAttributeBase(EConditionOperator conditionOperator, params string[] conditions)
		{
			ConditionOperator = conditionOperator;
			Conditions = conditions;
		}

		public ShowIfAttributeBase(string enumName, Enum enumValue)
			: this(enumName)
		{
			if (enumValue == null)
			{
				throw new ArgumentNullException(nameof(enumValue), "This parameter must be an enum value.");
			}

			EnumValue = enumValue;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ShowIfAttributeBase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/Utility/EColor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 059f8674a8065924ea9c678298b5cd63
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using UnityEngine;

namespace NaughtyAttributes
{
	public enum EColor
	{
		Clear,
		White,
		Black,
		Gray,
		Red,
		Pink,
		Orange,
		Yellow,
		Green,
		Blue,
		Indigo,
		Violet
	}

	public static class EColorExtensions
	{
		public static Color GetColor(this EColor color)
		{
			switch (color)
			{
				case EColor.Clear:
					return new Color32(0, 0, 0, 0);
				case EColor.White:
					return new Color32(255, 255, 255, 255);
				case EColor.Black:
					return new Color32(0, 0, 0, 255);
				case EColor.Gray:
					return new Color32(128, 128, 128, 255);
				case EColor.Red:
					return new Color32(255, 0, 63, 255);
				case EColor.Pink:
					return new Color32(255, 152, 203, 255);
				case EColor.Orange:
					return new Color32(255, 128, 0, 255);
				case EColor.Yellow:
					return new Color32(255, 211, 0, 255);
				case EColor.Green:
					return new Color32(98, 200, 79, 255);
				case EColor.Blue:
					return new Color32(0, 135, 189, 255);
				case EColor.Indigo:
					return new Color32(75, 0, 130, 255);
				case EColor.Violet:
					return new Color32(128, 0, 255, 255);
				default:
					return new Color32(0, 0, 0, 255);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/Utility/EColor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/Utility/EConditionOperator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3c227b6c19fc67b46ad294d95818f85a
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public enum EConditionOperator
	{
		And,
		Or
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/Utility/EConditionOperator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/MaxValueAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a748250af5ccfd7499cfb444aafb8a03
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class MaxValueAttribute : ValidatorAttribute
	{
		public float MaxValue { get; private set; }

		public MaxValueAttribute(float maxValue)
		{
			MaxValue = maxValue;
		}

		public MaxValueAttribute(int maxValue)
		{
			MaxValue = maxValue;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/MaxValueAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/MinValueAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 40133bac7c8d42b4d837138430a503e0
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class MinValueAttribute : ValidatorAttribute
	{
		public float MinValue { get; private set; }

		public MinValueAttribute(float minValue)
		{
			MinValue = minValue;
		}

		public MinValueAttribute(int minValue)
		{
			MinValue = minValue;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/MinValueAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/RequiredAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b0cdf49d1687849458b1a8d4786553d4
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class RequiredAttribute : ValidatorAttribute
	{
		public string Message { get; private set; }

		public RequiredAttribute(string message = null)
		{
			Message = message;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/RequiredAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/ValidateInputAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6c4171d68fb5bc0448d3ac298973e82c
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ValidateInputAttribute : ValidatorAttribute
	{
		public string CallbackName { get; private set; }
		public string Message { get; private set; }

		public ValidateInputAttribute(string callbackName, string message = null)
		{
			CallbackName = callbackName;
			Message = message;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/ValidateInputAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/ValidatorAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0f3c43bed2dbc5249b6c6ec7859c2020
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public class ValidatorAttribute : Attribute, INaughtyAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/ValidatorAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/AutoHandExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 25c5f6ae064fd274d9b8dea1c18335bb
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

namespace Autohand
{
    public static class AutoHandExtensions
    {
        
        static Transform _transformRuler = null;
        //This is a "ruler" tool used to help calculate parent child calculations without doing parenting/childing
        public static Transform transformRuler
        {
            get {
                if(_transformRuler == null)
                    _transformRuler = new GameObject() { name = "Ruler" }.transform;

                if (_transformRuler.parent != transformParent)
                    _transformRuler.parent = transformParent;

                if (_transformRuler.localScale != Vector3.one)
                    _transformRuler.localScale = Vector3.one;

                if (IsPositionNan(_transformRuler.position))
                    _transformRuler.position = Vector3.zero;
                if (IsRotationNan(_transformRuler.rotation))
                    _transformRuler.rotation = Quaternion.identity;



                return _transformRuler;
            }
        }

        static Transform _transformRulerChild = null;
        //This is a "ruler" tool used to help calculate parent child calculations without doing parenting/childing
        public static Transform transformRulerChild
        {
            get {
                if (_transformRulerChild == null)
                {
                    _transformRulerChild = new GameObject() { name = "RulerChild" }.transform;
                    _transformRulerChild.parent = _transformRuler;
                }

                if (_transformRulerChild.parent != _transformRuler)
                    _transformRulerChild.parent = _transformRuler;

                if (_transformRulerChild.localScale != Vector3.one)
                    _transformRulerChild.localScale = Vector3.one;

                if (IsPositionNan(_transformRulerChild.position))
                    _transformRulerChild.position = Vector3.zero;
                if (IsRotationNan(_transformRulerChild.rotation))
                    _transformRulerChild.rotation = Quaternion.identity;

                return _transformRulerChild;
            }
        }

        static bool IsPositionNan(Vector3 pos)
        {
            return float.IsNaN(pos.x) || float.IsNaN(pos.y) || float.IsNaN(pos.z);
        }
        
        static bool IsRotationNan(Quaternion rot)
        {
            return float.IsNaN(rot.x) || float.IsNaN(rot.y) || float.IsNaN(rot.z) || float.IsNaN(rot.w);
        }

        static Transform _transformParent = null;

        // Holds all the Auto Hand Generated GameObjects
        public static Transform transformParent {
            get {
                if(Application.isEditor)
                    return null;

                if(_transformParent == null)
                    _transformParent = new GameObject() { name="Auto Hand Generated" }.transform;

                return _transformParent;
            }
        }

        public static void RotateAround(this Transform target, Transform center, Quaternion deltaRotation) {
            transformRuler.SetPositionAndRotation(center.position, center.rotation);
            transformRulerChild.SetPositionAndRotation(target.position, target.rotation);
            transformRuler.rotation *= deltaRotation;
            target.SetPositionAndRotation(transformRulerChild.position, transformRulerChild.rotation);
        }

        public static float Round(this float value, int digits)
        {
            float mult = Mathf.Pow(10.0f, (float)digits);
            return Mathf.Round(value * mult) / mult;
        }

        /// <summary>Returns true if there is a grabbable or link, out null if there is none</summary>
        public static bool HasGrabbable(this Hand hand, GameObject obj, out Grabbable grabbable) {
            return HasGrabbable(obj, out grabbable);
        }

        /// <summary>Returns true if there is a grabbable or link, out null if there is none</summary>
        public static bool HasGrabbable(this Hand hand, UnityEngine.Component obj, out Grabbable grabbable) {
            return HasGrabbable(obj, out grabbable);
        }

        /// <summary>Returns true if there is a grabbable or link, out null if there is none</summary>
        public static bool HasGrabbable(this GameObject obj, out Grabbable grabbable, bool includeDisabled = false) {
            if(obj == null) {
                grabbable = null;
                return false;
            }


            if(obj.CanGetComponent(out IGrabbableEvents grabbableEvents)) {
                if(grabbableEvents.GetGrabbable() != null && (includeDisabled || grabbableEvents.GetGrabbable().enabled)) {
                    grabbable = grabbableEvents.GetGrabbable();
                    return true;
                }
            }

            if(obj.CanGetComponent(out grabbable) && (includeDisabled || grabbable.enabled)) {
                return true;
            }

            GrabbableChild grabChild;
            if(obj.CanGetComponent(out grabChild) && (includeDisabled || grabChild.grabParent.enabled)) {
                grabbable = grabChild.grabParent;
                return true;
            }

            grabbable = null;
            return false;
        }

        /// <summary>Returns true if there is a grabbable or link, out null if there is none</summary>
        public static bool HasGrabbable(this Component obj, out Grabbable grabbable, bool includeDisabled = false) {
            if(obj == null) {
                grabbable = null;
                return false;
            }


            if(obj.CanGetComponent(out IGrabbableEvents grabbableEvents)) {
                if(grabbableEvents.GetGrabbable() != null && (includeDisabled || grabbableEvents.GetGrabbable().enabled)) {
                    grabbable = grabbableEvents.GetGrabbable();
                    return true;
                }
            }

            if(obj.CanGetComponent(out grabbable) && (includeDisabled || grabbable.enabled)) {
                return true;
            }

            GrabbableChild grabChild;
            if(obj.CanGetComponent(out grabChild) && (includeDisabled || grabChild.grabParent.enabled)) {
                grabbable = grabChild.grabParent;
                return true;
            }

            grabbable = null;
            return false;
        }









        public static T GetCopyOf<T>(this Component comp, T other) where T : Component{
            Type type = comp.GetType();
            if (type != other.GetType()) return null; // type mis-match
            BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Default | BindingFlags.DeclaredOnly;
            PropertyInfo[] pinfos = type.GetProperties(flags);
            foreach (var pinfo in pinfos)
            {
                if (pinfo.CanWrite)
                {
                    try
                    {
                        pinfo.SetValue(comp, pinfo.GetValue(other, null), null);
                    }
                    catch { } // In case of NotImplementedException being thrown. For some reason specifying that exception didn't seem to catch it, so I didn't catch anything specific.
                }
            }
            FieldInfo[] finfos = type.GetFields(flags);
            foreach (var finfo in finfos)
            {
                finfo.SetValue(comp, finfo.GetValue(other));
            }
            return comp as T;
        }



        /// <summary>Autohand extension method, used so I can use TryGetComponent for newer versions and GetComponent for older versions</summary>
        public static bool CanGetComponent<T>(this Component componentClass, out T component)
        {
#if UNITY_2019_1 || UNITY_2018 || UNITY_2017
       var tempComponent = componentClass.GetComponent<T>();
        if(tempComponent != null){
            component = tempComponent;
            return true;
        }
        else {
            component = tempComponent;
            return false;
        }
#else
            var value = componentClass.TryGetComponent(out component);
            return value;
#endif
        }

        /// <summary>Autohand extension method, used so I can use TryGetComponent for newer versions and GetComponent for older versions</summary>
        public static bool CanGetComponent<T>(this GameObject componentClass, out T component) {
#if UNITY_2019_1 || UNITY_2018 || UNITY_2017
       var tempComponent = componentClass.GetComponent<T>();
        if(tempComponent != null){
            component = tempComponent;
            return true;
        }
        else {
            component = tempComponent;
            return false;
        }
#else
            var value = componentClass.TryGetComponent(out component);
            return value;
#endif
        }

        /// <summary>Autohand extension method, used so I can use TryGetComponent for newer versions and GetComponent for older versions</summary>
        public static T CanFindObjectOfType<T>(bool includeInactive = false) where T : Component {
#if UNITY_2023_1_OR_NEWER
            return GameObject.FindFirstObjectByType<T>((includeInactive ? FindObjectsInactive.Include : FindObjectsInactive.Exclude));
#elif (UNITY_2020_3_OR_NEWER)
            return GameObject.FindObjectOfType<T>(includeInactive);
#else
            return GameObject.FindObjectOfType<T>();
#endif
        }
        /// <summary>Autohand extension method, used so I can use TryGetComponent for newer versions and GetComponent for older versions</summary>
        public static T[] CanFindObjectsOfType<T>(bool includeInactive = false) where T : Component {
#if UNITY_2023
            return GameObject.FindObjectsByType<T>((includeInactive ? FindObjectsInactive.Include : FindObjectsInactive.Exclude), FindObjectsSortMode.None);
#elif (UNITY_6000_0_OR_NEWER)
            return GameObject.FindObjectsByType<T>((includeInactive ? FindObjectsInactive.Include : FindObjectsInactive.Exclude), FindObjectsSortMode.None);
#elif (UNITY_2020_3_OR_NEWER)                        
            return GameObject.FindObjectsOfType<T>(includeInactive);
#else
            return GameObject.FindObjectsOfType<T>();
#endif
        }




#if UNITY_EDITOR

        public static void TextDebug(this Vector3 vector3, string name = "") {
            Debug.Log(name + ": " + vector3.x + ", " + vector3.y + ", " + vector3.z);
        }

        public static GUIStyle LabelStyle(TextAnchor textAnchor = TextAnchor.MiddleLeft, FontStyle fontStyle = FontStyle.Normal, int fontSize = 13) {
            var style = new GUIStyle(GUI.skin.label);
            style.font = (Font)Resources.Load("Righteous-Regular", typeof(Font));
            style.fontSize = fontSize;
            style.alignment = textAnchor;
            style.fontStyle = fontStyle;
            return style;
        }
        public static GUIStyle LabelStyle(Color textColor, TextAnchor textAnchor = TextAnchor.MiddleLeft, FontStyle fontStyle = FontStyle.Normal, int fontSize = 13) {
            var style = new GUIStyle(GUI.skin.label);
            style.font = (Font)Resources.Load("Righteous-Regular", typeof(Font));
            style.fontSize = fontSize;
            style.alignment = textAnchor;
            style.fontStyle = fontStyle;
            style.normal.textColor = textColor;
            return style;
        }

        public static GUIStyle LabelStyleB(Color textColor, TextAnchor textAnchor = TextAnchor.MiddleLeft, FontStyle fontStyle = FontStyle.Normal, int fontSize = 13) {
            var style = new GUIStyle(GUI.skin.toggle);
            style.font = (Font)Resources.Load("Righteous-Regular", typeof(Font));
            style.fontSize = fontSize;
            style.alignment = textAnchor;
            style.fontStyle = fontStyle;
            style.normal.textColor = textColor;
            return style;
        }
#endif

        public static LayerMask GetPhysicsLayerMask(int currentLayer) {
            int finalMask = 0;
            for (int i=0; i<32; i++) {
                if (!Physics.GetIgnoreLayerCollision(currentLayer, i)) finalMask = finalMask | (1 << i);
            }
            return finalMask;
        }

        public static void AddTorqueAtPoint(this Rigidbody rigidbody, Vector3 torque, Vector3 point) {
            // Apply the torque
            rigidbody.AddTorque(torque, ForceMode.VelocityChange);

            // Calculate the force direction (perpendicular to the torque and line from center of mass to point)
            Vector3 forceDir = Vector3.Cross(torque, point - rigidbody.worldCenterOfMass).normalized;

            // Calculate the magnitude of the force
            Vector3 pointVelocity = rigidbody.GetPointVelocity(point);
            Vector3 angularVelocityContribution = Vector3.Cross(rigidbody.angularVelocity, point - rigidbody.worldCenterOfMass);
            float forceMagnitude = (pointVelocity - angularVelocityContribution).magnitude;

            // Apply the force at the point
            rigidbody.AddForceAtPosition(forceDir * forceMagnitude, point, ForceMode.VelocityChange);
        }


        public static Matrix4x4 Lerp(ref Matrix4x4 from, Matrix4x4 to, float t) {
            var fromPosition = ExtractPosition(ref from);
            var fromRotation = ExtractRotation(ref from);
            var fromScale = ExtractScale(ref from);

            var toPosition = ExtractPosition(ref to);
            var toRotation = ExtractRotation(ref to);
            var toScale = ExtractScale(ref to);

            return Matrix4x4.TRS(Vector3.Lerp(fromPosition, toPosition, t), Quaternion.Slerp(fromRotation, toRotation, t), Vector3.Lerp(fromScale, toScale, t));
        }

        public static Vector3 ExtractPosition(ref Matrix4x4 matrix) => matrix.GetColumn(3);
        public static Quaternion ExtractRotation(ref Matrix4x4 matrix) => Quaternion.LookRotation(matrix.GetColumn(2), matrix.GetColumn(1));
        public static Vector3 ExtractScale(ref Matrix4x4 matrix) => matrix.lossyScale;

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/AutoHandExtensions.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoAmmo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6bdeab21deb0d4b4093a6d63537c25cc
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [RequireComponent(typeof(Grabbable))]
    public class AutoAmmo : MonoBehaviour {
        public int currentAmmo = 16;
        public TMPro.TextMeshPro ammoText;

        private void Start() {
            SetAmmo(currentAmmo);
        }

        public bool RemoveAmmo() {
            if(currentAmmo > 0) {
                SetAmmo(--currentAmmo);
                return true;
            }
            return false;
        }

        public void SetAmmo(int amount) {
            currentAmmo = amount;
            if(ammoText != null)
                ammoText.text = currentAmmo.ToString();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoAmmo.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoAnimation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3ce88833e24f32946b52520c576f041f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand
{
    public enum AnimationPoint
    {
        start,
        end
    }

    public class AutoAnimation : MonoBehaviour
    {
        [Tooltip("This each transform that will be animated")]
        public AnimationCurve animationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);
        public bool recordChildTransforms = true;
        public bool setPositions = true;
        public bool setRotations = true;
        public bool setScale = false;

        [SerializeField,HideInInspector]
        private Transform[] transformReferences;
        [SerializeField, HideInInspector]
        private Vector3[] maxValuePositions;
        [SerializeField, HideInInspector]
        private Quaternion[] maxValueRotations;
        [SerializeField, HideInInspector]
        private Vector3[] maxValueScales;

        [SerializeField, HideInInspector]
        private Vector3[] minValuePositions;
        [SerializeField, HideInInspector]
        private Quaternion[] minValueRotations;
        [SerializeField, HideInInspector]
        private Vector3[] minValueScales;

        Transform transformRoot;

        public void SetAnimation(float point)
        {
            if (setPositions)
                for (int i = 0; i < transformReferences.Length; i++)
                    transformReferences[i].localPosition = Vector3.Lerp(minValuePositions[i], maxValuePositions[i], animationCurve.Evaluate(point));

            if (setRotations)
                for (int i = 0; i < transformReferences.Length; i++)
                    transformReferences[i].localRotation = Quaternion.Lerp(minValueRotations[i], maxValueRotations[i], animationCurve.Evaluate(point));

            if (setScale)
                for (int i = 0; i < transformReferences.Length; i++)
                    transformReferences[i].localScale = Vector3.Lerp(minValueScales[i], maxValueScales[i], animationCurve.Evaluate(point));
        }

        internal Vector3 GetTransformPositionAtPoint(int index, float point)
        {
            return Vector3.Lerp(minValuePositions[index], maxValuePositions[index], animationCurve.Evaluate(point));
        }

        internal int GetTransformIndex(Transform transform)
        {
            for (int i = 0; i < transformReferences.Length; i++)
            {
                if (transformReferences[i].Equals(transform))
                    return i;
            }

            return -1;
        }

        [NaughtyAttributes.Button("Save Start"), ContextMenu("Save Start")]
        public void SaveAnimationStart()
        {
            Debug.Log("Saved Start Pose");
            SaveAnimation(AnimationPoint.start);
        }

        [NaughtyAttributes.Button("Save End"), ContextMenu("Save End")]
        public void SaveAnimationEnd() {
            Debug.Log("Saved End Pose");
            SaveAnimation(AnimationPoint.end);
        }

        [Range(0, 1)]
        public float setTestValue = 0;
        [NaughtyAttributes.Button("Set")]
        public void SetAnimation()
        {
            SetAnimation(setTestValue);
        }

        public void SaveAnimation(AnimationPoint animationPoint)
        {
            if(transformRoot == null)
                transformRoot = transform;

            int count = 0;
            void GetRecursiveChildCount(Transform obj){
                count++;
                if (recordChildTransforms)
                    for (int k = 0; k < obj.childCount; k++)
                        GetRecursiveChildCount(obj.GetChild(k));
            }

            GetRecursiveChildCount(transformRoot);

            transformReferences = new Transform[count];
            if (animationPoint == AnimationPoint.end)
            {
                maxValuePositions = new Vector3[count];
                maxValueRotations = new Quaternion[count];
                maxValueScales = new Vector3[count];
            }
            else if(animationPoint == AnimationPoint.start)
            {
                minValuePositions = new Vector3[count];
                minValueRotations = new Quaternion[count];
                minValueScales = new Vector3[count];
            }


            int currIndex = 0;
            AssignChildrenPose(transformRoot);


            void AssignChildrenPose(Transform obj) {

                AssignPoint(currIndex, obj.localPosition, obj.localRotation, obj.localScale, obj);
                currIndex++;

                if (recordChildTransforms)
                    for (int j = 0; j < obj.childCount; j++)
                        AssignChildrenPose(obj.GetChild(j));
            }


            void AssignPoint(int point, Vector3 pos, Quaternion rot, Vector3 scale, Transform joint)
            {
                transformReferences[point] = joint;
                if (animationPoint == AnimationPoint.end)
                {
                    maxValuePositions[point] = pos;
                    maxValueRotations[point] = rot;
                    maxValueScales[point] = scale;
                }
                else if (animationPoint == AnimationPoint.start)
                {
                    minValuePositions[point] = pos;
                    minValueRotations[point] = rot;
                    minValueScales[point] = scale;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoAnimation.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoArrow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3034800f363546d40a653770a8c3207e
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo
{
    public class AutoArrow : MonoBehaviour
    {
        public float minPenetrationVelocity = 4f;
        public float maxPenetrationVelocity = 20f;
        public float minPenetrationDistance = 0.1f;
        public float maxPenetrationDistance = 0.2f;
        public float impactForceMultiplier = 1f;
        public Grabbable grabbable;
        Grabbable hitGrabbable;

        public AutoBow firedBow { get; internal set; }

        Vector3 direction;
        float currforce;

        public void FireArrow(float force, Grabbable arrowGrab, AutoBow firedBow)
        {
            grabbable = arrowGrab;
            this.firedBow = firedBow;
            impactForceMultiplier = firedBow.arrowImpactForceMultiplier;

            currforce = force;
            direction = transform.TransformDirection(firedBow.arrowForceDirection);
        }

        private void OnEnable() {
            if(grabbable == null)
                grabbable = GetComponent<Grabbable>();

            grabbable.OnGrabEvent += OnGrabbed;
        }

        private void OnDisable() {
            grabbable.OnGrabEvent -= OnGrabbed;
        }
        void OnGrabbed(Hand hand, Grabbable grab) {
            grabbable.ActivateRigidbody();
            hitGrabbable?.RemoveChildGrabbable(grab);
            hitGrabbable = null;
            firedBow = null;
        }

        public void FixedUpdate()
        {
            if (firedBow != null)
            {
                var currVel = direction * currforce;
                currVel += Physics.gravity * Time.fixedDeltaTime;
                direction = currVel.normalized;
                grabbable.rootTransform.position += direction * Time.fixedDeltaTime * currforce;
                grabbable.rootTransform.rotation = Quaternion.FromToRotation(firedBow.arrowForceDirection, direction);
                grabbable.body.linearVelocity = Vector3.zero;
                grabbable.body.angularVelocity = Vector3.zero;
            }
        }




        public void OnCollisionEnter(Collision collision)
        {
            if (firedBow != null)
            {
                if (collision.rigidbody == null || collision.rigidbody != firedBow.bowHandleGrabbable.body)
                {
                    if (currforce > minPenetrationVelocity)
                    {
                        GrabbableChild hitGrabbableChild;
                        if(collision.collider.CanGetComponent<Grabbable>(out hitGrabbable)) {
                            hitGrabbable.AddChildGrabbable(grabbable);

                        }
                        if (collision.collider.CanGetComponent<GrabbableChild>(out hitGrabbableChild)) {

                            hitGrabbable = hitGrabbableChild.grabParent;
                            hitGrabbable.AddChildGrabbable(grabbable);

                        }

                        grabbable.rootTransform.position += grabbable.body.linearVelocity * 1 / 50f;
                        grabbable.rootTransform.parent = collision.collider.transform;
                        grabbable.DeactivateRigidbody();
                        
                    }

                    //grabbable.body.isKinematic = false;
                    firedBow = null;

                    if (collision.rigidbody != null)
                        collision.rigidbody.AddForceAtPosition(impactForceMultiplier * direction * currforce, collision.contacts[0].point, ForceMode.Impulse);
                }

            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoArrow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoBow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 752961632a0d3c449954753f1750e488
# ASMDEF: AutoHandAssembly.dll
# ---
using NaughtyAttributes;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using Autohand;

namespace Autohand.Demo {
    public class AutoBow : MonoBehaviour
    {
        public AutoAnimation bowAnimation;
        public Grabbable bowHandleGrabbable;
        public HeldPlaceJoint arrowPoint;
        [Space]
        public float drawbackRange = 0.3f;
        public float drawbackSpring = 100f;
        public float drawbackDamper = 10f;
        public float tolerance = 0.005f;
        [Space]
        public Vector3 arrowForceDirection = Vector3.forward;
        public float arrowForce = 1f;
        public float arrowImpactForceMultiplier = 1f;
        public AnimationCurve arrowForceCurve = AnimationCurve.Linear(0, 0, 1, 1);

        protected Grabbable arrow;
        protected SpringJoint arrowJoint;

        int placePointIndex = 0;

        public void Start()
        {
            placePointIndex = bowAnimation.GetTransformIndex(arrowPoint.transform);
            arrowPoint.enabled = false;
            arrowPoint.OnPlaceEvent += OnArrowPlace;
            bowHandleGrabbable.OnGrabEvent += OnBowHandleGrab;
            bowHandleGrabbable.OnReleaseEvent += OnBowHandleRelease;

        }

        public void Update()
        {
            BowStringAnimation();
        }

        float arrowPointValue = 0.5f;
        public void BowStringAnimation()
        {

            if (arrowPoint.placedObject != null)
            {
                var arrowHand = arrowPoint.placedObject.GetHeldBy()[0];
                arrowPointValue = 0.5f;
                float closestPoint = 0.5f;
                for (int i = 0; i < 20; i++) {
                    var postitionA = bowAnimation.GetTransformPositionAtPoint(placePointIndex, closestPoint + arrowPointValue / 2f);
                    var postitionB = bowAnimation.GetTransformPositionAtPoint(placePointIndex, closestPoint - arrowPointValue / 2f);
                    var postitionC = bowAnimation.GetTransformPositionAtPoint(placePointIndex, closestPoint);
                    var distanceA = Vector3.Distance(postitionA, arrowPoint.placedObject.transform.position);
                    var distanceB = Vector3.Distance(postitionB, arrowPoint.placedObject.transform.position);
                    var distanceC = Vector3.Distance(postitionC, arrowPoint.placedObject.transform.position);

                    if(distanceC < distanceA && distanceC < distanceB) { }
                    else if(distanceA < distanceB)
                        closestPoint += arrowPointValue / 2f;
                    else
                        closestPoint -= arrowPointValue / 2f;

                    arrowPointValue /= 2f;
                }

                bowAnimation.SetAnimation(closestPoint);
            }
            else if(arrowPointValue != 0) {
                arrowPointValue = 0;
                bowAnimation.SetAnimation(arrowPointValue);
            }
        }

        public void OnBowHandleGrab(Hand hand, Grabbable grab)
        {
            arrowPoint.enabled = true;
        }

        public void OnBowHandleRelease(Hand hand, Grabbable grab)
        {
            arrowPoint.enabled = false;
        }



        public void OnArrowPlace(PlacePoint point, Grabbable grab)
        {
            point.placedObject.OnReleaseEvent += OnArrowRelease;
            if(bowHandleGrabbable.HeldCount() > 0)
                point.placedObject.IgnoreHand(bowHandleGrabbable.GetHeldBy()[0], true);
            point.placedObject.ignoreReleaseTime = 1f;
        }


        public void OnArrowRelease(Hand hand, Grabbable grab)
        {
            if (arrowPoint.placedObject != null)
            {
                //arrowPoint.Destroyjoint();
                arrowPoint.Remove(arrowPoint.placedObject);
                if (bowHandleGrabbable.HeldCount() > 0){
                    bowAnimation.SetAnimation(0);
                    var bowHand = bowHandleGrabbable.GetHeldBy()[0];
                    EnableCollisionDelay(3f, grab, bowHandleGrabbable.GetHeldBy()[0], arrowPoint);
                }

                AutoArrow arrow;
                if (grab.body.TryGetComponent<AutoArrow>(out arrow))
                {
                    arrow.FireArrow(arrowForceCurve.Evaluate(arrowPointValue)*arrowForce, grab, this);
                }
                else
                {
                    arrow = grab.body.gameObject.AddComponent<AutoArrow>();
                    arrow.FireArrow(arrowForceCurve.Evaluate(arrowPointValue) * arrowForce, grab, this);
                }

            }
        }

        IEnumerator EnableCollisionDelay(float delay, Grabbable grab, Hand hand, PlacePoint placePoint)
        {
            var preDrag = grab.body.angularDamping;
            bowHandleGrabbable.IgnoreGrabbableCollisionUntilNone(grab);
            placePoint.dontAllows.Add(grab);
            yield return new WaitForSeconds(delay);
            grab.IgnoreHand(hand, false);
            placePoint.dontAllows.Remove(grab);

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoBow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGun.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 11f7286f437aec34c8a4a6f841c921ef
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand {
    public enum SlideLoadType {
        HandLoaded,
        ShotLoaded
    }

    [Serializable] public class UnityGunHitEvent : UnityEvent<AutoGun, RaycastHit> { }
    [Serializable] public class UnityGunEvent : UnityEvent<AutoGun> { }
    [Serializable] public class UnityGunSlideEvent : UnityEvent<AutoGun, SlideLoadType> { }
    [Serializable] public class UnityAmmoEvent : UnityEvent<AutoGun, AutoAmmo> { }



    [RequireComponent(typeof(Grabbable))]
    public class AutoGun : MonoBehaviour {

        [AutoHeader("Auto Gun")]
        public bool ignoreMe1;
        [Tooltip("The local forward of this transform is where the bullet raycast will come from")]
        public Transform shootForward;
        [Tooltip("(Optional) GrabbableHeldJoint recommended for triggering the LoadSlide event, if connected this will trigger the slide movement when shooting ")]
        public GrabbableHeldJoint slideJoint;
        [Tooltip("The place point for the ammo")]
        public PlacePoint magazinePoint;

        [AutoSmallHeader("Gun Settings")]
        public bool ignoreMe2;
        [Tooltip("The automatic fire rate while holding the trigger, 0 is semi-automatic")]
        public float automaticFireRate = 0;
        [Tooltip("The force applied to the target's rigidbody when hit")]
        public float hitForce = 2500f;
        [Tooltip("The force applied to the gun when shooting")]
        public float recoilForce = 500f;
        [Tooltip("The maximum distance a target can be hit")]
        public float maxHitDistance = 1000f;
        [Tooltip("If true the gun will hit every target until it hits a static collider")]
        public bool useBulletPenetration = false;
        [Tooltip("Whether or not the LoadSlide function needs to be called externally or if it is automatically called when the ammo is loaded")]
        public bool requireSlideLoading = true;
        [Tooltip("Whether or not the ammo clip should automatically be removed from the place point when it's empty")]
        public bool autoEjectEmptyClip = false;


        [AutoSmallHeader("Events")]
        public bool ignoreMe5;
        public UnityGunEvent OnShoot;
        public UnityGunEvent OnEmptyShoot;
        public UnityGunHitEvent OnHitEvent;
        public UnityAmmoEvent OnAmmoPlaceEvent;
        public UnityAmmoEvent OnAmmoRemoveEvent;
        public UnityGunSlideEvent OnSlideEvent;

        protected AutoAmmo loadedAmmo;
        internal Grabbable grabbable;
        protected bool slideLoaded = false;

        float lastFireTime;
        bool squeezingTrigger;
        bool lastSqueezingTrigger;

        private void Start() {
            grabbable = GetComponent<Grabbable>();
            if(magazinePoint != null)
                magazinePoint.dontAllows.Add(grabbable);

        }

        private void OnEnable() {
            if(magazinePoint != null) {
                magazinePoint.OnPlaceEvent += OnMagPlace;
                magazinePoint.OnRemoveEvent += OnMagRemove;
            }
        }
        private void OnDisable() {
            if(magazinePoint != null) {
                magazinePoint.OnPlaceEvent -= OnMagPlace;
                magazinePoint.OnRemoveEvent -= OnMagRemove;
            }
        }

        private void FixedUpdate() {
            if(squeezingTrigger && automaticFireRate > 0 && slideLoaded && Time.fixedTime-lastFireTime > automaticFireRate)
                Shoot();
            else if(squeezingTrigger && !lastSqueezingTrigger && automaticFireRate <= 0)
                Shoot();
            else if(squeezingTrigger && !lastSqueezingTrigger && automaticFireRate > 0)
                Shoot();

            lastSqueezingTrigger = squeezingTrigger;
        }


        public void PressTrigger() {
            squeezingTrigger = true;
        }


        public void ReleaseTrigger() {
            squeezingTrigger = false;
        }


        public void Shoot() {
            if(slideLoaded) {
                grabbable.body.AddForceAtPosition(-shootForward.forward * recoilForce / 10f, shootForward.position);
                grabbable.body.AddForceAtPosition(shootForward.up * recoilForce, shootForward.position);
                OnShoot?.Invoke(this);

                if(useBulletPenetration){
                    var raycasthits = Physics.RaycastAll(shootForward.position, shootForward.forward, maxHitDistance, ~0, QueryTriggerInteraction.Ignore);
                    if(raycasthits.Length > 0) {
                        foreach(var hit in raycasthits) {
                            if(hit.rigidbody != grabbable.body)
                                OnHit(hit);
                            if(hit.rigidbody == null)
                                break;
                        }
                    }
                }
                else if(Physics.Raycast(shootForward.position, shootForward.forward, out var hit, maxHitDistance, ~0, QueryTriggerInteraction.Ignore)){
                    if(hit.rigidbody != grabbable.body)
                        OnHit(hit);
                    else
                        Debug.LogError("Gun is shooting itself, make sure the shootforward transform is not inside a collider", this);
                }

                lastFireTime = Time.fixedTime;
                FireLoadSlide();
            }
            else
                OnEmptyShoot?.Invoke(this);

            if(autoEjectEmptyClip && loadedAmmo != null && loadedAmmo.currentAmmo == 0 && !slideLoaded)
                magazinePoint?.Remove();
        }





        public void LoadSlide() {
            OnSlideEvent?.Invoke(this, SlideLoadType.HandLoaded);
            slideLoaded = loadedAmmo != null && loadedAmmo.currentAmmo > 0;
            if(slideLoaded)
                loadedAmmo.RemoveAmmo();

        }


        public void FireLoadSlide() {
            OnSlideEvent?.Invoke(this, SlideLoadType.ShotLoaded);
            slideLoaded = loadedAmmo != null && loadedAmmo.currentAmmo > 0;
            if(slideLoaded)
                loadedAmmo.RemoveAmmo();

        }


        public void UnloadSlide() {
            slideLoaded = false;
        }


        public bool IsSlideLoaded() {
            return slideLoaded;
        }


        /// <summary>Returns ammo in count in current clip plus slide</summary>
        public int GetAmmo() {
            int ammo = slideLoaded ? 1 : 0;
            if(loadedAmmo != null)
                ammo += loadedAmmo.currentAmmo;
            return magazinePoint == null ? 1 : ammo;
        }


        void OnMagPlace(PlacePoint point, Grabbable mag) {
            if(mag.TryGetComponent<AutoAmmo>(out var ammo)) {
                this.loadedAmmo = ammo;
                OnAmmoPlaceEvent?.Invoke(this, loadedAmmo);
            }
            if(!slideLoaded && !requireSlideLoading)
                LoadSlide();
        }

        void OnMagRemove(PlacePoint point, Grabbable mag) {
            OnAmmoRemoveEvent?.Invoke(this, loadedAmmo);
            loadedAmmo = null;
        }

        protected virtual void OnHit(RaycastHit hit) {
            if(hit.rigidbody) {
                hit.rigidbody.AddForceAtPosition(shootForward.forward * recoilForce, hit.point);
                OnHitEvent?.Invoke(this, hit);
                if(hit.rigidbody.TryGetComponent<AutoGunTarget>(out var target))
                    target.OnShot(this, hit);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGun.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGunEffects.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d1d6fe45f7f6aed49bac268508f3a78d
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [RequireComponent(typeof(AutoGun))]
    public class AutoGunEffects : MonoBehaviour {


        [AutoSmallHeader("Visual Effects")]
        public bool ignoreMe3;
        [Tooltip("Whether or not racking the slide with a bullet already in the chamber ejects that bullet or not")]
        public bool ejectUnfiredBullet = true;
        [Tooltip("This is the unfired bullet prefab that will be instantiated and ejected if the 'ejectUnfiredBullet' value is true and the slide is racked while full")]
        public GameObject bullet;
        [Tooltip("This is the fired bullet shell prefab that will be instantiated and ejected if the when the gun is shot")]
        public GameObject bulletShell;
        [Tooltip("Particle effect that plays from the gun aim transform on shoot")]
        public ParticleSystem shootParticle;
        [Tooltip("The lifetime of the ejected bullets before they are added to the pool")]
        public float ejectedBulletLifetime = 3f;
        [Tooltip("The position and rotation where the bullets are instantiated")]
        public Transform shellEjectionSpawnPoint;
        [Tooltip("The forward direction of this point represents the direction the shells should be ejected")]
        public Transform shellEjectionDirection;
        [Tooltip("The amount of force to add to the ejected bullet")]
        public float shellEjectionForce = 50;

        [AutoSmallHeader("Sound Effects")]
        public bool ignoreMe4;
        [Tooltip("This sound will play when a bullet is fired")]
        public AudioSource shootSound;
        [Tooltip("This sound will play when a the trigger is pressed and there is nothing to shoot")]
        public AudioSource emptyShootSound;

        Dictionary<GameObject, float> bulletLifetimeTracker = new Dictionary<GameObject, float>();
        Dictionary<GameObject, float> shellLifetimeTracker = new Dictionary<GameObject, float>();
        List<GameObject> bulletPool = new List<GameObject>();
        List<GameObject> bulletShellPool = new List<GameObject>();

        List<ParticleSystem> activeParticlePool = new List<ParticleSystem>();
        List<ParticleSystem> inactiveParticlePool = new List<ParticleSystem>();
        AutoGun gun;


        private void OnEnable(){
            gun = GetComponent<AutoGun>();
            gun.OnShoot.AddListener(OnShoot);
            gun.OnEmptyShoot.AddListener(OnEmptyShoot);
            gun.OnSlideEvent.AddListener(OnSlideLoaded);
        }

        private void OnDisable(){
            gun.OnShoot.RemoveListener(OnShoot);
            gun.OnEmptyShoot.RemoveListener(OnEmptyShoot);
            gun.OnSlideEvent.RemoveListener(OnSlideLoaded);
        }

        private void FixedUpdate() {
            CheckBulletLifetime();
            CheckParticlPlaying();

        }

        void CreateShootParticle() {
            if(shootParticle != null) {
                var newShootParticle = GameObject.Instantiate(shootParticle);
                newShootParticle.transform.position = gun.shootForward.position;
                newShootParticle.transform.forward = gun.shootForward.forward;
                activeParticlePool.Add(newShootParticle);
            }
        }

        void OnShoot(AutoGun gun){
            shootSound?.PlayOneShot(shootSound.clip);
            CreateShootParticle();
        }

        void OnEmptyShoot(AutoGun gun){
            emptyShootSound?.PlayOneShot(emptyShootSound.clip);
        }

        void OnSlideLoaded(AutoGun gun, SlideLoadType loadType) {

            if(loadType == SlideLoadType.ShotLoaded){
                if(gun.slideJoint != null) {
                    if(Mathf.Abs(gun.slideJoint.xMinLimit) >= gun.slideJoint.xMaxLimit &&
                        Mathf.Abs(gun.slideJoint.yMinLimit) >= gun.slideJoint.yMaxLimit &&
                        Mathf.Abs(gun.slideJoint.zMinLimit) >= gun.slideJoint.zMaxLimit)
                        gun.slideJoint.SetJointMin();
                    else
                        gun.slideJoint.SetJointMax();
                }

                EjectShell();
            }
            else if(gun.IsSlideLoaded()) {
                EjectBullet();
            }

        }

        public void EjectBullet() {
            if(bullet != null) {
                GameObject newBullet;
                if(bulletPool.Count > 0) {
                    newBullet = bulletPool[0];
                    bulletPool.RemoveAt(0);
                    newBullet.transform.position = shellEjectionSpawnPoint.position;
                    newBullet.transform.rotation = shellEjectionSpawnPoint.rotation;
                    newBullet.SetActive(true);
                }
                else {
                    newBullet = Instantiate(bullet, shellEjectionSpawnPoint.position, shellEjectionSpawnPoint.rotation);
                }

                if(newBullet.CanGetComponent<Rigidbody>(out var body)) {
                    if(AutoHandPlayer.Instance.IsHolding(gun.grabbable))
                        body.linearVelocity = AutoHandPlayer.Instance.body.linearVelocity;
                    body.linearVelocity += gun.grabbable.body.linearVelocity;
                    body.AddForce(shellEjectionDirection.forward * shellEjectionForce, ForceMode.Force);
                }
                bulletLifetimeTracker.Add(newBullet, ejectedBulletLifetime);
            }
        }

        public void EjectShell() {
            if(bulletShell != null) {
                GameObject newShell;
                if(bulletShellPool.Count > 0) {
                    newShell = bulletShellPool[0];
                    bulletShellPool.RemoveAt(0);
                    newShell.transform.position = shellEjectionSpawnPoint.position;
                    newShell.transform.rotation = shellEjectionSpawnPoint.rotation;
                    newShell.SetActive(true);
                }
                else {
                    newShell = Instantiate(bulletShell, shellEjectionSpawnPoint.position, shellEjectionSpawnPoint.rotation);
                }

                if(newShell.CanGetComponent<Rigidbody>(out var body)) {
                    if(AutoHandPlayer.Instance.IsHolding(gun.grabbable))
                        body.linearVelocity = AutoHandPlayer.Instance.body.linearVelocity;
                    body.linearVelocity += gun.grabbable.body.linearVelocity;
                    body.AddForce(shellEjectionDirection.forward * shellEjectionForce, ForceMode.Force);

                }
                shellLifetimeTracker.Add(newShell, ejectedBulletLifetime);
            }

        }



        void CheckBulletLifetime() {
            if(bulletLifetimeTracker.Count > 0) {
                var bulletKeys = new GameObject[bulletLifetimeTracker.Count];
                bulletLifetimeTracker.Keys.CopyTo(bulletKeys, 0);
                foreach(var bullet in bulletKeys) {
                    bulletLifetimeTracker[bullet] -= Time.deltaTime;
                    if(bulletLifetimeTracker[bullet] <= 0) {
                        bullet.SetActive(false);
                        bulletPool.Add(bullet);
                        bulletLifetimeTracker.Remove(bullet);
                    }
                }
            }

            if(shellLifetimeTracker.Count > 0) {
                var shellKeys = new GameObject[shellLifetimeTracker.Count];
                shellLifetimeTracker.Keys.CopyTo(shellKeys, 0);
                foreach(var shell in shellKeys) {
                    shellLifetimeTracker[shell] -= Time.deltaTime;
                    if(shellLifetimeTracker[shell] <= 0) {
                        shell.SetActive(false);
                        bulletShellPool.Add(shell);
                        shellLifetimeTracker.Remove(shell);
                    }
                }
            }
        }



        void CheckParticlPlaying() {
            if(inactiveParticlePool.Count > 0) {
                var playingKeys = new ParticleSystem[activeParticlePool.Count];
                activeParticlePool.CopyTo(playingKeys, 0);
                foreach(var particle in playingKeys) {
                    if(!particle.isPlaying)
                        particle.gameObject.SetActive(false);
                    inactiveParticlePool.Add(particle);
                    activeParticlePool.Remove(particle);
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGunEffects.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGunTarget.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 98c232a2f70ebaf46952b97e503b6e07
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class AutoGunTarget : MonoBehaviour {
        public GameObject hitDecal;
        public ParticleSystem hitParticle;
        public float hitDecalLifetime;
        public UnityGunHitEvent OnShotEvent;


        Dictionary<GameObject, float> decalLifetimeTracker = new Dictionary<GameObject, float>();
        List<GameObject> decalPool = new List<GameObject>();
        List<ParticleSystem> inactiveParticlePool = new List<ParticleSystem>();
        List<ParticleSystem> activeParticlePool = new List<ParticleSystem>();

        public virtual void OnShot(AutoGun gun, RaycastHit hit){
            OnShotEvent?.Invoke(gun, hit);
             CreateHitParticle(hit);
            CreateHitDecal(hit);
        }

        private void FixedUpdate() {
            CheckDecalLifetime();
            CheckParticlPlaying();

        }

        void CreateHitParticle(RaycastHit hit) {
            if(hitParticle != null) { 
                var newHitParticle = GameObject.Instantiate(hitParticle);
                newHitParticle.transform.position = hit.point;
                newHitParticle.transform.forward = hit.normal;
                activeParticlePool.Add(newHitParticle);
            }
        }
        void CreateHitDecal(RaycastHit hit) {
            if(hitDecal != null) {
                var newHitDecal = GameObject.Instantiate(hitDecal);
                newHitDecal.transform.position = hit.point;
                newHitDecal.transform.forward = hit.normal;
                decalLifetimeTracker.Add(hitDecal, hitDecalLifetime);
            }
        }

        void CheckDecalLifetime() {
            if(decalLifetimeTracker.Count > 0) {
                var decalKeys = new GameObject[decalLifetimeTracker.Count];
                decalLifetimeTracker.Keys.CopyTo(decalKeys, 0);
                foreach(var decal in decalKeys) {
                    decalLifetimeTracker[decal] -= Time.deltaTime;
                    if(decalLifetimeTracker[decal] <= 0) {
                        decal.SetActive(false);
                        decalPool.Add(decal);
                        decalLifetimeTracker.Remove(decal);
                    }
                }
            }
        }


        void CheckParticlPlaying() {
            if(inactiveParticlePool.Count > 0) {
                var playingKeys = new ParticleSystem[activeParticlePool.Count];
                activeParticlePool.CopyTo(playingKeys, 0);
                foreach(var particle in playingKeys) {
                    if(!particle.isPlaying)
                        particle.gameObject.SetActive(false);
                    inactiveParticlePool.Add(particle);
                    activeParticlePool.Remove(particle);
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGunTarget.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/GrabbableHeldJoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e4313c8dbf9d16545a3263ec0411b031
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand
{
    [RequireComponent(typeof(Grabbable)), DefaultExecutionOrder(10)]
    public class GrabbableHeldJoint : MonoBehaviour
    {
        [Tooltip("The grabbable that this grabbable is connected to")]
        public Grabbable connectedGrabbable;
        [Tooltip("Offsets the center of this joint")]
        public Vector3 pivotOffset;
        [Tooltip("This will multiply the hands strength while holding this grabbable to give it more or less positional priority while holding this joint as a second hand (good to reduce when you dont want this joint having movement priority while being held)")]
        [Min(0.1f)]
        public float heldMassScale = 1f;
        [Space]
        [Tooltip("The maximum distance this joint is allowed to move in the local positive x-axis")]
        public float xMaxLimit = 0f;
        [Tooltip("The maximum distance this joint is allowed to move in the local negative x-axis")]
        public float xMinLimit = 0f;
        [Tooltip("This will force the joint back into its center position based on the given spring strength while not being held along this axis")]
        public float xSpring = 0f;
        [Space]
        [Tooltip("The maximum distance this joint is allowed to move in the local positive y-axis")]
        public float yMaxLimit = 0f;
        [Tooltip("The maximum distance this joint is allowed to move in the local negative y-axis")]
        public float yMinLimit = 0f;
        [Tooltip("This will force the joint back into its center position based on the given spring strength while not being held along this axis")]
        public float ySpring = 0f;
        [Space]
        [Tooltip("The maximum distance this joint is allowed to move in the local positive z-axis")]
        public float zMaxLimit = 0f;
        [Tooltip("The maximum distance this joint is allowed to move in the local negative z-axis")]
        public float zMinLimit = 0f;
        [Tooltip("This will force the joint back into its center position based on the given spring strength while not being held along this axis")]
        public float zSpring = 0f;

        [Space]
        [Range(0, 1), Tooltip("The percentage from the min/max distance needed to trigger the event, good for creating a buffer for the event to trigger slightly before the max range to help prevent missed event")]
        public float eventOffset = 0.05f;

        public UnityHandGrabEvent OnMinDistanceEvent;
        public UnityHandGrabEvent OnMaxDistanceEvent;

        bool triggeredMaxEvent;
        bool triggeredMinEvent;

        Vector3 handLocalPosition;
        Vector3 localPosition;
        Vector3 localTargetPosition;
        Vector3 localStartPosition;

        Grabbable grabbable;
        Vector3 localOrigin;
        Vector3 localStartOrigin;
        Hand jointHand;
        bool grabFrame;
        bool started = false;
        public void Start()
        {
            if(started)
                return;

            ResetOrigin();

            if(grabbable == null) {
                grabbable = GetComponent<Grabbable>();
                grabbable.OnGrabEvent += OnGrabbed;
                grabbable.OnReleaseEvent += OnReleased;
            }
            grabbable.singleHandOnly = true;

            if(xMinLimit == 0 && yMinLimit == 0 && zMinLimit == 0)
                triggeredMinEvent = true;
            started = true;
        }

        public void ResetOrigin()
        {
            localOrigin = connectedGrabbable.rootTransform.InverseTransformPoint(transform.position) + pivotOffset;
            localStartOrigin = localOrigin;
        }

        internal void OnGrabbed(Hand hand, Grabbable grab)
        {
            jointHand = hand;
            hand.handFollow.minMass *= heldMassScale;
            hand.handFollow.maxMass *= heldMassScale;

            localOrigin = hand.heldJoint.connectedAnchor + pivotOffset;
            localTargetPosition = new Vector3(
                Mathf.Clamp(handLocalPosition.x, localOrigin.x + xMinLimit, localOrigin.x + xMaxLimit),
                Mathf.Clamp(handLocalPosition.y, localOrigin.y + yMinLimit, localOrigin.y + yMaxLimit),
                Mathf.Clamp(handLocalPosition.z, localOrigin.z + zMinLimit, localOrigin.z + zMaxLimit)
            );

            localTargetPosition += pivotOffset;
            grabFrame = true;
        }

        void OnReleased(Hand hand, Grabbable grab)
        {
            jointHand = null;
            hand.handFollow.minMass /= heldMassScale;
            hand.handFollow.maxMass /= heldMassScale;

            localOrigin = localStartOrigin;
        }

        private void FixedUpdate()
        {
            if(grabFrame) {
                grabFrame = false;
                return;
            }

            UpdateJoint();
        }

        public void SetJointMax() {
            transform.position = connectedGrabbable.rootTransform.TransformPoint(localOrigin + pivotOffset + new Vector3(xMaxLimit, yMaxLimit, zMaxLimit));
        }

        public void SetJointMin() {
            transform.position = connectedGrabbable.rootTransform.TransformPoint(localOrigin + pivotOffset + new Vector3(xMinLimit, yMinLimit, zMinLimit));
        }

        public void UpdateJoint()
        {
            if (connectedGrabbable.HeldCount() > 0 && grabbable.HeldCount(false, false, true) > 0 && jointHand != null)
            {
                handLocalPosition = jointHand.heldJoint.connectedBody.transform.InverseTransformPoint(jointHand.moveTo.position) + pivotOffset;
                localPosition = jointHand.heldJoint.connectedAnchor + pivotOffset;
                localTargetPosition = new Vector3(
                    Mathf.MoveTowards(localPosition.x, Mathf.Clamp(handLocalPosition.x, localOrigin.x + xMinLimit, localOrigin.x + xMaxLimit), 1f),
                    Mathf.MoveTowards(localPosition.y, Mathf.Clamp(handLocalPosition.y, localOrigin.y + yMinLimit, localOrigin.y + yMaxLimit), 1f),
                    Mathf.MoveTowards(localPosition.z, Mathf.Clamp(handLocalPosition.z, localOrigin.z + zMinLimit, localOrigin.z + zMaxLimit), 1f)
                );

                if(localPosition != localTargetPosition) {
                    //Vector3 globalTargetPosition = connectedGrabbable.rootTransform.TransformPoint(localTargetPosition - jointHand.handGrabPoint.localPosition);
                    transform.localPosition += (localTargetPosition - localPosition); // Adjusting position with pivot offset
                    transform.localPosition = new Vector3(
                        Mathf.Clamp(transform.localPosition.x, localStartOrigin.x + xMinLimit, localStartOrigin.x + xMaxLimit),
                        Mathf.Clamp(transform.localPosition.y, localStartOrigin.y + yMinLimit, localStartOrigin.y + yMaxLimit),
                        Mathf.Clamp(transform.localPosition.z, localStartOrigin.z + zMinLimit, localStartOrigin.z + zMaxLimit)
                    );
                    jointHand.heldJoint.connectedAnchor += (localTargetPosition - localPosition);
                    jointHand.handGrabPoint.localPosition += (localTargetPosition - localPosition);
                }
            }
            else
            {
                Vector3 localPosition = connectedGrabbable.transform.InverseTransformPoint(transform.position) + pivotOffset;
                Vector3 localTargetPosition = new Vector3(
                    Mathf.MoveTowards(localPosition.x, localOrigin.x, Time.fixedDeltaTime * xSpring),
                    Mathf.MoveTowards(localPosition.y, localOrigin.y, Time.fixedDeltaTime * ySpring),
                    Mathf.MoveTowards(localPosition.z, localOrigin.z, Time.fixedDeltaTime * zSpring)
                );

                if(transform.localPosition != localOrigin)
                    transform.position = connectedGrabbable.rootTransform.TransformPoint(localTargetPosition);
            }
                    
            if(OnMaxDistanceEvent != null) {
                var localPos = connectedGrabbable.rootTransform.InverseTransformPoint(transform.position);
                bool greaterOrEqual =
                    localPos.x >= localStartOrigin.x + xMaxLimit - xMaxLimit * eventOffset - 0.001f &&
                    localPos.y >= localStartOrigin.y + yMaxLimit - yMaxLimit * eventOffset - 0.001f &&
                    localPos.z >= localStartOrigin.z + zMaxLimit - zMaxLimit * eventOffset - 0.001f; 

                if(greaterOrEqual && !triggeredMaxEvent) {
                    OnMaxDistanceEvent.Invoke(jointHand, connectedGrabbable);
                    triggeredMaxEvent = true;
                    triggeredMinEvent = false;
                }
            }

            if(OnMinDistanceEvent != null) {
                var localPos = connectedGrabbable.rootTransform.InverseTransformPoint(transform.position);
                bool lessOrEqual =
                    localPos.x <= localStartOrigin.x + xMinLimit - xMinLimit * eventOffset + 0.001f &&
                    localPos.y <= localStartOrigin.y + yMinLimit - yMinLimit * eventOffset + 0.001f &&
                    localPos.z <= localStartOrigin.z + zMinLimit - zMinLimit * eventOffset + 0.001f;

                if(lessOrEqual && !triggeredMinEvent) {
                    OnMinDistanceEvent.Invoke(jointHand, connectedGrabbable);
                    triggeredMinEvent = true;
                    triggeredMaxEvent = false;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/GrabbableHeldJoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/GrabbablePoseAnimaion.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5e0938fd494e5f74da83d0fe188a5ac1
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public enum HeldAnimationDriver {
        squeeze,
        grip,
        custom
    }

    [DefaultExecutionOrder(100000)]
    public class GrabbablePoseAnimaion : MonoBehaviour {
        public AnimationCurve animationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);
        [Tooltip("Determines the default hand value to activate this pose while it's being held")]
        public HeldAnimationDriver animationDriver = HeldAnimationDriver.squeeze;

        [NaughtyAttributes.ShowIf("animationDriver", HeldAnimationDriver.custom)]
        public float customValue;
        [Space]
        [Tooltip("The pose the hand will have by default")]
        public GrabbablePose fromPose;
        [Tooltip("The pose the hand will move to match given the animation driver value")]
        public GrabbablePose toPose;
        [Tooltip("Additional animations to run alongside the given driver value (good for things like a gun trigger that is separate from the hand but still needs to move with the hand during the animation)")]
        public AutoAnimation[] additionalAnimations;
        [Space]
        [Tooltip("The weight of the index finger in the animation - 0 means the finger will not animate, 1 means it will animate fully")]
        public float indexWeight = 1;
        [Tooltip("The weight of the middle finger in the animation - 0 means the finger will not animate, 1 means it will animate fully")]
        public float middleWeight = 1;
        [Tooltip("The weight of the ring finger in the animation - 0 means the finger will not animate, 1 means it will animate fully")]
        public float ringWeight = 1;
        [Tooltip("The weight of the pinky finger in the animation - 0 means the finger will not animate, 1 means it will animate fully")]
        public float pinkyWeight = 1;
        [Tooltip("The weight of the thumb finger in the animation - 0 means the finger will not animate, 1 means it will animate fully")]
        public float thumbWeight = 1;
        [Space]
        [Tooltip("The strength of the hand position lerping between the two poses")]
        public float handPositionWeight = 0;
        [Tooltip("The strength of the hand rotation lerping between the two poses")]
        public float handRotationWeight = 0;

        [Space]

        HandPoseData fromPoseData, toPoseData;
        HandPoseData _currentAnimationPose;

        float[] fingerWeights;

        public ref HandPoseData currentAnimationPose { get { return ref _currentAnimationPose; } }
        int lastPosingHandsCount;

        Dictionary<Hand, bool> trackWasIKEnabled = new Dictionary<Hand, bool>();

        private void OnEnable() {
            fingerWeights = new float[5];
            fingerWeights[(int)FingerEnum.index] = indexWeight;
            fingerWeights[(int)FingerEnum.middle] = middleWeight;
            fingerWeights[(int)FingerEnum.ring] = ringWeight;
            fingerWeights[(int)FingerEnum.pinky] = pinkyWeight;
            fingerWeights[(int)FingerEnum.thumb] = thumbWeight;

            if(fromPose.rightPoseSet)
                currentAnimationPose = new HandPoseData(ref fromPose.rightPose);
            else if(fromPose.leftPoseSet)
                currentAnimationPose = new HandPoseData(ref fromPose.leftPose);

            trackWasIKEnabled = new Dictionary<Hand, bool>();

        }



        public void LateUpdate() {
            var posingHandCount = fromPose.posingHands.Count + toPose.posingHands.Count;
            if(posingHandCount == 0)
                return;

            foreach(var hand in fromPose.posingHands) {
                if(hand.IsGrabbing())
                    continue;
                Animate(hand);
            }
            foreach(var hand in toPose.posingHands) {
                if(hand.IsGrabbing())
                    continue;
                Animate(hand);
            }

            if(lastPosingHandsCount != 0 && posingHandCount == 0)
                foreach(var autoAnim in additionalAnimations)
                    autoAnim.SetAnimation(0);

            lastPosingHandsCount = posingHandCount;

        }   

        public void Animate(Hand hand) {
            fromPoseData = fromPose.GetHandPoseData(hand);
            toPoseData = toPose.GetHandPoseData(hand);
            var animationValue = GetAnimationValue(hand);

            foreach(var finger in hand.fingers) {
                var fingerIndex = (int)finger.fingerType;
                if(fingerWeights[fingerIndex] == 0)
                    continue;

                currentAnimationPose.fingerPoses[fingerIndex].LerpData(ref fromPoseData.fingerPoses[fingerIndex], ref toPoseData.fingerPoses[fingerIndex], fingerWeights[fingerIndex] * animationValue);
                currentAnimationPose.fingerPoses[fingerIndex].SetFingerPose(finger);
            }

            if(handPositionWeight != 0 || handRotationWeight != 0) {
                currentAnimationPose.handOffset = Vector3.Lerp(fromPoseData.handOffset, toPoseData.handOffset, animationValue * handPositionWeight);
                currentAnimationPose.localQuaternionOffset = Quaternion.Lerp(fromPoseData.localQuaternionOffset, toPoseData.localQuaternionOffset, animationValue * handRotationWeight);
                hand.handGrabPoint.localRotation = currentAnimationPose.localQuaternionOffset;
                hand.handGrabPoint.localPosition = currentAnimationPose.handOffset;
            }

            foreach(var autoAnim in additionalAnimations)
                autoAnim.SetAnimation(animationCurve.Evaluate(animationValue));

            float GetAnimationValue(Hand hand1) {
                if(animationDriver == HeldAnimationDriver.squeeze)
                    return hand1.GetSqueezeAxis();
                else if(animationDriver == HeldAnimationDriver.grip)
                    return hand1.GetGripAxis();
                else if(animationDriver == HeldAnimationDriver.custom)
                    return customValue;

                return 0;
            }

        }



        public void Animate(Hand hand, float value) {
            HandPoseData.LerpPose(ref currentAnimationPose, ref fromPose.GetHandPoseData(hand), ref toPose.GetHandPoseData(hand), value);
            currentAnimationPose.handOffset = Vector3.Lerp(fromPoseData.handOffset, toPoseData.handOffset, value);
            currentAnimationPose.localQuaternionOffset = Quaternion.Lerp(fromPoseData.localQuaternionOffset, toPoseData.localQuaternionOffset, value);
            currentAnimationPose.SetPose(hand);
        }
    }

}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/GrabbablePoseAnimaion.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/HeldPlaceJoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 37ad27b092cab5640be450a446fb23b8
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HeldPlaceJoint : PlacePoint {

        [AutoHeader("Held Place Joint")]
        public bool ignoreMe1;
        public Grabbable connectedGrabbable;
        public Vector3 pivotOffset;
        public float heldMassScale = 1f;
        [Space]
        public float xMaxLimit = 0f;
        public float xMinLimit = 0f;
        public float xSpring = 0f;
        [Space]
        public float yMaxLimit = 0f;
        public float yMinLimit = 0f;
        public float ySpring = 0f;
        [Space]
        public float zMaxLimit = 0f;
        public float zMinLimit = 0f;
        public float zSpring = 0f;

        [Space]
        [Range(0, 1), Tooltip("The percentage from the min/max distance needed to trigger the event, good for creating a buffer for the event to trigger slightly before the max range to help prevent missed event")]
        public float eventOffset = 0.05f;
        public UnityHandGrabEvent OnMinDistanceEvent;
        public UnityHandGrabEvent OnMaxDistanceEvent;

        GrabbableHeldJoint heldJoint = null;


        protected  void Start() {
            //base.Start();
            //heldPlaceOnly = true;
            disableRigidbodyOnPlace = false;
            parentOnPlace = true;
            forceHandRelease = false;
            makePlacedKinematic = false;
            forcePlace = true;
            
        }

        public override bool CanPlace(Grabbable placeObj, bool checkRoot = true) {
            if(placeObj.body == connectedGrabbable.body)
                return false;

            return base.CanPlace(placeObj);
        }


        public override void Place(Grabbable placeObj) {

            Debug.Log("Place");
            Dictionary<Hand, Transform> grabPoint = new Dictionary<Hand, Transform>();
            var hands = new Hand[(placeObj.GetHeldBy().Count)];
            placeObj.GetHeldBy().CopyTo(hands, 0);

            placeObj.transform.position = placedOffset.position;
            placeObj.transform.rotation = placedOffset.rotation;

            foreach(var hand in hands) {
                grabPoint.Add(hand, hand.handGrabPoint);
            }

            base.Place(placeObj);

            foreach(var hand in hands) {
                //hand.BreakGrabConnection();
                //hand.CreateGrabConnection(placeObj, grabPoint[hand].position, grabPoint[hand].rotation, placeObj.transform.position, placeObj.transform.rotation, true);
                hand.heldJoint.connectedBody = connectedGrabbable.body;
                hand.heldJoint.connectedAnchor = connectedGrabbable.body.transform.InverseTransformPoint(hand.handGrabPoint.position);
            }

            placeObj.DeactivateRigidbody();
            placeObj.transform.parent = connectedGrabbable.body.transform;
            placeObj.body = connectedGrabbable.body;

            if(heldJoint == null) {
                heldJoint = placeObj.gameObject.AddComponent<GrabbableHeldJoint>();
                heldJoint.connectedGrabbable = connectedGrabbable;
                heldJoint.xMaxLimit = xMaxLimit;
                heldJoint.xMinLimit = xMinLimit;
                heldJoint.xSpring = xSpring;

                heldJoint.yMaxLimit = yMaxLimit;
                heldJoint.yMinLimit = yMinLimit;
                heldJoint.ySpring = ySpring;

                heldJoint.zMaxLimit = zMaxLimit;
                heldJoint.zMinLimit = zMinLimit;
                heldJoint.zSpring = zSpring;

                heldJoint.eventOffset = eventOffset;
                heldJoint.OnMaxDistanceEvent = OnMaxDistanceEvent;
                heldJoint.OnMinDistanceEvent = OnMinDistanceEvent;
                heldJoint.Start();
                if(hands.Length > 0)
                    heldJoint.OnGrabbed(hands[0], placeObj);

                heldJoint.UpdateJoint();
            }
        }

        public override void Remove(Grabbable placeObj) {
            Debug.Log("Remove");
            if(heldJoint != null) {
                Destroy(heldJoint);
                heldJoint = null;
            }

            base.Remove(placeObj);

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/HeldPlaceJoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/PlaceJoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b38d62fde75c6ff4ba1f4742da2c3d3a
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class PlaceJoint : PlacePoint {
        [Tooltip("This is for connecting grabbables together, leave empty if using a static")]
        public Grabbable localGrabbable;
        public Rigidbody localRigidbody;
        public Vector3 anchor;
        public Vector3 axis = Vector3.right;
        public bool autoConfigureConnection = true;
        public Vector3 connectedAnchor;
        public Vector3 secondaryAxis = Vector3.up;
        public ConfigurableJointMotion xMotion, yMotion, zMotion;
        public ConfigurableJointMotion angularXMotion, angularYMotion, angularZMotion;
        [SerializeField]
        public SerializedSoftJointLimitSpring linearLimitSpring;
        [SerializeField]
        public SerializedSoftJointLimit linearLimit;
        [SerializeField]
        public SerializedSoftJointLimitSpring angularXLimitSpring;
        public SerializedSoftJointLimit lowAngularXLimit;
        public SerializedSoftJointLimit highAngularXLimit;
        public SerializedSoftJointLimitSpring angularYZLimitSpring;
        public SerializedSoftJointLimit angularYLimit;
        public SerializedSoftJointLimit angularZLimit;
        public Vector3 targetPosition;
        public Vector3 targetVelocity;
        public SerializedJointDrive xDrive;
        public SerializedJointDrive yDrive;
        public SerializedJointDrive zDrive;
        public Vector3 targetAngularVelocity;
        public RotationDriveMode rotationDriveMode;
        public SerializedJointDrive angularXDrive;
        public SerializedJointDrive angularYZDrive;
        public SerializedJointDrive slerpDrive;
        public JointProjectionMode projectionMode = JointProjectionMode.PositionAndRotation;
        public float projectionDistance = 0f;
        public float projectionAngle = 0;
        public bool configuredInWorldSpace;
        public bool swapBodies;


        public bool enableCollision = false;
        public bool enablePreprocessing = true;
        public float breakForce = float.PositiveInfinity;
        public float breakTorque = float.PositiveInfinity;
        public float massScale = 1;
        public float connectedMassScale = 1;
        [Range(1, 255), Tooltip("The solver iterations to use while a placeJoint is connected, higher is higher quality joint stability but more expensive 1-255")]
        public int solverIterations = 100;
        [Range(1, 255), Tooltip("The velocity solver iterations to use while a placeJoint is connected, higher is higher quality joint stability but more expensive 1-255")]
        public int velocitySolverIterations = 100;

        Quaternion targetRotation = Quaternion.identity;
        ConfigurableJoint connectionJoint = null;

        Vector3 prePlacedPos;
        Quaternion prePlacedRot;


        protected void Start() {
            //base.Start();
            base.makePlacedKinematic = false;
            base.placedJointLink = null;
        }
        public override void Highlight(Grabbable placeObj) {
            base.Highlight(placeObj);
        }

        public override bool CanPlace(Grabbable placeObj, bool checkRoot = true) {
            return base.CanPlace(placeObj) && placeObj.body != localRigidbody;
        }

        //protected override void OnEnable() {
        //    base.OnEnable();
        //    if(localGrabbable != null)
        //        localGrabbable.OnReleaseEvent += OnReleased;
        //}

        //protected override void OnDisable() {
        //    base.OnDisable();
        //    if(localGrabbable != null)
        //        localGrabbable.OnReleaseEvent -= OnReleased;
        //}
        //void OnReleased(Hand hand, Grabbable grab) {
        //    if(localGrabbable != null) {
        //        Remove();
        //    }
        //}

        public override void Place(Grabbable placeObj) {
            prePlacedPos = placeObj.transform.position;
            prePlacedRot = placeObj.transform.rotation;

            base.Place(placeObj);
            if(connectionJoint == null && placedObject != null) {
                CreateConnection(placeObj);
            }

            if(localGrabbable) {
                if (localGrabbable.body != null)
                {
                    localGrabbable.body.linearVelocity = Vector3.zero;
                    localGrabbable.body.angularVelocity = Vector3.zero;
                }
                for(int i = 0; i < localGrabbable.jointedBodies.Count; i++) {
                    localGrabbable.jointedBodies[i].linearVelocity = Vector3.zero;
                    localGrabbable.jointedBodies[i].angularVelocity = Vector3.zero;
                }
            }

        }

        private void FixedUpdate() {
            if(placedObject != null) {
                if(connectionJoint == null)
                    Remove(placedObject);
            }
        }


        
        public override void Remove(Grabbable placeObj) {
            if(localGrabbable != null && localGrabbable.body != null)
                localGrabbable.RemoveJointedBody(placeObj.body);
            placeObj.RemoveJointedBody(localRigidbody);

            if(connectionJoint != null) {
                Destroy(connectionJoint);
                connectionJoint = null;
            }

            localRigidbody.solverIterations = Physics.defaultSolverIterations;
            localRigidbody.solverVelocityIterations = Physics.defaultSolverVelocityIterations;
            base.Remove(placeObj);

        }

        Vector3 pregrabPos;
        Quaternion pregrabRot;
        public void CreateConnection(Grabbable connection) {
            if(localRigidbody != null) {
                connection.AddJointedBody(localRigidbody);
                if(localGrabbable != null && localGrabbable.body != null)
                    localGrabbable.AddJointedBody(connection.body);
            }

            localRigidbody.solverIterations = solverIterations;
            localRigidbody.solverVelocityIterations = velocitySolverIterations;
            connectionJoint = connection.gameObject.AddComponent<ConfigurableJoint>();
            connectionJoint.connectedBody = localRigidbody;
            connectionJoint.anchor = anchor;
            connectionJoint.axis = axis;
            connectionJoint.autoConfigureConnectedAnchor = false;
            connectionJoint.connectedAnchor = Vector3.zero;
            connectionJoint.secondaryAxis = secondaryAxis;
            connectionJoint.xMotion = xMotion;
            connectionJoint.yMotion = yMotion;
            connectionJoint.zMotion = zMotion;
            connectionJoint.angularXMotion = angularXMotion;
            connectionJoint.angularYMotion = angularYMotion;
            connectionJoint.angularZMotion = angularZMotion;
            connectionJoint.linearLimitSpring = linearLimitSpring;
            connectionJoint.linearLimit = linearLimit;
            connectionJoint.angularXLimitSpring = angularXLimitSpring;
            connectionJoint.lowAngularXLimit = lowAngularXLimit;
            connectionJoint.highAngularXLimit = highAngularXLimit;
            connectionJoint.angularYZLimitSpring = angularYZLimitSpring;
            connectionJoint.angularYLimit = angularYLimit;
            connectionJoint.angularZLimit = angularZLimit;
            connectionJoint.targetPosition = targetPosition;
            connectionJoint.targetVelocity = targetVelocity;
            connectionJoint.xDrive = xDrive;
            connectionJoint.yDrive = yDrive;
            connectionJoint.zDrive = zDrive;
            connectionJoint.targetAngularVelocity = targetAngularVelocity;
            connectionJoint.rotationDriveMode = rotationDriveMode;
            connectionJoint.angularXDrive = angularXDrive;
            connectionJoint.angularYZDrive = angularYZDrive;
            connectionJoint.slerpDrive = slerpDrive;
            connectionJoint.projectionMode = projectionMode;
            connectionJoint.projectionDistance = projectionDistance;
            connectionJoint.projectionAngle = projectionAngle;
            connectionJoint.configuredInWorldSpace = configuredInWorldSpace;
            connectionJoint.swapBodies = swapBodies;
            connectionJoint.enableCollision = enableCollision;
            connectionJoint.enablePreprocessing = enablePreprocessing;
            connectionJoint.breakForce = breakForce;
            connectionJoint.breakTorque = breakTorque;
            connectionJoint.massScale = massScale;
            connectionJoint.connectedMassScale = connectedMassScale;
        }


        public void Destroyjoint()
        {
            if (connectionJoint != null)
            {
                Destroy(connectionJoint);
                if (localGrabbable != null)
                    localGrabbable.RemoveJointedBody(placedObject.body);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/PlaceJoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/BowlingManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d7e43f3b6c658e442868b907c090b2de
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BowlingManager : MonoBehaviour
{
    [Header("Bowling Ball Settings")]
    public GameObject bowlingBall;

    [Header("Bowling Pin Settings")]
    public Vector3 pinCenter;
    public float pinSpaceX;
    public float pinSpaceZ;

    public List<GameObject> pins = new List<GameObject>();

    public Vector3 ballPosition;
    private void Start()
    {
        ballPosition = bowlingBall.transform.position;
        ResetPins();
    }

    public void ResetBall()
    {
        bowlingBall.GetComponent<Rigidbody>().isKinematic = true;
        bowlingBall.transform.position = ballPosition;
        bowlingBall.GetComponent<Rigidbody>().isKinematic = false;
    }

    public void ResetPins()
    {
        int max = (pins.Count / 2) - 2;
        int topRow = (pins.Count / 2) - 2; ;
        int row = 0;

        float currentX = pinCenter.x;
        float currentZ = pinCenter.z;

        for (int i = 0; i < pins.Count; i++)
        {
            pins[i].GetComponent<Rigidbody>().isKinematic = true;

            pins[i].transform.rotation = Quaternion.Euler(0, 0, 0);
            pins[i].transform.position = new Vector3(currentX, pinCenter.y, currentZ);

            pins[i].GetComponent<Rigidbody>().isKinematic = false;

            currentZ += pinSpaceZ;

            if (row == topRow)
            {
                topRow--;
                row = 0;

                currentZ = pinCenter.z + ((pinSpaceZ / 2) * (max - topRow));
                currentX = pinCenter.x + (pinSpaceX * (max - topRow));
            }
            else
            {
                row++;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/BowlingManager.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/BoxingGlove.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7c3f28cbd7ab11d44be4bb0f35e485c3
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {
    public class BoxingGlove : MonoBehaviour {
        public Rigidbody body;
        public float power = 2f;

        float lastHitTime;
        float delay = 1f;

        public void OnCollisionEnter(Collision collision) {
            if(lastHitTime + delay < Time.fixedTime) {
                collision.rigidbody?.AddForce(body.linearVelocity * power);
                lastHitTime = Time.fixedTime;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/BoxingGlove.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Briefcase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bcba248aa04eb1e46ac301e7773478b6
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Briefcase : MonoBehaviour
{
    public Grabbable grabbable;
    public Transform openCloseTransform;

    public float openCloseSpeed = 1;
    public AnimationCurve openCloseCurve;

    public float openAngle = 110;
    public float closeAngle = -10;

    bool isOpen = true;
    float openCloseState = 1;

    Vector3 targetOpenRotation;
    Vector3 targetCloseRotation;


    private void OnEnable() {
        targetOpenRotation = new Vector3(openAngle, 0, 0);
        targetCloseRotation = new Vector3(closeAngle, 0, 0);
        openCloseState = isOpen ? 1 : 0;
        openCloseTransform.localRotation = Quaternion.Euler(Vector3.Lerp(targetCloseRotation, targetOpenRotation, openCloseCurve.Evaluate(openCloseState)));
    }

    public void Open() {
        isOpen = true;
    }

    public void Close() {
        isOpen = false;
    }


    void Update() {
        if(isOpen && openCloseState < 1) {
            openCloseState += Time.deltaTime * openCloseSpeed;
            openCloseState = Mathf.Clamp01(openCloseState);
            openCloseTransform.localRotation = Quaternion.Euler(Vector3.Lerp(targetCloseRotation, targetOpenRotation, openCloseCurve.Evaluate(openCloseState)));
            if(openCloseState >= 1) {
                OnOpen();
            }
        }
        else if(!isOpen && openCloseState > 0) {
            openCloseState -= Time.deltaTime * openCloseSpeed;
            openCloseState = Mathf.Clamp01(openCloseState);
            openCloseTransform.localRotation = Quaternion.Euler(Vector3.Lerp(targetCloseRotation, targetOpenRotation, openCloseCurve.Evaluate(openCloseState)));
            if(openCloseState <= 0) {
                OnClose();
            }
        }
    }


    public void OnOpen() {
        foreach(var placepoint in grabbable.childPlacePoints) {
            placepoint.enabled = true;
        }
    }


    public void OnClose() {
        foreach(var placepoint in grabbable.childPlacePoints) {
            placepoint.enabled = false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Briefcase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/CubeBreak.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a929b8a9aed45794ca106c9d0498b3b2
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;

namespace Autohand.Demo{
    public class CubeBreak : MonoBehaviour{
        public float force = 10f;
        Vector3[] offsets = { new Vector3(0.25f, 0.25f, 0.25f), new Vector3(-0.25f, 0.25f, 0.25f), new Vector3(0.25f, 0.25f, -0.25f), new Vector3(-0.25f, 0.25f, -0.25f),
                            new Vector3(0.25f, -0.25f, 0.25f), new Vector3(-0.25f, -0.25f, 0.25f), new Vector3(0.25f, -0.25f, -0.25f), new Vector3(-0.25f, -0.25f, -0.25f),};
        [ContextMenu("Break")]
        public void Break() {
            for(int i = 0; i < 8; i++) {
                var smallerCopy = Instantiate(gameObject, transform.position, transform.rotation);
                foreach(var joint in smallerCopy.GetComponents<FixedJoint>()) {
                    Destroy(joint);
                }
                try{
                    smallerCopy.transform.parent = transform;
                }
                catch { }
                smallerCopy.transform.localPosition += offsets[i];
                smallerCopy.transform.parent = null;
                smallerCopy.transform.localScale = transform.localScale/2f;
                smallerCopy.layer = LayerMask.NameToLayer(Hand.grabbableLayerNameDefault);
                var body = smallerCopy.GetComponent<Rigidbody>();
                body.ResetCenterOfMass();
                body.ResetInertiaTensor();
                body.linearVelocity = GetComponent<Rigidbody>().linearVelocity;
                body.AddRelativeForce(transform.rotation*(offsets[i]*force), ForceMode.Impulse);
                body.AddRelativeTorque(transform.rotation*(offsets[i]*force + Vector3.one*(Random.value/3f)), ForceMode.Impulse);
                body.mass /= 2;
                smallerCopy.GetComponent<Grabbable>().jointBreakForce /= 2;
                if(smallerCopy.transform.localScale.x < 0.03f)
                    smallerCopy.GetComponent<Grabbable>().singleHandOnly = true;
            }
            Destroy(gameObject);
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/CubeBreak.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/DemoExitCondition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5b27bab7ee6c6804abfd2d9685544d01
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class DemoExitCondition : MonoBehaviour
{
    void Update(){
        if (Input.GetKeyDown(KeyCode.Space)){
            SceneManager.LoadScene(SceneManager.GetActiveScene().name);
        }
        if (Input.GetKeyDown(KeyCode.Escape)){
            Application.Quit();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/DemoExitCondition.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/DemoFlyingToggle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c012a21fdec3be0429e787f0e12bebd5
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {
    public class DemoFlyingToggle : MonoBehaviour {
        public void ToggleFlying() {
            AutoHandPlayer.Instance.ToggleFlying();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/DemoFlyingToggle.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Door.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a9e9c10705da8584586d2507228a934e
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand.Demo{
    public class Door : PhysicsGadgetHingeAngleReader
    {
        [Header("Door should start closed")]
        public Rigidbody body;
        Vector3 closedPosition;
        Quaternion closedRotation;
        
        [Tooltip("The door needs to reach this level of open before it can be reset")]
        public float minThreshold = 0.05f;
        public float midThreshold = 0.05f;
        [Tooltip("The door needs to reach this level of open before it can be reset")]
        public float maxThreshold = 0.05f;
        [Space]
        public UnityEvent OnMax;
        public UnityEvent OnMid;
        public UnityEvent OnMin;
        
        bool min = false;
        bool max = false;
        bool mid = true;

        private void Awake(){
            if(!body && GetComponent<Rigidbody>())
                body = GetComponent<Rigidbody>();
            
            closedPosition = transform.position;
            closedRotation = transform.rotation;
        }

        protected void FixedUpdate(){
            if(!max && mid && GetValue()+maxThreshold >= 1) {
                Max();
            }

            if(!min && mid && GetValue()-minThreshold <= -1){
                Min();
            }
        
            if (GetValue() <= midThreshold && max && !mid) {
                Mid();
            }

            if (GetValue() >= -midThreshold && min && !mid) {
                Mid();
            }
        }


        void Max(){
            mid = false;
            max = true;
            OnMax?.Invoke();
        }

        void Mid(){
            min = false;
            max = false;
            mid = true;
            OnMid?.Invoke();
        }

        void Min() {
            min = true;
            mid = false;
            OnMin?.Invoke();
        }

        public void ClosedDoor() {
            transform.position = closedPosition;
            transform.rotation = closedRotation;
            if(body.collisionDetectionMode == CollisionDetectionMode.ContinuousDynamic)
                body.collisionDetectionMode = CollisionDetectionMode.Continuous;
            body.isKinematic = true;
        }

        private void OnDrawGizmosSelected() {
            if(!body && GetComponent<Rigidbody>())
                body = GetComponent<Rigidbody>();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Door.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ExplosionSource.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4757631d9b63da44ba986db68e9cd6d5
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;

namespace Autohand.Demo{
    public class ExplosionSource : MonoBehaviour{
        public float radius = 1;
        public float force = 10;

        public void Explode(bool destroy) {
            var hits = Physics.OverlapSphere(transform.position, radius);
            foreach(var hit in hits) {
                var rb = hit.GetComponent<Rigidbody>();
                if(rb != null)
                    rb.AddExplosionForce(force, transform.position, radius);
            }
            if(destroy)
                Destroy(gameObject);
        }

        private void OnDrawGizmosSelected() {
            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(transform.position, radius);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ExplosionSource.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Grenade.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4249cc9f1f9401b48af7156044fcd45d
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand.Demo {
    public class Grenade : MonoBehaviour {
        public Grabbable grenade;
        public Grabbable pin;
        public ConfigurableJoint pinJoint;
        public float explosionDelay = 2;
        public bool startDelayOnRelease = false;
        public float explosionForce = 100;
        public float explosionRadius = 10;
        public float pinJointStrength = 750f;
        public GameObject explosionEffect;
        public UnityEvent pinBreakEvent;
        public UnityEvent explosionEvent;

        private void OnEnable() {
            pin.isGrabbable = false;
            grenade.OnGrabEvent += OnGrenadeGrab;
            grenade.OnReleaseEvent += OnGrenadeRelease;
            pin.OnGrabEvent += OnPinGrab;
            pin.OnReleaseEvent += OnPinRelease;
            if(!grenade.jointedBodies.Contains(pin.body))
                grenade.jointedBodies.Add(pin.body);
            if(!pin.jointedBodies.Contains(grenade.body))
                pin.jointedBodies.Add(grenade.body);
        }

        private void OnDisable() {
            grenade.OnGrabEvent -= OnGrenadeGrab;
            grenade.OnReleaseEvent -= OnGrenadeRelease;
            pin.OnGrabEvent -= OnPinGrab;
            pin.OnReleaseEvent -= OnPinRelease;
        }

        void OnGrenadeGrab(Hand hand, Grabbable grab) {
            if(pinJoint != null) {
                pin.isGrabbable = true;
            }
        }

        void OnGrenadeRelease(Hand hand, Grabbable grab) {
            if(pinJoint != null) {
                pin.isGrabbable = false;
            }
            if(grenade != null && startDelayOnRelease)
                Invoke("CheckJointBreak", explosionDelay + Time.fixedDeltaTime * 3);

        }
        void OnPinGrab(Hand hand, Grabbable grab) {
            if(pinJoint != null) {
                pinJoint.breakForce = pinJointStrength;
            }
        }

        void OnPinRelease(Hand hand, Grabbable grab) {
            if(pinJoint != null) {
                pinJoint.breakForce = 100000;
            }

        }

        private void OnJointBreak(float breakForce) {
            Invoke("CheckJointBreak", Time.fixedDeltaTime*2);
        }

        void CheckJointBreak() {
            if(pinJoint == null) {
                pin.maintainGrabOffset = false;
                pin.RemoveJointedBody(grenade.body);
                grenade.RemoveJointedBody(pin.body);
                if(!startDelayOnRelease)
                    Invoke("Explode", explosionDelay);
            }

        }
        
        void Explode() {
            var hits = Physics.OverlapSphere(grenade.transform.position, explosionRadius);
            foreach(var hit in hits) {
                if(AutoHandPlayer.Instance.body == hit.attachedRigidbody) {
                    AutoHandPlayer.Instance.DisableGrounding(0.05f);
                    var dist = Vector3.Distance(hit.attachedRigidbody.position, grenade.transform.position);
                    explosionForce *= 2;
                    hit.attachedRigidbody.AddExplosionForce(explosionForce - explosionForce * (dist / explosionRadius), grenade.transform.position, explosionRadius);
                    explosionForce /= 2;
                }
                if(hit.attachedRigidbody != null) {
                    var dist = Vector3.Distance(hit.attachedRigidbody.position, grenade.transform.position);
                    hit.attachedRigidbody.AddExplosionForce(explosionForce - explosionForce * (dist / explosionRadius), grenade.transform.position, explosionRadius);
                }
            }
            explosionEvent?.Invoke();
            GameObject.Instantiate(explosionEffect, grenade.transform.position, grenade.transform.rotation);
            GameObject.Destroy(grenade.gameObject);

        }

        private void OnDrawGizmosSelected() {
            Gizmos.color = Color.red;
            if(grenade != null)
            Gizmos.DrawWireSphere(grenade.transform.position, explosionRadius);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Grenade.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/HandPoseCopier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 20185548f02bd944aad89f2d1dc25e8c
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand
{
    public class HandPoseCopier : MonoBehaviour
    {
        public HandPoseDataContainer handPose;
        public Hand hand;

        [ContextMenu("Copy Pose To Hand")]
        public void CopyPoseToHand() {
              if(handPose == null || hand == null)
                return;

              handPose.SetHandPose(hand);
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/HandPoseCopier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/HandSwapper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6872f4b57dc44634aaf0c10b5453d1d8
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {
public class HandSwapper : MonoBehaviour{
        public AutoHandPlayer player;
        public Hand fromHand;
        public Hand toHand;
        public GameObject fromModel;
        public GameObject toModel;

        bool swapped;
        public void Swap() {
            if(!swapped){
                if (toHand.left)
                    player.handLeft = toHand;
                else
                    player.handRight = toHand;

                fromHand.gameObject.SetActive(false);
                fromModel.gameObject.SetActive(true);
                toHand.gameObject.SetActive(true);
                toModel.gameObject.SetActive(false);
            }
            else { 
                if (fromHand.left)
                    player.handLeft = fromHand;
                else
                    player.handRight = fromHand;

                fromHand.gameObject.SetActive(true); 
                fromModel.gameObject.SetActive(false);
                toHand.gameObject.SetActive(false);
                toModel.gameObject.SetActive(true);

            }
            swapped = !swapped;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/HandSwapper.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/JointBreakStopForce1.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8086b3ff476e1fb46be04ba055c7a906
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class JointBreakStopForce1 : MonoBehaviour
    {

        void OnJointBreak(float breakForce) {
            if(gameObject.CanGetComponent(out Rigidbody body)) {
                body.linearVelocity = Vector3.zero;
                body.angularVelocity = Vector3.zero;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/JointBreakStopForce1.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/OpenLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f8536c35c369f2f4cadf9c7299e8e16c
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class OpenLink : MonoBehaviour
{
    public string URL;
    public void OpenLinkURL() {
        Application.OpenURL(URL);
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/OpenLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Pistol.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d5aa5c06028015b45918ad5dbbefc548
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class Pistol : MonoBehaviour
    {
        public Rigidbody body;

        public Transform barrelTip;
        public float hitPower = 1;
        public float recoilPower = 1;
        public float range = 100;
        public LayerMask layer;

        public AudioClip shootSound;
        public float shootVolume = 1f;

        private void Start() {
            if(body == null && GetComponent<Rigidbody>() != null)
                body = GetComponent<Rigidbody>();
        }

        public void Shoot() {
            //Play the audio sound
            if(shootSound)
                AudioSource.PlayClipAtPoint(shootSound, transform.position, shootVolume);

            RaycastHit hit;
            if(Physics.Raycast(barrelTip.position, barrelTip.forward, out hit, range, layer)){
                var hitBody = hit.transform.GetComponent<Rigidbody>();
                if(hitBody != null) {
                    Debug.DrawRay(barrelTip.position, (hit.point - barrelTip.position), Color.green, 5);
                    hitBody.GetComponent<Smash>()?.DoSmash();
                    hitBody.AddForceAtPosition((hit.point - barrelTip.position).normalized*hitPower*10, hit.point, ForceMode.Impulse);
                }
            }
            else
                Debug.DrawRay(barrelTip.position, barrelTip.forward*range, Color.red, 1);

            body.AddForce(barrelTip.transform.up*recoilPower*5, ForceMode.Impulse);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Pistol.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/PlatformMover.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c683db686df4f834bb6ad25857a3b7de
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlatformMover : MonoBehaviour
{
    public Vector3 toRange;
    public float time = 1;

    Vector3 startPos;
    // Start is called before the first frame update
    void Start() {
        startPos = transform.position;
        StartCoroutine(Move());
    }

    IEnumerator Move() {
        while (true) {
            var timePassed = 0f;
            while(timePassed < time){
                timePassed += Time.fixedDeltaTime;
                transform.position = Vector3.Lerp(startPos, startPos+toRange, timePassed/time);
                yield return new WaitForEndOfFrame();
            }
            transform.position = toRange;

            timePassed = 0f;
            while(timePassed < time){
                timePassed += Time.fixedDeltaTime;
                transform.position = Vector3.Lerp(startPos + toRange, startPos, timePassed/time);
                yield return new WaitForEndOfFrame();
            }
            transform.position = toRange;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/PlatformMover.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/PlayerFallCatcher.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 573626c2803a9f04aa9674af69754045
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Autohand.Demo{
    public class PlayerFallCatcher : MonoBehaviour{
        Vector3 startPos;

        void Start(){
            if(AutoHandPlayer.Instance != null) {
                startPos = AutoHandPlayer.Instance.transform.position;
                if(!SceneManager.GetActiveScene().name.ToLower().Contains("demo"))
                    enabled = false;
            }
        }
        
        void FixedUpdate() {
            if(AutoHandPlayer.Instance != null) {
                if(AutoHandPlayer.Instance.transform.position.y < -10f) {
                    AutoHandPlayer.Instance.SetPosition(startPos);
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/PlayerFallCatcher.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ReloadSceneByName.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8b3f69fa09888e34a8f0c5bb6f2fd3dc
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class ReloadSceneByName : MonoBehaviour
{
    public string sceneName;

    public void ReloadScene()
    {
        SceneManager.LoadScene(sceneName);
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ReloadSceneByName.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ScaleHighlight.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 33617aa892a81454485697364fce6613
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class ScaleHighlight : MonoBehaviour{
        public Vector3 highlighScale;
        public Vector3 normalScale;

        public void Highlight() {
            transform.localScale = highlighScale;
        }

        public void HighlightStop() {
            transform.localScale = normalScale;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ScaleHighlight.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Spinner.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e0ac23cfaa9b1534d9d5af4b6fe6a38f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class Spinner : MonoBehaviour{
        public Vector3 rotationSpeed;

        void FixedUpdate()
        {
            transform.Rotate(rotationSpeed * Time.fixedDeltaTime/2f);
        }

        void Update()
        {
            transform.Rotate(rotationSpeed * Time.deltaTime/2f);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Spinner.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ToggleAutoMoveFlying.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b5e2349f27d04b74c8c691ab00cbcd1a
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {
    public class ToggleAutoMoveFlying : MonoBehaviour {
        public void ToggleFlying() {
            var player = AutoHandExtensions.CanFindObjectOfType<AutoHandPlayer>();
            player.useGrounding = !player.useGrounding;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ToggleAutoMoveFlying.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ToggleHandProjection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 33d078add29c26a4099661b6e0fc25d9
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo
{
    public class ToggleHandProjection : MonoBehaviour
    {
        public void DisableGripProjection()
        {
            var projections = AutoHandExtensions.CanFindObjectsOfType<HandProjector>(true);

            foreach (var projection in projections)
            {
                projection.gameObject.SetActive(false);
                if (projection.useGrabTransition)
                    projection.enabled = false;
            }
        }

        public void EnableGripProjection()
        {
            var projections = AutoHandExtensions.CanFindObjectsOfType<HandProjector>(true);
            foreach (var projection in projections)
            {
                projection.gameObject.SetActive(true);
                if (projection.useGrabTransition)
                    projection.enabled = true;
            }
        }

        public void DisableHighlightProjection()
        {
            var projections = AutoHandExtensions.CanFindObjectsOfType<HandProjector>(true);
            foreach (var projection in projections)
            {
                projection.gameObject.SetActive(false);
                if (!projection.useGrabTransition)
                    projection.enabled = false;
            }
        }

        public void EnableHighlightProjection()
        {
            var projections = AutoHandExtensions.CanFindObjectsOfType<HandProjector>(true);

            foreach (var projection in projections)
            {
                projection.gameObject.SetActive(true);
                if (!projection.useGrabTransition)
                    projection.enabled = true;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ToggleHandProjection.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/TomatoSpawner.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a2088b237456a2c43a11e0ba06470e50
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
public class TomatoSpawner : MonoBehaviour{
    public GameObject[] tomatoes;
    List<GameObject> copies;

    void Start(){
        copies = new List<GameObject>();
        foreach(var tomato in tomatoes) {
            var newTomato = Instantiate(tomato, tomato.transform.position, tomato.transform.rotation);
            newTomato.transform.position += new Vector3(0, 0.2f, 0);
            newTomato.SetActive(false);
            copies.Add(newTomato);
            
        }
    }

    public void SpawnTomato() {
        int i = Random.Range(0, copies.Count-1);
        Instantiate(copies[i], copies[i].transform.position, copies[i].transform.rotation).SetActive(true);
    }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/TomatoSpawner.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/UnlockChest.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 060a595b650563245bdcfab5935ba6a3
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo
{
    public class UnlockChest : MonoBehaviour
    {
        public PlacePoint placePoint;

        public HingeJoint joint;

        public void Start()
        {
            placePoint.OnPlaceEvent += (PlacePoint point, Grabbable grab) => {
                Unlock();
                grab.body.detectCollisions = false;
            };
        }

        public void Unlock()
        {
            joint.limits = new JointLimits
            {
                bounceMinVelocity = joint.limits.bounceMinVelocity,
                bounciness = joint.limits.bounciness,
                contactDistance = joint.limits.contactDistance,
                min = 0,
                max = 160
            };
            joint.spring = new JointSpring() { spring = 5, targetPosition = 160 };
        }

        public void Lock()
        {
            joint.limits = new JointLimits
            {
                bounceMinVelocity = joint.limits.bounceMinVelocity,
                bounciness = joint.limits.bounciness,
                contactDistance = joint.limits.contactDistance,
                min = -2,
                max = 2
            };
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/UnlockChest.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/ButtonDemoRespawn.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0c3308b24daf7e746813f1558f8d877c
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Autohand.Demo{
    public class ButtonDemoRespawn : MonoBehaviour{
        public Transform root;

        List<Transform> respawns = new List<Transform>();

        List<Vector3> startPos;
        List<Quaternion> startRot;


        void Start(){

            startPos = new List<Vector3>();
            startRot = new List<Quaternion>();

            for (int i = 0; i < root.childCount; i++){
                respawns.Add(root.GetChild(i));
                startPos.Add(root.GetChild(i).transform.position);
                startRot.Add(root.GetChild(i).transform.rotation);
                for (int j = 0; j < root.GetChild(i).childCount; j++){
                    respawns.Add(root.GetChild(i).GetChild(j));
                    startPos.Add(root.GetChild(i).GetChild(j).transform.position);
                    startRot.Add(root.GetChild(i).GetChild(j).transform.rotation);
                }
            }
        }

        public void Respawn() {
            for(int i = 0; i < respawns.Count; i++) {
                try {
                    if (respawns[i].CanGetComponent(out Rigidbody body)){
                        body.linearVelocity = Vector3.zero;
                        body.angularVelocity = Vector3.zero;
                        body.ResetInertiaTensor();
                    }
                    respawns[i].transform.position = startPos[i];
                    respawns[i].transform.rotation = startRot[i];
                }
                catch { }
            }
        }

        public void ReloadScene() {
            SceneManager.LoadScene(SceneManager.GetActiveScene().name);
        }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/ButtonDemoRespawn.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/DialHandScaler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1f4b70a8134140646914d4825d4a6617
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class DialHandScaler : PhysicsGadgetHingeAngleReader{
        public Hand hand;
        public Vector3 minScale;
        public Vector3 maxScale;

        float startReach;
        Vector3 startScale;
        float[] fingersStartScale;
        Vector3 lastHandScale;

        new protected void Start() {
            base.Start();
            startScale = hand.transform.localScale;
            startReach = hand.reachDistance;
            fingersStartScale = new float[hand.fingers.Length];
            for(int i = 0; i < hand.fingers.Length; i++) {
                fingersStartScale[i] = hand.fingers[i].tipRadius;
            }
            lastHandScale = hand.transform.localScale;
        }

        void Update(){ 
            var value = GetValue();
            var scaleDiff = hand.transform.localScale.magnitude/startScale.magnitude;

            if(value >= 0)
                hand.transform.localScale = Vector3.Lerp(startScale, maxScale, value);
            else if(value < 0)
                hand.transform.localScale = Vector3.Lerp(startScale, minScale, -value);

            //The hands reach distance, and the fingers tip radius all need to be set based on the scale
            hand.reachDistance = startReach*scaleDiff;
            for(int i = 0; i < hand.fingers.Length; i++)
                hand.fingers[i].tipRadius = fingersStartScale[i]*scaleDiff;

            if(hand.transform.localScale != lastHandScale)
                hand.ForceReleaseGrab();

            lastHandScale = hand.transform.localScale;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/DialHandScaler.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/JoystickObjectMover.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 271c5f0aab7c79c4baf763651deb6b8c
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class JoystickObjectMover : PhysicsGadgetJoystick{
        public Transform move;
        public float speed = 2;
        
        void Update(){
            var axis = GetValue();
            var moveAxis = new Vector3(axis.x*Time.deltaTime*speed, 0, axis.y*Time.deltaTime*speed);
            move.transform.localPosition += moveAxis;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/JoystickObjectMover.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/MoverLever.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0fa576b4d758c154c9f822f75e47e220
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using Autohand;

namespace Autohand.Demo{
    public class MoverLever : PhysicsGadgetHingeAngleReader{
        public Transform move;
        public Vector3 axis;
        public float speed = 1;
    
        void Update(){
            if(Mathf.Abs(GetValue()) > 0.1f)
                move.position = Vector3.MoveTowards(move.position, move.position-axis, Time.deltaTime*speed*(GetValue()));
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/MoverLever.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/PhysicsSliderPositionMover.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eea6f209c3501824eac00e1f5626ded0
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class PhysicsSliderPositionMover : PhysicsGadgetConfigurableLimitReader{

        [Header("Movement")]
        public Transform move;
        [Tooltip("Acts as speed")]
        public Vector3 axis = Vector3.up;
        [Header("Range")]
        public bool useRange = false;
        public Vector3 minRange = -Vector3.up;
        public Vector3 maxRange = Vector3.up;
        
        Vector3 startPos;

        protected new void Start(){
            base.Start();
            startPos = move.position;
        }

        public void FixedUpdate(){
            if(useRange){
                var value = GetValue();

                if(value >= 0)
                    move.position = Vector3.Lerp(startPos, startPos+minRange, value);
                else if(value < 0)
                    move.position = Vector3.Lerp(startPos, startPos+maxRange, -value);
            }
            else
                move.position += axis*GetValue()*Time.fixedDeltaTime;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/PhysicsSliderPositionMover.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/WheelRotator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9bcaa22d55bd51e41aff35e61ffe7535
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Autohand;

namespace Autohand.Demo{
    public class WheelRotator : PhysicsGadgetHingeAngleReader{
        public Transform move;
        public Vector3 angle;
        public bool useLocal = false;
        

        void Update(){

            if(useLocal)
                move.localRotation *= Quaternion.Euler(angle*Time.deltaTime*GetValue());
            else
                move.rotation *= Quaternion.Euler(angle*Time.deltaTime*GetValue());
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/WheelRotator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/LeverTextChanger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 611b8567faa503a49ae0f3e982d21b3a
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class LeverTextChanger : MonoBehaviour{
        public TMPro.TextMeshPro text;
        public PhysicsGadgetHingeAngleReader sliderReader;

        float lastValue = 0;
        void Update(){
            var value = sliderReader.GetValue();
            if(value != lastValue) {
                lastValue = value;
                text.text = Math.Round(value, 2).ToString();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/LeverTextChanger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/SliderTextChanger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0049c988a2ee3424d948efba0d6c4524
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class SliderTextChanger : MonoBehaviour{
        public TMPro.TextMeshPro text;
        public PhysicsGadgetConfigurableLimitReader sliderReader;

        float lastValue = 0;

        void Update(){
            var value = sliderReader.GetValue();
            if(value != lastValue) {
                lastValue = value;
                text.text = Math.Round(value, 2).ToString();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/SliderTextChanger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextChanger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5a0de1c68fdad6a4c8ba6a07c4c708e5
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Autohand;

namespace Autohand.Demo{
    public class TextChanger : MonoBehaviour{
        public TMPro.TextMeshPro text;
        Coroutine changing;
        Coroutine hide;
        
        public void UpdateText(string newText, float upTime) {

        }

        public void UpdateText(string newText) {

        }

        IEnumerator ChangeText(float seconds, string newText) {
            //float totalTime = 1f;
            //var timePassed = 0f;
            //text.text = newText;
            //text.alpha = 0;

            //while(timePassed <= totalTime) {
            //    text.alpha = (timePassed/totalTime);
            //    timePassed += Time.deltaTime;
            //    if(totalTime >= timePassed)
            //        text.alpha = 1;
            //    yield return new WaitForFixedUpdate();
            //}

            //yield return new WaitForSeconds(seconds);

            //totalTime = 2f;
            //timePassed = 0f;
            //while(timePassed <= totalTime) {
            //    text.alpha = 1-(timePassed/totalTime);
            //    timePassed += Time.deltaTime;
            //    if(totalTime >= timePassed)
            //        text.alpha = 0;
            //    yield return new WaitForFixedUpdate();
            //}

            yield return new WaitForFixedUpdate();
            //text.text = "";
        }

        private void OnDestroy() {
            text.text = "";
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextChanger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextFieldInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 61eb7df20390f15409feba60c95784dd
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TextFieldInspector : MonoBehaviour
{
    [TextArea]
    public string text;
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextFieldInspector.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextGrabEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b2aea2de75c7aac428a4c2cc43c65b46
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Autohand;

namespace Autohand.Demo{
    public class TextGrabEvent : MonoBehaviour{
        public TextChanger changer;
        public Grabbable grab;
        [TextArea]
        public string message;

        private void Start() {
            if(grab == null && GetComponent<Grabbable>() != null)
                grab = GetComponent<Grabbable>();

            if(grab == null || changer == null)
                Destroy(this);

            grab.OnGrabEvent += OnGrab;
        }
        
        void OnGrab(Hand hand, Grabbable grab) {
            changer?.UpdateText(message);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextGrabEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextInformation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9d18906787894d14894103caf956f8cf
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TextInformation : MonoBehaviour{
    public GameObject activateImage;
    public GameObject deactivateImage;
    public GameObject[] texts;


    bool active;
    
    public void ActivateText() {
        active = true;
        foreach(var text in texts) {
            text.SetActive(active);
        }
        
        activateImage.SetActive(true);
        deactivateImage.SetActive(false);
    }


    public void DeactivateText() {
        active = false;
        foreach(var text in texts) {
            text.SetActive(active);
        }
        
        activateImage.SetActive(false);
        deactivateImage.SetActive(true);
    }

    public void ToggleText() {
        if(active)
            DeactivateText();
        else
            ActivateText();
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextInformation.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextPlacePointEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 519fd41fb2f35384ab9142bf2f7c6153
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Autohand;

namespace Autohand.Demo{
    public class TextPlacePointEvent : MonoBehaviour{
        public TextChanger changer;
        public PlacePoint point;
        public float fadeTime = 5;
        [TextArea]
        public string placeMessage;
        [TextArea]
        public string highlightMessage;

        private void Start() {
            if(point == null && GetComponent<PlacePoint>() != null)
                point = GetComponent<PlacePoint>();
            point.OnPlaceEvent += OnGrab;
            point.OnHighlightEvent += OnHighlight;
        }
        
        void OnGrab(PlacePoint hand, Grabbable grab) {
            changer?.UpdateText(placeMessage);
        }

        void OnHighlight(PlacePoint hand, Grabbable grab) {
            changer?.UpdateText(highlightMessage);
        }
        

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextPlacePointEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TMPSizeProtector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0d48f091a3199d14084f6e23151ace29
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//This is a script applied to tmp demo text because of a bug where the letters scales are not saved because tmp is not imported
public class TMPSizeProtector : MonoBehaviour{
    public float size;

    void Start(){
#if UNITY_EDITOR
        if(GetComponent<TMPro.TextMeshPro>() != null)
            GetComponent<TMPro.TextMeshPro>().fontSize = size;
#endif
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TMPSizeProtector.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/HandTouchButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 766578289e5886149944336e79b79c4a
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HandTouchButton : MonoBehaviour {
        [NaughtyAttributes.HideIf("startUnpress")]
        public bool startPress = false;
        [NaughtyAttributes.HideIf("startPress")]
        public bool startUnpress = false;
        public HandTouchEvent touchEvent;
        public Transform button;
        public Vector3 pressOffset;
        public Color unpressColor = Color.white;
        public Color pressColor = Color.white;

        public bool toggle = true;

        [Space]
        public UnityHandEvent OnPressed;
        public UnityHandEvent OnUnpressed;

        bool pressed = false;
        MeshRenderer buttonRenderer;

        private void Start() {
            if(startPress)
                PressButton(null);
            else if(startUnpress)
                ReleaseButton(null);

            buttonRenderer = button.GetComponent<MeshRenderer>();
        }

        void OnEnable() {
            touchEvent.HandStartTouchEvent += OnTouch;
            touchEvent.HandStopTouchEvent += OnUntouch;
        }
        void OnDisable() {
            touchEvent.HandStartTouchEvent -= OnTouch;
            touchEvent.HandStopTouchEvent -= OnUntouch;
        }

        void OnTouch(Hand hand) {
            if(toggle) {
                if(!pressed)
                    PressButton(hand);
                else if(pressed)
                    ReleaseButton(hand);
            }
            else if(!pressed)
                PressButton(hand);
        }
        void OnUntouch(Hand hand) {
            if(pressed && !toggle)
                ReleaseButton(hand);
        }

        void PressButton(Hand hand) {
            if(!pressed)
                button.localPosition += pressOffset;
            pressed = true;
            OnPressed?.Invoke(hand); 
            if(buttonRenderer != null && buttonRenderer.material != null)
                buttonRenderer.material.color = pressColor;
        }

        void ReleaseButton(Hand hand) {
            if(pressed)
                button.localPosition -= pressOffset;
            pressed = false; 
            OnUnpressed?.Invoke(hand);
            if(buttonRenderer != null && buttonRenderer.material != null)
                buttonRenderer.material.color = unpressColor;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/HandTouchButton.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/JointExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6896bbcb23a89e64a9efcd8458fd9630
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public static class JointExtensions{
    public static Vector3 Angles(this ConfigurableJoint joint){
        float to180(float v) {
            if (v > 180) {
                v = v - 360;
            }
            return v;
        }

        Quaternion jointBasis = Quaternion.LookRotation(joint.secondaryAxis, Vector3.Cross(joint.axis, joint.secondaryAxis));
        Quaternion jointBasisInverse = Quaternion.Inverse(jointBasis);
        Vector3 rotation;
        if(joint.connectedBody != null) rotation = (jointBasisInverse * Quaternion.Inverse(joint.connectedBody.rotation) * joint.GetComponent<Rigidbody>().transform.rotation * jointBasis).eulerAngles;
        else rotation =  (jointBasisInverse * joint.GetComponent<Rigidbody>().transform.rotation * jointBasis).eulerAngles;
        return new Vector3(to180(rotation.x), to180(rotation.z),to180(rotation.y));
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/JointExtensions.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1c95fc8dc8ac7aa4c867fe21c24639c0
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    //THIS MAY NOT WORK AS A GRABBABLE AT THIS TIME - Try PhysicsGadgetSlider instead
    public class PhysicsGadgetButton : PhysicsGadgetConfigurableLimitReader{
        bool pressed = false;

        [Tooltip("The percentage (0-1) from the required value needed to call the event, if threshold is 0.1 OnPressed will be called at 0.9, and OnUnpressed at 0.1"), Min(0.01f)]
        public float threshold = 0.1f;
        public bool lockOnPressed = false;
        [Space]
        public UnityEvent OnPressed;
        public UnityEvent OnUnpressed;

        Vector3 startPos;
        Vector3 pressedPos;
        float pressedValue;

        Rigidbody body;

        new protected void Start(){
            base.Start();
            startPos = transform.localPosition;
            body = joint.GetComponent<Rigidbody>();
        }


        protected void FixedUpdate(){
            var value = GetValue();
            if(!pressed && value+threshold >= 1) 
                Pressed();
            else if(!lockOnPressed && pressed && value-threshold <= 0)
                Unpressed();
        }


        public void Pressed() {
            pressed = true;
            pressedValue = GetValue();
            pressedPos = transform.localPosition;
            OnPressed?.Invoke();
            if(lockOnPressed)
                body.isKinematic = true;
        }

        public void Unpressed(){
            pressed = false;
            OnUnpressed?.Invoke();
        }

        public void Unlock() {
            lockOnPressed = false;
            body.isKinematic = false;
            body.WakeUp();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetButton.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetConfigurableLimitReader.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 18d9c58a36556874fad9e6f1666c394f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    [RequireComponent(typeof(ConfigurableJoint))]
    public class PhysicsGadgetConfigurableLimitReader : MonoBehaviour{
        public bool invertValue = false;
        [Tooltip("The minimum abs value required to return a value nonzero value\n " +
            "- if playRange is 0.1, you have to move the gadget 10% to get a result")]
        public float playRange = 0.025f;
        protected ConfigurableJoint joint;

        protected Vector3 axisPos;
        float value;
        Vector3 limitAxis;

        protected virtual void Start(){
            joint = GetComponent<ConfigurableJoint>();
            limitAxis = new Vector3(joint.xMotion == ConfigurableJointMotion.Locked ? 0 : 1, joint.yMotion == ConfigurableJointMotion.Locked ? 0 : 1, joint.zMotion == ConfigurableJointMotion.Locked ? 0 : 1);
            axisPos = Vector3.Scale(transform.localPosition, limitAxis);
        }


        /// <summary>Returns a -1 to 1 value that represents the point of the slider</summary>
        public float GetValue() {
            bool positive = true;
            var currPos = Vector3.Scale(transform.localPosition, limitAxis);
            if(axisPos.x < currPos.x || axisPos.y < currPos.y || axisPos.z < currPos.z)
                positive = false;

            if(invertValue)
                positive = !positive;

            value = Vector3.Distance(axisPos, currPos)/joint.linearLimit.limit;

            if(!positive) value *= -1;

            if(float.IsNaN(value))
                value = 0;

            if (Mathf.Abs(value) < playRange)
                value = 0;
            return Mathf.Clamp(value, -1f, 1f);
        }

        public ConfigurableJoint GetJoint() => joint;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetConfigurableLimitReader.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetHingeAngleReader.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3f2580c2349119b46b7b6be979d1ad61
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    [RequireComponent(typeof(HingeJoint))]
    public class PhysicsGadgetHingeAngleReader : MonoBehaviour{
        public bool invertValue = false;
        [Tooltip("For objects slightly off center. " +
            "\nThe minimum abs value required to return a value nonzero value\n " +
            "- if playRange is 0.1, you have to move the gadget 10% to get a result")]
        public float playRange = 0.05f; 
        HingeJoint joint;
        protected float value = 0;
        Quaternion startRot;
        Quaternion deltaParentRotation;

        protected virtual void Start(){
            joint = GetComponent<HingeJoint>(); 
            startRot = transform.localRotation;
        }

        /// <summary>Returns a -1 to 1 value representing the hinges angle from min-max</summary>
        public float GetValue() {
            float limitRange = joint.limits.max - joint.limits.min;
            if(limitRange == 0f) {
                value = 0f;
            }
            else {
                value = joint.angle / limitRange * 2f;
            }

            value = invertValue ? -value : value;

            if(float.IsNaN(value))
                value = 0f;

            if(Mathf.Abs(value) < playRange)
                value = 0f;

            return Mathf.Clamp(value, -1f, 1f);
        }


        public HingeJoint GetJoint() => joint;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetHingeAngleReader.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetJoystick.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 75b68df54cd03f242849b082c2373599
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    [RequireComponent(typeof(ConfigurableJoint))]
    public class PhysicsGadgetJoystick : MonoBehaviour{
        ConfigurableJoint joint;
        public bool invertX;
        public bool invertY;
        [Tooltip("For objects slightly off center. " +
            "\nThe minimum abs value required to return a value nonzero value\n " +
            "- if playRange is 0.1, you have to move the gadget 10% to get a result")]
        public float playRange = 0.05f; 
        Vector2 xRange, zRange;
        Vector2 value;
        Vector3 jointRotation;
        Rigidbody body;

        void Start(){
            joint = GetComponent<ConfigurableJoint>();  
            body = GetComponent<Rigidbody>();
        }

        public void FixedUpdate(){
            xRange = new Vector2(joint.lowAngularXLimit.limit, joint.highAngularXLimit.limit);
            zRange = new Vector2(-joint.angularZLimit.limit, joint.angularZLimit.limit);
            jointRotation = joint.Angles();
            value = new Vector2(jointRotation.z/(zRange.x - zRange.y), jointRotation.x/(xRange.x - xRange.y))*2;
        }

        public Vector2 GetValue() {
            if (Mathf.Abs(value.x) < playRange)
                value.x = 0;
            if (Mathf.Abs(value.y) < playRange)
                value.y = 0;
            
            value.x = invertX ? -value.x : value.x;
            value.y = invertY ? -value.y : value.y;
            return new Vector2(Mathf.Clamp(value.x, -1, 1), Mathf.Clamp(value.y, -1, 1));
        }
        
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetJoystick.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetLever.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ca4a171938232714ea376c9d195c0c73
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{

[System.Serializable]
public struct StepEvent {
    public int step;
    public UnityEvent OnStepEnter;
    public UnityEvent OnStepExit;
}

public class PhysicsGadgetLever : PhysicsGadgetHingeAngleReader{
    [Min(0.01f), Tooltip("The percentage (0-1) from the required value needed to call the event, if threshold is 0.1 OnMax will be called at 0.9, OnMin at -0.9, and OnMiddle at -0.1 or 0.1")]
    public float threshold = 0.05f;

    [Min(0)]
    public int stepCount = 0;
    public int startStep = 0;
    private int prevStepCount = -1;

    public UnityEvent OnMax;
    public UnityEvent OnMid;
    public UnityEvent OnMin;
    public StepEvent[] stepEvents;
        
    bool min = false;
    bool max = false;
    bool mid = true;

    private int currStep = -1;
    private int prevStep = -1;
    
    private float minimum;
    private float maximum;
    float[] stepMarkers;

    protected void FixedUpdate(){
        var value = GetValue();

        if(!max && mid && value+threshold >= 1) {
            Max();
        }

        if(!min && mid && value-threshold <= -1){
            Min();
        }
        
        if (value <= threshold && max && !mid) {
            Mid();
        }

        if (value >= -threshold && min && !mid) {
            Mid();
        }
    }

    protected override void Start() {
        base.Start();
        if(startStep <= 0) return;

        FindSteps();
        SetSpring(startStep - 1);
    }

    void Update() {
        AdjustStep();
    }

    void AdjustStep() {
        if(stepCount <= 0) return;

        FindSteps();
        SetSpring(FindCurrentStep()); 
    }

    bool FindSteps() {
        if(prevStepCount == stepCount) return false;

        prevStepCount = stepCount;

        stepMarkers = new float[stepCount];

        minimum = GetJoint().limits.min;
        maximum = GetJoint().limits.max;
        
        float step = GetStep();

        for(int i = 0; i < stepCount; i++) {
            stepMarkers[stepCount - i - 1] = minimum + (i * step);
        }

        return true;
    }

    public void SetSpring(int step)
    {
        GetJoint().transform.localRotation *= Quaternion.Euler(GetJoint().axis  * stepMarkers[step]);

        currStep = step;
        JointSpring jointSpring = GetJoint().spring;
        jointSpring.targetPosition = stepMarkers[step]; 
        GetJoint().spring = jointSpring;
    }

    public void SetSpring(float stepRotation)
    {
        JointSpring jointSpring = GetJoint().spring;
        jointSpring.targetPosition = stepRotation; 
        GetJoint().spring = jointSpring;
    }

    float FindCurrentStep() {
        float checkValue = GetValue() * GetRange();
        for(int i = 0; i < stepCount; i++) {
            if(checkValue >= GetMinimumStep(i) && checkValue <= GetMaximumStep(i)) {
                currStep = i;
                if(currStep != prevStep) {
                    Step();
                    prevStep = currStep;
                }

                return stepMarkers[i];
            }
        }

        return 0;
    }

    float GetStep() => (Mathf.Abs(minimum) + Mathf.Abs(maximum)) / (stepCount - 1);
    float GetRange() => (Mathf.Abs(minimum) + Mathf.Abs(maximum)) / 2;
    float GetMinimumStep(int index) => stepMarkers[index] - (GetStep() / 2);
    float GetMaximumStep(int index) => stepMarkers[index] + (GetStep() / 2);

    void Max() {
        mid = false;
        max = true;
        OnMax?.Invoke();
    }

    void Mid() {
        min = false;
        max = false;
        mid = true;
        OnMid?.Invoke();
    }

    void Min() {
        min = true;
        mid = false;
        OnMin?.Invoke();
    }

    void Step() {
        for(int i = 0; i < stepEvents.Length; i++) {
            if(stepEvents[i].step == currStep + 1) {
                stepEvents[i].OnStepEnter?.Invoke();
            }
            else if(stepEvents[i].step == prevStep + 1) {
                stepEvents[i].OnStepExit?.Invoke();
            }
        }
    }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetLever.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetSlider.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 18f6faf550e7518449699c9a49dc7298
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
public class PhysicsGadgetSlider : PhysicsGadgetConfigurableLimitReader{
    [Min(0.01f), Tooltip("The percentage (0-1) from the required value needed to call the event, if threshold is 0.1 OnMax will be called at 0.9, OnMin at -0.9, and OnMiddle at -0.1 or 0.1")]
    public float threshold = 0.05f;

    [Min(0)]
    public int stepCount = 0;
    public int startStep = 0;
    private int prevStepCount = -1;

    public UnityEvent OnMax;
    public UnityEvent OnMid;
    public UnityEvent OnMin;
    public StepEvent[] stepEvents;
        
    bool min = false;
    bool max = false;
    bool mid = true;

    private int currStep = -1;
    private int prevStep = -1;
    
    private float minimum;
    private float maximum;
    float[] stepMarkers;

    protected void FixedUpdate(){
            var value = GetValue();
        if(!max && mid && value+threshold >= 1) {
            Max();
        }

        if(!min && mid && value-threshold <= -1){
            Min();
        }
        
        if (value <= threshold && max && !mid) {
            Mid();
        }

        if (value >= -threshold && min && !mid) {
            Mid();
        }
    }

    protected override void Start() {
        base.Start();
        if(startStep <= 0) return;

        FindSteps();
        SetSpring(startStep - 1);
    }

    void Update() {
        AdjustStep();
    }
    
    void AdjustStep() {
        if(stepCount <= 0) return;
        
        FindSteps();
        SetSpring(FindCurrentStep());

    }

    bool FindSteps() {
        if(prevStepCount == stepCount) return false;

        prevStepCount = stepCount;

        stepMarkers = new float[stepCount];

        minimum = -(GetJoint().linearLimit.limit);
        maximum = (GetJoint().linearLimit.limit);
        
        float step = GetStep();

        for(int i = 0; i < stepCount; i++) {
            stepMarkers[i] = minimum + (i * step);
        }
        return true;
    }

    public void SetSpring(int step)
    {
        currStep = step;
        Vector3 limitAxis = new Vector3(joint.xMotion == ConfigurableJointMotion.Locked ? 0 : stepMarkers[step], 
                                        joint.yMotion == ConfigurableJointMotion.Locked ? 0 : stepMarkers[step], 
                                        joint.zMotion == ConfigurableJointMotion.Locked ? 0 : stepMarkers[step]);
        
        GetJoint().transform.localPosition = limitAxis;
        GetJoint().targetPosition = limitAxis;
    }

    public void SetSpring(float stepRotation)
    {
        Vector3 limitAxis = new Vector3(joint.xMotion == ConfigurableJointMotion.Locked ? 0 : stepRotation, 
                                        joint.yMotion == ConfigurableJointMotion.Locked ? 0 : stepRotation, 
                                        joint.zMotion == ConfigurableJointMotion.Locked ? 0 : stepRotation);
        
        GetJoint().targetPosition = limitAxis;
    }

    float FindCurrentStep() {
        float checkValue = GetValue() / GetScalar();
        for(int i = 0; i < stepCount; i++)
            if(checkValue >= GetMinimumStep(i) && checkValue <= GetMaximumStep(i)) {
                currStep = i;
                if(currStep != prevStep) {
                    Step();
                    prevStep = currStep;
                }

                return stepMarkers[i];
            }

        return 0;
    }

    float GetStep() => (Mathf.Abs(minimum) + Mathf.Abs(maximum)) / (stepCount - 1);
    float GetScalar() => (1 / Mathf.Abs(minimum));
    float GetMinimumStep(int index) => stepMarkers[index] - (GetStep() / 2);
    float GetMaximumStep(int index) => stepMarkers[index] + (GetStep() / 2);

    void Max() {
        mid = false;
        max = true;
        OnMax?.Invoke();
    }

    void Mid() {
        min = false;
        max = false;
        mid = true;
        OnMid?.Invoke();
    }

    void Min() {
        min = true;
        mid = false;
        OnMin?.Invoke();
    }
    void Step() {
        for(int i = 0; i < stepEvents.Length; i++) {
            if(stepEvents[i].step == currStep + 1) {
                stepEvents[i].OnStepEnter?.Invoke();
            }
            else if(stepEvents[i].step == prevStep + 1) {
                stepEvents[i].OnStepExit?.Invoke();
            }
        }
    }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetSlider.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/DispenserPoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8e06fa0b8c2a3b047ab22fa2c4dcbaa4
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

namespace Autohand {
    [Serializable, DefaultExecutionOrder(100)] 
    public class UnityDispenserEvent : UnityEvent<DispenserPoint, Grabbable> { }
    public class DispenserPoint : MonoBehaviour {
        [AutoHeader("Dispenser Point")]
        public bool ignoreMe;

        [AutoSmallHeader("Dispenser Settings")]
        public bool showeSettings = true;
        [Tooltip("The object to be copied and dispensed")]
        public Grabbable dispenseObject;
        [Tooltip("The maximum copies allowed to exist from this dispenser before they are destroyed or reset")]
        public int maxCopies = 3;
        [Tooltip("The delay in seconds before the next dispense appears after the current dispense is taken")]
        public float resetDelay = 0f;
        [Tooltip("Whether or not objects placed in the dispense point should be set to kinematic on placed or not")]
        public bool disableBody = false;
        [NaughtyAttributes.HideIf("disableBody"), Tooltip("Whether or not objects placed in the dispense point should be set to kinematic on placed or not")]
        public bool isKinematic = true;
        [Tooltip("If true the object will not just reset its position on reset it will be destroyed and a new copy will be placed. Less performant but important for things like ammo that should always respawn as new clips full")]
        public bool destroyOnReset = false;
        [Tooltip("The maximum distance a dispensed object can move from the point before the next object is dispensed")]
        public float maxDistance = 1f;

        [Space]
        public UnityDispenserEvent OnGrabDispenseEvent;
        public UnityDispenserEvent OnDispenseEvent;

        Grabbable currentDispense;
        Grabbable lastDispense;
        GameObject[] dispensePool;
        int poolCount;
        Coroutine dispenseRoutine;

        protected virtual void Start() {
            GameObject instanceObject;
            dispenseObject.body.gameObject.SetActive(false);

            instanceObject = Instantiate(dispenseObject.body.gameObject);


            instanceObject.transform.position = transform.position;
            instanceObject.transform.rotation = transform.rotation;
            instanceObject.SetActive(true);


            dispensePool = new GameObject[maxCopies];
            dispensePool[0] = instanceObject;


            if(dispensePool[0].HasGrabbable(out var grab)) {
                if(!disableBody && isKinematic && grab.body != null)
                    grab.body.isKinematic = true;

                grab.OnGrabEvent += OnGrab;
                grab.OnPlacePointAddEvent += OnPlaced;
                currentDispense = grab;

                if(disableBody)
                    grab.DeactivateRigidbody();
            }

            poolCount++;
        }

        protected virtual void OnDisable() {
            if(dispenseRoutine != null)
                StopCoroutine(dispenseRoutine);
            dispenseRoutine = null;
        }

        protected virtual void FixedUpdate() { 
            if(maxDistance > 0 && currentDispense.gameObject.activeInHierarchy && Vector3.Distance(transform.position, currentDispense.rootTransform.position) > maxDistance)
                Dispense();
        }

        public virtual Grabbable Dispense() {
            if(dispenseRoutine == null) {
                var poolIndex = (poolCount) % maxCopies;
                if(destroyOnReset) {
                    Destroy(dispensePool[poolIndex]);
                    dispensePool[poolIndex] = null;
                }

                if(poolCount < maxCopies || dispensePool[poolIndex] == null || dispensePool[poolIndex].activeInHierarchy == false)
                    dispensePool[poolIndex] = Instantiate(dispenseObject.body.gameObject);

                dispensePool[poolIndex].transform.position = transform.position;
                dispensePool[poolIndex].transform.rotation = transform.rotation;

                if(dispensePool[poolIndex].HasGrabbable(out var grab)) {
                    grab.ForceHandsRelease();
                    if(grab.placePoint != null)
                        grab.placePoint.Remove();
                    if(grab.body == null)
                        grab.ActivateRigidbody();

                    if(!disableBody && isKinematic)
                        grab.body.isKinematic = true;

                    if(!grab.body.isKinematic) {
                        grab.body.linearVelocity = Vector3.zero;
                        grab.body.angularVelocity = Vector3.zero;
                    }

                    grab.OnGrabEvent += OnGrab;
                    grab.OnPlacePointAddEvent += OnPlaced;

                    dispenseRoutine = StartCoroutine(DispenseResetDelay(grab));


                    lastDispense = currentDispense;
                    lastDispense.OnGrabEvent -= OnGrab;
                    lastDispense.OnPlacePointAddEvent -= OnPlaced;
                    currentDispense = grab;

                    poolCount++;
                    return grab;
                }


                poolCount++;
            }
            return null;
        }

        public virtual void OnGrab(Hand hand, Grabbable grab) {
            if(grab != null && isKinematic && grab.body != null)
                grab.body.isKinematic = false;

            OnGrabDispenseEvent?.Invoke(this, grab);
            Dispense();
        }

        public virtual void OnPlaced(PlacePoint point, Grabbable grab) {
            if(grab != null && isKinematic && grab.body != null)
                grab.body.isKinematic = false;

            Debug.Log("Placed: " + grab.body.isKinematic);

            Dispense();
        }

        IEnumerator DispenseResetDelay(Grabbable dispenseObject) {
            dispenseObject.body.gameObject.SetActive(false);
            yield return new WaitForSeconds(resetDelay);
            dispenseObject.body.gameObject.SetActive(true);
            dispenseObject.IgnoreGrabbableCollisionUntilNone(lastDispense);
            foreach(var hand in lastDispense.GetHeldBy())
                dispenseObject.IgnoreHandCollisionUntilNone(hand);
            OnDispenseEvent?.Invoke(this, dispenseObject);
            if(disableBody)
                dispenseObject.DeactivateRigidbody();
            dispenseRoutine = null;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/DispenserPoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/DistanceGrabbable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 935aaf7da50abf94697c8d70a7a71efe
# ASMDEF: AutoHandAssembly.dll
# ---
using NaughtyAttributes;
using UnityEngine;

namespace Autohand{
    public enum DistanceGrabType {
        Velocity,
        Linear
    }

    [RequireComponent(typeof(Grabbable))]
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/grabbable/distance-grabbinghttps://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/grabbable/distance-grabbing")]
    public class DistanceGrabbable : MonoBehaviour{
        [AutoHeader("Distance Grabbable")]
        public bool ignoreMe;
        
        [Header("Pull")]
        public bool instantPull = true;


        public DistanceGrabType grabType;

        [Range(0.4f, 1.1f)]
        [Tooltip("Use this to adjust the angle of the arch that the gameobject follows while shooting towards your hand.")]
        [ShowIf("grabType", DistanceGrabType.Velocity)]
        public float archMultiplier = .6f;
        [Tooltip("Slow down or speed up gravitation to your liking.")]
        [ShowIf("grabType", DistanceGrabType.Velocity)]
        public float gravitationVelocity = 1f;



        [Header("Rotation")]
        [Tooltip("This enables rotation which makes the gameobject orient to the rotation of you hand as it moves through the air. All below rotation variables have no use when this is false.")]
        [ShowIf("grabType", DistanceGrabType.Velocity)]
        public bool rotate = true;

        [Tooltip("Speed that the object orients to the rotation of your hand.")]
        [ShowIf("grabType", DistanceGrabType.Velocity)]
        public float rotationSpeed = 1;
        
        [AutoToggleHeader("Enable Highlighting")]
        [Tooltip("Whether or not to ignore all highlights including default highlights on HandPointGrab")]
        public bool ignoreHighlights = true;
        [EnableIf("ignoreHighlights"), Tooltip("Highlight targeted material to use - defaults to HandPointGrab materials if none")]
        public Material targetedMaterial;
        [EnableIf("ignoreHighlights"), Tooltip("Highlight selected material to use - defaults to HandPointGrab materials if none")]
        public Material selectedMaterial;

        [AutoToggleHeader("Show Events")]
        public bool showEvents = true;
        [ShowIf("showEvents")]
        public UnityHandGrabEvent OnPull;
        [Space]
        [Tooltip("Called when the object has been targeted/aimed at by the pointer")]
        [ShowIf("showEvents")]
        public UnityHandGrabEvent StartTargeting;
        [ShowIf("showEvents")]
        public UnityHandGrabEvent StopTargeting;
        [Space]
        [Tooltip("Called when the object has been selected before being pulled or flicked")]
        [ShowIf("showEvents")]
        public UnityHandGrabEvent StartSelecting;
        [ShowIf("showEvents")]
        public UnityHandGrabEvent StopSelecting;

        public HandGrabEvent OnPullCanceled;

        internal Grabbable grabbable;
    

        private Transform target = null;
        private Vector3 calculatedNecessaryVelocity;
        private bool gravitationEnabled;
        private bool gravitationMethodBegun;
        private bool pullStarted;
        private Rigidbody body;
        float timePassedSincePull;

        private void Start() {
            grabbable = GetComponent<Grabbable>();
            grabbable.OnGrabEvent += (Hand hand, Grabbable grab) => { gravitationEnabled = false; };
            body = grabbable.body;
        }
    
        void FixedUpdate(){
            if(!instantPull && grabType == DistanceGrabType.Velocity) {
                if (target == null)
                    return;

                InitialVelocityPushToHand();
                if(rotate)
                    FollowHandRotation();
                if (gravitationEnabled)
                    GravitateTowardsHand();
                timePassedSincePull += Time.fixedDeltaTime;
            }
        }


        private void FollowHandRotation(){
            transform.rotation = Quaternion.Slerp(transform.rotation, target.rotation, rotationSpeed * Time.fixedDeltaTime); 
        }

        Vector3 lastGravitationVelocity;
        private void GravitateTowardsHand(){
            if (gravitationEnabled){

                if (!gravitationMethodBegun){
                    gravitationMethodBegun = true;
                }
                    
                lastGravitationVelocity = (target.position- transform.position).normalized*Time.fixedDeltaTime*gravitationVelocity;
                body.linearVelocity += lastGravitationVelocity*10;
            }
            else{
                gravitationMethodBegun = false;
            }
        }


        private void InitialVelocityPushToHand(){
            //This way I can ensure that the initial shot with velocity is only shot once
            if (pullStarted){
                if(archMultiplier > 0)
                    calculatedNecessaryVelocity = CalculateTrajectoryVelocity(transform.position, target.transform.position, archMultiplier);

                timePassedSincePull = 0;
                body.linearVelocity = calculatedNecessaryVelocity;
                gravitationEnabled = true;
                pullStarted = false;
            }
        }

        private void OnCollisionEnter(Collision collision){
            if (timePassedSincePull > 0.2f)
            {
                pullStarted = false;
                gravitationEnabled = false;
                CancelTarget();
            }
        }


        Vector3 CalculateTrajectoryVelocity(Vector3 origin, Vector3 target, float t){
            float vx = (target.x - origin.x) / t;
            float vz = (target.z - origin.z) / t;
            float vy = ((target.y - origin.y) - 0.5f * Physics.gravity.y * t * t) / t;
            return new Vector3(vx, vy, vz);
        }

        public void SetTarget(Transform theObject) { target = theObject; pullStarted = true; }
        public void CancelTarget() { target = null; pullStarted = false; }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/DistanceGrabbable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/Grabbable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 822bc9090447b9c40833509c4a32e597
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;
using NaughtyAttributes;
using UnityEditor;
using UnityEngine.Serialization;
using UnityEngine.XR;


namespace Autohand {
    public enum HandGrabType {
        Default,
        HandToGrabbable,
        GrabbableToHand
    }

    public enum HandGrabPoseType {
        Grab,
        Pinch
    }

    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/grabbable"), DefaultExecutionOrder(-100)]
    public class Grabbable : GrabbableBase, IGrabbableEvents {


        [Tooltip("This will copy the given grabbables settings to this grabbable when applied"), OnValueChanged("EditorCopyGrabbable")]
        public Grabbable CopySettings;

        [Header("Grab Settings")]
        [Tooltip("Which hand this can be held by")]
        public HandGrabType grabType = HandGrabType.Default;

        [Tooltip("Which hand pose this will grab with")]
        public HandGrabPoseType grabPoseType = HandGrabPoseType.Grab;

        [Tooltip("Which hand this can be held by")]
        public HandType handType = HandType.both;

        [Tooltip("Whether or not this can be grabbed with more than one hand")]
        public bool singleHandOnly = false;

        [Space]
        [Tooltip("Will the item automatically return the hand on grab - good for saved poses, bad for heavy things")]
        public bool instantGrab = false;

        [DisableIf("instantGrab"), Tooltip("If true (and using HandToGrabbable) the hand will only return to the follow while moving. Good for picking up objects without disrupting the things around them - you can change the speed of the hand return on the hand through the gentleGrabSpeed value")]
        public bool useGentleGrab = false;

        [Tooltip("Creates an offset an grab so the hand will not return to the hand on grab - Good for statically jointed grabbable objects")]
        public bool maintainGrabOffset = false;

        [Tooltip("This will NOT parent the object under the hands on grab. This will parent the object to the parents of the hand, which allow you to move the hand parent object smoothly while holding an item, but will also allow you to move items that are very heavy - recommended for all objects that aren't very heavy or jointed to other rigidbodies")]
        public bool parentOnGrab = true;


        [Header("Held Settings")]

        [Tooltip("Replaces the physics material with the resources NoFriction material while held")]
        public bool heldNoFriction = true;

        [Tooltip("Experimental - ignores weight of held object while held")]
        public bool ignoreWeight = false;

        [ShowIf("singleHandOnly")]
        [Tooltip("if false single handed items cannot be passes back and forth on grab")]
        public bool allowHeldSwapping = true;

        [Header("Release Settings")]
        [Tooltip("How much to multiply throw by for this grabbable when releasing - 0-1 for no or reduced throw strength")]
        [FormerlySerializedAs("throwMultiplyer")]
        public float throwPower = 1;

        [Tooltip("The required force to break the fixedJoint\n " +
                 "Turn this to \"infinity\" to disable (Might cause jitter)\n" +
                "Ideal value depends on hand mass and velocity settings")]
        public float jointBreakForce = 3500;



        [AutoSmallHeader("Advanced Settings")]
        public bool showAdvancedSettings = true;

        [Tooltip("Adds and links a GrabbableChild to each child with a collider on start - So the hand can grab them")]
        public bool makeChildrenGrabbable = true;

        [Min(0), Tooltip("I.E. Grab Prioirty - BIGGER IS BETTER - divides highlight distance by this when calculating which object to grab. Hands always grab closest object to palm")]
        public float grabPriorityWeight = 1;

        [Tooltip("The number of seconds that the hand collision should ignore the released object\n (Good for increased placement precision and resolves clipping errors)"), Min(0)]
        public float ignoreReleaseTime = 0.5f;


        [Tooltip("The minimum allow drag a held objects rigidbody can have, this can help prevent dramatic wobbling on held objects"), Min(0)]
        public float minHeldDrag = 1.5f;
        [Tooltip("The minimum allow drag a held objects rigidbody can have, this can help prevent dramatic wobbling on held objects"), Min(0)]
        public float minHeldAngleDrag = 3f;
        [Tooltip("The minimum allow drag a held objects rigidbody can have, this can help prevent dramatic wobbling on held objects"), Min(0)]
        public float minHeldMass = 0.1f;

        [Tooltip("Lowing this value will help allow for more stable joint interactions and make objects seems heavier if lowered enough"), Min(0)]
        public float maxHeldVelocity = 10f;
        [Space]

        [Tooltip("Offsets the grabbable by this much when being held")]
        public Vector3 heldPositionOffset;

        [Tooltip("Offsets the grabbable by this many degrees when being held")]
        public Vector3 heldRotationOffset;

        [Space]

        [Min(0), Tooltip("The joint that connects the hand and the grabbable. Defaults to the joint in AutoHand/Resources/DefaultJoint.prefab if empty")]
        public ConfigurableJoint customGrabJoint;

        [Space]

        [Tooltip("For the special use case of having grabbable objects with physics jointed peices move properly while being held")]
        public List<Rigidbody> jointedBodies = new List<Rigidbody>();

        [Tooltip("For the special use case of having things connected to the grabbable that the hand should ignore while being held (good for doors and drawers) -> for always active use the [GrabbableIgnoreHands] Component")]
        public List<Collider> heldIgnoreColliders = new List<Collider>();

        [Space]

        [Tooltip("Whether or not the break call made only when holding with multiple hands - if this is false the break event can be called by forcing an object into a static collider"), HideInInspector]
        public bool pullApartBreakOnly = true;

        [AutoToggleHeader("Show Events")]
        public bool showEvents = true;
        [Space]
        [ShowIf("showEvents")]
        public UnityHandGrabEvent onGrab = new UnityHandGrabEvent();
        [ShowIf("showEvents")]
        public UnityHandGrabEvent onRelease = new UnityHandGrabEvent();

        [ShowIf("showEvents")]
        [Space, Space]
        public UnityHandGrabEvent onSqueeze = new UnityHandGrabEvent();
        [ShowIf("showEvents")]
        public UnityHandGrabEvent onUnsqueeze = new UnityHandGrabEvent();

        [Space, Space]
        [ShowIf("showEvents")]
        public UnityHandGrabEvent onHighlight = new UnityHandGrabEvent();
        [ShowIf("showEvents")]
        public UnityHandGrabEvent onUnhighlight = new UnityHandGrabEvent();
        [Space, Space]

        [ShowIf("showEvents")]
        public UnityHandGrabEvent OnJointBreak = new UnityHandGrabEvent();


        //Advanced Hidden Settings
        [HideInInspector, Tooltip("Lock hand in place on grab (This is a legacy setting, set hand kinematic on grab/release instead)")]
        public bool lockHandOnGrab = false;



        //For programmers <3
        public HandGrabEvent OnBeforeGrabEvent;
        public HandGrabEvent OnGrabEvent;

        public HandGrabEvent OnBeforeReleaseEvent;
        public HandGrabEvent OnReleaseEvent;
        public HandGrabEvent OnJointBreakEvent;

        public HandGrabEvent OnSqueezeEvent;
        public HandGrabEvent OnUnsqueezeEvent;

        public HandGrabEvent OnHighlightEvent;
        public HandGrabEvent OnUnhighlightEvent;

        public PlacePointEvent OnPlacePointHighlightEvent;
        public PlacePointEvent OnPlacePointUnhighlightEvent;
        public PlacePointEvent OnPlacePointAddEvent;
        public PlacePointEvent OnPlacePointRemoveEvent;


        /// <summary>Whether or not this object was force released (dropped) when last released (as opposed to being intentionally released)</summary>
        public bool wasForceReleased { get; protected internal set; } = false;
        public Hand lastHeldBy { get; protected set; } = null;


#if UNITY_EDITOR
        void EditorCopyGrabbable() {
            if(CopySettings != null)
                EditorUtility.CopySerialized(CopySettings, this);
        }
#endif


        public void Start()
        {
#if UNITY_EDITOR
            if (Selection.activeGameObject == gameObject)
            {
                Selection.activeGameObject = null;
                Debug.Log("Auto Hand: highlighting grabbables and rigidbodies in the inspector can cause lag and quality reduction at runtime in VR. (Automatically deselecting at runtime) Remove this code at any time.", this);
                editorSelected = true;
            }
            Application.quitting += () => { if (editorSelected && Selection.activeGameObject == null) Selection.activeGameObject = gameObject; };
#endif
        }

        public override void Awake() {
            base.Awake();

            if(makeChildrenGrabbable)
                MakeChildrenGrabbable();

            if(body.transform != transform && !body.gameObject.HasGrabbable(out Grabbable grab)) {
                var grabChild = body.gameObject.AddComponent<GrabbableChild>();
                grabChild.grabParent = this;
            }


            for(int i = 0; i < jointedBodies.Count; i++) {
                jointedParents.Add(jointedBodies[i].transform.parent != null ? jointedBodies[i].transform.parent : null);
                if(jointedBodies[i].gameObject.HasGrabbable(out var grabbable) && !jointedGrabbables.Contains(grabbable))
                    jointedGrabbables.Add(grabbable);
            }

            for(int i = 0; i < transform.childCount; i++) {
                ConnectGrabbablesRecursive(transform.GetChild(i));
            }

            void ConnectGrabbablesRecursive(Transform obj) {
                Grabbable grab1;
                for(int i = 0; i < obj.childCount; i++) {
                    if(obj.CanGetComponent<Grabbable>(out grab1)) {
                        if(!grabbableChildren.Contains(grab1))
                            grabbableChildren.Add(grab1);

                        if(!grab1.grabbableParents.Contains(this))
                            grab1.grabbableParents.Add(this);
                    }

                    ConnectGrabbablesRecursive(obj.GetChild(i));
                }
            }
            grabbableChildren = new List<Grabbable>(GetComponentsInChildren<Grabbable>(true));
            if(grabbableChildren.Contains(this))
                grabbableChildren.Remove(this);


            grabbableParents = new List<Grabbable>(GetComponentsInParent<Grabbable>(true));
            if(grabbableParents.Contains(this))
                grabbableParents.Remove(this);


            //This will automatically prevent grabbables from being placed into any place points that are children of this grabbable
            var placePointChildren = GetComponentsInChildren<PlacePoint>(true);
            for(int i = 0; i < placePointChildren.Length; i++) {

                if(placePointChildren[i].dontAllows == null)
                    placePointChildren[i].dontAllows = new List<Grabbable>();
                placePointChildren[i].dontAllows.Add(this);

                if(!childPlacePoints.Contains(placePointChildren[i]))
                    childPlacePoints.Add(placePointChildren[i]);

                if(grabbableParents.Count == 0)
                    placePointChildren[i].parentGrabbable = this;

                foreach(var grabbable in grabbableChildren) {
                    if(grabbable != this && !placePointChildren[i].dontAllows.Contains(grabbable))
                        placePointChildren[i].dontAllows.Add(grabbable);
                }

                foreach(var grabbable in grabbableParents) {
                    if(grabbable != this && !placePointChildren[i].dontAllows.Contains(grabbable))
                        placePointChildren[i].dontAllows.Add(grabbable);
                }
            }

            if(grabbableParents.Count == 0) {
                foreach(var grabbable in grabbableChildren) {
                    grabbable.rootGrabbable = this;
                }
                rootGrabbable = this;
            }
        }

        protected override void OnDisable() {
            base.OnDisable();
            if(heldBy.Count != 0)
                ForceHandsRelease();
        }

        protected virtual void OnDestroy()
        {
            beingDestroyed = true;

            if (heldBy.Count != 0)
                ForceHandsRelease();

            foreach(var routine in resetLayerRoutine) {
                if(routine.Value != null)
                    StopCoroutine(routine.Value);

                IgnoreHand(routine.Key, false);
            }
            resetLayerRoutine.Clear();

            MakeChildrenUngrabbable();
            if (placePoint != null && !placePoint.disablePlacePointOnPlace)
                placePoint.Remove(this);

            Destroy(poseCombiner);
        }

        public override void HeldFixedUpdate() {
            base.HeldFixedUpdate();

            if(wasIsGrabbable && !(isGrabbable || enabled))
                ForceHandsRelease();

            wasIsGrabbable = isGrabbable || enabled;
            lastUpdateTime = Time.fixedTime;
        }



        public void IgnoreColliders(Collider collider, bool ignore = true) {
            foreach(var col in grabColliders)
                Physics.IgnoreCollision(collider, col, ignore);
        }

        public void IgnoreColliders(Collider[] colliders, bool ignore = true)
        {
            foreach (var col in grabColliders)
                foreach (var col1 in colliders)
                    Physics.IgnoreCollision(col1, col, ignore);
        }
        public void IgnoreColliders(List<Collider> colliders, bool ignore = true)
        {
            foreach (var col in grabColliders)
                foreach (var col1 in colliders)
                    Physics.IgnoreCollision(col1, col, ignore);
        }


        void TryCreateHighlight(Material customMat, Hand hand)
        {

            var highlightMat = customMat != null ? customMat : hightlightMaterial;
            highlightMat = highlightMat != null ? highlightMat : hand.defaultHighlight;
            if (highlightMat != null && !highlightObjs.ContainsKey(highlightMat))
            {
                highlightObjs.Add(highlightMat, new List<GameObject>());
                AddHighlightObject(transform);


                bool AddHighlightObject(Transform obj)
                {

                    //This will stop the highlighting subsearch if there is another grabbable so that grabbable can create its own highlight settings/section
                    if (obj.CanGetComponent<Grabbable>(out var grab) && grab != this)
                        return false;
                    if((highlightObjs[highlightMat].Contains(obj.gameObject)))
                        return true;

                    for (int i = 0; i < obj.childCount; i++)
                    {
                        if (!AddHighlightObject(obj.GetChild(i)))
                            break;
                    }

                    MeshRenderer meshRenderer;
                    if (obj.CanGetComponent(out meshRenderer))
                    {
                        //Creates a slightly larger copy of the mesh and sets its material to highlight material
                        var highlightObj = new GameObject();
                        highlightObj.transform.parent = obj;
                        highlightObj.transform.localPosition = Vector3.zero;
                        highlightObj.transform.localRotation = Quaternion.identity;
                        highlightObj.transform.localScale = Vector3.one * 1.001f;
                        highlightObj.AddComponent<MeshFilter>().sharedMesh = obj.GetComponent<MeshFilter>().sharedMesh;
                        var highlightRenderer = highlightObj.AddComponent<MeshRenderer>();
                        var mats = new Material[meshRenderer.materials.Length];
                        for (int i = 0; i < mats.Length; i++)
                            mats[i] = highlightMat;
                        highlightRenderer.materials = mats;
                        highlightObjs[highlightMat].Add(highlightObj);
                    }

                    return true;
                }
            }

        }

        void ToggleHighlight(Hand hand, Material customMat, bool enableHighlight)
        {
            var highlightMat = customMat != null ? customMat : hightlightMaterial;
            highlightMat = highlightMat != null ? highlightMat : hand.defaultHighlight;
            if (highlightMat != null && highlightObjs.ContainsKey(highlightMat))
                for (int i = 0; i < highlightObjs[highlightMat].Count; i++)
                    highlightObjs[highlightMat][i].SetActive(enableHighlight);
        }

        /// <summary>Called when the hand starts aiming at this item for pickup</summary>
        protected internal virtual void Highlight(Hand hand, Material customMat = null, bool ignoreHighlightEvents = false) {
            if(!hightlighting) {
                hightlighting = true;
                if(!ignoreHighlightEvents && onHighlight != null)
                    onHighlight.Invoke(hand, this);
                if(!ignoreHighlightEvents && OnHighlightEvent != null)
                    OnHighlightEvent.Invoke(hand, this);
                TryCreateHighlight(customMat, hand);
                ToggleHighlight(hand, customMat, true);
            }
        }

        /// <summary>Called when the hand stops aiming at this item</summary>
        protected internal virtual void Unhighlight(Hand hand, Material customMat = null, bool ignoreHighlightEvents = false) {
            if(hightlighting) {
                if(!ignoreHighlightEvents && onUnhighlight != null)
                    onUnhighlight.Invoke(hand, this);
                if(!ignoreHighlightEvents && OnUnhighlightEvent != null)
                    OnUnhighlightEvent.Invoke(hand, this);
                hightlighting = false;
                ToggleHighlight(hand, customMat, false);
            }
        }





        /// <summary>Called by the hands Squeeze() function is called and this item is being held</summary>
        protected internal virtual void OnSqueeze(Hand hand) {
            OnSqueezeEvent?.Invoke(hand, this);
            onSqueeze?.Invoke(hand, this);
        }

        /// <summary>Called by the hands Unsqueeze() function is called and this item is being held</summary>
        protected internal virtual void OnUnsqueeze(Hand hand) {
            OnUnsqueezeEvent?.Invoke(hand, this);
            onUnsqueeze?.Invoke(hand, this);
        }

        /// <summary>Called by the hand when this item is started being grabbed</summary>
        protected internal virtual void OnBeforeGrab(Hand hand) {

            foreach(var collider in heldIgnoreColliders)
                hand.HandIgnoreCollider(collider, true);

            beingGrabbedBy.Add(hand);
            OnBeforeGrabEvent?.Invoke(hand, this);
            Unhighlight(hand, null);
            beingGrabbed = true;

            StartIgnoreRoutine(hand, false);
        }

        public bool IsOnlyBeingGrabbedBy(Hand hand) {
            return beingGrabbedBy.Contains(hand) && beingGrabbedBy.Count == 1;
        }


        protected void StartIgnoreRoutine(Hand hand, bool untilNone) {
            foreach(var grabbable in grabbableParents)
                if(grabbable.resetLayerRoutine.ContainsKey(hand)) {
                    if(grabbable.resetLayerRoutine[hand] != null)
                        grabbable.StopIgnoreRoutine(hand);
                    grabbable.resetLayerRoutine.Remove(hand);
                }

            foreach(var grabbable in grabbableChildren)
                if(grabbable.resetLayerRoutine.ContainsKey(hand)) {
                    if(grabbable.resetLayerRoutine[hand] != null)
                        grabbable.StopIgnoreRoutine(hand);
                    grabbable.resetLayerRoutine.Remove(hand);
                }

            if(resetLayerRoutine.ContainsKey(hand)) {
                if(resetLayerRoutine[hand] != null)
                    StopCoroutine(resetLayerRoutine[hand]);
                resetLayerRoutine.Remove(hand);
            }

            if(gameObject.activeInHierarchy) {
                if(untilNone)
                    resetLayerRoutine.Add(hand, StartCoroutine(IgnoreHandCollisionUntilNoneRoutine(hand, hand.maxGrabTime)));
                else
                    resetLayerRoutine.Add(hand, StartCoroutine(IgnoreHandCollision(hand, hand.maxGrabTime)));
            }

        }

        protected void StopIgnoreRoutine(Hand hand) {
            StopCoroutine(resetLayerRoutine[hand]);
        }

        /// <summary>Whether or not the hand can grab this grabbable</summary>
        public virtual bool CanGrab(HandBase hand) {
            return enabled && isGrabbable && (handType == HandType.both || (handType == HandType.left && hand.left) || (handType == HandType.right && !hand.left));
        }

        /// <summary>Called by the hand whenever this item is grabbed</summary>
        protected internal virtual void OnGrab(Hand hand) {

            if(beingGrabbedBy.Contains(hand))
                beingGrabbedBy.Remove(hand);

            if (rigidbodyDeactivated)
                ActivateRigidbody();

            if (lockHandOnGrab)
                hand.body.isKinematic = true;

            SetGrabbedRigidbodySettings();

            if(parentOnGrab) {
                rootTransform.parent = hand.transform.parent;
                foreach(var jointedBody in jointedBodies) {
                    jointedBody.transform.parent = hand.transform.parent;
                }
            }


            if(ignoreWeight) {
                if(!body.gameObject.CanGetComponent(out WeightlessFollower heldFollower))
                    heldFollower = body.gameObject.AddComponent<WeightlessFollower>();
                heldFollower?.Set(hand, this);
            }

            collisionTracker.enabled = true;

            heldBy?.Add(hand);
            placePoint?.Remove(this);
            onGrab?.Invoke(hand, this);
            OnGrabEvent?.Invoke(hand, this);

            wasForceReleased = false;
            beingGrabbed = false;
        }


        /// <summary>Called by the hand whenever this item is release</summary>
        protected internal virtual void OnRelease(Hand hand){

            if (heldBy.Contains(hand)) {
                bool canPlace = placePoint != null && placePoint.CanPlace(this);


                BreakHandConnection(hand);

                SetThrowVelocity(hand.ThrowVelocity(), hand.ThrowAngularVelocity());

                if(placePoint != null && canPlace)
                    placePoint.Place(this);



                OnReleaseEvent?.Invoke(hand, this);
                onRelease?.Invoke(hand, this);

                Unhighlight(hand, null);

            }
            else if(beingGrabbedBy.Contains(hand))
                hand.BreakGrabConnection();
        }

        /// <summary>Usually called through the release function. This function will release the connection to the hand and grabbable without calling the release events or applying throw force</summary>
        protected internal virtual void BreakHandConnection(Hand hand)
        {
            if(beingGrabbedBy.Contains(hand))
                beingGrabbedBy.Remove(hand);

            if (!heldBy.Remove(hand))
                return;

            ResetGrabbableAfterRlease();

            foreach(var collider in heldIgnoreColliders)
                hand.HandIgnoreCollider(collider, false);

            if (lockHandOnGrab)
                hand.body.isKinematic = false;

            if(ignoringHand.ContainsKey(hand))
                IgnoreHand(hand, false);

            if(gameObject.activeInHierarchy && !beingDestroyed)
                StartIgnoreRoutine(hand, true);

            if(beingGrabbedBy.Count == 0 && waitingToGrabHands.Count == 0)
                beingGrabbed = false;

            lastHeldBy = hand;
        }

        /// <summary>Tells each hand holding this object to release</summary>
        public virtual void HandsRelease() {
            for(int i = heldBy.Count - 1; i >= 0; i--)
                heldBy[i].Release();
        }

        /// <summary>Tells each hand holding this object to release</summary>
        public virtual void HandRelease(Hand hand) {
            if(heldBy.Contains(hand))
                hand.Release();
        }

        /// <summary>Forces all the hands on this object to relese without applying throw force or calling OnRelease event</summary>
        public virtual void ForceHandsRelease() {
            for(int i = waitingToGrabHands.Count - 1; i >= 0; i--) {
                waitingToGrabHands[i].BreakGrabConnection();
                waitingToGrabHands.RemoveAt(i);
            }

            for(int i = beingGrabbedBy.Count - 1; i >= 0; i--) {
                beingGrabbedBy[i].BreakGrabConnection();
            }

            for(int i = heldBy.Count - 1; i >= 0; i--) {
                wasForceReleased = true;
                ForceHandRelease(heldBy[i]);
            }
        }

        /// <summary>Forces all the hands on this object to relese without applying throw force</summary>
        public virtual void ForceHandRelease(Hand hand) {

            if(heldBy.Contains(hand)) {
                var throwMult = throwPower;
                throwPower = 0;
                wasForceReleased = true;
                hand.Release();
                throwPower = throwMult;
                if(body != null && !body.isKinematic)
                    body.linearVelocity = body.linearVelocity.normalized * Mathf.Clamp(body.linearVelocity.magnitude, 0, 1);
            }
            else if(beingGrabbedBy.Contains(hand))
                hand.BreakGrabConnection();
        }


        /// <summary>Called when the joint between the hand and this item is broken\n - Works to simulate pulling item apart event</summary>
        public virtual void OnHandJointBreak(Hand hand) {
            if(heldBy.Contains(hand)) {
                if (body != null){
                    body.WakeUp();
                    body.linearVelocity *= 0;
                    body.angularVelocity *= 0;
                }

                if(!pullApartBreakOnly) {
                    OnJointBreakEvent?.Invoke(hand, this);
                    OnJointBreak?.Invoke(hand, this);
                }
                if(pullApartBreakOnly && HeldCount() > 1) {
                    OnJointBreakEvent?.Invoke(hand, this);
                    OnJointBreak?.Invoke(hand, this);
                }

                ForceHandRelease(hand);

                if(heldBy.Count > 0)
                    heldBy[0].handFollow.SetHandLocation(heldBy[0].moveTo.position, heldBy[0].transform.rotation);
            }
        }

        //============================ GETTERS ============================
        //=================================================================
        //=================================================================


        /// <summary>Returns the list of hands that are currently holding this grabbables</summary>
        public List<Hand> GetHeldBy() {
            return heldBy;
        }

        /// <summary>Returns the list of hands that are currently holding this grabbables</summary>
        public List<Hand> GetHeldBy(bool includeChildGrabbables, bool includeParentrabbables) {
            List<Hand> hands = new List<Hand>();
            for(int i = 0; i < heldBy.Count; i++) {
                hands.Add(heldBy[i]);
            }

            if(includeChildGrabbables)
                for(int i = 0; i < grabbableChildren.Count; i++)
                    for(int j = 0; j < grabbableChildren[i].heldBy.Count; j++) 
                        hands.Add(grabbableChildren[i].heldBy[j]);

            if(includeParentrabbables)
                for(int i = 0; i < grabbableParents.Count; i++)
                    for(int j = 0; j < grabbableParents[i].heldBy.Count; j++)
                        hands.Add(grabbableParents[i].heldBy[j]);

            return hands;
        }

        /// <summary>Returns the hands local and held by jointed grabbables</summary>
        public List<Hand> GetJointedHeldBy()
        {
            List<Hand> hands = new List<Hand>();
            for (int i = 0; i < heldBy.Count; i++)
            {
                hands.Add(heldBy[i]);
            }
            for(int i = 0; i < jointedGrabbables.Count; i++) {
                for(int j = 0; j < jointedGrabbables[i].heldBy.Count; j++) {
                    hands.Add(jointedGrabbables[i].heldBy[j]);
                }
            }
            return hands;
        }


        /// <summary>Returns the number of hands currently holding this object [Call GetHeldBy() to get a list of the hand references]</summary>
        /// <param name="includedJointedCount">Whether or not to return the held count of only this grabbable, or the total of this grabbable and any jointed bodies with a grabbable attached</param>
        public virtual int HeldCount(bool includedJointedCount = true, bool includeChildGrabbables = true, bool includeParentrabbables = true) {
            var count = heldBy.Count;
            if(includedJointedCount)
                for(int i = 0; i < jointedGrabbables.Count; i++)
                    count += jointedGrabbables[i].HeldCount(false, true, true);

            if(includeChildGrabbables)
                for(int i = 0; i < grabbableChildren.Count; i++) 
                    count += grabbableChildren[i].HeldCount(false, false, false);

            if(includeParentrabbables)
                for(int i = 0; i < grabbableParents.Count; i++) 
                    count += grabbableParents[i].HeldCount(false, false, false);

            return count;
        }





        /// <summary>Returns true if this grabbable is currently being held</summary>
        public bool IsHeld() {
            return heldBy.Count > 0;
        }

        /// <summary>Returns true during hand grabbing coroutine</summary>
        public bool BeingGrabbed() {
            return beingGrabbed;
        }



        /// <summary>Plays haptic on each hand holding this grabbable</summary>
        public void PlayHapticVibration() {
            foreach(var hand in heldBy) {
                hand.PlayHapticVibration();
            }
        }

        /// <summary>Plays haptic on each hand holding this grabbable</summary>
        public void PlayHapticVibration(float duration = 0.025f) {
            foreach(var hand in heldBy) {
                hand.PlayHapticVibration(duration);
            }
        }

        /// <summary>Plays haptic on each hand holding this grabbable</summary>
        public void PlayHapticVibration(float duration, float amp = 0.5f) {
            foreach(var hand in heldBy) {
                hand.PlayHapticVibration(duration, amp);
            }
        }



        protected internal void SetThrowVelocity(Vector3 throwVel, Vector3 throwAngularVel) {
            if(body != null && !body.isKinematic && heldBy.Count == 0) {
                body.linearVelocity = throwVel * throwPower;
                if(!float.IsNaN(throwAngularVel.x) && !float.IsNaN(throwAngularVel.y) && !float.IsNaN(throwAngularVel.z))
                    body.angularVelocity = throwAngularVel;
            }
        }


        /// <summary>Returns the velocity of the grabbable, old function, recommend using body.velocity instead</summary>
        public Vector3 GetVelocity() {
            if (body == null)
                return Vector3.zero;
            return lastCenterOfMassPos - body.position;
        }


        /// <summary>Returns the angular velocity of the grabbable, old function, recommend using body.velocity instead</summary>
        public Vector3 GetAngularVelocity() {
            Quaternion deltaRotation = body.rotation * Quaternion.Inverse(lastCenterOfMassRot);
            deltaRotation.ToAngleAxis(out var angle, out var axis);
            angle *= Mathf.Deg2Rad;
            return (1.0f / Time.fixedDeltaTime) * angle / 1.2f * axis;
        }


        /// <summary>
        /// Adds a grabbable as a child to this one.
        /// A grabbable child is usually applied automatically when a grabbable parented below this another grabbable. 
        /// This connects the grabbable and allows events to be called and settings to be changed
        /// </summary>
        public void AddChildGrabbable(Grabbable grab) {
            if(!grabbableChildren.Contains(grab))
                grabbableChildren.Add(grab);
        }

        /// <summary>
        /// Removes a grabbable as a child to this one.
        /// </summary>
        public void RemoveChildGrabbable(Grabbable grab) {
            if(grabbableChildren.Contains(grab))
                grabbableChildren.Remove(grab);
        }

        /// <summary>Add a jointed rigidbody to this grabbable, important for continuity between a held object and it's jointed bodies</summary>
        public void AddJointedBody(Rigidbody body)
        {
            if (!jointedBodies.Contains(body))
            {
                if(body.gameObject.HasGrabbable(out Grabbable otherGrabbable)) {
                    if (otherGrabbable.parentOnGrab && HeldCount() > 0 && otherGrabbable.HeldCount() == 0 && rootTransform.parent != originalParent) { 
                        otherGrabbable.rootTransform.parent = rootTransform.parent;
                    }

                    jointedParents.Add(otherGrabbable.originalParent);
                    if(!jointedGrabbables.Contains(otherGrabbable))
                        jointedGrabbables.Add(otherGrabbable);

                }
                else
                    jointedParents.Add(body.transform.parent);

                jointedBodies.Add(body);

            }
        }

        /// <summary>Remove a jointed rigidbody in the jointedBodies list</summary>
        public void RemoveJointedBody(Rigidbody body) {
            if (jointedBodies.Contains(body))
            {
                var i = jointedBodies.IndexOf(body);

                jointedBodies.RemoveAt(i);

                if (body.gameObject.HasGrabbable(out var otherGrabbable)) {
                    if(jointedGrabbables.Contains(otherGrabbable)) {
                        jointedGrabbables.Remove(otherGrabbable);
                        if(otherGrabbable.HeldCount(false, true, true) == 0) {
                            otherGrabbable.rootTransform.parent = otherGrabbable.originalParent;
                            otherGrabbable.ResetGrabbedRigidbodySettings();
                        }
                    }

                }
                else
                    body.transform.parent = jointedParents[i];

                if(HeldCount() == 0 && rootTransform.parent != originalParent && parentOnGrab) {
                    ResetGrabbableAfterRlease();
                }

                jointedParents.RemoveAt(i);
            }
        }

        public void DoDestroy() {
            Destroy(gameObject);
        }

        /// <summary>Returns the total collision count of all this grabbable</summary>
        public int CollisionCount() {
            return collisionTracker.collisionObjects.Count;
        }

        /// <summary>Returns the total collision count of all the "jointed grabbables"</summary>
        public int JointedCollisionCount() {
            int count = 0;
            for(int i = 0; i < jointedGrabbables.Count; i++)
                count += jointedGrabbables[i].HeldCount();

            return count;
        }


        /// <summary>Sets the given place point to ignore this grabbables and all it's children</summary>
        public void PlacePointIgnore(PlacePoint point) {
            point.dontAllows.Add(rootGrabbable);
            foreach(var grabbable in rootGrabbable.grabbableChildren) {
                if(grabbable != this)
                    point.dontAllows.Add(grabbable);
            }
        }


        /// <summary>Sets the given place point to allow this grabbables and all it's children</summary>
        public void PlacePointAllow(PlacePoint point) {
            if(point.dontAllows.Contains(rootGrabbable))
                point.dontAllows.Remove(rootGrabbable);
            foreach(var grabbable in rootGrabbable.grabbableChildren) {
                if(grabbable != this && point.dontAllows.Contains(grabbable))
                    point.dontAllows.Remove(grabbable);
            }
        }


        //Adds a reference script to child colliders so they can be grabbed
        void MakeChildrenGrabbable() {
            for(int i = 0; i < transform.childCount; i++) {
                AddChildGrabbableRecursive(transform.GetChild(i));
            }

            void AddChildGrabbableRecursive(Transform obj) {
                if(obj.CanGetComponent(out Collider col) && col.isTrigger == false && !obj.CanGetComponent<IGrabbableEvents>(out _) && !obj.CanGetComponent<GrabbableChild>(out _) && !obj.CanGetComponent<PlacePoint>(out _)) {
                    var child = obj.gameObject.AddComponent<GrabbableChild>();
                    child.grabParent = this;
                }
                for(int i = 0; i < obj.childCount; i++) {
                    if(!obj.CanGetComponent<Grabbable>(out _))
                        AddChildGrabbableRecursive(obj.GetChild(i));
                }
            }
        }


        //Adds a reference script to child colliders so they can be grabbed
        void MakeChildrenUngrabbable() {
            for(int i = 0; i < transform.childCount; i++) {
                RemoveChildGrabbableRecursive(transform.GetChild(i));
            }

            void RemoveChildGrabbableRecursive(Transform obj) {
                if(obj.GetComponent<GrabbableChild>() && obj.GetComponent<GrabbableChild>().grabParent == this) {
                    Destroy(obj.gameObject.GetComponent<GrabbableChild>());
                }
                for(int i = 0; i < obj.childCount; i++) {
                    RemoveChildGrabbableRecursive(obj.GetChild(i));
                }
            }
        }


        bool rigidbodyGrabbedState;
        internal void SetGrabbedRigidbodySettings() {
            if(rigidbodyGrabbedState == false) {
                rigidbodyGrabbedState = true;

                if(body != null) {
                    body.collisionDetectionMode = body.isKinematic ? CollisionDetectionMode.ContinuousSpeculative : CollisionDetectionMode.ContinuousDynamic;
                    body.interpolation = RigidbodyInterpolation.None;
                    body.solverIterations = 100;
                    body.solverVelocityIterations = 100;

                    if(targetDrag == 0 && body.linearDamping < minHeldDrag) {
                        body.linearDamping = minHeldDrag;
                    }
                    if(targetAngularDrag == 0 && body.angularDamping < minHeldAngleDrag) {
                        body.angularDamping = minHeldAngleDrag;
                    }

                    if(targetMass == 0 && body.mass < minHeldMass) {
                        body.mass = minHeldMass;
                    }


                    for(int i = 0; i < jointedBodies.Count; i++) {
                        if(jointedBodies[i] != null && jointedBodies[i].gameObject.HasGrabbable(out var grab) && grab != this) {
                            grab.SetGrabbedRigidbodySettings();
                        }
                    }

                    if(heldNoFriction) {
                        var colliderMat = Resources.Load<PhysicsMaterial>("NoFriction");
                        SetPhysicsMaterial(colliderMat);
                    }

                }
            }
        }


        //Resets to original collision dection
        protected void ResetGrabbedRigidbodySettings() {
            if(rigidbodyGrabbedState) {
                if(body != null) {
                    body.collisionDetectionMode = detectionMode;
                    body.interpolation = startInterpolation;
                    body.solverIterations = Physics.defaultSolverIterations;
                    body.solverVelocityIterations = Physics.defaultSolverVelocityIterations;
                    body.linearDamping = targetDrag;
                    body.angularDamping = targetAngularDrag;
                    body.mass = targetMass;

                    if(heldNoFriction) {
                        ResetPhysicsMateiral();
                    }
                }

                rigidbodyGrabbedState = false;
                collisionTracker.enabled = false;
            }
        }


        /// <summary>INTERNAL - Sets the grabbables original layers</summary>
        protected internal void ResetGrabbableAfterRlease() {
            if(!beingDestroyed) {

                if(HeldCount() == 0 && gameObject.activeInHierarchy && parentOnGrab && (placePoint == null || !(placePoint.placedObject == this && placePoint.parentOnPlace))) {
                    rootTransform.parent = originalParent;
                }

                if(HeldCount() == 0) {
                    ResetGrabbedRigidbodySettings();
                }

                for(int i = 0; i < jointedBodies.Count; i++) {
                    if(jointedBodies[i].gameObject.HasGrabbable(out var grab)) {
                        if(grab.HeldCount() == 0) {
                            grab.rootTransform.parent = grab.originalParent;
                            grab.ResetGrabbedRigidbodySettings();
                        }
                        else if(parentOnGrab && grab.rootTransform.parent != grab.originalParent) {
                            rootTransform.parent = grab.rootTransform.parent;
                        }
                    }
                    else
                        jointedBodies[i].transform.parent = jointedParents[i];
                }
            }
        }

        public bool IsHolding(Rigidbody body)
        {

            foreach (var holding in heldBy)
            {
                if (holding.body == body)
                    return true;
            }

            return false;
        }

        public bool IsHolding(Hand hand)
        {
            foreach (var held in heldBy)
            {
                if (held == hand)
                    return true;
            }

            return false;
        }

        public virtual void OnHighlight(Hand hand) {
            Highlight(hand);
        }

        public virtual void OnUnhighlight(Hand hand) {
            OnUnhighlight(hand);
        }

        void IGrabbableEvents.OnGrab(Hand hand) {
            OnGrab(hand);
        }

        void IGrabbableEvents.OnRelease(Hand hand) {
            OnRelease(hand);
        }

        public Grabbable GetGrabbable() {
            return this;
        }

        public bool CanGrab(Hand hand) {
            if (hand == null)
                return false;
            return CanGrab(hand as HandBase);
        }


        internal void AddWaitingForGrab(Hand hand) {
            waitingToGrabHands.Add(hand);
        }

        internal void RemoveWaitingForGrab(Hand hand) {
            waitingToGrabHands.Remove(hand);
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/Grabbable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableChild.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 88c6f05faa8c57b4c83638f7f36c7c8f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;


namespace Autohand{
    /// <summary>
    /// THIS SCRIPT CAN BE ATTACHED TO A COLLIDER OBJECT TO REFERENCE A GRABBABLE BODY
    /// </summary>
    [DefaultExecutionOrder(1)]
    public class GrabbableChild : MonoBehaviour{
        public Grabbable grabParent;

        private void Start() {
            grabParent.SetGrabbableChild(this);
            if(gameObject.layer == LayerMask.NameToLayer("Default") || LayerMask.LayerToName(gameObject.layer) == "")
                gameObject.layer = LayerMask.NameToLayer(Hand.grabbableLayerNameDefault);

            var colliders = GetComponents<Collider>();
            foreach(Collider col in colliders) {
                if(col.isTrigger)
                    continue;

                if(!grabParent.grabColliders.Contains(col)) {
                    grabParent.grabColliders.Add(col);
                }
                if(col.gameObject.layer == LayerMask.NameToLayer("Default") || LayerMask.LayerToName(col.gameObject.layer) == "")
                    col.gameObject.layer = LayerMask.NameToLayer(Hand.grabbableLayerNameDefault);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableChild.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableCollisionHaptics.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 40c473564bfd20d4d86e896752dee195
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [RequireComponent(typeof(Grabbable))]
    public class GrabbableCollisionHaptics : MonoBehaviour {
        [Tooltip("The layers that cause the sound to play")]
        public LayerMask collisionTriggers = ~0;
        public float hapticAmp = 0.8f;
        public float velocityAmp = 0.5f;
        public float repeatDelay = 0.2f;
        public float maxDuration = 0.5f;
        [Tooltip("Source to play sound from")]
        public AnimationCurve velocityAmpCurve = AnimationCurve.Linear(0, 0, 1, 1);
        [Tooltip("Source to play sound from")]
        public AnimationCurve velocityDurationCurve = AnimationCurve.Linear(0, 0, 1, 1);

        Grabbable grab;
        Rigidbody body;
        bool canPlay = true;
        Coroutine playRoutine;

        private void Start() {
            body = GetComponent<Rigidbody>();
            grab = GetComponent<Grabbable>();

            //So the sound doesn't play when falling in place on start
            StartCoroutine(HapticPlayBuffer(1f));
        }

        private void OnDisable() {
            if(playRoutine != null)
                StopCoroutine(playRoutine);
        }

        void OnCollisionEnter(Collision collision) {
            if(canPlay && collisionTriggers == (collisionTriggers | (1 << collision.gameObject.layer))) {
                if(body != null) {
                    if(collision.collider.attachedRigidbody == null || collision.collider.attachedRigidbody.mass > 0.0000001f) {
                        var magnitude = collision.relativeVelocity.magnitude;
                        grab.PlayHapticVibration(Mathf.Clamp(velocityDurationCurve.Evaluate(magnitude), 0, maxDuration), velocityAmpCurve.Evaluate(magnitude * velocityAmp) * hapticAmp);
                        if(playRoutine != null)
                            StopCoroutine(playRoutine);
                        playRoutine = StartCoroutine(PlayBuffer());
                    }
                }
            }
        }

        IEnumerator PlayBuffer() {
            canPlay = false;
            yield return new WaitForSeconds(repeatDelay);
            canPlay = true;
            playRoutine = null;
        }

        IEnumerator HapticPlayBuffer(float time) {
            canPlay = false;
            yield return new WaitForSeconds(time);
            canPlay = true;
            playRoutine = null;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableCollisionHaptics.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b87d93cca04293d4cb59fd2373cfa5d4
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public struct SaveRigidbodyData {
        GameObject origin;
        float mass;
        float angularDrag;
        float drag;
        bool useGravity;
        bool isKinematic;
        RigidbodyInterpolation interpolation;
        CollisionDetectionMode collisionDetectionMode;
        RigidbodyConstraints constraints;

        public SaveRigidbodyData(Rigidbody from, bool removeBody = true) {
            origin = from.gameObject;
            mass = from.mass;
            drag = from.linearDamping;
            angularDrag = from.angularDamping;
            useGravity = from.useGravity;
            isKinematic = from.isKinematic;
            interpolation = from.interpolation;
            collisionDetectionMode = from.collisionDetectionMode;
            constraints = from.constraints;
            if(removeBody)
                GameObject.Destroy(from);
        }
        public SaveRigidbodyData(SaveRigidbodyData from) {
            origin = from.origin;
            mass = from.mass;
            drag = from.drag;
            angularDrag = from.angularDrag;
            useGravity = from.useGravity;
            isKinematic = from.isKinematic;
            interpolation = from.interpolation;
            collisionDetectionMode = from.collisionDetectionMode;
            constraints = from.constraints;
        }

        public Transform GetOrigin() {
            return origin.transform;
        }

        public bool IsSet() {
            return origin != null;
        }

        public Rigidbody ReloadRigidbody() {
            if(origin != null) {
                if(origin.CanGetComponent<Rigidbody>(out var currBody))
                    return currBody;
                var from = origin.AddComponent<Rigidbody>();
                if(from != null) {
                    from.mass = mass;
                    from.linearDamping = drag;
                    from.angularDamping = angularDrag;
                    from.useGravity = useGravity;
                    from.isKinematic = isKinematic;
                    from.interpolation = interpolation;
                    from.collisionDetectionMode = collisionDetectionMode;
                    from.constraints = constraints;
                    origin = null;
                    return from;
                }
            }
            return null;
        }
    }


    public static class GrabbableExtensions {

        public static bool GetGrabPose(this Grabbable grabbable, Hand hand, out GrabbablePose grabPose) {
            grabPose = null;
            if (grabbable == null)
            {
                return false;
            }
            
            if(grabbable.GetSavedPose(out var poseCombiner) && poseCombiner.CanSetPose(hand, grabbable)) {
                grabPose = poseCombiner.GetClosestPose(hand, grabbable);
                return true;
            }

            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableExtensions.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableExtraEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 35d8771252739254ea3bf5819ffad032
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [RequireComponent(typeof(Grabbable))]
    public class GrabbableExtraEvents : MonoBehaviour {
        public UnityHandGrabEvent OnFirstGrab;
        public UnityHandGrabEvent OnLastRelease;
        public UnityHandGrabEvent OnTwoHandedGrab;
        public UnityHandGrabEvent OnTwoHandedRelease;

        [Space]
        public UnityPlacePointEvent OnPlacePointAdd;
        public UnityPlacePointEvent OnPlacePointRemove;
        public UnityPlacePointEvent OnPlacePointHighlight;
        public UnityPlacePointEvent OnPlacePointUnhighlight;


        Grabbable grab;

        void OnEnable() {
            grab = GetComponent<Grabbable>();
            grab.OnGrabEvent += Grab;
            grab.OnReleaseEvent += Release;
            grab.OnPlacePointAddEvent += PlacePointAdd;
            grab.OnPlacePointRemoveEvent += PlacePointRemove;
            grab.OnPlacePointHighlightEvent += PlacePointHighlight;
            grab.OnPlacePointUnhighlightEvent += PlacePointUnhighlight;
        }

        void OnDisable() {
            grab = grab ?? GetComponent<Grabbable>();
            grab.OnGrabEvent -= Grab;
            grab.OnReleaseEvent -= Release;
            grab.OnPlacePointAddEvent -= PlacePointAdd;
            grab.OnPlacePointRemoveEvent -= PlacePointRemove;
            grab.OnPlacePointHighlightEvent -= PlacePointHighlight;
            grab.OnPlacePointUnhighlightEvent -= PlacePointUnhighlight;


        }

        public void PlacePointAdd(PlacePoint point, Grabbable grab) {
            OnPlacePointAdd?.Invoke(point, grab);
        }

        public void PlacePointRemove(PlacePoint point, Grabbable grab) {
            OnPlacePointRemove?.Invoke(point, grab);
        }

        public void PlacePointHighlight(PlacePoint point, Grabbable grab) {
            OnPlacePointHighlight?.Invoke(point, grab);
        }

        public void PlacePointUnhighlight(PlacePoint point, Grabbable grab) {
            OnPlacePointUnhighlight?.Invoke(point, grab);
        }

        public void Grab(Hand hand, Grabbable grab) {
            if(grab.HeldCount() == 1) {
                OnFirstGrab?.Invoke(hand, grab);
            }
            if(grab.HeldCount() == 2) {
                OnTwoHandedGrab?.Invoke(hand, grab);
            }
        }

        public void Release(Hand hand, Grabbable grab) {
            if(grab.HeldCount() == 0) {
                OnLastRelease?.Invoke(hand, grab);
            }
            if(grab.HeldCount() == 1) {
                OnTwoHandedRelease?.Invoke(hand, grab);
            }
        }
    }

}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableExtraEvents.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableOnlyJoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 87627214e167368439a3b48bdbc35bce
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    //This component will freeze an attached grabbable joint with a fixed joint while not being held 
    [RequireComponent(typeof(Grabbable))]
    public class GrabbableOnlyJoint : MonoBehaviour {
        public Grabbable jointedGrabbable;
        public bool resetOnRelease = true;

        Grabbable localGrabbable;

        Joint freezeJoint;
        Vector3 localStartPosition;
        Quaternion localStartRotation;

        void Start() {
            localGrabbable = GetComponent<Grabbable>();
            localGrabbable.OnGrabEvent += OnGrab;
            localGrabbable.OnReleaseEvent += OnRelease;
            localStartPosition = jointedGrabbable.transform.InverseTransformPoint(transform.position);
            localStartRotation = Quaternion.Inverse(jointedGrabbable.transform.rotation) * transform.rotation;

            freezeJoint = localGrabbable.gameObject.AddComponent<FixedJoint>().GetCopyOf(Resources.Load<FixedJoint>("DefaultJoint"));
            freezeJoint.anchor = Vector3.zero;
            freezeJoint.breakForce = float.PositiveInfinity;
            freezeJoint.breakTorque = float.PositiveInfinity;
            freezeJoint.connectedBody = jointedGrabbable.body;
        }

        void OnGrab(Hand hand, Grabbable grab) {
            if(grab.GetHeldBy().Count == 1) {
                Destroy(freezeJoint);
                freezeJoint = null;
            }
        }
        void OnRelease(Hand hand, Grabbable grab) {
            if(grab.GetHeldBy().Count == 0) {
                transform.position = jointedGrabbable.transform.TransformPoint(localStartPosition);
                transform.rotation = jointedGrabbable.transform.rotation * localStartRotation;
                localGrabbable.body.position = transform.position;
                localGrabbable.body.rotation = transform.rotation;

                Invoke("CreateJoint", Time.fixedDeltaTime + Time.deltaTime);
            }
        }

        private void LateUpdate() {
            if(freezeJoint != null) {
                transform.position = jointedGrabbable.transform.TransformPoint(localStartPosition);
                transform.rotation = jointedGrabbable.transform.rotation * localStartRotation;
            }
        }

        void CreateJoint() {
            freezeJoint = localGrabbable.gameObject.AddComponent<FixedJoint>().GetCopyOf(Resources.Load<FixedJoint>("DefaultJoint"));
            freezeJoint.anchor = Vector3.zero;
            freezeJoint.breakForce = float.PositiveInfinity;
            freezeJoint.breakTorque = float.PositiveInfinity;
            freezeJoint.connectedBody = jointedGrabbable.body;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableOnlyJoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePose.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5143e42808965614a9bb64f4880aaf33
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using NaughtyAttributes;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Autohand{


#if UNITY_EDITOR
    [CanEditMultipleObjects]
#endif
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/custom-poses"), DefaultExecutionOrder(1000)]
    public class GrabbablePose : HandPoseDataContainer{
        public bool poseEnabled = true;
        [Tooltip("Whether or not this pose can be used by both hands at once or only one hand at a time")]
        public bool singleHanded = false;


        [AutoSmallHeader("Advanced Settings")]
        public bool showAdvanced = true;
        public float positionWeight = 1;
        public float rotationWeight = 1;
        [Tooltip("These poses will only be enabled when this pose is active. Great for secondary poses like holding the front of a gun with your second hand, only while holding the trigger")]
        public GrabbablePose[] linkedPoses;


        protected HandPoseData poseDataNonAlloc;

        public Grabbable grabbable { get; internal set; }
        public List<Hand> posingHands { get; protected set; }



        protected virtual void Awake()  {
            posingHands = new List<Hand>();
            if (poseScriptable != null)
            {
                if (poseScriptable.leftSaved)
                    leftPoseSet = true;
                if (poseScriptable.rightSaved)
                    rightPoseSet = true;
            }

            for (int i = 0; i < linkedPoses.Length; i++)
                linkedPoses[i].poseEnabled = false;

            if(leftPoseSet)
                poseDataNonAlloc = new HandPoseData(ref leftPose);
            else if(rightPoseSet)
                poseDataNonAlloc = new HandPoseData(ref rightPose);
        }

        protected virtual void OnEnable() {
            grabbable.onRelease.AddListener(OnRelease);
        }

        protected virtual void OnDisable() {
            grabbable.onRelease.RemoveListener(OnRelease);
        }

        protected virtual void OnRelease(Hand hand, Grabbable grab) {
            if(posingHands.Contains(hand))
                posingHands.Remove(hand);
        }


        public bool CanSetPose(Hand hand, Grabbable grab) {
            if(singleHanded && posingHands.Count > 0 && !posingHands.Contains(hand) && !(grab.singleHandOnly && grab.allowHeldSwapping))
                return false;
            if(hand.poseIndex != poseIndex)
                return false;
            if(hand.left && !leftPoseSet)
                return false;
            if(!hand.left && !rightPoseSet)
                return false;

            return poseEnabled;
        }


        public virtual ref HandPoseData GetHandPoseData(Hand hand) {
            if(poseScriptable != null) {
                if(hand.left)
                    return ref poseScriptable.leftPose;
                else
                    return ref poseScriptable.rightPose;
            }
            
            if(hand.left)
                return ref leftPose;
            else                 
                return ref rightPose;
        }


        /// <summary>Sets the hand to this pose, make sure to check CanSetPose() flag for proper use</summary>
        /// <param name="isProjection">for pose projections, so they wont fill condition for single handed before grab</param>
        public virtual void SetHandPose(Hand hand, bool isProjection = false) {
            if(!isProjection) {
                if(!posingHands.Contains(hand))
                    posingHands.Add(hand);

                for(int i = 0; i < linkedPoses.Length; i++)
                    linkedPoses[i].poseEnabled = true;
            }

            GetHandPoseData(hand).SetPose(hand, transform);
        }


        public virtual void CancelHandPose(Hand hand) {
            if(posingHands.Contains(hand)) {
                posingHands.Remove(hand);
            }

            for(int i = 0; i < linkedPoses.Length; i++)
                linkedPoses[i].poseEnabled = false;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePose.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseAdvanced.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c49b27d5a0e0d4dd8ab20e2bed42e835
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using NaughtyAttributes;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Autohand {
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/custom-poses#advanced-grabbable-pose")]
    public class GrabbablePoseAdvanced : GrabbablePose{
        [Tooltip("Usually this can be left empty, used to create a different center point if the objects transform isn't ceneterd for the prefered rotation/movement axis")]
        public Transform centerObject;
        [Space]
        [Tooltip("You want this set so the disc gizmo is around the axis you want the hand to rotate, or that the line is straight through the axis you want to move")]
        public Vector3 up = Vector3.up;
        [Space, Tooltip("Whether or not to automatically allow for the opposite direction pose to be automatically applied (I.E. Should I be able to grab my hammer only with the head facing up, or in both directions?)")]
        public bool useInvertPose = false;

        [Space]
        [Tooltip("The minimum angle rotation around the included directions")]
        public int minAngle = 0;
        [Tooltip("The maximum angle rotation around the included directions")]
        public int maxAngle = 360;
        [Space]
        [Tooltip("The minimum distance allowed from the saved posed along the included directions")]
        public float maxRange = 0;
        [Tooltip("The maximum distance allowed from the saved posed along the included directions")]
        public float minRange = 0;

        [Header("Requires Gizmos Enabled")]
        [Tooltip("Helps test pose by setting the angle of the editor hand, REQUIRES GIZMOS ENABLED")]
        public int testAngle = 0;
        [Tooltip("Helps test pose by setting the range position of the editor hand, REQUIRES GIZMOS ENABLED")]
        public float testRange = 0;


        int lastAngle = 0;
        float lastRange = 0;

        Vector3 pregrabPos;
        Quaternion pregrabRot;
        Transform tempContainer;
        Transform handMatch;
        Transform getTransform;


        protected override void Awake() {
            base.Awake();
            if (minAngle > maxAngle) {
                var tempAngle = minAngle;
                minAngle = maxAngle;
                maxAngle = tempAngle;
            }
            if (minRange > maxRange) {
                var temp = minRange;
                minRange = maxRange;
                maxRange = temp;
            }
        }

        public override ref HandPoseData GetHandPoseData(Hand hand) {
            pregrabPos = hand.transform.position;
            pregrabRot = hand.transform.rotation;

            var preGrabPose = new HandPoseData(hand, transform);
            base.GetHandPoseData(hand).SetPose(hand, transform);

            getTransform = GetTransform();

            tempContainer = AutoHandExtensions.transformRuler;
            tempContainer.rotation = Quaternion.identity;
            tempContainer.position = getTransform.position;
            tempContainer.localScale = getTransform.lossyScale;

            handMatch = AutoHandExtensions.transformRulerChild;
            handMatch.position = hand.transform.position;
            handMatch.rotation = hand.transform.rotation;

            tempContainer.rotation = getTransform.rotation;


            var closestRotation = GetClosestRotation(hand, up, useInvertPose);

            tempContainer.rotation = closestRotation;

            var closestPosition = GetClosestPosition(up);

            tempContainer.position = closestPosition;
            hand.transform.position = handMatch.position;
            hand.transform.rotation = handMatch.rotation;

            //var pose = new HandPoseData(hand, transform);
            poseDataNonAlloc.SavePose(hand, transform);
            preGrabPose.SetPose(hand);

#if UNITY_EDITOR
            if(Application.isEditor && !Application.isPlaying)
                DestroyImmediate(tempContainer.gameObject);
#endif

            return ref poseDataNonAlloc;
        }

        public Quaternion GetClosestRotation(Hand hand, Vector3 up, bool addInverse) {
            tempContainer = AutoHandExtensions.transformRuler;
            tempContainer.rotation = Quaternion.identity;
            tempContainer.position = getTransform.position;
            tempContainer.localScale = getTransform.lossyScale;

            handMatch = AutoHandExtensions.transformRulerChild;
            handMatch.position = hand.transform.position;
            handMatch.rotation = hand.transform.rotation;

            tempContainer.rotation = getTransform.rotation;
            Quaternion closestRotation = tempContainer.rotation;

            //if((minAngle != 0 || maxAngle != 0 || addInverse) && !(minAngle == maxAngle))
           // {
                float closestDistance = float.MaxValue;
                float closestIndex = 0;

                var iteration = (Mathf.Abs(minAngle) + Mathf.Abs(maxAngle))/10f;
                if(iteration == 0)
                    iteration = 1;
                var additionalDirection = Vector3.zero;
                if(up.x != 0)
                    additionalDirection = new Vector3(0, 1, 0);
                else if(up.y != 0)
                    additionalDirection = new Vector3(1, 0, 0);
                else if(up.z != 0)
                    additionalDirection = new Vector3(0, 0, 1);

                for (float i = minAngle; i <= maxAngle; i += iteration) {
                    tempContainer.eulerAngles = getTransform.rotation * up;
                    tempContainer.RotateAround(getTransform.position, getTransform.rotation * up, i);


                    var distance = Vector3.Distance(handMatch.position, pregrabPos);
                    distance += Quaternion.Angle(handMatch.rotation, pregrabRot)/180f;
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestRotation = tempContainer.rotation;
                        closestIndex = i;
                    }
                }

                for (float i = -iteration/2; i < iteration/2; i += iteration/10f) {
                    tempContainer.eulerAngles = getTransform.rotation * up;
                    tempContainer.RotateAround(getTransform.position, getTransform.rotation * up, closestIndex + i);

                    var distance = Vector3.Distance(handMatch.position, pregrabPos);
                    distance += Quaternion.Angle(handMatch.rotation, pregrabRot)/180f;
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestRotation = tempContainer.rotation;
                        closestIndex = i;
                    }
                }

                if(addInverse) {
                    var closestInverseDistance = float.MaxValue;
                    float closestInverseIndex = 0;
                    for(float i = minAngle; i <= maxAngle; i += iteration) {
                        tempContainer.eulerAngles = getTransform.rotation * up;
                        tempContainer.RotateAround(getTransform.position, getTransform.rotation * up, i);
                        tempContainer.RotateAround(getTransform.position, getTransform.rotation * additionalDirection, 180);


                        var distance = Vector3.Distance(handMatch.position, pregrabPos);
                        distance += Quaternion.Angle(handMatch.rotation, pregrabRot)/180f;
                        if(distance < closestInverseDistance) {
                            closestInverseDistance = distance; 
                            if(closestInverseDistance < closestDistance)
                                closestRotation = tempContainer.rotation;
                            closestInverseIndex = i;
                        }
                    }

                    for(float i = -iteration / 2; i < iteration / 2; i += iteration / 10f) {
                        tempContainer.eulerAngles = getTransform.rotation * up;
                        tempContainer.RotateAround(getTransform.position, getTransform.rotation * up, closestInverseIndex + i);
                        tempContainer.RotateAround(getTransform.position, getTransform.rotation * additionalDirection, 180);

                        var distance = Vector3.Distance(handMatch.position, pregrabPos);
                        distance += Quaternion.Angle(handMatch.rotation, pregrabRot) / 180f;
                        if(distance < closestInverseDistance) {
                            closestInverseDistance = distance;
                            if(closestInverseDistance < closestDistance)
                                closestRotation = tempContainer.rotation;
                            closestInverseIndex = i;
                        }
                    }
                }

            //}

            return closestRotation;
        }


        public Vector3 GetClosestPosition(Vector3 up)
        {

            Vector3 closestPosition = tempContainer.position;

            if (minRange != 0 || maxRange != 0)
            {
                float closestDistance = float.MaxValue;
                float closestIndex = 0;

                var minRangeVec = getTransform.position + getTransform.rotation * up * minRange;
                var maxRangeVec = getTransform.position + getTransform.rotation * up * maxRange;

                for (int i = 0; i < 10; i++)
                {
                    tempContainer.position = Vector3.Lerp(minRangeVec, maxRangeVec, i / 10f);

                    var distance = Vector3.Distance(handMatch.position, pregrabPos);
                    if (distance < closestDistance)
                    {
                        closestDistance = distance;
                        closestPosition = tempContainer.position;
                        closestIndex = i;
                    }
                }

                for (int i = -5; i < 5; i++)
                {
                    tempContainer.position = Vector3.Lerp(minRangeVec, maxRangeVec, closestIndex + i / 100f);

                    var distance = Vector3.Distance(handMatch.position, pregrabPos);
                    if (distance < closestDistance)
                    {
                        closestDistance = distance;
                        closestPosition = tempContainer.position;
                    }
                }
            }

            return closestPosition;
        }

        public HandPoseData GetHandPoseData(Hand hand, int angle, float range) {
            base.GetHandPoseData(hand).SetPosition(hand, transform);

            var getTransform = GetTransform();

            var tempContainer = AutoHandExtensions.transformRuler;
            tempContainer.rotation = Quaternion.identity;
            tempContainer.position = getTransform.position;
            tempContainer.localScale = getTransform.lossyScale;

            var handMatch = AutoHandExtensions.transformRulerChild;
            handMatch.position = hand.transform.position;
            handMatch.rotation = hand.transform.rotation;

            tempContainer.rotation = getTransform.rotation;

            tempContainer.eulerAngles = getTransform.rotation * up;
            tempContainer.RotateAround(tempContainer.transform.position, getTransform.rotation * up, angle);
            tempContainer.transform.position = getTransform.position +  getTransform.rotation * up * range;

            hand.transform.position = handMatch.position;
            hand.transform.rotation = handMatch.rotation;
            tempContainer.localScale = Vector3.one;

#if UNITY_EDITOR
            if(Application.isEditor)
                DestroyImmediate(tempContainer.gameObject);
#endif

            return base.GetHandPoseData(hand);
        }

        Transform GetTransform() {
            return centerObject != null ? centerObject : transform;
        }

#if UNITY_EDITOR
        protected override void OnDrawGizmosSelected() {
            if(Application.isPlaying)
                return;

            base.OnDrawGizmosSelected();

            var usingTransform = GetTransform();
            var radius = 0.1f;
            
            var pose = HasPose(false) ? rightPose : leftPose;

            var handDir = Quaternion.AngleAxis(minAngle, usingTransform.rotation * up) * pose.handOffset.normalized;
            Handles.DrawWireArc(usingTransform.position, usingTransform.rotation * up, handDir, maxAngle-minAngle, radius);
            
            var minRangeVec = usingTransform.position + usingTransform.rotation * up * minRange;
            var maxRangeVec = usingTransform.position + usingTransform.rotation * up * maxRange;
            Gizmos.DrawLine(usingTransform.position, minRangeVec);
            Gizmos.DrawLine(usingTransform.position, maxRangeVec);

            EditorTestValues(editorHand);
        }

        public void EditorTestValues(Hand editorHand) {

            if(grabbable == null)
                grabbable = GetComponentInParent<Grabbable>();

            if(editorHand != null && (testAngle != lastAngle || testRange != lastRange) && (lastAngle != 0 || lastRange != 0)) {
                testAngle = Mathf.Clamp(testAngle, minAngle, maxAngle);
                testRange = Mathf.Clamp(testRange, minRange, maxRange);

                if(minAngle > maxAngle) {
                    var temp = minAngle;
                    minAngle = maxAngle;
                    maxAngle = temp;
                }
                if(minRange > maxRange) {
                    var temp = minRange;
                    minRange = maxRange;
                    maxRange = temp;
                }

                GetHandPoseData(editorHand, testAngle, testRange);
            }

            lastAngle = testAngle;
            lastRange = testRange;
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseAdvanced.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseCombiner.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ac82bc3766612f34da61b06da6008fa9
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    public class GrabbablePoseCombiner : MonoBehaviour{
        public List<GrabbablePose> poses = new List<GrabbablePose>();


        public bool CanSetPose(Hand hand, Grabbable grab) {
            foreach(var pose in poses) {
                if(pose != null && pose.CanSetPose(hand, grab))
                    return true;
            }
            return false;
        }

        public void AddPose(GrabbablePose pose) {
            if(!poses.Contains(pose))
                poses.Add(pose);
        }

        private void OnDestroy()
        {
            for (int i = poses.Count - 1; i >= 0; i--)
            {
                Destroy(poses[i]);
            }
        }

        public GrabbablePose GetClosestPose(Hand hand, Grabbable grab) {
            List<GrabbablePose> possiblePoses = new List<GrabbablePose>();
            foreach(var handPose in this.poses)
                if(handPose != null && handPose.CanSetPose(hand, grab))
                    possiblePoses.Add(handPose);
            
            float closestValue = float.MaxValue;
            int closestIndex = 0;

            var handPosition = hand.transform.position;
            var handRotation = hand.transform.rotation;


            for (int i = 0; i < possiblePoses.Count; i++){

                var pose = possiblePoses[i].GetHandPoseData(hand);
                var poseGlobalPosition = possiblePoses[i].transform.TransformPoint(pose.handOffset);
                var poseGlobalRotation = possiblePoses[i].transform.rotation * pose.localQuaternionOffset;

                var distance = Vector3.Distance(poseGlobalPosition, handPosition);
                var angleDistance = Quaternion.Angle(poseGlobalRotation, handRotation) / 270f;

                var closenessValue = distance / possiblePoses[i].positionWeight + angleDistance / possiblePoses[i].rotationWeight;
                if(closenessValue < closestValue) {
                    closestIndex = i;
                    closestValue = closenessValue;
                }
            }

            hand.transform.position = handPosition;
            hand.transform.rotation = handRotation;
            Physics.SyncTransforms();

            return possiblePoses[closestIndex];
        }

        internal int PoseCount() {
            return poses.Count;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseCombiner.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseGizmo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0c0eed604b5d993409380c03ea7c6408
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace Autohand {
    public class GrabbablePoseGizmo : MonoBehaviour {
        public GrabbablePose grabbablePose;
        public bool showRightPose = true;
        public bool showLeftPose = false;

        private void OnDrawGizmos() {
            if(grabbablePose == null)
                return;

            if(grabbablePose.rightPoseSet && showRightPose) {
                foreach(var fingerPose in grabbablePose.rightPose.fingerPoses) {
                    if(fingerPose.isSet) {
                        DrawFingerPoseExample(fingerPose, grabbablePose.rightPose.GetHandToWorldMatrix(grabbablePose.transform), Color.cyan);
                    }
                }

                DrawHandShapeExample(grabbablePose.rightPose, grabbablePose.transform.localToWorldMatrix, Color.cyan);
            }

            if(grabbablePose.leftPoseSet && showLeftPose) {
                foreach(var fingerPose in grabbablePose.leftPose.fingerPoses) {
                    if(fingerPose.isSet) {
                        DrawFingerPoseExample(fingerPose, grabbablePose.leftPose.GetHandToWorldMatrix(grabbablePose.transform), Color.cyan);
                    }
                }
            }
        }

        private void DrawFingerPoseRecursiveExample(FingerPoseData fingerPose, Matrix4x4 handToWorld, Color color) {
            Matrix4x4 parentMatrix = handToWorld;
            Matrix4x4 prevMatrix = parentMatrix;
            
            for(int i = 0; i < fingerPose.poseRelativeMatrix.Length; i++) {
                Matrix4x4 jointMatrix = prevMatrix * fingerPose.poseRelativeMatrix[i];
                Vector3 position = AutoHandExtensions.ExtractPosition(ref jointMatrix);
                var newColor = color * (i + 1f)/3f;
                newColor.a = 1f;
                Gizmos.color = newColor;
                Gizmos.DrawWireSphere(position, 0.004f);
                if(i > 0)
                    Gizmos.DrawLine(AutoHandExtensions.ExtractPosition(ref prevMatrix), position);

                prevMatrix = jointMatrix; 
            }
        }

        public static void DrawHandGizmo(HandPoseData pose, Transform relativeTo, Color color) {
            var handGlobalMatrix = pose.GetHandToWorldMatrix(relativeTo);
            foreach(var fingerPose in pose.fingerPoses)
                if(fingerPose.isSet)
                    DrawFingerPoseExample(fingerPose, handGlobalMatrix, color);
            DrawHandShapeExample(pose, handGlobalMatrix, color);

        }

        public static void DrawHandGizmo(HandPoseData pose, Matrix4x4 relativeTo, Color color) {
            var handGlobalMatrix = relativeTo;
            foreach(var fingerPose in pose.fingerPoses)
                if(fingerPose.isSet)
                    DrawFingerPoseExample(fingerPose, handGlobalMatrix, color);
            DrawHandShapeExample(pose, handGlobalMatrix, color);

        }


        public static void DebugDrawFingerPose(FingerPoseData fingerPose, Matrix4x4 handToWorld, Color color) {

            Matrix4x4 handGlobalMatrix = handToWorld;
            var kuckleToHandMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            var middleToKnuckleMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.middle];
            var distalToMiddleMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.distal];
            var tipToDistalMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.tip];

            var knuckleGlobalMatrix = handGlobalMatrix * kuckleToHandMatrix;
            var middleGlobalMatrix = knuckleGlobalMatrix * middleToKnuckleMatrix;
            var distalGlobalMatrix = middleGlobalMatrix * distalToMiddleMatrix;
            var tipGlobalMatrix = distalGlobalMatrix * tipToDistalMatrix;

            var handPosition = AutoHandExtensions.ExtractPosition(ref handGlobalMatrix);
            var knucklePosition = AutoHandExtensions.ExtractPosition(ref knuckleGlobalMatrix);
            var middlePosition = AutoHandExtensions.ExtractPosition(ref middleGlobalMatrix);
            var distalPosition = AutoHandExtensions.ExtractPosition(ref distalGlobalMatrix);
            var tipPosition = AutoHandExtensions.ExtractPosition(ref tipGlobalMatrix);

            Debug.DrawLine(handPosition, knucklePosition, color);
            Debug.DrawLine(knucklePosition, middlePosition, color);
            Debug.DrawLine(middlePosition, distalPosition, color);
            Debug.DrawLine(distalPosition, tipPosition, color);
        }

            public static void DrawFingerPoseExample(FingerPoseData fingerPose, Matrix4x4 handToWorld,  Color color) {
           // grabbableToWorld = Matrix4x4.TRS(grabbableToWorld.ExtractPosition(), grabbableToWorld.ExtractRotation(), Vector3.one);
           // handToGrabbable = Matrix4x4.TRS(handToGrabbable.ExtractPosition(), handToGrabbable.ExtractRotation(), Vector3.one);
           
            Matrix4x4 handGlobalMatrix = handToWorld;
            var kuckleToHandMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            var middleToKnuckleMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.middle];
            var distalToMiddleMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.distal];
            var tipToDistalMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.tip];

            var knuckleGlobalMatrix = handGlobalMatrix * kuckleToHandMatrix;
            var middleGlobalMatrix = knuckleGlobalMatrix * middleToKnuckleMatrix;
            var distalGlobalMatrix = middleGlobalMatrix * distalToMiddleMatrix;
            var tipGlobalMatrix = distalGlobalMatrix * tipToDistalMatrix;

            var handPosition = AutoHandExtensions.ExtractPosition(ref handGlobalMatrix);
            var knucklePosition = AutoHandExtensions.ExtractPosition(ref knuckleGlobalMatrix);
            var middlePosition = AutoHandExtensions.ExtractPosition(ref middleGlobalMatrix);
            var distalPosition = AutoHandExtensions.ExtractPosition(ref distalGlobalMatrix);
            var tipPosition = AutoHandExtensions.ExtractPosition(ref tipGlobalMatrix);


            Gizmos.color = color;
            Gizmos.DrawLine(handPosition, knucklePosition);
            Gizmos.DrawLine(knucklePosition, middlePosition);
            Gizmos.DrawLine(middlePosition, distalPosition);
            Gizmos.DrawLine(distalPosition, tipPosition);
        }

        public static void DrawHandShapeExample(HandPoseData pose, Matrix4x4 handGlobalMatrix, Color color) {
            var thumbKnuckleGlobalMatrix = handGlobalMatrix * pose.fingerPoses[(int)FingerEnum.thumb].poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            var indexKnuckleGlobalMatrix = handGlobalMatrix * pose.fingerPoses[(int)FingerEnum.index].poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            var middleKnuckleGlobalMatrix = handGlobalMatrix * pose.fingerPoses[(int)FingerEnum.middle].poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            var ringKnuckleGlobalMatrix = handGlobalMatrix * pose.fingerPoses[(int)FingerEnum.ring].poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            var pinkyKnuckleGlobalMatrix = handGlobalMatrix * pose.fingerPoses[(int)FingerEnum.pinky].poseRelativeMatrix[(int)FingerJointEnum.knuckle];        

            //Line from thumb to index
            Gizmos.color = color;
            Gizmos.DrawLine(AutoHandExtensions.ExtractPosition(ref thumbKnuckleGlobalMatrix), AutoHandExtensions.ExtractPosition(ref indexKnuckleGlobalMatrix));
            Gizmos.DrawLine(AutoHandExtensions.ExtractPosition(ref indexKnuckleGlobalMatrix), AutoHandExtensions.ExtractPosition(ref middleKnuckleGlobalMatrix));
            Gizmos.DrawLine(AutoHandExtensions.ExtractPosition(ref middleKnuckleGlobalMatrix), AutoHandExtensions.ExtractPosition(ref ringKnuckleGlobalMatrix));
            Gizmos.DrawLine(AutoHandExtensions.ExtractPosition(ref ringKnuckleGlobalMatrix), AutoHandExtensions.ExtractPosition(ref pinkyKnuckleGlobalMatrix));
            Gizmos.DrawLine(AutoHandExtensions.ExtractPosition(ref pinkyKnuckleGlobalMatrix), AutoHandExtensions.ExtractPosition(ref thumbKnuckleGlobalMatrix));
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseGizmo.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableSubstitute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3f1287143c1c3fa478149aeec0c569a2
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    /// <summary>Takes a reference for a disabled grabbable, and grabs that instead</summary>
    [RequireComponent(typeof(Grabbable))]
    public class GrabbableSubstitute : MonoBehaviour{
        [Tooltip("Whether or not to disable this gameobject on grab")]
        public bool disableOnGrab = true;
        [Tooltip("If true, the substitute will return to the this local location and turn off and the local grabbable will turn back on")]
        public bool returnOnRelease = false;
        public Grabbable grabbableSubstitute;

        Grabbable localGrabbable;

        private void Start() {
            localGrabbable = GetComponent<Grabbable>();
            localGrabbable.OnGrabEvent += OnGrabOriginal;
            grabbableSubstitute.OnReleaseEvent += OnReleaseSub;
        }

        void OnGrabOriginal(Hand hand, Grabbable grab) {
            hand.Release();

            grabbableSubstitute.gameObject.SetActive(true);
            hand.CreateGrabConnection(grabbableSubstitute, hand.transform.position, hand.transform.rotation, grab.transform.position, grab.transform.rotation, true);

            if(disableOnGrab)
                grab.gameObject.SetActive(false);
        }

        void OnReleaseSub(Hand hand, Grabbable grab) {
            if(returnOnRelease) {
                grabbableSubstitute.transform.position = localGrabbable.transform.position;
                grabbableSubstitute.transform.rotation = localGrabbable.transform.rotation;
                grabbableSubstitute.body.position = localGrabbable.body.position;
                grabbableSubstitute.body.rotation = localGrabbable.body.rotation;

                grabbableSubstitute.gameObject.SetActive(false);
                if(disableOnGrab)
                    grab.gameObject.SetActive(true);

            }
        }

        /// <summary>Disables the local grabbale (if enabled), enables the substitute at the local grabbables positoin)</summary>
        public void LocalSubstitute(Hand hand, Grabbable grab) {
            if(localGrabbable.gameObject.activeInHierarchy) {
                grabbableSubstitute.gameObject.SetActive(true);
                grabbableSubstitute.transform.position = localGrabbable.transform.position;
                grabbableSubstitute.transform.rotation = localGrabbable.transform.rotation;
                grabbableSubstitute.body.position = localGrabbable.body.position;
                grabbableSubstitute.body.rotation = localGrabbable.body.rotation;

                if(disableOnGrab)
                    localGrabbable.gameObject.SetActive(false);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableSubstitute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableThrowEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 94010c3364a7d0a43a5e49e48d078a08
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using UnityEngine.Events;
using System.Collections;
using System.Collections.Generic;

namespace Autohand{
    [RequireComponent(typeof(Grabbable))]
    public class GrabbableThrowEvent : MonoBehaviour {
        public Rigidbody rb;
        [Tooltip("The velocity magnitude required on collision to cause the break event")]
        public float breakVelocity = 1;
        [Tooltip("The layers that will cause this grabbale to break")]
        public LayerMask collisionLayers = ~0;
        public UnityEvent OnBreak;
        Grabbable grab;
        bool thrown = false;
        Coroutine resetThrowing;
        float throwTime = 3;

        void Awake() {
            if(rb == null)
                rb = GetComponent<Rigidbody>();
            grab = GetComponent<Grabbable>();
        }

        private void OnEnable() {
            grab.OnReleaseEvent += OnReleased;
        }
        private void OnDisable() {
            grab.OnReleaseEvent -= OnReleased;
        }

        void OnReleased(Hand hand, Grabbable grab) {
            if(resetThrowing != null)
                StopCoroutine(resetThrowing);
            resetThrowing = StartCoroutine(ResetThrown());

            if(grab.body == null)
                return;

            if(grab.body.linearVelocity.magnitude >= breakVelocity) 
                thrown = true;

        }

        IEnumerator ResetThrown() {
            yield return new WaitForSeconds(throwTime);
            thrown = false;
            resetThrowing = null;
        }

        

        private void OnCollisionEnter(Collision collision) {
            if(!thrown || grab == null)
                return;

            if(((1 << collision.collider.gameObject.layer) & collisionLayers) == 0)
                return;
        
            if(rb.linearVelocity.magnitude >= breakVelocity) {
                Invoke("Break", Time.fixedDeltaTime);
            }
        }

        void Break() {
            OnBreak.Invoke();
        }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableThrowEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabLock.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 72ddecfd57951984cb3fe8b722d3f68b
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    [RequireComponent(typeof(Grabbable))]
    public class GrabLock : MonoBehaviour{
        [Header("Hand.Released() must be called elsewhere")]
        [Header("Use this script to prevent grabbable release")]
        
        //THIS SCRIPT ALLOWS YOU TO HOLD AN OBJECT AFTER TRIGGER RELEASE AND CALL THIS EVENT WITH TRIGGER PRESS
        public UnityHandGrabEvent OnGrabPressed;

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabLock.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/PlacePoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7d9c288aa20513c4aafa0228d4cfd80e
# ASMDEF: AutoHandAssembly.dll
# ---
using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.UIElements;

namespace Autohand {
    public enum PlacePointNameType
    {
        name,
        tag
    }

    public enum PlacePointShape {
        Sphere,
        Box
    }

    public delegate void PlacePointEvent(PlacePoint point, Grabbable grabbable);
    [Serializable]
    public class UnityPlacePointEvent : UnityEvent<PlacePoint, Grabbable> { }
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/place-point")]
    //You can override this by turning the radius to zero, and using any other trigger collider
    [DefaultExecutionOrder(1000)]
    public class PlacePoint : MonoBehaviour, IGrabbableEvents{
        [AutoHeader("Place Point")]
        public bool ignoreMe;

        [AutoSmallHeader("Place Settings")]
        public bool showPlaceSettings = true;
        [Tooltip("Snaps an object to the point at start, leave empty for no target")]
        public Grabbable startPlaced;
        [Tooltip("This will offset where the object position is when placed")]
        public Transform placedOffset;

        [Space]
        public PlacePointShape shapeType = PlacePointShape.Sphere;
        [Tooltip("The radius of the place point (relative to scale)"), ShowIf("shapeType", PlacePointShape.Sphere)]
        public float placeRadius = 0.1f;
        [Tooltip("The radius of the place point (relative to scale)"), ShowIf("shapeType", PlacePointShape.Box)]
        public Vector3 placeSize = new Vector3(0.1f, 0.1f, 0.1f);
        [Tooltip("The local offset of the enter radius of the place point (not the offset of the placement)"), FormerlySerializedAs("radiusOffset")]
        public Vector3 shapeOffset;

        [Space]
        [Tooltip("This will make the place point itself targetable for grab istead of just the object inside. Functionally just makes the place point an easier grab target, also essential if turning off the colliders on the placed object")]
        public bool grabbablePlacePoint = true;
        [Tooltip("This will make the point place the object as soon as it enters the radius, instead of on release")]
        public bool forcePlace = false;
        [Tooltip("If true and will force hand to release on place when force place is called. If false the hand will attempt to keep the connection to the held object (but can still break due to max distances/break forces)")]
        [ShowIf("forcePlace")]
        public bool forceHandRelease = true;
        [Tooltip("This will make the object parent to be under this point when placed")]
        public bool parentOnPlace = true;

        [Space]
        [Tooltip("If disabled the place point will not set the placed object to match its position")]
        public bool matchPosition = true;
        [Tooltip("If disabled the place point will not set the placed object to match its rotation")]
        public bool matchRotation = true;
        [Tooltip("This will resize the object, depending on it's render bounds, to fit into the place point radius (- resizeOffset) on place")]

        [Space] 
        public bool resizeOnPlace = false;
        [ShowIf("resizeOnPlace")]
        public float resizeOffset = -0.02f;

        [Space]
        [Tooltip("Whether or not the placed object should have its rigidbody disabled on place, good for parenting placed objects under dynamic objects")]
        public bool disableRigidbodyOnPlace = false;
        [Tooltip("Whether or not the grabbable should be disabled on place")]
        public bool disableGrabOnPlace = false;
        [Tooltip("Whether or not this place point should be disabled on placement. It will maintain its connection and can no longer accept new items. Causes less overhead if true")]
        public bool disablePlacePointOnPlace = false;
        [Tooltip("Whether or not the placed object should be disabled on placement (this will hide the placed object and leave the place point active for a new object)")]
        public bool destroyObjectOnPlace = false;


        [Tooltip("If true and will force release on place")]
        [DisableIf("disableRigidbodyOnPlace")]
        public bool makePlacedKinematic = true;
        
        [DisableIf("disableRigidbodyOnPlace")]
        [Tooltip("The rigidbody to attach the placed grabbable to - leave empty means no joint")]
        public Rigidbody placedJointLink;
        [DisableIf("disableRigidbodyOnPlace")]
        public float jointBreakForce = 1000;

        [AutoSmallHeader("Place Requirements")]
        public bool showPlaceRequirements = true;

        [Tooltip("Whether or not to only allow placement of an object while it's being held (or released)")]
        public bool heldPlaceOnly = false;

        [Tooltip("Whether the placeNames should compare names or tags")]
        public PlacePointNameType nameCompareType;
        [Tooltip("Will allow placement for any grabbable with a name containing this array of strings, leave blank for any grabbable allowed")]
        public string[] placeNames;
        [Tooltip("Will prevent placement for any name containing this array of strings")]
        public string[] blacklistNames;

        [Tooltip("(Unless empty) Will only allow placement any object contained here")]
        public List<Grabbable> onlyAllows;
        [Tooltip("Will NOT allow placement any object contained here")]
        public List<Grabbable> dontAllows;
        [Tooltip("The layer that this place point will check for placeable objects, if none will default to Grabbable")]
        public LayerMask placeLayers;

        [Space]

        [AutoToggleHeader("Show Events")]
        public bool showEvents = true;
        [ShowIf("showEvents")]
        public UnityPlacePointEvent OnPlace;
        [ShowIf("showEvents")]
        public UnityPlacePointEvent OnRemove;
        [ShowIf("showEvents")]
        public UnityPlacePointEvent OnHighlight;
        [ShowIf("showEvents")]
        public UnityPlacePointEvent OnStopHighlight;
        
        //For the programmers
        public PlacePointEvent OnPlaceEvent;
        public PlacePointEvent OnRemoveEvent;
        public PlacePointEvent OnHighlightEvent;
        public PlacePointEvent OnStopHighlightEvent;

        public Grabbable highlightingObj { get; protected set; } = null;
        public Grabbable placedObject { get; protected set; } = null;
        public Grabbable lastPlacedObject { get; protected set; } = null;

        /// <summary>If this place point is set under a grabbable, this value will reference that grabbable</summary>
        internal Grabbable parentGrabbable;

        protected FixedJoint joint = null;
        protected float lastPlacedTime;
        protected CollisionDetectionMode placedObjDetectionMode;
        protected float tickRate = 0.05f;

        Coroutine checkRoutine;
        Collider[] collidersNonAlloc = new Collider[50];
        Vector3 lastPlacePosition = Vector3.zero;
        bool wasInstantGrab = false;
        Vector3 prefitScale;
        protected bool placingFrame;


        protected virtual void Awake(){
            if (placedOffset == null)
                placedOffset = transform;

            if(placeLayers == 0)
                placeLayers = LayerMask.GetMask(Hand.grabbableLayerNameDefault);

            //If the place point is set to be grabbable, make sure it's on the default layer
            if(grabbablePlacePoint) {
                var colliders = GetComponents<Collider>();
                foreach(Collider col in colliders) {
                    if(col.gameObject.layer == LayerMask.NameToLayer("Default") || LayerMask.LayerToName(col.gameObject.layer) == "")
                        col.gameObject.layer = LayerMask.NameToLayer(Hand.grabbableLayerNameDefault);
                }


                if(shapeType == PlacePointShape.Sphere && !gameObject.CanGetComponent<SphereCollider>(out var sphereCollider)) {
                    sphereCollider = gameObject.AddComponent<SphereCollider>();
                    sphereCollider.isTrigger = true;
                    sphereCollider.radius = placeRadius;
                    sphereCollider.center = shapeOffset;
                }
                if(shapeType == PlacePointShape.Box && !gameObject.CanGetComponent<BoxCollider>(out var boxCollider)) {
                    boxCollider = gameObject.AddComponent<BoxCollider>();
                    boxCollider.isTrigger = true;
                    boxCollider.size = placeSize;
                    boxCollider.center = shapeOffset;
                }
            }

            CheckInvalidSettings();

            if(startPlaced != null && startPlaced.childPlacePoints.Count == 0)
                SetStartPlaced();
            else if(startPlaced != null)
                StartCoroutine(LateStart());


        }

        protected virtual void CheckInvalidSettings() {
            if(parentGrabbable && !disableRigidbodyOnPlace && parentOnPlace) {
                Debug.LogWarning("Place Points placed under a grabbable cannot support parenting other rigidbody grabbables, disable rigibody on place is being enabled" , this);
                disableRigidbodyOnPlace = true;
                makePlacedKinematic = false;
            }
        }

        //This function helps solve the specific case where a place point is set to be placed into a different place point,
        //but the objects set to be placed in this place point are not yet placed, so we wait until they are placed before setting this place point to be placed
        IEnumerator LateStart() {
            bool waitForChildPointPlacement = false;
            int maxWaitFrames = 10;
            while(true) {
                yield return new WaitForFixedUpdate();

                foreach(var childPoint in startPlaced.childPlacePoints) {
                    if(childPoint.startPlaced != null && childPoint.placedObject == null) {
                        if(parentGrabbable == null || childPoint.startPlaced != parentGrabbable) {
                            waitForChildPointPlacement = true;
                            break;
                        }
                    }
                }

                if(waitForChildPointPlacement && maxWaitFrames > 0) {
                    maxWaitFrames--;
                    continue;
                }
                else {
                    if(startPlaced != null && startPlaced.childPlacePoints.Count > 0)
                        SetStartPlaced();

                    break;
                }

            }
        }



        protected virtual void OnEnable() {
            if(placedOffset == null)
                placedOffset = transform;

            if(checkRoutine == null)
                checkRoutine = StartCoroutine(CheckPlaceObjectLoop());

        }

        protected virtual void OnDisable() {
            if(checkRoutine != null) {
                StopCoroutine(checkRoutine);
                checkRoutine = null;
            }

            if(!parentOnPlace)
                Remove();

            StopHighlight();
        }

        ///<summary>Sets the placement of the object set in the start placed value</summary>
        protected virtual void SetStartPlaced() {
            if(startPlaced != null) {
                //Checks if the start placed object is already in the scene
                if(startPlaced.gameObject.scene.IsValid()) {
                    Highlight(startPlaced);
                    Place(startPlaced);
                }
                //or if it's a prefab that needs to be instantiated
                else {
                    var instance = GameObject.Instantiate(startPlaced);
                    instance.transform.position = placedOffset.position;
                    instance.transform.rotation = placedOffset.rotation;
                    Highlight(instance);
                    Place(instance);

                }
            }
        }

        /// <summary>Places the object current placed to this place point</summary>
        public Grabbable GetPlacedObject() {
            return placedObject;
        }

        

        /// <summary>Whether or not the place point can accept an object based on its settings</summary>
        public virtual bool CanPlace(Grabbable placeObj, bool checkRoot = true) {
            if(checkRoot && CanPlace(placeObj.rootGrabbable, false))
                return true;

            if(placedObject != null) {
                return false;
            }

            //This prevents place points from accepting objects that arent parent on grab
            if(!placeObj.parentOnGrab && parentGrabbable != null) {
                return false;
            }

            //This prevents place points from accepting objects that arent being held while heldPlaceOnly is true
            if(heldPlaceOnly && placeObj.HeldCount() == 0) {
                return false;
            }

            //This prevents place points from accepting objects that arent being held while heldPlaceOnly is true
            if(onlyAllows.Count > 0 && !onlyAllows.Contains(placeObj)) {
                return false;
            }

            //This prevents place points from accepting objects that are in the dontAllows list
            if(dontAllows.Count > 0 && dontAllows.Contains(placeObj)) {
                return false;
            }

            //If no place names are set, then any grabbable is allowed
            if(placeNames.Length == 0 && blacklistNames.Length == 0) {
                return true;
            }

            //This prevents place points from accepting objects that are in the blacklistNames list
            if (blacklistNames.Length > 0)
                foreach(var badName in blacklistNames)
                {
                    if (nameCompareType == PlacePointNameType.name && placeObj.name.Contains(badName))
                        return false;
                    if (nameCompareType == PlacePointNameType.tag && placeObj.CompareTag(badName))
                        return false;
                }

            //This prevents place points from accepting objects that arent in the placeNames list
            if (placeNames.Length > 0)
                foreach (var placeName in placeNames)
                {
                    if (nameCompareType == PlacePointNameType.name && placeObj.name.Contains(placeName))
                        return true;
                    if (nameCompareType == PlacePointNameType.tag && placeObj.CompareTag(placeName))
                        return true;
                }
            else
                return true;

            return false;
        }


        /// <summary>Places the given grabbable into this place point if the settings allow it</summary>
        public virtual void TryPlace(Grabbable placeObj) {
            if(CanPlace(placeObj))
                Place(placeObj);
        }


        /// <summary>Places the given grabbable into this place point</summary>
        public virtual void Place(Grabbable placeObj) {
            if (placedObject != null)
                return;

            placeObj = placeObj.rootGrabbable;
            placingFrame = true;

            //Remove from any other place points then initialize
            if(placeObj.placePoint != null && placeObj.placePoint != this)
                placeObj.placePoint.Remove(placeObj);

            placedObject = placeObj.rootGrabbable;
            placedObject.SetPlacePoint(this);


            //Release any hands holding the grabbable or its children
            if((forceHandRelease || disableRigidbodyOnPlace) && placeObj.HeldCount() > 0) {
                placeObj.ForceHandsRelease();
                foreach(var grab in placeObj.grabbableChildren)
                    grab.ForceHandsRelease();
            }



            //Placement, set position, create whatever joints based on settings
            if(matchPosition)
                placeObj.rootTransform.position = placedOffset.position;
            if(matchRotation)
                placeObj.rootTransform.rotation = placedOffset.rotation;

            if (placeObj.body != null){
                placeObj.body.linearVelocity = Vector3.zero;
                placeObj.body.angularVelocity = Vector3.zero;
                placedObjDetectionMode = placeObj.body.collisionDetectionMode;

                if (makePlacedKinematic && !disableRigidbodyOnPlace){
                    placeObj.body.collisionDetectionMode = CollisionDetectionMode.ContinuousSpeculative;
                    placeObj.body.isKinematic = makePlacedKinematic;
                }

                if (placedJointLink != null){
                    joint = placedJointLink.gameObject.AddComponent<FixedJoint>();
                    joint.connectedBody = placeObj.body;
                    joint.breakForce = jointBreakForce;
                    joint.breakTorque = jointBreakForce;
                
                    joint.connectedMassScale = 1;
                    joint.massScale = 1;
                    joint.enableCollision = false;
                    joint.enablePreprocessing = false;
                }
            }

            StopHighlight(placeObj);

            //If a child of the root grabbable is grabbed, this calls the remove function
            foreach(var grab in placeObj.grabbableChildren) 
                grab.OnGrabEvent += OnPlaceObjectChildGrabbed;

            //Call Events
            placeObj.OnPlacePointAddEvent?.Invoke(this, placeObj);
            foreach(var grabChild in placeObj.grabbableChildren)
                grabChild.OnPlacePointAddEvent?.Invoke(this, grabChild);

            OnPlaceEvent?.Invoke(this, placeObj);
            OnPlace?.Invoke(this, placeObj);
            lastPlacedTime = Time.time;

            //Apply place point settings
            if(destroyObjectOnPlace) {
                Destroy(placeObj.gameObject);
                return;
            }

            if(parentOnPlace) {
                placeObj.rootTransform.parent = transform;
            }

            if (disableRigidbodyOnPlace)
                placeObj.DeactivateRigidbody();

            if (disablePlacePointOnPlace)
                enabled = false;

            if (disableGrabOnPlace || disablePlacePointOnPlace)
                placeObj.isGrabbable = false;


            if(resizeOnPlace) {
                //It's important this happens in the before grab instead of on remove so the grab pose is calculated correctly
                placeObj.OnBeforeGrabEvent += ResizeBeforeGrab;
                foreach(var grabbable in placeObj.grabbableChildren)
                    grabbable.OnBeforeGrabEvent += ResizeBeforeGrab;

                //Ensures the pose looks correct after resizing
                placeObj.OnGrabEvent += RecacluatePoseAfterGrab;
                foreach(var grabChild in placeObj.rootGrabbable.grabbableChildren)
                    grabChild.OnGrabEvent += RecacluatePoseAfterGrab;

                //Save relevent values
                prefitScale = placeObj.rootTransform.localScale;
                wasInstantGrab = placeObj.instantGrab;
                placeObj.instantGrab = true;

                //Calculate and resize the object
                var scale = Mathf.Abs(transform.lossyScale.x < transform.lossyScale.y ? transform.lossyScale.x : transform.lossyScale.y);
                scale = Mathf.Abs(scale < transform.lossyScale.z ? scale : transform.lossyScale.z);
                if(shapeType == PlacePointShape.Sphere)
                    FitAndCenterToBounds(placeObj.rootTransform.gameObject, placeRadius*scale +  resizeOffset*scale);
                else if(shapeType == PlacePointShape.Box)
                    FitAndCenterToBounds(placeObj.rootTransform.gameObject, (placeSize + placeSize * resizeOffset)*scale);
            }


            //If the place point is grabbable add an event to recalculate the before grab event to ensure the pose is correct
            if(grabbablePlacePoint) {
                placeObj.OnBeforeGrabEvent += RecalculateBeforeGrab;
                foreach(var grabbable in placeObj.grabbableChildren)
                    grabbable.OnBeforeGrabEvent += RecalculateBeforeGrab;
            }

            //If the place point is found to be a child of a grabbable
            if(parentGrabbable != null) {
                //Disable the place points of the placed object from interacting with the parent grabbable
                foreach(var childPlacePoint in placeObj.childPlacePoints) {
                    parentGrabbable.PlacePointIgnore(childPlacePoint);
                    childPlacePoint.StopHighlight();
                    childPlacePoint.enabled = false;
                    if(childPlacePoint.placedObject != null)
                        childPlacePoint.placedObject.enabled = false;
                }
                //Combine the colliders of the placed object with the parent grabbable
                if(disableRigidbodyOnPlace && parentOnPlace)
                    parentGrabbable.AddGrabbableColliders(placeObj);
            }


        }


        /// <summary>Removes the object if it matches the given object</summary>
        public virtual void Remove(Grabbable placeObj) {
            placeObj = placeObj.rootGrabbable;

            if (placeObj == null || placeObj != placedObject || disablePlacePointOnPlace)
                return;

            //Remove Events
            foreach(var grab in placeObj.grabbableChildren)
                grab.OnGrabEvent -= OnPlaceObjectChildGrabbed;


            //Trigger highlight
            Highlight(placeObj);

            if(disableRigidbodyOnPlace)
                placeObj.ActivateRigidbody();


            //Reset rigidbody settings
            if (placeObj.body != null){
                if (makePlacedKinematic && !disableRigidbodyOnPlace)
                    placeObj.body.isKinematic = false;

                placeObj.body.collisionDetectionMode = placedObjDetectionMode;
            }


            //If the place point is a child of a grabbable
            if(parentGrabbable != null) {
                //Enable the place points of the placed object to interact with the parent grabbable
                if(placeObj.childPlacePoints.Count > 0) {
                    foreach(var childPlacePoint in placeObj.childPlacePoints) {
                        parentGrabbable.PlacePointAllow(childPlacePoint);
                        childPlacePoint.enabled = true;
                        if(childPlacePoint.placedObject != null)
                            childPlacePoint.placedObject.enabled = true;
                    }
                }

                //Remove the colliders of the placed object from the parent grabbable
                parentGrabbable.RemoveGrabbableColliders(placeObj);

                //Ignore the collisions between the placed object and the parent grabbable
                parentGrabbable.IgnoreGrabbableCollisionUntilNone(placeObj);
                //Ignore the collisions between the placed object and the hands holding the parent grabbable
                foreach(var hand in parentGrabbable.GetHeldBy()) 
                    placeObj.IgnoreHandCollisionUntilNone(hand);
                //Ignore the collisions between the placed object and the hands holding the placed object
                foreach(var hand in placeObj.GetHeldBy()) 
                    parentGrabbable.IgnoreHandCollisionUntilNone(hand);
            }

            //Reset size
            if(resizeOnPlace) {
                //Remove Events
                placedObject.OnBeforeGrabEvent -= ResizeBeforeGrab;
                foreach(var grabbable in placedObject.grabbableChildren)
                    grabbable.OnBeforeGrabEvent -= ResizeBeforeGrab;

                //If the remove function is called without grabbing
                if(placeObj.HeldCount() == 0)
                    placeObj.rootTransform.localScale = prefitScale;

                placeObj.instantGrab = wasInstantGrab;
            }
             
            if(grabbablePlacePoint) {
                //Remove Events
                placedObject.OnBeforeGrabEvent -= RecalculateBeforeGrab;
                foreach(var grabbable in placedObject.grabbableChildren)
                    grabbable.OnBeforeGrabEvent -= RecalculateBeforeGrab;
            }


            //Reset parent if the parenting isnt already being handled by a hand
            if((!placeObj.parentOnGrab || placeObj.HeldCount() == 0) && parentOnPlace && gameObject.activeInHierarchy) {
                placeObj.rootTransform.parent = placeObj.originalParent;
            }


            if(joint != null){
                Destroy(joint);
                joint = null;
            }

            //Call Events
            placedObject.OnPlacePointRemoveEvent?.Invoke(this, highlightingObj);
            foreach(var grabChild in placedObject.grabbableChildren)
                grabChild.OnPlacePointRemoveEvent?.Invoke(this, grabChild);
            OnRemoveEvent?.Invoke(this, placeObj);
            OnRemove?.Invoke(this, placeObj);


            lastPlacedObject = placedObject;
            placedObject = null;
        }


        /// <summary>Removes the object if it has one</summary>
        [ContextMenu("Remove Placed")]
        public void Remove() {
            if(placedObject != null)
                Remove(placedObject);
        }



        public virtual void Highlight(Grabbable from) {
            from = from.rootGrabbable;
            if(highlightingObj == null){
                highlightingObj = from;
                from.SetPlacePoint(this);

                highlightingObj.OnPlacePointHighlightEvent?.Invoke(this, highlightingObj);
                foreach(var grabChild in highlightingObj.grabbableChildren)
                    grabChild.OnPlacePointHighlightEvent?.Invoke(this, grabChild);

                OnHighlightEvent?.Invoke(this, from);
                OnHighlight?.Invoke(this, from);

                if(placedObject == null && (forcePlace || (!heldPlaceOnly && from.HeldCount() == 0)))
                    Place(from);
            }
        }

        public virtual void StopHighlight(Grabbable grab) {
            grab = grab.rootGrabbable;
            if(highlightingObj == grab) {
                StopHighlight();
            }
        }

        public virtual void StopHighlight() {
            if(highlightingObj != null) {
                highlightingObj.OnPlacePointUnhighlightEvent?.Invoke(this, highlightingObj);
                foreach(var grabChild in highlightingObj.grabbableChildren)
                    grabChild.OnPlacePointUnhighlightEvent?.Invoke(this, grabChild);

                OnStopHighlightEvent?.Invoke(this, highlightingObj);
                OnStopHighlight?.Invoke(this, highlightingObj);

                if (placedObject == null)
                    highlightingObj.SetPlacePoint(null);

                highlightingObj = null;
            }
        }




        //CHECK PLACEMENT FUNCTIONS
        int lastOverlapCount = 0;
        protected virtual IEnumerator CheckPlaceObjectLoop() {
            yield return new WaitForSeconds(0.2f);
            yield return new WaitForSeconds(UnityEngine.Random.Range(0f, tickRate));

            while(gameObject.activeInHierarchy) {
                var scale = Mathf.Abs(transform.lossyScale.x < transform.lossyScale.y ? transform.lossyScale.x : transform.lossyScale.y);
                scale = Mathf.Abs(scale < transform.lossyScale.z ? scale : transform.lossyScale.z);
                if(!disablePlacePointOnPlace && !disableRigidbodyOnPlace && placedObject != null &&
                    lastPlacePosition != placedObject.transform.position && !IsStillOverlapping(placedObject, scale) && !placingFrame) {
                    Remove(placedObject);
                }

                if(placedObject != null)
                    lastPlacePosition = placedObject.transform.position;

                CheckHighlight(scale);

                yield return new WaitForSeconds(tickRate);
                if(placedObject != null && placingFrame) {
                    if(matchPosition)
                        placedObject.rootTransform.position = placedOffset.position;
                    if(matchRotation)
                        placedObject.rootTransform.rotation = placedOffset.rotation;

                    lastPlacePosition = placedObject.transform.position;
                }

                placingFrame = false;
            }
        }

        protected virtual void CheckPlaceObject(float scale) {
            if(!disablePlacePointOnPlace && !disableRigidbodyOnPlace && placedObject != null &&
                lastPlacePosition != placedObject.transform.position && !IsStillOverlapping(placedObject, scale)) {
                Remove(placedObject);
            }

            if(placedObject != null)
                lastPlacePosition = placedObject.transform.position;

            CheckHighlight(scale);
        }

        protected virtual void CheckHighlight(float scale) {
            if(placedObject == null && highlightingObj == null) {
                var overlapCenterPos = placedOffset.position + transform.rotation * shapeOffset;
                int overlaps = 0;
                switch(shapeType) {
                    case PlacePointShape.Sphere:
                        overlaps = Physics.OverlapSphereNonAlloc(overlapCenterPos, placeRadius * scale, collidersNonAlloc, placeLayers);
                        break;
                    case PlacePointShape.Box:
                        overlaps = Physics.OverlapBoxNonAlloc(overlapCenterPos, placeSize/2f * scale, collidersNonAlloc, transform.rotation, placeLayers);
                        break;
                }

                if(overlaps != lastOverlapCount) {
                    var updateOverlaps = true;
                    for(int i = 0; i < overlaps; i++) {
                        if(AutoHandExtensions.HasGrabbable(collidersNonAlloc[i].gameObject, out var tempGrabbable)) {
                            tempGrabbable = tempGrabbable.rootGrabbable;
                            updateOverlaps = false;

                            if(CanPlace(tempGrabbable)) {
                                var existingPlacePoint = tempGrabbable.placePoint;
                                if(existingPlacePoint) {
                                    var grabbablePos = tempGrabbable.transform.position;
                                    var concurrentCenterPos = existingPlacePoint.placedOffset.position + existingPlacePoint.transform.rotation * existingPlacePoint.shapeOffset;
                                    var concurrentDist = Vector3.Distance(concurrentCenterPos, grabbablePos);
                                    var currentDist = Vector3.Distance(overlapCenterPos, grabbablePos);
                                    if(currentDist >= concurrentDist)
                                        continue;

                                    existingPlacePoint.StopHighlight(tempGrabbable);
                                }

                                Highlight(tempGrabbable);
                                break;
                            }
                        }
                    }

                    if(updateOverlaps) {
                        lastOverlapCount = overlaps;
                    }
                }
            }
            else if(highlightingObj != null) {
                if(!IsStillOverlapping(highlightingObj, scale)) {
                    StopHighlight(highlightingObj);
                }
            }
        }


        protected bool IsStillOverlapping(Grabbable from, float scale = 1) {
            var overlapCenterPos = placedOffset.position + transform.rotation * shapeOffset;
            int overlaps = 0;
            switch(shapeType) {
                case PlacePointShape.Sphere:
                    overlaps = Physics.OverlapSphereNonAlloc(overlapCenterPos, placeRadius * scale, collidersNonAlloc, placeLayers);
                    break;
                case PlacePointShape.Box:
                    overlaps = Physics.OverlapBoxNonAlloc(overlapCenterPos, placeSize/2f * scale, collidersNonAlloc, transform.rotation, placeLayers);
                    break;
            }

            for (int i = 0; i < overlaps; i++){
                if (collidersNonAlloc[i].attachedRigidbody == from.body) {
                    return true;
                }
            }
            
            return false;
        }


        protected virtual void OnPlaceObjectChildGrabbed(Hand pHand, Grabbable pGrabbable){
            Remove();
        }




        protected void ResizeBeforeGrab(Hand hand, Grabbable grab) {
            grab.rootTransform.localScale = prefitScale;
            Physics.SyncTransforms();
            if(grab.body != null) {
                grab.body.WakeUp();
                grab.body.detectCollisions = false;
                grab.body.detectCollisions = true;
            }

        }

        protected void RecalculateBeforeGrab(Hand hand, Grabbable grab) {
            hand.RecalculateBeforeGrab(grab);
        }

        protected void RecacluatePoseAfterGrab(Hand hand, Grabbable grab) {
            hand.RecaculateHeldAutoPose();
            grab.rootGrabbable.OnGrabEvent -= RecacluatePoseAfterGrab;
            foreach(var grabChild in grab.rootGrabbable.grabbableChildren) {
                grabChild.OnGrabEvent -= RecacluatePoseAfterGrab;
            }
        }

        protected void FitAndCenterToBounds(GameObject obj, float radius) {
            Bounds bounds = CalculateCombinedBounds(obj);
            var scaleOffset = ScaleToFitRadius(obj, bounds, radius);
            obj.transform.localScale *= scaleOffset;
            bounds.extents *= scaleOffset;
            bounds = CalculateCombinedBounds(obj);
            if(matchPosition)
                obj.transform.position = placedOffset.position + (obj.transform.position - bounds.center);
            if(matchRotation)
                obj.transform.rotation = placedOffset.rotation;
        }


        protected float ScaleToFitRadius(GameObject obj, Bounds bounds, float radius) {
            float maxExtent = bounds.extents.magnitude;
            float scale = radius / maxExtent;
            return scale;
        }
        protected void FitAndCenterToBounds(GameObject obj, Vector3 size) {
            Bounds bounds = CalculateCombinedBounds(obj);
            float scaleOffset = ScaleToFitSize(obj, bounds, size);
            obj.transform.localScale *= scaleOffset;
            bounds.extents *= scaleOffset;
            bounds = CalculateCombinedBounds(obj);
            if(matchPosition)
                obj.transform.position = placedOffset.position + (obj.transform.position - bounds.center);
            if(matchRotation)
                obj.transform.rotation = placedOffset.rotation;
        }

        protected float ScaleToFitSize(GameObject obj, Bounds bounds, Vector3 size) {
            Vector3 currentSize = bounds.size;
            float scaleX = size.x / currentSize.x;
            float scaleY = size.y / currentSize.y;
            float scaleZ = size.z / currentSize.z;
            float scale = Mathf.Min(scaleX, Mathf.Min(scaleY, scaleZ));
            return scale;
        }

        protected Bounds CalculateCombinedBounds(GameObject obj) {
            var meshRenderers = obj.GetComponentsInChildren<MeshRenderer>().OfType<Renderer>();
            var skinnedMeshRenderers = obj.GetComponentsInChildren<SkinnedMeshRenderer>().OfType<Renderer>();
            List<Renderer> renderers = new List<Renderer>();

            renderers.AddRange(meshRenderers);
            renderers.AddRange(skinnedMeshRenderers);
            Bounds combinedBounds = new Bounds(obj.transform.position, Vector3.zero);

            foreach(Renderer renderer in renderers)
                combinedBounds.Encapsulate(renderer.bounds);

            return combinedBounds;
        }





        protected virtual void OnJointBreak(float breakForce) {
            if(placedObject != null)
                Remove(placedObject);
        }




        void OnDrawGizmos() {
            if(placedOffset == null)
                placedOffset = transform;

            var scale = Mathf.Abs(transform.lossyScale.x < transform.lossyScale.y ? transform.lossyScale.x : transform.lossyScale.y);
            scale = Mathf.Abs(scale < transform.lossyScale.z ? scale : transform.lossyScale.z);

            Gizmos.color = Color.white; 
            Gizmos.matrix = transform.localToWorldMatrix;

            if(shapeType == PlacePointShape.Box) {
                Gizmos.DrawWireCube(shapeOffset, placeSize);
                
                if(resizeOffset != 0 && resizeOnPlace) {
                    Gizmos.color = Color.red;
                    Gizmos.DrawWireCube(shapeOffset, (placeSize + placeSize * resizeOffset));
                }
            }
            else if(shapeType == PlacePointShape.Sphere) {

                Gizmos.DrawWireSphere(shapeOffset, placeRadius);

                if(resizeOffset != 0 && resizeOnPlace) {
                    Gizmos.color = Color.red;
                    Gizmos.DrawWireSphere(shapeOffset, placeRadius + resizeOffset);
                }
            }
        }


        //INTERFACE FUNCTIONS FOR GRABBABLE PLACE POINT
        void IGrabbableEvents.OnHighlight(Hand hand) {
            if(!grabbablePlacePoint)
                return; 

            if(placedObject != null)
                placedObject.Highlight(hand);
        }

        public virtual void OnUnhighlight(Hand hand) {
            if(!grabbablePlacePoint)
                return;

            if(placedObject != null)
                placedObject.Unhighlight(hand);

        }

        public virtual void OnGrab(Hand hand) {
            if(!grabbablePlacePoint)
                return;

            hand.RecaculateHeldAutoPose();
        }

        public virtual void OnRelease(Hand hand) {
            if(!grabbablePlacePoint)
                return;
        }

        public virtual bool CanGrab(Hand hand) {
            if(!grabbablePlacePoint || placedObject == null)
                return false;

            return placedObject.CanGrab(hand);
        }

        public virtual Grabbable GetGrabbable() {
            if(!grabbablePlacePoint || placedObject == null || !enabled)
                return null;

            return placedObject;

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/PlacePoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/PlacePointSoundEffects.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d9ec4dfc370076d4f8e478d26e0b407b
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class PlacePointSoundEffects : MonoBehaviour {
        public PlacePoint placePoint;
        public AudioSource audioSource;
        public AudioClip highlightSound;
        public AudioClip unhighlightSound;
        public AudioClip placeSound;
        public AudioClip removeSound;

        float startDelay = 1f;
        Coroutine waitToActivateRountine;

        void OnEnable() {
            if(audioSource == null)
                audioSource = GetComponent<AudioSource>();
            waitToActivateRountine = StartCoroutine(WaitToActivate());
        }

        void OnDisable() {
            if(waitToActivateRountine != null) {
                StopCoroutine(waitToActivateRountine);
            }
            else {
                placePoint.OnHighlight.RemoveListener(OnHighlight);
                placePoint.OnStopHighlight.RemoveListener(OnUnhighlight);
                placePoint.OnPlace.RemoveListener(OnPlace);
                placePoint.OnRemove.RemoveListener(OnRemove);
            }
        }

        IEnumerator WaitToActivate() {
            yield return new WaitForSeconds(startDelay);
            placePoint.OnHighlight.AddListener(OnHighlight);
            placePoint.OnStopHighlight.AddListener(OnUnhighlight);
            placePoint.OnPlace.AddListener(OnPlace);
            placePoint.OnRemove.AddListener(OnRemove);
        }

        void OnHighlight(PlacePoint placePoint, Grabbable grabbable) {
            if(highlightSound != null && audioSource.enabled && audioSource.gameObject.activeInHierarchy && placePoint.enabled)
                audioSource.PlayOneShot(highlightSound);
        }


        void OnUnhighlight(PlacePoint placePoint, Grabbable grabbable) {
            if(unhighlightSound != null && audioSource.enabled && audioSource.gameObject.activeInHierarchy && placePoint.enabled)
                audioSource.PlayOneShot(unhighlightSound);
        }

        void OnPlace(PlacePoint placePoint, Grabbable grabbable) {
            if(placeSound != null && audioSource.enabled && audioSource.gameObject.activeInHierarchy && placePoint.enabled)
                audioSource.PlayOneShot(placeSound);
        }

        void OnRemove(PlacePoint placePoint, Grabbable grabbable) {
            if(removeSound != null && audioSource.enabled && audioSource.gameObject.activeInHierarchy && placePoint.enabled)
                audioSource.PlayOneShot(removeSound);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/PlacePointSoundEffects.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/WeightlessFollower.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: faa064f2c7293d94294547ec24301cf2
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [DefaultExecutionOrder(999)]
    public class WeightlessFollower : MonoBehaviour {
        [HideInInspector]
        public Transform follow1 = null;
        [HideInInspector]
        public Transform follow2 = null;
        [HideInInspector]
        public Hand hand1 = null;
        [HideInInspector]
        public Hand hand2 = null;

        public Dictionary<Hand, Transform> heldMoveTo = new Dictionary<Hand, Transform>();

        [HideInInspector]
        public float followPositionStrength = 30;
        [HideInInspector]
        public float followRotationStrength = 30;

        [HideInInspector]
        public float maxVelocity = 5;

        [HideInInspector]
        public Grabbable grab;

        Transform _pivot = null;
        public Transform pivot {
            get {
                if(!gameObject.activeInHierarchy)
                    return null;

                if(_pivot == null) {
                    _pivot = new GameObject().transform;
                    _pivot.parent = transform.parent;
                    _pivot.name = "WEIGHTLESS PIVOT";
                }

                return _pivot;
            }
        }

        internal Rigidbody body;
        Transform moveTo = null;

        float startMass = 0;
        float startDrag;
        float startAngleDrag;
        float startHandMass;
        float startHandDrag;
        float startHandAngleDrag;
        bool useGravity;


        public void Start() {
            if(body == null)
                body = GetComponent<Rigidbody>();
        }


        public virtual void Set(Hand hand, Grabbable grab) {
            if (body == null)
                body = grab.body;

            if(moveTo == null) {
                moveTo = new GameObject().transform;
                moveTo.name = gameObject.name + " FOLLOW POINT";
                moveTo.parent = AutoHandExtensions.transformParent;
            }

            if(!heldMoveTo.ContainsKey(hand)) {
                heldMoveTo.Add(hand, new GameObject().transform);
                heldMoveTo[hand].name = "HELD FOLLOW POINT";
            }

            var tempTransform = AutoHandExtensions.transformRuler;
            tempTransform.position = hand.transform.position;
            tempTransform.rotation = hand.transform.rotation;

            var tempTransformChild = AutoHandExtensions.transformRulerChild;
            tempTransformChild.position = grab.rootTransform.position;
            tempTransformChild.rotation = grab.rootTransform.rotation;

            if(grab.maintainGrabOffset) {
                tempTransform.position = hand.moveTo.position + hand.grabPositionOffset;
                tempTransform.rotation = hand.moveTo.rotation * hand.grabRotationOffset;
            }
            else {
                tempTransform.position = hand.moveTo.position;
                tempTransform.rotation = hand.moveTo.rotation;
            }

            heldMoveTo[hand].parent = hand.moveTo;
            heldMoveTo[hand].position = tempTransformChild.position;
            heldMoveTo[hand].rotation = tempTransformChild.rotation;


            if(follow1 == null) {
                follow1 = heldMoveTo[hand];
                hand1 = hand;
            }
            else if(follow2 == null) {
                follow2 = heldMoveTo[hand];
                hand2 = hand;
                pivot.parent = body.transform;
                pivot.position = Vector3.Lerp(hand1.handGrabPoint.position, hand2.handGrabPoint.position, 0.5f);
                pivot.rotation = Quaternion.LookRotation((hand1.handGrabPoint.position - hand2.handGrabPoint.position).normalized, 
                                 Vector3.Lerp(hand1.handGrabPoint.up, hand2.handGrabPoint.up, 0.5f));
            }


            if (startMass == 0) {
                startMass = body.mass;
                startDrag = grab.targetDrag;
                startAngleDrag = grab.targetAngularDrag;
                useGravity = body.useGravity;
            }


            startHandMass = hand.body.mass;
            startHandDrag = hand.handFollow.startDrag;
            startHandAngleDrag = hand.handFollow.startAngularDrag;

            body.mass = startHandMass;
            body.linearDamping = startHandDrag;
            body.angularDamping = startHandAngleDrag;
            body.useGravity = false;

            followPositionStrength = hand.handFollow.followPositionStrength;
            followRotationStrength = hand.handFollow.followRotationStrength;


            maxVelocity = grab.maxHeldVelocity;
            this.grab = grab;

            hand.OnBeforeReleased += OnHandReleased;
        }


        void OnHandReleased(Hand hand, Grabbable grab){
            if(heldMoveTo.ContainsKey(hand))
                RemoveFollow(hand, heldMoveTo[hand]);
        }
        public virtual void FixedUpdate() {
            if(follow1 == null)
                return;

            if(follow2 != null) {
                pivot.position = Vector3.Lerp(hand1.handGrabPoint.position, hand2.handGrabPoint.position, 0.5f);
                pivot.rotation = Quaternion.LookRotation(
                    (hand1.handGrabPoint.position - hand2.handGrabPoint.position).normalized,
                    Vector3.Lerp(hand1.handGrabPoint.up, hand2.handGrabPoint.up, 0.5f)
                );
            }

            MoveTo();
            TorqueTo();

            if(grab.HeldCount() == 0)
                Destroy(this);
        }



        protected void SetMoveTo() {
            if(follow1 == null || moveTo == null)
                return;

            if(follow2 != null) {
                moveTo.position = Vector3.Lerp(hand1.moveTo.position, hand2.moveTo.position, 0.5f);
                moveTo.rotation = Quaternion.LookRotation((hand1.moveTo.position - hand2.moveTo.position).normalized,
                                 Vector3.Lerp(hand1.moveTo.up, hand2.moveTo.up, 0.5f));
                moveTo.position -= pivot.position - pivot.parent.transform.position;
                moveTo.rotation *= Quaternion.Inverse(pivot.localRotation);
            }
            else {
                moveTo.position = follow1.position;
                moveTo.rotation = follow1.rotation;
            }
        }



        /// <summary>Moves the hand to the controller position using physics movement</summary>
        protected virtual void MoveTo() {
            if(followPositionStrength <= 0 || moveTo == null)
                return;

            SetMoveTo();


            var movePos = moveTo.position;
            var distance = Vector3.Distance(movePos, transform.position);

            distance = Mathf.Clamp(distance, 0, 0.5f);

            SetVelocity(0.55f);


            void SetVelocity(float minVelocityChange) {
                var velocityClamp = grab.maxHeldVelocity;
                Vector3 vel = (movePos - transform.position).normalized * followPositionStrength * distance;

                vel.x = Mathf.Clamp(vel.x, -velocityClamp, velocityClamp);
                vel.y = Mathf.Clamp(vel.y, -velocityClamp, velocityClamp);
                vel.z = Mathf.Clamp(vel.z, -velocityClamp, velocityClamp);

                var deltaOffset = Time.fixedDeltaTime / 0.011111f;
                var inverseDeltaOffset = 0.011111f / Time.fixedDeltaTime;
                body.linearDamping = startDrag * inverseDeltaOffset;
                var maxDelta = deltaOffset;
                minVelocityChange *= deltaOffset;

                body.linearVelocity = new Vector3(
                    Mathf.MoveTowards(body.linearVelocity.x, vel.x, minVelocityChange + Mathf.Abs(body.linearVelocity.x) * maxDelta),
                    Mathf.MoveTowards(body.linearVelocity.y, vel.y, minVelocityChange + Mathf.Abs(body.linearVelocity.y) * maxDelta),
                    Mathf.MoveTowards(body.linearVelocity.z, vel.z, minVelocityChange + Mathf.Abs(body.linearVelocity.z) * maxDelta)
                );
            }
        }


        /// <summary>Rotates the hand to the controller rotation using physics movement</summary>
        protected virtual void TorqueTo() {
            var moveRot = moveTo.rotation;
            var delta = (moveRot * Quaternion.Inverse(body.rotation));
            delta.ToAngleAxis(out float angle, out Vector3 axis);

            if(float.IsInfinity(axis.x))
                return;

            if(angle > 180f)
                angle -= 360f;

            var multiLinear = Mathf.Deg2Rad * angle * followRotationStrength;
            Vector3 angular = multiLinear * axis.normalized;
            angle = Mathf.Abs(angle);

            var angleStrengthOffset = Mathf.Lerp(1f, 1.5f, angle/16f);
            var deltaOffset = Time.fixedDeltaTime / 0.011111f;
            var inverseDeltaOffset = 0.011111f / Time.fixedDeltaTime;
            body.angularDamping = Mathf.Lerp((startAngleDrag * 1.2f), startAngleDrag, angle/4f) * inverseDeltaOffset;
            var maxDelta = followRotationStrength * 50f * angleStrengthOffset;


            body.angularVelocity = new Vector3(
                Mathf.MoveTowards(body.angularVelocity.x, angular.x, maxDelta),
                Mathf.MoveTowards(body.angularVelocity.y, angular.y, maxDelta),
                Mathf.MoveTowards(body.angularVelocity.z, angular.z, maxDelta)
            );

        }


        int CollisionCount() {
            return grab.CollisionCount();
        }

        public void RemoveFollow(Hand hand, Transform follow) {
            hand.OnReleased -= OnHandReleased;

            if(this.follow1 == follow) {
                this.follow1 = null;
                hand1 = null;
            }
            if(follow2 == follow) {
                follow2 = null;
                hand2 = null;
            }

            if(this.follow1 == null && follow2 != null) {
                this.follow1 = follow2;
                this.hand1 = hand2;
                hand2 = null;
                follow2 = null;
            }

            if(this.follow1 == null && follow2 == null && !grab.beingGrabbed) {
                if(body != null) {
                    body.mass = startMass;
                    body.linearDamping = startDrag;
                    body.angularDamping = startAngleDrag;
                    body.useGravity = useGravity;
                }
                Destroy(this);
            }

            heldMoveTo.Remove(hand);
        }

        private void OnDestroy()
        {
            if(moveTo != null)
                Destroy(moveTo.gameObject);

            foreach(var transform in heldMoveTo)
                Destroy(transform.Value.gameObject);

            if (body != null)
            {
                body.mass = startMass;
                body.linearDamping = startDrag;
                body.angularDamping = startAngleDrag;
                body.useGravity = useGravity;
            }
        }


    }


}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/WeightlessFollower.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/Finger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7efad4f49bdc399409aae0e128b0ad2b
# ASMDEF: AutoHandAssembly.dll
# ---

using System;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {

    public enum FingerEnum {
        none = -1,
        index,
        middle,
        ring,
        pinky,
        thumb
    }

    public enum FingerJointEnum {
        knuckle,
        middle,
        distal,
        tip
    }

    //You can add more poses here and they will automatically be added to the hands save pose button list
    //Dont change the order of the poses, only add new ones to the end
    public enum FingerPoseEnum {
        Open = 0,
        Closed = 1,
        PinchOpen = 2,
        PinchClosed = 3,
        TotalPoses
    }

    [System.Serializable]
    public struct FingerMask {
        public FingerEnum finger;
        public float weight;
    }



    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/hand/finger-component")]
    public class Finger : MonoBehaviour {
        [Header("Hand Reference")]
        public Hand hand;
        [Header("Finger Joints")]
        public FingerEnum fingerType = FingerEnum.none;
        [Tooltip("This is the first joint on the finger, the knuckle that rotates the whole finger, on the thumb this should be joint closer the wrist (The first joint on your actual thumb that moves)")]
        public Transform knuckleJoint;
        [Tooltip("The second joint that connect the primary finger bone to the middle finger bone")]
        public Transform middleJoint;
        [Tooltip("The third that attached the middle finger bone and the top bone")]
        public Transform distalJoint;
        [Space]
        [Header("Finger Tip")]
        [Tooltip("This transfrom will represent the tip/stopper of the finger")]
        public Transform tip;
        [Tooltip("This determines the radius of the spherecast check when bending fingers")]
        public float tipRadius = 0.01f;
        [Tooltip("This will offset the fingers bend (0 is no bend, 1 is full bend)")]
        [Range(0, 1f)]
        public float bendOffset;
        public float fingerSmoothSpeed = 1;

        [HideInInspector]
        public float secondaryOffset = 0;

        public Transform[] FingerJoints {
            get {
                if(fingerJoints == null || fingerJoints.Length == 0)
                    fingerJoints = new Transform[] { knuckleJoint, middleJoint, distalJoint, tip };

                return fingerJoints;
            }
        }

        [SerializeField, HideInInspector]
        Transform[] fingerJoints;

        [SerializeField, HideInInspector]
        public FingerPoseData[] poseData;



        FingerPoseData _poseDataNonAlloc;
        public FingerPoseData poseDataNonAlloc {
            get {
                if(!_poseDataNonAlloc.isSet) {
                    _poseDataNonAlloc = new FingerPoseData();
                    _poseDataNonAlloc.poseRelativeMatrix = new Matrix4x4[4];
                    _poseDataNonAlloc.localRotations = new Quaternion[4];
                }
                return _poseDataNonAlloc;
            }
        }

        float bend = 0;


        //DEPRICATED FINGER POSE DATA
        [SerializeField]
        [HideInInspector]
        internal Quaternion[] minGripRotPose;

        [SerializeField]
        [HideInInspector]
        internal Vector3[] minGripPosPose;

        [SerializeField]
        [HideInInspector]
        internal Quaternion[] maxGripRotPose;

        [SerializeField]
        [HideInInspector]
        internal Vector3[] maxGripPosPose;

        public bool isMissingReferences { get { return knuckleJoint == null || middleJoint == null || distalJoint == null || tip == null; } }

        public bool isDataDepricated {
            get {
                return poseData == null || poseData.Length == 0 || (minGripPosPose.Length > 0 && poseData[(int)FingerPoseEnum.Open].isSet == false) || (maxGripPosPose.Length > 0 && poseData[(int)FingerPoseEnum.Closed].isSet == false);
            }
        }

        float lastHitBend;
        Collider[] results = new Collider[4];


        protected virtual void Awake() {
            if(hand == null)
                hand = GetComponentInParent<Hand>();
            if(hand == null)
                Debug.LogError("AUTO HAND: Missing hand reference, please assign the hand reference to the finger component", this);

            if(isDataDepricated)
                UpdateDepricatedValues();

            for(int i = 0; i < poseData.Length; i++)
                if(poseData[i].isSet)
                    poseData[i].CalculateAdditionalValues(hand.transform.lossyScale);


            if((knuckleJoint == null || middleJoint == null || distalJoint == null || tip == null))
                Debug.LogError("AUTO HAND: Missing finger connections, please connect all the joint values of the finger component (If your finger has less than the required joints add the same joint to two inputs)", this);
            if(poseData == null || poseData.Length == 0)
                Debug.LogError("AUTO HAND: Missing finger pose data, please set the open and closed finger pose data (If you have not set this up please do so in the inspector or use the context menu to set the open and closed finger pose data)", this);

        }




        /// <summary>Forces the finger to a bend until it hits something on the given physics layer</summary>
        /// <param name="steps">The number of steps and physics checks it will make lerping from 0 to 1</param>
        public virtual bool BendFingerUntilNoHit(int steps, int layermask, FingerPoseEnum fromPose = FingerPoseEnum.Open, FingerPoseEnum toPose = FingerPoseEnum.Closed) {
            return BendFingerUntilNoHit(steps, layermask, ref poseData[(int)fromPose], ref poseData[(int)toPose]);
        }

        /// <summary>Forces the finger to a bend until it hits something on the given physics layer</summary>
        /// <param name="steps">The number of steps and physics checks it will make lerping from 0 to 1</param>
        public virtual bool BendFingerUntilNoHit(int steps, int layermask, ref FingerPoseData fromPose, ref FingerPoseData toPose) {
            lastHitBend = 0;
            var fingerTipTransform = tip.transform;
            var handTransform = hand.transform;
            var handPosition = handTransform.position;
            var handRotation = handTransform.rotation;

            Vector3 lastFingerPos = Vector3.zero;
            for(float i = 0; i <= steps / 5f; i++) {
                lastHitBend = i / (steps / 5f);
                int overlapCount = CheckFingerBlendOverlap(layermask, handRotation, fingerTipTransform, ref fromPose, ref toPose, lastHitBend);

                if(overlapCount == 0) {
                    lastHitBend = Mathf.Clamp01(lastHitBend);
                    if(i == 0) {
                        poseDataNonAlloc.SetFingerPose(this, handRotation, knuckleJoint, middleJoint, distalJoint);
                        bend = lastHitBend;
                        //currBendOffset = lastHitBend;
                        return true;
                    }
                    break;
                }

            }

            lastHitBend -= (5f / steps);
            for(int i = 0; i <= steps / 10f; i++) {
                lastHitBend += (1f / steps);
                lastHitBend = Mathf.Clamp01(lastHitBend);
                int overlapCount = CheckFingerBlendOverlap(layermask, handRotation, fingerTipTransform, ref fromPose, ref toPose, lastHitBend);

                if(overlapCount == 0 || lastHitBend >= 1) {
                    bend = lastHitBend;
                    //currBendOffset = lastHitBend;
                    return true;
                }
            }

            lastHitBend = 1f;
            toPose.SetFingerPose(this, handRotation, knuckleJoint, middleJoint, distalJoint);
            return false;
        }



        /// <summary>Forces the finger to a bend until it hits something on the given physics layer</summary>
        /// <param name="steps">The number of steps and physics checks it will make lerping from 0 to 1</param>
        public virtual bool BendFingerUntilHit(int steps, int layermask, FingerPoseEnum fromPose = FingerPoseEnum.Open, FingerPoseEnum toPose = FingerPoseEnum.Closed) {
            return BendFingerUntilHit(steps, layermask, ref poseData[(int)fromPose], ref poseData[(int)toPose]);
        }

        /// <summary>Forces the finger to a bend until it hits something on the given physics layer</summary>
        /// <param name="steps">The number of steps and physics checks it will make lerping from 0 to 1</param>
        public virtual bool BendFingerUntilHit(int steps, int layermask, ref FingerPoseData fromPose, ref FingerPoseData toPose) {
            lastHitBend = 0;
            var fingerTipTransform = tip.transform;
            var handRotation = hand.transform.rotation;
            for(float i = 0; i <= steps / 5f; i++) {
                lastHitBend = i / (steps / 5f);
                int overlapCount = CheckFingerBlendOverlap(layermask, handRotation, fingerTipTransform, ref fromPose, ref toPose, lastHitBend);

                if(overlapCount > 0) {
                    lastHitBend = Mathf.Clamp01(lastHitBend);
                    if(i == 0) {
                        poseDataNonAlloc.SetFingerPose(this, handRotation, knuckleJoint, middleJoint, distalJoint);
                        bend = lastHitBend;
                        return true;
                    }
                    break;
                }

            }

            lastHitBend -= (5f / steps);
            for(int i = 0; i <= steps / 10f; i++) {
                lastHitBend += (1f / steps);
                lastHitBend = Mathf.Clamp01(lastHitBend);
                int overlapCount = CheckFingerBlendOverlap(layermask, handRotation, fingerTipTransform, ref fromPose, ref toPose, lastHitBend);

                if(overlapCount > 0 || lastHitBend >= 1) {
                    bend = lastHitBend;
                    //currBendOffset = lastHitBend;
                    return true;
                }
            }

            lastHitBend = 1f;
            toPose.SetFingerPose(this, handRotation, knuckleJoint, middleJoint, distalJoint); ;
            return false;
        }

        public virtual int CheckFingerBlendOverlap(int layermask, Quaternion handRotation, Transform fingerTipTransform, ref FingerPoseData fromPose, ref FingerPoseData toPose, float point) {
            poseDataNonAlloc.LerpData(ref fromPose, ref toPose, point, false);
            poseDataNonAlloc.SetFingerPose(this, handRotation, knuckleJoint, middleJoint, distalJoint);
            return Physics.OverlapSphereNonAlloc(fingerTipTransform.position, tipRadius, results, layermask, QueryTriggerInteraction.Ignore);
        }






        public virtual void UpdateFingerPose(float bend, FingerPoseEnum fromPose = FingerPoseEnum.Open, FingerPoseEnum toPose = FingerPoseEnum.Closed) { 
            UpdateFingerPose(bend, ref poseData[(int)fromPose], ref poseData[(int)toPose]);
        }

        public virtual void UpdateFingerPose(float bend, ref FingerPoseData fromPose, ref FingerPoseData toPose) {
            this.bend = bend;

            poseDataNonAlloc.LerpData(ref fromPose, ref toPose, bend);
            poseDataNonAlloc.SetFingerPose(this);
        }



        public virtual void SetFingerBend(float bend, ref FingerPoseData fromPose, ref FingerPoseData toPose) {
            this.bend = bend;
            poseDataNonAlloc.LerpData(ref fromPose, ref toPose, bend);
            poseDataNonAlloc.SetFingerPose(this);
        }

        /// <summary>Forces the finger to a bend ignoring physics and offset</summary>
        /// <param name="bend">0 is no bend / 1 is full bend</param>
        public virtual void SetFingerBend(float bend, FingerPoseEnum fromPose = FingerPoseEnum.Open, FingerPoseEnum toPose = FingerPoseEnum.Closed) {
            this.bend = bend;
            SetFingerBend(bend, ref poseData[(int)fromPose], ref poseData[(int)toPose]);
        }




        /// <summary>Sets the current finger to a bend without interfering with the target</summary>
        /// <param name="bend">0 is no bend / 1 is full bend</param>
        //public void SetCurrentFingerBend(float bend, FingerPoseEnum fromPose = FingerPoseEnum.Open, FingerPoseEnum toPose = FingerPoseEnum.Closed) {
        //    currBendOffset = bend;

        //    var openPose = poseData[(int)fromPose];
        //    var closedPose = poseData[(int)toPose];

        //    poseDataNonAlloc.LerpData(ref openPose, ref closedPose, bend);
        //    poseDataNonAlloc.SetFingerPose(this);
        //}



        [ContextMenu("Open")]
        public virtual void ResetBend() {
            var openPose = poseData[(int)FingerPoseEnum.Open];
            openPose.SetFingerPose(this);
        }

        [ContextMenu("Close")]
        public virtual void Grip() {
            var closedPose = poseData[(int)FingerPoseEnum.Closed];
            closedPose.SetFingerPose(this);
        }


        /// <summary>Returns the bend the finger ended with from the last BendFingerUntilHit() call</summary>
        public float GetLastHitBend() {
            return lastHitBend;
        }

        /// <summary>Saves the current pose the finger is taking to the given pose type</summary>
        public virtual void SavePose(Hand hand, Finger finger, FingerPoseEnum poseType) {
            if(poseData == null)
                poseData = new FingerPoseData[(int)FingerPoseEnum.TotalPoses];

            if(poseData.Length != (int)FingerPoseEnum.TotalPoses) {
                var oldData = poseData;
                poseData = new FingerPoseData[(int)FingerPoseEnum.TotalPoses];
                for(int i = 0; i < oldData.Length; i++) {
                    poseData[i] = oldData[i];
                }
            }

            Debug.Log("Pose Type: " + poseType + " - " + (int)poseType + " - Length: " + poseData.Length);

            if(!poseData[(int)poseType].isSet)
                poseData[(int)poseType] = new FingerPoseData(hand, finger);
            else
                poseData[(int)poseType].SetPoseData(hand, finger);
        }

        public virtual void SavePose(ref FingerPoseData fingerPoseData, FingerPoseEnum poseType) {
            if(!poseData[(int)poseType].isSet)
                poseData[(int)poseType] = new FingerPoseData(ref fingerPoseData);
            else
                poseData[(int)poseType].CopyFromData(ref fingerPoseData);
        }

        [ContextMenu("SAVE - Open Pose")]
        public void SaveOpenPose() {
            SavePose(hand, this, FingerPoseEnum.Open);
        }

        [ContextMenu("SAVE - Closed Pose")]
        public void SaveClosedPose() {
            SavePose(hand, this, FingerPoseEnum.Closed);
        }

        [ContextMenu("SAVE - Pinch Open Pose")]
        public void SavePinchOpenPose() {
            SavePose(hand, this, FingerPoseEnum.PinchOpen);
        }

        [ContextMenu("SAVE - Pinch Closed Pose")]
        public void SavePinchClosedPose() {
            SavePose(hand, this, FingerPoseEnum.PinchClosed);
        }


        /// <summary>Copies the pose data from the given finger to this finger</summary>
        public virtual void CopyPoseData(Finger finger) {
            for(int i = 0; i < finger.poseData.Length; i++) {
                if(poseData[i].isSet)
                    poseData[i].CopyFromData(finger.poseData[i]);
                else
                    poseData[i] = new FingerPoseData(ref finger.poseData[i]);
            }

        }

        /// <summary>Checks if the given pose type has been saved</summary>
        public virtual bool IsPoseSaved(FingerPoseEnum poseType) {
            if((int)poseType >= poseData.Length)
                return false;

            return (poseData != null && poseData.Length != 0) && poseData[(int)poseType].poseRelativeMatrix != null && poseData[(int)poseType].poseRelativeMatrix.Length > 0;
        }

        public virtual float GetCurrentBend() {
            bendOffset = Mathf.Clamp(bendOffset, 0, 1);
            return bendOffset+secondaryOffset;
        }


        private void OnDrawGizmos() {
            if(tip == null)
                return;

            Gizmos.color = Color.cyan;
            Gizmos.DrawWireSphere(tip.transform.position, tipRadius);
        }


        public bool UpdateDepricatedValues() {

            try {
                if(hand == null)
                    hand = GetComponentInParent<Hand>();
                if(hand == null)
                    Debug.LogError("AUTO HAND: Missing hand reference, please assign the hand reference to the finger component", this);

                //Find enum type
                if(fingerType == FingerEnum.none) {
                    int fingerIndex = -1;
                    for(int i = 0; i < 5; i++) {
                        string enumFingerNames = Enum.GetName(typeof(FingerEnum), (FingerEnum)i).ToLower();
                        if(name.ToLower().Contains(enumFingerNames)) {
                            fingerIndex = i;
                            fingerType = (FingerEnum)fingerIndex;
                            break;
                        }
                    }

                    if(fingerIndex == -1) {
                        Debug.LogError("AUTO HAND: Could not find finger type in name, please set the finger type manually", this);
                        return false;
                    }
                }


                bool missingSetup = (knuckleJoint == null || middleJoint == null || distalJoint == null || tip == null);
                //Set up finger joints if none
                if(missingSetup && fingerType != FingerEnum.none) {
                    //If it has just 4 points we assume it's knuck->middle->distle->tip it doesn't have any additional joints
                    if(fingerJoints.Length == 3) {
                        if(knuckleJoint == null)
                            knuckleJoint = fingerJoints[0];
                        if(middleJoint == null)
                            middleJoint = fingerJoints[1];
                        if(distalJoint == null)
                            distalJoint = fingerJoints[2];
                    }
                    else {
                        Debug.LogError("AUTO HAND: Could not find correct finger joint, unsure about automatic setup, place connected finger values manually", this);
                        return false;
                    }
                }

                missingSetup = (knuckleJoint == null || middleJoint == null || distalJoint == null || tip == null);
                if(missingSetup) {
                    Debug.LogError("AUTO HAND: Missing finger connections, please connect all the joint values of the finger component (If your finger has less than the required joints add the same joint to two inputs)", this);
                    return false;
                }

                if(fingerJoints.Length > 0 && minGripPosPose.Length == fingerJoints.Length && maxGripPosPose.Length == fingerJoints.Length) {

                    var knuckleJointIndex = -1;
                    var middleJointIndex = -1;
                    var distalJointIndex = -1;

                    for(int i = 0; i < fingerJoints.Length; i++) {
                        if(fingerJoints[i] == knuckleJoint)
                            knuckleJointIndex = i;
                        if(fingerJoints[i] == middleJoint)
                            middleJointIndex = i;
                        if(fingerJoints[i] == distalJoint)
                            distalJointIndex = i;
                    }

                    var fingerPosesEnumCount = Enum.GetValues(typeof(FingerPoseEnum)).Length;
                    if(poseData == null || poseData.Length != fingerPosesEnumCount) {
                        poseData = new FingerPoseData[fingerPosesEnumCount];

                    }

                    var knuckleJointPosition = minGripPosPose[knuckleJointIndex];
                    var middleJointPosition = minGripPosPose[middleJointIndex];
                    var distalJointPosition = minGripPosPose[distalJointIndex];

                    var knuckleJointRotation = minGripRotPose[knuckleJointIndex];
                    var middleJointRotation = minGripRotPose[middleJointIndex];
                    var distalJointRotation = minGripRotPose[distalJointIndex];

                    var knuckleStartPosition = knuckleJoint.localPosition;
                    var middleStartPosition = middleJoint.localPosition;
                    var distalStartPosition = distalJoint.localPosition;

                    var knuckleStartRotation = knuckleJoint.localRotation;
                    var middleStartRotation = middleJoint.localRotation;
                    var distalStartRotation = distalJoint.localRotation;

                    knuckleJoint.localPosition = knuckleJointPosition;
                    middleJoint.localPosition = middleJointPosition;
                    distalJoint.localPosition = distalJointPosition;

                    knuckleJoint.localRotation = knuckleJointRotation;
                    middleJoint.localRotation = middleJointRotation;
                    distalJoint.localRotation = distalJointRotation;

                    poseData[(int)FingerPoseEnum.Open] = new FingerPoseData(hand, this);

                    knuckleJointPosition = maxGripPosPose[knuckleJointIndex];
                    middleJointPosition = maxGripPosPose[middleJointIndex];
                    distalJointPosition = maxGripPosPose[distalJointIndex];

                    knuckleJointRotation = maxGripRotPose[knuckleJointIndex];
                    middleJointRotation = maxGripRotPose[middleJointIndex];
                    distalJointRotation = maxGripRotPose[distalJointIndex];

                    knuckleJoint.localPosition = knuckleJointPosition;
                    middleJoint.localPosition = middleJointPosition;
                    distalJoint.localPosition = distalJointPosition;

                    knuckleJoint.localRotation = knuckleJointRotation;
                    middleJoint.localRotation = middleJointRotation;
                    distalJoint.localRotation = distalJointRotation;

                    poseData[(int)FingerPoseEnum.Closed] = new FingerPoseData(hand, this);

                    knuckleJoint.localPosition = knuckleStartPosition;
                    middleJoint.localPosition = middleStartPosition;
                    distalJoint.localPosition = distalStartPosition;

                    knuckleJoint.localRotation = knuckleStartRotation;
                    middleJoint.localRotation = middleStartRotation;
                    distalJoint.localRotation = distalStartRotation;

#if UNITY_EDITOR
                    UnityEditor.EditorUtility.SetDirty(this);
#endif

                    Debug.LogWarning("AUTO HAND: Automatically updating finger joint data, recommend doing this manually to ensure correct setup", this);
                }


                for(int i = 0; i < poseData.Length; i++) {
                    if(poseData[i].isSet)
                        poseData[i].CalculateAdditionalValues(hand.transform.lossyScale);
                }

                return true;
            }
            catch(System.Exception e) {
                Debug.LogWarning("AUTO HAND: Error updating finger values, please check the finger component for errors or manually redo the hand Open/Closed pose after setting all finger values", this);
                Debug.LogWarning(e);
                return false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/Finger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerGizmo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 48b44988d9ac3ad4d829d672b3d86020
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {

    public static class FingerGizmo {


        public static void DrawFingerPoseExample(FingerPoseData fingerPose, Matrix4x4 grabbableToWorld, Matrix4x4 handToGrabbable, Color color) {
            Matrix4x4 handGlobalMatrix = grabbableToWorld * handToGrabbable;
            var kuckleToHandMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            var middleToKnuckleMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.middle];
            var distalToMiddleMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.distal];
            var tipToDistalMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.tip];

            var knuckleGlobalMatrix = handGlobalMatrix * kuckleToHandMatrix;
            var middleGlobalMatrix = knuckleGlobalMatrix * middleToKnuckleMatrix;
            var distalGlobalMatrix = middleGlobalMatrix * distalToMiddleMatrix;
            var tipGlobalMatrix = distalGlobalMatrix * tipToDistalMatrix;

            var handPosition = AutoHandExtensions.ExtractPosition(ref handGlobalMatrix);
            var knucklePosition = AutoHandExtensions.ExtractPosition(ref knuckleGlobalMatrix);
            var middlePosition = AutoHandExtensions.ExtractPosition(ref middleGlobalMatrix);
            var distalPosition = AutoHandExtensions.ExtractPosition(ref distalGlobalMatrix);
            var tipPosition = AutoHandExtensions.ExtractPosition(ref tipGlobalMatrix);

            Gizmos.color = color;
            Gizmos.DrawLine(handPosition, knucklePosition);
            Gizmos.DrawLine(knucklePosition, middlePosition);
            Gizmos.DrawLine(middlePosition, distalPosition);
            Gizmos.DrawLine(distalPosition, tipPosition);

            Gizmos.DrawWireSphere(knucklePosition, 0.004f);
            Gizmos.DrawWireSphere(middlePosition, 0.004f);
            Gizmos.DrawWireSphere(distalPosition, 0.004f);
            Gizmos.DrawWireSphere(tipPosition, 0.004f);
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerGizmo.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerTriggerAreaEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6a33e6ce4c2567a4e8dea64cbe24ebe6
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class FingerTriggerAreaEvents : HandTriggerAreaEvents
{
    [Header("Finger Trigger Events")]
    public FingerEnum[] allowedFingers;
    [Space]
    public UnityEvent<Finger, FingerTriggerAreaEvents> FingerEnterEvent;
    public UnityEvent<Finger, FingerTriggerAreaEvents> FingerExitEvent;

    protected Collider[] triggerAreaColliders;
    protected GameObject[] triggerAreaObjects;
    protected int[] startingLayers;

    Collider[] colliderNonAlloc = new Collider[32];
    bool validState = false;
    bool lastValidState = false;
    Finger currentFinger;

    protected virtual void Awake() {
        triggerAreaColliders = GetComponentsInChildren<Collider>();
        startingLayers = new int[triggerAreaColliders.Length];
        triggerAreaObjects = new GameObject[triggerAreaColliders.Length];
        for(int i = 0; i < triggerAreaColliders.Length; i++) {
            startingLayers[i] = triggerAreaColliders[i].gameObject.layer;
            triggerAreaObjects[i] = triggerAreaColliders[i].gameObject;
        }
    }


    protected virtual void FixedUpdate() {
        CheckFingerOverlapEvents();
    }

    protected virtual void CheckFingerOverlapEvents() {
        validState = false;

        if(hands.Count > 0) {
            var layer = LayerMask.NameToLayer(Hand.grabbingLayerName);
            var layerMask = LayerMask.GetMask(Hand.grabbingLayerName);
            for(int i = 0; i < triggerAreaColliders.Length; i++)
                triggerAreaObjects[i].layer = layer;

            foreach(var hand in hands) {
                foreach(var finger in hand.fingers) {
                    for(int i = 0; i < allowedFingers.Length; i++) {
                        if(finger.fingerType == allowedFingers[i]) {
                            int overlapCount = Physics.OverlapSphereNonAlloc(finger.tip.position, finger.tipRadius, colliderNonAlloc, layerMask, QueryTriggerInteraction.Collide);
                            if(overlapCount > 0) {
                                validState = true;
                                currentFinger = finger;
                                if(validState != lastValidState)
                                    OnFingerEnter(finger);
                                break;
                            }
                        }
                    }
                }
            }

            for(int i = 0; i < startingLayers.Length; i++)
                triggerAreaObjects[i].layer = startingLayers[i];
        }

        if(validState != lastValidState) {
            if(validState == false)
                OnFingerExit(currentFinger);
        }

        if(validState == false)
            currentFinger = null;
        lastValidState = validState;
    }

    protected virtual void OnFingerEnter(Finger finger) {
        FingerEnterEvent?.Invoke(finger, this);
    }

    protected virtual void OnFingerExit(Finger finger) {
        FingerExitEvent?.Invoke(finger, this);
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerTriggerAreaEvents.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerTriggerAreaToggleEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 21e9ee66b17487c4e93f9d7b5fe26df5
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand
{
    [RequireComponent(typeof(FingerTriggerAreaEvents))]
    public class FingerTriggerAreaToggleEvents : MonoBehaviour
    {
        public UnityEvent<Finger, FingerTriggerAreaEvents> ToggleOn;
        public UnityEvent<Finger, FingerTriggerAreaEvents> ToggleOff;

        bool toggleState = false;

        void OnEnable() {
            GetComponent<FingerTriggerAreaEvents>().FingerEnterEvent.AddListener(Toggle);
        }

        void OnDisable() {
            GetComponent<FingerTriggerAreaEvents>().FingerEnterEvent.RemoveListener(Toggle);
        }

        void Toggle(Finger finger, FingerTriggerAreaEvents triggerArea) {
            toggleState = !toggleState;
            if(toggleState)
                ToggleOn.Invoke(finger, triggerArea);
            else
                ToggleOff.Invoke(finger, triggerArea);

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerTriggerAreaToggleEvents.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/Hand.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9413d460e98076241a1f46c91201217d
# ASMDEF: AutoHandAssembly.dll
# ---
using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.XR;

namespace Autohand {


    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/hand"), DefaultExecutionOrder(10)]
    public class Hand : HandBase {


        [AutoToggleHeader("Enable Highlight", 0, 0, tooltip = "Raycasting for grabbables to highlight is expensive, you can disable it here if you aren't using it")]
        public bool usingHighlight = true;

        [EnableIf("usingHighlight")]
        [Tooltip("The layers to highlight and use look assist on --- Nothing will default on start")]
        public LayerMask highlightLayers;

        [EnableIf("usingHighlight")]
        [Tooltip("Leave empty for none - used as a default option for all grabbables with empty highlight material")]
        public Material defaultHighlight;


        [AutoSmallHeader("Advanced Settings")]
        public bool showAdvanced = false;

        [Tooltip("The hand will automatically apply a no friction physics material to each hand collider on start")]
        public bool noHandFriction = true;

        [Tooltip("Any layers in this mask will be removed from the spherecast checking if a grab is possible: " +
            "IMPORTANT!!! This does not only apply to grabbables, any layers included in  this mask will be completely ignored meaning the hand can grab and highlight objects through with these layers")]
        public LayerMask ignoreGrabCheckLayers;

        [Tooltip("Whether the hand should go to the object and come back on grab, or the object to float to the hand on grab. Will default to HandToGrabbable for objects that have \"parentOnGrab\" disabled")]
        public GrabType grabType = GrabType.HandToGrabbable;

        [Tooltip("The animation curve based on the grab time 0-1"), Min(0)]
        public AnimationCurve grabCurve;

        [Tooltip("Makes grab smoother; also based on range and reach distance - a very near grab is minGrabTime and a max distance grab is maxGrabTime"), Min(0)]
        public float minGrabTime = 0.04f;

        [Tooltip("Makes grab smoother; also based on range and reach distance - a very near grab is minGrabTime and a max distance grab is maxGrabTime"), Min(0)]
        public float maxGrabTime = 0.33f;


        [Tooltip("Increasing this value will make grabbing faster based on controller velocity during grab. Setting this value to 0 will disable this feature. When grabbing an object the speed it takes for the hand to reach the object is decreased based on the velocity of the controller while grabbing"), Min(0)]
        public float velocityGrabHandAmplifier = 600;

        [Tooltip("Increasing this value will make grabbing faster based on grab target velocity during grab. Setting this value to 0 will disable this feature. When grabbing an object the speed it takes for the hand to reach the object is decreased based on the velocity of the controller while grabbing"), Min(0)]
        public float velocityGrabObjectAmplifier = 100;

        [Tooltip("The point along the grab time 0-1 where the hand has been transitioned from whatever pose it was when grabbing to its open hand pose"), Range(0, 1)]
        public float grabOpenHandPoint = 0.5f;

        [Tooltip("This is used in conjunction with custom poses. For a custom pose to work it must has the same PoseIndex as the hand. Used for when your game has multiple hands")]
        public int poseIndex = 0;

        [AutoLine]
        public bool ignoreMe1;





#if UNITY_EDITOR
        bool editorSelected = false;
#endif


        public static string[] grabbableLayers = { "Grabbable", "Grabbing" };

        //The layer is used and applied to all grabbables in if the hands layer is set to default
        public static string grabbableLayerNameDefault = "Grabbable";
        //This helps the auto grab distinguish between what item is being grabbaed and the items around it
        public static string grabbingLayerName = "Grabbing";

        //This was added by request just in case you want to add different layers for left/right hand
        public static string rightHandLayerName = "Hand";
        public static string leftHandLayerName = "Hand";



        ///Events for all my programmers out there :)/// 
        /// <summary>Called when the grab event is triggered, event if nothing is being grabbed</summary>
        public event HandGrabEvent OnTriggerGrab;
        /// <summary>Called at the very start of a grab before anything else</summary>
        public event HandGrabEvent OnBeforeGrabbed;
        /// <summary>Called when the hand grab connection is made (the frame the hand touches the grabbable)</summary>
	    public event HandGrabEvent OnGrabbed;

        /// <summary>Called when the release event is triggered, event if nothing is being held</summary>
        public event HandGrabEvent OnTriggerRelease;
        public event HandGrabEvent OnBeforeReleased;
        /// <summary>Called at the end the release</summary>
        public event HandGrabEvent OnReleased;

        /// <summary>Called when the squeeze button is pressed, regardless of whether an object is held or not (grab returns null)</summary>
        public event HandGrabEvent OnSqueezed;
        /// <summary>Called when the squeeze button is released, regardless of whether an object is held or not (grab returns null)</summary>
        public event HandGrabEvent OnUnsqueezed;


        /// <summary>Called whenever joint breaks or force release event is called</summary>
        public event HandGrabEvent OnForcedRelease;
        /// <summary>Called when the physics joint between the hand and the grabbable is broken by force</summary>
        public event HandGrabEvent OnGrabJointBreak;

        /// <summary>Legacy Event - same as OnRelease</summary>
        public event HandGrabEvent OnHeldConnectionBreak;

        public event HandGameObjectEvent OnHandCollisionStart;
        public event HandGameObjectEvent OnHandCollisionStop;
        public event HandGameObjectEvent OnHandTriggerStart;
        public event HandGameObjectEvent OnHandTriggerStop;

        public Hand copyFromHand;

        public Grabbable lastHoldingObj { get; private set; }

        public Grabbable lookingAtObj { get { return highlighter.currentHighlightTarget; } }
        public Vector3 lastFollowPosition { get { return handFollow.lastFrameFollowPosition; }  }
        public Quaternion lastFollowRotation { get { return handFollow.lastFrameFollowRotation; } }



        List<HandTriggerAreaEvents> triggerEventAreas = new List<HandTriggerAreaEvents>();

        float startGrabDist;
        Vector3 startHandLocalGrabPosition;


        Coroutine _grabRoutine;
        Coroutine grabRoutine {
            get { return _grabRoutine; }
            set {
                if(value != null && _grabRoutine != null) {
                    StopCoroutine(_grabRoutine);
                    if(holdingObj != null) {
                        holdingObj.body.linearVelocity = Vector3.zero;
                        holdingObj.body.angularVelocity = Vector3.zero;
                        holdingObj.beingGrabbed = false;
                    }
                    BreakGrabConnection();
                }
                _grabRoutine = value;
            }
        }


        protected override void Awake() {
            this.SetLayerRecursive(transform, LayerMask.NameToLayer(left ? Hand.leftHandLayerName : Hand.rightHandLayerName));

            if(highlightLayers.value == 0 || highlightLayers == LayerMask.GetMask("")) {
                highlightLayers = LayerMask.GetMask(grabbableLayerNameDefault);
            }

            handLayers = LayerMask.GetMask(rightHandLayerName, leftHandLayerName, AutoHandPlayer.HandPlayerLayer);
            handIgnoreCollisionLayers = AutoHandExtensions.GetPhysicsLayerMask(LayerMask.NameToLayer(rightHandLayerName)) & AutoHandExtensions.GetPhysicsLayerMask(LayerMask.NameToLayer(leftHandLayerName));

            if(grabCurve == null || grabCurve.keys.Length == 0)
                grabCurve = AnimationCurve.Linear(0, 0, 1, 1);

            base.Awake();
        }


        protected virtual void Start()
        {
            if(noHandFriction) {
                var noFrictionMat = Resources.Load<PhysicsMaterial>("NoFriction");
                foreach(var collider in handColliders) {
                    collider.material = noFrictionMat;
                }
            }

#if UNITY_EDITOR
            if (Selection.activeGameObject == gameObject)
            {
                Selection.activeGameObject = null;
                Debug.Log("Auto Hand: highlighting hand component in the inspector can cause lag and quality reduction at runtime in VR. (Automatically deselecting at runtime) Remove this code at any time.", this);
                editorSelected = true;
            }

            Application.quitting += () => { if (editorSelected && Selection.activeGameObject == null) Selection.activeGameObject = gameObject; };
#endif
        }


        protected override void OnEnable() {
            base.OnEnable();
            collisionTracker.OnCollisionFirstEnter += OnCollisionFirstEnter;
            collisionTracker.OnCollisionLastExit += OnCollisionLastExit;
            collisionTracker.OnTriggerFirstEnter += OnTriggerFirstEnter;
            collisionTracker.OnTriggerLastExit += OnTriggerLastExit;

            collisionTracker.OnCollisionFirstEnter += OnCollisionFirstEnterEvent;
            collisionTracker.OnCollisionLastExit += OnCollisionLastExitEvent;
            collisionTracker.OnTriggerFirstEnter += OnTriggerFirstEnterEvent;
            collisionTracker.OnTriggerLastExit += OnTriggeLastExitEvent;

        }

        protected override void OnDisable() {
            foreach(var trigger in triggerEventAreas)
                trigger.Exit(this);

            base.OnDisable();
            collisionTracker.OnCollisionFirstEnter -= OnCollisionFirstEnter;
            collisionTracker.OnCollisionLastExit -= OnCollisionLastExit;
            collisionTracker.OnTriggerFirstEnter -= OnTriggerFirstEnter;
            collisionTracker.OnTriggerLastExit -= OnTriggerLastExit;

            collisionTracker.OnCollisionFirstEnter -= OnCollisionFirstEnterEvent;
            collisionTracker.OnCollisionLastExit -= OnCollisionLastExitEvent;
            collisionTracker.OnTriggerFirstEnter -= OnTriggerFirstEnterEvent;
            collisionTracker.OnTriggerLastExit -= OnTriggeLastExitEvent;
        }




        //================================================================
        //================== CORE INTERACTION FUNCTIONS ==================
        //================================================================


        /// <summary>Whether or not this hand can grab the grabbbale based on hand and grabbable settings</summary>
        public bool CanGrab(Grabbable grab) {
            if(grab == null)
                return false;

            var cantHandSwap = (grab.IsHeld() && grab.singleHandOnly && !grab.allowHeldSwapping);
            return (!IsGrabbing() && !cantHandSwap) && grab.CanGrab(this);
        }

        /// <summary>Function for controller trigger fully pressed -> Grabs whatever is directly in front of and closest to the hands palm (by default this is called by the hand controller link component)</summary>
        public virtual void Grab() {
            Grab(grabType);
        }

        /// <summary>Function for controller trigger fully pressed -> Grabs whatever is directly in front of and closest to the hands palm</summary>
        public virtual void Grab(GrabType grabType) {
            OnTriggerGrab?.Invoke(this, null);
            foreach(var triggerArea in triggerEventAreas) {
                triggerArea.Grab(this);
            }
            if(usingHighlight && !grabbing && holdingObj == null && highlighter.currentHighlightTarget != null) {
                
                grabType = GetGrabType(highlighter.currentHighlightTarget);
                grabRoutine = StartCoroutine(GrabObject(highlighter.GetHighlightHit(), highlighter.currentHighlightTarget, grabType));
            }
            else if(!grabbing && holdingObj == null) {
                highlighter.UpdateHighlight(true, true);
                if(highlighter.currentHighlightTarget != null) {

                    grabType = GetGrabType(highlighter.currentHighlightTarget);
                    grabRoutine = StartCoroutine(GrabObject(highlighter.GetHighlightHit(), highlighter.currentHighlightTarget, grabType));
                }

                highlighter.ClearHighlights();
            }

            else if(holdingObj != null && holdingObj.CanGetComponent(out GrabLock grabLock)) {
                grabLock.OnGrabPressed?.Invoke(this, holdingObj);
            }
        }

        /// <summary>Grabs based on raycast and grab input data</summary>
        public virtual void Grab(RaycastHit hit, Grabbable grab, GrabType grabType = GrabType.InstantGrab) {
            bool objectFree = grab.body.isKinematic != true && grab.body.constraints == RigidbodyConstraints.None;
            if(!grabbing && holdingObj == null && this.CanGrab(grab) && objectFree) {
                grabRoutine = StartCoroutine(GrabObject(hit, grab, grabType));
            }
        }

        GrabType GetGrabType(Grabbable grabbable) {
            GrabType grabType = this.grabType;
            if(grabbable.instantGrab)
                grabType = GrabType.InstantGrab;
            else if(grabbable.grabType != HandGrabType.Default) {
                switch(grabbable.grabType) {
                    case HandGrabType.HandToGrabbable:
                        grabType = GrabType.HandToGrabbable;
                        break;
                    case HandGrabType.GrabbableToHand:
                        grabType = GrabType.GrabbableToHand;
                        break;
                }
            }

            return grabType;
        }

        /// <summary>Grab a given grabbable</summary>
        public virtual void TryGrab(Grabbable grab) {
            ForceGrab(grab);
        }


        /// <summary>Alwyas grab a given grabbable, only works if grab is possible will automaticlly Instantiate a new copy of the given grabbable if using a prefab reference</summary>
        public virtual void ForceGrab(Grabbable grab, bool createCopy = false) {
            if(createCopy || !grab.gameObject.scene.IsValid())
                grab = Instantiate(grab);

            RaycastHit closestHit = new RaycastHit();
            closestHit.distance = float.MaxValue;
            if(!grabbing && holdingObj == null && this.CanGrab(grab)) {
                if(GetClosestGrabbableHit(grab, out closestHit))
                    Grab(closestHit, grab, GrabType.InstantGrab);
            }
        }

        /// <summary>Function for controller trigger unpressed (by default this is called by the hand controller link component)</summary>
        public virtual void Release() {
            OnTriggerRelease?.Invoke(this, null);

            foreach(var triggerArea in triggerEventAreas) {
                triggerArea.Release(this);
            }

            if(holdingObj && !holdingObj.wasForceReleased && holdingObj.CanGetComponent<GrabLock>(out GrabLock grablock) && grablock.enabled)
                return;

            if(holdingObj != null) {
                OnBeforeReleased?.Invoke(this, holdingObj);
                holdingObj.OnBeforeReleaseEvent?.Invoke(this, holdingObj);
                holdingObj.OnRelease(this);
                handFollow.ignoreMoveFrame = true;
            }

            BreakGrabConnection();
        }

        /// <summary>This will force release the hand without throwing or calling OnRelease\n like losing grip on something instead of throwing</summary>
        public virtual void ForceReleaseGrab() {
            if(holdingObj != null) {
                OnForcedRelease?.Invoke(this, holdingObj);
                holdingObj?.ForceHandRelease(this);
            }
        }

        /// <summary>Old function left for backward compatability -> Will release grablocks, recommend using ForceReleaseGrab() instead</summary>
        public virtual void ReleaseGrabLock() {
            ForceReleaseGrab();
        }

        /// <summary>Event for controller grip (by default this is called by the hand controller link component)</summary>
        public virtual void Squeeze() {
            OnSqueezed?.Invoke(this, holdingObj);
            holdingObj?.OnSqueeze(this);

            foreach(var triggerArea in triggerEventAreas)
                triggerArea.Squeeze(this);

            squeezing = true;
        }

        /// <summary>Returns the grab axis value from zero to one, (by default this is set by the hand controller link)</summary>
        public virtual float GetGripAxis() {
            return gripAxis;
        }

        /// <summary>Returns the squeeze value from zero to one, (by default this is set by the hand controller link)</summary>
        public float GetSqueezeAxis() {
            return squeezeAxis;
        }

        /// <summary>Event for controller ungrip</summary>
        public virtual void Unsqueeze() {
            squeezing = false;
            OnUnsqueezed?.Invoke(this, holdingObj);
            holdingObj?.OnUnsqueeze(this);

            foreach(var triggerArea in triggerEventAreas) {
                triggerArea.Unsqueeze(this);
            }
        }

        /// <summary>Breaks the grab event without calling the release functions and events</summary>
        public virtual void BreakGrabConnection(bool callEvent = true) {

            if(holdingObj != null) {
                if(squeezing)
                    holdingObj.OnUnsqueeze(this);

                if(grabbing) {
                    if (holdingObj.body != null && !holdingObj.body.isKinematic){
                        holdingObj.body.linearVelocity = Vector3.zero;
                        holdingObj.body.angularVelocity = Vector3.zero;
                    }
                }

                if(holdingObj.HeldCount() > 1)
                    ResetGrabOffset();

                if(holdingObj.ignoreReleaseTime == 0) {
                    transform.position = holdingObj.transform.InverseTransformPoint(startHandLocalGrabPosition);
                    body.position = transform.position;
                }

                holdingObj.BreakHandConnection(this);
                lastHoldingObj = holdingObj;
                lastReleaseTime = Time.time;
                holdingObj = null;
                OnHeldConnectionBreak?.Invoke(this, lastHoldingObj);
                OnReleased?.Invoke(this, lastHoldingObj);
            }
            else if(grabRoutine != null) {
                StopCoroutine(grabRoutine);
            }

            velocityTracker.Disable(throwVelocityExpireTime);
            currentHeldPose = null;
            grabRoutine = null;

            handAnimator.CancelPose(0.05f);

            if(heldJoint != null) {
                Destroy(heldJoint);
                heldJoint = null;
            }
        }



        /// <summary>Creates the grab connection at the current position of the hand and given grabbable</summary>
        public virtual void CreateGrabConnection(Grabbable grab, bool executeGrabEvents = false) {
            CreateGrabConnection(grab, transform.position, transform.rotation, grab.transform.position, grab.transform.rotation, executeGrabEvents);
        }

        /// <summary>Creates the grab connection</summary>
        public virtual void CreateGrabConnection(Grabbable grab, Vector3 handPos, Quaternion handRot, Vector3 grabPos, Quaternion grabRot, bool executeGrabEvents = false, bool ignorePoses = false) {

            if(executeGrabEvents) {
                OnBeforeGrabbed?.Invoke(this, grab);
                grab.OnBeforeGrab(this);
            }

            transform.position = handPos;
            body.position = handPos;
            transform.rotation = handRot;
            body.rotation = handRot;

            if(grab.body == null)
                grab.ActivateRigidbody();

            grab.transform.position = grabPos;
            grab.body.position = grabPos;
            grab.transform.rotation = grabRot;
            grab.body.rotation = grabRot;

            handGrabPoint.parent = grab.transform;
            handGrabPoint.position = handPos;
            handGrabPoint.rotation = handRot;


            startGrabDist = Vector3.Distance(palmTransform.position, handGrabPoint.position);
            startHandLocalGrabPosition = grab.transform.InverseTransformPoint(transform.position);

            holdingObj = grab;

            localGrabbablePoint.transform.position = holdingObj.rootTransform.position;
            localGrabbablePoint.transform.rotation = holdingObj.rootTransform.rotation;

            if(!(holdingObj.grabType == HandGrabType.GrabbableToHand) && !(grabType == GrabType.GrabbableToHand)) {
                ResetGrabOffset();
            }

            //If it's a predetermined Pose
            if(!ignorePoses && holdingObj.GetSavedPose(out var poseCombiner)) {
                if(poseCombiner.CanSetPose(this, holdingObj)) {
                    currentHeldPose = poseCombiner.GetClosestPose(this, holdingObj);
                    currentHeldPose.SetHandPose(this);
                }
            }


            //Hand Swap - One Handed Items
            if(holdingObj.singleHandOnly && holdingObj.HeldCount(false, false, false) > 0) {
                holdingObj.ForceHandRelease(holdingObj.GetHeldBy()[0]);
                if(holdingObj.body != null) {
                    holdingObj.body.linearVelocity = Vector3.zero;
                    holdingObj.body.angularVelocity = Vector3.zero;
                }
            }

            handAnimator.targetGrabPose.SavePose(this, holdingObj.transform);

            if(executeGrabEvents) {
                OnGrabbed?.Invoke(this, holdingObj);
                holdingObj.OnGrab(this);
            }

            grabbing = false;
            grabRoutine = null;

            CreateJoint(holdingObj, holdingObj.jointBreakForce, float.PositiveInfinity);
        }


        /// <summary>Creates Joints between hand and grabbable, does not call grab events</summary>
        public virtual void CreateJoint(Grabbable grab) {
            CreateJoint(grab, grab.jointBreakForce, float.PositiveInfinity);
        }

        /// <summary>Creates Joints between hand and grabbable, does not call grab events</summary>
        public virtual void CreateJoint(Grabbable grab, float breakForce, float breakTorque) {
            if(grab.customGrabJoint == null) {
                var jointCopy = (Resources.Load<ConfigurableJoint>("DefaultJoint"));
                var newJoint = gameObject.AddComponent<ConfigurableJoint>().GetCopyOf(jointCopy);
                newJoint.anchor = Vector3.zero;
                newJoint.breakForce = breakForce;
                if(grab.HeldCount() == 1)
                    newJoint.breakForce += 500;
                newJoint.breakTorque = breakTorque;
                newJoint.connectedBody = grab.body;
                newJoint.enablePreprocessing = jointCopy.enablePreprocessing;
                newJoint.autoConfigureConnectedAnchor = false;
                newJoint.connectedAnchor = grab.body.transform.InverseTransformPoint(handGrabPoint.position);
                newJoint.angularXMotion = jointCopy.angularXMotion;
                newJoint.angularYMotion = jointCopy.angularYMotion;
                newJoint.angularZMotion = jointCopy.angularZMotion;

                heldJoint = newJoint;
            }
            else {
                var newJoint = grab.body.gameObject.AddComponent<ConfigurableJoint>().GetCopyOf(grab.customGrabJoint);
                newJoint.anchor = Vector3.zero;
                if(grab.HeldCount() == 1)
                    newJoint.breakForce += 500;
                newJoint.breakForce = breakForce;
                newJoint.breakTorque = breakTorque;
                newJoint.connectedBody = body;
                newJoint.enablePreprocessing = grab.customGrabJoint.enablePreprocessing;
                newJoint.autoConfigureConnectedAnchor = false;
                newJoint.connectedAnchor = grab.body.transform.InverseTransformPoint(handGrabPoint.position);
                newJoint.angularXMotion = grab.customGrabJoint.angularXMotion;
                newJoint.angularYMotion = grab.customGrabJoint.angularYMotion;
                newJoint.angularZMotion = grab.customGrabJoint.angularZMotion;
                heldJoint = newJoint;
            }
        }


        public virtual void OnJointBreak(float breakForce) {
            if(heldJoint != null) {
                Destroy(heldJoint);
                heldJoint = null;
            }
            if(holdingObj != null) {
                holdingObj.body.linearVelocity /= 100f;
                holdingObj.body.angularVelocity /= 100f;
                OnGrabJointBreak?.Invoke(this, holdingObj);
                holdingObj?.OnHandJointBreak(this);
            }
        }




        //=================================================================
        //======================== GETTERS AND SETTERS ====================
        //=================================================================

        /// <summary>Takes a raycasthit and grabbable and automatically poses the hand</summary>
        public void AutoPose(RaycastHit hit, Grabbable grabbable) {
            var grabbingLayer = LayerMask.NameToLayer(Hand.grabbingLayerName);
            grabbable.SetLayerRecursive(grabbingLayer);

            Transform palmTransform = this.palmTransform;

            if(grabbable.grabPoseType == HandGrabPoseType.Pinch) {
                palmTransform = pinchPointTransform;
            }

            Vector3 palmLocalPos = palmTransform.localPosition;
            Quaternion palmLocalRot = palmTransform.localRotation;

            Vector3 hitColliderPosition = hit.collider.transform.position;
            Quaternion hitColliderRotation = hit.collider.transform.rotation;

            var palmColliderTransform = palmCollider.transform;

            var handTransform = transform;

            palmCollider.enabled = true;
            for(int i = 0; i < 12; i++)
                Calculate();
            palmCollider.enabled = false;

            void Calculate() {
                Align();

                var grabDir = hit.point - palmTransform.position;
                handTransform.position += grabDir;
                body.position = handTransform.position;

                if(Physics.ComputePenetration(hit.collider, hitColliderPosition, hitColliderRotation,
                    palmCollider, palmColliderTransform.position, palmColliderTransform.rotation, 
                    out var dir, out var dist)) {
                        handTransform.position -= dir * dist / 2f;
                        body.position = handTransform.position;
                }

                handTransform.position -= palmTransform.forward * grabDir.magnitude / 3f;
                body.position = handTransform.position;
            }

            void Align() {
                palmChild.position = handTransform.position;
                palmChild.rotation = handTransform.rotation;

                palmTransform.LookAt(hit.point, palmTransform.up);

                handTransform.position = palmChild.position;
                handTransform.rotation = palmChild.rotation;

                palmTransform.localPosition = palmLocalPos;
                palmTransform.localRotation = palmLocalRot;
            }

            var mask = LayerMask.GetMask(Hand.grabbingLayerName);
            if(grabbable.grabPoseType == HandGrabPoseType.Grab)
                foreach(var finger in fingers)
                    finger.BendFingerUntilHit(fingerBendSteps, mask);
            else
                foreach(var finger in fingers) {
                    if(!finger.BendFingerUntilHit(fingerBendSteps, mask, FingerPoseEnum.PinchOpen, FingerPoseEnum.PinchClosed))
                        finger.BendFingerUntilHit(fingerBendSteps, mask);
                }

            grabbable.ResetOriginalLayers();
        }


        public void BendFingersUntilHit(Grabbable grabbable) {
            var grabbingLayer = LayerMask.NameToLayer(Hand.grabbingLayerName);
            grabbable.SetLayerRecursive(grabbingLayer);

            var mask = LayerMask.GetMask(Hand.grabbingLayerName);
            if(grabbable.grabPoseType == HandGrabPoseType.Grab) {
                foreach(var finger in fingers)
                    finger.BendFingerUntilHit(fingerBendSteps, mask);
            }
            else {
                foreach(var finger in fingers) {
                    if(!finger.BendFingerUntilHit(fingerBendSteps, mask, FingerPoseEnum.PinchOpen, FingerPoseEnum.PinchClosed))
                        finger.BendFingerUntilHit(fingerBendSteps, mask);
                }
            }

            grabbable.ResetOriginalLayers();
        }

        /// <summary>Recalculates the grab point for the grabbing pose - should only be called in an OnBeforeGrab event</summary>
        public void RecalculateBeforeGrab(Grabbable grab) {
            if(GetClosestGrabbableHit(grab, out var closestHit)) {
                grabbingHit = closestHit;
            }
        }

        /// <summary>Recalulate Held Auto Pose - should only be called while holding an object</summary>
        public void RecaculateHeldAutoPose() {
            if(holdingObj != null && currentHeldPose == null) {
                transform.position -= palmTransform.forward * reachDistance;
                body.position = transform.position;
                var didHit = GetClosestGrabbableHit(holdingObj, out var closestHit);

                if(didHit) {
                    AutoPose(closestHit, holdingObj);
                    handGrabPoint.position = transform.position;
                    handGrabPoint.rotation = transform.rotation;
                    localGrabbablePoint.position = holdingObj.rootTransform.position;
                    localGrabbablePoint.rotation = holdingObj.rootTransform.rotation;
                    heldJoint.connectedAnchor = holdingObj.body.transform.InverseTransformPoint(handGrabPoint.position);
                    handAnimator.targetGrabPose.SavePose(this, holdingObj.transform);
                }
                else {
                    transform.position += palmTransform.forward * reachDistance;
                    body.position = transform.position;
                }
            }
        }


        /// <summary>Returns the current held object - null if empty (Same as GetHeld())</summary>
        public Grabbable GetHeldGrabbable() {
            return holdingObj;
        }

        /// <summary>Returns the current held object - null if empty (Same as GetHeldGrabbable())</summary>
        public Grabbable GetHeld() {
            return holdingObj;
        }

        /// <summary>Returns true if squeezing has been triggered</summary>
        public bool IsSqueezing() {
            return squeezing;
        }



        //=================================================================
        //========================= HELPER FUNCTIONS ======================
        //=================================================================



        /// <summary>Resets the grab offset created on grab for a smoother hand return</summary>
        public void ResetGrabOffset() {
            grabPositionOffset = transform.position - follow.transform.position;
            grabRotationOffset = Quaternion.Inverse(follow.transform.rotation) * transform.rotation;
        }

        /// <summary>Sets the hands grip 0 is open 1 is closed</summary>
        public void SetGrip(float grip, float squeeze) {
            gripAxis = grip;
            squeezeAxis = squeeze;
        }

        [ContextMenu("Set Pose - Relax Hand")]
        public void RelaxHand() {
            foreach(var finger in fingers)
                finger.SetFingerBend(gripOffset);
        }

        [ContextMenu("Set Pose - Open Hand")]
        public void OpenHand() {
            foreach(var finger in fingers)
                finger.SetFingerBend(0);
        }

        [ContextMenu("Set Pose - Close Hand")]
        public void CloseHand() {
            foreach(var finger in fingers)
                finger.SetFingerBend(1);
        }

        [ContextMenu("Set Pose - Pinch Hand")]
        public void PinchHand() {
            foreach(var finger in fingers)
                finger.SetFingerBend(1, FingerPoseEnum.Open, FingerPoseEnum.PinchClosed);
        }

        [ContextMenu("Set Pose - Open Pinch Hand")]
        public void OpenPinchHand() {
            foreach(var finger in fingers)
                finger.SetFingerBend(1, FingerPoseEnum.Open, FingerPoseEnum.PinchOpen);
        }

        [ContextMenu("Bend Fingers Until Hit")]
        /// <summary>Bends each finger until they hit</summary>
        public void ProceduralFingerBend() {
            ProceduralFingerBend(~LayerMask.GetMask(rightHandLayerName, leftHandLayerName));
        }

        /// <summary>Bends each finger until they hit</summary>
        public void ProceduralFingerBend(int layermask) {
            foreach(var finger in fingers) {
                finger.BendFingerUntilHit(fingerBendSteps, layermask);
            }
        }

        /// <summary>Bends each finger until they hit</summary>
        public void ProceduralFingerBend(RaycastHit hit) {
            foreach(var finger in fingers) {
                finger.BendFingerUntilHit(fingerBendSteps, hit.transform.gameObject.layer);
            }
        }

        /// <summary>Plays haptic vibration on the hand controller if supported by controller link</summary>
        public void PlayHapticVibration() {
            PlayHapticVibration(0.05f, 0.5f);
        }

        /// <summary>Plays haptic vibration on the hand controller if supported by controller link</summary>
        public void PlayHapticVibration(float duration) {
            PlayHapticVibration(duration, 0.5f);
        }

        /// <summary>Plays haptic vibration on the hand controller if supported by controller link</summary>
        public void PlayHapticVibration(float duration, float amp = 0.5f) {
            if(left)
                HandControllerLink.handLeft?.TryHapticImpulse(duration, amp);
            else
                HandControllerLink.handRight?.TryHapticImpulse(duration, amp);
        }


            

        #region INTERNAL FUNCTIONS

        //=================================================================
        //======================= INTERNAL FUNCTIONS ======================
        //=================================================================



        /// <summary>Takes a hit from a grabbable object and moves the hand towards that point, then calculates ideal hand shape</summary>
        protected IEnumerator GrabObject(RaycastHit hit, Grabbable grab, GrabType grabType) {
            /////////////////////////
            ////Initialize values////
            /////////////////////////
            if(!CanGrab(grab))
                yield break;


            grab.AddWaitingForGrab(this);

            bool waitingForGrab = false;
            while(grab.beingGrabbed) {
                waitingForGrab = true;
                yield return new WaitForFixedUpdate();
            }

            grab.RemoveWaitingForGrab(this);

            grab.beforeGrabFrame = true;
            var startHandPosition = transform.position;
            var startHandRotation = transform.rotation;
            var startGrabbablePosition = grab.transform.position;
            var startGrabbableRotation = grab.transform.rotation;
            if(grab.body != null) {
                startGrabbablePosition = grab.body.transform.position;
                startGrabbableRotation = grab.body.transform.rotation;
            }

            grabbing = true;
            grab.beforeGrabFrame = false;


            handAnimator.CancelPose();
            handAnimator.ClearPoseArea();

            currentHeldPose = null;
            holdingObj = grab;
            var startHoldingObj = holdingObj;

            body.linearVelocity = Vector3.zero;
            body.angularVelocity = Vector3.zero;

            grabbingHit = hit;

            OnBeforeGrabbed?.Invoke(this, holdingObj);
            holdingObj.OnBeforeGrab(this);

            if(waitingForGrab)
                RecalculateBeforeGrab(grab);

            handGrabPoint.parent = grab.rootTransform;
            handGrabPoint.position = grabbingHit.point;
            handGrabPoint.up = grabbingHit.normal;

            if(holdingObj == null || grabbingHit.collider == null) {
                CancelGrab();
                yield break;
            }

            var instantGrab = holdingObj.instantGrab || grabType == GrabType.InstantGrab;
            startGrabDist = Vector3.Distance(palmTransform.position, handGrabPoint.position);
            startHandLocalGrabPosition = holdingObj.transform.InverseTransformPoint(transform.position);


            if(holdingObj == null || grabbingHit.collider == null) {
                CancelGrab();
                yield break;
            }

            if(instantGrab)
                holdingObj.ActivateRigidbody();

            /////////////////
            ////Sets Pose////
            /////////////////
            
            HandPoseData startGrabPose;
            if(holdingObj.GetGrabPose(this, out var tempGrabPose)) {
                startGrabPose = new HandPoseData(this, tempGrabPose.transform);
                currentHeldPose = tempGrabPose;
                currentHeldPose.SetHandPose(this);
            }
            else {
                startGrabPose = new HandPoseData(this, holdingObj.transform);
                transform.position -= palmTransform.forward * 0.08f;
                body.position = transform.position;
                AutoPose(grabbingHit, holdingObj);
            }

            if(currentHeldPose != null)
                handAnimator.targetGrabPose.CopyFromData(ref currentHeldPose.GetHandPoseData(this));
            else
                handAnimator.targetGrabPose.SavePose(this, holdingObj.transform);

            localGrabbablePoint.position = grab.rootTransform.position;
            localGrabbablePoint.rotation = grab.rootTransform.rotation;


            //////////////////////////
            ////Grabbing Animation////
            //////////////////////////

            handAnimator.SetPose(ref handAnimator.targetGrabPose, 0f);

            //Instant Grabbing
            if(instantGrab) {
                if(currentHeldPose != null)
                    currentHeldPose.SetHandPose(this);

                //Hand Swap - One Handed Items
                if(holdingObj.singleHandOnly && holdingObj.HeldCount(false, false, false) > 0) {
                    holdingObj.ForceHandRelease(holdingObj.GetHeldBy()[0]);
                    if(holdingObj.body != null) {
                        holdingObj.body.linearVelocity = Vector3.zero;
                        holdingObj.body.angularVelocity = Vector3.zero;
                    }
                }
            }
            //Smooth Grabbing
            else {
                transform.position = startHandPosition;
                transform.rotation = startHandRotation;
                body.position = startHandPosition;
                body.rotation = startHandRotation;

                var adjustedGrabTime = GetGrabTime();
                instantGrab = instantGrab || adjustedGrabTime == 0;
                Transform grabTarget = currentHeldPose != null ? currentHeldPose.transform : holdingObj.transform;

                var targetOpenPose = new HandPoseData(this);
                targetOpenPose.CopyFromData(ref handAnimator.openHandPose);
                foreach(var finger in fingers) {
                    int fingerIndex = (int)finger.fingerType;
                    targetOpenPose.fingerPoses[fingerIndex].LerpDataTo(ref handAnimator.closeHandPose.fingerPoses[fingerIndex], finger.GetLastHitBend() / 2f);
                }

                /////////////////////////
                ////Hand To Grabbable////
                /////////////////////////
                if(grabType == GrabType.HandToGrabbable || (grabType == GrabType.GrabbableToHand && (holdingObj.HeldCount() > 0 || !holdingObj.parentOnGrab))) {
                    //Loop until the hand is at the object
                    for(float i = 0; i < adjustedGrabTime; i += Time.deltaTime) {
                        if(holdingObj != null) {
                            //Will move the hand faster if the controller or object is moving
                            var deltaDist = Vector3.Distance(follow.position, lastFollowPosition);
                            float maxDeltaTimeOffset = minGrabTime/adjustedGrabTime * Time.deltaTime * 5f;

                            float timeOffset = deltaDist * Time.deltaTime * velocityGrabHandAmplifier;
                            timeOffset += holdingObj.GetVelocity().magnitude * Time.deltaTime * velocityGrabObjectAmplifier * 3f;
                            i += Mathf.Clamp(timeOffset, 0, maxDeltaTimeOffset);

                            if(i < adjustedGrabTime) {
                                var point = Mathf.Clamp01(i / adjustedGrabTime);
                                var handTargetTime = 1.25f;

                                if(point < grabOpenHandPoint) {
                                    HandPoseData.LerpPose(ref handAnimator.handPoseDataNonAlloc, ref startGrabPose, ref targetOpenPose, grabCurve.Evaluate(point * 1f / grabOpenHandPoint));
                                    handAnimator.handPoseDataNonAlloc.SetFingerPose(this);
                                }
                                else {
                                    HandPoseData.LerpPose(ref handAnimator.handPoseDataNonAlloc, ref targetOpenPose, ref handAnimator.targetGrabPose, grabCurve.Evaluate((point - grabOpenHandPoint) * (1f / (1f - grabOpenHandPoint))));
                                    handAnimator.handPoseDataNonAlloc.SetFingerPose(this);
                                }

                                HandPoseData.LerpPose(ref handAnimator.handPoseDataNonAlloc, ref startGrabPose, ref handAnimator.targetGrabPose, point * handTargetTime);
                                handAnimator.handPoseDataNonAlloc.SetPosition(this, grabTarget);

                                body.position = transform.position;
                                body.rotation = transform.rotation;

                                if(holdingObj.body != null && !holdingObj.body.isKinematic) {
                                    holdingObj.body.angularVelocity *= 0.5f;
                                    if(point * handTargetTime >= 1f)
                                        holdingObj.body.linearVelocity *= 0.9f;
                                    else
                                        holdingObj.body.linearVelocity *= 0.98f;
                                }
                                yield return new WaitForEndOfFrame();
                            }
                        }
                    }

                    //Hand Swap - One Handed Items
                    if(holdingObj != null && holdingObj.singleHandOnly && holdingObj.GetHeldBy().Count > 0)
                        holdingObj.ForceHandRelease(holdingObj.GetHeldBy()[0]);
                }



                /////////////////////////
                ////Grabbable to Hand////
                /////////////////////////
                else if(grabType == GrabType.GrabbableToHand) {
                    holdingObj.ActivateRigidbody();


                    //Hand Swap - One Handed Items
                    if(holdingObj.singleHandOnly && holdingObj.HeldCount() > 0)
                        holdingObj.ForceHandRelease(holdingObj.GetHeldBy()[0]);

                    //Disable grabbable while item is moving towards hand
                    bool useGravity = holdingObj.body.useGravity;
                    holdingObj.body.useGravity = false;
                    
                    //Loop until the object is at the hand
                    for(float i = 0; i < adjustedGrabTime; i += Time.deltaTime) {
                        if(holdingObj != null) {
                            //Will move the hand faster if the controller or object is moving
                            var deltaDist = Vector3.Distance(follow.position, lastFollowPosition);
                            float minDeltaTime = minGrabTime/adjustedGrabTime * Time.deltaTime * 5f;

                            float timeOffset = deltaDist * Time.deltaTime * velocityGrabHandAmplifier;
                            i += Mathf.Clamp(timeOffset, 0, minDeltaTime);

                            var point = Mathf.Clamp01(i / adjustedGrabTime);

                            if(point < grabOpenHandPoint) {
                                HandPoseData.LerpPose(ref handAnimator.handPoseDataNonAlloc, ref startGrabPose, ref targetOpenPose, grabCurve.Evaluate(point / grabOpenHandPoint));
                                handAnimator.handPoseDataNonAlloc.SetFingerPose(this);
                            }
                            else {
                                HandPoseData.LerpPose(ref handAnimator.handPoseDataNonAlloc, ref targetOpenPose, ref handAnimator.targetGrabPose, grabCurve.Evaluate((point - grabOpenHandPoint) * (1f / (1f - grabOpenHandPoint))));
                                handAnimator.handPoseDataNonAlloc.SetFingerPose(this);
                            }

                            if(holdingObj.body != null && !holdingObj.body.isKinematic) {
                                holdingObj.body.transform.position = Vector3.Lerp(startGrabbablePosition, localGrabbablePoint.position, grabCurve.Evaluate(point / grabOpenHandPoint));
                                holdingObj.body.transform.rotation = Quaternion.Lerp(startGrabbableRotation, localGrabbablePoint.rotation, grabCurve.Evaluate(point / grabOpenHandPoint));
                                holdingObj.body.position = holdingObj.body.transform.position;
                                holdingObj.body.rotation = holdingObj.body.transform.rotation;
                                holdingObj.body.linearVelocity = Vector3.zero;
                                holdingObj.body.angularVelocity = Vector3.zero;
                            }
                            else {
                                holdingObj.transform.position = Vector3.Lerp(startGrabbablePosition, localGrabbablePoint.position, grabCurve.Evaluate(point / grabOpenHandPoint));
                                holdingObj.transform.rotation = Quaternion.Lerp(startGrabbableRotation, localGrabbablePoint.rotation, grabCurve.Evaluate(point / grabOpenHandPoint));
                            }

                            handFollow.SetMoveTo(true);
                            handFollow.MoveTo(Time.fixedDeltaTime);
                            handFollow.TorqueTo(Time.fixedDeltaTime);

                            yield return new WaitForEndOfFrame();

                        }
                    }

                    //Reset Gravity
                    if(holdingObj != null && holdingObj.body != null)
                        holdingObj.body.useGravity = useGravity;
                    else if(startHoldingObj.body != null)
                        startHoldingObj.body.useGravity = useGravity;
                }

                //Ensure final pose
                if(holdingObj != null)
                    handAnimator.targetGrabPose.SetPose(this, grabTarget);
            }

            if(holdingObj == null) {
                CancelGrab();
                yield break;
            }




            //////////////////////////////////
            ////Finalize Values and Events////
            //////////////////////////////////

            handGrabPoint.position = transform.position;
            handGrabPoint.rotation = transform.rotation;

            holdingObj.ActivateRigidbody();
            localGrabbablePoint.position = holdingObj.rootTransform.position;
            localGrabbablePoint.rotation = holdingObj.rootTransform.rotation;


            if(!instantGrab || !holdingObj.parentOnGrab) {
                ResetGrabOffset();
            }


            CreateJoint(holdingObj, holdingObj.jointBreakForce , float.PositiveInfinity);
            handFollow.SetMoveTo();
            holdingObj?.OnGrab(this);
            OnGrabbed?.Invoke(this, holdingObj);

            if(holdingObj == null) {
                CancelGrab();
                yield break;
            }

            void CancelGrab() {
                BreakGrabConnection();
                if(startHoldingObj)
                {
                    if (startHoldingObj.body != null)
                    {
                        startHoldingObj.body.linearVelocity = Vector3.zero;
                        startHoldingObj.body.angularVelocity = Vector3.zero;
                    }
                    startHoldingObj.beingGrabbed = false;
                }
                grabbing = false;
                grabRoutine = null;
            }

            grabbing = false;
            startHoldingObj.beingGrabbed = false;
            lastGrabTime = Time.time;

            grabRoutine = null;

            if(instantGrab && holdingObj.parentOnGrab) {
                handFollow.SetHandLocation(handFollow.moveTo.position, handFollow.moveTo.rotation);
            }
        }




        internal float GetGrabTime() {
            var distanceDivider = Mathf.Clamp01(startGrabDist / reachDistance);
            return Mathf.Clamp(minGrabTime*2 + ((maxGrabTime - minGrabTime) * distanceDivider), 0, maxGrabTime);
        }

        bool GetClosestGrabbableHit(Grabbable grab, out RaycastHit closestHit) {
            closestHit = new RaycastHit();
            closestHit.distance = float.MaxValue;
            Ray ray = new Ray();
            ray.origin = palmTransform.position;

            bool didHit = false;
            foreach(var collider in grab.grabColliders) {
                Vector3 closestPoint = collider.ClosestPoint(palmTransform.transform.position);
                ray.direction = closestPoint - palmTransform.position;
                ray.direction = ray.direction.normalized;
                if(ray.direction == Vector3.zero) {
                    ray.direction = collider.bounds.center - palmTransform.position;
                }
                if(collider.Raycast(ray, out var hit, 1000)) {
                    if(hit.distance < closestHit.distance) {
                        closestHit = hit;
                        didHit = true;
                    }
                }
                else {
                    ray.origin = Vector3.MoveTowards(ray.origin, collider.bounds.center, 0.002f);
                    if(collider.Raycast(ray, out hit, 1000) && hit.distance < closestHit.distance)
                        closestHit = hit;
                    else {
                        ray.origin = Vector3.MoveTowards(ray.origin, collider.bounds.center, 0.01f);
                        if(collider.Raycast(ray, out hit, 1000) && hit.distance < closestHit.distance)
                            closestHit = hit;
                    }
                }
            }

            return didHit;
        }


        #endregion


        protected virtual void OnCollisionFirstEnter(GameObject collision) {
            if(collision.CanGetComponent(out HandTouchEvent touchEvent)) {
                touchEvent.Touch(this);
            }
        }

        protected virtual void OnCollisionLastExit(GameObject collision) {
            if(collision.CanGetComponent(out HandTouchEvent touchEvent))
                touchEvent.Untouch(this);
        }

        protected virtual void OnTriggerFirstEnter(GameObject other) {
            if(other.CanGetComponent(out HandTriggerAreaEvents area)) {
                triggerEventAreas.Add(area);
                area.Enter(this);
            }
        }

        protected virtual void OnTriggerLastExit(GameObject other) {
            if(other.CanGetComponent(out HandTriggerAreaEvents area)) {
                triggerEventAreas.Remove(area);
                area.Exit(this);
            }
        }

        internal virtual void RemoveHandTriggerArea(HandTriggerAreaEvents handTrigger) {
            handTrigger.Exit(this);
            triggerEventAreas.Remove(handTrigger);
        }


        void OnCollisionFirstEnterEvent(GameObject collision) { OnHandCollisionStart?.Invoke(this, collision); }
        void OnCollisionLastExitEvent(GameObject collision) { OnHandCollisionStop?.Invoke(this, collision); }
        void OnTriggerFirstEnterEvent(GameObject collision) { OnHandTriggerStart?.Invoke(this, collision); }
        void OnTriggeLastExitEvent(GameObject collision) { OnHandTriggerStop?.Invoke(this, collision); }


        public void ResetGrabConnectionOffset() {
            if(heldJoint != null) {
                ResetGrabOffset();

                handGrabPoint.position = transform.position;
                handGrabPoint.rotation = transform.rotation;
                localGrabbablePoint.position = holdingObj.rootTransform.position;
                localGrabbablePoint.rotation = holdingObj.rootTransform.rotation;
                heldJoint.connectedAnchor = holdingObj.body.transform.InverseTransformPoint(handGrabPoint.position);

            }
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/Hand.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandAdvancedOptions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 55c79f4af9a18df40816e08e3399de97
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    [RequireComponent(typeof(Hand)), DefaultExecutionOrder(10000)]
    public class HandAdvancedOptions : MonoBehaviour{
        [Tooltip("Meant for things childed under the Hand. These transforms will not be set to the hand layer on start")]
        public List<Collider> ignoreHandCollider = new List<Collider>();


        Hand hand;

        void Awake(){
            hand = GetComponent<Hand>();
        }

        void Start() { 
            for (int i = 0; i < ignoreHandCollider.Count; i++)
                hand.HandIgnoreCollider(ignoreHandCollider[i], true);
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandAdvancedOptions.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandClippingGuard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e73b55722fce3ca44a89b26c9535ce88
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    public class HandClippingGuard : MonoBehaviour{
        //This script is designed to help prevent the hand from clipping through thin grabbables on release.
        //Also recommeneded that the grabbable has 0 `ignore release time`

        public Hand hand;
        [Tooltip("This should be a sphere collider that covers the hand (similar, but seperate from the recommended trigger sphere collider)")]
        public SphereCollider collisionGuard;
        public Transform body;
        public float guardTime = 0.02f;

        Vector3 grabPoint;
        bool runProtection = false;
        Coroutine guardRoutine;

        // Start is called before the first frame update
        void Start(){
            collisionGuard.enabled = false;
            hand.OnGrabJointBreak += OnRelease;
            hand.OnBeforeGrabbed += BeforeGrab;
        }

        void BeforeGrab(Hand hand, Grabbable grab) {
            if(body == null)
                body = hand.transform.parent;

            if (grab.ignoreReleaseTime == 0)
                runProtection = true;
            else
                runProtection = false;

            grabPoint = hand.transform.position;
            if(guardRoutine != null){
                StopCoroutine(guardRoutine);
                collisionGuard.enabled = false;
            }
        }

        void OnRelease(Hand hand, Grabbable grab) {
            if (runProtection) {
                guardRoutine = StartCoroutine(Guard(hand));
                runProtection = false;
            }
        }

        IEnumerator Guard(Hand hand) {
            hand.body.position = grabPoint;
            hand.transform.position = grabPoint;
            hand.transform.position = Vector3.MoveTowards(hand.transform.position, body.position, collisionGuard.radius);
            collisionGuard.enabled = true;
            yield return new WaitForSeconds(guardTime);
            collisionGuard.enabled = false;
        }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandClippingGuard.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandCollisionHaptics.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 102143406c4b41c46b4c86959873f5c6
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [RequireComponent(typeof(Hand))]
    public class HandCollisionHaptics : MonoBehaviour {

        [Tooltip("The layers that cause the sound to play")]
        public LayerMask collisionTriggers = ~0;
        public float hapticAmp = 0.8f;
        public float velocityAmp = 0.5f;
        public float repeatDelay = 0.2f;
        public float maxDuration = 0.5f;
        [Tooltip("Source to play sound from")]
        public AnimationCurve velocityAmpCurve = AnimationCurve.Linear(0, 0, 1, 1);
        [Tooltip("Source to play sound from")]
        public AnimationCurve velocityDurationCurve = AnimationCurve.Linear(0, 0, 1, 1);

        Hand hand;
        Rigidbody body;
        bool canPlay = true;
        Coroutine playRoutine;

        private void Start() {
            body = GetComponent<Rigidbody>();
            hand = GetComponent<Hand>();

            //So the sound doesn't play when falling in place on start
            StartCoroutine(HapticPlayBuffer(1f));
        }

        private void OnDisable() {
            if(playRoutine != null)
                StopCoroutine(playRoutine);
        }

        void OnCollisionEnter(Collision collision) {
            if(canPlay && collisionTriggers == (collisionTriggers | (1 << collision.gameObject.layer))) {
                if(body != null) {
                    if(collision.collider.attachedRigidbody == null || collision.collider.attachedRigidbody.mass > 0.0000001f) {
                        var magnitude = collision.relativeVelocity.magnitude;
                        hand.PlayHapticVibration(Mathf.Clamp(velocityDurationCurve.Evaluate(magnitude), 0, maxDuration), velocityAmpCurve.Evaluate(magnitude * velocityAmp) * hapticAmp);
                        if(playRoutine != null)
                            StopCoroutine(playRoutine);
                        playRoutine = StartCoroutine(PlayBuffer());
                    }
                }
            }
        }

        IEnumerator PlayBuffer() {
            canPlay = false;
            yield return new WaitForSeconds(repeatDelay);
            canPlay = true;
            playRoutine = null;
        }

        IEnumerator HapticPlayBuffer(float time) {
            canPlay = false;
            yield return new WaitForSeconds(time);
            canPlay = true;
            playRoutine = null;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandCollisionHaptics.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandControllerLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: efa024384f9092f4384f843022b1b5bf
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HandControllerLink : MonoBehaviour {
        public static HandControllerLink handLeft, handRight;

        public Hand hand;

        public virtual void TryHapticImpulse(float duration, float amp, float freq = 10f) {

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandControllerLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandDistanceGrabber.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1827e9caa3a42174ea1ead7cf86e7b2f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using NaughtyAttributes;

namespace Autohand {
    [DefaultExecutionOrder(2)]
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/grabbable/distance-grabbing")]
    public class HandDistanceGrabber : MonoBehaviour {
        [Header("Hands")]
        [Tooltip("The primaryHand used to trigger pulling or flicking")]
        public Hand primaryHand;
        [Tooltip("This is important for catch assistance")]
        public Hand secondaryHand;

        [Header("Pointing Options")]
        public Transform forwardPointer;
        public bool useSmoothing = true;
        public float forwardSmoothingSpeed = 5f;
        public LineRenderer line;
        [Space]
        public float maxRange = 5;
        [Tooltip("Defaults to grabbable on start if none")]
        public LayerMask layers;
        [Space]
        public Material defaultTargetedMaterial;
        [Tooltip("The highlight material to use when pulling")]
        public Material defaultSelectedMaterial;

        [Header("Pull Options")]
        public bool useInstantPull = false;
        [Tooltip("If false will default to distance pull, set pullGrabDistance to 0 for instant pull on select")]
        public bool useFlickPull = false;


        [Tooltip("The magnitude of your hands angular velocity for \"flick\" to start")]
        [ShowIf("useFlickPull")]
        public float flickThreshold = 7f;


        [Tooltip("The amount you need to move your hand from the select position to trigger the grab")]
        [HideIf("useFlickPull")]
        public float pullGrabDistance = 0.1f;

        [Space]
        [Tooltip("If this is true the object will be grabbed when entering the radius")]
        public bool instantGrabAssist = true;
        [Tooltip("The radius around of thrown object")]
        public float catchAssistRadius = 0.2f;

        [AutoToggleHeader("Show Events")]
        public bool showEvents = true;

        [ShowIf("showEvents")]
        public UnityHandGrabEvent OnPull;
        [ShowIf("showEvents")]
        public UnityHandEvent StartPoint;
        [ShowIf("showEvents")]
        public UnityHandEvent StopPoint;
        [ShowIf("showEvents"), Tooltip("Targeting is started when object is highlighted")]
        public UnityHandGrabEvent StartTarget;
        [ShowIf("showEvents")]
        public UnityHandGrabEvent StopTarget;
        [ Tooltip("Selecting is started when grab is selected on highlight object")]
        [ShowIf("showEvents")]
        public UnityHandGrabEvent StartSelect;
        [ShowIf("showEvents")]
        public UnityHandGrabEvent StopSelect;


        List<CatchAssistData> catchAssisted;

        DistanceGrabbable targetingDistanceGrabbable;
        DistanceGrabbable selectingDistanceGrabbable;

        float catchAssistSeconds = 3f;
        bool pointing;
        bool pulling;
        Vector3 startPullPosition;
        RaycastHit hit;
        Quaternion lastRotation;
        private RaycastHit selectionHit;
        float selectedEstimatedRadius;
        float startLookAssist;
        bool lastInstantPull;

        GameObject _hitPoint;
        Coroutine catchAssistRoutine;
        private DistanceGrabbable catchAsistGrabbable;
        private CatchAssistData catchAssistData;

        Vector3 currentSmoothForward;

        GameObject hitPoint {
            get {
                if(!gameObject.activeInHierarchy)
                    return null;

                if(_hitPoint == null) {
                    _hitPoint = new GameObject();
                    _hitPoint.name = "Distance Hit Point";
                    return _hitPoint;
                }

                return _hitPoint;
            }
        }

        void Start() {
            catchAssisted = new List<CatchAssistData>();
            if(layers == 0)
                layers = LayerMask.GetMask(Hand.grabbableLayerNameDefault);

            if(useInstantPull)
                SetInstantPull();
        }

        private void OnEnable() {
            primaryHand.OnTriggerGrab += TryCatchAssist;
            if(secondaryHand != null)
                secondaryHand.OnTriggerGrab += TryCatchAssist;
            primaryHand.OnBeforeGrabbed += (hand, grabbable) => { StopPointing(); CancelSelect(); };

        }

        private void OnDisable() {
            primaryHand.OnTriggerGrab -= TryCatchAssist;
            if(secondaryHand != null)
                secondaryHand.OnTriggerGrab -= TryCatchAssist;
            primaryHand.OnBeforeGrabbed -= (hand, grabbable) => { StopPointing(); CancelSelect(); };

            if(catchAssistRoutine != null) {
                StopCoroutine(catchAssistRoutine);
                catchAssistRoutine = null;
                catchAsistGrabbable.grabbable.OnGrabEvent -= (hand, grabbable) => { if(catchAssisted.Contains(catchAssistData)) catchAssisted.Remove(catchAssistData); };
                catchAsistGrabbable.OnPullCanceled -= (hand, grabbable) => { if(catchAssisted.Contains(catchAssistData)) catchAssisted.Remove(catchAssistData); };
            }
        }

        void Update() {
            CheckDistanceGrabbable();
            if(lastInstantPull != useInstantPull) {
                if(useInstantPull) {
                    useFlickPull = false;
                    pullGrabDistance = 0;
                }
                lastInstantPull = useInstantPull;
            }
        }

        private void OnDestroy() {
            Destroy(hitPoint);
        }
        public void SetInstantPull() {
            useInstantPull = true;
        }

        public void SetPull(float distance) {
            useInstantPull = false;
            useFlickPull = false;
            pullGrabDistance = distance;
        }

        public void SetFlickPull(float threshold) {
            useInstantPull = false;
            useFlickPull = true;
            flickThreshold = threshold;
        }


        void CheckDistanceGrabbable() {

            if(useSmoothing) {
                var currentAngleDistance = Vector3.Angle(currentSmoothForward, forwardPointer.forward);
                currentSmoothForward = Vector3.RotateTowards(currentSmoothForward, forwardPointer.forward, Time.deltaTime * forwardSmoothingSpeed + Time.deltaTime * forwardSmoothingSpeed * currentAngleDistance, 1000f);
                currentSmoothForward.Normalize();
            }
            else
                currentSmoothForward = forwardPointer.forward;

            if(!pulling && pointing && primaryHand.holdingObj == null) {

                bool didHit = Physics.SphereCast(forwardPointer.position, 0.03f, currentSmoothForward, out hit, maxRange, layers);
                DistanceGrabbable hitGrabbable;
                GrabbableChild hitGrabbableChild;
                if(didHit) {
                    if(hit.transform.CanGetComponent(out hitGrabbable)) {
                        if(targetingDistanceGrabbable == null || hitGrabbable.GetInstanceID() != targetingDistanceGrabbable.GetInstanceID())
                        {
                            StartTargeting(hitGrabbable);
                        }
                    }
                    else if(hit.transform.CanGetComponent(out hitGrabbableChild)) {
                        if(hitGrabbableChild.grabParent.transform.CanGetComponent(out hitGrabbable)) {
                            if(targetingDistanceGrabbable == null || hitGrabbable.GetInstanceID() != targetingDistanceGrabbable.GetInstanceID())
                            {
                                StartTargeting(hitGrabbable);
                            }
                        }
                    }
                    else if(targetingDistanceGrabbable != null && hit.transform.gameObject.GetInstanceID() != targetingDistanceGrabbable.gameObject.GetInstanceID())
                    {
                        StopTargeting();
                    }
                }
                else {
                    StopTargeting();
                }

                if(line != null) {
                    if(didHit) {
                        line.positionCount = 2;
                        line.SetPositions(new Vector3[] { forwardPointer.position, hit.point });
                    }
                    else {
                        line.positionCount = 2;
                        line.SetPositions(new Vector3[] { forwardPointer.position, forwardPointer.position + currentSmoothForward * maxRange });
                    }
                }
            }
            else if(pulling && primaryHand.holdingObj == null) {
                if(useFlickPull) {
                    TryFlickPull();
                }
                else {
                    TryDistancePull();
                }
            }
            else if(targetingDistanceGrabbable != null) {
                StopTargeting();
            }
        }




        public virtual void StartPointing() {
            pointing = true;
            currentSmoothForward = forwardPointer.forward;
            StartPoint?.Invoke(primaryHand);
        }

        public virtual void StopPointing() {
            pointing = false;
            if(line != null) {
                line.positionCount = 0;
                line.SetPositions(new Vector3[0]);
            }
            StopPoint?.Invoke(primaryHand);
            StopTargeting();
        }



        public virtual void StartTargeting(DistanceGrabbable target) {
            if(target.enabled && primaryHand.CanGrab(target.grabbable)) {
                if(targetingDistanceGrabbable != null)
                    StopTargeting();
                targetingDistanceGrabbable = target;
                targetingDistanceGrabbable?.grabbable.Highlight(primaryHand, GetTargetedMaterial(targetingDistanceGrabbable));
                targetingDistanceGrabbable?.StartTargeting?.Invoke(primaryHand, target.grabbable);
                StartTarget?.Invoke(primaryHand, target.grabbable);
            }
        }

        public virtual void StopTargeting() {
            targetingDistanceGrabbable?.grabbable.Unhighlight(primaryHand, GetTargetedMaterial(targetingDistanceGrabbable));
            targetingDistanceGrabbable?.StopTargeting?.Invoke(primaryHand, targetingDistanceGrabbable.grabbable);
            if(targetingDistanceGrabbable != null)
                StopTarget?.Invoke(primaryHand, targetingDistanceGrabbable.grabbable);
            else if(selectingDistanceGrabbable != null)
                StopTarget?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
            targetingDistanceGrabbable = null;
        }

        public virtual void SelectTarget() {
            if(targetingDistanceGrabbable != null) {
                pulling = true;
                startPullPosition = primaryHand.transform.localPosition;
                lastRotation = transform.rotation;
                selectionHit = hit;
                if(catchAssistRoutine == null) {
                    hitPoint.transform.position = selectionHit.point;
                    hitPoint.transform.parent = selectionHit.transform;
                }
                selectingDistanceGrabbable = targetingDistanceGrabbable;
                selectedEstimatedRadius = Vector3.Distance(hitPoint.transform.position, selectingDistanceGrabbable.grabbable.body.transform.position);
                selectingDistanceGrabbable.grabbable.Unhighlight(primaryHand, GetTargetedMaterial(selectingDistanceGrabbable));
                selectingDistanceGrabbable.grabbable.Highlight(primaryHand, GetSelectedMaterial(selectingDistanceGrabbable));
                selectingDistanceGrabbable?.StartSelecting?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
                targetingDistanceGrabbable?.StopTargeting?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
                targetingDistanceGrabbable = null;
                StartSelect?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
                StopPointing();
            }
        }

        public virtual void CancelSelect() {
            StopTargeting();
            pulling = false;
            selectingDistanceGrabbable?.grabbable.Unhighlight(primaryHand, GetSelectedMaterial(selectingDistanceGrabbable));
            selectingDistanceGrabbable?.StopSelecting?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
            if(selectingDistanceGrabbable != null)
                StopSelect?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
            selectingDistanceGrabbable = null;
        }

        public virtual void ActivatePull() {
            if(selectingDistanceGrabbable) {
                OnPull?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
                selectingDistanceGrabbable.OnPull?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
                if(selectingDistanceGrabbable.instantPull) {
                    selectingDistanceGrabbable.grabbable.body.linearVelocity = Vector3.zero;
                    selectingDistanceGrabbable.grabbable.body.angularVelocity = Vector3.zero;
                    selectionHit.point = hitPoint.transform.position;
                    if (selectingDistanceGrabbable.grabbable.placePoint != null)
                        selectingDistanceGrabbable.grabbable.placePoint.Remove();
                    primaryHand.Grab(selectionHit, selectingDistanceGrabbable.grabbable);
                    CancelSelect();
                    selectingDistanceGrabbable?.CancelTarget();
                }
                else if(selectingDistanceGrabbable.grabType == DistanceGrabType.Velocity) {
                    catchAssistRoutine = StartCoroutine(StartCatchAssist(selectingDistanceGrabbable, selectedEstimatedRadius));
                    catchAsistGrabbable = selectingDistanceGrabbable;
                    if (selectingDistanceGrabbable.grabbable.placePoint != null)
                    {
                        
                        selectingDistanceGrabbable.grabbable.placePoint.Remove();
                    }
                    selectingDistanceGrabbable.SetTarget(primaryHand.palmTransform);
                }
                else if(selectingDistanceGrabbable.grabType == DistanceGrabType.Linear) {
                    selectingDistanceGrabbable.grabbable.body.linearVelocity = Vector3.zero;
                    selectingDistanceGrabbable.grabbable.body.angularVelocity = Vector3.zero;
                    selectionHit.point = hitPoint.transform.position;
                    if (selectingDistanceGrabbable.grabbable.placePoint != null)
                        selectingDistanceGrabbable.grabbable.placePoint.Remove();
                    primaryHand.Grab(selectionHit, selectingDistanceGrabbable.grabbable, GrabType.GrabbableToHand);
                    CancelSelect();
                    selectingDistanceGrabbable?.CancelTarget();

                }

                    CancelSelect();
            }
        }


        void TryDistancePull() {
            if(Vector3.Distance(startPullPosition, primaryHand.transform.localPosition) > pullGrabDistance) {
                ActivatePull();
            }
        }

        void TryFlickPull() {
            Quaternion deltaRotation = transform.rotation * Quaternion.Inverse(lastRotation);
            lastRotation = transform.rotation;
            var getAngle = 0f;
            Vector3 getAxis = Vector3.zero;
            deltaRotation.ToAngleAxis(out getAngle, out getAxis);
            getAngle *= Mathf.Deg2Rad;
            float speed = (getAxis * getAngle * (1f / Time.deltaTime)).magnitude;

            if(speed > flickThreshold || useInstantPull) {
                if(selectingDistanceGrabbable) {
                    ActivatePull();
                }
            }
        }




        Material GetSelectedMaterial(DistanceGrabbable grabbable) {
            if(grabbable.ignoreHighlights)
                return null;
            return grabbable.selectedMaterial != null ? grabbable.selectedMaterial : defaultSelectedMaterial;
        }
        Material GetTargetedMaterial(DistanceGrabbable grabbable) {
            if(grabbable.ignoreHighlights)
                return null;
            return grabbable.selectedMaterial != null ? grabbable.targetedMaterial : defaultTargetedMaterial;
        }

        void TryCatchAssist(Hand hand, Grabbable grab) {
            for(int i = 0; i < catchAssisted.Count; i++) {
                var distance = Vector3.Distance(hand.palmTransform.position + hand.palmTransform.forward * catchAssistRadius, catchAssisted[i].grab.transform.position) - catchAssisted[i].estimatedRadius;
                if(distance < catchAssistRadius) {
                    Ray ray = new Ray(hand.palmTransform.position, hitPoint.transform.position - hand.palmTransform.position);
                    if(Physics.SphereCast(ray, 0.03f, out var catchHit, catchAssistRadius * 2, LayerMask.GetMask(Hand.grabbableLayerNameDefault, Hand.grabbingLayerName))) {
                        if(catchHit.transform.gameObject == catchAssisted[i].grab.gameObject) {
                            catchAssisted[i].grab.body.linearVelocity = Vector3.zero;
                            catchAssisted[i].grab.body.angularVelocity = Vector3.zero;
                            hand.Grab(catchHit, catchAssisted[i].grab);
                            CancelSelect();
                        }
                    }
                }
            }
        }


        IEnumerator StartCatchAssist(DistanceGrabbable grab, float estimatedRadius) {
            catchAssistData = new CatchAssistData(grab.grabbable, catchAssistRadius);
            catchAssisted.Add(catchAssistData);
            grab.grabbable.OnGrabEvent += (hand, grabbable) => { if(catchAssisted.Contains(catchAssistData)) catchAssisted.Remove(catchAssistData); };
            grab.OnPullCanceled += (hand, grabbable) => { if(catchAssisted.Contains(catchAssistData)) catchAssisted.Remove(catchAssistData); };

            if(instantGrabAssist) {
                bool cancelInstantGrab = false;
                var time = 0f;
                primaryHand.OnTriggerRelease += (hand, grabbable) => { cancelInstantGrab = true; };

                while(time < catchAssistSeconds && !cancelInstantGrab) {
                    time += Time.fixedDeltaTime;

                    if(TryCatch(primaryHand))
                        break;

                    bool TryCatch(Hand hand) {
                        var distance = Vector3.Distance(hand.palmTransform.position + hand.palmTransform.forward * catchAssistRadius, grab.transform.position) - estimatedRadius;
                        if(distance < catchAssistRadius) {
                            Ray ray = new Ray(hand.palmTransform.position, hitPoint.transform.position - hand.palmTransform.position);
                            var hits = Physics.SphereCastAll(ray, 0.03f, catchAssistRadius * 2, LayerMask.GetMask(Hand.grabbableLayerNameDefault, Hand.grabbingLayerName));
                            for(int i = 0; i < hits.Length; i++) {
                                if(hits[i].transform.gameObject == grab.gameObject) {
                                    grab.grabbable.body.linearVelocity = Vector3.zero;
                                    grab.grabbable.body.angularVelocity = Vector3.zero;
                                    hand.Grab(hits[i], grab.grabbable);
                                    grab.CancelTarget();
                                    CancelSelect();
                                    return true;
                                }
                            }
                        }
                        return false;
                    }

                    yield return new WaitForEndOfFrame();
                }

                primaryHand.OnTriggerRelease -= (hand, grabbable) => { cancelInstantGrab = true; };

            }

            else
                yield return new WaitForSeconds(catchAssistSeconds);

            grab.grabbable.OnGrabEvent -= (hand, grabbable) => { if(catchAssisted.Contains(catchAssistData)) catchAssisted.Remove(catchAssistData); };
            grab.OnPullCanceled -= (hand, grabbable) => { if(catchAssisted.Contains(catchAssistData)) catchAssisted.Remove(catchAssistData); };
            if(catchAssisted.Contains(catchAssistData))
                catchAssisted.Remove(catchAssistData);

            catchAssistRoutine = null;
        }

        private void OnDrawGizmosSelected() {
            if(primaryHand)
                Gizmos.DrawWireSphere(primaryHand.palmTransform.position + primaryHand.palmTransform.forward * catchAssistRadius * 4 / 5f + primaryHand.palmTransform.up * catchAssistRadius * 1 / 4f, catchAssistRadius);
        }
    }

    struct CatchAssistData {
        public Grabbable grab;
        public float estimatedRadius;

        public CatchAssistData(Grabbable grab, float estimatedRadius) {
            this.grab = grab;
            this.estimatedRadius = estimatedRadius;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandDistanceGrabber.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1bb1227c08e7ffb4f8455e68370ae54f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public static class HandExtensions {

        


        public static void HandIgnoreCollider(this Hand hand, Collider collider, bool ignore) {
            for(int i = 0; i < hand.handColliders.Count; i++)
                Physics.IgnoreCollision(hand.handColliders[i], collider, ignore);
        }


        public static void SetLayerRecursive(this Hand hand, Transform obj, int newLayer) {
            obj.gameObject.layer = newLayer;
            for(int i = 0; i < obj.childCount; i++) {
                hand.SetLayerRecursive(obj.GetChild(i), newLayer);
            }
        }


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandExtensions.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandFingerTouch.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9a1deccc66b15ad45982fd415dd879a2
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HandFingerTouch
        : MonoBehaviour {
        [Tooltip("Reference to the Hand component")]
        public Hand hand;

        [Tooltip("Reference to the Index Finger component")]
        public Finger index;
        [Tooltip("Reference to the Middle Finger component")]
        public Finger middle;
        [Tooltip("Reference to the Ring Finger component")]
        public Finger ring;
        [Tooltip("Reference to the Pinky Finger component")]
        public Finger pinky;
        [Tooltip("Reference to the Thumb component")]
        public Finger thumb;

        [Tooltip("Layer mask for determining what objects the fingers can interact with")]
        public LayerMask touchMask;

        [Tooltip("Speed at which finger offset adjusts - These default settings are tuned for the default hands physics settings and results might vary based on hands set follow speed and rigidbody settings\"")]
        public float offsetSpeed = 0.65f;

        [Tooltip("Maximum offset for the index finger")]
        public float maxIndexOffset = 0.5f;
        [Tooltip("Maximum offset for the middle finger")]
        public float maxMiddleOffset = 0.5f;
        [Tooltip("Maximum offset for the ring finger")]
        public float maxRingOffset = 0.5f;
        [Tooltip("Maximum offset for the pinky finger")]
        public float maxPinkyOffset = 0.5f;
        [Tooltip("Maximum offset for the thumb")]
        public float maxThumbOffset = 0.5f;

        [Tooltip("Minimum pressure required for interaction - These default settings are tuned for the default hands physics settings and results might vary based on hands set follow speed and rigidbody settings")]
        public float minPressure = 300;
        [Tooltip("Maximum pressure for interaction - These default settings are tuned for the default hands physics settings and results might vary based on hands set follow speed and rigidbody settings")]
        public float maxPressure = 1200;

        [Tooltip("Curve to represent the relationship between pressure applied and finger bend")]
        public AnimationCurve pressureBendCurve = AnimationCurve.Linear(0, 0, 1, 1);


        // Internal fields for handling finger touch and pressure
        private float fingerRadiusMultiplier = 4f;
        private float[] maxOffsets;
        private float[] currentPressure;
        private bool[] isTouching;
        private Vector3 largeSphereCheckerPoint;
        private float largeSphereCheckerRadius;
        private Collider[] collidersNonAlloc = new Collider[100];
        private Vector3[] fingerTips = new Vector3[5];
        private Finger[] fingers = new Finger[5];
        private Vector3 smoothAngularVelocity;



        /// <summary>
        /// Returns a value between 0 and 1 representing the current pressure applied to the finger
        /// </summary>
        public float GetCurrentFingerPressure(FingerEnum finger) {
            return currentPressure[(int)finger];
        }




        void Awake() {
            fingerTips[0] = (hand.transform.InverseTransformPoint(index.tip.position));
            fingerTips[1] =(hand.transform.InverseTransformPoint(middle.tip.position));
            fingerTips[2] =(hand.transform.InverseTransformPoint(ring.tip.position));
            fingerTips[3] =(hand.transform.InverseTransformPoint(pinky.tip.position));
            fingerTips[4] =(hand.transform.InverseTransformPoint(thumb.tip.position));

            fingers[0] = (index);
            fingers[1] =(middle);
            fingers[2] =(ring);
            fingers[3] =(pinky);
            fingers[4] =(thumb);

            maxOffsets = new float[] { maxIndexOffset, maxMiddleOffset, maxRingOffset, maxPinkyOffset, maxThumbOffset };
            currentPressure = new float[] { 0, 0, 0, 0, 0 };
            isTouching = new bool[] { false, false, false, false, false };

            CreateEncapsulatingSphere(fingerTips, out largeSphereCheckerPoint, out largeSphereCheckerRadius);
            largeSphereCheckerRadius += index.tipRadius;
            largeSphereCheckerRadius += middle.tipRadius;
        }


        void OnEnable() {
            StartCoroutine(SlowUpdateCoroutine());
        }


        void OnDisable() {
            StopAllCoroutines();
        }


        void LateUpdate() {
            MoveTowardsBendTarget();
        }


        IEnumerator SlowUpdateCoroutine() {
            while (true) {
                CheckFingerTouch();
                yield return new WaitForFixedUpdate();
            }
        }


        void MoveTowardsBendTarget() {
            for(int i = 0; i < fingers.Length; i++) {
                if(fingers[i].secondaryOffset == 0 && currentPressure[i] == 0)
                    continue;

                float currentTarget = currentPressure[i]*maxOffsets[i];
                float targetDistance = Mathf.Abs(currentTarget - fingers[i].secondaryOffset)/maxOffsets[i];
                targetDistance = Mathf.Pow(targetDistance, 2f);
                float distanceSpeed = Time.deltaTime * offsetSpeed * targetDistance;

                currentTarget = Mathf.Clamp(currentTarget, -maxOffsets[i], maxOffsets[i]);

                fingers[i].secondaryOffset = Mathf.MoveTowards(fingers[i].secondaryOffset, currentTarget, distanceSpeed + Time.deltaTime * offsetSpeed/2f);
                if(fingers[i].GetCurrentBend() < 0) {
                    fingers[i].secondaryOffset += -fingers[i].GetCurrentBend();
                }
            }
        }


        void CheckFingerTouch() {
            //var angularVelocity = CalculateCustomAngularVelocity(hand.transform.rotation, hand.moveTo.transform.rotation, 2000f);
            var targetAngularVelocity = !hand.holdingObj ? hand.handFollow.lastAngularVelocity : Vector3.zero;
            //var lerpDelta = Vector3.SqrMagnitude(targetAngularVelocity - smoothAngularVelocity) * Time.fixedDeltaTime * 1200f + Time.fixedDeltaTime * 360f;
            var lerpDelta =  Time.fixedDeltaTime * 1200f;
            //smoothAngularVelocity = Vector3.Lerp(smoothAngularVelocity, targetAngularVelocity, lerpDelta);
            smoothAngularVelocity = targetAngularVelocity;//Vector3.MoveTowards(smoothAngularVelocity, targetAngularVelocity, lerpDelta);

            //Check for overlap with large sphere
            int numColliders = Physics.OverlapSphereNonAlloc(hand.transform.TransformPoint(largeSphereCheckerPoint), largeSphereCheckerRadius, collidersNonAlloc, touchMask, QueryTriggerInteraction.Ignore);
            if (numColliders > 0) {
                //Check for overlap with each finger
                for(int i = 0; i < fingerTips.Length; i++) {

                    fingerTips[i] = hand.transform.InverseTransformPoint(fingers[i].tip.position);

                    Vector3 fingerTipWorld = hand.transform.TransformPoint(fingerTips[i]);
                    float radius = fingers[i].tipRadius*fingerRadiusMultiplier*Mathf.Abs(hand.transform.lossyScale.x) * (isTouching[i] ? 2f : 1f);
                    int numCollidersFinger = Physics.OverlapSphereNonAlloc(fingerTipWorld, radius, collidersNonAlloc, touchMask, QueryTriggerInteraction.Ignore);
                    if (numCollidersFinger > 0) {
                        var pressure = CalculateFingerTipPressure(fingerTipWorld, hand.transform.position, smoothAngularVelocity, hand.palmTransform.forward, out bool isForceTop, fingers[i].tipRadius);
                        var evaluatedPressure = pressureBendCurve.Evaluate((pressure-minPressure)/maxPressure);

                        isTouching[i] = true;
                        if(pressure < minPressure)
                            continue;

                        //Difference between currentPressure[i] and evaluatedPressure
                        float pressureDifference = Mathf.Abs(currentPressure[i] - evaluatedPressure);
                        pressureDifference = Mathf.Pow(pressureDifference, 2f);


                        currentPressure[i] = Mathf.MoveTowards(currentPressure[i], evaluatedPressure * (isForceTop ? -1 : 1), pressureDifference * Time.fixedDeltaTime * 30f + Time.fixedDeltaTime * 5f);

                    }
                    else {
                        currentPressure[i] =  Mathf.MoveTowards(currentPressure[i], 0, maxOffsets[i]*Time.fixedDeltaTime*30f);
                        isTouching[i] = false;
                    }
                }
            }
            else {
                for(int i = 0; i < fingers.Length; i++) {
                    isTouching[i] = false;
                    if(currentPressure[i] == 0)
                        continue;
                    currentPressure[i] = Mathf.MoveTowards(currentPressure[i], 0, maxOffsets[i]*Time.fixedDeltaTime*30f);
                }
            }
        }

       
        
        Vector3 CalculateCustomAngularVelocity(Quaternion currentRotation, Quaternion targetRotation, float maxAngularVelocity) {
            Quaternion rotationDifference = targetRotation * Quaternion.Inverse(currentRotation);
            var eularAngularVelocity = rotationDifference.eulerAngles;

            return eularAngularVelocity;
        }

        float CalculateFingerTipPressure(Vector3 fingertipPoint, Vector3 wristPoint, Vector3 angularVelocity, Vector3 palmDirection, out bool isForceOnTop, float fingertipArea) {
            Vector3 leverArm = fingertipPoint - wristPoint;
            Vector3 torque = Vector3.Cross(leverArm, angularVelocity);

            float forceMagnitude = torque.magnitude / leverArm.magnitude;
            float pressure = forceMagnitude / fingertipArea;

            Vector3 relativePoint;
            if(float.IsNaN(angularVelocity.x) || float.IsNaN(angularVelocity.y) || float.IsNaN(angularVelocity.z))
                relativePoint = fingertipPoint + hand.body.linearVelocity*Time.fixedDeltaTime;
            else 
                relativePoint = Quaternion.Euler(angularVelocity)*leverArm + hand.body.linearVelocity*Time.fixedDeltaTime;

            var plane = new Plane(palmDirection, Vector3.zero);
            isForceOnTop = plane.GetSide(relativePoint);

            return pressure;
        }



        void CreateEncapsulatingSphere(Vector3[] fingerTips, out Vector3 sphereCenter, out float sphereRadius) {
            sphereCenter = new Vector3();

            foreach(var point in fingerTips) {
                sphereCenter += point;
            }
            sphereCenter /= fingerTips.Length;

            sphereRadius = 0f;
            foreach(var point in fingerTips) {
                float distance = Vector3.Distance(sphereCenter, point);
                sphereRadius = Mathf.Max(sphereRadius, distance);
            }
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandFingerTouch.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPoseArea.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 860940885d4f04170a30987b127e5ff2
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/custom-poses#hand-pose-areas")]
    public class HandPoseArea : HandPoseDataContainer {
        public bool useDistancePose = false;
        public float transitionTime = 0.2f;

        [Header("Events")]
        public UnityHandEvent OnHandEnter = new UnityHandEvent();
        public UnityHandEvent OnHandExit = new UnityHandEvent();

        internal HandPoseArea[] poseAreas;
        List<Hand> posingHands = new List<Hand>();



        protected virtual void Start(){
            poseAreas = GetComponents<HandPoseArea>();
        }

        protected virtual void OnEnable() {
            OnHandEnter.AddListener(HandEnter);
            OnHandExit.AddListener(HandExit);
        }

        protected virtual void OnDisable() {
            for(int i = posingHands.Count - 1; i >= 0; i--) 
                posingHands[i].handAnimator.TryRemoveHandPoseArea(this);
            OnHandEnter.RemoveListener(HandEnter);
            OnHandExit.RemoveListener(HandExit);
        }

        protected virtual void HandEnter(Hand hand) {
            posingHands.Add(hand);
        }

        protected virtual void HandExit(Hand hand) {
            posingHands.Remove(hand);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPoseArea.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPoseDataContainer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4537f3e5cda87b448b1ba36df1b100fd
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Autohand {
    public class HandPoseDataContainer : MonoBehaviour {
        [AutoHeader("Auto Hand Pose")]
        public bool ignoreMe;
        [HideInInspector, SerializeField]
        public HandPoseData rightPose;
        [HideInInspector]
        public bool rightPoseSet = false;
        [HideInInspector, SerializeField]
        public HandPoseData leftPose;
        [HideInInspector]
        public bool leftPoseSet = false;
        [Tooltip("Purely for organizational purposes in the editor")]
        public string poseName = "";
        public int poseIndex = 0;


#if UNITY_EDITOR
        [HideInInspector]
        public bool showEditorTools = true;
        [HideInInspector, Tooltip("Used to pose for the grabbable")]
        public Hand editorHand;
#endif

        [HideInInspector, Tooltip("Scriptable options NOT REQUIRED (will be saved locally instead if empty) -> Create scriptable throught [Auto Hand/Custom Pose]")]
        public HandPoseScriptable poseScriptable;


        //If the old data type is set but not the new data type
        public bool isDataDepricated {
            get {
                bool isOldRightPoseSet = rightPoseSet && rightPose.posePositions.Length > 0;
                bool isOldLeftPoseSet = leftPoseSet && leftPose.posePositions.Length > 0;
                bool isNewRightPoseSet = !rightPose.isDataDeprecated;
                bool isNewLeftPoseSet = !leftPose.isDataDeprecated;
                return (isOldRightPoseSet && !isNewRightPoseSet) || (isOldLeftPoseSet && !isNewLeftPoseSet);
            }
        }

        public void UpdateDepricatedData(Hand hand) {

            if(hand.left && leftPoseSet) {
                leftPose.UpdateDepricatedData(hand, transform);
            }
            else if(!hand.left && rightPoseSet) {
                rightPose.UpdateDepricatedData(hand, transform);
            }
#if UNITY_EDITOR
            EditorUtility.SetDirty(this);
#endif
        }


        /// <summary>Saves/Overwrites the pose data of this grabbable pose to be the given hand relative to this grabbable</summary>
        public virtual void SaveHandPose(Hand hand) {
            if(hand.left)
                leftPose = new HandPoseData(hand, transform);
            else if(!hand.left)
                rightPose = new HandPoseData(hand, transform);
        }

        public virtual ref HandPoseData GetHandPoseData(bool left) {
            if(poseScriptable != null) {
                if(left) 
                    return ref poseScriptable.leftPose;
                else
                    return ref poseScriptable.rightPose;
            }

            if(left) 
                return ref leftPose;
            else 
                return ref rightPose;
        }


        public void SetHandPose(Hand hand) {
            HandPoseData pose;
            if(hand.left) {
                if(leftPoseSet) pose = leftPose;
                else return;
            }
            else {
                if(rightPoseSet) pose = rightPose;
                else return;
            }

            pose.SetPose(hand, transform);
        }

#if UNITY_EDITOR
        [ContextMenu("SAVE RIGHT")]
        public void EditorSavePoseRight() {
            if(editorHand != null)
                EditorSaveGrabPose(editorHand);
            else
                Debug.Log("Editor Hand must be assigned");
        }

        [ContextMenu("SAVE LEFT")]
        public void EditorSavePoseLeft() {
            if(editorHand != null)
                EditorSaveGrabPose(editorHand);
            else
                Debug.Log("Editor Hand must be assigned");
        }

        [ContextMenu("OVERWRITE SCRIPTABLE")]
        public void SaveScriptable() {
            if(poseScriptable != null) {
                if(rightPoseSet)
                    poseScriptable.SaveRightPose(rightPose);
                if(leftPoseSet)
                    poseScriptable.SaveLeftPose(leftPose);
            }
        }

        [ContextMenu("LOAD SCRIPTABLE")]
        public void LoadScriptable() {
            if(poseScriptable != null) {
                if(poseScriptable.leftSaved) {
                    leftPose.CopyFromData(ref poseScriptable.leftPose);
                    leftPoseSet = true;
                }
                if(poseScriptable.rightSaved) {
                    rightPose.CopyFromData(ref poseScriptable.rightPose);
                    rightPoseSet = true;
                }
            }
        }

        public void EditorCreateHandCopyTool(Hand hand, Transform relativeTo) {
            Hand handCopy;
            if(hand.name != "HAND COPY DELETE")
                handCopy = Instantiate(hand, relativeTo.transform.position, hand.transform.rotation);
            else
                handCopy = hand;

            handCopy.name = "HAND COPY DELETE";
            var referenceHand = handCopy.gameObject.AddComponent<EditorHand>();
            referenceHand.handPoseDataContainer = this;

            editorHand = handCopy;

            Selection.activeGameObject = editorHand.gameObject;
            SceneView.lastActiveSceneView.FrameSelected();

            if(hand.left && leftPoseSet) {
                leftPose.SetPose(handCopy, transform);
            }
            else if(!hand.left && rightPoseSet) {
                rightPose.SetPose(handCopy, transform);
            }
            else {
                handCopy.transform.position = relativeTo.transform.position;
                editorHand.RelaxHand();
            }

            var contrainer = new GameObject();
            contrainer.name = "HAND COPY CONTAINER DELETE";
            contrainer.transform.position = relativeTo.transform.position;
            contrainer.transform.rotation = relativeTo.transform.rotation;
            handCopy.transform.parent = contrainer.transform;
            if(hand.poseIndex != poseIndex)
                handCopy.RelaxHand();

            if(handCopy.transform.parent.GetComponentInChildren<MeshRenderer>()  == null && handCopy.transform.parent.GetComponentInChildren<SkinnedMeshRenderer>()  == null) {

                foreach(Finger finger in handCopy.fingers) {
                    for(int i = -1; i < finger.FingerJoints.Length; i++) {
                        Transform fingerTransform = null;
                        Transform childFingerTranform = null;
                        if(i == -1) {

                            fingerTransform = finger.FingerJoints[i+1].parent;
                            childFingerTranform = finger.FingerJoints[i+1];
                        }
                        else if(i < finger.FingerJoints.Length-1) {
                            fingerTransform = finger.FingerJoints[i];
                            childFingerTranform = finger.FingerJoints[i+1];
                        }
                        else if(finger.FingerJoints[i].childCount > 0) {
                            fingerTransform = finger.FingerJoints[i];
                            childFingerTranform = finger.tip;
                        }

                        if(childFingerTranform == null || fingerTransform == null)
                            continue;

                        float distance = Vector3.Distance(fingerTransform.position, childFingerTranform.position);
                        Vector3 direction = (fingerTransform.position - childFingerTranform.position).normalized;

                        GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
                        cube.transform.position = childFingerTranform.position + direction * (distance / 2);  // Offset in direction of bone
                        cube.transform.localScale = new Vector3(finger.tipRadius*2, distance+finger.tipRadius, finger.tipRadius*2);  // Scale based on bone length
                        cube.transform.up = direction;  // Orient cube in direction of bone
                        cube.transform.parent = fingerTransform;
                    }
                }

            }

            Undo.RegisterCreatedObjectUndo(contrainer, "Create Hand Copy Container");

            EditorGUIUtility.PingObject(handCopy);
            SceneView.lastActiveSceneView.FrameSelected();
        }

        public void EditorSaveGrabPose(Hand hand) {
            var pose = new HandPoseData(hand, transform);

            if(hand.left) {
                leftPose = pose;
                leftPoseSet = true;
                Debug.Log("Pose Saved - Left");
                if(poseScriptable != null)
                    if(!poseScriptable.leftSaved)
                        poseScriptable.SaveLeftPose(leftPose);
            }
            else {
                rightPose = pose;
                rightPoseSet = true;
                Debug.Log("Pose Saved - Right");
                if(poseScriptable != null)
                    if(!poseScriptable.rightSaved)
                        poseScriptable.SaveRightPose(rightPose);
            }
        }

        public void EditorClearPoses() {
            leftPoseSet = false;
            leftPose = new HandPoseData();
            rightPoseSet = false;
            rightPose = new HandPoseData();
        }
#endif

        public bool HasPose(bool left) {
            if(poseScriptable != null && ((left) ? poseScriptable.leftSaved : poseScriptable.rightSaved))
                return (left) ? poseScriptable.leftSaved : poseScriptable.rightSaved;
            return left ? leftPoseSet : rightPoseSet;
        }

        protected virtual void OnDrawGizmosSelected() {
            Transform targetTransform = null;
            if(this is GrabbablePose)
                targetTransform = transform;
            if(rightPoseSet && poseIndex == 0)
                GrabbablePoseGizmo.DrawHandGizmo(rightPose, targetTransform, Color.blue/2f);
            if(leftPoseSet)
                GrabbablePoseGizmo.DrawHandGizmo(leftPose, targetTransform, Color.red/2f);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPoseDataContainer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandProjector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5a19d3478546e174ba4693f363a23073
# ASMDEF: AutoHandAssembly.dll
# ---

using NaughtyAttributes;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HandProjector : MonoBehaviour {
        [Header("References")]
        public Hand hand;
        [Tooltip("This should be a copy of the hand with the desired visual setup for your projection hand")]
        public Hand handProjection;
        [Tooltip("The Object(s) under your Hand that contain the MeshRenderer Component(s)")]
        public Transform[] handProjectionVisuals;

        [Tooltip("Smoothing speed, turning too high could cause jitters")]
        public float speed = 15f;

        [Tooltip("If true everything in the hand Vvisuals will be disabled/hidden when projection hand is showing")]
        public bool hideHand;
        [ShowIf("hideHand")]
        [Tooltip("The Object(s) under your main hand (not the projection hand) that contain the MeshRenderer Component(s)")]
        public Transform[] handVisuals;

        [Tooltip("Should the projection interpolate between the hand pose and the projected grab pose based on the grip input axis")]
        public bool useGrabTransition;
        [EnableIf("useGrabTransition")]
        [Tooltip("This offsets the grab transistion by this percent when active [0-1 range]")]
        public float grabTransitionOffset = 0;
        [EnableIf("useGrabTransition")]
        [Tooltip("This sets the position of the hand based on its [(gripAxis + grabTransitionOffset) * grabDistanceMultiplyer] -> gripAxis is set on the HandControllerLink component on the main hand")]
        public float grabDistanceMultiplyer = 2f;
        [Tooltip("This sets the pose of the hand based on its [(gripAxis + grabTransitionOffset) * grabDistanceMultiplyer] -> gripAxis is set on the HandControllerLink component on the main hand")]
        [EnableIf("useGrabTransition")]
        public float grabTransitionMultiplyer = 2f;
        [DisableIf("useGrabTransition")]
        [Tooltip("This offsets the highlight by this percent when active [0-1 range]")]
        public float grabPercent = 1f;


        [Header("Events")]
        public UnityHandGrabEvent OnStartProjection;
        public UnityHandGrabEvent OnEndProjection;




        HandPoseData lastProjectionPose;
        HandPoseData newProjectionPose;
        HandPoseData postGrabPose;

        Vector3 lastProjectionPosition;
        Quaternion lastProjectionRotation;

        Grabbable target;
        float startMass = 0;
        float minGrabTime = 0;
        float currAmount;
        bool tryingGrab = false;

        void OnEnable() {
            if(handProjection.body == null)
                handProjection.body = handProjection.GetComponent<Rigidbody>();
            if(hand.body == null)
                hand.body = hand.GetComponent<Rigidbody>();
            handProjection.body.detectCollisions = false;
            handProjection.body.mass = 0;

            handProjection.enableMovement = false;
            handProjection.usingHighlight = false;
            handProjection.enableIK = false;

            handProjection.handFollow.followPositionStrength = 0;
            handProjection.handFollow.followRotationStrength = 0;
            handProjection.swayStrength = 0;
            handProjection.usingHighlight = false;
            handProjection.usingPoseAreas = false;
            startMass = hand.body.mass;
            minGrabTime = hand.minGrabTime;

            lastProjectionPosition = hand.transform.position;
            lastProjectionRotation = hand.transform.rotation;
            lastProjectionPose = new HandPoseData(hand);
            newProjectionPose = new HandPoseData(hand);
            postGrabPose = new HandPoseData(hand);

            hand.OnBeforeGrabbed += OnBeforeGrab;
            hand.OnGrabbed += OnGrab;
            hand.OnBeforeReleased += OnRelease;
            hand.OnTriggerGrab += OnTriggerGrab;

            if(!hideHand)
                handProjection.transform.parent = null;
        }

        void OnDisable() {
            ShowProjection(false);
            hand.OnBeforeGrabbed -= OnBeforeGrab;
            hand.OnGrabbed -= OnGrab;
            hand.OnBeforeReleased -= OnRelease;
            hand.OnTriggerGrab -= OnTriggerGrab;
        }

        void OnTriggerGrab(Hand hand, Grabbable grab) {
            tryingGrab = true;
        }

        void OnBeforeGrab(Hand hand, Grabbable grab) {

            if(hideHand) {
                lastProjectionPose.SetFingerPose(hand);
                hand.transform.position = handProjection.transform.position;
                hand.transform.rotation = handProjection.transform.rotation;
                hand.body.position = hand.transform.position;
                hand.body.rotation = hand.transform.rotation;

                hand.minGrabTime = 0f;
            }

            ShowProjection(false);
        }

        void OnGrab(Hand hand, Grabbable grab) {

            if(useGrabTransition) {
                hand.minGrabTime = minGrabTime;
            }
        }

        void OnRelease(Hand hand, Grabbable grab) {
            lastProjectionPose.CopyFromData(ref hand.handAnimator.currentHandPose);
            lastProjectionPose.SetFingerPose(handProjection);
            lastProjectionPosition = hand.transform.position;
            lastProjectionRotation = hand.transform.rotation;
            handProjection.transform.position = hand.transform.position;
            handProjection.transform.rotation = hand.transform.rotation;
            handProjection.body.position = handProjection.transform.position;
            handProjection.body.rotation = handProjection.transform.rotation;
        }

        void LateUpdate() {
            if(tryingGrab && hand.GetTriggerAxis() < 0.35f)
                tryingGrab = false;


            SetTarget(hand.lookingAtObj);
            ShowProjection(IsProjectionActive());
        }


        void OnProjectionStart(Hand projectionHand, Grabbable target) {
            OnStartProjection?.Invoke(projectionHand, target);
        }


        void OnProjectionEnd(Hand projectionHand, Grabbable target) {
            OnEndProjection?.Invoke(projectionHand, target);
        }


        void ShowProjection(bool show) {
            for(int i = 0; i < handProjectionVisuals.Length; i++)
                handProjectionVisuals[i].gameObject.SetActive(show);

            if(hideHand) {
                for(int i = 0; i < handVisuals.Length; i++)
                    handVisuals[i].gameObject.SetActive(!show);
                if(show)
                    hand.body.mass = 0;
                else
                    hand.body.mass = startMass;
            }

            if(show) {
                var targetHit = hand.highlighter.GetHighlightHit();
                if(targetHit.collider != null) {

                    if(!hand.CanGrab(target)) {
                        ShowProjection(false);
                        return;
                    }

                    var amount = useGrabTransition ? hand.grabCurve.Evaluate(hand.GetTriggerAxis() * grabTransitionMultiplyer + grabTransitionOffset) : grabPercent;
                    currAmount = Mathf.MoveTowards(currAmount, amount, Time.deltaTime * speed);
                    var newSpeed = Mathf.Lerp(speed, speed / 4f, hand.GetTriggerAxis());
                    if(hideHand)
                        hand.body.mass = Mathf.Lerp(startMass, 0, Mathf.Pow(amount * 2, 2));

                    //Do new pose
                    GrabbablePose grabPose;
                    handProjection.transform.position = hand.transform.position;
                    handProjection.transform.rotation = hand.transform.rotation;
                    if(target.GetGrabPose(hand, out grabPose)) {
                        grabPose.SetHandPose(handProjection, true);
                    }
                    else {
                        handProjection.transform.position -= handProjection.palmTransform.forward * 0.08f;
                        handProjection.body.position = handProjection.transform.position;
                        handProjection.AutoPose(targetHit, target);
                    }
                    newProjectionPose.SavePose(handProjection);
                    Vector3 targetPos;
                    Quaternion targetRot;

                    if(useGrabTransition && (target.grabType == HandGrabType.GrabbableToHand || (target.grabType == HandGrabType.Default && hand.grabType == GrabType.GrabbableToHand))) {
                        targetPos = hand.transform.position;
                        targetRot = hand.transform.rotation;
                    }
                    else {
                        targetPos = Vector3.Lerp(hand.transform.position, handProjection.transform.position, currAmount * grabDistanceMultiplyer);
                        targetRot = Quaternion.Lerp(hand.transform.rotation, handProjection.transform.rotation, currAmount * grabDistanceMultiplyer);
                    }


                    //Visual Adjustments
                    if(grabPose == null)
                        foreach(var finger in handProjection.fingers)
                            finger.SetFingerBend(Mathf.Clamp01(finger.GetLastHitBend() - 0.1f));
                    else {
                        foreach(var finger in handProjection.fingers)
                            finger.SetFingerBend(handProjection.gripOffset);
                    }


                    //Interpolate Fingers
                    postGrabPose.LerpPose(ref hand.handAnimator.currentHandPose, ref newProjectionPose, Mathf.Clamp01(currAmount - 0.1f) * 1.25f);
                    lastProjectionPose.LerpPose(ref lastProjectionPose, ref postGrabPose, speed * Time.deltaTime);
                    lastProjectionPose.SetFingerPose(handProjection);

                    if(hand.GetTriggerAxis() > 0.05f || !hideHand) {
                        //Interpolate Position
                        var distance = Vector3.Distance(lastProjectionPosition, targetPos);
                        var angle = Quaternion.Angle(lastProjectionRotation, targetRot);
                        handProjection.transform.position = Vector3.MoveTowards(lastProjectionPosition, targetPos, distance * Time.deltaTime * newSpeed );
                        handProjection.transform.rotation = Quaternion.RotateTowards(lastProjectionRotation, targetRot, angle * newSpeed * Time.deltaTime );
                    }
                    else {
                        handProjection.transform.position = hand.transform.position;
                        handProjection.transform.rotation = hand.transform.rotation;
                        lastProjectionPose.CopyFromData(ref hand.handAnimator.currentHandPose);
                        lastProjectionPose.SetFingerPose(handProjection);
                    }
                    handProjection.body.position = handProjection.transform.position;
                    handProjection.body.rotation = handProjection.transform.rotation;

                    lastProjectionPosition = handProjection.transform.position;
                    lastProjectionRotation = handProjection.transform.rotation;
                }
                else if(!hand.IsGrabbing()) {
                    handProjection.transform.position = hand.transform.position;
                    handProjection.transform.rotation = hand.transform.rotation;
                    lastProjectionPosition = hand.transform.position;
                    lastProjectionRotation = hand.transform.rotation;
                    lastProjectionPose.CopyFromData(ref hand.handAnimator.currentHandPose);
                    lastProjectionPose.SetFingerPose(handProjection);
                }
            }
            else if(useGrabTransition) {
                handProjection.transform.position = hand.transform.position;
                handProjection.transform.rotation = hand.transform.rotation;
            }
        }

        void SetTarget(Grabbable newTarget) {
            if(newTarget != null && !hand.CanGrab(newTarget))
                newTarget = null;

            if(hand.holdingObj != null || newTarget == null) {
                if(target != null) {
                    OnProjectionEnd(handProjection, target);

                    lastProjectionPosition = hand.transform.position;
                    lastProjectionRotation = hand.transform.rotation;
                    handProjection.transform.position = hand.transform.position;
                    handProjection.transform.rotation = hand.transform.rotation;
                    handProjection.body.position = handProjection.transform.position;
                    handProjection.body.rotation = handProjection.transform.rotation;
                }

                target = null;
            }

            if(newTarget != target) {
                if(target != null)
                    OnProjectionEnd(handProjection, target);
                target = newTarget;
                OnProjectionStart(handProjection, target);
            }
        }



        bool IsProjectionActive() {
            return target != null && hand.holdingObj == null && !hand.IsGrabbing() && !tryingGrab;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandProjector.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPublicEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 92716075103c54d429004096c1d8b87a
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand {
    public class HandPublicEvents : MonoBehaviour {
        public Hand hand;
        public UnityHandGrabEvent OnBeforeGrab = new UnityHandGrabEvent();
        public UnityHandGrabEvent OnGrab = new UnityHandGrabEvent();
        public UnityHandGrabEvent OnRelease = new UnityHandGrabEvent();
        public UnityHandGrabEvent OnForceRelease = new UnityHandGrabEvent();
        public UnityHandGrabEvent OnSqueeze = new UnityHandGrabEvent();
        public UnityHandGrabEvent OnUnsqueeze = new UnityHandGrabEvent();
        public UnityHandGrabEvent OnHighlight = new UnityHandGrabEvent();
        public UnityHandGrabEvent OnStopHighlight = new UnityHandGrabEvent();


        void OnEnable() {
            hand.OnBeforeGrabbed += OnBeforeGrabEvent;
            hand.OnGrabbed += OnGrabEvent;
            hand.OnReleased += OnReleaseEvent;
            hand.OnSqueezed += OnSqueezeEvent;
            hand.OnUnsqueezed += OnUnsqueezeEvent;
            hand.highlighter.OnHighlight += OnHighlightEvent;
            hand.highlighter.OnStopHighlight += OnStopHighlightEvent;
        }

        void OnDisable() {
            hand.OnBeforeGrabbed -= OnBeforeGrabEvent;
            hand.OnGrabbed -= OnGrabEvent;
            hand.OnReleased -= OnReleaseEvent;
            hand.OnSqueezed -= OnSqueezeEvent;
            hand.OnUnsqueezed -= OnUnsqueezeEvent;
            hand.highlighter.OnHighlight -= OnHighlightEvent;
            hand.highlighter.OnStopHighlight -= OnStopHighlightEvent;
        }

        public void OnBeforeGrabEvent(Hand hand, Grabbable grab) {
            OnBeforeGrab?.Invoke(hand, grab);
        }

        public void OnGrabEvent(Hand hand, Grabbable grab) {
            OnGrab?.Invoke(hand, grab);
        }

        public void OnReleaseEvent(Hand hand, Grabbable grab) {
            OnRelease?.Invoke(hand, grab);
        }

        public void OnSqueezeEvent(Hand hand, Grabbable grab) {
            OnSqueeze?.Invoke(hand, grab);
        }

        public void OnUnsqueezeEvent(Hand hand, Grabbable grab) {
            OnUnsqueeze?.Invoke(hand, grab);
        }
        public void OnHighlightEvent(Hand hand, Grabbable grab) {
            OnHighlight?.Invoke(hand, grab);
        }

        public void OnStopHighlightEvent(Hand hand, Grabbable grab) {
            OnStopHighlight?.Invoke(hand, grab);
        }

        public void OnForceReleaseEvent(Hand hand, Grabbable grab) {
            OnForceRelease?.Invoke(hand, grab);
        }

        private void OnDrawGizmosSelected() {
            if(hand == null && GetComponent<Hand>())
                hand = GetComponent<Hand>();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPublicEvents.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTeleportGuard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6a1edd828a2bad242ae37583788fee8d
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

namespace Autohand{
    [DefaultExecutionOrder(1000)]
    public class HandTeleportGuard : MonoBehaviour{
        [Header("Helps prevent hand from passing through static collision boundries")]
        public Hand hand;

        [Header("Guard Settings")]
        [Tooltip("The mask of things the guarding will ignore, if left on default or empty, will default to ignoring recommended Auto Hand layers")]
        public LayerMask ignoreMask;
        [Tooltip("The amount of distance change required in one frame or fixed udpate to activate the teleport guard")]
        public float buffer = 0.1f;
        [Tooltip("Whether this should always run or only run when activated by the teleporter")]
        public bool alwaysRun = false;
        [Tooltip("If true hands wont teleport return when past the max distance if something is in the way"), FormerlySerializedAs("strict")]
        public bool ignoreMaxHandDistance = false;
        
        
        Vector3 deltaHandPos;
        Vector3 deltaHandFixedPos;

        void Awake(){
            if(hand == null && GetComponent<Hand>())
                hand = GetComponent<Hand>();
            
            if(ignoreMask == 0)
                ignoreMask = LayerMask.GetMask(Hand.grabbableLayerNameDefault, Hand.grabbingLayerName, Hand.rightHandLayerName, Hand.leftHandLayerName, AutoHandPlayer.HandPlayerLayer);
            else
                ignoreMask |= LayerMask.GetMask(Hand.rightHandLayerName, Hand.leftHandLayerName);
        }

        void Update() {
            if(hand == null || !hand.gameObject.activeInHierarchy)
                return;

            if(alwaysRun) {
                var distance = Vector3.Distance(hand.palmTransform.position, deltaHandPos);
                if(ignoreMaxHandDistance || (!ignoreMaxHandDistance && distance < hand.handFollow.maxFollowDistance)) {
                    if(distance > buffer)
                        TeleportProtection(deltaHandPos, hand.palmTransform.position);
                }
                deltaHandPos = hand.palmTransform.position;
            }
        }

        void FixedUpdate() {
            if(hand == null || !hand.gameObject.activeInHierarchy)
                return;

            if(alwaysRun) {
                var distance = Vector3.Distance(hand.palmTransform.position, deltaHandFixedPos);
                if(ignoreMaxHandDistance || (!ignoreMaxHandDistance && distance < hand.handFollow.maxFollowDistance)) {
                    if(distance > buffer)
                        TeleportProtection(deltaHandFixedPos, hand.palmTransform.position);
                }
                deltaHandFixedPos = hand.palmTransform.position;
            }
        }

        /// <summary>Should be called just after a teleportation</summary>
        public void TeleportProtection(Vector3 fromPos, Vector3 toPos) {
            if (hand == null || hand.transform == null)
                return;

            RaycastHit[] hits = Physics.RaycastAll(fromPos, toPos - fromPos, Vector3.Distance(fromPos, toPos), ~ignoreMask);
            Vector3 handPos = Vector3.zero;
            foreach(var hit in hits) {
                if(hit.transform != hand.transform) {
                    handPos = fromPos;
                    break;
                }
            }
            if(handPos != Vector3.zero)
                hand.handFollow.SetHandLocation(handPos, hand.transform.rotation);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTeleportGuard.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTouchEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8bd7f387aed6a494eb37bfca11e0b9cd
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/hand-touch-trigger")]
    public class HandTouchEvent : MonoBehaviour{
        [Header("For Solid Collision")]
        [Tooltip("Whether or not first hand to enter should take ownership and be the only one to call events")]
        public bool oneHanded = true;
        public HandType handType = HandType.both;

        [Header("Events")]
        public UnityHandEvent HandStartTouch;
        public UnityHandEvent HandStopTouch;
        
        public HandEvent HandStartTouchEvent;
        public HandEvent HandStopTouchEvent;

        protected List<Hand> hands = new List<Hand>();

        protected virtual void OnDisable() 
        {
            foreach (Hand hand in new List<Hand>(hands))
            {
                if (hand == null)
                {
                    continue;
                }
                
                Untouch(hand);
            }
               
            hands.Clear();
        }

        public virtual void Touch(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(!hands.Contains(hand)) {
                if(oneHanded && hands.Count == 0) {
                    HandStartTouch?.Invoke(hand);
                    HandStartTouchEvent?.Invoke(hand);
                }
                else {
                    HandStartTouch?.Invoke(hand);
                    HandStartTouchEvent?.Invoke(hand);
                }

                hands.Add(hand);
            }
        }
        
        public virtual void Untouch(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(hands.Contains(hand)) {
                if(oneHanded && hands[0] == hand){
                    HandStopTouch?.Invoke(hand);
                    HandStopTouchEvent?.Invoke(hand);
                }
                else if(!oneHanded){
                    HandStopTouch?.Invoke(hand);
                    HandStopTouchEvent?.Invoke(hand);
                }

                hands.Remove(hand);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTouchEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTriggerAreaEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bf4e711b062ea3f4e9b98bb216629994
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    public delegate void HandAreaEvent(Hand hand, HandTriggerAreaEvents area);
    public delegate void HandEvent(Hand hand);

    [HelpURL("https://app.gitbook.com/o/v43F1UfKchmlV5VQCpro/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/hand-touch-trigger")]
    public class HandTriggerAreaEvents : MonoBehaviour{
        [Header("Trigger Events Settings")]
        [Tooltip("Whether or not first hand to enter should take ownership and be the only one to call events")]
        public bool oneHanded = true;
        public HandType handType = HandType.both;
        [Tooltip("Whether or not to call the release event if exiting while grab event activated")]
        public bool exitTriggerRelease = true;
        [Tooltip("Whether or not to call the release event if exiting while grab event activated")]
        public bool exitTriggerUnsqueeze = true;

        [Header("Events")]
        public UnityHandEvent HandEnter;
        public UnityHandEvent HandExit;
        public UnityHandEvent HandGrab;
        public UnityHandEvent HandRelease;
        public UnityHandEvent HandSqueeze;
        public UnityHandEvent HandUnsqueeze;

        //For Programmers <3
        public HandAreaEvent HandEnterEvent;
        public HandAreaEvent HandExitEvent;
        public HandAreaEvent HandGrabEvent;
        public HandAreaEvent HandReleaseEvent;
        public HandAreaEvent HandSqueezeEvent;
        public HandAreaEvent HandUnsqueezeEvent;

        protected List<Hand> hands = new List<Hand>();
        protected bool grabbing;
        protected bool squeezing;

        protected virtual void OnDisable()
        {
            foreach (Hand hand in new List<Hand>(hands))
            {
                if (hand == null)
                {
                    continue;
                }

                hand.RemoveHandTriggerArea(this);
            }
        } 

        protected virtual void Update(){
            foreach (var hand in hands){
                if (!hand.enabled) {
                    Exit(hand);
                    Release(hand);
                }
            }
        }


        public virtual void Enter(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(!hands.Contains(hand)) {
                hands.Add(hand);
                if(oneHanded && hands.Count == 1) {
                    HandEnter?.Invoke(hand);
                    HandEnterEvent?.Invoke(hand, this);
                }
                else {
                    HandEnter?.Invoke(hand);
                    HandEnterEvent?.Invoke(hand, this);
                }
            }
        }

        public virtual void Exit(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(hands.Contains(hand)) {
                if(oneHanded && hands[0] == hand){
                    HandExit?.Invoke(hand);
                    HandExitEvent?.Invoke(hand, this);

                    if(grabbing && exitTriggerRelease){
                        HandRelease?.Invoke(hand);
                        HandReleaseEvent?.Invoke(hand, this);
                        grabbing = false;
                    }
                    if(squeezing && exitTriggerUnsqueeze){
                        HandUnsqueeze?.Invoke(hand);
                        HandUnsqueezeEvent?.Invoke(hand, this);
                        squeezing = false;
                    }

                    //If there is another hand, it enters
                    if(hands.Count > 1) {
                        HandEnter?.Invoke(hands[1]);
                        HandEnterEvent?.Invoke(hands[1], this);
                    }

                }
                else if(!oneHanded) {
                    HandExit?.Invoke(hand);
                    HandExitEvent?.Invoke(hand, this);

                    if(grabbing && exitTriggerRelease){
                        HandRelease?.Invoke(hand);
                        HandReleaseEvent?.Invoke(hand, this);
                        grabbing = false;
                    }
                    if(squeezing && exitTriggerUnsqueeze){
                        HandUnsqueeze?.Invoke(hand);
                        HandUnsqueezeEvent?.Invoke(hand, this);
                        squeezing = false;
                    }

                }

                hands.Remove(hand);
            }
        }


        public virtual void Grab(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(grabbing)
                return;

            if(oneHanded && hands[0] == hand){
                HandGrab?.Invoke(hand);
                HandGrabEvent?.Invoke(hand, this);
                grabbing = true;
            }
            else if(!oneHanded){
                HandGrab?.Invoke(hand);
                HandGrabEvent?.Invoke(hand, this);
                grabbing = true;
            }
        }

        public virtual void Release(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(!grabbing)
                return;

            if(oneHanded && hands[0] == hand){
                HandRelease?.Invoke(hand);
                HandReleaseEvent?.Invoke(hand, this);
                grabbing = false;
            }
            else if(!oneHanded){
                HandRelease?.Invoke(hand);
                HandReleaseEvent?.Invoke(hand, this);
                grabbing = false;
            }
        }


        public virtual void Squeeze(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(squeezing)
                return;

            if(oneHanded && hands[0] == hand){
                HandSqueeze?.Invoke(hand);
                HandSqueezeEvent?.Invoke(hand, this);
                squeezing = true;
            }
            else if(!oneHanded){
                squeezing = true;
                HandSqueeze?.Invoke(hand);
                HandSqueezeEvent?.Invoke(hand, this);
            }
        }

        public virtual void Unsqueeze(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(!squeezing)
                return;

            if(oneHanded && hands[0] == hand){
                HandUnsqueeze?.Invoke(hand);
                HandUnsqueezeEvent?.Invoke(hand, this);
                squeezing = false;
            }
            else if(!oneHanded){
                squeezing = false;
                HandUnsqueeze?.Invoke(hand);
                HandUnsqueezeEvent?.Invoke(hand, this);
            }
        }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTriggerAreaEvents.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/IgnoreHandLayer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 132145a7047493646ad4aaa119028c20
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>For the special use case of attaching something under the hand component and 
/// wanting to ignore the hand layer override operation</summary>
[DefaultExecutionOrder(-100000)]
public class IgnoreHandLayer : MonoBehaviour
{
    public bool includeChildren = true;
    int startLayer;

    void Awake(){
        startLayer = gameObject.layer;
        Invoke("LateStart", 0.1f);
    }

    void LateStart(){
        if(includeChildren)
            SetLayerRecursive(transform, startLayer);
        else
            transform.gameObject.layer = startLayer;
    }
    
    internal void SetLayerRecursive(Transform obj, int newLayer) {
        obj.gameObject.layer = newLayer;
        for (int i = 0; i < obj.childCount; i++)
            SetLayerRecursive(obj.GetChild(i), newLayer);
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/IgnoreHandLayer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/WristLookEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6d164bbe93437d3429e93e40abc6aa56
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class WristLookEvent : MonoBehaviour{
        public Hand hand;
        public Camera head;

        [Tooltip("The minimum head->wrist distance required to activate")]
        public float maxDistance = 0.75f;
        [Tooltip("The angle precisness required to activate; 0 is any angle, 1 is exactly pointed at the face")]
        [Range(0, 1)]
        public float anglePreciseness = 0.75f;
        public bool disableWhileHolding = true;

        [Header("Events")]
        public UnityHandEvent OnShow;
        public UnityHandEvent OnHide;


        bool showing = false;

        void Update(){
            if (hand == null || head == null)
                return;

            var handPos = hand.transform.position;
            var headPos = head.transform.position;

            float lookness = Vector3.Dot((headPos - handPos).normalized, -hand.palmTransform.forward);
            float distance = Vector3.Distance(headPos, hand.palmTransform.position);
            bool found = lookness >= anglePreciseness && distance < maxDistance && hand.holdingObj == null;

            if (!showing && found){
                OnShow?.Invoke(hand);
                showing = true;
            }
            else if(showing && !found){
                OnHide?.Invoke(hand);
                showing = false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/WristLookEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Helpers/BoxColliderSerializationFixer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f628651c1a93e4f48909d4f9bf594f39
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BoxColliderSerializationFixer : MonoBehaviour
{
    //THIS SCRIPT SERVES TO FIX A SERIALIZATION BUG THAT OCCURS WHEN PACKAGING
    //A SCENE OR PREFAB WITH A BOX COLLIDER FROM 2023 OR HIGHER,
    //AND UNPACKING THAT SCENE ON A UNITY VERSION BEFORE 2022_2

    [System.Serializable]
    public struct ColliderData {
        public BoxCollider collider;
        public Vector3 size;
    }

    [SerializeField]
    private List<ColliderData> colliderSizes = new List<ColliderData>();

    [ContextMenu("Save Colliders")]
    public void SaveColliderSizes() {
        colliderSizes.Clear();
        SaveColliderSizesRecursive(transform);
    }

#if UNITY_2022_1_OR_NEWER
#else
    public void Start() {
        ApplyColliderSizesRecursive();
    }
#endif

    private void SaveColliderSizesRecursive(Transform currentTransform) {
        BoxCollider[] boxCollider = currentTransform.GetComponents<BoxCollider>();
        if(boxCollider != null && boxCollider.Length > 0) {
            for(int i = 0; i < boxCollider.Length; i++) {
                ColliderData data = new ColliderData {
                    size = boxCollider[i].size,
                    collider = boxCollider[i]
                };
                colliderSizes.Add(data);
            }
        }

        foreach(Transform child in currentTransform) {
            SaveColliderSizesRecursive(child);
        }
    }

    [ContextMenu("Apply Colliders")]
    public void ApplyColliderSizesRecursive() {
        //Debug.Log("Applying Collider  Resizes: This is a fix to a Unity Error where box collider sizes are not saved properly when downloading a scene from Unity 2022 or higher on a project from 2021 or lower. ");
        foreach(var collider in colliderSizes) {
            if(collider.collider != null)
                collider.collider.size = collider.size;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Helpers/BoxColliderSerializationFixer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Helpers/OnPlaceIgnoreHands.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0edca2759cb852b4582e1c514cb91df8
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class OnPlaceIgnoreHands : MonoBehaviour {

        public PlacePoint placePoint;
        public Hand[] ignoreHands;

        void OnEnable() {
            placePoint.OnPlaceEvent += OnPlace;
            placePoint.OnRemoveEvent += OnRemove;
        }


        void OnDisable() {
            placePoint.OnPlaceEvent -= OnPlace;
            placePoint.OnRemoveEvent -= OnRemove;
        }

        void OnPlace(PlacePoint point, Grabbable grab) {
            foreach(var hand in ignoreHands)
                grab.IgnoreHand(hand, true, true);
        }

        void OnRemove(PlacePoint point, Grabbable grab) {
            foreach(var hand in ignoreHands) 
                grab.IgnoreHand(hand, false, true);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Helpers/OnPlaceIgnoreHands.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/DynamicTimestepSetter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 55b6f48a67da5af47997d327361ececb
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DynamicTimestepSetter : MonoBehaviour {

    public float slowestTimestep = 1 / 50f;
    public float fastestTimestep = 1 / 144f;

    float[] deltaTimeList = new float[10];
    Coroutine slowUpdateRounte = null;
    int id;

    private void OnEnable() {
        if(slowUpdateRounte != null)
            StopCoroutine(slowUpdateRounte);

        slowUpdateRounte = StartCoroutine(SlowUpdate());
        GameObject.DontDestroyOnLoad(gameObject);
    }

    private void OnDisable() {
        if(slowUpdateRounte != null)
            StopCoroutine(slowUpdateRounte);
    }

    IEnumerator SlowUpdate() {
        while(gameObject.activeInHierarchy) {

            deltaTimeList[id] = Time.deltaTime;
            id = (++id) % deltaTimeList.Length;
            Time.fixedDeltaTime = Mathf.Clamp(AverageDelta(), fastestTimestep, slowestTimestep);
            yield return new WaitForSecondsRealtime(0.02f);
        }

        slowUpdateRounte = null;
    }

    public float AverageDelta() {
        float averageVelocity = 0;
        if(deltaTimeList.Length > 0) {
            foreach(var deltaTime in deltaTimeList) {
                averageVelocity += deltaTime;
            }
            averageVelocity /= deltaTimeList.Length;
        }

        return averageVelocity;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/DynamicTimestepSetter.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/EditorHand.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bf20b88b218211d4692fce1603f0cf60
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class EditorHand : MonoBehaviour {
        public bool useEditorGUI = true;
        public HandPoseDataContainer handPoseDataContainer;

        Hand _hand = null;
        public Hand hand {
            get {
                if(_hand == null)
                    _hand = GetComponent<Hand>();

                return _hand;
            }
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/EditorHand.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/GrabbableBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f3878a7d69c8ad44bbe220753bc94b7a
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;
using NaughtyAttributes;
using UnityEditor;
using UnityEngine.Serialization;

namespace Autohand {

    [DefaultExecutionOrder(-100)]
    public class GrabbableBase : MonoBehaviour {

        [AutoHeader("Grabbable")]
        public bool ignoreMe;

        [Tooltip("The physics body to connect this colliders grab to - if left empty will default to local body")]
        public Rigidbody body;

        [Tooltip("A copy of the mesh will be created and slighly scaled and this material will be applied to create a highlight effect with options")]
        public Material hightlightMaterial;

        [HideInInspector]
        public bool isGrabbable = true;


        private PlacePoint _placePoint = null;
        public PlacePoint placePoint { get { return _placePoint; } protected set { _placePoint = value; } }

        protected List<PlacePoint> _childPlacePoints = new List<PlacePoint>();
        public List<PlacePoint> childPlacePoints { get { return _childPlacePoints; } }


        internal List<Collider> _grabColliders = new List<Collider>();
        public List<Collider> grabColliders { get { return _grabColliders; } }


        internal Grabbable rootGrabbable;
        internal List<Grabbable> grabbableChildren = new List<Grabbable>();
        internal List<Grabbable> grabbableParents = new List<Grabbable>();
        internal List<Grabbable> jointedGrabbables = new List<Grabbable>();
        internal List<GrabbableChild> grabChildren = new List<GrabbableChild>();

        public float targetMass { get; protected set; }
        public float targetDrag { get; protected set; }
        public float targetAngularDrag { get; protected set; }



        protected Dictionary<Collider, PhysicsMaterial> grabColliderMaterials = new Dictionary<Collider, PhysicsMaterial>();
        protected Dictionary<Transform, int> originalLayers = new Dictionary<Transform, int>();

        private List<Hand> _heldBy = new List<Hand>();
        public List<Hand> heldBy {
            get { return _heldBy; }
        }

        private List<Hand> _beingGrabbedBy = new List<Hand>();
        public List<Hand> beingGrabbedBy {
            get { return _beingGrabbedBy; }
        }

        protected List<Hand> waitingToGrabHands = new List<Hand>();

        protected bool hightlighting;
        protected GameObject highlightObj;
        protected PlacePoint lastPlacePoint = null;

        public Transform originalParent { get; set; }
        protected Vector3 lastCenterOfMassPos;
        protected Quaternion lastCenterOfMassRot;
        protected CollisionDetectionMode detectionMode;
        protected RigidbodyInterpolation startInterpolation;

        public bool beingGrabbed { get; protected internal set; }
        internal bool beforeGrabFrame { get; set; }
        protected bool wasIsGrabbable = false;
        protected bool beingDestroyed = false;
        protected Dictionary<Hand, Coroutine> resetLayerRoutine = new Dictionary<Hand, Coroutine>();
        protected Dictionary<Hand, Coroutine> ignoreWhileGrabbingRoutine = new Dictionary<Hand, Coroutine>();
        protected List<Transform> jointedParents = new List<Transform>();
        protected Dictionary<Material, List<GameObject>> highlightObjs = new Dictionary<Material, List<GameObject>>();

        protected GrabbablePoseCombiner poseCombiner;
        protected float lastUpdateTime;

        protected bool rigidbodyDeactivated = false;
        protected SaveRigidbodyData rigidbodyData;

        /// <summary>This transform represents the root rigidbody gameobject. This is used in place a rigidbody call just in case the rigidbody is disabled</summary>
        public Transform rootTransform {
            get {
                if(body != null)
                    return body.transform;
                else if(rigidbodyData.IsSet())
                    return rigidbodyData.GetOrigin();
                else if(gameObject.CanGetComponent<Rigidbody>(out var rigidbody))
                    return rigidbody.transform;
                else if(gameObject.GetComponentInParent<Rigidbody>() != null)
                    return gameObject.GetComponentInParent<Rigidbody>().transform;
                else
                    return null;
            }
        }


        private CollisionTracker _collisionTracker;
        public CollisionTracker collisionTracker {
            get {
                if(_collisionTracker == null) {
                    if(!(_collisionTracker = GetComponent<CollisionTracker>())) {
                        _collisionTracker = gameObject.AddComponent<CollisionTracker>();
                        _collisionTracker.disableTriggersTracking = true;
                    }
                }
                return _collisionTracker;
            }
            protected set {
                if(_collisionTracker != null)
                    Destroy(_collisionTracker);

                _collisionTracker = value;
            }
        }

#if UNITY_EDITOR
        protected bool editorSelected = false;
#endif

        public virtual void Awake() {
            if(!gameObject.CanGetComponent(out poseCombiner))
                poseCombiner = gameObject.AddComponent<GrabbablePoseCombiner>();

            GetPoseSaves(transform);

            void GetPoseSaves(Transform obj) {
                if(obj.CanGetComponent(out Grabbable grab) && grab != this)
                    return;

                var poses = obj.GetComponents<GrabbablePose>();
                for(int i = 0; i < poses.Length; i++) {
                    poseCombiner.AddPose(poses[i]);
                    poses[i].grabbable = (this as Grabbable);
                }

                for(int i = 0; i < obj.childCount; i++)
                    GetPoseSaves(obj.GetChild(i));
            }

            if(body == null) {
                if(GetComponent<Rigidbody>())
                    body = GetComponent<Rigidbody>();
                else
                    Debug.LogError("RIGIDBODY MISSING FROM GRABBABLE: " + transform.name + " \nPlease add/attach a rigidbody", this);
            }

#if UNITY_EDITOR
            if(Selection.activeGameObject == gameObject) {
                Selection.activeGameObject = null;
                Debug.Log("Auto Hand (EDITOR ONLY): Selecting the grabbable in the inspector can cause lag and quality reduction at runtime. (Automatically deselecting at runtime) Remove this code at any time.", this);
                editorSelected = true;
            }

            Application.quitting += () => { if(editorSelected) Selection.activeGameObject = gameObject; };
#endif

            originalParent = body.transform.parent;
            detectionMode = body.collisionDetectionMode;
            startInterpolation = body.interpolation;
            UpdateGrabbableColliderSettings();
            UpdateGrabbableRigidbodySettings(body.linearDamping, body.angularDamping, body.mass);
        }


        private void OnDestroy() {
            beingDestroyed = true;
        }

        public virtual void HeldFixedUpdate() {
            if(heldBy.Count > 0) {
                lastCenterOfMassRot = body.transform.rotation;
                lastCenterOfMassPos = body.transform.position;
            }

        }

        protected virtual void OnDisable() {
            foreach(var routine in resetLayerRoutine) {
                IgnoreHand(routine.Key, false);
                if(routine.Value != null)
                    StopCoroutine(routine.Value);
            }
            resetLayerRoutine.Clear();

            foreach(var routine in ignoreGrabbableCollisions) {
                if(routine.Value != null)
                    StopCoroutine(routine.Value);
            }
            ignoreGrabbableCollisions.Clear();

            foreach(var routine in ignoreHandCollisions) {
                if(routine.Value != null)
                    StopCoroutine(routine.Value);
            }
            ignoreHandCollisions.Clear();

        }


        public void SetPlacePoint(PlacePoint point) {
            this.placePoint = point;

            foreach(var grabbable in grabbableChildren) {
                grabbable.placePoint = point;
            }
        }

        public void SetGrabbableChild(GrabbableChild child) {
            child.grabParent = this as Grabbable;
            if(!grabChildren.Contains(child))
                grabChildren.Add(child);
        }


        public void DeactivateRigidbody() {
            if(body != null) {
                if(body != null)
                    rigidbodyData = new SaveRigidbodyData(body);

                body = null;
                rigidbodyDeactivated = true;
            }

            foreach(var grabbable in grabbableChildren) {
                if(grabbable.body != null) {
                    grabbable.body = null;
                    grabbable.rigidbodyData = new SaveRigidbodyData(rigidbodyData);
                    grabbable.rigidbodyDeactivated = true;
                }
            }
        }


        public void ActivateRigidbody() {
            if(rigidbodyDeactivated && !beingDestroyed) {
                rigidbodyDeactivated = false;
                body = rigidbodyData.ReloadRigidbody();

                foreach(var grabbable in grabbableChildren) {
                    grabbable.rigidbodyDeactivated = false;
                    if(grabbable.body == null)
                        grabbable.body = body;
                }
            }
        }



        protected internal void SetLayerRecursive(int newLayer) {
            foreach(var transform in originalLayers) {
                transform.Key.gameObject.layer = newLayer;
            }
        }

        /// <summary>Sets the grabbable and children to the physics layers it had on Start()</summary>
        protected internal void ResetOriginalLayers() {
            foreach(var transform in originalLayers) {
                transform.Key.gameObject.layer = transform.Value;
            }
        }


        Dictionary<Grabbable, Coroutine> ignoreGrabbableCollisions = new Dictionary<Grabbable, Coroutine>();
        public void IgnoreGrabbableCollisionUntilNone(Grabbable other) {
            if(!beingDestroyed && !ignoreGrabbableCollisions.ContainsKey(other))
                ignoreGrabbableCollisions.Add(other, StartCoroutine(IgnoreGrabbableCollisionUntilNoneRoutine(other)));
        }

        protected IEnumerator IgnoreGrabbableCollisionUntilNoneRoutine(Grabbable other) {
            IgnoreGrabbableColliders(other, true);

            yield return new WaitForSeconds(0.05f);
            while(IsGrabbableOverlapping(other))
                yield return new WaitForSeconds(0.1f);

            IgnoreGrabbableColliders(other, false);
            ignoreGrabbableCollisions.Remove(other);

            if(ignoreGrabbableCollisions.ContainsKey(other))
                ignoreGrabbableCollisions.Remove(other);

        }

        public bool IsGrabbableOverlapping(Grabbable other) {
            foreach(var col1 in grabColliders) {
                foreach(var col2 in other.grabColliders) {
                    if(col1.enabled && !col1.isTrigger && !col1.isTrigger && col2.enabled && !col2.isTrigger && !col2.isTrigger &&
                        Physics.ComputePenetration(col1, col1.transform.position, col1.transform.rotation, col2, col2.transform.position, col2.transform.rotation, out _, out _)) {
                        return true;
                    }
                }
            }

            return false;
        }

        public void IgnoreGrabbableColliders(Grabbable other, bool ignore) {
            foreach(var col1 in grabColliders) {
                foreach(var col2 in other.grabColliders) {
                    Physics.IgnoreCollision(col1, col2, ignore);
                }
            }
        }




        Dictionary<Hand, Coroutine> ignoreHandCollisions = new Dictionary<Hand, Coroutine>();
        public void IgnoreHandCollisionUntilNone(Hand hand, float minIgnoreTime = 1) {
            if(gameObject.activeInHierarchy && !beingDestroyed && !ignoreHandCollisions.ContainsKey(hand))
                ignoreHandCollisions.Add(hand, StartCoroutine(IgnoreHandCollisionUntilNoneRoutine(hand, minIgnoreTime)));
        }

        protected IEnumerator IgnoreHandCollisionUntilNoneRoutine(Hand hand, float minIgnoreTime) {
            if(!ignoringHand.ContainsKey(hand) || !ignoringHand[hand]) {
                IgnoreHand(hand, true);

                yield return new WaitForSeconds(minIgnoreTime);
                if(minIgnoreTime != 0)
                    while(IsHandOverlapping(hand))
                        yield return new WaitForSeconds(0.1f);

                IgnoreHand(hand, false);
                if(resetLayerRoutine.ContainsKey(hand))
                    resetLayerRoutine.Remove(hand);
                if(ignoreHandCollisions.ContainsKey(hand))
                    ignoreHandCollisions.Remove(hand);
            }
        }


        protected IEnumerator IgnoreHandCollision(Hand hand, float time) {
            if(!ignoringHand.ContainsKey(hand) || !ignoringHand[hand]) {
                IgnoreHand(hand, true);

                yield return new WaitForSeconds(time);

                IgnoreHand(hand, false);
                resetLayerRoutine.Remove(hand);
            }
        }

        protected Dictionary<Hand, bool> ignoringHand = new Dictionary<Hand, bool>();
        public void IgnoreHand(Hand hand, bool ignore, bool overrideIgnoreRoutines = false) {
            if(overrideIgnoreRoutines && resetLayerRoutine.ContainsKey(hand) && resetLayerRoutine[hand] != null) {
                StopCoroutine(resetLayerRoutine[hand]);
                resetLayerRoutine[hand] = null;
            }

            foreach(var col in grabColliders)
                hand.HandIgnoreCollider(col, ignore);

            foreach(var grab in grabbableChildren)
                foreach(var col in grab.grabColliders)
                    hand.HandIgnoreCollider(col, ignore);

            foreach(var grab in grabbableParents)
                foreach(var col in grab.grabColliders)
                    hand.HandIgnoreCollider(col, ignore);

            if(!ignoringHand.ContainsKey(hand))
                ignoringHand.Add(hand, ignore);
            else
                ignoringHand[hand] = ignore;
        }


        public bool IsHandOverlapping(Hand hand) {
            float dist;
            Vector3 dir;
            foreach(var col2 in grabColliders) {
                foreach(var col1 in hand.handColliders) {
                    if(col1.enabled && !col1.isTrigger && !col1.isTrigger && col2.enabled && !col2.isTrigger && !col2.isTrigger &&
                    Physics.ComputePenetration(col1, col1.transform.position, col1.transform.rotation, col2, col2.transform.position, col2.transform.rotation, out dir, out dist)) {
                        return true;
                    }
                }
            }

            return false;
        }








        public bool GetSavedPose(out GrabbablePoseCombiner pose) {
            if(poseCombiner != null && poseCombiner.PoseCount() > 0) {
                pose = poseCombiner;
                return true;
            }
            else {
                pose = null;
                return false;
            }
        }

        public bool HasCustomPose() {
            return poseCombiner.PoseCount() > 0;
        }


        /// <summary>Resets the physics materials on all the colliders to the given physics material</summary>
        public void SetPhysicsMaterial(PhysicsMaterial physMat) {
            foreach(var collider in grabColliders) {
                collider.material = physMat;
            }
        }

        /// <summary>Resets the physics materials on all the colliders to how it was during last UpdateGrabbableColliderSettings()</summary>
        public void ResetPhysicsMateiral() {
            foreach(var col in grabColliderMaterials)
                col.Key.sharedMaterial = col.Value;
        }


        /// <summary> Saves the grabbables target collider settings to be whatever the current collider settings are. DO NOT CALL THIS WHILE THE GRABBABLE IS HELD </summary>
        public void UpdateGrabbableColliderSettings() {
            grabColliders.Clear();
            grabColliderMaterials.Clear();
            originalLayers.Clear();

            var colliders = body.GetComponentsInChildren<Collider>();
            foreach(var col in colliders) {
                if(col.isTrigger)
                    continue;

                grabColliders.Add(col);
                if(col.sharedMaterial == null)
                    grabColliderMaterials.Add(col, null);
                else
                    grabColliderMaterials.Add(col, col.sharedMaterial);

                if(!originalLayers.ContainsKey(col.transform)) {
                    if(col.gameObject.layer == LayerMask.NameToLayer("Default") || LayerMask.LayerToName(col.gameObject.layer) == "")
                        col.gameObject.layer = LayerMask.NameToLayer(Hand.grabbableLayerNameDefault);
                    originalLayers.Add(col.transform, col.gameObject.layer);
                }
            }
        }


        /// <summary>Sets the grabbables rigidbody settigns and target settings when not held</summary>
        public void UpdateGrabbableRigidbodySettings(float drag, float angularDrag, float mass) {
            targetAngularDrag = angularDrag;
            targetDrag = drag;
            targetMass = mass;

            if(body != null && (this as Grabbable).HeldCount() == 0) {
                body.linearDamping = drag;
                body.angularDamping = angularDrag;
                body.mass = mass;
            }
    }


        /// <summary>Adds a grabbables collider to this list of colliders on this grabbable, REMOVE_GRABBABLE_COLLIDERS() MUST BE CALLED</summary>
        public void AddGrabbableColliders(Grabbable other) {
            var ignoreHandKeys = new List<Hand>(ignoreHandCollisions.Keys);
            foreach(var col in other.grabColliders) {
                if(!grabColliders.Contains(col)) {
                    grabColliders.Add(col);
                    for(int i = 0; i < ignoreHandKeys.Count; i++)
                        ignoreHandKeys[i].HandIgnoreCollider(col, true);
                }
            }
        }

        public void RemoveGrabbableColliders(Grabbable other) {
            var ignoreHandKeys = new List<Hand>(ignoreHandCollisions.Keys);
            foreach(var col in other.grabColliders) {
                if(grabColliders.Contains(col)) {
                    grabColliders.Remove(col);
                    for(int i = 0; i < ignoreHandKeys.Count; i++)
                        ignoreHandKeys[i].HandIgnoreCollider(col, false);
                }
            }
        }




        public bool BeingDestroyed() {
            return beingDestroyed;
        }

        public void DebugBreak() {
#if UNITY_EDITOR
            Debug.Break();
#endif
        }


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/GrabbableBase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandAnimator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 098d5f45d7e666742b7295b5ab142cee
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [RequireComponent(typeof(Hand)), DefaultExecutionOrder(10000)]
    public class HandAnimator : MonoBehaviour {
        Hand hand;

        public float defaultPoseTransitionTime = 0.3f;
        public AnimationCurve defaultPoseTransitionCurve = AnimationCurve.Linear(0, 0, 1, 1);
        public HandPoseArea currentPoseArea { get; protected set; }



        HandPoseData _handPoseDataNonAlloc;
        internal ref HandPoseData handPoseDataNonAlloc {
            get {
                if(!_handPoseDataNonAlloc.isSet)
                    _handPoseDataNonAlloc = new HandPoseData(hand);

                return ref _handPoseDataNonAlloc;
            }
        }


        HandPoseData _openHandPose;
        public ref HandPoseData openHandPose {
            get {
                if(!_openHandPose.isSet)
                    _openHandPose = new HandPoseData(hand);

                return ref _openHandPose;
            }
        }


        HandPoseData _closeHandPose;
        public ref HandPoseData closeHandPose {
            get {
                if(!_closeHandPose.isSet)
                    _closeHandPose = new HandPoseData(hand);

                return ref _closeHandPose;
            }
        }

        HandPoseData _targetGrabPose;
        public ref HandPoseData targetGrabPose {
            get {
                if(!_targetGrabPose.isSet)
                    _targetGrabPose = new HandPoseData(hand);

                return ref _targetGrabPose;
            }
        }

        HandPoseData _currentInputPose;
        public ref HandPoseData currentInputPose {
            get {
                if(!_currentInputPose.isSet)
                    _currentInputPose = new HandPoseData(hand);

                return ref _currentInputPose;
            }
        }


        float targetPoseStartTransitionTime = 0;
        float targetPoseStopTransitionTime = 0;
        float targetPoseTotalTransitionTime = 0;
        AnimationCurve targetTransitionAnimationCurve = null;
        bool poseActive = false;
        HandPoseData _currentTargetPose;
        public ref HandPoseData currentTargetPose {
            get {
                if(!_currentTargetPose.isSet)
                    _currentTargetPose = new HandPoseData(hand);

                return ref _currentTargetPose;
            }
        }




        HandPoseData _currentHandPose;
        public ref HandPoseData currentHandPose {
            get {
                if(!_currentHandPose.isSet)
                    _currentHandPose = new HandPoseData(hand);

                return ref _currentHandPose;
            }
        }

        HandPoseData _currentHandSmoothPose;
        public ref HandPoseData currentHandSmoothPose {
            get {
                if(!_currentHandSmoothPose.isSet)
                    _currentHandSmoothPose = new HandPoseData(hand);

                return ref _currentHandSmoothPose;
            }
        }



        float fingerSwayVel;


        public void Start() {
            for(int i = 0; i < hand.fingers.Length; i++) {
                Finger finger = hand.fingers[i];
                int fingerIndex = (int)finger.fingerType;
                openHandPose.fingerPoses[fingerIndex].CopyFromData(ref finger.poseData[(int)FingerPoseEnum.Open]);
                closeHandPose.fingerPoses[fingerIndex].CopyFromData(ref finger.poseData[(int)FingerPoseEnum.Closed]);
            }

            if(defaultPoseTransitionCurve == null || defaultPoseTransitionCurve.keys.Length == 0)
                defaultPoseTransitionCurve = AnimationCurve.Linear(0, 0, 1, 1);

            targetTransitionAnimationCurve = defaultPoseTransitionCurve;
        }

        protected virtual void OnEnable() {
            hand = GetComponent<Hand>();
            hand.collisionTracker.OnTriggerFirstEnter += OnTriggerFirstEnter;
            hand.collisionTracker.OnTriggerLastExit += OnTriggerLastExit;
        }

        protected virtual void OnDisable() {
            hand.collisionTracker.OnTriggerFirstEnter -= OnTriggerFirstEnter;
            hand.collisionTracker.OnTriggerLastExit -= OnTriggerLastExit;
        }


        protected virtual void LateUpdate() {
            if(hand.enableIK) {
                UpdateInputPoseState();
                UpdateTargetPoseState();
            }
        }

        /// <summary>Determines how the hand should look/move based on its flags</summary>
        protected virtual void UpdateTargetPoseState() {
            float currentPoseState;
            if(poseActive)
                currentPoseState = targetTransitionAnimationCurve.Evaluate(Mathf.Clamp01((Time.time - targetPoseStartTransitionTime) / targetPoseTotalTransitionTime));
            else
                currentPoseState = targetTransitionAnimationCurve.Evaluate(1f - Mathf.Clamp01((Time.time - targetPoseStopTransitionTime) / targetPoseTotalTransitionTime));


            if(currentPoseState < 1f)
                currentHandPose.LerpPose(ref currentInputPose, ref currentTargetPose, currentPoseState);
            else if(poseActive)
                currentHandPose.CopyFromData(ref currentTargetPose);
            else
                currentHandPose.CopyFromData(ref currentInputPose);


            currentHandSmoothPose.LerpPose(ref currentHandSmoothPose, ref currentHandPose, 0.33f);
            if(!hand.IsGrabbing())
                currentHandSmoothPose.SetFingerPose(hand);
        }



        /// <summary>Determines how the hand should look/move based on its flags</summary>
        protected virtual void UpdateInputPoseState() {
            var averageVel = Vector3.zero;
            for(int i = 1; i < hand.handFollow.updatePositionTracked.Length; i++)
                averageVel += hand.handFollow.updatePositionTracked[i] - hand.handFollow.updatePositionTracked[i - 1];
            averageVel /= hand.handFollow.updatePositionTracked.Length;

            if(transform.parent != null)
                averageVel = (Quaternion.Inverse(hand.palmTransform.rotation) * transform.parent.rotation) * averageVel;


            //Responsable for movement finger sway
            float vel = (averageVel * 60).z;

            if(hand.CollisionCount() > 0) vel = 0;
            fingerSwayVel = Mathf.MoveTowards(fingerSwayVel, vel, Time.deltaTime * (Mathf.Abs((fingerSwayVel - vel) * 30f)));

            float grip = hand.gripOffset + hand.swayStrength * fingerSwayVel;
            foreach(var finger in hand.fingers) {
                int fingerIndex = (int)finger.fingerType;
                currentInputPose.fingerPoses[fingerIndex].LerpData(ref openHandPose.fingerPoses[fingerIndex], ref closeHandPose.fingerPoses[fingerIndex], grip + finger.GetCurrentBend());
            }
        }
        protected virtual void OnTriggerFirstEnter(GameObject other) {
            CheckEnterPoseArea(other);
        }

        protected virtual void OnTriggerLastExit(GameObject other) {
            CheckExitPoseArea(other);
        }



        /// <summary>Takes a new pose and an amount of time and poses the hand</summary>
        public virtual void SetTargetPose(ref HandPoseData poseData, float transitionTime, AnimationCurve animationCurve) {
            targetTransitionAnimationCurve = animationCurve;
            targetPoseTotalTransitionTime = transitionTime;
            targetPoseStartTransitionTime = Time.time;
            this.poseActive = true;
            currentTargetPose.CopyFromData(ref poseData);
            if(transitionTime == 0)
                currentHandPose.CopyFromData(ref poseData);
        }



        /// <summary>Takes a new pose and an amount of time and poses the hand</summary>
        public void SetPose(ref HandPoseData pose, float transitionTime, AnimationCurve animationCurve) => SetTargetPose(ref pose, transitionTime, animationCurve);
        public void SetPose(ref HandPoseData pose, float transitionTime) => SetTargetPose(ref pose, transitionTime, defaultPoseTransitionCurve);
        public void SetPose(ref HandPoseData pose) => SetTargetPose(ref pose, defaultPoseTransitionTime, defaultPoseTransitionCurve);


        /// <summary>Returns the current hand pose, ignoring what is being held - (IF SAVING A HELD POSE USE GetHeldPose())</summary>
        public ref HandPoseData GetCurrentHandPose() => ref currentHandPose;


        /// <summary>Copies the current hand pose to the given handPose, ignoring what is being held - (IF SAVING A HELD POSE USE GetHeldPose())</summary>
        public void CopyHandData(ref HandPoseData handPose) {
            if(!handPose.isSet)
                handPose = new HandPoseData(ref currentHandPose);
            else
                handPose.CopyFromData(ref currentHandPose);
        }


        /// <summary>Ensures any pose being made is canceled</summary>
        public void CancelPose(float cancelPoseTransitionTime) {
            targetPoseTotalTransitionTime = cancelPoseTransitionTime;
            targetPoseStopTransitionTime = Time.time;
            poseActive = false;
        }

        public void CancelPose() => CancelPose(defaultPoseTransitionTime);









        /// <summary>Checks and manages if any of the hands colliders enter a pose area</summary>
        protected virtual void CheckEnterPoseArea(GameObject other) {
            if(hand.holdingObj || !hand.usingPoseAreas || !other.activeInHierarchy)
                return;

            if(other && other.CanGetComponent(out HandPoseArea tempPose)) {
                for(int i = 0; i < tempPose.poseAreas.Length; i++) {
                    if(tempPose.poseIndex == hand.poseIndex) {
                        if(tempPose.HasPose(hand.left) && (currentPoseArea == null || currentPoseArea != tempPose)){
                            if(currentPoseArea != null)
                                TryRemoveHandPoseArea(currentPoseArea);

                            currentPoseArea = tempPose;
                            currentPoseArea?.OnHandEnter?.Invoke(hand);
                            if(hand.holdingObj == null)
                                SetPose(ref currentPoseArea.GetHandPoseData(hand.left), currentPoseArea.transitionTime);
                        }

                        break;
                    }
                }
            }
        }


        /// <summary>Checks if manages any of the hands colliders exit a pose area</summary>
        protected virtual void CheckExitPoseArea(GameObject other) {
            if(!hand.usingPoseAreas || !other.gameObject.activeInHierarchy)
                return;

            if(other.CanGetComponent(out HandPoseArea poseArea))
                TryRemoveHandPoseArea(poseArea);
        }

        public void TryRemoveHandPoseArea(HandPoseArea poseArea) {
            if(this.currentPoseArea != null && this.currentPoseArea.gameObject.Equals(poseArea.gameObject)) {
                if(hand.holdingObj == null) {
                    CancelPose();
                    this.currentPoseArea?.OnHandExit?.Invoke(hand);
                    this.currentPoseArea = null;
                }
                else if(hand.holdingObj != null) {
                    this.currentPoseArea?.OnHandExit?.Invoke(hand);
                    this.currentPoseArea = null;
                }
            }
        }

        public void ClearPoseArea() {
            if(currentPoseArea != null)
                currentPoseArea.OnHandExit?.Invoke(hand);
            currentPoseArea = null;
        }



        /// <returns>Returns true if that hand is currently locked into a pose</returns>
        public bool IsPosing() {
            return currentPoseArea != null || (hand.holdingObj != null && hand.holdingObj.HasCustomPose()) || (Time.time - targetPoseStartTransitionTime < targetPoseTotalTransitionTime) || poseActive;
        }
        


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandAnimator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e726604bfeafa1540ab696f8d739d797
# ASMDEF: AutoHandAssembly.dll
# ---
using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Serialization;
using UnityEngine.UIElements;

namespace Autohand {

    /// <summary>
    /// 
    /// </summary>
    public enum HandMovementType {
        /// <summary>Movement method for Auto Hand V2 and below</summary>
        Legacy,
        /// <summary>Uses physics forces</summary>
        Forces
    }

    public enum HandType {
        both,
        right,
        left,
        none
    }

    public enum GrabType {
        /// <summary>On grab, hand will move to the grabbable, create grab connection, then return to follow position</summary>
        HandToGrabbable,
        /// <summary>On grab, grabbable will move to the hand, then create grab connection</summary>
        GrabbableToHand,
        /// <summary>On grab, grabbable instantly travel to the hand</summary>
        InstantGrab
    }

    [Serializable]
    public struct VelocityTimePair {
        public float time;
        public Vector3 velocity;
    }

    public delegate void HandGrabEvent(Hand hand, Grabbable grabbable);
    public delegate void HandGameObjectEvent(Hand hand, GameObject other);

    [Serializable]  public class UnityHandGrabEvent : UnityEvent<Hand, Grabbable> { }
    [Serializable] public class UnityHandEvent : UnityEvent<Hand> { }



    [RequireComponent(typeof(Rigidbody)), RequireComponent(typeof(HandFollow)), RequireComponent(typeof(HandAnimator)), RequireComponent(typeof(HandGrabbableHighlighter)), DefaultExecutionOrder(10)]
    /// <summary>This is the base of the Auto Hand hand class, used for organizational purposes</summary>
    public class HandBase : MonoBehaviour {


        [AutoHeader("AUTO HAND")]
        public bool ignoreMe;

        public Finger[] fingers;

        [Tooltip("An empty GameObject that should be placed on the surface of the center of the palm")]
        public Transform palmTransform;
        [Tooltip("An empty GameObject that should be placed on the surface of the center of pinch point")]
        public Transform pinchPointTransform;

        [FormerlySerializedAs("isLeft")]
        [Tooltip("Whether this is the left (on) or right (off) hand")]
        public bool left = false;


        [Space]
        [Tooltip("Maximum distance for pickup"), Min(0.01f)]
        public float reachDistance = 0.2f;


        [AutoToggleHeader("Enable Movement", 0, 0, tooltip = "Whether or not to enable the hand's Rigidbody Physics movement")]
        public bool enableMovement = true;

        [EnableIf("enableMovement"), Tooltip("Follow target, the hand will always try to match this transforms position with rigidbody movements")]
        public Transform follow;

        [EnableIf("enableMovement"), Tooltip("Amplifier for applied velocity on released object"), Min(0)]
        public float throwPower = 1.25f;

        [Tooltip("Speed at which the gentle grab returns the grabbable"), Min(0)]
        [FormerlySerializedAs("smoothReturnSpeed")]
        public float gentleGrabSpeed = 1;

        [HideInInspector]
        public bool advancedFollowSettings = true;

        [AutoToggleHeader("Enable Auto Posing", 0, 0, tooltip = "Auto Posing will override Unity Animations -- This will disable all the Auto Hand IK, including animations from: finger sway, pose areas, finger bender scripts (runtime Auto Posing will still work)")]
        [Tooltip("Turn this on when you want to animate the hand or use other IK Drivers")]
        public bool enableIK = true;

        [EnableIf("enableIK"), Tooltip("How much the fingers sway from the velocity")]
        public float swayStrength = 0.4f;

        [EnableIf("enableIK"), Tooltip("This will offset each fingers bend (0 is no bend, 1 is full bend)")]
        public float gripOffset = 0.14f;



        [HideInInspector, NonSerialized, Tooltip("After this many seconds velocity data within a 'throw window' will be tossed out. (This allows you to get only use acceeleration data from the last 'x' seconds of the throw.)")]
        public float throwVelocityExpireTime = 0.125f;
        [HideInInspector, NonSerialized, Tooltip("After this many seconds velocity data within a 'throw window' will be tossed out. (This allows you to get only use acceeleration data from the last 'x' seconds of the throw.)")]
        public float throwAngularVelocityExpireTime = 0.25f;

        [HideInInspector, NonSerialized, Tooltip("Increase for closer finger tip results / Decrease for less physics checks - The number of steps the fingers take when bending to grab something")]
        public int fingerBendSteps = 40;

        [HideInInspector]
        public bool usingPoseAreas = true;

        [HideInInspector]
        public QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.Ignore;




        HandFollow _handFollow;
        public HandFollow handFollow {
            get {
                if(_handFollow == null)
                    _handFollow = GetComponent<HandFollow>();

                return _handFollow;
            }
        }


        HandAnimator _handAnimator;
        public HandAnimator handAnimator {
            get {
                if(_handAnimator == null)
                    _handAnimator = GetComponent<HandAnimator>();

                return _handAnimator;
            }
        }


        HandGrabbableHighlighter _highlighter;
        public HandGrabbableHighlighter highlighter {
            get {
                if(_highlighter == null)
                    _highlighter = GetComponent<HandGrabbableHighlighter>();

                return _highlighter;
            }
        }


        private CollisionTracker _collisionTracker;
        public CollisionTracker collisionTracker {
            get {
                if(_collisionTracker == null)
                    _collisionTracker = gameObject.AddComponent<CollisionTracker>();
                return _collisionTracker;
            }
            protected set {
                if(_collisionTracker != null)
                    Destroy(_collisionTracker);

                _collisionTracker = value;
            }
        }


        public HandVelocityTracker velocityTracker {
            get; protected set;
        }


        Rigidbody _body;
        public Rigidbody body { 
            get{
                if(_body == null)
                    _body = GetComponent<Rigidbody>();

                return _body;
            }
            internal set { _body = body; } 
        }

        public Transform moveTo {
            get {
                return handFollow.moveTo;
            }
        }


        Grabbable HoldingObj = null;
        public Grabbable holdingObj {
            get { return HoldingObj; }
            internal set { HoldingObj = value; }
        }


        protected GrabbablePose _currentHeldPose;
        public GrabbablePose currentHeldPose {
            get {
                return _currentHeldPose;
            }
    
            internal set {
                if(value == null && _currentHeldPose != null)
                    _currentHeldPose.CancelHandPose(this as Hand);

                _currentHeldPose = value;
            }
        }


        Transform _handGrabPoint;
        /// <summary>This is a transform the represents where the held hand is relative to the object in local space</summary>
        public Transform handGrabPoint {
            get {
                if(_handGrabPoint == null && gameObject.scene.isLoaded) {
                    _handGrabPoint = new GameObject().transform;
                    _handGrabPoint.name = "grabPoint";
                }
                return _handGrabPoint;
            }
        }


        Transform _localGrabbablePoint;
        /// <summary>This is a transform the represents where the held object should be relative to the hand in local space</summary>
        public Transform localGrabbablePoint {
            get {
                if(!gameObject.activeInHierarchy)
                    _localGrabbablePoint = null;
                else if(gameObject.activeInHierarchy && _localGrabbablePoint == null) {
                    _localGrabbablePoint = new GameObject().transform;
                    _localGrabbablePoint.name = "grabPosition";
                    _localGrabbablePoint.parent = transform;
                }


                return _localGrabbablePoint;
            }
        }



        Vector3 _grabPositionOffset = Vector3.zero;
        public Vector3 grabPositionOffset {
            get { return _grabPositionOffset; }
            set { _grabPositionOffset = value; }
        }

        Quaternion _grabRotationOffset = Quaternion.identity;
        public Quaternion grabRotationOffset {
            get { return _grabRotationOffset; }
            set { _grabRotationOffset = value; }
        }




        [HideInInspector, NonSerialized]
        public ConfigurableJoint heldJoint;

        public bool grabbing { get; protected set; }
        public bool squeezing { get; protected set; }

        protected float gripAxis;
        protected float squeezeAxis;
        
        internal List<Collider> handColliders = new List<Collider>();

        internal float lastGrabTime = 0;
        internal float lastReleaseTime = 0;


        BoxCollider _handEncapsulationCollider;
        internal BoxCollider handEncapsulationBox {
            get {
                if(!gameObject.activeInHierarchy)
                    _handEncapsulationCollider = null;
                else if(gameObject.activeInHierarchy && _handEncapsulationCollider == null) {
                    _handEncapsulationCollider = new GameObject().AddComponent<BoxCollider>();
                    _handEncapsulationCollider.name = "handEncapsulationBox";
                    _handEncapsulationCollider.transform.parent = transform;
                    _handEncapsulationCollider.transform.localPosition = Vector3.zero;
                    _handEncapsulationCollider.transform.localRotation = Quaternion.identity;
                    _handEncapsulationCollider.transform.localScale = Vector3.one;
                    _handEncapsulationCollider.isTrigger = true;
                    _handEncapsulationCollider.enabled = false;
                }

                return _handEncapsulationCollider;
            }
        }

        internal int handLayers;
        internal int handIgnoreCollisionLayers;

        protected Transform palmChild;
        protected Collider palmCollider;
        protected RaycastHit grabbingHit;

        protected int noCollisionFrames = 0;
        protected int collisionFrames = 0;

        protected bool prerendered = false;
        protected Vector3 preRenderPos;
        protected Quaternion preRenderRot;

        protected virtual void Awake() {
            body = GetComponent<Rigidbody>();
            body.interpolation = RigidbodyInterpolation.None;
            body.useGravity = false;

            body.solverIterations = 100;
            body.solverVelocityIterations = 100;

            if(palmCollider == null) {
                palmCollider = palmTransform.gameObject.AddComponent<BoxCollider>();
                (palmCollider as BoxCollider).size = new Vector3(0.2f, 0.15f, 0.05f);
                (palmCollider as BoxCollider).center = new Vector3(0f, 0f, -0.025f);
                palmCollider.enabled = false;
            }

            if(palmChild == null) {
                palmChild = new GameObject().transform;
                palmChild.parent = palmTransform;
            }

            var cams = AutoHandExtensions.CanFindObjectsOfType<Camera>(true);
            foreach(var cam in cams) {
                if(cam.targetDisplay == 0) {
                    bool found = false;
                    var handStabilizers = cam.gameObject.GetComponents<HandStabilizer>();
                    foreach(var handStabilizer in handStabilizers) {
                        if(handStabilizer.hand == this)
                            found = true;
                    }
                    if(!found)
                        cam.gameObject.AddComponent<HandStabilizer>().hand = this;
                }
            }
            
            if(velocityTracker == null)
                velocityTracker = new HandVelocityTracker(this);


            if(AutoHandSettings.UsingDynamicTimestep()) {
                if(AutoHandExtensions.CanFindObjectOfType<DynamicTimestepSetter>() == null) {
                    new GameObject() { name = "DynamicFixedTimeSetter" }.AddComponent<DynamicTimestepSetter>();
                    Debug.Log("AUTO HAND: Creating Dynamic Timestepper");
                }
            }


            //Update the hand encapsulation sphere
            var bounds = new Bounds(Vector3.zero, Vector3.zero);
            foreach(var finger in fingers) {
                var fingerJoints = finger.FingerJoints;
                for(int i = 0; i < fingerJoints.Length; i++)
                    bounds.Encapsulate(transform.InverseTransformPoint(fingerJoints[i].position));
                bounds.Encapsulate(transform.InverseTransformPoint(finger.tip.position + (finger.tip.position - transform.position)*finger.tipRadius));
            }

            bounds.Encapsulate(transform.InverseTransformPoint(palmTransform.position + palmTransform.forward*0.01f));
            bounds.Encapsulate(transform.InverseTransformPoint(palmTransform.position - palmTransform.forward*0.01f));

            handEncapsulationBox.center = bounds.center;
            handEncapsulationBox.size = bounds.size;
            handEncapsulationBox.gameObject.layer = LayerMask.NameToLayer(left ? Hand.leftHandLayerName : Hand.rightHandLayerName);
        }

        protected virtual void OnEnable() {
            SetHandCollidersRecursive(transform);
        }

        protected virtual void OnDisable() {
            handColliders.Clear();
        }

        protected virtual void OnDestroy() {
            if(_handGrabPoint != null)
                Destroy(_handGrabPoint.gameObject);
            if(_localGrabbablePoint != null)
                Destroy(_localGrabbablePoint.gameObject);
        }

        protected virtual void FixedUpdate(){
            velocityTracker.UpdateThrowing();

            if(CollisionCount() > 0) {
                noCollisionFrames = 0;
                collisionFrames++;
            }
            else {
                noCollisionFrames++;
                collisionFrames = 0;
            }

            if(holdingObj != null)
                holdingObj.HeldFixedUpdate();
        }


        //This is used to force the hand to always look like its where it should be even when physics is being weird
        //public virtual void OnPreRender() {
        //    if(!prerendered) {
        //        preRenderPos = transform.position;
        //        preRenderRot = transform.rotation;
        //    }

        //    //Hides fixed joint jitterings
        //    if(holdingObj != null && holdingObj.customGrabJoint == null && !IsGrabbing()) {
        //        //Debug.Log(name + ": PRERENDERED");
        //        transform.position = handGrabPoint.position;
        //        transform.rotation = handGrabPoint.rotation;
        //        prerendered = true;
        //    }
        //}

        //This is used to force the hand to always look like its where it should be even when physics is being weird
        public virtual void OnWillRenderObject(){
            if(!prerendered) {
                preRenderPos = transform.position;
                preRenderRot = transform.rotation;
            }

            //Hides fixed joint jitterings
            if(holdingObj != null && holdingObj.customGrabJoint == null && !IsGrabbing()) {
                //Debug.Log(name + ": PRERENDERED - " + Time.time);
                transform.position = handGrabPoint.position;
                transform.rotation = handGrabPoint.rotation;
                prerendered = true;
            }
        }

        //This puts everything where it should be for the physics update
        public virtual void OnPostRender(){
            //Returns position after hiding for camera
            if(prerendered && holdingObj != null && holdingObj.customGrabJoint == null && !IsGrabbing()) {
                //Debug.Log(name + ": POSTRENDERED - " + Time.time);
                transform.position = preRenderPos;
                transform.rotation = preRenderRot;
            }

            prerendered = false;
        }


        public float GetTriggerAxis() {
            return gripAxis;
        }



        protected void SetHandCollidersRecursive(Transform obj) {
            handColliders.Clear();
            AddHandCol(obj);

            void AddHandCol(Transform obj1) {
                foreach(var col in obj1.GetComponents<Collider>())
                    handColliders.Add(col);

                for(int i = 0; i < obj1.childCount; i++) {
                    AddHandCol(obj1.GetChild(i));
                }
            }
        }



        /// <summary>Returns the current throw velocity</summary>
        public Vector3 ThrowVelocity() { return velocityTracker.ThrowVelocity(); }

        /// <summary>Returns the current throw angular velocity</summary>
        public Vector3 ThrowAngularVelocity() { return velocityTracker.ThrowAngularVelocity(); }



        public  int CollisionCount() {
            if(holdingObj != null)
                return collisionTracker.collisionObjects.Count + holdingObj.CollisionCount();
            return collisionTracker.collisionObjects.Count;
        }


        /// <summary>Returns true during the time between when a grab starts and a hold begins</summary>
        public bool IsGrabbing() {
            return grabbing;
        }


        public bool IsHolding() {
            return holdingObj != null;
        }


        public static int GetHandsLayerMask() {
            return LayerMask.GetMask(Hand.rightHandLayerName, Hand.leftHandLayerName);
        }



        protected virtual void OnDrawGizmosSelected() {
            var radius = reachDistance;
            Gizmos.color = Color.yellow;
            Gizmos.DrawWireSphere(palmTransform.position + palmTransform.forward * radius, radius);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandBase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandFollow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1f45b4d990ab65e478cc05444d8e79a5
# ASMDEF: AutoHandAssembly.dll
# ---
using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace Autohand { 
    [RequireComponent(typeof(Hand)), DefaultExecutionOrder(0)]
    public class HandFollow : MonoBehaviour {

        Hand _hand;
        public Hand hand {
            get {
                if(_hand == null)
                    _hand = GetComponent<Hand>();
                return _hand;
            }
        }

        Transform follow;

        [Header("Move To Settings")]
        public float maxMoveToDistance = 0.1f;
        public float maxMoveToAngle = 45f;

        [Tooltip("Returns hand to the target after this distance [helps just in case it gets stuck]"), Min(0)]
        public float maxFollowDistance = 0.5f;
        [Tooltip("The maximum allowed velocity of the hand"), Min(0)]
        public float maxVelocity = 12f;

        [Header("Position Settings")]
        [Tooltip("Follow target speed (Can cause jittering if turned too high - recommend increasing drag with speed)"), Min(0)]
        public float followPositionStrength = 60;
        public float startDrag = 20f;
        [Tooltip("The drag multiplier the hand will lerp between the (start drag), and the (start drag * this) to when less than the dragDamperDistance from the follow target")]
        public float dragDamper = 3f;
        [Tooltip("The distance at which the drag damper starts to take effect")]
        public float dragDamperDistance = 0.025f;
        public float minVelocityChange = 1f;
        public float minVelocityDistanceMulti = 5f;

        [Header("Rotation Settings")]
        [Tooltip("Follow target rotation speed (Can cause jittering if turned too high - recommend increasing angular drag with speed)"), Min(0)]
        public float followRotationStrength = 100;
        public float startAngularDrag = 20;
        [Tooltip("The angular drag multiplier the hand will lerp between the (start angular drag), and the (start angular drag * this) to when less than the angleDragDamperDistance from the follow target")]
        public float angleDragDamper = 5f;
        [Tooltip("The distance at which the angular drag damper starts to take effect, in degrees")]
        public float angleDragDamperDistance = 3f;

        [Header("Mass Settings")]
        public float minMass = 0.25f;
        public float maxMass = 10f;
        public float heldMassDivider = 2f;
        public float distanceMassDifference = 10f;
        public float distanceMassMaxDistance = 0.5f;
        public float angleMassDifference = 10f;
        public float angleMassMaxAngle = 45f;

        [Header("Advanced Settings")]
        [Tooltip("If the hand is holding an unparented grabbable (see gabbable.parentOnGrab) and hits its max distance it will drop the object if it cannot returm within the max distance after this many frames - this is a safety to prevent the hand from getting stuck of grabbing something it isnt supposed to")]
        public int maxDistanceNoParentReleaseFrames = 1;

        [Tooltip("If the hand is holding a parented grabbable (see gabbable.parentOnGrab) and hits its max distance it will drop the object if it cannot returm within the max distance after this many frames - this is a safety to prevent the hand from getting stuck of grabbing something it isnt supposed to")]
        public int maxDistanceParentReleaseFrames = 5;


        public Vector3 lastAngularVelocity { get; protected set; }
        public Vector3 lastVelocity { get; protected set; }


        public Vector3 lastFollowDeltaPosition {
            get { return follow.position - lastFrameFollowPosition; }
        }
        public Quaternion lastFollowDeltaRotation {
            get { return follow.rotation * Quaternion.Inverse(lastFrameFollowRotation); }
        }


        internal Vector3 followVel;
        internal Vector3 followAngularVel;
        internal bool ignoreMoveFrame;

        internal Vector3 lastFrameFollowPosition;
        internal Quaternion lastFrameFollowRotation;
        internal Vector3 lastFollowPosition;
        internal Vector3 lastFollowRotation;

        internal Vector3[] updatePositionTracked = new Vector3[3];

        protected int tryMaxDistanceCount;

        protected float targetMass;
        protected float targetHeldMass;

        public Vector3 targetMoveToPosition { get; protected set; }
        public Quaternion targetMoveToRotation { get; protected set; }

        Vector3 lastSetMoveToFollowPosition;
        Quaternion lastSetMoveToFollowRotation;
        float lastSetMoveToTime;
        float lastSetVelocityTime;
        float lastSetAngularVelocityTime;
        float lastSetAverageMoveToTime;
        float lastSetMassTime;

        float currentFollowRotationStrength;
        float currentFollowPositionStrength;


        Transform _moveTo = null;
        public Transform moveTo {
            get {
                if(!gameObject.activeInHierarchy)
                    return null;

                if(_moveTo == null) {
                    _moveTo = new GameObject().transform;
                    _moveTo.parent = transform.parent;
                    _moveTo.name = "HAND FOLLOW POINT";
                }

                return _moveTo;
            }
        }

        List<Hand> currentHands {
            get{
                if(hand.holdingObj == null || hand.holdingObj.HeldCount() < 2)
                    return null;

                return hand.holdingObj.GetHeldBy(true, true);
            }
        }

        Rigidbody moveToBody;




        protected virtual void OnEnable() {
            currentFollowRotationStrength = followRotationStrength;
            currentFollowPositionStrength = followPositionStrength;
        }


        protected virtual void Awake() {
            hand.body.linearDamping = startDrag;
            hand.body.angularDamping = startAngularDrag;
            hand.body.useGravity = false;
        }

        protected virtual void OnDestroy() {
            if(_moveTo != null)
                Destroy(_moveTo.gameObject);
        }

        protected virtual void Update() {
            UpdateHandOffset();
        }

        protected virtual void FixedUpdate() {
            UpdateHandPhysicsMovement();
        }


        protected virtual void UpdateHandPhysicsMovement() {

            if(follow == null || follow != hand.follow)
                follow = hand.follow;

            if(follow != null && hand.enableMovement) {

                followVel = follow.position - lastFollowPosition;
                followAngularVel = follow.rotation.eulerAngles - lastFollowRotation;
                lastFollowPosition = follow.position;
                lastFollowRotation = follow.rotation.eulerAngles;


                if(!hand.IsGrabbing() && !hand.body.isKinematic) {
                    SetMoveTo();
                    AverageSetMoveTo();
                    SetMass();
                    MoveTo(Time.fixedDeltaTime);
                    TorqueTo(Time.fixedDeltaTime);
                }

                if(ignoreMoveFrame) {
                    hand.body.linearVelocity = Vector3.zero;
                    hand.body.angularVelocity = Vector3.zero;
                }
                ignoreMoveFrame = false;


                for(int i = 1; i < updatePositionTracked.Length; i++)
                    updatePositionTracked[i] = updatePositionTracked[i - 1];
                updatePositionTracked[0] = transform.localPosition;

                ignoreMoveFrame = false;
            }
        }



        float timeOffset;
        protected virtual void UpdateHandOffset() {
            if(follow == null || !hand.enableMovement)
                return;

            if(hand.enableMovement) {
                var deltaDist = Vector3.Distance(follow.position, lastFrameFollowPosition);
                var deltaRot = Quaternion.Angle(follow.rotation, lastFrameFollowRotation);

                if(hand.holdingObj && !hand.IsGrabbing() && !hand.holdingObj.maintainGrabOffset) {

                    //Returns the hand to the original position and rotation based on input movement
                    //A value of 1 gentle grab speed will return the hands position/rotation 1:1 with the controller movement
                    hand.grabPositionOffset = Vector3.MoveTowards(hand.grabPositionOffset, Vector3.zero, (deltaDist) * hand.gentleGrabSpeed * Time.deltaTime * 60f);
                    hand.grabRotationOffset = Quaternion.RotateTowards(hand.grabRotationOffset, Quaternion.identity, (deltaRot) * hand.gentleGrabSpeed * Time.deltaTime * 60f);
                    
                    if(!hand.holdingObj.useGentleGrab) {
                        UpdateOffset(true);
                    }
                }
                else if(!hand.holdingObj  && !hand.IsGrabbing()) {
                    UpdateOffset(false);
                }

                void UpdateOffset(bool isGrab) {

                    float grabTime = isGrab ? hand.lastGrabTime : hand.lastReleaseTime;
                    float grabReturnRotationDistance = Vector3.Angle(hand.grabRotationOffset.eulerAngles, Vector3.zero);
                    float grabReturnPositionDistance = hand.grabPositionOffset.magnitude;

                    var point = (Time.time - grabTime)/(hand.GetGrabTime()*2f);

                    timeOffset = ((timeOffset - 1f) + deltaDist * Time.deltaTime * hand.velocityGrabHandAmplifier)/2f + 1f;


                    var smoothTime = hand.GetGrabTime() * timeOffset;

                    hand.grabPositionOffset = Vector3.MoveTowards(hand.grabPositionOffset, Vector3.zero, grabReturnRotationDistance * smoothTime * Time.deltaTime);
                    hand.grabRotationOffset = Quaternion.RotateTowards(hand.grabRotationOffset, Quaternion.identity, grabReturnPositionDistance * smoothTime * Time.deltaTime);

                    hand.grabPositionOffset = Vector3.Lerp(hand.grabPositionOffset, Vector3.zero, point);
                    hand.grabRotationOffset = Quaternion.Lerp(hand.grabRotationOffset, Quaternion.identity, point);
                }
            }

            lastFrameFollowPosition = follow.position;
            lastFrameFollowRotation = follow.rotation;
        }








        internal virtual void MoveTo(float deltaTime) {

            if(followPositionStrength <= 0)
                return;

            if(Time.fixedTime - lastSetVelocityTime != 0)
                lastSetVelocityTime = Time.fixedTime;
            else
                return;

            if(currentHands != null) {
                foreach(var hand in currentHands) 
                    if(hand != null && hand != this.hand) 
                        hand.handFollow.MoveTo(deltaTime);
            }

            float minVelocityChange = this.minVelocityChange;
            var movePos = moveTo.position;
            var currentPos = hand.holdingObj != null && !hand.IsGrabbing() ? hand.handGrabPoint.position : hand.transform.position;
            var distance = Vector3.Distance(movePos, currentPos);

            var velocityClamp = hand.holdingObj != null ? hand.holdingObj.maxHeldVelocity : maxVelocity;
            Vector3 vel = (movePos - currentPos) * followPositionStrength;

            vel.x = Mathf.Clamp(vel.x, -velocityClamp, velocityClamp);
            vel.y = Mathf.Clamp(vel.y, -velocityClamp, velocityClamp);
            vel.z = Mathf.Clamp(vel.z, -velocityClamp, velocityClamp);

            float deltaOffset = Time.fixedDeltaTime / 0.011111f;
            float inverseDeltaOffset = 0.011111f / Time.fixedDeltaTime;
            Vector3 currentVelocity = hand.body.linearVelocity;
            minVelocityChange *= deltaOffset;
            minVelocityChange *= 1 + (distance)*minVelocityDistanceMulti;

            if(currentHands == null)
                hand.body.linearDamping = Mathf.Lerp((startDrag * dragDamper), startDrag, distance/dragDamperDistance) * inverseDeltaOffset;
            else 
                hand.body.linearDamping = startDrag * inverseDeltaOffset;

            Vector3 towardsVel;
            if(currentHands != null) {
                towardsVel = new Vector3(
                    Mathf.MoveTowards(currentVelocity.x, vel.x, minVelocityChange),
                    Mathf.MoveTowards(currentVelocity.y, vel.y, minVelocityChange),
                    Mathf.MoveTowards(currentVelocity.z, vel.z, minVelocityChange)
                );
            }
            else {
                towardsVel = new Vector3(
                    Mathf.MoveTowards(currentVelocity.x, vel.x, minVelocityChange/5f + Mathf.Abs(currentVelocity.x)/1.5f),
                    Mathf.MoveTowards(currentVelocity.y, vel.y, minVelocityChange/5f + Mathf.Abs(currentVelocity.y)/1.5f),
                    Mathf.MoveTowards(currentVelocity.z, vel.z, minVelocityChange/5f + Mathf.Abs(currentVelocity.z)/1.5f)
                );
            }

            hand.body.linearVelocity = towardsVel;
            lastVelocity = hand.body.linearVelocity;
        }





        /// <summary>Rotates the hand to the controller rotation using physics movement</summary>
        internal virtual void TorqueTo(float deltaTime) {

            if(currentFollowRotationStrength <= 0)
                return;

            if(Time.fixedTime - lastSetAngularVelocityTime != 0)
                lastSetAngularVelocityTime = Time.fixedTime;
            else
                return;

            var delta = (moveTo.rotation * Quaternion.Inverse(hand.body.rotation));
            delta.ToAngleAxis(out float angle, out Vector3 axis);
            if(float.IsInfinity(axis.x))
                return;


            if(currentHands != null) {
                foreach(var hand in currentHands)
                    if(hand != null && hand != this.hand)
                        hand.handFollow.TorqueTo(deltaTime);
            }

            if(angle > 180f)
                angle -= 360f;

            float multiLinear = Mathf.Deg2Rad * angle * currentFollowRotationStrength;
            Vector3 angular = multiLinear * axis.normalized;
            angle = Mathf.Abs(angle);


            float inverseDeltaOffset = 0.011111f / Time.fixedDeltaTime;

            if(currentHands == null)
                hand.body.angularDamping = Mathf.Lerp((startAngularDrag * angleDragDamper), startAngularDrag, angle/angleDragDamperDistance) * inverseDeltaOffset;
            else
                hand.body.angularDamping = startAngularDrag * inverseDeltaOffset;

            hand.body.angularVelocity = angular;
            lastAngularVelocity = hand.body.angularVelocity;
        }



        /// <summary>Sets the mass of the hands based on the follow target parameters </summary>
        protected virtual void SetMass() {
            if(Time.fixedTime - lastSetMassTime < 1/1000f)
                return;
            lastSetMassTime = Time.fixedTime;

            if(currentHands != null) {
                foreach(var hand in currentHands)
                    if(hand != null && hand != this.hand)
                        hand.handFollow.SetMass();
            }

            //Converts the distance to a mass value
            float lerpPoint = 0;
            float angleLerpPoint = 0;

            var currentPos = hand.holdingObj != null && !hand.IsGrabbing() ? hand.handGrabPoint.position : hand.transform.position;
            var currentRot = hand.holdingObj != null && !hand.IsGrabbing() ? hand.handGrabPoint.rotation : hand.transform.rotation;
            lerpPoint = Vector3.Distance(moveTo.position, currentPos)/distanceMassMaxDistance;
            angleLerpPoint = Mathf.Abs(Quaternion.Angle(moveTo.rotation, currentRot)) / angleMassMaxAngle;

            float distanceMass = Mathf.Lerp(minMass, maxMass, lerpPoint) * distanceMassDifference / (distanceMassDifference + angleMassDifference);
            float angleMass = Mathf.Lerp(minMass, maxMass, angleLerpPoint) * angleMassDifference / (distanceMassDifference + angleMassDifference);
            targetMass = (angleMass + distanceMass);
            hand.body.mass = targetMass;

            if(hand.holdingObj != null && !hand.IsGrabbing()) {
                float startHeldMass = hand.holdingObj.targetMass/heldMassDivider;
                var heldDistanceMass = Mathf.Lerp(startHeldMass * (minMass/maxMass), startHeldMass, lerpPoint)* distanceMassDifference / (distanceMassDifference + angleMassDifference);
                float heldAngleMass = Mathf.Lerp(startHeldMass * (minMass/maxMass), startHeldMass, angleLerpPoint) * angleMassDifference / (distanceMassDifference + angleMassDifference);
                targetHeldMass = heldAngleMass + heldDistanceMass;
                hand.holdingObj.body.mass = targetHeldMass;
            }

            AverageMass();
        }



        /// <summary>Averages the masses if there are multiple hands to stabilize the held state</summary>
        protected virtual void AverageMass() {

            if(currentHands == null)
                return;

            float averageMass = 0;
            float averageHeldMass = 0;
            foreach(var hand in currentHands) {
                averageMass += hand.handFollow.targetMass;
                averageHeldMass += hand.handFollow.targetHeldMass;
            }

            averageMass /= currentHands.Count;
            foreach(var hand in currentHands)
                hand.body.mass = averageMass;

            hand.holdingObj.body.mass = averageHeldMass/currentHands.Count;
        }




        protected virtual void CheckHandMaxDistance() {
            var currentHandPos = hand.holdingObj != null && !hand.IsGrabbing() ? hand.handGrabPoint.position : hand.transform.position;
            var distance = Vector3.Distance(currentHandPos, targetMoveToPosition);

            //Returns if out of distance, if you aren't holding anything
            if(distance > maxFollowDistance) {
                if(hand.holdingObj != null) {
                    if(((!hand.holdingObj.parentOnGrab && tryMaxDistanceCount < maxDistanceNoParentReleaseFrames) 
                        || (hand.holdingObj.parentOnGrab && tryMaxDistanceCount < maxDistanceParentReleaseFrames))) {
                        SetHandLocation(targetMoveToPosition, hand.transform.rotation);
                        //Adding two because we remove 1 at the end of the function
                        tryMaxDistanceCount += 2;
                    }
                    else {
                        hand.holdingObj.ForceHandRelease(hand);
                        SetHandLocation(targetMoveToPosition, hand.transform.rotation);
                    }
                }
                else {
                    SetHandLocation(targetMoveToPosition, hand.transform.rotation);
                }
            }

            if(tryMaxDistanceCount > 0)
                tryMaxDistanceCount--;
        }



        ///<summary>Moves the hand and whatever it might be holding (if teleport allowed) to given pos/rot</summary>
        public virtual void SetHandLocation(Vector3 targetPosition, Quaternion targetRotation) {
            var currentTransformPosition = hand.holdingObj != null && !hand.IsGrabbing() ? hand.handGrabPoint.position : hand.transform.position;
            var currentTransformRotation = hand.holdingObj != null && !hand.IsGrabbing() ? hand.handGrabPoint.rotation : hand.transform.rotation;
            var deltaPos = targetPosition - currentTransformPosition;
            var deltaRot = targetRotation * Quaternion.Inverse(currentTransformRotation);

            if(hand.holdingObj && hand.holdingObj.parentOnGrab) {
                if(!hand.IsGrabbing()) {
                    ignoreMoveFrame = true;

                    if(currentHands != null) {
                        targetPosition += currentTransformPosition - moveTo.position;
                        targetRotation *= (Quaternion.Inverse(moveTo.rotation)* currentTransformRotation);
                    }

                    var handRuler = AutoHandExtensions.transformRuler;
                    handRuler.position = currentTransformPosition;
                    handRuler.rotation = currentTransformRotation;

                    var grabRuler = AutoHandExtensions.transformRulerChild;
                    grabRuler.position = hand.holdingObj.body.transform.position;
                    grabRuler.rotation = hand.holdingObj.body.transform.rotation;

                    handRuler.position = targetPosition;
                    handRuler.rotation = targetRotation;

                    var deltaHandRot = targetRotation * Quaternion.Inverse(currentTransformRotation);
                    var deltaGrabPos = grabRuler.position - hand.holdingObj.body.transform.position;
                    var deltaGrabRot = Quaternion.Inverse(grabRuler.rotation) * hand.holdingObj.body.transform.rotation;

                    hand.transform.position = handRuler.position;
                    hand.transform.rotation = handRuler.rotation;
                    hand.body.position = handRuler.position;
                    hand.body.rotation = handRuler.rotation;

                    hand.holdingObj.body.transform.position = grabRuler.position;
                    hand.holdingObj.body.transform.rotation = grabRuler.rotation;
                    hand.holdingObj.body.position = grabRuler.position;
                    hand.holdingObj.body.rotation = grabRuler.rotation;

                    hand.body.linearVelocity = deltaHandRot * hand.body.linearVelocity;
                    hand.body.angularVelocity = deltaHandRot * hand.body.angularVelocity;
                    

                    hand.grabPositionOffset = deltaGrabRot * hand.grabPositionOffset;

                    foreach(var jointed in hand.holdingObj.jointedBodies) {
                        if(!(jointed.CanGetComponent(out Grabbable grab) && grab.HeldCount() > 0)) {
                            jointed.position += deltaGrabPos;
                            jointed.transform.RotateAround(hand.holdingObj.body.transform, deltaGrabRot);
                        }
                    }

                    hand.velocityTracker.ClearThrow();
                }
            }
            else {
                ignoreMoveFrame = true;
                hand.transform.position = targetPosition;
                hand.transform.rotation = targetRotation;
                hand.body.position = targetPosition;
                hand.body.rotation = targetRotation;
                hand.body.linearVelocity = Vector3.zero;
                hand.body.angularVelocity = Vector3.zero;
            }

            moveTo.position += deltaPos;
            moveTo.rotation *= deltaRot;
            SetMoveTo();
            //AverageSetMoveTo();

        }



        ///<summary>Moves the hand and keeps the local rotation</summary>
        public virtual void SetHandLocation(Vector3 targetPosition) {
            SetMoveTo();
            SetHandLocation(targetPosition, hand.transform.rotation);
        }



        /// <summary>Resets the hand location to the follow</summary>
        public void ResetHandLocation() {
            SetHandLocation(moveTo.position, moveTo.rotation);
        }



        /// <summary>Updates the target used to calculate velocity / movements towards follow</summary>
        public virtual void SetMoveTo(bool ignoreRedundancyCheck = false) {
            if(follow == null)
                return;

            if(ignoreRedundancyCheck || Time.fixedTime - lastSetMoveToTime > 0 || lastSetMoveToFollowPosition != (follow.position + hand.grabPositionOffset) || lastSetMoveToFollowRotation != (follow.rotation * hand.grabRotationOffset)) {
                lastSetMoveToFollowPosition = follow.position + hand.grabPositionOffset;
                lastSetMoveToFollowRotation = follow.rotation * hand.grabRotationOffset;
                lastSetMoveToTime = Time.fixedTime;
                lastSetVelocityTime = 0;
                lastSetAngularVelocityTime = 0;
                lastSetAverageMoveToTime = 0;
                lastSetMassTime = 0;
            }
            else {
                return;
            }

            if(currentHands != null) {
                foreach(var hand in currentHands)
                    if(hand != null && !hand.Equals(this.hand))
                        hand.handFollow.SetMoveTo();
            }


            var targetMoveToPosition = follow.position + hand.grabPositionOffset;
            var targetMoveToRotation = follow.rotation * hand.grabRotationOffset;

            if(hand.holdingObj != null) {
                if(hand.left) {
                    var moveLeft = hand.holdingObj.heldPositionOffset; moveLeft.x *= -1;
                    var leftRot = -hand.holdingObj.heldRotationOffset; leftRot.x *= -1;
                    targetMoveToPosition += transform.rotation * moveLeft;
                    targetMoveToRotation *= Quaternion.Euler(leftRot);
                }
                else {
                    targetMoveToPosition += transform.rotation * hand.holdingObj.heldPositionOffset;
                    targetMoveToRotation *= Quaternion.Euler(hand.holdingObj.heldRotationOffset);
                }
            }

            //Instead of just setting the moveto directly like in AutoHand V3,
            //I've found this method move using a moveTowards with a square root distance creates snappy forces
            //that get stronger the further away the hand is from the target, but in such a way that doesn't create sudden instabilities
            if(hand.holdingObj != null && !hand.IsGrabbing()) {
                var distance = Vector3.Distance(targetMoveToPosition, hand.handGrabPoint.position);
                var angleDistance = Quaternion.Angle(targetMoveToRotation, hand.handGrabPoint.rotation);
                moveTo.position = Vector3.MoveTowards(hand.handGrabPoint.position, targetMoveToPosition, maxMoveToDistance + (Mathf.Sqrt(distance+1f))-1f);
                moveTo.rotation = Quaternion.RotateTowards(hand.handGrabPoint.rotation, targetMoveToRotation, maxMoveToAngle + Mathf.Sqrt(angleDistance+1f)-1f);
            }
            else {
                var distance = Vector3.Distance(targetMoveToPosition, hand.transform.position);
                var angleDistance = Quaternion.Angle(targetMoveToRotation, hand.transform.rotation);
                moveTo.position = Vector3.MoveTowards(hand.transform.position, targetMoveToPosition, maxMoveToDistance + (Mathf.Sqrt(distance+1f)-1f));
                moveTo.rotation = Quaternion.RotateTowards(hand.transform.rotation, targetMoveToRotation, maxMoveToAngle + Mathf.Sqrt(angleDistance+1f)-1f);
            }

            //If you were using the old method of tracking the moveTo values, you can use these values to get the same results as V3.3 and older
            this.targetMoveToPosition = targetMoveToPosition;
            this.targetMoveToRotation = targetMoveToRotation;

            CheckHandMaxDistance();
        }




        public virtual void AverageSetMoveTo(bool ignoreRedundencyCheck = false) {

            if(Time.fixedTime - lastSetAverageMoveToTime != 0)
                lastSetAverageMoveToTime = Time.fixedTime;
            else if(!ignoreRedundencyCheck)
                return;

            //This line should stay between the fixed time return and the currentHands null check
            currentFollowRotationStrength = followRotationStrength;

            if(currentHands == null)
                return;

            var distance = Vector3.Distance(targetMoveToPosition, hand.handGrabPoint.position);
            var angleDistance = Quaternion.Angle(targetMoveToRotation, hand.handGrabPoint.rotation);

            var totalDistance = 0f;
            float totalAngleDistance = 0;
            foreach(var hand in currentHands) {
                if(hand != null) {
                    totalDistance += Vector3.Distance(hand.handFollow.targetMoveToPosition, hand.handGrabPoint.position);
                    totalAngleDistance +=  Quaternion.Angle(hand.handFollow.targetMoveToRotation, hand.handGrabPoint.rotation);
                }
            }

            if(currentHands != null) {
                foreach(var hand in currentHands)
                    if(hand != null && !hand.Equals(this.hand))
                        hand.handFollow.AverageSetMoveTo();
            }

            List<Hand> heldBy = currentHands;
            for(int i = 0; i < heldBy.Count; i++) {
                if(!heldBy[i].Equals(hand)) {
                    var otherHandFollow = heldBy[i].handFollow;
                    var otherMoveRotation = otherHandFollow.targetMoveToRotation;
                    var otherAngleDistance = Quaternion.Angle(otherMoveRotation, heldBy[i].handGrabPoint.rotation);

                    var massOffset = Mathf.Clamp01(heldBy[i].body.mass / hand.body.mass);
                    var deltaRotation = Quaternion.Inverse(heldBy[i].handGrabPoint.rotation) * heldBy[i].handFollow.targetMoveToRotation;

                    var totalDistanceDiff = Mathf.Clamp01(1-(totalDistance/maxFollowDistance));
                    moveTo.rotation = Quaternion.Lerp(moveTo.rotation, moveTo.rotation * deltaRotation, otherAngleDistance/totalAngleDistance * massOffset * 0.5f * totalDistanceDiff);

                }
            }

            currentFollowRotationStrength = Mathf.Lerp(followRotationStrength, followRotationStrength/4f, Mathf.Sqrt(distance/maxMoveToDistance));
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandFollow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandGizmos.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 58e5d1d13a89f3b498d2152b5d799f28
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand
{
    [RequireComponent(typeof(Hand))]
    public class HandGizmos : MonoBehaviour
        {
    #if UNITY_EDITOR
        private float lastOffset;
        private Quaternion lastHandRot;
        private Vector3 lastHandPos;
        private float lastReachDistance;

        Hand hand;

        private void OnDrawGizmos() {
            if (hand == null)
                hand = GetComponent<Hand>();

            if(hand.palmTransform == null)
                return;
        }


        private void OnDrawGizmosSelected() {
            if(hand.palmTransform == null)
                return;
            Gizmos.color = Color.blue;
            Gizmos.DrawRay(hand.palmTransform.position, hand.palmTransform.forward* hand.reachDistance);

            if (lastOffset == 0)
                lastOffset = hand.gripOffset;
            if (hand.gripOffset != lastOffset){
                lastOffset = hand.gripOffset;
                hand.RelaxHand();
            }

            if (lastReachDistance == 0)
                lastReachDistance = hand.reachDistance;

            if (hand.reachDistance != lastReachDistance){
                var percent = hand.reachDistance / lastReachDistance;
                lastReachDistance = hand.reachDistance;
            }
        }
    #endif

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandGizmos.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandGrabbableHighlighter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 62282a7c920d8134092c8af4e7d85f92
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HandGrabbableHighlighter : MonoBehaviour {
        Hand _hand;
        public Hand hand {
            get {
                if(_hand == null)
                    _hand = GetComponent<Hand>();
                return _hand;
            }
        }

        [Tooltip("When choosing between multiple targets to highlight, " +
            "the hand will favor objects in the palms local forward direction (0) " +
            "or the palms local right direction (1) or a blend between the two recommended (0.5-0.75). " +
            "The forward direction should be facing away from the palm and the right direction should be pointing to the finger tips")]
        public float palmForwardRightDirection = 0.65f;

        [Tooltip("Whether the highlighter should ignore or check for grabbabels that are using trigger colliders or just solid colliders - reocommend using collide for most cases.")]
        public QueryTriggerInteraction highlightQuery = QueryTriggerInteraction.Collide;


        /// <summary>Called when highlighting starts</summary>
        public event HandGrabEvent OnHighlight;
        /// <summary>Called when highlighting ends</summary>
        public event HandGrabEvent OnStopHighlight;



        //Highlighting doesn't need to be called every update, it can be called every 4th update without causing any noticable differrences 
        IEnumerator HighlightUpdate(float timestep) {
            yield return new WaitForEndOfFrame();
            yield return new WaitForFixedUpdate();

            //This will smooth out the highlight calls to help prevent lag spikes
            if(hand.left)
                yield return new WaitForSecondsRealtime(timestep / 2);

            while(true) {
                if(hand.usingHighlight) {
                    UpdateHighlight();
                }
                yield return new WaitForSecondsRealtime(timestep);
            }
        }

        RaycastHit _highlightHit = new RaycastHit();
        public RaycastHit highlightHit {
            get { return _highlightHit; }
            protected set { _highlightHit = value; }
        }

        [HideInInspector]
        public Collider[] highlightCollidersNonAlloc = new Collider[128];
        [HideInInspector]
        public int highlightColliderNonAllocCount = 0;
        [HideInInspector]
        public List<Grabbable> foundHighlightGrabbables = new List<Grabbable>();

        Coroutine highlightRoutine;
        protected List<RaycastHit> closestHits = new List<RaycastHit>();
        protected List<Grabbable> closestGrabs = new List<Grabbable>();

        public Grabbable currentHighlightTarget { get; protected set; }


        public virtual void OnEnable() {
            highlightRoutine = StartCoroutine(HighlightUpdate(1/30f));
        }

        public virtual void OnDisable() {
            if(highlightRoutine != null)
                StopCoroutine(highlightRoutine);

            if(currentHighlightTarget != null) {
                OnStopHighlight?.Invoke(hand, currentHighlightTarget);
                currentHighlightTarget.Unhighlight(hand);
            }
        }

        public virtual void Update() {
            if(hand.holdingObj != null || hand.IsGrabbing())
                currentHighlightTarget = null;
        }



        /// <summary>Manages the highlighting for grabbables</summary>
        public virtual void UpdateHighlight(bool overrideIgnoreHighlight = false, bool ignoreHighlightEvents = false) {

            if((overrideIgnoreHighlight || hand.usingHighlight) && hand.highlightLayers != 0 && (overrideIgnoreHighlight || hand.holdingObj == null && !hand.IsGrabbing())) {
                int grabbingLayer = LayerMask.NameToLayer(Hand.grabbingLayerName);
                int gabbingMask = LayerMask.GetMask(Hand.grabbingLayerName);
                highlightColliderNonAllocCount = Physics.OverlapSphereNonAlloc(hand.palmTransform.position + hand.palmTransform.forward * hand.reachDistance / 3f, hand.reachDistance, highlightCollidersNonAlloc, hand.highlightLayers & ~(hand.ignoreGrabCheckLayers.value), highlightQuery);
                foundHighlightGrabbables.Clear();

                for(int i = 0; i < highlightColliderNonAllocCount; i++) {
                    if(highlightCollidersNonAlloc[i].gameObject.HasGrabbable(out var grab)) {
                        grab.SetLayerRecursive(grabbingLayer);
                        foundHighlightGrabbables.Add(grab);
                    }
                }

                if(foundHighlightGrabbables.Count > 0) {
                    Vector3 dir = HandClosestHit(out _highlightHit, out IGrabbableEvents newLookingAtObjEvent, ~(hand.handLayers | hand.ignoreGrabCheckLayers.value));
                    Grabbable newLookingAtObj = null;
                    if(newLookingAtObjEvent != null && newLookingAtObjEvent.GetGrabbable() != null && newLookingAtObjEvent.GetGrabbable().enabled == true)
                        newLookingAtObj = newLookingAtObjEvent.GetGrabbable();

                    //Zero means it didn't hit
                    if(dir != Vector3.zero && (newLookingAtObj != null && newLookingAtObj.CanGrab(hand))) {
                        //Changes look target
                        if(newLookingAtObj != currentHighlightTarget) {
                            //Unhighlights current target if found
                            if(currentHighlightTarget != null) {
                                if(!ignoreHighlightEvents && OnStopHighlight != null)
                                    OnStopHighlight.Invoke(hand, currentHighlightTarget);

                                currentHighlightTarget.Unhighlight(hand, null, ignoreHighlightEvents);
                            }

                            currentHighlightTarget = newLookingAtObj;

                            //Highlights new target if found
                            if(!ignoreHighlightEvents && OnHighlight != null)
                                OnHighlight.Invoke(hand, currentHighlightTarget);
                            currentHighlightTarget.Highlight(hand, null, ignoreHighlightEvents);
                        }
                    }
                    //If it was looking at something but now it's not there anymore
                    else if(newLookingAtObj == null && currentHighlightTarget != null) {
                        //Just in case the object your hand is looking at is destroyed
                        if(!ignoreHighlightEvents && OnStopHighlight != null)
                            OnStopHighlight.Invoke(hand, currentHighlightTarget);
                        currentHighlightTarget.Unhighlight(hand, null, ignoreHighlightEvents);
                        currentHighlightTarget = null;
                    }

                    for(int i = 0; i < foundHighlightGrabbables.Count; i++) {
                        foundHighlightGrabbables[i].ResetOriginalLayers();
                    }
                }
                else if(currentHighlightTarget != null) {
                    //Just in case the object your hand is looking at is destroyed
                    if(!ignoreHighlightEvents && OnStopHighlight != null)
                        OnStopHighlight.Invoke(hand, currentHighlightTarget);

                    currentHighlightTarget.Unhighlight(hand, null, ignoreHighlightEvents);

                    currentHighlightTarget = null;
                }
            }
        }

        public void ClearHighlights() {
            if(currentHighlightTarget != null) {
                OnStopHighlight?.Invoke(hand, currentHighlightTarget);
                currentHighlightTarget.Unhighlight(hand);
                currentHighlightTarget = null;
            }
        }

        /// <summary>Returns the closest raycast hit from the hand's highlighting system, if no highlight, returns blank raycasthit</summary>
        public RaycastHit GetHighlightHit() {
            _highlightHit.point = hand.handGrabPoint.position;
            _highlightHit.normal = hand.handGrabPoint.up;
            return _highlightHit;
        }



        Collider[] handHighlightNonAlloc = new Collider[128];
        /// <summary>Finds the closest raycast from a cone of rays -> Returns average direction of all hits</summary>
        public virtual Vector3 HandClosestHit(out RaycastHit closestHit, out IGrabbableEvents grabbable, int layerMask, Grabbable target = null) {
            Grabbable grab;
            Vector3 palmForward = hand.palmTransform.forward;
            Vector3 palmRight = hand.palmTransform.right;
            Vector3 palmPosition = hand.palmTransform.position;
            GameObject rayHitObject;
            Grabbable lastRayHitGrabbable = null;
            Ray ray = new Ray();
            RaycastHit hit;
            Collider col;

            closestGrabs.Clear();
            closestHits.Clear();
            var checkSphereRadius = hand.reachDistance * 1.35f;
            int overlapCount = Physics.OverlapSphereNonAlloc(palmPosition + palmForward * (checkSphereRadius * 0.5f), checkSphereRadius, handHighlightNonAlloc, layerMask, highlightQuery);


            for(int i = 0; i < overlapCount; i++) {
                col = handHighlightNonAlloc[i];

                if(!(col is MeshCollider) || (col as MeshCollider).convex == true) {
                    Vector3 closestPoint = col.ClosestPoint(hand.palmTransform.transform.position);
                    ray.direction = closestPoint -hand.palmTransform.position;
                }
                else
                    ray.direction =hand.palmTransform.forward;

                ray.origin =hand.palmTransform.transform.position;
                ray.origin = Vector3.MoveTowards(ray.origin, col.bounds.center, 0.001f);
                
                if(ray.direction != Vector3.zero && Vector3.Angle(ray.direction,hand.palmTransform.forward) < 120 && Physics.Raycast(ray, out hit, checkSphereRadius*2, layerMask, highlightQuery)) {

                    rayHitObject = hit.collider.gameObject;
                    if(closestGrabs.Count > 0)
                        lastRayHitGrabbable = closestGrabs[closestGrabs.Count - 1];

                    if(closestGrabs.Count > 0 && rayHitObject == lastRayHitGrabbable.gameObject) {
                        if(target == null) {
                            closestGrabs.Add(lastRayHitGrabbable);
                            closestHits.Add(hit);
                        }
                    }
                    else if(rayHitObject.HasGrabbable(out grab) && hand.CanGrab(grab)) {
                        if(target == null || target == grab) {
                            closestGrabs.Add(grab);
                            closestHits.Add(hit);
                        }
                    }
                }
            }

            int closestHitCount = closestHits.Count;

            if(closestHitCount > 0) {
                closestHit = closestHits[0];
                grabbable = closestGrabs[0];
                Vector3 dir = Vector3.zero;
                float grabPriorityWeight = (grabbable is Grabbable) ? (grabbable as Grabbable).grabPriorityWeight : 1f;
                var targetDirection = Vector3.Lerp(palmForward, palmRight, palmForwardRightDirection);

                for(int i = 0; i < closestHitCount; i++) {
                    var newDistance = closestHits[i].distance / closestGrabs[i].grabPriorityWeight;
                    var newDot = Vector3.Dot(targetDirection, closestHits[i].point -hand.palmTransform.position)/2f * hand.reachDistance;
                    var currentDistance = closestHit.distance / grabPriorityWeight;
                    var currentDot = Vector3.Dot(targetDirection, closestHit.point -hand.palmTransform.position)/2f * hand.reachDistance;

                    if(newDistance-newDot < currentDistance-currentDot) {
                        closestHit = closestHits[i];
                        grabbable = closestGrabs[i];
                    }

                    dir += closestHits[i].point - hand.palmTransform.position;
                }

                if(hand.holdingObj == null && !hand.IsGrabbing()) {
                    if(hand.handGrabPoint.parent != closestHit.transform)
                        hand.handGrabPoint.parent = closestHit.collider.transform;
                    hand.handGrabPoint.position = closestHit.point;
                    hand.handGrabPoint.up = closestHit.normal;
                }

                return dir / closestHitCount;
            }

            closestHit = new RaycastHit();
            grabbable = null;
            return Vector3.zero;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandGrabbableHighlighter.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandPoseData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dbb03ea4c2f094a53b02416e0c2fc1ac
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {

    [System.Serializable]
    public struct FingerPoseData {
        public Matrix4x4[] poseRelativeMatrix;

        //Local rotations are calculated once when the matrix array is created, this prevents wasted calculations from calling matrix.extractrotation multiple times
        //These arent the same transform.localRotation, they represent the difference in rotation between the joints, ignoring any joints between them. Useful for quickly calulating blended poses
        public Quaternion[] localRotations;

        public bool isLocalSet => localRotations != null && localRotations.Length > 0;

        public bool isSet => poseRelativeMatrix != null && poseRelativeMatrix.Length > 0;


        public FingerPoseData(Hand hand, Finger finger) {
            poseRelativeMatrix = new Matrix4x4[4];
            poseRelativeMatrix[(int)FingerJointEnum.knuckle] = hand.transform.worldToLocalMatrix * finger.knuckleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.middle] =  finger.knuckleJoint.worldToLocalMatrix * finger.middleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.distal] =  finger.middleJoint.worldToLocalMatrix * finger.distalJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.tip] =  finger.distalJoint.worldToLocalMatrix * finger.tip.localToWorldMatrix;
            localRotations = new Quaternion[4];
            CalculateAdditionalValues(hand.transform.lossyScale);

        }

        public FingerPoseData(Transform hand, Transform knuckleJoint, Transform middleJoint, Transform distalJoint, Transform tip) {
            poseRelativeMatrix = new Matrix4x4[4];
            poseRelativeMatrix[(int)FingerJointEnum.knuckle] = hand.worldToLocalMatrix * knuckleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.middle] =  knuckleJoint.worldToLocalMatrix * middleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.distal] =  middleJoint.worldToLocalMatrix * distalJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.tip] =  distalJoint.worldToLocalMatrix * tip.localToWorldMatrix;
            localRotations = new Quaternion[4];
            CalculateAdditionalValues(hand.lossyScale);
        }

        public FingerPoseData(ref FingerPoseData data) {
            poseRelativeMatrix = new Matrix4x4[data.poseRelativeMatrix.Length];
            data.poseRelativeMatrix.CopyTo(poseRelativeMatrix, 0);
            localRotations = new Quaternion[4];
            data.localRotations.CopyTo(localRotations, 0);
        }

        public FingerPoseData(FingerPoseData data) {
            poseRelativeMatrix = new Matrix4x4[data.poseRelativeMatrix.Length];
            data.poseRelativeMatrix.CopyTo(poseRelativeMatrix, 0);
            localRotations = new Quaternion[4];
            data.localRotations.CopyTo(localRotations, 0);
        }


        public void SetPoseData(ref FingerPoseData data, FingerJointEnum[] fingerJoints) {
            if(data.poseRelativeMatrix == null || data.poseRelativeMatrix.Length == 0)
                poseRelativeMatrix = new Matrix4x4[4];

            for(int i = 0; i < fingerJoints.Length; i++) {
                int fingerJointIndex = (int)fingerJoints[i];
                poseRelativeMatrix[fingerJointIndex] = data.poseRelativeMatrix[fingerJointIndex];
                localRotations[fingerJointIndex] = data.localRotations[fingerJointIndex];
            }
        }


        public void SetPoseData(Hand hand, Finger finger) {
            if(poseRelativeMatrix == null || poseRelativeMatrix.Length == 0)
                poseRelativeMatrix = new Matrix4x4[4];
            poseRelativeMatrix[(int)FingerJointEnum.knuckle] = hand.transform.worldToLocalMatrix * finger.knuckleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.middle] =  finger.knuckleJoint.worldToLocalMatrix * finger.middleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.distal] =  finger.middleJoint.worldToLocalMatrix * finger.distalJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.tip] =  finger.distalJoint.worldToLocalMatrix * finger.tip.localToWorldMatrix;
            CalculateAdditionalValues(hand.transform.lossyScale);
        }

        public void SetPoseData(Transform hand, Transform knuckleJoint, Transform middleJoint, Transform distalJoint, Transform tip) {
            poseRelativeMatrix[(int)FingerJointEnum.knuckle] = hand.worldToLocalMatrix * knuckleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.middle] =  knuckleJoint.worldToLocalMatrix * middleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.distal] =  middleJoint.worldToLocalMatrix * distalJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.tip] =  distalJoint.worldToLocalMatrix * tip.localToWorldMatrix;
            CalculateAdditionalValues(hand.transform.lossyScale);
        }

        public void CopyFromData(ref FingerPoseData fingerPoseData) {
            fingerPoseData.poseRelativeMatrix.CopyTo(poseRelativeMatrix, 0);
            fingerPoseData.localRotations.CopyTo(localRotations, 0);
        }

        public void CopyFromData(FingerPoseData fingerPoseData) {
            fingerPoseData.poseRelativeMatrix.CopyTo(poseRelativeMatrix, 0);
            fingerPoseData.localRotations.CopyTo(localRotations, 0);
        }

        /// <summary>Interpolates this pose data to the given pose data by the given point 0.0 - 1.0</summary>
        /// <param name="updateMatrixData">If you know that you aren't going to use the matrix data for this PoseData</param>
        public void LerpDataTo(ref FingerPoseData otherPose, float point, bool updateMatrixData = false) {
            var length = poseRelativeMatrix.Length;
            for(int i = 0; i < length; i++) {
                var interpolatedRotation = Quaternion.Lerp(localRotations[i], otherPose.localRotations[i], point);
                localRotations[i] = interpolatedRotation;

                if(updateMatrixData)
                    poseRelativeMatrix[i].SetTRS(AutoHandExtensions.ExtractPosition(ref poseRelativeMatrix[i]), interpolatedRotation, AutoHandExtensions.ExtractScale(ref poseRelativeMatrix[i]));
            }
        }
        
        /// <summary>Interpolates this pose data to the given pose data by the given point 0.0 - 1.0</summary>
         /// <param name="updateMatrixData">If you know that you aren't going to use the matrix data for this PoseData</param>
        public void LerpData(ref FingerPoseData fromPose, ref FingerPoseData toPose, float point, bool updateMatrixData = false) {
            var length = poseRelativeMatrix.Length;
            for(int i = 0; i < length; i++) {
                var fromRotation = fromPose.localRotations[i];
                var toRotation = toPose.localRotations[i];
                var interpolatedRotation = Quaternion.Lerp(fromRotation, toRotation, point);

                localRotations[i] = interpolatedRotation;

                if(updateMatrixData)
                    poseRelativeMatrix[i].SetTRS(AutoHandExtensions.ExtractPosition(ref poseRelativeMatrix[i]), interpolatedRotation, AutoHandExtensions.ExtractScale(ref poseRelativeMatrix[i]));
            }
        }

        /// <summary>Sets the finger to match this poses data</summary>
        public void SetFingerPose(Finger finger) {
            var handToWorldRotation = finger.hand.transform.rotation;
            var knuckleRotation = handToWorldRotation * localRotations[(int)FingerJointEnum.knuckle];
            var middleRotation = knuckleRotation * localRotations[(int)FingerJointEnum.middle];
            var distalRotation = middleRotation * localRotations[(int)FingerJointEnum.distal];

            finger.knuckleJoint.rotation = knuckleRotation;
            finger.middleJoint.rotation = middleRotation;
            finger.distalJoint.rotation = distalRotation;
        }

        /// <summary>Sets the finger to match this poses data, faster than the simpler SetFingerPose(Finger finger) method because it doesn't call the transform getters when blending through two poses</summary>
        public void SetFingerPose(Finger finger, Quaternion handRotation, Transform knuckleJoint, Transform middleJoint, Transform distalJoint) {
            var handToWorldRotation = handRotation;
            var knuckleRotation = handToWorldRotation * localRotations[(int)FingerJointEnum.knuckle];
            var middleRotation = knuckleRotation * localRotations[(int)FingerJointEnum.middle];
            var distalRotation = middleRotation * localRotations[(int)FingerJointEnum.distal];

            knuckleJoint.rotation = knuckleRotation;
            middleJoint.rotation = middleRotation;
            distalJoint.rotation = distalRotation;
        }



        /// <summary>Returns Rotation Difference</summary>
        public float GetPoseDifferenceByAngle(ref FingerPoseData otherPose) {
            float angleDifference = 0;
            var length = poseRelativeMatrix.Length;
            for(int i = 0; i < length; i++) {
                Quaternion rotation = localRotations[i];
                Quaternion otherRotation = otherPose.localRotations[i];
                angleDifference += Quaternion.Angle(rotation, otherRotation);
            }

            return angleDifference;
        }

        public void CalculateAdditionalValues(Vector3 handLossyScale) {
            if(localRotations == null || localRotations.Length != 4)
                localRotations = new Quaternion[4];

            Matrix4x4 handGlobalMatrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, handLossyScale);
            Matrix4x4 knuckleGlobalMatrix = handGlobalMatrix * poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            Matrix4x4 middleGlobalMatrix = knuckleGlobalMatrix * poseRelativeMatrix[(int)FingerJointEnum.middle];
            Matrix4x4 distalGlobalMatrix = middleGlobalMatrix * poseRelativeMatrix[(int)FingerJointEnum.distal];
            Matrix4x4 tipGlobalMatrix = distalGlobalMatrix * poseRelativeMatrix[(int)FingerJointEnum.tip];

            Quaternion knuckleRotation = AutoHandExtensions.ExtractRotation(ref knuckleGlobalMatrix);
            Quaternion middleRotation = AutoHandExtensions.ExtractRotation(ref middleGlobalMatrix);
            Quaternion distalRotation = AutoHandExtensions.ExtractRotation(ref distalGlobalMatrix);
            Quaternion tipRotation = AutoHandExtensions.ExtractRotation(ref tipGlobalMatrix);

            localRotations[(int)FingerJointEnum.knuckle] = knuckleRotation;
            localRotations[(int)FingerJointEnum.middle] = Quaternion.Inverse(knuckleRotation) * middleRotation;
            localRotations[(int)FingerJointEnum.distal] = Quaternion.Inverse(middleRotation) * distalRotation;
            localRotations[(int)FingerJointEnum.tip] = Quaternion.Inverse(distalRotation) * tipRotation;
        }

    }


    [System.Serializable]
    public struct PoseIdentifier {
        public float[] fingerLengths;
        
        public PoseIdentifier(Hand hand) {
            fingerLengths = new float[5];
            for(int i = 0; i < 5; i++) {
                var finger = hand.fingers[i];
                if(finger.tip != null && finger.fingerType != FingerEnum.none)
                    fingerLengths[(int)finger.fingerType] = finger.tip.localPosition.sqrMagnitude;
            }
        }

        public static bool operator == (PoseIdentifier a, PoseIdentifier b) {
            for(int i = 0; i < 5; i++) {
                if(a.fingerLengths[i] != b.fingerLengths[i]) {
                    return false;
                }
            }
            return true;
        }

        public static bool operator != (PoseIdentifier a, PoseIdentifier b) {
            return !(a == b);
        }

        public override bool Equals(object obj) {
            if(obj is PoseIdentifier) {
                return this == (PoseIdentifier)obj;
            }
            return false;
        }

        public override int GetHashCode() {
            return base.GetHashCode();
        }
    }


    [System.Serializable]
    public struct HandPoseData {

        //DEPRECATED POSE DATA
        public Vector3 rotationOffset;
        public Vector3[] posePositions;
        public Quaternion[] poseRotations;

        //NEWER POSE DATA VALUES
        public Vector3 handOffset;
        public Quaternion localQuaternionOffset;
        public Vector3 globalHandScale;
        public FingerPoseData[] fingerPoses;
        public PoseIdentifier poseID;

        public bool isSet {
            get {
                return fingerPoses != null && fingerPoses.Length > 0;
            }
        }

        public bool isDataDeprecated {
            get {
                if(posePositions != null && posePositions.Length > 0) {
                    if(fingerPoses == null || fingerPoses.Length == 0) {
                        return true;
                    }

                    foreach(var fingerPose in fingerPoses) {
                        if(fingerPose.isSet && !fingerPose.isLocalSet) {
                            return true;
                        }
                    }
                }

                return false;
            }
        }

        /// <summary>Creates a new pose using the current hand relative to a given grabbable</summary>
        public HandPoseData(Hand hand, Grabbable grabbable) {
            //OLD POSE DATA
            posePositions = new Vector3[0];
            poseRotations = new Quaternion[0];
            rotationOffset = Vector3.zero;

            //NEW POSE DATA
            handOffset = new Vector3();
            localQuaternionOffset = Quaternion.identity;
            globalHandScale = hand.transform.lossyScale;
            fingerPoses = new FingerPoseData[5];

            poseID = new PoseIdentifier(hand);
            SavePose(hand, grabbable.transform);
        }

        /// <summary>Creates a new pose using the current hand relative to a given grabbable</summary>
        public HandPoseData(Hand hand, Transform point) {
            //OLD POSE DATA
            posePositions = new Vector3[0];
            poseRotations = new Quaternion[0];
            rotationOffset = Vector3.zero;

            //NEW POSE DATA
            handOffset = new Vector3();
            localQuaternionOffset = Quaternion.identity;
            globalHandScale = hand.transform.lossyScale;
            fingerPoses = new FingerPoseData[5];
            poseID = new PoseIdentifier(hand);

            SavePose(hand, point);
        }

        /// <summary>Creates a new pose using the current hand shape</summary>
        public HandPoseData(Hand hand) {
            //OLD POSE DATA
            posePositions = new Vector3[0];
            poseRotations = new Quaternion[0];
            rotationOffset = Vector3.zero;

            //NEW POSE DATA
            handOffset = new Vector3();
            localQuaternionOffset = Quaternion.identity;
            globalHandScale = hand.transform.lossyScale;
            fingerPoses = new FingerPoseData[5];
            poseID = new PoseIdentifier(hand);

            SavePose(hand, null);
        }

        /// <summary>Creates a new pose using the current hand shape</summary>
        public HandPoseData(ref HandPoseData data) {
            //OLD POSE DATA;
            posePositions = new Vector3[0];
            poseRotations = new Quaternion[0];
            rotationOffset = Vector3.zero;

            //NEW POSE DATA
            handOffset = data.handOffset;
            localQuaternionOffset = data.localQuaternionOffset;
            globalHandScale = data.globalHandScale;
            fingerPoses = new FingerPoseData[5];
            poseID = data.poseID;

            for(int i = 0; i < data.fingerPoses.Length; i++)
                fingerPoses[i] = new FingerPoseData(ref data.fingerPoses[i]);
        }

        /// <summary>Creates a new pose using the current hand shape</summary>
        public void CopyFromData(ref HandPoseData data) {
            //OLD POSE DATA;
            posePositions = new Vector3[0];
            poseRotations = new Quaternion[0];
            rotationOffset = Vector3.zero;

            //NEW POSE DATA
            handOffset = data.handOffset;
            localQuaternionOffset = data.localQuaternionOffset;
            globalHandScale = data.globalHandScale;
            if(fingerPoses == null || fingerPoses.Length == 0) {
                fingerPoses = new FingerPoseData[5];
                for(int i = 0; i < data.fingerPoses.Length; i++)
                    fingerPoses[i] = new FingerPoseData(ref data.fingerPoses[i]);
            }
            else {
                for(int i = 0; i < data.fingerPoses.Length; i++)
                    fingerPoses[i].CopyFromData(ref data.fingerPoses[i]);
            }

            poseID = data.poseID;

        }


        /// <summary> Saves the pose data to the match the current shape of the given hand, relative to is the grabbable transform the hand is posing to hold, or null if empty hand pose </summary>
        public void SavePose(Hand hand, Transform relativeTo = null) {
            foreach(var finger in hand.fingers) {
                if(finger.fingerType == FingerEnum.none)
                    Debug.LogError("AUTO HAND: Finger type is not set, finger type needs to be set on finger component", finger);

                int fingerIndex = (int)finger.fingerType;
                if(!fingerPoses[fingerIndex].isSet)
                    fingerPoses[fingerIndex] = new FingerPoseData(hand, finger);
                else
                    fingerPoses[fingerIndex].SetPoseData(hand, finger);
            }

            if(relativeTo != null) {
                handOffset = relativeTo.InverseTransformPoint(hand.transform.position);
                localQuaternionOffset = Quaternion.Inverse(relativeTo.rotation) * hand.transform.rotation;
                globalHandScale = hand.transform.lossyScale;
            }
            else { 
                handOffset = Vector3.zero;
                localQuaternionOffset = Quaternion.identity;
                globalHandScale = hand.transform.lossyScale;
            }
        }



        /// <summary>Sets the hand pose to match the given hand, relative to the given transform </summary>
        public void SetPose(Hand hand, Transform relativeTo = null) {
            SetPosition(hand, relativeTo);
            SetFingerPose(hand);
        }


        /// <summary>Sets the finger pose without changing the hands position</summary>
        public void SetFingerPose(Hand hand) {
            foreach(var finger in hand.fingers)
                fingerPoses[(int)finger.fingerType].SetFingerPose(finger);
        }


        /// <summary>Sets the position without setting the finger pose</summary>
        public void SetPosition(Hand hand, Transform relativeTo = null) {
            if(relativeTo != null && relativeTo != hand.transform) {
                Matrix4x4 relativeToWorldMatrix = GetHandToWorldMatrix(relativeTo);

                Vector3 newPosition = AutoHandExtensions.ExtractPosition(ref relativeToWorldMatrix);
                Quaternion newRotation = AutoHandExtensions.ExtractRotation(ref relativeToWorldMatrix);

                hand.transform.SetPositionAndRotation(newPosition, newRotation);
                if(hand.body != null) {
                    hand.body.position = newPosition;
                    hand.body.rotation = newRotation;
                }
            }
        }

        public Matrix4x4 GetHandToWorldMatrix(Transform relativeTo) {
            if(relativeTo == null)
                return Matrix4x4.TRS(handOffset, localQuaternionOffset, globalHandScale);

            var globalHandPosition = relativeTo.TransformPoint(handOffset);
            var globalHandRotation = relativeTo.rotation * localQuaternionOffset;
            return Matrix4x4.TRS(globalHandPosition, globalHandRotation, globalHandScale);
        }



        public void LerpPose(ref HandPoseData from, ref HandPoseData to, float point) {
            handOffset = Vector3.Lerp(from.handOffset, to.handOffset, point);
            globalHandScale = Vector3.Lerp(from.globalHandScale, to.globalHandScale, point);
            localQuaternionOffset = Quaternion.Lerp(from.localQuaternionOffset, to.localQuaternionOffset, point);

            for(int i = 0; i < 5; i++) {
                fingerPoses[i].CopyFromData(ref from.fingerPoses[i]);
                fingerPoses[i].LerpDataTo(ref to.fingerPoses[i], point);
            }
        }


        public static void LerpPose(ref HandPoseData lerpPose, ref HandPoseData from, ref HandPoseData to, float point) {
            lerpPose.handOffset = Vector3.Lerp(from.handOffset, to.handOffset, point);
            lerpPose.globalHandScale = Vector3.Lerp(from.globalHandScale, to.globalHandScale, point);
            lerpPose.localQuaternionOffset = Quaternion.Lerp(from.localQuaternionOffset, to.localQuaternionOffset, point);

            for(int i = 0; i < 5; i++) {
                lerpPose.fingerPoses[i].CopyFromData(ref from.fingerPoses[i]);
                lerpPose.fingerPoses[i].LerpDataTo(ref to.fingerPoses[i], point);
            }
        }

        public void GetPoseDifference(ref HandPoseData otherPose, out float[] fingerDistances) {
            fingerDistances = new float[5];
            for(int i = 0; i < 5; i++) {
                fingerDistances[i] = fingerPoses[i].GetPoseDifferenceByAngle(ref otherPose.fingerPoses[i]);
            }
        }

        public void GetPoseDifference(ref HandPoseData otherPose, out float indexDifference, out float middleDifference, out float ringDifference, out float pinkyDifference, out float thumbDifference) {
            GetPoseDifference(ref otherPose, out var fingerDistances);
            indexDifference = fingerDistances[(int)FingerEnum.index];
            middleDifference = fingerDistances[(int)FingerEnum.middle];
            ringDifference = fingerDistances[(int)FingerEnum.ring];
            pinkyDifference = fingerDistances[(int)FingerEnum.pinky];
            thumbDifference = fingerDistances[(int)FingerEnum.thumb];
        }

        public void UpdateDepricatedData(Hand hand, Transform relativeTo) {

            List<Transform> poseTransformsList = new List<Transform>();

            foreach(var finger in hand.fingers)
                AssignChildrenPose(finger.transform);

            void AssignChildrenPose(Transform obj) {
                poseTransformsList.Add(obj);

                for(int j = 0; j < obj.childCount; j++)
                    AssignChildrenPose(obj.GetChild(j));
            }

            if(poseRotations.Length == 0 || posePositions.Length == 0 || posePositions.Length != poseTransformsList.Count) {
                Debug.LogWarning("AUTO HAND: Pose data is not set, skipping updating this pose data", relativeTo);
                return;
            }

            fingerPoses = new FingerPoseData[5];


            var newFingerPose = new FingerPoseData[5];
            foreach(var finger in hand.fingers) {
                newFingerPose[(int)finger.fingerType].poseRelativeMatrix = new Matrix4x4[3];
            }

            for(int i = 0; i < poseTransformsList.Count; i++) {
                var transformJoint = poseTransformsList[i];

                foreach(var finger in hand.fingers) {
                    if(finger.isDataDepricated) {
                        Debug.LogError("AUTO HAND: Finger data is depricated - please try manually updating the finger references on your hand and try again", finger);
                        return;
                    }

                    var knuckleJointIndex = poseTransformsList.IndexOf(finger.knuckleJoint);
                    var middleJointIndex = poseTransformsList.IndexOf(finger.middleJoint);
                    var distalJointIndex = poseTransformsList.IndexOf(finger.distalJoint);

                    var knuckleJointPosition = posePositions[knuckleJointIndex];
                    var middleJointPosition = posePositions[middleJointIndex];
                    var distalJointPosition = posePositions[distalJointIndex];

                    var knuckleJointRotation = poseRotations[knuckleJointIndex];
                    var middleJointRotation = poseRotations[middleJointIndex];
                    var distalJointRotation = poseRotations[distalJointIndex];

                    var knuckleStartPosition = finger.knuckleJoint.localPosition;
                    var middleStartPosition = finger.middleJoint.localPosition;
                    var distalStartPosition = finger.distalJoint.localPosition;

                    var knuckleStartRotation = finger.knuckleJoint.localRotation;
                    var middleStartRotation = finger.middleJoint.localRotation;
                    var distalStartRotation = finger.distalJoint.localRotation;

                    finger.knuckleJoint.localPosition = knuckleJointPosition;
                    finger.middleJoint.localPosition = middleJointPosition;
                    finger.distalJoint.localPosition = distalJointPosition;

                    finger.knuckleJoint.localRotation = knuckleJointRotation;
                    finger.middleJoint.localRotation = middleJointRotation;
                    finger.distalJoint.localRotation = distalJointRotation;

                    newFingerPose[(int)finger.fingerType] = new FingerPoseData(hand, finger);

                    finger.knuckleJoint.localPosition = knuckleStartPosition;
                    finger.middleJoint.localPosition = middleStartPosition;
                    finger.distalJoint.localPosition = distalStartPosition;

                    finger.knuckleJoint.localRotation = knuckleStartRotation;
                    finger.middleJoint.localRotation = middleStartRotation;
                    finger.distalJoint.localRotation = distalStartRotation;
                }
            }

            globalHandScale = hand.transform.lossyScale;



            newFingerPose.CopyTo(fingerPoses, 0);
        }

        internal void SetPositionData(Transform handPoint, Transform relativeTo) {
            if(relativeTo != null) {
                handOffset = relativeTo.InverseTransformPoint(handPoint.position);
                localQuaternionOffset = Quaternion.Inverse(relativeTo.rotation) * handPoint.rotation;
                globalHandScale = handPoint.lossyScale;
            }
            else {
                handOffset = Vector3.zero;
                localQuaternionOffset = Quaternion.identity;
                globalHandScale = Vector3.one;
            }
        }
    }






    public static class HandPoseExtentions {
        public static HandPoseData GetApproximateHandPose(this HandPoseData approximatePose, Hand hand, HandPoseData matchPose, Matrix4x4 offset) {

            approximatePose.handOffset = hand.transform.position;
            approximatePose.localQuaternionOffset = hand.transform.rotation;
            matchPose.localQuaternionOffset = hand.transform.rotation;
            matchPose.handOffset = hand.transform.position;

            Matrix4x4 handToWorld = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, approximatePose.globalHandScale);
            Matrix4x4 otherHandToWorld = Matrix4x4.TRS(AutoHandExtensions.ExtractPosition(ref offset), AutoHandExtensions.ExtractRotation(ref offset), matchPose.globalHandScale);

            FingerPoseData highPose = new FingerPoseData(hand, hand.fingers[0]);
            FingerPoseData lowPose = new FingerPoseData(ref highPose);

            FingerPoseData highLerpPose = new FingerPoseData(ref highPose);
            FingerPoseData lowLerpPose = new FingerPoseData(ref highPose);
            FingerPoseData targetPose = new FingerPoseData(ref highPose);

            //Initial Open Hand Pose
            foreach(var finger in hand.fingers) {
                targetPose.CopyFromData(ref matchPose.fingerPoses[(int)finger.fingerType]);
                FingerPoseData[] fingerPoses = { finger.poseData[(int)FingerPoseEnum.Open], finger.poseData[(int)FingerPoseEnum.PinchOpen] };

                int closestPoseIndex1 = -1;
                int closestPoseIndex2 = -1;
                float closestBlendValue = float.MaxValue;
                float closestPoseValue = float.MaxValue;

                for(int i = 0; i < fingerPoses.Length; i++) { 
                    var pose1 = fingerPoses[i];
                    highPose.CopyFromData(ref pose1);
                    lowPose.CopyFromData(ref pose1);

                    for(int j = i; j < fingerPoses.Length; j++) {
                        if(i == j)
                            continue;

                        var pose2 = fingerPoses[j];
                        float low = 0f;
                        float high = 1f;

                        for(int k = 0; k < 8; k++) {
                            float mid = (low + high) / 2f;

                            highLerpPose.CopyFromData(ref pose2);
                            highLerpPose.LerpDataTo(ref highPose, high);
                            float highValue = GetFingerPoseDistanceDifferenceValue(targetPose, highLerpPose, otherHandToWorld, handToWorld);

                            lowLerpPose.CopyFromData(ref pose2);
                            lowLerpPose.LerpDataTo(ref lowPose, low);
                            float lowValue = GetFingerPoseDistanceDifferenceValue(targetPose, lowLerpPose, otherHandToWorld, handToWorld);

                            if(highValue < lowValue) {
                                low = mid;
                                if(highValue < closestPoseValue) {
                                    closestBlendValue = high;
                                    closestPoseValue = highValue;
                                    closestPoseIndex1 = i;
                                    closestPoseIndex2 = j;
                                }
                            }
                            else {
                                high = mid;
                                if(lowValue < closestPoseValue) {
                                    closestBlendValue = low;
                                    closestPoseValue = lowValue;
                                    closestPoseIndex1 = i;
                                    closestPoseIndex2 = j;
                                }
                            }
                        }
                    }
                }

                highPose.CopyFromData(ref fingerPoses[closestPoseIndex2]);
                lowPose.CopyFromData(ref fingerPoses[closestPoseIndex1]);
                highPose.LerpDataTo(ref lowPose, closestBlendValue);
                approximatePose.fingerPoses[(int)finger.fingerType].CopyFromData(ref highPose);
            }


            return approximatePose;



            float GetFingerPoseDistanceDifferenceValue(FingerPoseData currentPose, FingerPoseData targetPose, Matrix4x4 currentLocalToWorld, Matrix4x4 targetOffset) {
                float value = 0;


                Matrix4x4 kuckleToHandMatrix = currentPose.poseRelativeMatrix[(int)FingerJointEnum.knuckle];
                Matrix4x4 middleToKnuckleMatrix = currentPose.poseRelativeMatrix[(int)FingerJointEnum.middle];

                Matrix4x4 knuckleGlobalMatrix = currentLocalToWorld * kuckleToHandMatrix;
                Matrix4x4 middleGlobalMatrix = knuckleGlobalMatrix * middleToKnuckleMatrix;

                Vector3 knuckleCurrentPosition = AutoHandExtensions.ExtractPosition(ref knuckleGlobalMatrix);
                Vector3 middleCurrentPosition = AutoHandExtensions.ExtractPosition(ref middleGlobalMatrix);

                kuckleToHandMatrix = targetPose.poseRelativeMatrix[(int)FingerJointEnum.knuckle];
                middleToKnuckleMatrix = targetPose.poseRelativeMatrix[(int)FingerJointEnum.middle];

                knuckleGlobalMatrix = targetOffset * kuckleToHandMatrix;
                middleGlobalMatrix = knuckleGlobalMatrix * middleToKnuckleMatrix;

                Vector3 knuckleTargetPosition = AutoHandExtensions.ExtractPosition(ref knuckleGlobalMatrix);
                Vector3 middleTargetPosition = AutoHandExtensions.ExtractPosition(ref middleGlobalMatrix);

                value += Vector3.Distance(middleCurrentPosition, middleTargetPosition);

                return value;
            }
        }

        public static Matrix4x4 ApproximateOffsetMatrix(this HandPoseData fromPose, HandPoseData poseData) {

            Vector3[] localKnucklePositions = new Vector3[5];
            localKnucklePositions[0] = AutoHandExtensions.ExtractPosition(ref fromPose.fingerPoses[(int)FingerEnum.thumb].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            localKnucklePositions[1] = AutoHandExtensions.ExtractPosition(ref fromPose.fingerPoses[(int)FingerEnum.index].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            localKnucklePositions[2] = AutoHandExtensions.ExtractPosition(ref fromPose.fingerPoses[(int)FingerEnum.middle].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            localKnucklePositions[3] = AutoHandExtensions.ExtractPosition(ref fromPose.fingerPoses[(int)FingerEnum.ring].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            localKnucklePositions[4] = AutoHandExtensions.ExtractPosition(ref fromPose.fingerPoses[(int)FingerEnum.pinky].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);

            Vector3[] globalKnucklePositions = new Vector3[5];
            var handToWorld = fromPose.GetHandToWorldMatrix(null);
            globalKnucklePositions[0] = handToWorld*localKnucklePositions[0];
            globalKnucklePositions[1] = handToWorld*localKnucklePositions[1];
            globalKnucklePositions[2] = handToWorld*localKnucklePositions[2];
            globalKnucklePositions[3] = handToWorld*localKnucklePositions[3];
            globalKnucklePositions[4] = handToWorld*localKnucklePositions[4];

            Vector3[] otherLocalKnucklePositions = new Vector3[5];
            otherLocalKnucklePositions[0] = AutoHandExtensions.ExtractPosition(ref poseData.fingerPoses[(int)FingerEnum.thumb].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            otherLocalKnucklePositions[1] = AutoHandExtensions.ExtractPosition(ref poseData.fingerPoses[(int)FingerEnum.index].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            otherLocalKnucklePositions[2] = AutoHandExtensions.ExtractPosition(ref poseData.fingerPoses[(int)FingerEnum.middle].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            otherLocalKnucklePositions[3] = AutoHandExtensions.ExtractPosition(ref poseData.fingerPoses[(int)FingerEnum.ring].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            otherLocalKnucklePositions[4] = AutoHandExtensions.ExtractPosition(ref poseData.fingerPoses[(int)FingerEnum.pinky].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);


            Vector3[] otherGlobalKnucklePositions = new Vector3[5];
            handToWorld = poseData.GetHandToWorldMatrix(null);
            otherGlobalKnucklePositions[0] = handToWorld*otherLocalKnucklePositions[0];
            otherGlobalKnucklePositions[1] = handToWorld*otherLocalKnucklePositions[1];
            otherGlobalKnucklePositions[2] = handToWorld*otherLocalKnucklePositions[2];
            otherGlobalKnucklePositions[3] = handToWorld*otherLocalKnucklePositions[3];
            otherGlobalKnucklePositions[4] = handToWorld*otherLocalKnucklePositions[4];

            Vector3[] array1 = new Vector3[4];
            Vector3[] array2 = new Vector3[4];
            array1[0] = globalKnucklePositions[1] - globalKnucklePositions[0];
            array1[1] = globalKnucklePositions[2] - globalKnucklePositions[1];
            array1[2] = globalKnucklePositions[3] - globalKnucklePositions[2];
            array1[3] = globalKnucklePositions[4] - globalKnucklePositions[3];
            array2[0] = otherGlobalKnucklePositions[1] - otherGlobalKnucklePositions[0];
            array2[1] = otherGlobalKnucklePositions[2] - otherGlobalKnucklePositions[1];
            array2[2] = otherGlobalKnucklePositions[3] - otherGlobalKnucklePositions[2];
            array2[3] = otherGlobalKnucklePositions[4] - otherGlobalKnucklePositions[3];

            Plane fromHandPlane = new Plane(globalKnucklePositions[0], globalKnucklePositions[1], globalKnucklePositions[2]);
            Plane otherHandPlane = new Plane(otherGlobalKnucklePositions[0], otherGlobalKnucklePositions[1], otherGlobalKnucklePositions[2]);

            Vector3 normal1 = fromHandPlane.normal;
            Vector3 normal2 = otherHandPlane.normal;

            var rotationOffset = Quaternion.FromToRotation(normal1, normal2);
            var localToWorld = Matrix4x4.TRS(Vector3.zero, rotationOffset, Vector3.one);

            //This will rotate the hand around the normal of the plane until the localToWorld matrix is as close as possible to the other hand
            //We will use binary search principle along that normal axis to find the best rotation with as few iterations as possible

            Quaternion[] quaternionOffset = new Quaternion[3];
            quaternionOffset[0] = Quaternion.Euler(90, 0, 0);
            quaternionOffset[1] = Quaternion.Euler(0, 90, 0);
            quaternionOffset[2] = Quaternion.Euler(0, 0, 90);

            for(int q = 0; q < quaternionOffset.Length; q++) {
                float closestDistance = CompareVector3ArrayCross(array1, array2, localToWorld);
                float closestAngle = -1;
                var rotation = quaternionOffset[q];
                var normal = rotation * normal1;
                var high = 359;
                var low = 0;

                for(int i = 0; i < 9; i++) {
                    var mid = (high + low) / 2;
                    var highRotation = Quaternion.AngleAxis(high, normal);
                    var lowRotation = Quaternion.AngleAxis(low, normal);

                    var lowDistance = CompareVector3ArrayCross(array1, array2, localToWorld * Matrix4x4.Rotate(lowRotation));
                    var highDistance = CompareVector3ArrayCross(array1, array2, localToWorld * Matrix4x4.Rotate(highRotation));

                    if(lowDistance < closestDistance) {
                        closestDistance = lowDistance;
                        closestAngle = low;
                        high = mid;
                    }

                    if(highDistance < closestDistance) {
                        closestDistance = highDistance;
                        closestAngle = high;
                        low = mid;
                    }
                }


                if(closestAngle != -1) {
                    var rotationAdjustment = Quaternion.AngleAxis(closestAngle, normal);
                    localToWorld = localToWorld * Matrix4x4.Rotate(rotationAdjustment);
                    normal1 = rotationAdjustment * normal1;
                }
            }


            Vector3[] directions = new Vector3[] { Vector3.right, Vector3.up, Vector3.forward, Vector3.right, Vector3.up, Vector3.forward };

            var directionMagnitude = 0f;
            for(int i = 0; i < globalKnucklePositions.Length; i++) {
                var newDirectionMagnitude = Vector3.Distance(globalKnucklePositions[i], otherGlobalKnucklePositions[i]);
                if(directionMagnitude < newDirectionMagnitude) {
                    directionMagnitude = newDirectionMagnitude;
                }
            }


            foreach(var direction in directions) {
                float minDistance = -1;
                float maxDistance = 1;
                float midDistance = 0f;
                float closestDistance = float.MaxValue;

                for(int i = 0; i < 10; i++){
                    midDistance = (minDistance + maxDistance) / 2f;
                    Vector3 minDirection = minDistance * direction;
                    Vector3 maxDirection = maxDistance * direction;

                    float minDistanceResult = CompareVector3ArrayDistance(globalKnucklePositions, otherGlobalKnucklePositions, localToWorld * Matrix4x4.Translate(minDirection));
                    float maxDistanceResult = CompareVector3ArrayDistance(globalKnucklePositions, otherGlobalKnucklePositions, localToWorld * Matrix4x4.Translate(maxDirection));

                    if(minDistanceResult < maxDistanceResult) {
                        if(minDistanceResult < closestDistance) {
                            closestDistance = minDistanceResult;
                        }
                        maxDistance = midDistance;
                    }
                    else {
                        if(maxDistanceResult < closestDistance) {
                            closestDistance = maxDistanceResult;
                        }
                        minDistance = midDistance;
                    }
                }

                localToWorld = localToWorld*Matrix4x4.Translate(midDistance * direction);
            }




            for(int q = 0; q < quaternionOffset.Length; q++) {
                float closestDistance = CompareVector3ArrayCross(array1, array2, localToWorld);
                float closestAngle = -1;
                var rotation = quaternionOffset[q];
                var normal = rotation * normal1;
                var high = 359;
                var low = 0;

                for(int i = 0; i < 9; i++) {
                    var mid = (high + low) / 2;
                    var highRotation = Quaternion.AngleAxis(high, normal);
                    var lowRotation = Quaternion.AngleAxis(low, normal);

                    var lowDistance = CompareVector3ArrayCross(array1, array2, localToWorld * Matrix4x4.Rotate(lowRotation));
                    var highDistance = CompareVector3ArrayCross(array1, array2, localToWorld * Matrix4x4.Rotate(highRotation));

                    if(lowDistance < closestDistance) {
                        closestDistance = lowDistance;
                        closestAngle = low;
                        high = mid;
                    }

                    if(highDistance < closestDistance) {
                        closestDistance = highDistance;
                        closestAngle = high;
                        low = mid;
                    }
                }


                if(closestAngle != -1) {
                    var rotationAdjustment = Quaternion.AngleAxis(closestAngle, normal);
                    localToWorld = localToWorld * Matrix4x4.Rotate(rotationAdjustment);
                    normal1 = rotationAdjustment * normal1;
                }
            }


            return localToWorld;
        }

        public static float CompareVector3ArrayCross(Vector3[] target, Vector3[] offset, Matrix4x4 localToWorld) {
            float value = 0;

            for(int i = 0; i < target.Length; i++) {
                var targetPosition = target[i];
                var offsetPosition = offset[i];

                var localPosition = localToWorld.MultiplyPoint3x4(offsetPosition);
                float dotProduct = Vector3.Dot(targetPosition, localPosition);
                value += (1 - dotProduct) / 2f;
            }

            return value;
        }

        public static float CompareVector3ArrayDistance(Vector3[] target, Vector3[] offset, Matrix4x4 localToWorld) {
            float value = 0;

            for(int i = 0; i < target.Length; i++) {
                var targetPosition = target[i];
                var offsetPosition = offset[i];

                var localPosition = localToWorld.MultiplyPoint3x4(offsetPosition);
                float distance = Vector3.Distance(targetPosition, localPosition);
                value += distance;
            }

            return value;
        }
    }


}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandPoseData.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandPoseScriptable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6f9629acaf41af8408d8406e0816e2c0
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand
{
    [CreateAssetMenu(fileName = "AutoHand Pose", menuName = "Auto Hand/Custom Pose", order = 1)]
    public class HandPoseScriptable : ScriptableObject{
        [HideInInspector]
        public bool rightSaved;
        [HideInInspector]
        public bool leftSaved;
        public HandPoseData rightPose;
        public HandPoseData leftPose;

        public void SavePoses(HandPoseData right, HandPoseData left)
        {
            SaveRightPose(right);
            SaveLeftPose(left);
        }

        public void SaveRightPose(HandPoseData right)
        {
            rightPose = new HandPoseData(ref right);
            rightSaved = true;
#if UNITY_EDITOR
            UnityEditor.EditorUtility.SetDirty(this);
#endif
        }

        public void SaveLeftPose(HandPoseData left)
        {
            leftPose = new HandPoseData(ref left);
            leftSaved = true;
#if UNITY_EDITOR
            UnityEditor.EditorUtility.SetDirty(this);
#endif
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandPoseScriptable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandStabilizer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f820a3019d6fa6d49a0813bc55bba9c0
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

namespace Autohand{
    //This script is used to hide rigidbody physics instabilitites by
    //putting the hand where it visually should be on prerender
    //and putting it where it physically should be on post render
    [DefaultExecutionOrder(int.MaxValue)]
    public class HandStabilizer : MonoBehaviour{
        public HandBase hand = null;

        void Start(){
            if (!GetComponent<Camera>().enabled || hand == null)
                enabled = false;
        }

        void OnEnable(){
            if(GraphicsSettings.defaultRenderPipeline != null){
                RenderPipelineManager.beginContextRendering += OnPreRenderEvent;
                RenderPipelineManager.endContextRendering += OnPostRenderEvent;
                RenderPipelineManager.beginCameraRendering += OnPreRenderEvent;
                RenderPipelineManager.endCameraRendering += OnPostRenderEvent;
            }
        }

        void OnDisable(){
            if(GraphicsSettings.defaultRenderPipeline != null){
                RenderPipelineManager.beginContextRendering -= OnPreRenderEvent;
                RenderPipelineManager.endContextRendering -= OnPostRenderEvent;
                RenderPipelineManager.beginCameraRendering -= OnPreRenderEvent;
                RenderPipelineManager.endCameraRendering -= OnPostRenderEvent;
            }
        }

        private void Update() {
            if(hand == null)
                Destroy(this);
        }

        private void OnWillRenderObject() {
            if(hand != null && hand.gameObject.activeInHierarchy)
                hand.OnWillRenderObject();
        }

        private void OnPreRender() {
            if(hand != null && hand.gameObject.activeInHierarchy)
                hand.OnWillRenderObject();
        }

        private void OnPostRender() {
            if(hand != null && hand.gameObject.activeInHierarchy)
                hand.OnPostRender();
        }



        private void OnPreRenderEvent(ScriptableRenderContext context, List<Camera> cameras) {
            if(hand != null && hand.gameObject.activeInHierarchy)
                hand.OnWillRenderObject();
        }
        private void OnPreRenderEvent(ScriptableRenderContext context, Camera cam) {
            if(hand != null && hand.gameObject.activeInHierarchy)
                hand.OnWillRenderObject();
        }
        private void OnPostRenderEvent(ScriptableRenderContext context, Camera cam) {
            if(hand != null && hand.gameObject.activeInHierarchy)
                hand.OnPostRender();
        }

        private void OnPostRenderEvent(ScriptableRenderContext context, List<Camera> cameras) {
            if(hand != null && hand.gameObject.activeInHierarchy)
                hand.OnPostRender();
        }
        
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandStabilizer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandVelocityTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bc13386119009a34bb92919fb31f8f9f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HandVelocityTracker {
        HandBase hand = null;
        float minThrowVelocity = 0f;

        ///<summary> A list of all acceleration values from the time the throwing motion was detected til now.</summary>
        protected List<VelocityTimePair> m_ThrowVelocityList = new List<VelocityTimePair>();
        protected List<VelocityTimePair> m_ThrowAngleVelocityList = new List<VelocityTimePair>();

        public void ClearThrow() {
            m_ThrowVelocityList.Clear();
            m_ThrowAngleVelocityList.Clear();
        }

        float disableTime;
        float disableSeconds;
        public void Disable(float seconds) {
            disableTime = Time.realtimeSinceStartup;
            disableSeconds = seconds;
            ClearThrow();
        }

        public HandVelocityTracker(HandBase hand) {
            this.hand = hand;
        }


        public void UpdateThrowing() {
            if(disableTime + disableSeconds > Time.realtimeSinceStartup) {
                if(m_ThrowVelocityList.Count > 0) {
                    m_ThrowVelocityList.Clear();
                    m_ThrowAngleVelocityList.Clear();
                }
                return;
            }

            if(hand.holdingObj == null || hand.IsGrabbing()) {
                if(m_ThrowVelocityList.Count > 0) {
                    m_ThrowVelocityList.Clear();
                    m_ThrowAngleVelocityList.Clear();
                }

                return;
            }

            // Add current hand velocity to throw velocity list.
            m_ThrowVelocityList.Add(new VelocityTimePair() { time = Time.realtimeSinceStartup, velocity = hand.holdingObj.body == null ? Vector3.zero : hand.holdingObj.body.linearVelocity });

            // Remove old entries from m_ThrowVelocityList.
            for(int i = m_ThrowVelocityList.Count - 1; i >= 0; --i) {
                if(Time.realtimeSinceStartup - m_ThrowVelocityList[i].time >= hand.throwVelocityExpireTime) {
                    // Remove expired entry.
                    m_ThrowVelocityList.RemoveAt(i);
                }
            }

            // Add current hand velocity to throw velocity list.
            m_ThrowAngleVelocityList.Add(new VelocityTimePair() { time = Time.realtimeSinceStartup, velocity = hand.holdingObj.body == null ? Vector3.zero : hand.holdingObj.body.angularVelocity });

            // Remove old entries from m_ThrowVelocityList.
            for(int i = m_ThrowAngleVelocityList.Count - 1; i >= 0; --i) {
                if(Time.realtimeSinceStartup - m_ThrowAngleVelocityList[i].time >= hand.throwAngularVelocityExpireTime) {
                    // Remove expired entry.
                    m_ThrowAngleVelocityList.RemoveAt(i);
                }
            }
        }

        /// <summary>Returns the hands velocity times its strength</summary>
        public Vector3 ThrowVelocity() {
            if(hand.IsGrabbing() || hand.holdingObj == null)
                return Vector3.zero;

            // Calculate the average hand velocity over the course of the throw.
            Vector3 averageVelocity = Vector3.zero;
            if(m_ThrowVelocityList.Count > 0) {
                foreach(VelocityTimePair pair in m_ThrowVelocityList) {
                    averageVelocity += pair.velocity;
                }
                averageVelocity /= m_ThrowVelocityList.Count;
            }

            var vel = averageVelocity * hand.holdingObj.throwPower;

            return vel.magnitude > minThrowVelocity ? vel : Vector3.zero;
        }

        /// <summary>Returns the hands velocity times its strength</summary>
        public Vector3 ThrowAngularVelocity() {
            if(hand.IsGrabbing() || hand.holdingObj == null)
                return Vector3.zero;

            // Calculate the average hand velocity over the course of the throw.
            Vector3 averageVelocity = Vector3.zero;
            if(m_ThrowAngleVelocityList.Count > 0) {
                foreach(VelocityTimePair pair in m_ThrowAngleVelocityList) {
                    averageVelocity += pair.velocity;
                }
                averageVelocity /= m_ThrowAngleVelocityList.Count;
            }

            averageVelocity *= Mathf.Sqrt(hand.throwPower) / 2f;

            return averageVelocity.magnitude > minThrowVelocity ? averageVelocity : Vector3.zero; ;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandVelocityTracker.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/IGrabbableEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8591546fd0fd6ca468c64a608b092140
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public interface IGrabbableEvents {


        void OnHighlight(Hand hand);

        void OnUnhighlight(Hand hand);

        void OnGrab(Hand hand);

        void OnRelease(Hand hand);

        public bool CanGrab(Hand hand);

        Grabbable GetGrabbable();
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/IGrabbableEvents.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/KeyboardHand.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ade8508f9cb7c1d439cf94e9cada134b
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand
{
    public class KeyboardHand : MonoBehaviour
    {
        public Hand hand;
        public float speed = 1;
        public float flySpeed = 1;
        public bool useLocal = true;

        void Update() {
            float yMove = 0;

            if(Input.GetKey(KeyCode.Space))
                yMove = 1;

            if(Input.GetKey(KeyCode.LeftShift))
                yMove = -1;

            if(Input.GetKey(KeyCode.E))
                transform.Rotate(new Vector3(speed * 90 * Time.deltaTime, 0, 0));

            if(Input.GetKey(KeyCode.Q))
                transform.Rotate(new Vector3(-speed * 90 * Time.deltaTime, 0, 0));


            if(useLocal) {
                Vector3 move = new Vector3(yMove * flySpeed, -Input.GetAxis("Horizontal") * speed, Input.GetAxis("Vertical") * speed);
                transform.position += transform.rotation * move * Time.deltaTime;
            }
            else {
                Vector3 move = new Vector3(Input.GetAxis("Horizontal") * speed, yMove * flySpeed, Input.GetAxis("Vertical") * speed);
                transform.position += move * Time.deltaTime;
            }
            if(Input.GetKeyDown(KeyCode.Mouse0))
                hand.Grab();

            if(Input.GetKeyUp(KeyCode.Mouse0))
                hand.Release();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/KeyboardHand.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedJointDrive.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b71188a7ea1430a4189ce11c2e783d7e
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;

[System.Serializable]
public class SerializedJointDrive {
    private JointDrive struc = new JointDrive();

    public static implicit operator JointDrive(SerializedJointDrive c) {
        return new JointDrive() { positionSpring = c._spring, positionDamper = c._damper, maximumForce = c._maxForce };
    }
    public static explicit operator SerializedJointDrive(JointDrive c) {
        return new SerializedJointDrive(c);
    }

    public SerializedJointDrive() { }
    private SerializedJointDrive(JointDrive _data) {
        this.damper = _data.positionDamper;
        this.spring = _data.positionSpring;
        this._maxForce = _data.maximumForce;
    }

    [SerializeField]
    private float _spring = 0;
    [SerializeField]
    private float _damper = 0;
    [SerializeField]
    private float _maxForce = 1000;

    public float damper { get { return struc.positionDamper; } set { _damper = struc.positionDamper = value; } }
    public float spring { get { return struc.positionSpring; } set { _spring = struc.positionSpring = value; } }
    public float maxForce { get { return struc.positionSpring; } set { _spring = struc.positionSpring = value; } }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedJointDrive.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedSoftJointLimit.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f37852b160323da458da84a978e07a54
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;

[System.Serializable]
public class SerializedSoftJointLimit {
    private SoftJointLimit struc = new SoftJointLimit();
    public static implicit operator SoftJointLimit(SerializedSoftJointLimit c) {
        return new SoftJointLimit() { limit = c._limit, bounciness = c._bounciness, contactDistance = c._contactDistance };
    }
    public static explicit operator SerializedSoftJointLimit(SoftJointLimit c) {
        return new SerializedSoftJointLimit(c);
    }
    public SerializedSoftJointLimit() { }
    private SerializedSoftJointLimit(SoftJointLimit _data) {
        this.limit = _data.limit;
        this.bounciness = _data.bounciness;
        this.contactDistance = _data.contactDistance;
    }
    [SerializeField]
    private float _limit = 0;
    [SerializeField]
    private float _bounciness = 0;
    [SerializeField]
    private float _contactDistance = 0;

    public float limit { get { return struc.limit; } set { _limit = struc.limit = value; } }
    public float bounciness { get { return struc.bounciness; } set { _bounciness = struc.bounciness = value; } }
    public float contactDistance { get { return struc.contactDistance; } set { _contactDistance = struc.contactDistance = value; } }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedSoftJointLimit.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedSoftJointLimitSpring.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cdbdf138596bf63448e3b8cca5e3640d
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;

[System.Serializable]
public class SerializedSoftJointLimitSpring {
    private SoftJointLimitSpring struc = new SoftJointLimitSpring();

    public static implicit operator SoftJointLimitSpring(SerializedSoftJointLimitSpring c) {
        return new SoftJointLimitSpring() { spring = c._spring, damper = c._damper };
    }
    public static explicit operator SerializedSoftJointLimitSpring(SoftJointLimitSpring c) {
        return new SerializedSoftJointLimitSpring(c);
    }

    public SerializedSoftJointLimitSpring() { }
    private SerializedSoftJointLimitSpring(SoftJointLimitSpring _data) {
        this.damper = _data.damper;
        this.spring = _data.spring;
    }

    [SerializeField]
    private float _spring = 0;
    [SerializeField]
    private float _damper = 0;

    public float damper { get { return struc.damper; } set { _damper = struc.damper = value; } }
    public float spring { get { return struc.spring; } set { _spring = struc.spring = value; } }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedSoftJointLimitSpring.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/AutoHandPlayer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d8a35128610d1b34892726ec96e587d0
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Autohand.Demo;
using System;
using NaughtyAttributes;
using UnityEngine.Serialization;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Autohand {
    public enum RotationType {
        snap,
        smooth
    }

    public delegate void AutoHandPlayerEvent(AutoHandPlayer player);

    [RequireComponent(typeof(Rigidbody)), RequireComponent(typeof(CapsuleCollider)), DefaultExecutionOrder(1)]
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand-3.1/auto-hand-player")]
    public class AutoHandPlayer : MonoBehaviour {

        static bool notFound = false;
        public static AutoHandPlayer _Instance;
        public static AutoHandPlayer Instance {
            get {
                if(_Instance == null && !notFound)
                    _Instance = AutoHandExtensions.CanFindObjectOfType<AutoHandPlayer>();

                if(_Instance == null)
                    notFound = true;

                return _Instance;
            }
        }



        [AutoHeader("Auto Hand Player")]
        public bool ignoreMe;



        [Tooltip("The tracked headCamera object")]
        public Camera headCamera;
        [Tooltip("The object that represents the forward direction movement, usually should be set as the camera or a tracked controller")]
        public Transform forwardFollow;
        [Tooltip("This should NOT be a child of this body. This should be a GameObject that contains all the tracked objects (head/controllers)")]
        public Transform trackingContainer;
        public Hand handRight;
        public Hand handLeft;



        [AutoToggleHeader("Movement")]
        public bool useMovement = true;
        [EnableIf("useMovement"), FormerlySerializedAs("moveSpeed")]
        [Tooltip("Movement speed when isGrounded")]
        public float maxMoveSpeed = 2.3f;
        [EnableIf("useMovement")]
        [Tooltip("Movement acceleration when isGrounded")]
        public float moveAcceleration = 100000f;
        [EnableIf("useMovement")]
        [Tooltip("Whether or not to use snap turning or smooth turning"), Min(0)]
        public RotationType rotationType =  RotationType.snap;
        [Tooltip("turn speed when not using snap turning - if snap turning, represents angle per snap")]
        public float snapTurnAngle = 30f;
        public float smoothTurnSpeed = 180f;
        public bool bodyFollowsHead = true;
        public float maxHeadDistance = 0.5f;
        public bool useSmoothStep = false;
        [ShowIf("useSmoothStep")]
        [Tooltip("How quickly to smooth step up/down when stepping onto a surface.")]
        public float stepSmoothSpeed = 6f;



        [AutoToggleHeader("Height")]
        public bool showHeight = true;
        [ShowIf("showHeight"), Tooltip("Smooths camera upward movement when stepping up")]
        public float heightSmoothSpeed = 10f;
        [ShowIf("showHeight")]
        public float heightOffset = 0f;
        [ShowIf("showHeight")]
        public bool crouching = false;
        [ShowIf("showHeight")]
        public float crouchHeight = 0.6f;
        [ShowIf("showHeight")]
        [Tooltip("Whether or not the capsule height should be adjusted to match the headCamera height")]
        public bool autoAdjustColliderHeight = true;
        [ShowIf("showHeight")]
        [Tooltip("Minimum and maximum auto adjusted height, to adjust height without auto adjustment change capsule collider height instead")]
        public Vector2 minMaxHeight = new Vector2(0.5f, 2.5f);
        [ShowIf("showHeight")]
        public bool useHeadCollision = true;
        [ShowIf("showHeight")]
        public float headRadius = 0.15f;




        [AutoToggleHeader("Use Grounding")]
        public bool useGrounding = true;
        [EnableIf("useGrounding"), Tooltip("Maximum height that the body can step up onto"), Min(0)]
        public float maxStepHeight = 0.3f;
        [Tooltip("The space between the bottom of the body and the spherecast the checks for the ground and steps")]
        public float groundingPenetrationOffset = 0.1f;
        [EnableIf("useGrounding"), Tooltip("Maximum angle the player can walk on"), Min(0)]
        public float maxStepAngle = 45f;
        [EnableIf("useGrounding"), Tooltip("The layers that count as ground")]
        public LayerMask groundLayerMask;
        [EnableIf("useGrounding"), Tooltip("Movement acceleration when isGrounded")]
        public float groundedDrag = 10000f;
        [Tooltip("Movement acceleration when grounding is disabled")]
        public float flyingDrag = 4f;



        [AutoToggleHeader("Enable Climbing")]
        [Tooltip("Whether or not the player can use Climbable objects  (Objects with the Climbable component)")]
        public bool allowClimbing = true;
        [Tooltip("Whether or not the player move while climbing")]
        [ShowIf("allowClimbing")]
        public bool allowClimbingMovement = true;
        [Tooltip("How quickly the player can climb")]
        [ShowIf("allowClimbing")]
        public Vector3 climbingStrength = new Vector3(20f, 20f, 20f);
        public float climbingAcceleration = 30f;
        public float climbingDrag = 5f;
        [Tooltip("Inscreases the step height while climbing up to make it easier to step up onto a surface")]
        public float climbUpStepHeightMultiplier = 3f;



        [AutoToggleHeader("Enable Pushing")]
        [Tooltip("Whether or not the player can use Pushable objects (Objects with the Pushable component)")]
        public bool allowBodyPushing = true;
        [Tooltip("How quickly the player can climb")]
        [EnableIf("allowBodyPushing")]
        public Vector3 pushingStrength = new Vector3(10f, 10f, 10f);
        public float pushingAcceleration = 10f;
        public float pushingDrag = 1f;
        [Tooltip("Inscreases the step height while pushing up to make it easier to step up onto a surface")]
        public float pushUpStepHeightMultiplier = 3f;



        [AutoToggleHeader("Enable Platforming")]
        [Tooltip("Platforms will move the player with them. A platform is an object with the Transform component on it")]
        public bool allowPlatforms = true;
        [EnableIf("useGrounding"), Tooltip("The layers that platforming will be enabled on, will not work with layers that the HandPlayer can't collide with")]
        public LayerMask platformingLayerMask = ~0;


        public AutoHandPlayerEvent OnSnapTurn;
        public AutoHandPlayerEvent OnSmoothTurn;
        public AutoHandPlayerEvent OnTeleported;


        [HideInInspector]
        /// <summary>Amount of input required to trigger movement, some vr controllers will return > 0.1 input when not touching the thumbsticks so using a deadzone to prevent movement drift</summary>
        public float movementDeadzone = 0.2f;
        [HideInInspector]
        /// <summary>Amount of input required to trigger a turn, some vr controllers will return > 0.1 input when not touching the thumbsticks so using a deadzone of 0.35 or higher is important</summary>
        public float turnDeadzone = 0.4f;
        [HideInInspector]
        /// <summary>Amount of input required to reset the turn state for snap turning</summary>
        public float turnResetzone = 0.3f;


        //How many times the head will attempt to move the body to the head and depenetrate it from colliders in a single frame,
        //this value uses nested loop so the actual iterations will be 2^bodySyncMaxIterations. Recommended value of 2-4
        const int bodySyncMaxIterations = 2;
        //How many times the head will attempt to depenetrate from colliders in a single frame. Recommended value of 3-8
        const int headCollisionMaxIterations = 4;

        public const string HandPlayerLayer = "HandPlayer";

        public CapsuleCollider bodyCollider { get { return bodyCapsule; } }

        public Rigidbody body { get; protected set; }

        public RaycastHit lastGroundHit { get; protected set; }









        protected HeadPhysicsFollower headPhysicsFollower;
        protected Vector3 moveDirection;
        protected float turningAxis;

        protected Vector3 climbAxis;
        protected Dictionary<Hand, Climbable> climbing = new Dictionary<Hand, Climbable>();

        protected Vector3 pushAxis;
        protected Dictionary<Pushable, Hand> pushRight = new Dictionary<Pushable, Hand>();
        protected Dictionary<Pushable, int> pushRightCount = new Dictionary<Pushable, int>();
        protected Dictionary<Pushable, Hand> pushLeft = new Dictionary<Pushable, Hand>();
        protected Dictionary<Pushable, int> pushLeftCount = new Dictionary<Pushable, int>();

        protected CapsuleCollider bodyCapsule;
        protected Hand lastRightHand;
        protected Hand lastLeftHand;
        protected Collider[] colliderNonAlloc = new Collider[128];

        protected bool trackingStarted = false;
        protected bool isGrounded = false;
        protected bool axisReset = true;
        protected bool tempDisableGrounding = false;
        protected bool lastCrouching;
        protected float lastCrouchingHeight;
        protected float playerHeight;
        protected Vector3 lastUpdatePosition;
        protected Vector3 lastHeadPos;

        protected Vector3 targetTrackedPos;
        protected Vector3 targetPosOffset;
        Vector3 lastPlatformPosition;
        Quaternion lastPlatformRotation;
        public RaycastHit lastPlatformingHit { get; protected set; }

        float headHeightOffset;
        float highestPoint;

        /// <summary>
        /// The layermask the player can collide with
        /// </summary>
        public int handPlayerMask { get; private set; }

        public virtual void Awake() {
            if(_Instance == null) {
                _Instance = this;
                notFound = false;
            }

            lastUpdatePosition = transform.position;

            gameObject.layer = LayerMask.NameToLayer(HandPlayerLayer);

            bodyCapsule = GetComponent<CapsuleCollider>();
            bodyCapsule.material = Resources.Load<PhysicsMaterial>("NoFriction");

            body = GetComponent<Rigidbody>();
            body.interpolation = RigidbodyInterpolation.None;
            body.freezeRotation = true;
            if(body.collisionDetectionMode == CollisionDetectionMode.Discrete)
                body.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;

            if(forwardFollow == null)
                forwardFollow = headCamera.transform;

            targetTrackedPos = trackingContainer.position;
            if(useHeadCollision)
                CreateHeadFollower();
        }


        public virtual void Start() {
            StartCoroutine(WaitFlagForTrackingStart());

            handPlayerMask = AutoHandExtensions.GetPhysicsLayerMask(gameObject.layer);
#if UNITY_EDITOR
                if (Selection.activeGameObject == gameObject)
                {
                    Selection.activeGameObject = null;
                    Debug.Log("Auto Hand: highlighting hand component in the inspector can cause lag and quality reduction at runtime in VR. (Automatically deselecting at runtime) Remove this code at any time.", this);
                    Application.quitting += () => { if (Selection.activeGameObject == null) Selection.activeGameObject = gameObject; };
                }

#endif
        }

        protected virtual void OnEnable() {
            EnableHand(handRight);
            EnableHand(handLeft);
        }

        protected virtual void OnDisable() {
            DisableHand(handRight);
            DisableHand(handLeft);
        }

        IEnumerator WaitFlagForTrackingStart() {
            yield return new WaitForEndOfFrame();
            yield return new WaitForFixedUpdate();
            lastHeadPos = headCamera.transform.position;
            while(!trackingStarted) {
                if(headCamera.transform.position != lastHeadPos)
                    trackingStarted = true;
                lastHeadPos = headCamera.transform.position;
                yield return new WaitForEndOfFrame();
            }
        }

        void CreateHeadFollower() {
            if(headPhysicsFollower == null) {
                var headFollower = new GameObject().transform;
                headFollower.transform.position = headCamera.transform.position;
                headFollower.name = "Head Follower";
                headFollower.parent = transform.parent;

                var col = headFollower.gameObject.AddComponent<SphereCollider>();
                col.material = bodyCapsule.material;
                col.radius = headRadius;

                var headBody = headFollower.gameObject.AddComponent<Rigidbody>();
                headBody.linearDamping = 5;
                headBody.angularDamping = 5;
                headBody.freezeRotation = false;
                headBody.useGravity = false;
                headBody.mass = body.mass / 3f;

                headPhysicsFollower = headFollower.gameObject.AddComponent<HeadPhysicsFollower>();
                headPhysicsFollower.headCamera = headCamera;
                headPhysicsFollower.followBody = transform;
                headPhysicsFollower.trackingContainer = trackingContainer;
                headPhysicsFollower.maxBodyDistance = maxHeadDistance;
                headPhysicsFollower.Init();
            }
        }



        void CheckHands() {
            if(lastLeftHand != handLeft) {
                DisableHand(lastLeftHand);
                EnableHand(handLeft);
                lastLeftHand = handLeft;
            }

            if(lastRightHand != handRight) {
                DisableHand(lastRightHand);
                EnableHand(handRight);
                lastRightHand = handRight;
            }
        }


        void EnableHand(Hand hand) {
            if(hand == null)
                return;

            hand.OnGrabbed += OnHandGrab;
            hand.OnReleased += OnHandRelease;


            if(allowClimbing) {
                hand.OnGrabbed += StartClimb;
                hand.OnReleased += EndClimb;
            }

            if(allowBodyPushing) {
                hand.OnGrabbed += StartGrabPush;
                hand.OnReleased += EndGrabPush;
                hand.OnHandCollisionStart += StartPush;
                hand.OnHandCollisionStop += StopPush;
            }
        }

        void DisableHand(Hand hand) {
            if(hand == null)
                return;

            hand.OnGrabbed -= OnHandGrab;
            hand.OnReleased -= OnHandRelease;

            if(allowClimbing) {
                hand.OnGrabbed -= StartClimb;
                hand.OnReleased -= EndClimb;
                if(climbing.ContainsKey(hand))
                    climbing.Remove(hand);
            }

            if(allowBodyPushing) {
                hand.OnGrabbed -= StartGrabPush;
                hand.OnReleased -= EndGrabPush;
                hand.OnHandCollisionStart -= StartPush;
                hand.OnHandCollisionStop -= StopPush;
                if(hand.left) {
                    pushLeft.Clear();
                    pushLeftCount.Clear();
                }
                else {
                    pushRight.Clear();
                    pushRightCount.Clear();
                }
            }
        }

        protected virtual void OnHandGrab(Hand hand, Grabbable grab) {
            grab.IgnoreColliders(bodyCapsule);
            if(headPhysicsFollower != null)
                grab.IgnoreColliders(headPhysicsFollower.headCollider);
        }

        protected virtual void OnHandRelease(Hand hand, Grabbable grab) {
            if(grab != null && grab.HeldCount() == 0) {
                grab.IgnoreColliders(bodyCapsule, false);
                if(headPhysicsFollower != null)
                    grab.IgnoreColliders(headPhysicsFollower.headCollider, false);

                if(grab && grab.parentOnGrab && grab.body != null && !grab.body.isKinematic)
                    grab.body.linearVelocity += body.linearVelocity / 2f;
            } 
        }

        public void IgnoreCollider(Collider col, bool ignore) {
            Physics.IgnoreCollision(bodyCapsule, col, ignore);
            Physics.IgnoreCollision(headPhysicsFollower.headCollider, col, ignore);
        }


        /// <summary>Sets move direction for this fixedupdate</summary>
        public virtual void Move(Vector2 axis, bool useDeadzone = true, bool useRelativeDirection = false) {
            moveDirection.x = (!useDeadzone || Mathf.Abs(axis.x) > movementDeadzone) ? axis.x : 0;
            moveDirection.z = (!useDeadzone || Mathf.Abs(axis.y) > movementDeadzone) ? axis.y : 0;
            if(useRelativeDirection)
                moveDirection = transform.rotation * moveDirection;
        }

        public virtual void Turn(float turnAxis) {
            turnAxis = (Mathf.Abs(turnAxis) > turnDeadzone) ? turnAxis : 0;
            turningAxis = turnAxis;
        }

        protected virtual void LateUpdate() {
            if(useMovement) {
                UpdateTrackedObjects();
                UpdateTurn(Time.deltaTime);
            }
        }

        protected virtual void FixedUpdate() {
            CheckHands();
            UpdatePlayerHeight();

            if(useMovement) {
                ApplyPushingForce();
                ApplyClimbingForce();
                UpdateRigidbody();
                UpdatePlatform();
                Ground();
            }
        }


        protected virtual void UpdateRigidbody() {
            var move = AlterDirection(moveDirection);
            var yVel = body.linearVelocity.y;

            //1. Moves velocity towards desired push direction
            if (pushAxis != Vector3.zero) {
                body.linearVelocity = Vector3.MoveTowards(body.linearVelocity, pushAxis, pushingAcceleration * Time.fixedDeltaTime);
                body.linearVelocity *= Mathf.Clamp01(1 - pushingDrag * Time.fixedDeltaTime);
            }

            //2. Moves velocity towards desired climb direction
            if(climbAxis != Vector3.zero) {
                body.linearVelocity = Vector3.MoveTowards(body.linearVelocity, climbAxis, climbingAcceleration * Time.fixedDeltaTime);
                body.linearVelocity *= Mathf.Clamp01(1 - climbingDrag * Time.fixedDeltaTime);
            }

            //3. Moves velocity towards desired movement direction
            if(move != Vector3.zero && CanInputMove()) {

                var newVel = Vector3.MoveTowards(body.linearVelocity, move * maxMoveSpeed, moveAcceleration * Time.fixedDeltaTime);
                if(newVel.magnitude > maxMoveSpeed)
                    newVel = newVel.normalized * maxMoveSpeed;
                body.linearVelocity = newVel;
            }

            //5. Checks if gravity should be turned off
            if (IsClimbing() || pushAxis.y > 0)
                body.useGravity = false;


            //4. This creates extra drag when grounded to simulate foot strength, or if flying greats drag in every direction when not moving
            if (move.magnitude <= movementDeadzone && isGrounded)
                body.linearVelocity *= (Mathf.Clamp01(1 - groundedDrag * Time.fixedDeltaTime));
            else if(!useGrounding)
                body.linearVelocity *= (Mathf.Clamp01(1 - flyingDrag * Time.fixedDeltaTime));

            //6. This will keep velocity if consistent when moving while falling
            if(body.useGravity)
                body.linearVelocity = new Vector3(body.linearVelocity.x, yVel, body.linearVelocity.z);

            //7. This will move the body to track the head in tracking space without overlapping colliders
            if(bodyFollowsHead) {
                SyncBodyHead();
                PreventHeadOverlap();
            }
        }


        protected virtual void UpdateTrackedObjects() {

            var startRightHandPos = handRight.transform.position;
            var startLeftHandPos = handLeft.transform.position;

            //Moves the tracked objects based on the physics bodys delta movement
            targetTrackedPos += (transform.position - lastUpdatePosition);
            trackingContainer.position = new Vector3(targetTrackedPos.x, trackingContainer.position.y, targetTrackedPos.z);


            //This slow moves the head + controllers on the Y-axis so it doesn't jump when stepping up
            if(isGrounded)
                trackingContainer.position = Vector3.MoveTowards(trackingContainer.position, targetTrackedPos + Vector3.up * heightOffset, (Mathf.Abs(trackingContainer.position.y - targetTrackedPos.y) + 0.1f) * Time.deltaTime * heightSmoothSpeed);
            else
                trackingContainer.position = targetTrackedPos + Vector3.up * heightOffset;


            //This code will move the tracking objects to match the body collider position when moving
            var targetPos = transform.position - headCamera.transform.position; targetPos.y = 0;
            targetPosOffset = Vector3.MoveTowards(targetPosOffset, targetPos, body.linearVelocity.magnitude * Time.deltaTime);
            trackingContainer.position += targetPosOffset;


            //This helps prevent the hands from clipping
            var deltaHandPos = handRight.transform.position - startRightHandPos;
            if(pushRight.Count > 0)
                handRight.transform.position -= deltaHandPos;
            else 
               PreventHandClipping(handRight, startRightHandPos);
            
            
            deltaHandPos = handLeft.transform.position - startLeftHandPos;
            if(pushLeft.Count > 0)
                handLeft.transform.position -= deltaHandPos;
            else 
                PreventHandClipping(handLeft, startLeftHandPos);
            

            lastUpdatePosition = transform.position;
        }



        void PreventHandClipping(Hand hand, Vector3 startPosition) {
            var deltaHandPos = hand.transform.position - startPosition;
            if (deltaHandPos.magnitude < Physics.defaultContactOffset)
                return;

            var center = hand.handEncapsulationBox.transform.TransformPoint(hand.handEncapsulationBox.center) - deltaHandPos;
            var halfExtents = hand.handEncapsulationBox.transform.TransformVector(hand.handEncapsulationBox.size) / 2f;
            var hits = Physics.BoxCastAll(center, halfExtents, deltaHandPos, hand.handEncapsulationBox.transform.rotation, deltaHandPos.magnitude*1.5f, handPlayerMask);
            for(int i = 0; i < hits.Length; i++) {
                var hit = hits[i];
                if(hit.collider.isTrigger)
                    continue;

                if(hand.holdingObj == null || hit.collider.attachedRigidbody == null || (hit.collider.attachedRigidbody != hand.holdingObj.body && !hand.holdingObj.jointedBodies.Contains(hit.collider.attachedRigidbody))) {
                    var deltaHitPos = hit.point - hand.transform.position;
                    hand.transform.position = Vector3.MoveTowards(hand.transform.position, startPosition, deltaHitPos.magnitude);
                    
                    break;
                }

            }
        }

        /// <summary>This function is responsible for keeping the body matching the head position when moving the head within the tracking space</summary>
        protected virtual void SyncBodyHead() {
            for(int i = 0; i < bodySyncMaxIterations; i++) {
                float minDistanceOffset = Physics.defaultContactOffset*1.5f;
                Vector3 currentPosition = transform.position;
                Vector3 flatHeadPos = headCamera.transform.position;
                Vector3 flatBodyPos = currentPosition;
                flatHeadPos.y = flatBodyPos.y = 0;

                //If the body is too far away from the head, move the body closer to the head
                if(Vector3.Distance(flatHeadPos, flatBodyPos) >  minDistanceOffset) {
                    Vector3 direction = Vector3.ClampMagnitude(flatHeadPos - flatBodyPos, bodyCapsule.radius/2f);

                    //Check if the body is going to collide with something
                    GetCapsuleEndPoints(bodyCollider, out var capsuleTop, out var capsuleBottom, out var scaledRadius);

                    capsuleBottom.y += maxStepHeight;
                    if(capsuleBottom.y > capsuleTop.y)
                        capsuleTop.y = capsuleBottom.y;

                    int overlapCount = Physics.OverlapCapsuleNonAlloc(
                        capsuleBottom + direction,
                        capsuleTop + direction,
                        scaledRadius,
                        colliderNonAlloc,
                        handPlayerMask,
                        QueryTriggerInteraction.Ignore
                    );

                    int attempts = 0;
                    //If the body is going to collide with something, move the body to the closest point that doesn't collide using Physics.ComputePenetration
                    if(overlapCount > 0) {
                        while(overlapCount > 0 && attempts < bodySyncMaxIterations) {
                            Vector3 averageDepentration = Vector3.zero;
                            for(int j = 0; j < overlapCount; j++) {
                                Collider otherCollider = colliderNonAlloc[j];
                                var preColliderHeight = bodyCapsule.height;

                                if((handLeft.IsHolding() && handLeft.holdingObj.grabColliders.Contains(otherCollider)) ||
                                    (handRight.IsHolding() && handRight.holdingObj.grabColliders.Contains(otherCollider)))
                                    continue;
                                //Temporarily increase the height of the capsule to prevent the depenetration from using the Y-axis
                                //This should prevent bugs in most cases, but it might cause some issues with some very specific edge cases (E.G a giant inverted sphere shapped mesh collider)
                                bodyCapsule.height = preColliderHeight * 1000f;

                                if(Physics.ComputePenetration(otherCollider, otherCollider.transform.position, otherCollider.transform.rotation, bodyCapsule, direction + currentPosition, transform.rotation, out var closestDepentrationDirection, out var closestDepenetrationDistance)) {
                                    //Adding the 1.05f multiplier to the depenetration direction will make the body move a bit further away from the collider helping to prevent the body from getting stuck
                                    averageDepentration += (closestDepentrationDirection * closestDepenetrationDistance) * 1.05f; averageDepentration.y = 0;
                                }

                                bodyCapsule.height = preColliderHeight;
                            }

                            overlapCount = Physics.OverlapCapsuleNonAlloc(
                                capsuleBottom + direction - averageDepentration,
                                capsuleTop + direction - averageDepentration,
                                scaledRadius,
                                colliderNonAlloc,
                                handPlayerMask,
                                QueryTriggerInteraction.Ignore
                            );

                            if(overlapCount == 0) {
                                currentPosition += direction - averageDepentration;
                                transform.position += direction - averageDepentration;
                                targetTrackedPos -= direction - averageDepentration;
                                body.position = transform.position;
                            }
                            attempts++;
                        }
                    }
                    //If the body is not going to collide with anything, move the body towards the target position
                    else {
                        transform.position += direction;
                        targetTrackedPos -= direction;
                        body.position = transform.position;
                    }
                }
            }

            void GetCapsuleEndPoints(CapsuleCollider collider, out Vector3 top, out Vector3 bottom, out float radius) {
                Transform transform = collider.transform;
                Vector3 capsuleCenter = transform.TransformPoint(collider.center);
                float actualHeight = collider.height * 0.5f - collider.radius;
                float scaledHeight = actualHeight * Vector3.Scale(transform.lossyScale, Vector3.up).magnitude;
                radius = collider.radius * Mathf.Max(transform.lossyScale.x, transform.lossyScale.y, transform.lossyScale.z);

                top = capsuleCenter + Vector3.up * scaledHeight;
                bottom = capsuleCenter - Vector3.up * scaledHeight;
            }
        }


        /// <summary>This function is responsible for keeping the body matching the head position when moving the head within the tracking space</summary>
        protected virtual void PreventHeadOverlap() {
            //By using moveTowards with a radius * 0.95f, we can prevent the spheres from ever clipping through objects
            //because it will always depenetrate to the correct direction from the last depenetrated position
            Vector3 currentHeadPosition = headCamera.transform.position;
            Vector3 cameraHeadPosition = Vector3.MoveTowards(lastHeadPos, currentHeadPosition, headRadius*0.95f);

            int overlapCount = Physics.OverlapSphereNonAlloc(
                cameraHeadPosition,
                headRadius,
                colliderNonAlloc,
                handPlayerMask,
                QueryTriggerInteraction.Ignore
            );

            //Prevents held objects from being considered for depenetration
            if(handLeft.IsHolding() || handRight.IsHolding()) {
                for(int j = overlapCount - 1; j >= 0; j--) {
                    Collider otherCollider = colliderNonAlloc[j];

                    if(handLeft.IsHolding() && handLeft.holdingObj.grabColliders.Contains(otherCollider)
                        || handRight.IsHolding() && handRight.holdingObj.grabColliders.Contains(otherCollider))
                            overlapCount--;
                }
            }

            //If the head is overlapping with something, move the head/body away from the overlapped objects
            if(overlapCount > 0) {
                int attempts = 0;
                while(overlapCount > 0 && attempts < headCollisionMaxIterations) {
                    Vector3 averageDepentration = Vector3.zero;
                    for(int j = 0; j < overlapCount; j++) {
                        Collider otherCollider = colliderNonAlloc[j];
                        if(Physics.ComputePenetration(otherCollider, otherCollider.transform.position, otherCollider.transform.rotation, headPhysicsFollower.headCollider, cameraHeadPosition, transform.rotation, out var closestDepentrationDirection, out var closestDepenetrationDistance)) {
                            averageDepentration += (closestDepentrationDirection * closestDepenetrationDistance);
                        }
                    }

                    //Offsets the head on the Y-axis, but push the body away on the X/Z-axis
                    headHeightOffset -= averageDepentration.y;
                    targetTrackedPos -= Vector3.up * averageDepentration.y;
                    cameraHeadPosition.y -= averageDepentration.y;
                    currentHeadPosition -= averageDepentration;
                    averageDepentration.y = 0f;

                    transform.position -= averageDepentration;
                    cameraHeadPosition -= averageDepentration;
                    body.position = transform.position; 
                    
                    cameraHeadPosition = Vector3.MoveTowards(cameraHeadPosition, currentHeadPosition, headRadius*0.95f);

                    overlapCount = Physics.OverlapSphereNonAlloc(
                        cameraHeadPosition,
                        headRadius,
                        colliderNonAlloc,
                        handPlayerMask,
                        QueryTriggerInteraction.Ignore
                    );


                    attempts++;
                }
            }
            //If there is height debt to pay, pay it
            else if(headHeightOffset != 0) {
                Vector3 castDirection = (headHeightOffset > 0) ? -Vector3.up : Vector3.up;
                float castDistance = Mathf.Abs(headHeightOffset);
                Vector3 startPosition = cameraHeadPosition + Vector3.up * Mathf.Sign(headHeightOffset) * 0.001f;

                //Check if there is space to move the head to pay of the height debt
                //Using a 0.001f buffer to prevent the sphere cast from ignoring the collider if perfectly flush
                if(Physics.SphereCast(startPosition, headRadius, castDirection, out var hit, castDistance, handPlayerMask, QueryTriggerInteraction.Ignore) && hit.distance > 0.001f) {
                    var adjustment = headHeightOffset - Mathf.MoveTowards(headHeightOffset, 0, hit.distance - 0.001f);
                    headHeightOffset -= adjustment;
                    cameraHeadPosition.y -= adjustment;
                    targetTrackedPos -= Vector3.up * adjustment;
                }
                //If there is no space to move the head to pay of the height debt, just move the body
                else {
                    targetTrackedPos -= Vector3.up * headHeightOffset;
                    cameraHeadPosition.y -= headHeightOffset;
                    headHeightOffset = 0;
                }
            }

            if(trackingStarted)
                lastHeadPos = cameraHeadPosition;
        }
        
        protected virtual bool CanInputMove() {
            return (allowClimbingMovement || !IsClimbing());
        }




        protected virtual void UpdateTurn(float deltaTime) {

            //Snap turning
            if(rotationType == RotationType.snap) {
                if(Mathf.Abs(turningAxis) > turnDeadzone && axisReset) {
                    var angle = turningAxis > turnDeadzone ? snapTurnAngle : -snapTurnAngle;

                    var targetPos = transform.position - headCamera.transform.position; targetPos.y = 0;

                    trackingContainer.position += targetPos;
                    if(headPhysicsFollower != null) {
                        headPhysicsFollower.transform.position += targetPos;
                        headPhysicsFollower.body.position = headPhysicsFollower.transform.position;
                    }

                    lastUpdatePosition = new Vector3(transform.position.x, lastUpdatePosition.y, transform.position.z);
                    var handRightStartPos = handRight.transform.position;
                    var handLeftStartPos = handLeft.transform.position;

                    trackingContainer.RotateAround(transform.position, Vector3.up, angle);
                    targetPosOffset = Vector3.zero;
                    targetTrackedPos = new Vector3(trackingContainer.position.x, targetTrackedPos.y, trackingContainer.position.z);

                    if(handRight.holdingObj != null && !handRight.IsGrabbing()) {
                        handRight.body.position = handRight.handGrabPoint.position;
                        handRight.body.rotation = handRight.handGrabPoint.rotation;
                    }
                    else {
                        handRight.body.position = handRight.transform.position;
                        handRight.body.rotation = handRight.transform.rotation;

                    }

                    handRight.handFollow.AverageSetMoveTo();
                    handLeft.handFollow.AverageSetMoveTo();

                    PreventHandClipping(handRight, handRightStartPos);
                    PreventHandClipping(handLeft, handLeftStartPos);
                    Physics.SyncTransforms();

                    OnSnapTurn?.Invoke(this);
                    axisReset = false;
                }
            }
            else if(Mathf.Abs(turningAxis) > turnDeadzone) {
                
                lastUpdatePosition = new Vector3(transform.position.x, lastUpdatePosition.y, transform.position.z);
                trackingContainer.RotateAround(transform.position, Vector3.up, smoothTurnSpeed * (Mathf.MoveTowards(turningAxis, 0, turnDeadzone)) * deltaTime);

                targetPosOffset = Vector3.zero;
                targetTrackedPos = new Vector3(trackingContainer.position.x, targetTrackedPos.y, trackingContainer.position.z);

                handRight.handFollow.AverageSetMoveTo();
                handLeft.handFollow.AverageSetMoveTo();
                Physics.SyncTransforms();

                OnSmoothTurn?.Invoke(this);
                axisReset = false;
            }

            if(Mathf.Abs(turningAxis) < turnResetzone)
                axisReset = true;
        }

        RaycastHit[] hitsNonAlloc = new RaycastHit[128];
        protected virtual void Ground() {
            isGrounded = false;
            lastGroundHit = new RaycastHit();

            if(!tempDisableGrounding && useGrounding && !IsClimbing() && !(pushAxis.y > 0)) {
                highestPoint = -1;

                float stepAngle;
                float dist;
                float scale = transform.lossyScale.x > transform.lossyScale.z ? transform.lossyScale.x : transform.lossyScale.z;

                var maxStepHeight = this.maxStepHeight;
                maxStepHeight *= climbAxis.y > 0 ? climbUpStepHeightMultiplier : 1;
                maxStepHeight *= pushAxis.y > 0 ? pushUpStepHeightMultiplier : 1;
                maxStepHeight *= scale;

                var point1 = scale * bodyCapsule.center + transform.position + scale * bodyCapsule.height / 2f * -Vector3.up + (maxStepHeight + scale * bodyCapsule.radius * 2) * Vector3.up;
                var point2 = scale * bodyCapsule.center + transform.position + (scale * bodyCapsule.height / 2f + groundingPenetrationOffset) * -Vector3.up;

                var radius = scale * bodyCapsule.radius * 2 + Physics.defaultContactOffset * 2;
                int hitCount = Physics.SphereCastNonAlloc(point1, radius, -Vector3.up, hitsNonAlloc, Vector3.Distance(point1, point2) + scale * bodyCapsule.radius * 4, groundLayerMask, QueryTriggerInteraction.Ignore);

                // Initial Grounding Check includes the body and the area right around it
                CheckGroundHits();

                if(!isGrounded && hitCount > 0) {
                    // If it's hitting something but not valid ground, check the smaller area just below the feet.
                    // This specifically fixes a bug where a mesh collider won't return a valid grounding hit when standing against a vertical step just above the max step height
                    // This is because SphereCast will only return the first highest valid hit per collider
                    radius = scale * bodyCapsule.radius;
                    hitCount = Physics.SphereCastNonAlloc(point1, radius, -Vector3.up, hitsNonAlloc, Vector3.Distance(point1, point2) + scale * bodyCapsule.radius * 4, groundLayerMask, QueryTriggerInteraction.Ignore);

                    CheckGroundHits();
                }

                void CheckGroundHits() {
                    for(int i = 0; i < hitCount; i++) {
                        var hit = hitsNonAlloc[i];

                        if(hit.collider != bodyCapsule) {
                            if(hit.point.y >= point2.y && hit.point.y <= point2.y + maxStepHeight + groundingPenetrationOffset) {
                                stepAngle = Vector3.Angle(hit.normal, Vector3.up);
                                dist = hit.point.y - transform.position.y;

                                if(stepAngle < maxStepAngle && dist > highestPoint) {
                                    isGrounded = true;
                                    highestPoint = dist;
                                    lastGroundHit = hit;
                                }
                            }
                        }
                    }
                }

                if(isGrounded) {
                    // Zero out vertical velocity since we're grounded.
                    body.linearVelocity = new Vector3(body.linearVelocity.x, 0, body.linearVelocity.z);

                    // If smooth stepping is enabled, interpolate the Y-position.
                    if(useSmoothStep) {
                        float currentY = body.position.y;
                        float targetY = lastGroundHit.point.y;
                        float newY = Mathf.Lerp(currentY, targetY, Time.fixedDeltaTime * stepSmoothSpeed);
                        body.position = new Vector3(body.position.x, newY, body.position.z);
                    }
                    else {
                        // Otherwise, instantly snap to the step height.
                        body.position = new Vector3(body.position.x, lastGroundHit.point.y, body.position.z);
                    }
                    transform.position = body.position;
                }

                body.useGravity = !isGrounded;
            }
        }

        public bool IsGrounded() {
            return isGrounded;
        }

        public void ToggleFlying() {
            useGrounding = !useGrounding;
            body.useGravity = useGrounding;
        }

        protected virtual void UpdatePlayerHeight() {
            if(crouching != lastCrouching) {
                if(lastCrouching)
                    heightOffset += lastCrouchingHeight;
                if(!lastCrouching)
                    heightOffset -= crouchHeight;

                lastCrouching = crouching;
                lastCrouchingHeight = crouchHeight;
            }

            if(autoAdjustColliderHeight) {
                playerHeight = Mathf.Clamp(headCamera.transform.position.y - transform.position.y, minMaxHeight.x, minMaxHeight.y);
                bodyCapsule.height = playerHeight;
                var centerHeight = playerHeight / 2f > bodyCapsule.radius ? playerHeight / 2f : bodyCapsule.radius;
                bodyCapsule.center = new Vector3(0, centerHeight, 0);
            }
        }


        protected void UpdatePlatform(){
            if (isGrounded && lastGroundHit.transform != null && (platformingLayerMask == (platformingLayerMask | (1 << lastGroundHit.collider.gameObject.layer)))) {
                if (!lastGroundHit.transform.Equals(lastPlatformingHit.transform)) {
                    lastPlatformingHit = lastGroundHit;
                    lastPlatformPosition = lastPlatformingHit.transform.position;
                    lastPlatformRotation = lastPlatformingHit.transform.rotation;
                }
                else if(lastGroundHit.transform.Equals(lastPlatformingHit.transform))
                {
                    if (lastPlatformingHit.transform.position != lastPlatformPosition || lastPlatformingHit.transform.rotation.eulerAngles != lastPlatformRotation.eulerAngles) {
                        lastPlatformingHit = lastGroundHit;
                        Transform ruler = AutoHandExtensions.transformRuler;
                        ruler.position = transform.position;
                        ruler.rotation = transform.rotation;
                        ruler.position += lastPlatformingHit.transform.position - lastPlatformPosition;

                        var deltaPos = ruler.transform.position - transform.position;
                        var deltaRot = (lastPlatformingHit.transform.rotation * Quaternion.Inverse(lastPlatformRotation));

                        ruler.transform.RotateAround(lastPlatformingHit.transform.position, Vector3.up, deltaRot.eulerAngles.y);
                        trackingContainer.RotateAround(headCamera.transform.position, Vector3.up, deltaRot.eulerAngles.y);

                        transform.position += deltaPos;
                        body.position = transform.position;

                        trackingContainer.position += deltaPos;

                        lastUpdatePosition = transform.position;

                        targetPosOffset = Vector3.zero;

                        targetTrackedPos = new Vector3(trackingContainer.position.x, targetTrackedPos.y + deltaPos.y, trackingContainer.position.z);
                        lastPlatformPosition = lastPlatformingHit.transform.position;
                        lastPlatformRotation = lastPlatformingHit.transform.rotation;
                    }
                }
            }
        }


        public void Jump(float jumpPower = 1) {
            if(isGrounded) {
                DisableGrounding(0.1f);
                body.useGravity = true;
                body.AddForce(Vector3.up * jumpPower, ForceMode.VelocityChange);
            }
        }


        public void DisableGrounding(float seconds) {
            if(disableGroundingRoutine != null)
                StopCoroutine(disableGroundingRoutine);
            disableGroundingRoutine = StartCoroutine(DisableGroundingSecondsRoutine(seconds));
        }

        Coroutine disableGroundingRoutine;
        IEnumerator DisableGroundingSecondsRoutine(float seconds) {
            tempDisableGrounding = true;
            isGrounded = false;
            yield return new WaitForSeconds(seconds);
            tempDisableGrounding = false;

        }

        /// <summary>Legacy function, use body.addfoce instead</summary>
        public void AddVelocity(Vector3 force, ForceMode mode = ForceMode.Acceleration) {
            body.AddForce(force, mode);
        }

        protected virtual void StartPush(Hand hand, GameObject other) {
            if(!allowBodyPushing || IsClimbing())
                return;

            if(other.CanGetComponent(out Pushable push) && push.enabled) {
                if(hand.left) {
                    if(!pushLeft.ContainsKey(push)) {
                        pushLeft.Add(push, hand);
                        pushLeftCount.Add(push, 1);
                    }
                    else {
                        pushLeftCount[push]++;
                    }
                }

                if(!hand.left && !pushRight.ContainsKey(push)) {
                    if(!pushRight.ContainsKey(push)) {
                        pushRight.Add(push, hand);
                        pushRightCount.Add(push, 1);
                    }
                    else {
                        pushRightCount[push]++;
                    }
                }
            }
        }

        protected virtual void StopPush(Hand hand, GameObject other) {
            if(!allowBodyPushing)
                return;

            if(other.CanGetComponent(out Pushable push)) {
                if(hand.left && pushLeft.ContainsKey(push)) {
                    var count = --pushLeftCount[push];
                    if(count == 0) {
                        pushLeft.Remove(push);
                        pushLeftCount.Remove(push);
                    }
                }
                if(!hand.left && pushRight.ContainsKey(push)) {
                    var count = --pushRightCount[push];
                    if(count == 0) {
                        pushRight.Remove(push);
                        pushRightCount.Remove(push);
                    }
                }
            }
        }

        protected virtual void StartGrabPush(Hand hand, Grabbable grab) {
            if(!allowBodyPushing)
                return;

            if(grab.CanGetComponent(out Pushable push) && push.enabled) {
                if(hand.left && !pushLeft.ContainsKey(push)) {
                    pushLeft.Add(push, hand);
                    pushLeftCount.Add(push, 1);
                }

                if(!hand.left && !pushRight.ContainsKey(push)) {
                    pushRight.Add(push, hand);
                    pushRightCount.Add(push, 1);
                }
            }
        }

        protected virtual void EndGrabPush(Hand hand, Grabbable grab) {
            if(grab != null && grab.CanGetComponent(out Pushable push)) {
                if(hand.left && pushLeft.ContainsKey(push)) {
                    pushLeft.Remove(push);
                    pushLeftCount.Remove(push);
                }
                else if(!hand.left && pushRight.ContainsKey(push)) {
                    pushRight.Remove(push);
                    pushRightCount.Remove(push);
                }

            }
        }

        protected virtual void ApplyPushingForce() {
            pushAxis = Vector3.zero;
            if(allowBodyPushing) {

                foreach(var push in pushRight) {
                    if(push.Key.enabled && !push.Value.IsGrabbing()) {
                        Vector3 offset = Vector3.zero;
                        var distance = Vector3.Distance(push.Value.body.position, push.Value.moveTo.position);
                        if(distance > 0)
                            offset = Vector3.Scale((push.Value.body.position - push.Value.moveTo.position), push.Key.strengthScale);

                        offset = Vector3.Scale(offset, pushingStrength);
                        pushAxis += offset / 2f;
                    }
                }

                foreach(var push in pushLeft) {
                    if(push.Key.enabled && !push.Value.IsGrabbing()) {
                        Vector3 offset = Vector3.zero;
                        var distance = Vector3.Distance(push.Value.body.position, push.Value.moveTo.position);
                        if(distance > 0)
                            offset = Vector3.Scale((push.Value.body.position - push.Value.moveTo.position), push.Key.strengthScale);

                        offset = Vector3.Scale(offset, pushingStrength);
                        pushAxis += offset / 2f;
                    }
                }
            }
        }

        public bool IsPushing() {
            foreach(var push in pushRight)
                if(push.Key.enabled)
                    return true;
            foreach(var push in pushLeft)
                if(push.Key.enabled)
                    return true;

            return false;
        }
        public bool IsPushingUp() {
            return pushAxis.y > 0;
        }




        protected virtual void StartClimb(Hand hand, Grabbable grab) {
            if(!allowClimbing)
                return;

            if(!climbing.ContainsKey(hand) && grab != null && grab.CanGetComponent(out Climbable climbbable) && climbbable.enabled) {
                if(climbing.Count == 0) {
                    pushRight.Clear();
                    pushRightCount.Clear();
                    pushLeft.Clear();
                    pushLeftCount.Clear();
                }

                if(climbing.Count == 0)
                    body.linearVelocity /= 4f;

                climbing.Add(hand, climbbable);
            }
        }

        protected virtual void EndClimb(Hand hand, Grabbable grab) {
            if(!allowClimbing)
                return;

            if(climbing.ContainsKey(hand))
                climbing.Remove(hand);

            foreach(var climb in climbing)
                climb.Key.ResetGrabOffset();
        }

        protected virtual void ApplyClimbingForce() {
            climbAxis = Vector3.zero;
            if(allowClimbing && climbing.Count > 0) {
                foreach(var hand in climbing) {
                    if(hand.Value.enabled) {
                        var offset = Vector3.Scale(hand.Key.body.position - hand.Key.moveTo.position, hand.Value.axis);
                        offset = Vector3.Scale(offset, climbingStrength);
                        climbAxis += offset / climbing.Count;
                    }
                }
            }
        }

        public bool IsClimbing() {
            foreach(var climb in climbing)
                if(climb.Value.enabled)
                    return true;
            return false;
        }



        public virtual void SetPosition(Vector3 position) {
            SetPosition(position, headCamera.transform.rotation);
        }

        public virtual void SetPosition(Vector3 position, Quaternion rotation) {
            // Calculate and apply the positional delta.
            Vector3 deltaPos = position - transform.position;
            transform.position += deltaPos;

            // Adjust the tracking container's position.
            var targetPos = transform.position - headCamera.transform.position;
            targetPos.y = deltaPos.y;
            trackingContainer.position += targetPos;

            // Update tracking positions.
            lastUpdatePosition = transform.position;
            targetTrackedPos = new Vector3(
                trackingContainer.position.x,
                targetTrackedPos.y + deltaPos.y,
                trackingContainer.position.z
            );

            targetPosOffset = Vector3.zero;
            body.position = transform.position;

            // Update head physics follower if it exists.
            if(headPhysicsFollower != null) {
                headPhysicsFollower.transform.position += targetPos;
                headPhysicsFollower.body.position = headPhysicsFollower.transform.position;
            }

            lastHeadPos = headCamera.transform.position;

            SafeMoveHandToPosition(handRight, transform, handRight.transform.position);
            SafeMoveHandToPosition(handLeft, transform, handLeft.transform.position);

            AddRotation(rotation * Quaternion.Inverse(headCamera.transform.rotation));

            OnTeleported?.Invoke(this);
        }





        public virtual void SetRotation(Quaternion rotation) {
            var targetPos = transform.position - headCamera.transform.position; targetPos.y = 0;

            trackingContainer.position += targetPos;
            if(headPhysicsFollower != null) {
                headPhysicsFollower.transform.position += targetPos;
                headPhysicsFollower.body.position = headPhysicsFollower.transform.position;
            }
            lastUpdatePosition = transform.position;

            var deltaRot = rotation * Quaternion.Inverse(headCamera.transform.rotation);
            trackingContainer.RotateAround(headCamera.transform.position, Vector3.up, deltaRot.eulerAngles.y);

            targetPosOffset = Vector3.zero;
            targetTrackedPos = new Vector3(trackingContainer.position.x, targetTrackedPos.y, trackingContainer.position.z);

            SafeMoveHandToPosition(handRight, transform, handRight.transform.position);
            SafeMoveHandToPosition(handLeft, transform, handLeft.transform.position);

            if(deltaRot.eulerAngles.magnitude > 10f)
                OnTeleported?.Invoke(this);


        }

        public virtual void AddRotation(Quaternion addRotation) {
            var targetPos = transform.position - headCamera.transform.position; targetPos.y = 0;

            trackingContainer.position += targetPos;
            if(headPhysicsFollower != null) {
                headPhysicsFollower.transform.position += targetPos;
                headPhysicsFollower.body.position = headPhysicsFollower.transform.position;
            }
            lastUpdatePosition = transform.position;

            trackingContainer.RotateAround(headCamera.transform.position, Vector3.up, addRotation.eulerAngles.y);

            targetPosOffset = Vector3.zero;
            targetTrackedPos = new Vector3(trackingContainer.position.x, targetTrackedPos.y, trackingContainer.position.z);

            SafeMoveHandToPosition(handRight, transform, handRight.transform.position);
            SafeMoveHandToPosition(handLeft, transform, handLeft.transform.position);

            if(addRotation.eulerAngles.magnitude > 10f)
                OnTeleported?.Invoke(this);
        }



        protected void SafeMoveHandToPosition(Hand hand, Transform playerTransform, Vector3 desiredHandPosition) {
            var handBody = hand.body;
            Vector3 bodyXZCenter = new Vector3(
                playerTransform.position.x,
                handBody.position.y,
                playerTransform.position.z
            );

            handBody.position = bodyXZCenter;
            handBody.transform.position = bodyXZCenter;

            Vector3 offset = desiredHandPosition - bodyXZCenter;
            float distance = offset.magnitude;
            if(distance < 0.0001f)
                return;

            Vector3 direction = offset.normalized;

            if(handBody.SweepTest(direction, out var hit, distance))
                hand.handFollow.SetHandLocation(bodyXZCenter + direction * hit.distance);
            else
                hand.handFollow.SetHandLocation(desiredHandPosition);

        }

        public virtual void Recenter() {
            var targetPos = transform.position - headCamera.transform.position; targetPos.y = 0;

            trackingContainer.position += targetPos;
            if(headPhysicsFollower != null) {
                headPhysicsFollower.transform.position += targetPos;
                headPhysicsFollower.body.position = headPhysicsFollower.transform.position;
            }
            lastUpdatePosition = transform.position;

            targetPosOffset = Vector3.zero;
            targetTrackedPos = new Vector3(trackingContainer.position.x, targetTrackedPos.y, trackingContainer.position.z);
        }

        public bool IsHolding(Grabbable grab) {
            return handRight.GetHeld() == grab || handLeft.GetHeld() == grab;
        }

        protected virtual Vector3 AlterDirection(Vector3 moveAxis) {
            if(useGrounding)
                return Quaternion.AngleAxis(forwardFollow.eulerAngles.y, Vector3.up) * (new Vector3(moveAxis.x, moveAxis.y, moveAxis.z));
            else
                return forwardFollow.rotation * (new Vector3(moveAxis.x, moveAxis.y, moveAxis.z));
        }


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/AutoHandPlayer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/AutoHandPlayerForceArea.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bc9301e05ec9df54e938f861887b8b93
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Autohand {
    public class AutoHandPlayerForceArea : MonoBehaviour
    {
        public AutoHandPlayer player;
        public float force = 1;
        public ForceMode forceMode = ForceMode.Force;
        public LayerMask layers = ~0;
        Collider[] colliders = new Collider[30];

        private void FixedUpdate()
        {
            var direction = new Vector3 { [player.bodyCollider.direction] = 1 };
            var offset = player.bodyCollider.height / 2 - player.bodyCollider.radius;
            var localPoint0 = player.bodyCollider.center - direction * offset;
            var localPoint1 = player.bodyCollider.center + direction * offset;
            var point0 = transform.TransformPoint(localPoint0);
            var point1 = transform.TransformPoint(localPoint1); 
            var r = transform.TransformVector(player.bodyCollider.radius, player.bodyCollider.radius, player.bodyCollider.radius);
            var radius = Enumerable.Range(0, 3).Select(xyz => xyz == player.bodyCollider.direction ? 0 : r[xyz])
                .Select(Mathf.Abs).Max();

            var overlaps = Physics.OverlapCapsuleNonAlloc(point0, point1, radius, colliders, layers);
            for (int i = 0; i < overlaps; i++)
            {
                if (colliders[i].attachedRigidbody != null)
                {
                    if (colliders[i].attachedRigidbody != player.body && colliders[i].attachedRigidbody != player.handRight.body && colliders[i].attachedRigidbody != player.handLeft.body)
                    {
                        var adjustedForce = (colliders[i].transform.position - player.transform.position).normalized * force;
                        adjustedForce.y /= 10f;
                        colliders[i].attachedRigidbody.AddForce(adjustedForce, forceMode);
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/AutoHandPlayerForceArea.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/BodyPhysicsFollower.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 49e0f95e9f8843d4b8c39421649bc8eb
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BodyPhysicsFollower : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/BodyPhysicsFollower.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Climbable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1e1e358c1b681e8448d2f168014855c7
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;

namespace Autohand {
    [RequireComponent(typeof(Grabbable)), HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/auto-hand-player#climbing")]
    public class Climbable : MonoBehaviour{
        public Vector3 axis = Vector3.one;
        public Stabber stabber;

        private void Start() {
            if(stabber != null) {
                stabber.StartStabEvent += (hand, grab) => {
                    enabled = true;
                };
                stabber.EndStabEvent += (hand, grab) => {
                    enabled = false;
                };
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Climbable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/HeadCameraSmoothing.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 43f45130b60269b47b8e86db114a6478
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class HeadCameraSmoothing : MonoBehaviour
{
    public Vector3 lastPos;
    public Quaternion lastRot;



    public void LateUpdate() {


        lastPos = transform.position;
        lastRot = transform.rotation;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/HeadCameraSmoothing.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/HeadPhysicsFollower.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 62d72f32b05f0d64bae54ab684c65e3b
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    [RequireComponent(typeof(Rigidbody))]
    public class HeadPhysicsFollower : MonoBehaviour{

        [Header("References")]
        public Camera headCamera;
        public Transform trackingContainer;
        public Transform followBody;

        [Header("Follow Settings")]
        public float followStrength = 50f;
        [Tooltip("The maximum allowed distance from the body for the headCamera to still move")]
        public float maxBodyDistance = 1f;

        internal SphereCollider headCollider;
        Vector3 startHeadPos;
        bool started;
        float lastUpdateTime;

        Transform _moveTo = null;
        Transform moveTo {
            get {
                if(!gameObject.activeInHierarchy)
                    return null;
                if(_moveTo == null) {
                    _moveTo = new GameObject().transform;
                    _moveTo.transform.rotation = transform.rotation;
                    _moveTo.rotation = transform.rotation;
                    _moveTo.name = "HEAD FOLLOW POINT";
                    _moveTo.parent = AutoHandExtensions.transformParent;
                }

                return _moveTo;
            }
        }
        public Rigidbody body;
        CollisionTracker collisionTracker = null;


        internal void Init() {
            if(collisionTracker == null) {
                collisionTracker = gameObject.AddComponent<CollisionTracker>();
                collisionTracker.disableTriggersTracking = true;
            }
            body = GetComponent<Rigidbody>();
            body.useGravity = false;
            gameObject.layer = LayerMask.NameToLayer(AutoHandPlayer.HandPlayerLayer);
            
            transform.position = headCamera.transform.position;
            transform.rotation = headCamera.transform.rotation;
            headCollider = GetComponent<SphereCollider>();
            //headCollider.isTrigger = true;
            startHeadPos = headCamera.transform.position;
        }

        protected void FixedUpdate() {
            moveTo.position = headCamera.transform.position;

            if(startHeadPos.y != headCamera.transform.position.y && !started) {
                started = true;
                body.position = headCamera.transform.position;
            }

            if(!started)
                return;
            
            MoveTo();
        }

        public bool Started() {
            return started;
        }
        
        internal virtual void MoveTo() {
            Vector3 currentPosition = transform.position;
            Vector3 currentHeadPosition = headCamera.transform.position;
            moveTo.position = Vector3.MoveTowards(currentPosition, currentHeadPosition, maxBodyDistance);
            body.linearVelocity = (moveTo.position - currentPosition) * followStrength;
            lastUpdateTime = Time.realtimeSinceStartup;

            var deltaTime = (Time.realtimeSinceStartup - lastUpdateTime);
            transform.position = Vector3.MoveTowards(transform.position, moveTo.position, body.linearVelocity.magnitude * deltaTime);
            body.linearVelocity = Vector3.MoveTowards(body.linearVelocity, Vector3.zero, body.linearVelocity.magnitude * deltaTime);
            body.position = transform.position;
        }

        protected virtual void Update() {
            if(moveTo != null && !body.isKinematic) 
                MoveTo();

            lastUpdateTime = Time.realtimeSinceStartup;
        }


        public int CollisionCount() {
            return collisionTracker.collisionCount;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/HeadPhysicsFollower.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/IgnoreHandPlayerCollision.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a70859c512807c2408f79d08adb4d8c2
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class IgnoreHandPlayerCollision : MonoBehaviour {
        public List<Collider> colliders;

        void Start() {
            ActivateIgnoreCollision();
        }

        public void ActivateIgnoreCollision() {
            foreach(var col in colliders)
                AutoHandPlayer.Instance.IgnoreCollider(col, true);
        }
        public void DeactivateIgnoreCollision() {
            foreach(var col in colliders)
                AutoHandPlayer.Instance.IgnoreCollider(col, false);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/IgnoreHandPlayerCollision.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolatedTransform.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7bb8c5e6a9f6c504ba21222eea8af7ad
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using System.Collections;

namespace Autohand {
    [DefaultExecutionOrder(-50)]
    [RequireComponent(typeof(InterpolatedTransformUpdater))]
    public class InterpolatedTransform : MonoBehaviour {
        private TransformData[] m_lastTransforms;
        private int m_newTransformIndex;

        bool run = true;


        void OnEnable() {

            ForgetPreviousTransforms();
        }

        public void ForgetPreviousTransforms() {
            m_lastTransforms = new TransformData[2];
            TransformData t = new TransformData(
                                    transform.localPosition,
                                    transform.localRotation,
                                    transform.localScale);
            m_lastTransforms[0] = t;
            m_lastTransforms[1] = t;
            m_newTransformIndex = 0;
        }

        void FixedUpdate() {
            if(run) {
                TransformData newestTransform = m_lastTransforms[m_newTransformIndex];
                transform.localPosition = newestTransform.position;
                transform.localRotation = newestTransform.rotation;
                transform.localScale = newestTransform.scale;
            }
        }

        public void LateFixedUpdate() {
            m_newTransformIndex = OldTransformIndex();
            m_lastTransforms[m_newTransformIndex] = new TransformData(
                                                        transform.localPosition,
                                                        transform.localRotation,
                                                        transform.localScale);
        }

        void Update() {
            TransformData newestTransform = m_lastTransforms[m_newTransformIndex];
            TransformData olderTransform = m_lastTransforms[OldTransformIndex()];

            if(run) {
                transform.localPosition = Vector3.Lerp(
                                            olderTransform.position,
                                            newestTransform.position,
                                            InterpolationController.InterpolationFactor);
                transform.localRotation = Quaternion.Slerp(
                                            olderTransform.rotation,
                                            newestTransform.rotation,
                                            InterpolationController.InterpolationFactor);
                transform.localScale = Vector3.Lerp(
                                            olderTransform.scale,
                                            newestTransform.scale,
                                            InterpolationController.InterpolationFactor);
            }
        }

        public void DisableForSeconds(float time) {
            if(disableForTime != null) {
                StopCoroutine(disableForTime);
                disableForTime = null;
            }
            if(gameObject.activeInHierarchy)
                disableForTime = StartCoroutine(Disable(time));
        }

        Coroutine disableForTime;
        IEnumerator Disable(float time) {
            run = false;
            yield return new WaitForSeconds(time);
            run = true;
        }

        private int OldTransformIndex() {
            return (m_newTransformIndex == 0 ? 1 : 0);
        }

        private struct TransformData {
            public Vector3 position;
            public Quaternion rotation;
            public Vector3 scale;

            public TransformData(Vector3 position, Quaternion rotation, Vector3 scale) {
                this.position = position;
                this.rotation = rotation;
                this.scale = scale;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolatedTransform.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolatedTransformUpdater.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 097d5c968a806bf43979b2a0b971ecf3
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using System.Collections;

namespace Autohand {
    [DefaultExecutionOrder(100)]
    public class InterpolatedTransformUpdater : MonoBehaviour {

        private InterpolatedTransform _interpolatedTransform;
        private InterpolatedTransform interpolatedTransform {
            get {
                if(_interpolatedTransform == null)
                    _interpolatedTransform = GetComponent<InterpolatedTransform>();

                return _interpolatedTransform;
            }
        }

        void FixedUpdate() {
            interpolatedTransform?.LateFixedUpdate();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolatedTransformUpdater.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolationController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 449b545543ad6594d8d1de432caf00e0
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using System.Collections;

namespace Autohand {
    [DefaultExecutionOrder(-100)]
    public class InterpolationController : MonoBehaviour {
        private float[] m_lastFixedUpdateTimes;
        private int m_newTimeIndex;

        private static float m_interpolationFactor;
        public static float InterpolationFactor {
            get { return m_interpolationFactor; }
        }

        public static InterpolationController _Instance;
        public static InterpolationController Instance {
            get {
                if(_Instance == null && !AutoHandExtensions.CanFindObjectOfType<InterpolationController>()) {
                    _Instance = new GameObject() { name = "InterpolationTracker" }.AddComponent<InterpolationController>();
                    _Instance.transform.parent = AutoHandExtensions.transformParent;
                }

                return _Instance;
            }
        }

        public void Start() {
            m_lastFixedUpdateTimes = new float[2];
            m_newTimeIndex = 0;
        }

        public void FixedUpdate() {
            m_newTimeIndex = OldTimeIndex();
            m_lastFixedUpdateTimes[m_newTimeIndex] = Time.fixedTime;
        }

        public void Update() {
            float newerTime = m_lastFixedUpdateTimes[m_newTimeIndex];
            float olderTime = m_lastFixedUpdateTimes[OldTimeIndex()];

            if(newerTime != olderTime) {
                m_interpolationFactor = (Time.time - newerTime) / (newerTime - olderTime);
            }
            else {
                m_interpolationFactor = 1;
            }
        }

        private int OldTimeIndex() {
            return (m_newTimeIndex == 0 ? 1 : 0);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/InterpolationController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/PlayerPlatform.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7877ec4db1c9f2d4c9cd30c6e9ebbf77
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
namespace Autohand{
    public class PlayerPlatform : MonoBehaviour{
        
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/PlayerPlatform.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Pushable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8aaeb61b4f025df4aa1d1be1032bedc7
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/auto-hand-player#pushing")]
    public class Pushable : MonoBehaviour {
        public Vector3 strengthScale = Vector3.one;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Pushable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Teleporter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 02e7dadae3689a64bb9a24e46177ce9d
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
// Include the demo namespace to access TeleportPoint.
using Autohand.Demo;

namespace Autohand {
    [DefaultExecutionOrder(10000)]
    public class Teleporter : MonoBehaviour {
        [Header("Teleport")]
        public GameObject teleportObject;
        public Transform[] additionalTeleports;

        [Header("Aim Settings")]
        public bool onlyUseTeleportPoints;
        public bool preventCapsuleOverlap = true;
        public Transform aimer;
        public float aimerSmoothingSpeed = 5f;
        public LayerMask layer;
        public float maxSurfaceAngle = 45f;
        [Min(0)]
        public float distanceMultiplyer = 1f;
        [Min(0)]
        public float curveStrength = 1f;

        [Header("Line Settings")]
        public LineRenderer line;
        public int lineSegments = 50;
        public Gradient canTeleportColor;
        public Gradient cantTeleportColor;

        [Tooltip("Shown at the aim-hit point for non-TeleportPoint surfaces")]
        public GameObject indicator;

        [Header("Unity Events")]
        public UnityEvent OnStartTeleport;
        public UnityEvent OnStopTeleport;
        public UnityEvent OnTeleport;

        // ---------------- Internal state ----------------
        private Vector3[] lineArr;
        private bool aiming;
        private bool hitting;   // True if we found a valid teleport target this frame
        private RaycastHit aimHit;
        private AutoHandPlayer playerBody;
        private RaycastHit[] hitNonAlloc;
        private TeleportPoint currentTeleportPoint;

        private Vector3 currentTeleportSmoothForward;
        private Vector3 currentTeleportForward;
        private Vector3 currentTeleportPosition;

        private TeleportPoint[] teleportPoints;
        private const float arcTimeDivisor = 60f;

        private void Awake() {
            line.enabled = false;
            hitNonAlloc = new RaycastHit[10];
        }

        private void Start() {
            playerBody = AutoHandExtensions.CanFindObjectOfType<AutoHandPlayer>();

            // If the "teleportObject" is actually the player's root, null it to avoid double-moving
            if(playerBody != null && playerBody.transform.gameObject == teleportObject) {
                teleportObject = null;
            }

            lineArr = new Vector3[lineSegments];

            // Grab all TeleportPoints in scene, disable them initially
            teleportPoints = AutoHandExtensions.CanFindObjectsOfType<TeleportPoint>();
            ToggleTeleportPoints(false);
        }

        void ToggleTeleportPoints(bool enabled) {
            if(teleportPoints == null)
                return;

            foreach(var tp in teleportPoints) {
                // If TeleportPoint has "alwaysShow" = true, only disable if enabling == false
                if(!tp.alwaysShow || enabled) {
                    tp.gameObject.SetActive(enabled);
                }
            }
        }

        private void LateUpdate() {
            SmoothTargetValues();

            if(aiming) {
                CalculateTeleportPoint();
            }
            else {
                // Turn off line if not aiming
                line.positionCount = 0;
            }

            DrawIndicator();
        }

        void SmoothTargetValues() {
            currentTeleportForward = aimer.forward;
            currentTeleportPosition = aimer.position;
            currentTeleportSmoothForward = Vector3.Lerp(
                currentTeleportSmoothForward,
                currentTeleportForward,
                Time.deltaTime * aimerSmoothingSpeed
            );
        }

        /// <summary>
        /// Core arc logic + collisions checking for a valid teleport point.
        /// </summary>
        void CalculateTeleportPoint() {
            hitting = false;
            line.colorGradient = cantTeleportColor;



            var lineList = new List<Vector3>();
            TeleportPoint foundTP = null;
            bool foundTeleport = false;

            for(int i = 0; i < lineSegments; i++) {
                float time = i / arcTimeDivisor;

                // Parabolic arc
                lineArr[i] = currentTeleportPosition
                    + (currentTeleportSmoothForward * time * distanceMultiplyer * 15f)
                    + Vector3.up * (curveStrength * (time - Mathf.Pow(9.8f * 0.5f * time, 2)));

                lineList.Add(lineArr[i]);

                // Skip first segment, no line to cast
                if(i == 0)
                    continue;

                Vector3 segmentStart = lineArr[i - 1];
                Vector3 segmentDir = lineArr[i] - segmentStart;
                float segmentDist = segmentDir.magnitude;

                int hitCount = Physics.RaycastNonAlloc(
                    segmentStart,
                    segmentDir.normalized,
                    hitNonAlloc,
                    segmentDist,
                    layer,
                    QueryTriggerInteraction.Collide
                );

                if(hitCount > 0) {
                    bool teleporterHit = false;
                    bool solidHitFound = false;
                    RaycastHit bestSolidHit = default;

                    // Examine each hit in the segment
                    for(int h = 0; h < hitCount; h++) {
                        var tempHit = hitNonAlloc[h];

                        // If it's a TeleportPoint (trigger or not)
                        if(tempHit.collider.TryGetComponent<TeleportPoint>(out TeleportPoint tp)) {
                            foundTP = tp;
                            aimHit = tempHit;
                            teleporterHit = true;
                            // We choose the earliest TeleportPoint in the path, so break
                            break;
                        }
                        else if(!tempHit.collider.isTrigger) {
                            // This is an actual physical collider.
                            float angle = Vector3.Angle(tempHit.normal, Vector3.up);
                            if(angle <= maxSurfaceAngle) {
                                // The first valid flat surface we see on this segment
                                if(!solidHitFound) {
                                    solidHitFound = true;
                                    bestSolidHit = tempHit;
                                }
                            }
                            else {
                                // It's too steep => discard and break out
                                break;
                            }
                        }
                    }

                    // If we got either a teleporter or a valid solid, do overlap checks if needed
                    bool capsuleOverlapInvalid = false;
                    if(playerBody != null && preventCapsuleOverlap) {
                        bool arcValid = (teleporterHit || solidHitFound);

                        // If the user only wants TeleportPoints, disallow solids
                        if(!teleporterHit && onlyUseTeleportPoints)
                            arcValid = false;

                        if(arcValid) {
                            // The actual point we aim to stand on:
                            Vector3 checkPoint;
                            if(teleporterHit) {
                                checkPoint = foundTP.teleportPoint.position;
                            }
                            else {
                                checkPoint = bestSolidHit.point;
                            }

                            CapsuleCollider playerCapsule = playerBody.bodyCollider;
                            Vector3 capsuleBottom = checkPoint + Vector3.up * (playerCapsule.radius) + Vector3.up * 0.15f;
                            Vector3 capsuleTop = checkPoint + Vector3.up * (playerCapsule.height - playerCapsule.radius);

                            Collider[] overlaps = Physics.OverlapCapsule(
                                capsuleBottom,
                                capsuleTop,
                                playerCapsule.radius,
                                playerBody.handPlayerMask,
                                QueryTriggerInteraction.Ignore
                            );

                            foreach(Collider col in overlaps) {
                                if(col.gameObject == playerBody.gameObject)
                                    continue;

                                capsuleOverlapInvalid = true;
                                Debug.Log("Capsule overlap detected on: " + col.name);
                                break;
                            }

                            // Debug line to visualize overlap check
                            Debug.DrawLine(capsuleBottom, capsuleTop, capsuleOverlapInvalid ? Color.red : Color.green);
                        }
                    }

                    // If overlap is invalid, we end the arc here as "no"
                    if(capsuleOverlapInvalid) {
                        hitting = false;
                        line.colorGradient = cantTeleportColor;

                        // End line here for clarity
                        lineList[lineList.Count - 1] = lineArr[i];

                        // If we had a highlighted TeleportPoint from last frame, clear it now
                        if(currentTeleportPoint != null) {
                            currentTeleportPoint.StopHighlighting(this);
                            currentTeleportPoint = null;
                        }

                        break;
                    }
                    else {
                        // Overlap is fine => use teleporter or solid
                        if(teleporterHit) {
                            hitting = true;
                            if(currentTeleportPoint == null || currentTeleportPoint != foundTP)
                                foundTP.StartHighlighting(this);

                            currentTeleportPoint = foundTP;

                            // End line right at the TeleportPoint's collision point
                            lineList[lineList.Count - 1] = aimHit.point;
                            line.colorGradient = canTeleportColor;
                            break;
                        }
                        else if(solidHitFound) {
                            // Non-teleport surface, but valid
                            hitting = true;
                            aimHit = bestSolidHit;

                            // If we had an old teleport point, stop highlighting
                            if(currentTeleportPoint != null) {
                                currentTeleportPoint.StopHighlighting(this);
                                currentTeleportPoint = null;
                            }

                            lineList[lineList.Count - 1] = aimHit.point;
                            line.colorGradient = canTeleportColor;
                            foundTeleport = true;
                            break;
                        }
                        else {
                            foundTeleport = true;
                            break;
                        }
                    }
                }
            }

            // Final update to line renderer
            line.enabled = true;
            line.positionCount = lineList.Count;
            line.SetPositions(lineList.ToArray());

            // If we never found anything valid, be sure to clear any leftover highlight
            if(!hitting && currentTeleportPoint != null) {
                currentTeleportPoint.StopHighlighting(this);
                currentTeleportPoint = null;
            }
        }

        /// <summary>
        /// Places the indicator where we hit (if hitting) and if not a TeleportPoint.
        /// </summary>
        void DrawIndicator() {
            if(indicator == null)
                return;

            if(hitting) {
                if(currentTeleportPoint == null && onlyUseTeleportPoints) {
                    indicator.SetActive(false);
                    line.colorGradient = cantTeleportColor;
                }
                else if(currentTeleportPoint != null) {
                    indicator.SetActive(false);
                }
                else {
                    // Show our generic ground indicator
                    indicator.SetActive(true);
                    indicator.transform.position = aimHit.point;
                    indicator.transform.up = aimHit.normal;
                }
            }
            else {
                indicator.SetActive(false);
            }
        }

        public void StartTeleport() {
            aiming = true;
            ToggleTeleportPoints(true);
            line.enabled = true;
            OnStartTeleport?.Invoke();
        }

        public void CancelTeleport() {
            aiming = false;
            hitting = false;
            line.positionCount = 0;
            line.enabled = false;
            ToggleTeleportPoints(false);

            if(currentTeleportPoint != null) {
                currentTeleportPoint.StopHighlighting(this);
                currentTeleportPoint = null;
            }
            indicator?.SetActive(false);

            OnStopTeleport?.Invoke();
        }

        /// <summary>
        /// Actually perform the teleport, either to a TeleportPoint or a generic location.
        /// </summary>
        public void Teleport() {
            // If we are on a TeleportPoint:
            if(currentTeleportPoint != null) {
                Vector3 finalPos = currentTeleportPoint.matchPoint
                    ? currentTeleportPoint.teleportPoint.position
                    : aimHit.point;

                Quaternion finalRot = currentTeleportPoint.matchDirection
                    ? currentTeleportPoint.teleportPoint.rotation
                    : playerBody ? playerBody.headCamera.transform.rotation : Quaternion.identity;

                // Move the designated object
                if(teleportObject != null) {
                    Vector3 offset = finalPos - teleportObject.transform.position;
                    teleportObject.transform.position = finalPos;
                    foreach(var extra in additionalTeleports) {
                        extra.position += offset;
                    }
                }
                // Move the player body
                if(playerBody != null) {
                    playerBody.SetPosition(finalPos, finalRot);
                }

                // Invoke the TeleportPoints own teleport logic
                currentTeleportPoint.Teleport(this);
                OnTeleport?.Invoke();
            }
            else if(!onlyUseTeleportPoints && hitting) {
                // Solid ground (nonteleport) is allowed, and we found a valid aimHit
                Vector3 finalPos = aimHit.point;

                if(teleportObject != null) {
                    Vector3 offset = finalPos - teleportObject.transform.position;
                    teleportObject.transform.position = finalPos;
                    foreach(var extra in additionalTeleports) {
                        extra.position += offset;
                    }
                }
                if(playerBody != null) {
                    // Just rotate so player faces the same direction, or up to you
                    playerBody.SetPosition(finalPos);
                }
                OnTeleport?.Invoke();
            }

            CancelTeleport();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/Teleporter.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c847ed0f3ff34c24f900fe5219a64c6b
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand.Demo {

    public class TeleportPoint : MonoBehaviour {
        public Transform teleportPoint;
        public bool alwaysShow = false;
        public bool matchPoint = true;
        public bool matchDirection = true;

        public UnityEvent<TeleportPoint, Teleporter> StartHighlight;
        public UnityEvent<TeleportPoint, Teleporter> StopHighlight;
        public UnityEvent<TeleportPoint, Teleporter> OnTeleport;


        public void Awake() {
            if(teleportPoint == null)
                teleportPoint = transform;
        }


        public virtual void StartHighlighting(Teleporter raycaster) {
            StartHighlight.Invoke(this, raycaster);
        }

        public virtual void StopHighlighting(Teleporter raycaster) {
            StopHighlight.Invoke(this, raycaster);
        }

        public virtual void Teleport(Teleporter raycaster) {
            OnTeleport.Invoke(this, raycaster);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPointAnimation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3fcaf767645120d4fb8ca8b1fdeed5a3
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {
    [RequireComponent(typeof(TeleportPoint))]
    public class TeleportPointAnimation : InteractionAnimations {
        TeleportPoint teleportPoint;

        protected override void OnEnable() {
            base.OnEnable();
            teleportPoint = GetComponent<TeleportPoint>();
            teleportPoint.StartHighlight.AddListener(StartHighlight);
            teleportPoint.StopHighlight.AddListener(StopHighlight);
        }

        protected override void OnDisable() {
            base.OnDisable();
            teleportPoint.StartHighlight.RemoveListener(StartHighlight);
            teleportPoint.StopHighlight.RemoveListener(StopHighlight);
        }

        void StartHighlight(TeleportPoint teleportPoint, Teleporter teleporter) {
            highlightStartTime = Time.time;
            highlighting = true;
        }

        void StopHighlight(TeleportPoint teleportPoint, Teleporter teleporter) {
            highlightStopTime = Time.time;
            highlighting = false;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPointAnimation.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPointSoundEffects.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9f8ad05781f4e8e4ea6032116eb81d7b
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {
    public class TeleportPointSoundEffects : MonoBehaviour {
        public TeleportPoint teleportPoint;
        public float randomPitchRange = 0.1f;
        public AudioSource audioSource;
        public AudioClip startHighlightSound;
        public AudioClip stopHighlightSound;
        public AudioClip teleportSound;

        float startPitch;

        private void OnEnable() {
            if(audioSource == null)
                audioSource = GetComponent<AudioSource>();
            if(teleportPoint == null)
                teleportPoint = GetComponent<TeleportPoint>();

            teleportPoint.StartHighlight.AddListener(OnStartHighlight);
            teleportPoint.StopHighlight.AddListener(OnStopHighlight);
            teleportPoint.OnTeleport.AddListener(OnTeleport);
            startPitch = audioSource.pitch;
        }

        private void OnDisable() {
            teleportPoint.StartHighlight.RemoveListener(OnStartHighlight);
            teleportPoint.StopHighlight.RemoveListener(OnStopHighlight);
            teleportPoint.OnTeleport.RemoveListener(OnTeleport);
        }

        void OnStartHighlight(TeleportPoint point, Teleporter raycaster) {
            if(audioSource != null && startHighlightSound != null) {
                audioSource.pitch = startPitch + Random.Range(-randomPitchRange, randomPitchRange);
                audioSource.PlayOneShot(startHighlightSound);
            }
        }

        void OnStopHighlight(TeleportPoint point, Teleporter raycaster) {
            if(audioSource != null && stopHighlightSound != null) {
                audioSource.pitch = startPitch + Random.Range(-randomPitchRange, randomPitchRange);
                audioSource.PlayOneShot(stopHighlightSound);
            }
        }

        void OnTeleport(TeleportPoint point, Teleporter raycaster) {
            if(audioSource != null && teleportSound != null) {
                audioSource.pitch = startPitch + Random.Range(-randomPitchRange, randomPitchRange);
                audioSource.PlayOneShot(teleportSound);
            }
        }


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Movement/TeleportPointSoundEffects.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/GrabbableEventDebugger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 84b1fb89c46159949aa89dc678cd2a5f
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;


namespace Autohand.Demo {
    [RequireComponent(typeof(Grabbable))]public class GrabbableEventDebugger : MonoBehaviour
    {
        Grabbable grab;

        private void OnEnable(){
            grab = GetComponent<Grabbable>();
            grab.OnBeforeGrabEvent += OnBeforeGrabbed;
            grab.OnGrabEvent += OnGrabbed;
            grab.OnReleaseEvent += OnReleased;
            grab.OnJointBreakEvent += OnJointBreakEvent;
            grab.OnSqueezeEvent += OnSqueeze;
            grab.OnUnsqueezeEvent += OnUnsqueeze;
            grab.OnHighlightEvent += OnHighlightStart;
            grab.OnUnhighlightEvent += OnHighlightStop;
        }

        private void OnDisable(){
            grab.OnBeforeGrabEvent -= OnBeforeGrabbed;
            grab.OnGrabEvent -= OnGrabbed;
            grab.OnReleaseEvent -= OnReleased;
            grab.OnJointBreakEvent -= OnJointBreakEvent;
            grab.OnSqueezeEvent -= OnSqueeze;
            grab.OnUnsqueezeEvent -= OnUnsqueeze;
            grab.OnHighlightEvent -= OnHighlightStart;
            grab.OnUnhighlightEvent -= OnHighlightStop;
        }

        void OnBeforeGrabbed(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " BEFORE GRABBED");
        }

        void OnGrabbed(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " GRABBED");
        }

        void OnReleased(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " RELEASED");
        }

        void OnHighlightStart(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " HIGHLIGHTED");
        }

        void OnHighlightStop(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " UNHIGHLIGHTED");
        }

        void OnJointBreakEvent(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " JOINT BROKE");
        }

        void OnSqueeze(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " SQUEEZED");
        }

        void OnUnsqueeze(Hand hand, Grabbable grabbable) {
            Debug.Log(grabbable.name + " UNSQUEEZED");
        }
    }


[RequireComponent(typeof(Grabbable))]
public class GrabbableRigidbodyGrabEvents : MonoBehaviour {
    public bool setGravityWhenGrabbed = true;
    public bool setKinematicWhenGrabbed = false;
    public bool setGravityWhenReleased = false;
    public bool setKinematicWhenReleased = true;
    Grabbable grab;

    private void OnEnable() {
        grab = GetComponent<Grabbable>();
        grab.OnGrabEvent += OnGrabbed;
        grab.OnReleaseEvent += OnReleased;
    }

    private void OnDisable() {
        grab.OnGrabEvent -= OnGrabbed;
        grab.OnReleaseEvent -= OnReleased;
    }

    void OnGrabbed(Hand hand, Grabbable grabbable) {
        grabbable.body.useGravity = setGravityWhenGrabbed;
        grabbable.body.isKinematic = setKinematicWhenGrabbed;
    }

    void OnReleased(Hand hand, Grabbable grabbable) {
        grabbable.body.useGravity = setGravityWhenReleased;
        grabbable.body.isKinematic = setKinematicWhenReleased;
    }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/GrabbableEventDebugger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandEventDebugger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d1cfa7fca3c60d543beef7d0783d75f7
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;


namespace Autohand.Demo {
    [RequireComponent(typeof(Hand))]
    public class HandEventDebugger : MonoBehaviour
    {
        public bool showSqueezeEvents = true;
        public bool showHighlightEvents = true;

        private void OnEnable()
        {
            var hand1 = GetComponent<Hand>();
            hand1.OnBeforeGrabbed += (hand, grabbable) => { Debug.Log(hand.name + " BEFORE GRAB EVENT", this); };
            hand1.OnGrabbed += (hand, grabbable) => { Debug.Log(hand.name + " GRAB EVENT", this); };
            hand1.OnReleased += (hand, grabbable) => { Debug.Log(hand.name + " RELEASE EVENT", this); };
            hand1.OnGrabJointBreak += (hand, grabbable) => { Debug.Log(hand.name + " JOINT BREAK EVENT", this); };
            
            if(showSqueezeEvents) hand1.OnSqueezed += (hand, grabbable) => { Debug.Log(hand.name + " SQUEEZE EVENT", this); };
            if (showSqueezeEvents) hand1.OnUnsqueezed += (hand, grabbable) => { Debug.Log(hand.name + " UNSQUEEZE EVENT", this); };
            if (showHighlightEvents) hand1.highlighter.OnHighlight += (hand, grabbable) => { Debug.Log(hand.name + " HIGHLIGHT EVENT", this); };
            if (showHighlightEvents) hand1.highlighter.OnStopHighlight += (hand, grabbable) => { Debug.Log(hand.name + " UNHIGHLIGHT EVENT", this); };
        }

        private void OnDisable()
        {
            var hand1 = GetComponent<Hand>();
            hand1.OnBeforeGrabbed -= (hand, grabbable) => { Debug.Log(hand.name + " BEFORE GRAB EVENT", this); };
            hand1.OnGrabbed -= (hand, grabbable) => { Debug.Log(hand.name + " GRAB EVENT", this); };
            hand1.OnReleased -= (hand, grabbable) => { Debug.Log(hand.name + " RELEASE EVENT", this); };
            hand1.OnGrabJointBreak -= (hand, grabbable) => { Debug.Log(hand.name + " CONNECTION BREAK EVENT", this); };
            
            if (showSqueezeEvents) hand1.OnSqueezed -= (hand, grabbable) => { Debug.Log(hand.name + " SQUEEZE EVENT", this); };
            if (showSqueezeEvents) hand1.OnUnsqueezed -= (hand, grabbable) => { Debug.Log(hand.name + " UNSQUEEZE EVENT", this); };
            if (showHighlightEvents) hand1.highlighter.OnHighlight -= (hand, grabbable) => { Debug.Log(hand.name + " HIGHLIGHT EVENT", this); };
            if (showHighlightEvents) hand1.highlighter.OnStopHighlight -= (hand, grabbable) => { Debug.Log(hand.name + " UNHIGHLIGHT EVENT", this); };
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandEventDebugger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandEventTemplate.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 94d60b2b26a806841ae31afd9e936101
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using Autohand;

public class HandEventTemplate : MonoBehaviour{
    public Hand hand;

    void OnEnable() {
        hand.OnBeforeGrabbed += OnBeforeGrabbed;
        hand.OnGrabbed += OnGrabbed;
        hand.OnBeforeReleased += OnBeforeReleased;
        hand.OnReleased += OnReleased;
        hand.OnForcedRelease += OnForcedRelease;
        hand.OnGrabJointBreak += OnGrabJointBreak;

        hand.OnHandCollisionStart += OnHandCollisionStart;
        hand.OnHandCollisionStop += OnHandCollisionStop;
        hand.OnHandTriggerStart += OnHandTriggerStart;
        hand.OnHandTriggerStop += OnHandTriggerStop;

        hand.highlighter.OnHighlight += OnHighlight;
        hand.highlighter.OnStopHighlight += OnStopHighlight;

        hand.OnSqueezed += OnSqueezed;
        hand.OnUnsqueezed += OnUnsqueezed;

        hand.OnTriggerGrab += OnTriggerGrab;
        hand.OnTriggerRelease += OnTriggerRelease;
    }


    void OnDisable() {
        hand.OnBeforeGrabbed -= OnBeforeGrabbed;
        hand.OnGrabbed -= OnGrabbed;
        hand.OnBeforeReleased -= OnBeforeReleased;
        hand.OnReleased -= OnReleased;
        hand.OnForcedRelease -= OnForcedRelease;
        hand.OnGrabJointBreak -= OnGrabJointBreak;


        hand.highlighter.OnHighlight -= OnHighlight;
        hand.highlighter.OnStopHighlight -= OnStopHighlight;

        hand.OnSqueezed -= OnSqueezed;
        hand.OnUnsqueezed -= OnUnsqueezed;

        hand.OnTriggerGrab -= OnTriggerGrab;
        hand.OnTriggerRelease -= OnTriggerRelease;


        hand.OnHandCollisionStart -= OnHandCollisionStart;
        hand.OnHandCollisionStop -= OnHandCollisionStop;
        hand.OnHandTriggerStart -= OnHandTriggerStart;
        hand.OnHandTriggerStop -= OnHandTriggerStop;
    }

    void OnBeforeGrabbed(Hand hand, Grabbable grab) {
        //Called when an object is grabbed before anything else
    }

    void OnGrabbed(Hand hand, Grabbable grab) {
        //Called when an object is grabbed
    }

    void OnBeforeReleased(Hand hand, Grabbable grab) {
        //Called when a held object is released before anything else
    }

    void OnReleased(Hand hand, Grabbable grab) {
        //Called when a held object is released
    }

    void OnForcedRelease(Hand hand, Grabbable grab) {
        //Called when the force release functions is called

    }


    void OnGrabJointBreak(Hand hand, Grabbable grab) {
        //Called when the joint between the hand the grabbable breaks
    }


    void OnHighlight(Hand hand, Grabbable grab) {
        //Called when the hand grab targets a new object
    }
    
    void OnStopHighlight(Hand hand, Grabbable grab) {
        //Called when the hand grab stops targeting an object
    }



    void OnSqueezed(Hand hand, Grabbable grab) {
        //Called when the "Squeeze" event is called, this event is tied to a seconary controller input through the HandControllerLink component on the hand
    }
    void OnUnsqueezed(Hand hand, Grabbable grab) {
        //Called when the "Unsqueeze" event is called, this event is tied to a seconary controller input through the HandControllerLink component on the hand
    }



    void OnTriggerGrab(Hand hand, Grabbable grab) {
        //Called when the "Grab" event is called, regardless of whether something is being grabbed or not
    }
    void OnTriggerRelease(Hand hand, Grabbable grab) {
        //Called when the "Release" event is called, regardless of whether something is being held or released
    }



    void OnHandCollisionStart(Hand hand, GameObject other) {
        //Called when the hand hits an object for the first time and isn't already colliding
    }

    void OnHandCollisionStop(Hand hand, GameObject other) {
        //Called all the hand has zero collisions on the object

    }

    void OnHandTriggerStart(Hand hand, GameObject other) {
        //Called when the hand triggers an object for the first time and isn't already triggering
    }

    void OnHandTriggerStop(Hand hand, GameObject other) {
        //Called when the hand has zero colliders overlapping this trigger
    }


}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandEventTemplate.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandTouchEventDebugger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 57c04f334190d304395f0d844ffe1f04
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {
    public class HandTouchEventDebugger : MonoBehaviour {
        public HandTouchEvent touchEvent;

        private void OnEnable() {
            touchEvent.HandStartTouchEvent += StartTouch;
            touchEvent.HandStopTouchEvent += StopTouch;
        }

        private void OnDisable() {
            touchEvent.HandStartTouchEvent -= StartTouch;
            touchEvent.HandStopTouchEvent -= StopTouch;
        }

        void StartTouch(Hand hand) {
            Debug.Log("Start Touch: " + hand.name);
        }
        void StopTouch(Hand hand) {
            Debug.Log("Stop Touch: " + hand.name);
        }
    }

}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/HandTouchEventDebugger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/PlacePointEventDebugger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0561c58c7b0c54947b3ac20a3aa6d8ab
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(PlacePoint))]
public class PlacePointEventDebugger : MonoBehaviour
{
    PlacePoint placePoint;

    void OnEnable()
    {
        placePoint = GetComponent<PlacePoint>();
        placePoint.OnPlaceEvent += (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Place: " + Time.time); };
        placePoint.OnRemoveEvent += (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Remove: " + Time.time); };
        placePoint.OnHighlightEvent += (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Highlight: " + Time.time); };
        placePoint.OnStopHighlightEvent += (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Stop Highlight: " + Time.time); };
    }


    void OnDisable()
    {
        placePoint = GetComponent<PlacePoint>();
        placePoint.OnPlaceEvent -= (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Place: " + Time.time); };
        placePoint.OnRemoveEvent -= (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Remove: " + Time.time); };
        placePoint.OnHighlightEvent -= (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Highlight: " + Time.time); };
        placePoint.OnStopHighlightEvent -= (PlacePoint point, Grabbable grabbable) => { Debug.Log(name + "On Stop Highlight: " + Time.time); };
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/PlacePointEventDebugger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/PlacePointEventTemplate.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 68ca9f1f64514ea44b259d8683f56c5a
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using Autohand;

public class PlacePointEventTemplate : MonoBehaviour {
    public PlacePoint placePoint;

    void OnEnable() {
        placePoint.OnPlaceEvent += OnPlace;
        placePoint.OnRemoveEvent += OnPlace;
        placePoint.OnHighlightEvent += OnHighlight;
        placePoint.OnStopHighlightEvent += OnStopHighlight;
    }

    private void OnDisable() {
        placePoint.OnPlaceEvent -= OnPlace;
        placePoint.OnRemoveEvent -= OnPlace;
        placePoint.OnHighlightEvent -= OnHighlight;
        placePoint.OnStopHighlightEvent -= OnStopHighlight;

    }


    public void OnPlace(PlacePoint point, Grabbable grab) {
        //Stuff happens when placed
    }


    public void OnRemove(PlacePoint point, Grabbable grab) {
        //Stuff happens when placed was removed

    }
    public void OnHighlight(PlacePoint point, Grabbable grab) {
        //Stuff happens when placepoint was highlighted

    }

    public void OnStopHighlight(PlacePoint point, Grabbable grab) {
        //Stuff happens when placepoint was done highlighting
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Templates/PlacePointEventTemplate.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/AutoHandSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0bda962a91c41024b9c86bcb7cb57d2f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class AutoHandSettings : ScriptableObject{
    [Tooltip("Whether the popup should be ignored on launch or not")]
    public bool ignoreSetup = false;
    public bool usingDynamicTimestep = true;
    public bool useAutomaticControllerOffset = true;
    [Tooltip("-1 is custom, 0 is low, 1 is medium, 2 is high")]
    public float quality = -1;

    public static void ClearSettings() {
        var _handSettings = Resources.Load<AutoHandSettings>("AutoHandSettings");
        _handSettings.ignoreSetup = false;
        _handSettings.usingDynamicTimestep = true;
        _handSettings.quality = -1;
#if UNITY_EDITOR
        UnityEditor.EditorUtility.SetDirty(_handSettings);
#endif
    }
    public static bool UsingDynamicTimestep() {
        var _handSettings = Resources.Load<AutoHandSettings>("AutoHandSettings");
        return _handSettings.usingDynamicTimestep;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/AutoHandSettings.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/AutoInputModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f3db25e7af68fae448be32ac1f37480f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine.EventSystems;
using UnityEngine;

namespace Autohand
{
    public class AutoInputModule : BaseInputModule
    {
        private List<HandCanvasPointer> pointers = new List<HandCanvasPointer>();
        private PointerEventData[] eventDatas;

        AutoInputModule _instance;
        private bool _isDestroyed = false;

        /// <summary>Returns the current pointer being checked when triggering input events, should only be used during built in UI input events</summary>
        public HandCanvasPointer currentPointer { get; private set; }

        public AutoInputModule Instance
        {
            get
            {
                if (_isDestroyed)
                    return null;

                if (_instance == null)
                {
                    if (!(_instance = AutoHandExtensions.CanFindObjectOfType<AutoInputModule>()))
                    {
                        _instance = new GameObject().AddComponent<AutoInputModule>();
                        _instance.transform.parent = AutoHandExtensions.transformParent;
                    }



                    EventSystem[] system = null;
                    BaseInputModule[] inputModule;

                    inputModule = AutoHandExtensions.CanFindObjectsOfType<BaseInputModule>();
                    if (inputModule.Length > 1)
                    {
                        for (int i = inputModule.Length - 1; i >= 0; i--)
                        {
                            if (!inputModule[i].gameObject.GetComponent<AutoInputModule>())
                                Destroy(inputModule[i]);
                            Debug.LogWarning("AUTO HAND:  REMOVING ADDITIONAL EVENT SYSTEMS FROM THE SCENE");
                        }
                    }

                    system = AutoHandExtensions.CanFindObjectsOfType<EventSystem>();
                    if (system.Length > 1)
                    {
                        for (int i = system.Length - 1; i >= 0; i--)
                        {
                            if (!system[i].gameObject.GetComponent<AutoInputModule>())
                                Destroy(system[i]);
                            Debug.LogWarning("AUTO HAND:  REMOVING ADDITIONAL EVENT SYSTEMS FROM THE SCENE");
                        }
                    }

                }

                return _instance;
            }
        }

        protected override void Awake()
        {
            base.Awake();
        }

        protected override void OnDestroy()
        {
            _isDestroyed = true;
        }

        public int AddPointer(HandCanvasPointer pointer)
        {
            if (!pointers.Contains(pointer))
            {
                pointers.Add(pointer);
                eventDatas = new PointerEventData[pointers.Count];

                for (int i = 0; i < eventDatas.Length; i++)
                {
                    eventDatas[i] = new PointerEventData(eventSystem);
                    eventDatas[i].delta = Vector2.zero;
                    eventDatas[i].position = new Vector2(Screen.width / 2, Screen.height / 2);
                }
            }

            return pointers.IndexOf(pointer);
        }

        public void RemovePointer(HandCanvasPointer pointer)
        {
            int pIndex = pointers.IndexOf(pointer);
            ProcessRelease(pIndex);
            ProcessExit(pIndex);

            if (pointers.Contains(pointer))
                pointers.Remove(pointer);
            foreach (var point in pointers)
            {
                point.SetIndex(pointers.IndexOf(point));
            }
            eventDatas = new PointerEventData[pointers.Count];
            for (int i = 0; i < eventDatas.Length; i++)
            {
                eventDatas[i] = new PointerEventData(eventSystem);
                eventDatas[i].delta = Vector2.zero;
                eventDatas[i].position = new Vector2(Screen.width / 2, Screen.height / 2);
            }
        }

        public override void Process()
        {
#pragma warning disable
            for (int index = 0; index < pointers.Count; index++)
            {
                try
                {
                    if (pointers[index] != null && pointers[index].enabled)
                    {
                        currentPointer = pointers[index];
                        pointers[index].Preprocess();
                        // Hooks in to Unity's event system to handle hovering
                        eventSystem.RaycastAll(eventDatas[index], m_RaycastResultCache);
                        eventDatas[index].pointerCurrentRaycast = FindFirstRaycast(m_RaycastResultCache);

                        HandlePointerExitAndEnter(eventDatas[index], eventDatas[index].pointerCurrentRaycast.gameObject);

                        ExecuteEvents.Execute(eventDatas[index].pointerDrag, eventDatas[index], ExecuteEvents.dragHandler);
                    }

                }
                catch { }
            }
#pragma warning restore
        }

        public void ProcessPress(int index)
        {
            pointers[index].Preprocess();
            // Hooks in to Unity's event system to process a release
            eventDatas[index].pointerPressRaycast = eventDatas[index].pointerCurrentRaycast;

            eventDatas[index].pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(eventDatas[index].pointerPressRaycast.gameObject);
            eventDatas[index].pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(eventDatas[index].pointerPressRaycast.gameObject);

            ExecuteEvents.Execute(eventDatas[index].pointerPress, eventDatas[index], ExecuteEvents.pointerDownHandler);
            ExecuteEvents.Execute(eventDatas[index].pointerDrag, eventDatas[index], ExecuteEvents.beginDragHandler);
        }

        public void ProcessRelease(int index)
        {
            pointers[index].Preprocess();
            // Hooks in to Unity's event system to process a press
            GameObject pointerRelease = ExecuteEvents.GetEventHandler<IPointerClickHandler>(eventDatas[index].pointerCurrentRaycast.gameObject);

            if (eventDatas[index].pointerPress == pointerRelease)
                ExecuteEvents.Execute(eventDatas[index].pointerPress, eventDatas[index], ExecuteEvents.pointerClickHandler);

            ExecuteEvents.Execute(eventDatas[index].pointerPress, eventDatas[index], ExecuteEvents.pointerUpHandler);
            ExecuteEvents.Execute(eventDatas[index].pointerDrag, eventDatas[index], ExecuteEvents.endDragHandler);

            eventDatas[index].pointerPress = null;
            eventDatas[index].pointerDrag = null;

            eventDatas[index].pointerCurrentRaycast.Clear();
        }

        public void ProcessExit(int index) {
            GameObject pointerRelease = ExecuteEvents.GetEventHandler<IPointerExitHandler>(eventDatas[index].pointerCurrentRaycast.gameObject);
            ExecuteEvents.Execute(pointerRelease, eventDatas[index], ExecuteEvents.pointerExitHandler);
        }

        public PointerEventData GetData(int index) { return eventDatas[index]; }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/AutoInputModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionIgnores.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fe6db899177c9e348ba7b46314349499
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CollisionIgnores : MonoBehaviour {
    public bool disableOnStart = true;
    public Collider[] cols1;
    public Collider[] cols2;

    void Start() {
        DisableCollisions();
    }

    public void EnableCollisions() {
        for(int i = 0; i < cols1.Length; i++)
            for(int j = 0; j < cols2.Length; j++)
                Physics.IgnoreCollision(cols1[i], cols2[j], false);
    }

    public void DisableCollisions() {
        for(int i = 0; i < cols1.Length; i++)
            for(int j = 0; j < cols2.Length; j++)
                Physics.IgnoreCollision(cols1[i], cols2[j], true);
    }


}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionIgnores.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionSound.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1c498b8ff53f43d43bb5f3b6001c2364
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/collision-sounds")]
public class CollisionSound : MonoBehaviour{
    [Tooltip("The layers that cause the sound to play")]
    public LayerMask collisionTriggers = ~0;
    [Tooltip("Source to play sound from")]
    public AudioSource source;
    [Tooltip("Source to play sound from")]
    public AudioClip clip;
    [Space]
    [Tooltip("Source to play sound from")]
    public AnimationCurve velocityVolumeCurve = AnimationCurve.Linear(0, 0, 1, 1);

    public float volumeAmp = 0.8f;
    public float velocityAmp = 0.5f;
    public float soundRepeatDelay = 0.2f;

    Rigidbody body;
    bool canPlaySound = true;
    Coroutine playSoundRoutine;

    private void Start() {
        body = GetComponent<Rigidbody>();

        //So the sound doesn't play when falling in place on start
        StartCoroutine(SoundPlayBuffer(1f));
    }

    private void OnDisable(){
        if (playSoundRoutine != null)
            StopCoroutine(playSoundRoutine);
    }

    void OnCollisionEnter(Collision collision) {
        if (body == null && !gameObject.CanGetComponent(out body))
            return;

        if(canPlaySound && collisionTriggers == (collisionTriggers | (1 << collision.gameObject.layer))) {
            if(source != null && source.enabled){
                if (collision.collider.attachedRigidbody == null || collision.collider.attachedRigidbody.mass > 0.0000001f){
                    if(clip != null || source.clip != null)
                        source.PlayOneShot(clip == null ? source.clip : clip, velocityVolumeCurve.Evaluate(collision.relativeVelocity.magnitude * velocityAmp) * volumeAmp);
                    if (playSoundRoutine != null)
                        StopCoroutine(playSoundRoutine);
                    playSoundRoutine = StartCoroutine(SoundPlayBuffer());
                }
            }
        }
    }

    IEnumerator SoundPlayBuffer() {
        canPlaySound = false;
        yield return new WaitForSeconds(soundRepeatDelay);
        canPlaySound = true;
        playSoundRoutine = null;
    }

    IEnumerator SoundPlayBuffer(float time) {
        canPlaySound = false;
        yield return new WaitForSeconds(time);
        canPlaySound = true;
        playSoundRoutine = null;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionSound.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 21360bf2f4ba84149856028de8de2c89
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public delegate void CollisionEvent(GameObject from);

    public class CollisionTracker : MonoBehaviour {

        public bool disableCollisionTracking = false;
        public bool disableTriggersTracking = false;

        public event CollisionEvent OnCollisionFirstEnter;
        public event CollisionEvent OnCollisionLastExit;
        public event CollisionEvent OnTriggerFirstEnter;

        public event CollisionEvent OnTriggerLastExit; // todo fix typo?

        public int collisionCount { get { return collisionObjects.Count; } }
        public int triggerCount { get { return triggerObjects.Count; } }

        const int MAX_COLLISIONS_TRACKED = 256;

        public List<GameObject> triggerObjects { get; protected set; } = new List<GameObject>(MAX_COLLISIONS_TRACKED);

        public List<GameObject> collisionObjects { get; protected set; } = new List<GameObject>(MAX_COLLISIONS_TRACKED);

        public List<GameObject> nextTriggerObjects { get; protected set; } = new List<GameObject>(MAX_COLLISIONS_TRACKED);

        public List<GameObject> nextCollisionObjects { get; protected set; } = new List<GameObject>(MAX_COLLISIONS_TRACKED);

        protected List<Collision> collisions { get; set; } = new List<Collision>(MAX_COLLISIONS_TRACKED);

        Coroutine lateFixedUpdate;

        public void CleanUp() {
            triggerObjects.Clear();
            nextTriggerObjects.Clear();
            collisionObjects.Clear();
            nextCollisionObjects.Clear();
            collisions.Clear();
        }

        protected virtual void OnEnable() {
            lateFixedUpdate = StartCoroutine(LateFixedUpdate());
        }

        protected virtual void OnDisable() {
            for(int i = 0; i < collisionObjects.Count; i++) {
                if(collisionObjects[i] && OnCollisionLastExit != null)
                    OnCollisionLastExit.Invoke(collisionObjects[i]);
            }
            for(int i = 0; i < triggerObjects.Count; i++) {
                if(triggerObjects[i] && OnTriggerLastExit != null)
                        OnTriggerLastExit.Invoke(triggerObjects[i]);
            }
            CleanUp();

            StopCoroutine(lateFixedUpdate);
        }

        WaitForFixedUpdate waitForFixed = new WaitForFixedUpdate();
        IEnumerator LateFixedUpdate() {
            // using late fixed update so the events get fired in the same cycle as the collision updates happened
            while(true) {
                yield return waitForFixed;

                CheckTrackedObjects();
            }
        }

        private void CheckTrackedObjects() {
            if(!disableCollisionTracking) {
                for(int i = 0; i < collisionObjects.Count; i++) {
                    if(!collisionObjects[i].activeInHierarchy ||
                        !nextCollisionObjects.Contains(collisionObjects[i])) {
                        if(OnCollisionLastExit != null)
                            OnCollisionLastExit.Invoke(collisionObjects[i]);
                    }
                }

                for(int i = 0; i < nextCollisionObjects.Count; i++) {
                    if(nextCollisionObjects[i] == null ||
                    !nextCollisionObjects[i].activeInHierarchy) {
                        nextCollisionObjects.RemoveAt(i);
                    }
                    else if(!collisionObjects.Contains(nextCollisionObjects[i])) {
                        if(OnCollisionFirstEnter != null)
                            OnCollisionFirstEnter.Invoke(nextCollisionObjects[i]);
                    }
                }

                collisionObjects.Clear();
                collisionObjects.AddRange(nextCollisionObjects);
                nextCollisionObjects.Clear();
                collisions.Clear();
            }

            if(!disableTriggersTracking) {
                for(int i = 0; i < triggerObjects.Count; i++) {
                    if(!triggerObjects[i].activeInHierarchy ||
                        !nextTriggerObjects.Contains(triggerObjects[i])) {
                        if(OnTriggerLastExit != null)
                            OnTriggerLastExit.Invoke(triggerObjects[i]);
                    }
                }

                for(int i = 0; i < nextTriggerObjects.Count; i++) {
                    if(nextTriggerObjects[i] == null ||
                    !nextTriggerObjects[i].activeInHierarchy) {
                        nextTriggerObjects.RemoveAt(i);
                    }
                    else if(!triggerObjects.Contains(nextTriggerObjects[i])) {
                        if(OnTriggerFirstEnter != null)
                            OnTriggerFirstEnter.Invoke(nextTriggerObjects[i]);
                    }
                }

                triggerObjects.Clear();
                triggerObjects.AddRange(nextTriggerObjects);
                nextTriggerObjects.Clear();
            }
        }

        protected virtual void OnCollisionStay(Collision collision) {
            if(!disableCollisionTracking) {
                collisions.Add(collision);

                if(!nextCollisionObjects.Contains(collision.collider.gameObject)) {
                    nextCollisionObjects.Add(collision.collider.gameObject);
                }
            }
        }

        protected virtual void OnTriggerStay(Collider other) {
            if(!disableTriggersTracking) {
                if(!nextTriggerObjects.Contains(other.gameObject)) {
                    nextTriggerObjects.Add(other.gameObject);
                }
            }
        }

//#if UNITY_EDITOR
//        private void OnDrawGizmos() {
//            foreach(var collision in collisions) {
//                foreach(var contactPoint in collision.contacts) {
//                    Gizmos.DrawSphere(contactPoint.point, 0.0025f);
//                }
//            }
//        }
//#endif
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/CollisionTracker.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/HandCanvasPointer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 596e2cdbad5de264abd332ce27c9e3e9
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

namespace Autohand
{
    [Serializable]
    public class UnityCanvasPointerEvent : UnityEvent<Vector3, GameObject> { }

    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/ui-interaction"), DefaultExecutionOrder(10000)]
    public class HandCanvasPointer : MonoBehaviour
    {
        [Header("References")]
        public GameObject hitPointMarker;
        private LineRenderer lineRenderer;
        public bool useSmoothing = true;
        public float forwardPointerSmoothing = 25f;


        [Header("Ray settings")]
        public float raycastLength = 8.0f;
        public bool autoShowTarget = true;
        public LayerMask UILayer;


        [Header("Events")]
        public UnityCanvasPointerEvent StartSelect;
        public UnityCanvasPointerEvent StopSelect;
        public UnityCanvasPointerEvent StartPoint;
        public UnityCanvasPointerEvent StopPoint;



        private GameObject _currTarget;
        public GameObject currTarget
        {
            get { return _currTarget; }
        }

        private float _currDistance;
        public float? CurrentDistance {
            get {
                return (_currTarget == null ? null : _currDistance);
            }
        }

        Vector3 currentSmoothForward;


        public RaycastHit lastHit { get; private set; }

        // Internal variables
        private bool hover = false;
        AutoInputModule inputModule = null;
        float lineSegements = 10f;

        bool beingDestroyed = false;
        static Camera cam = null;
        public static Camera UICamera
        {
            get
            {
                if (cam == null)
                {
                    cam = new GameObject("Camera Canvas Pointer (I AM CREATED AT RUNTIME FOR UI CANVAS INTERACTION, I AM NOT RENDERING ANYTHING, I AM NOT CREATING ADDITIONAL OVERHEAD)").AddComponent<Camera>();
                    cam.clearFlags = CameraClearFlags.Nothing;
                    cam.stereoTargetEye = StereoTargetEyeMask.None;
                    cam.orthographic = true;
                    cam.orthographicSize = 0.001f;
                    cam.cullingMask = 0;
                    cam.nearClipPlane = 0.001f;
                    cam.depth = 0f;
                    cam.allowHDR = false;
                    cam.enabled = false;
                    cam.fieldOfView = 0.00001f;
                    cam.transform.parent = AutoHandExtensions.transformParent;

#if (UNITY_2020_3_OR_NEWER)
                    var canvases = AutoHandExtensions.CanFindObjectsOfType<Canvas>(true);
#else
                    var canvases = FindObjectsOfType<Canvas>();
#endif
                    foreach(var canvas in canvases) {
                        if(canvas.renderMode == RenderMode.WorldSpace)
                            canvas.worldCamera = cam;
                    }

                }
                return cam;
            }
        }
        int pointerIndex;

        protected virtual void OnEnable()
        {

            if(lineRenderer != null)
                lineRenderer.positionCount = (int)lineSegements;
            if (inputModule.Instance != null)
                pointerIndex = inputModule.Instance.AddPointer(this);
            ShowRay(false);
        }

        protected virtual void OnDisable()
        {
            if(inputModule) inputModule.Instance?.RemovePointer(this);
        }

        protected virtual void OnDestroy() {
            beingDestroyed = true;
            if(cam != null)
                Destroy(cam.gameObject);
            cam = null;
        }

        public void SetIndex(int index)
        {
            pointerIndex = index;
        }

        protected internal virtual void Preprocess()
        {
            if(beingDestroyed) return;

            UICamera.farClipPlane = raycastLength;
            UICamera.transform.position = transform.position;
            UICamera.transform.forward = currentSmoothForward;
        }

        public virtual void Press() {
            // Handle the UI events
            if(inputModule) inputModule.ProcessPress(pointerIndex);

            // Show the ray when they attemp to press
            if(!autoShowTarget && hover) ShowRay(true);

            PointerEventData data = inputModule.GetData(pointerIndex);
            if(data != null && data.selectedObject != null) {
                StartSelect?.Invoke(data.pointerCurrentRaycast.worldPosition, data.selectedObject);
            }
        }

        public virtual void Release()
        {
            // Handle the UI events
            if(inputModule) inputModule.ProcessRelease(pointerIndex);

            PointerEventData data = inputModule.GetData(pointerIndex);
            var selectedObject = data.selectedObject;
            if(selectedObject != null) 
                StopSelect?.Invoke(data.pointerCurrentRaycast.worldPosition, selectedObject);
        }

        protected virtual void Awake()
        {
            if (lineRenderer == null)
                gameObject.CanGetComponent(out lineRenderer);

            if (inputModule == null)
            {
                if (gameObject.CanGetComponent<AutoInputModule>(out var inputMod))
                {
                    inputModule = inputMod;
                }
                else if (!(inputModule = AutoHandExtensions.CanFindObjectOfType<AutoInputModule>()))
                {
                    EventSystem system = AutoHandExtensions.CanFindObjectOfType<EventSystem>();
                    if(system == null) {
                        system = new GameObject().AddComponent<EventSystem>();
                        system.name = "UI Input Event System";
                    }
                    inputModule = system.gameObject.AddComponent<AutoInputModule>();
                    inputModule.transform.parent = AutoHandExtensions.transformParent;
                }
            }
        }

        protected virtual void LateUpdate()
        {
            if(useSmoothing) {
                var currentAngleDistance = Vector3.Angle(currentSmoothForward, transform.forward);
                currentSmoothForward = Vector3.RotateTowards(currentSmoothForward, transform.forward, Time.deltaTime * forwardPointerSmoothing + Time.deltaTime * forwardPointerSmoothing * currentAngleDistance, 1000f);
                currentSmoothForward.Normalize();
            }
            else
                currentSmoothForward = transform.forward;

            UpdateLine();
        }

        protected virtual void UpdateLine()
        {

            PointerEventData data = inputModule.GetData(pointerIndex);
            float targetLength = data.pointerCurrentRaycast.gameObject == null ? raycastLength : data.pointerCurrentRaycast.distance;

            if(targetLength > 0) {
                _currTarget = data.pointerCurrentRaycast.gameObject;
                _currDistance = targetLength;
            }
            else {
                _currTarget = null;
            }

            if (data.pointerCurrentRaycast.gameObject != null && !hover){
                lastHit = CreateRaycast(targetLength);
                Vector3 endPosition = transform.position + (currentSmoothForward * targetLength);
                if (lastHit.collider) endPosition = lastHit.point;


                if(lastHit.collider != null) {
                    currentSmoothForward = transform.forward;
                    StartPoint?.Invoke(lastHit.point, lastHit.transform.gameObject);
                }
                else {
                    currentSmoothForward = transform.forward;
                    StartPoint?.Invoke(endPosition, null);
                }


                // Show the ray if autoShowTarget is on when they enter the canvas
                if (autoShowTarget) ShowRay(true);

                hover = true;
            }
            else if (data.pointerCurrentRaycast.gameObject == null && hover){
                lastHit = CreateRaycast(targetLength);
                Vector3 endPosition = transform.position + (currentSmoothForward * targetLength);
                if (lastHit.collider) endPosition = lastHit.point;

                if (lastHit.collider != null)
                    StopPoint?.Invoke(lastHit.point, lastHit.transform.gameObject);
                else
                    StopPoint?.Invoke(endPosition, null);

                // Hide the ray when they leave the canvas
                ShowRay(false);
                hover = false;
            }

            if(hover) {
                lastHit = CreateRaycast(targetLength);

                Vector3 endPosition = transform.position + (currentSmoothForward * targetLength);

                //Handle the hitmarker
                hitPointMarker.transform.position = endPosition;
                hitPointMarker.transform.forward = data.pointerCurrentRaycast.worldNormal;

                if(lastHit.collider) {
                    endPosition = lastHit.point;
                    hitPointMarker.transform.forward = lastHit.collider.transform.forward;
                    hitPointMarker.transform.position = endPosition + hitPointMarker.transform.forward * 0.002f;
                }

                //Handle the line renderer
                for(int i = 0; i < lineSegements; i++) {
                    lineRenderer.SetPosition(i, Vector3.Lerp(transform.position, endPosition, i/ lineSegements));
                }
            }



        }

        protected virtual RaycastHit CreateRaycast(float dist){
            RaycastHit hit;
            Ray ray = new Ray(transform.position, currentSmoothForward);
            Physics.Raycast(ray, out hit, dist, UILayer);

            return hit;
        }

        protected virtual void ShowRay(bool show) {
            if(hitPointMarker != null)
                hitPointMarker.SetActive(show);
            if(lineRenderer != null)
                lineRenderer.enabled = show;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/HandCanvasPointer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/MagneticBody.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eacc0ab70f0b8b64b9bbcbbac3d66d1e
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using UnityEngine;

[ HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/magnetic-forces")]
public class MagneticBody : MonoBehaviour
{
    public Rigidbody body;
    public int magneticIndex = 0;
    public float strengthMultiplyer = 1f;
    public UnityMagneticEvent magneticEnter;
    public UnityMagneticEvent magneticExit;

    private void Start() {
        if(body == null)
            body = GetComponent<Rigidbody>();
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/MagneticBody.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/MagneticSource.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0e00af7538f45324194b5c1361e5c854
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand {
    public enum MagnetEffect {
        Attractive,
        Repulsive
    }

    [Serializable]
    public class UnityMagneticEvent : UnityEvent<MagneticSource, MagneticBody> { }

    [Serializable]
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/magnetic-forces")]
    public class MagneticSource : MonoBehaviour {
        public Rigidbody body;
        public MagnetEffect magneticEffect;
        public float strength = 10f;
        public float radius = 4f;
        public ForceMode forceMode = ForceMode.Force;
        public AnimationCurve forceDistanceCurce = AnimationCurve.Linear(0, 0, 1, 1);
        public int magneticIndex = 0;
        public UnityMagneticEvent magneticEnter;
        public UnityMagneticEvent magneticExit;

        List<MagneticBody> magneticBodies = new List<MagneticBody>();
        float radiusScale;
        private void Start() {
            if(body == null)
                body = GetComponent<Rigidbody>();
            radiusScale = transform.lossyScale.x < transform.lossyScale.y ? transform.lossyScale.x : transform.lossyScale.y;
            radiusScale = radiusScale < transform.lossyScale.z ? radiusScale : transform.lossyScale.z;
        }

        private void FixedUpdate() {
            foreach(var magneticBody in magneticBodies) {
                var position = transform.position;
                var otherPosition = magneticBody.transform.position;
                var distance = Vector3.Distance(position, otherPosition);
                if(distance < radius * radiusScale) {
                    var distanceValue = distance / (radius * radiusScale + 0.0001f);
                    var distanceMulti = forceDistanceCurce.Evaluate(distanceValue) * magneticBody.strengthMultiplyer * strength;
                    distanceMulti *= magneticEffect == MagnetEffect.Repulsive ? -1 : 1;
                    magneticBody.body.AddForce((position - otherPosition).normalized * distanceMulti, forceMode);
                }
            }
        }

        private void OnTriggerEnter(Collider other) {
            if(other.attachedRigidbody != null && other.CanGetComponent<MagneticBody>(out var magnetBody)) {
                if(!magneticBodies.Contains(magnetBody) && magnetBody.magneticIndex == magneticIndex) {
                    magneticBodies.Add(magnetBody);
                    magneticEnter?.Invoke(this, magnetBody);
                    magnetBody.magneticEnter?.Invoke(this, magnetBody);
                }

            }
        }

        private void OnTriggerExit(Collider other) {
            if(other.attachedRigidbody != null && other.CanGetComponent<MagneticBody>(out var magnetBody)) {
                if(magneticBodies.Contains(magnetBody)) {
                    magneticBodies.Remove(magnetBody);
                    magneticExit?.Invoke(this, magnetBody);
                    magnetBody.magneticExit?.Invoke(this, magnetBody);
                }
            }
        }


        private void OnDrawGizmosSelected() {
            Gizmos.color = Color.blue;
            var radiusScale = transform.lossyScale.x < transform.lossyScale.y ? transform.lossyScale.x : transform.lossyScale.y;
            radiusScale = radiusScale < transform.lossyScale.z ? radiusScale : transform.lossyScale.z;
            Gizmos.DrawWireSphere(transform.position, radius * radiusScale);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/MagneticSource.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/PhysicsFollower.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b6ef29e56e28a9341a4a527879bc24ae
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    [RequireComponent(typeof(Rigidbody)), DefaultExecutionOrder(-1)]
    public class PhysicsFollower : MonoBehaviour{
        [Header("Follow Settings"), Space]
        [Tooltip("Follow target, the hand will always try to match this transforms rotation and position with rigidbody movements")]
        public Transform follow;

        [Tooltip("Stops hand physics follow - to freeze from all forces change rigidbody to kinematic or change rigidbody constraints")]
        public bool freezePos = false;

        [Tooltip("Stops hand physics follow - to freeze from all forces change rigidbody to kinematic or change rigidbody constraints")]
        public bool freezeRot = false;
        
        [Tooltip("This will offset the position without offsetting the rotation pivot")]
        public Vector3 followPositionOffset;
        public Vector3 rotationOffset;

        [Tooltip("Follow target speed (This will cause jittering if turned too high)"), Min(0)]
        public float followPositionStrength = 30;

        [Tooltip("Follow target rotation speed (This will cause jittering if turned too high)"), Min(0)]
        public float followRotationStrength = 30;

        [Tooltip("The maximum allowed velocity of the hand"), Min(0)]
        public float maxVelocity = 5;
        
        
        internal Rigidbody body;
        Transform moveTo;
        
        public void Start() {
            Set();
        }

        public virtual void Set() {
            if(moveTo == null){
                moveTo = new GameObject().transform;
                moveTo.name = gameObject.name + " FOLLOW POINT";
                moveTo.parent = follow.parent;
                moveTo.position = follow.transform.position;
                moveTo.rotation = follow.transform.rotation;
                body = GetComponent<Rigidbody>();
            }
        }
        
        public void Update() {
            OnUpdate();
        }

        protected virtual void OnUpdate() {
            if(follow == null)
                return;

            //Sets [Move To] Object
            moveTo.position = follow.position + transform.rotation*followPositionOffset;
            moveTo.rotation = follow.rotation * Quaternion.Euler(rotationOffset);
        }


        public void FixedUpdate() {
            OnFixedUpdate();
        }

        protected virtual void OnFixedUpdate() {
            if(follow == null)
                return;
            
            //Sets [Move To] Object
            moveTo.position = follow.position + transform.rotation*followPositionOffset;
            moveTo.rotation = follow.rotation * Quaternion.Euler(rotationOffset);

            //Calls physics movements
            if(!freezePos) MoveTo();
            if(!freezeRot) TorqueTo();

        }


        /// <summary>Moves the hand to the controller position using physics movement</summary>
        internal virtual void MoveTo() {
            if(followPositionStrength <= 0)
                return;

            var movePos = moveTo.position;
            var distance = Vector3.Distance(movePos, transform.position);
            var velocityClamp = maxVelocity;
            
            
            //Sets velocity linearly based on distance from hand
            var vel = (movePos - transform.position).normalized * followPositionStrength * distance;
            vel.x = Mathf.Clamp(vel.x, -velocityClamp, velocityClamp);
            vel.y = Mathf.Clamp(vel.y, -velocityClamp, velocityClamp);
            vel.z = Mathf.Clamp(vel.z, -velocityClamp, velocityClamp);
            body.linearVelocity = vel;
        }


        /// <summary>Rotates the hand to the controller rotation using physics movement</summary>
        internal virtual void TorqueTo() {
            var toRot = moveTo.rotation;
            float angleDist = Quaternion.Angle(body.rotation, toRot);
            Quaternion desiredRotation = Quaternion.Lerp(body.rotation, toRot, Mathf.Clamp(angleDist, 0, 2) / 4f);

            var kp = 90f * followRotationStrength;
            var kd = 60f;
            Vector3 x;
            float xMag;
            Quaternion q = desiredRotation * Quaternion.Inverse(transform.rotation);
            q.ToAngleAxis(out xMag, out x);
            x.Normalize();
            x *= Mathf.Deg2Rad;
            Vector3 pidv = kp * x * xMag - kd * body.angularVelocity;
            Quaternion rotInertia2World = body.inertiaTensorRotation * transform.rotation;
            pidv = Quaternion.Inverse(rotInertia2World) * pidv;
            pidv.Scale(body.inertiaTensor);
            pidv = rotInertia2World * pidv;
            body.AddTorque(pidv);
        }

        private void OnDestroy() {
            Destroy(moveTo.gameObject);
        }
    }

  
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/PhysicsFollower.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Smash.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 07d975bb4661eb244a698f2a75d13fe3
# ASMDEF: AutoHandAssembly.dll
# ---
using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand.Demo{
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/smashing")]
    public class Smash : MonoBehaviour{
        [Header("Smash Options")]
        [Tooltip("Required velocity magnitude from Smasher to smash")]
        public float smashForce = 1;
        [Tooltip("Whether or not to destroy this object on smash")]
        public bool destroyOnSmash = false;
        [Tooltip("Whether or not to release this object on smash")]
        [HideIf("destroyOnSmash")]
        public bool releaseOnSmash = false;

        [Header("Particle Effect")]
        [Tooltip("Plays this effect on smash")]
        public ParticleSystem effect;
        [Tooltip("Whether or not to instantiates a new a particle system on smash")]
        public bool createNewEffect = true;
        [Tooltip("Whether or not to apply rigidbody velocity to particle velocity on smash")]
        public bool applyVelocityOnSmash = true;
        
        [Header("Sound Options")]
        public AudioClip smashSound;
        public float smashVolume = 1f;
        

        [Header("Event")]
        public UnityEvent OnSmash;
        
        //Progammer Events <3
        public SmashEvent OnSmashEvent;


        internal Grabbable grabbable;

        public void Start() {
            if(!(grabbable = GetComponent<Grabbable>())){
                GrabbableChild grabChild;
                if(grabChild = GetComponent<GrabbableChild>())
                    grabbable = grabChild.grabParent;
            }

            OnSmashEvent += (smasher, smashable) => { OnSmash?.Invoke(); };
        }


        public void DelayedSmash(float delay) {
            Invoke("DoSmash", delay);
        }


        public void DoSmash() {
            DoSmash(null);
        }


        public void DoSmash(Smasher smash){
            if(effect){
                ParticleSystem particles;
                if(createNewEffect)
                    particles = Instantiate(effect, grabbable.transform.position, grabbable.transform.rotation);
                else
                    particles = effect;

                particles.transform.parent = null;
                particles.Play();

                Rigidbody rb;
                if(applyVelocityOnSmash && ((rb = grabbable.body) || gameObject.CanGetComponent(out rb))){
                    ParticleSystem.VelocityOverLifetimeModule module = particles.velocityOverLifetime;
                    module.x = rb.linearVelocity.x;
                    module.y = rb.linearVelocity.y;
                    module.z = rb.linearVelocity.z;
                }
            }

            //Play the audio sound
            if(smashSound)
                AudioSource.PlayClipAtPoint(smashSound, transform.position, smashVolume);

            OnSmashEvent?.Invoke(smash, this);

            if((destroyOnSmash || releaseOnSmash) && grabbable)
                grabbable.ForceHandsRelease();

            if(destroyOnSmash)
                Destroy(gameObject);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Smash.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Smasher.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fad2f22fe18c2bf46b033941144afa2e
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using UnityEngine.Events;

namespace Autohand.Demo{
    public delegate void SmashEvent(Smasher smasher, Smash smashable);

    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/smashing")]
    public class Smasher : MonoBehaviour{
        public Rigidbody rb;
        [Header("Options")]
        public LayerMask smashableLayers;
        [Tooltip("How much to multiply the magnitude on smash")]
        public float forceMulti = 1;
        [Tooltip("Can be left empty - The center of mass point to calculate velocity magnitude - for example: the camera of the hammer is a better point vs the pivot center of the hammer object")]
        public Transform centerOfMassPoint;

        [Header("Event")]
        public UnityEvent OnSmash;

        //Progammer Events <3
        public SmashEvent OnSmashEvent;

        Vector3[] velocityOverTime = new Vector3[3];
        Vector3 lastPos;
    
        private void Start(){
            if(rb == null)
                rb = GetComponent<Rigidbody>();
            if(smashableLayers == 0)
                smashableLayers = LayerMask.GetMask(Hand.grabbableLayerNameDefault);

            OnSmashEvent += (smasher, smashable) => { OnSmash?.Invoke(); };
        }


        void FixedUpdate() {
            for(int i = 1; i < velocityOverTime.Length; i++) {
                velocityOverTime[i] = velocityOverTime[i-1];
            }
            velocityOverTime[0] = lastPos - (centerOfMassPoint ? centerOfMassPoint.position : rb.position);

            lastPos = centerOfMassPoint ? centerOfMassPoint.position : rb.position;
        }


        private void OnCollisionEnter(Collision collision) {
            Smash smash;
            if(collision.transform.CanGetComponent(out smash)){
                if(GetMagnitude() >= smash.smashForce){
                    smash.DoSmash();
                    OnSmashEvent?.Invoke(this, smash);
                }
            }
        }


        float GetMagnitude() {
            Vector3 velocity = Vector3.zero;
            for(int i = 0; i < velocityOverTime.Length; i++) {
                velocity += velocityOverTime[i];
            }

            return (velocity.magnitude/velocityOverTime.Length)*forceMulti*10;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Smasher.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stabbable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3049614f012dedc469207bf41aa8944c
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/stabbing")]
    public class Stabbable : MonoBehaviour{
        public Rigidbody body;
        public Grabbable grabbable;

        [Tooltip("The index that must match the stabbers index to allow stabbing")]
        public int stabIndex = 0;
        public int maxStabbers = 1;
        public float positionDamper = 1000;
        public float rotationDamper = 1000;
        public bool parentOnStab = true;

        [Header("Events")]
        public UnityEvent StartStab;
        public UnityEvent EndStab;
        
        //Progammer Events <3
        public StabEvent StartStabEvent;
        public StabEvent EndStabEvent;

        public List<Stabber> currentStabbers { get; private set; }
        public int currentStabs { get; private set; }

        Transform prereleaseParent;

        private void OnEnable() {
            currentStabbers = new List<Stabber>();
            if(!body && GetComponent<Rigidbody>())
                body = GetComponent<Rigidbody>();

            if(grabbable == null) {
                body.gameObject.HasGrabbable(out grabbable);
            }
        }

        public virtual void OnStab(Stabber stabber) {
            currentStabs++;
            currentStabbers.Add(stabber);

            if(parentOnStab && grabbable != null && stabber.grabbable != null) {
                grabbable.AddJointedBody(stabber.grabbable.body);
                for(int i = 0; i < stabber.stabbed.Count; i++) {
                    if(stabber.stabbed[i] != this) {
                        var stabbable = stabber.stabbed[i];
                        if(stabbable != this && stabbable.grabbable != null && stabbable.parentOnStab && stabbable.grabbable.parentOnGrab) {
                            if(grabbable.parentOnGrab)
                                grabbable.AddJointedBody(stabbable.grabbable.body);
                            stabbable.grabbable.AddJointedBody(grabbable.body);
                        }
                    }
                }
            }



            StartStab?.Invoke();
            StartStabEvent?.Invoke(stabber, this);
        }

        public virtual void OnEndStab(Stabber stabber) {
            currentStabs--;
            currentStabbers.Remove(stabber);
            if(parentOnStab && grabbable && stabber.grabbable) {
                grabbable.RemoveJointedBody(stabber.grabbable.body);

                for(int i = 0; i < stabber.stabbed.Count; i++) {
                    if(stabber.stabbed[i] != this) {
                        var stabbable = stabber.stabbed[i];
                        if(stabbable != this && stabbable.grabbable != null && stabbable.parentOnStab && stabbable.grabbable.parentOnGrab) {
                            grabbable.RemoveJointedBody(stabbable.grabbable.body);
                            stabbable.grabbable.RemoveJointedBody(grabbable.body);
                        }
                    }
                }
            }

            EndStab?.Invoke();
            EndStabEvent?.Invoke(stabber, this);
        }

        public virtual bool CanStab(Stabber stabber) {
            return currentStabs < maxStabbers && stabber.stabIndex == stabIndex;
        }

        public int StabbedCount() {
            return currentStabbers.Count;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stabbable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stabber.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 80a6c4b11bee64943899872d86aad925
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand {
    public delegate void StabEvent(Stabber stabber, Stabbable stab);

    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/stabbing")]
    public class Stabber : MonoBehaviour {
        [Tooltip("Can be left empty/null")]
        public Grabbable grabbable;
        [Header("Stab Settings")]
        public CapsuleCollider stabCapsule;
        [Tooltip("If left empty, will default to grabbable layers")]
        public LayerMask stabbableLayers;
        [Tooltip("The index that must match the stabbables index to allow stabbing")]
        public int stabIndex;
        public int maxStabs = 3;


        [Header("Joint Settings")]
        public Vector3 axis;
        public float limit = float.MaxValue;
        public ConfigurableJointMotion xMotion;
        public ConfigurableJointMotion yMotion;
        public ConfigurableJointMotion zMotion;
        public ConfigurableJointMotion angularXMotion;
        public ConfigurableJointMotion angularYMotion;
        public ConfigurableJointMotion angularZMotion;
        [Space]
        public float positionDampeningMultiplyer = 1;
        public float rotationDampeningMultiplyer = 1;

        [Header("Events")]
        public UnityEvent StartStab;
        public UnityEvent EndStab;

        //Progammer Events <3
        public StabEvent StartStabEvent;
        public StabEvent EndStabEvent;

        public List<Stabbable> stabbed { get; private set; }
        public List<ConfigurableJoint> stabbedJoints { get; private set; }



        /// <summary>Helps prevent stabbable from being triggered accidently from the wrong angle</summary>
        Dictionary<Stabbable, int> stabbedFrames;
        const int STABFRAMES = 2;
        int frames;

        Vector3 startPos;
        Quaternion startRot;

        Vector3 lastPos;
        Quaternion lastRot;
        Collider[] resultsNonAlloc;

        Transform prereleaseParent;

        void Start() {
            stabbedFrames = new Dictionary<Stabbable, int>();
            stabbed = new List<Stabbable>();
            stabbedJoints = new List<ConfigurableJoint>();
            resultsNonAlloc = new Collider[25];
            if(stabbableLayers == 0)
                stabbableLayers = LayerMask.GetMask(Hand.grabbableLayers);

            if(grabbable == null)
                gameObject.HasGrabbable(out grabbable);

            startPos = transform.position;
            startRot = transform.rotation;

            StartCoroutine(StartWait());
        }

        //This will keep the stabbables in place for the start stab
        IEnumerator StartWait() {
            for(int i = 0; i < STABFRAMES; i++) {
                transform.position = startPos;
                transform.rotation = startRot;
                yield return new WaitForFixedUpdate();
            }
        }

        private void FixedUpdate() {
            if(transform.position != lastPos || lastRot != transform.rotation) {
                frames = 0;
                lastPos = transform.position;
                lastRot = transform.rotation;
            }
            if(frames < STABFRAMES) {
                CheckStabArea();
                frames++;
            }
        }

        protected virtual void CheckStabArea() {
            Vector3 point1;
            Vector3 point2;
            Vector3 capsuleAxis;
            var height = stabCapsule.height;
            var radius = stabCapsule.radius;

            if(stabCapsule.direction == 0) {
                capsuleAxis = Vector3.right;
                height *= stabCapsule.transform.lossyScale.x;
                radius *= stabCapsule.transform.lossyScale.y > stabCapsule.transform.lossyScale.z ? stabCapsule.transform.lossyScale.y : stabCapsule.transform.lossyScale.z;
            }
            else if(stabCapsule.direction == 1) {
                capsuleAxis = Vector3.up;
                height *= stabCapsule.transform.lossyScale.y;
                radius *= stabCapsule.transform.lossyScale.z > stabCapsule.transform.lossyScale.x ? stabCapsule.transform.lossyScale.z : stabCapsule.transform.lossyScale.x;
            }
            else {
                capsuleAxis = Vector3.forward;
                height *= stabCapsule.transform.lossyScale.z;
                radius *= stabCapsule.transform.lossyScale.y > stabCapsule.transform.lossyScale.x ? stabCapsule.transform.lossyScale.y : stabCapsule.transform.lossyScale.x;
            }

            if(height / 2 <= radius) {
                height = 0;
            }
            else {
                height /= 2;
                height -= radius;
            }

            point1 = stabCapsule.bounds.center + stabCapsule.transform.rotation * capsuleAxis * (height);
            point2 = stabCapsule.bounds.center - stabCapsule.transform.rotation * capsuleAxis * (height);
            Physics.OverlapCapsuleNonAlloc(point1, point2, radius, resultsNonAlloc, stabbableLayers, QueryTriggerInteraction.Ignore);

            List<Stabbable> newStabbed = new List<Stabbable>();

            for(int i = 0; i < resultsNonAlloc.Length; i++) {
                Stabbable tempStab;
                if(resultsNonAlloc[i] != null) {
                    if(resultsNonAlloc[i].CanGetComponent(out tempStab))
                        if(tempStab.gameObject != gameObject)
                            newStabbed.Add(tempStab);
                }
            }

            for(int i = stabbed.Count - 1; i >= 0; i--)
                if(!newStabbed.Contains(stabbed[i]))
                    OnStabbableExit(stabbed[i]);

            if(stabbed.Count < maxStabs)
                for(int i = 0; i < newStabbed.Count; i++)
                    if(!stabbed.Contains(newStabbed[i]) && newStabbed[i].CanStab(this))
                        OnStabbableEnter(newStabbed[i]);

            for(int i = 0; i < resultsNonAlloc.Length; i++)
                resultsNonAlloc[i] = null;

            if(stabbedFrames.Count > 0) {
                var stabFrameKeys = new Stabbable[stabbedFrames.Count];
                stabbedFrames.Keys.CopyTo(stabFrameKeys, 0);
                foreach(var stabFrame in stabFrameKeys)
                    if(!stabbed.Contains(stabFrame) && !newStabbed.Contains(stabFrame))
                        stabbedFrames.Remove(stabFrame);
            }

            newStabbed.Clear();
        }

        protected virtual void OnStabbableEnter(Stabbable stab) {
            if(stabbedFrames.ContainsKey(stab))
                stabbedFrames[stab]++;
            else
                stabbedFrames.Add(stab, 1);

            if(stabbedFrames[stab] < STABFRAMES)
                return;

            stabbed.Add(stab);
            var joint = gameObject.AddComponent<ConfigurableJoint>();
            joint.secondaryAxis = axis;
            joint.connectedBody = stab.body;
            joint.xMotion = xMotion;
            joint.yMotion = yMotion;
            joint.zMotion = zMotion;
            joint.angularXMotion = angularXMotion;
            joint.angularYMotion = angularYMotion;
            joint.angularZMotion = angularZMotion;

            joint.linearLimit = new SoftJointLimit() { limit = this.limit };
            joint.linearLimitSpring = new SoftJointLimitSpring() { damper = stab.positionDamper * positionDampeningMultiplyer };
            joint.xDrive = new JointDrive() { positionDamper = stab.positionDamper * positionDampeningMultiplyer, maximumForce = float.MaxValue };
            joint.yDrive = new JointDrive() { positionDamper = stab.positionDamper * positionDampeningMultiplyer, maximumForce = float.MaxValue };
            joint.zDrive = new JointDrive() { positionDamper = stab.positionDamper * positionDampeningMultiplyer, maximumForce = float.MaxValue };
            joint.slerpDrive = new JointDrive() { positionDamper = stab.positionDamper * positionDampeningMultiplyer };

            joint.angularXLimitSpring = new SoftJointLimitSpring() { damper = stab.rotationDamper * rotationDampeningMultiplyer };
            joint.angularYZLimitSpring = new SoftJointLimitSpring() { damper = stab.rotationDamper * rotationDampeningMultiplyer };
            joint.angularXDrive = new JointDrive() { positionDamper = stab.rotationDamper * rotationDampeningMultiplyer, maximumForce = float.MaxValue };
            joint.angularYZDrive = new JointDrive() { positionDamper = stab.rotationDamper * rotationDampeningMultiplyer, maximumForce = float.MaxValue };
            joint.projectionDistance /= 4f;

            joint.enablePreprocessing = true;
            joint.enableCollision = false;

            Rigidbody jointBody;
            joint.CanGetComponent(out jointBody);

            //resets the joint / wakes the body
            jointBody.detectCollisions = false;
            jointBody.detectCollisions = true;
            stab.body.WakeUp();
            jointBody.WakeUp();

            if(stab.parentOnStab && grabbable) {
                grabbable.AddJointedBody(stab.body);
            }
            stabbedJoints.Add(joint);
            stab.OnStab(this);
            StartStabEvent?.Invoke(this, stab);
            StartStab?.Invoke();
        }

        protected virtual void OnStabbableExit(Stabbable stab) {
            var removeIndex = stabbed.IndexOf(stab);
            stabbed.Remove(stab);
            var joint = stabbedJoints[removeIndex];
            stabbedJoints.RemoveAt(removeIndex);
            Destroy(joint);
            if(stab.parentOnStab && grabbable) {
                grabbable.RemoveJointedBody(stab.body);
            }
            stab.OnEndStab(this);
            stabbedFrames.Remove(stab);
            EndStabEvent?.Invoke(this, stab);
            EndStab?.Invoke();
        }

        public List<Stabbable> GetStabbed() {
            return stabbed;
        }

        public int GetStabbedCount() {
            return stabbed.Count;
        }



        void OnDrawGizmosSelected() {
            Vector3 point1;
            Vector3 point2;
            Vector3 capsuleAxis;
            var height = stabCapsule.height;
            var radius = stabCapsule.radius;

            if(stabCapsule.direction == 0) {
                capsuleAxis = Vector3.right;
                height *= stabCapsule.transform.lossyScale.x;
                radius *= stabCapsule.transform.lossyScale.y > stabCapsule.transform.lossyScale.z ? stabCapsule.transform.lossyScale.y : stabCapsule.transform.lossyScale.z;
            }
            else if(stabCapsule.direction == 1) {
                capsuleAxis = Vector3.up;
                height *= stabCapsule.transform.lossyScale.y;
                radius *= stabCapsule.transform.lossyScale.z > stabCapsule.transform.lossyScale.x ? stabCapsule.transform.lossyScale.z : stabCapsule.transform.lossyScale.x;
            }
            else {
                capsuleAxis = Vector3.forward;
                height *= stabCapsule.transform.lossyScale.z;
                radius *= stabCapsule.transform.lossyScale.y > stabCapsule.transform.lossyScale.x ? stabCapsule.transform.lossyScale.y : stabCapsule.transform.lossyScale.x;
            }

            if(height / 2 <= radius) {
                height = 0;
            }
            else {
                height /= 2;
                height -= radius;
            }

            point1 = stabCapsule.bounds.center + stabCapsule.transform.rotation * capsuleAxis * (height);
            point2 = stabCapsule.bounds.center - stabCapsule.transform.rotation * capsuleAxis * (height);

            Gizmos.color = Color.blue;
            Gizmos.DrawSphere(point1, radius);
            Gizmos.DrawSphere(point2, radius);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stabber.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stickable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1e708524a006c484cbc36797af2c5b26
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand {
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/stickies")]
    public class Stickable : MonoBehaviour{
        [Header("Sticky Settings")]
        public Rigidbody body;
        [Tooltip("How strong the joint is between the stickable and this")]
        public float stickStrength = 1;
        [Tooltip("Multiplyer for required stick speed to activate")]
        public float stickSpeedMultiplyer = 1;
        [Tooltip("This index must match the sticky object to stick")]
        public int stickIndex = 0;


        [Header("Event")]
        public UnityEvent OnStick;
        public UnityEvent EndStick;

        Sticky stickSource;

        private void OnDrawGizmosSelected() {
            if(!body && GetComponent<Rigidbody>())
                body = GetComponent<Rigidbody>();
        }

        public void Stick(Sticky source) {
            stickSource = source;
            OnStick?.Invoke();
        }

        public void ForceReleaseStick() {
            stickSource?.ForceRelease(this);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Stickable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Sticky.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 23e243e37b2899946b61644691f83e22
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    public class Sticky : MonoBehaviour{
        [Header("Sticky Settings")]
        public Rigidbody body;
        [Tooltip("How strong the joint is between the stickable and this")]
        public float stickStrength = 1;
        [Tooltip("Multiplyer for required stick speed to activate")]
        public float requiredStickSpeed = 1;
        [Tooltip("This index must match the stickable object to stick")]
        public int stickIndex = 0;

        [Header("Event")]
        public UnityEvent OnStick;

        List<Stickable> stickers;
        List<Joint> joints;

        private void Start() {
            if(body == null)
                body = GetComponent<Rigidbody>();
            stickers = new List<Stickable>();
            joints = new List<Joint>();
        }

        void OnCollisionEnter(Collision collision) {
            Stickable stick;
            if(collision.gameObject.CanGetComponent(out stick)) {
                CreateStick(stick);
            }   
        }

        void CreateStick(Stickable sticker) {
            if(stickers.Contains(sticker) || sticker.stickIndex != stickIndex)
                return;
            if(sticker.body.linearVelocity.sqrMagnitude*sticker.stickSpeedMultiplyer < requiredStickSpeed)
                return;

            var joint = gameObject.AddComponent<FixedJoint>();
            joint.connectedBody = sticker.body;
            joint.breakForce = 1000*stickStrength*sticker.stickStrength;
            joint.breakTorque = 1000*stickStrength*sticker.stickStrength;
                
            joint.connectedMassScale = 1;
            joint.massScale = 1;
            joint.enableCollision = false;
            joint.enablePreprocessing = true;

            sticker.Stick(this);
            OnStick?.Invoke();

            joints.Add(joint);
            stickers.Add(sticker);
        }

        public void ForceRelease(Stickable stuck) {
            var jointIndex = stickers.IndexOf(stuck);
            if(jointIndex == -1)
                return;

            if(!joints[jointIndex]) {
                joints.RemoveAt(jointIndex);
                stickers[jointIndex].EndStick?.Invoke();
                stickers.RemoveAt(jointIndex);
            }
            Destroy(joints[jointIndex]);
        }

        void OnJointBreak(float breakForce) {
            StartCoroutine(JointBreak());
        }

        IEnumerator JointBreak() {
            yield return new WaitForFixedUpdate();
            for(int i = joints.Count-1; i >= 0; i--) {
                if(!joints[i]) {
                    joints.RemoveAt(i);

                    stickers[i].EndStick?.Invoke();
                    stickers.RemoveAt(i);
                }
            }
        }
    
        private void OnDrawGizmosSelected() {
            if(!body && GetComponent<Rigidbody>())
                body = GetComponent<Rigidbody>();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Tools/Sticky.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/BlankUser.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 740f49ddb7ee0984b83bd6ab7514b564
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;

namespace Dreamteck.Splines
{
    //This is a blank SplineUser-derived class which you can use to build your custom SplineUser
    //You can safely delete any functions that you won't use
    //DO NOT ADD Update, LateUpdate or FixedUpdate, use Run, it is automatically called through one of these methods
    public class BlankUser : SplineUser
    {
        protected override void Awake()
        {
            base.Awake();
            //Awake is also called in the editor
        }

        void Start()
        {
            //Write initialization code here
        }

        protected override void LateRun()
        {
            base.LateRun();
            //Code to run every Update/FixedUpdate/LateUpdate
        }

        protected override void Build()
        {
            base.Build();
            //Build is called after the spline has been sampled. 
            //Use it for calculations (example: generate mesh geometry, calculate object positions)
        }

        protected override void PostBuild()
        {
            base.PostBuild();
            //Called on the main thread after Build has finished
            //Use it to apply the calculations from Build to GameObjects, Transforms, Meshes, etc.
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/BlankUser.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/BoxColliderGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1ca405288a4bb374aa05101b41667f31
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;

    public class BoxColliderGenerator : SplineUser, ISerializationCallbackReceiver
    {
        [SerializeField] private Vector2 _boxSize = Vector2.one;
        [SerializeField] private bool _debugDraw = false;
        [SerializeField] private Color _debugDrawColor = Color.white;


        [SerializeField]
        [HideInInspector]
        public ColliderObject[] _colliders = new ColliderObject[0];


        public Vector2 boxSize
        {
            get { return _boxSize; }
            set
            {
                if (value != _boxSize)
                {
                    _boxSize = value;
                    Rebuild();
                }
            }
        }

        private void DestroyCollider(ColliderObject collider)
        {
#if UNITY_EDITOR
            if (Application.isPlaying)
            {
                Destroy(collider.transform.gameObject);
            }
            else
            {
                DestroyImmediate(collider.transform.gameObject);
            }
#else
            Destroy(collider.transform.gameObject);
#endif
        }

        protected override void Build()
        {
            base.Build();

            if (sampleCount == 0)
            {
                for (int i = 0; i < _colliders.Length; i++)
                {
                    DestroyCollider(_colliders[i]);
                }
                _colliders = new ColliderObject[0];
                return;
            }

            int objectCount = sampleCount - 1;
            if (objectCount != _colliders.Length)
            {
                ColliderObject[] newColliders = new ColliderObject[objectCount];
                for (int i = 0; i < newColliders.Length; i++)
                {
                    if (i < _colliders.Length)
                    {
                        newColliders[i] = _colliders[i];
                    }
                    else
                    {
                        GameObject newObject = new GameObject("Collider " + i);
                        newObject.layer = gameObject.layer;
                        newObject.transform.parent = trs;
                        newColliders[i] = new ColliderObject(newObject.transform, newObject.AddComponent<BoxCollider>());
                    }
                }
                if (newColliders.Length < _colliders.Length)
                {
                    for (int i = newColliders.Length; i < _colliders.Length; i++)
                    {
                        DestroyCollider(_colliders[i]);
                    }
                }
                _colliders = newColliders;
            }

            SplineSample current = new SplineSample();
            SplineSample next = new SplineSample();
            Evaluate(0.0, ref current);

            for (int i = 0; i < objectCount; i++)
            {
                double nextPercent = (double)(i + 1) / (sampleCount - 1);
                Evaluate(nextPercent, ref next);
                _colliders[i].transform.position = Vector3.Lerp(current.position, next.position, 0.5f);
                _colliders[i].transform.rotation = Quaternion.LookRotation(next.position - current.position, Vector3.Slerp(current.up, next.up, 0.5f));
                float size = Mathf.Lerp(current.size, next.size, 0.5f);
                _colliders[i].collider.size = new Vector3(_boxSize.x * size, _boxSize.y * size, Vector3.Distance(current.position, next.position));
                current = next;
            }
        }

        public override void OnBeforeSerialize()
        {
            base.OnBeforeSerialize();
            Build();
        }

        private void OnDrawGizmos()
        {
            if (_debugDraw)
            {
                for (int i = 0; i < _colliders.Length; i++)
                {
                    Gizmos.matrix = _colliders[i].transform.localToWorldMatrix;
                    Gizmos.color = _debugDrawColor;
                    Gizmos.DrawCube(Vector3.zero, _colliders[i].collider.size);
                }
                Gizmos.matrix = Matrix4x4.identity;
            }
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            for (int i = 0; i < _colliders.Length; i++)
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                {
                    DestroyImmediate(_colliders[i].transform.gameObject);
                } else
                {
                    Destroy(_colliders[i].transform.gameObject);
                }
#else
                Destroy(_colliders[i].transform.gameObject);
#endif
            }
        }

        [System.Serializable]
        public class ColliderObject
        {
            public Transform transform;
            public BoxCollider collider;

            public ColliderObject(Transform transform, BoxCollider collider)
            {
                this.transform = transform;
                this.collider = collider;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/BoxColliderGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/CapsuleColliderGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 56dd191f9d7c9cd4d9c21559487036d6
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;

    public class CapsuleColliderGenerator : SplineUser, ISerializationCallbackReceiver
    {
        [SerializeField, HideInInspector, Min(0f)] private float _radius = 1f;
        [SerializeField, HideInInspector, Min(0f)] private float _height = 1f;
        [SerializeField, HideInInspector] private bool _overlapCaps = true;
        [SerializeField, HideInInspector] private CapsuleColliderZDirection _direction = CapsuleColliderZDirection.Z;
        [SerializeField, HideInInspector] private ColliderObject[] _colliders = new ColliderObject[0];

        public float radius
        {
            get { return _radius; }
            set
            {
                if (value != _radius)
                {
                    _radius = value;
                    Rebuild();
                }
            }
        }

        public float height
        {
            get { return _height; }
            set
            {
                if (value != _height)
                {
                    _height = value;
                    Rebuild();
                }
            }
        }

        public bool overlapCaps
        {
            get { return _overlapCaps; }
            set
            {
                if (value != _overlapCaps)
                {
                    _overlapCaps = value;
                    Rebuild();
                }
            }
        }

        public CapsuleColliderZDirection direction
        {
            get { return _direction; }
            set
            {
                if (value != _direction)
                {
                    _direction = value;
                    Rebuild();
                }
            }
        }

        private void DestroyCollider(ColliderObject collider)
        {
#if UNITY_EDITOR
            if (Application.isPlaying)
            {
                Destroy(collider.transform.gameObject);
            }
            else
            {
                DestroyImmediate(collider.transform.gameObject);
            }
#else
            Destroy(collider.transform.gameObject);
#endif
        }

        protected override void Build()
        {
            base.Build();

            if (sampleCount == 0)
            {
                for (int i = 0; i < _colliders.Length; i++)
                {
                    DestroyCollider(_colliders[i]);
                }
                _colliders = new ColliderObject[0];
                return;
            }

            int objectCount = sampleCount - 1;
            if (objectCount != _colliders.Length)
            {
                GenerateColliders(objectCount);
            }

            SplineSample current = new SplineSample();
            SplineSample next = new SplineSample();
            Evaluate(0.0, ref current);

            bool controlHeight = _direction == CapsuleColliderZDirection.Z;

            for (int i = 0; i < objectCount; i++)
            {
                double nextPercent = (double)(i + 1) / (sampleCount - 1);
                Evaluate(nextPercent, ref next);
                _colliders[i].transform.position = Vector3.Lerp(current.position, next.position, 0.5f);
                _colliders[i].transform.rotation = Quaternion.LookRotation(next.position - current.position, Vector3.Slerp(current.up, next.up, 0.5f));
                
                _colliders[i].collider.radius = _radius;
                _colliders[i].collider.direction = (int)_direction;

                var distance = Vector3.Distance(current.position, next.position);

                if (controlHeight)
                {
                    if (_overlapCaps)
                    {
                        _colliders[i].collider.height = distance + _radius * 2f;
                    } else
                    {
                        _colliders[i].collider.height = distance;
                    }
                    _colliders[i].collider.radius = _radius;
                }
                else
                {
                    _colliders[i].collider.height = _height;
                    _colliders[i].collider.radius = distance * 0.5f;
                }

                current = next;
            }
        }

        private void GenerateColliders(int count)
        {
            ColliderObject[] newColliders = new ColliderObject[count];
            for (int i = 0; i < newColliders.Length; i++)
            {
                if (i < _colliders.Length)
                {
                    newColliders[i] = _colliders[i];
                }
                else
                {
                    GameObject newObject = new GameObject("Collider " + i);
                    newObject.layer = gameObject.layer;
                    newObject.transform.parent = trs;
                    newColliders[i] = new ColliderObject(newObject.transform, newObject.AddComponent<CapsuleCollider>(), _direction, _height);
                }
            }
            if (newColliders.Length < _colliders.Length)
            {
                for (int i = newColliders.Length; i < _colliders.Length; i++)
                {
                    DestroyCollider(_colliders[i]);
                }
            }
            _colliders = newColliders;
        }

        public override void OnBeforeSerialize()
        {
            base.OnBeforeSerialize();
            Build();
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            for (int i = 0; i < _colliders.Length; i++)
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                {
                    DestroyImmediate(_colliders[i].transform.gameObject);
                }
                else
                {
                    Destroy(_colliders[i].transform.gameObject);
                }
#else
                Destroy(_colliders[i].transform.gameObject);
#endif
            }
        }

        [System.Serializable]
        public class ColliderObject
        {
            public Transform transform;
            public CapsuleCollider collider;

            public ColliderObject(Transform transform, CapsuleCollider collider, CapsuleColliderZDirection direction, float height)
            {
                this.transform = transform;
                this.collider = collider;
                this.collider.direction = (int)direction;
                this.collider.height = height;
            }
        }

        public enum CapsuleColliderZDirection
        {
            X = 0, Y = 1, Z = 2,
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/CapsuleColliderGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ComplexSurfaceGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 23c67ca6f2dc03d45be9d985a114a897
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;

    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Dreamteck/Splines/Complex Surface Generator")]
    public class ComplexSurfaceGenerator : MeshGenerator
    {
        public enum UVWrapMode { Clamp, UniformX, UniformY, Uniform }
        public enum SubdivisionMode { CatmullRom, BSpline, Linear }
        public UVWrapMode uvWrapMode
        {
            get { return _uvWrapMode; }
            set
            {
                if (value != _uvWrapMode)
                {
                    _uvWrapMode = value;
                    Rebuild();
                }
            }
        }

        public int subdivisions
        {
            get { return _subdivisions; }
            set
            {
                if (value != _subdivisions)
                {
                    _subdivisions = value;
                    Rebuild();
                }
            }
        }

        public SubdivisionMode subdivisionMode
        {
            get { return _subdivisionMode; }
            set
            {
                if (value != _subdivisionMode)
                {
                    _subdivisionMode = value;
                    Rebuild();
                }
            }
        }

        public bool automaticNormals
        {
            get { return _automaticNormals; }
            set
            {
                if (value != _automaticNormals)
                {
                    _automaticNormals = value;
                    Rebuild();
                }
            }
        }

        public bool separateMaterialIDs
        {
            get { return _separateMaterialIDs; }
            set
            {
                if (value != _separateMaterialIDs)
                {
                    _separateMaterialIDs = value;
                    Rebuild();
                }
            }
        }


        public SplineComputer[] otherComputers
        {
            get { return _otherComputers; }
            set
            {
                bool rebuild = false;
                if (value.Length != _otherComputers.Length)
                {
                    rebuild = true;
                    for (int i = 0; i < _otherComputers.Length; i++)
                    {
                        if (_otherComputers[i] != null)
                        {
                            _otherComputers[i].Unsubscribe(this);
                        }
                    }
                }
                else
                {
                    for (int i = 0; i < value.Length; i++)
                    {
                        if (_otherComputers[i] != null)
                        {
                            _otherComputers[i].Unsubscribe(this);
                        }
                        if (value[i] != _otherComputers[i])
                        {
                            rebuild = true;
                            break;
                        }
                    }
                }
                if (rebuild)
                {
                    _otherComputers = value;
                    for (int i = 0; i < _otherComputers.Length; i++)
                    {
                        if (_otherComputers[i] != null)
                        {
                            if (_otherComputers[i].subscriberCount == 0)
                            {
                                _otherComputers[i].name = "Surface Spline " + (i + 1);
                            }
                            _otherComputers[i].Subscribe(this);
                        }
                    }
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private UVWrapMode _uvWrapMode = UVWrapMode.Clamp;
        [SerializeField, HideInInspector, Min(1)]
        private int _subdivisions = 3;
        [SerializeField, HideInInspector]
        private SubdivisionMode _subdivisionMode;
        [SerializeField]
        [HideInInspector]
        private bool _automaticNormals = true;
        [SerializeField]
        [HideInInspector]
        private bool _separateMaterialIDs = false;
        [SerializeField]
        [HideInInspector]
        private SplineComputer[] _otherComputers = new SplineComputer[0];
        [SerializeField]
        [HideInInspector]
        private Spline[] _splines = new Spline[0];
        [SerializeField]
        [HideInInspector]
        private bool _initializedInEditor = false;

        private int iterations => _subdivisions * _otherComputers.Length;

        protected override void Awake()
        {
            base.Awake();

            _mesh.name = "multispline_surface";
            for (int i = 0; i < _otherComputers.Length; i++)
            {
                _otherComputers[i].onRebuild -= OnOtherRebuild;
                _otherComputers[i].onRebuild += OnOtherRebuild;
            }
        }

        void OnOtherRebuild()
        {
            RebuildImmediate();
        }

        protected override void Reset()
        {
            base.Reset();
        }

        private Spline.Type ModeToSplineType(SubdivisionMode mode)
        {
            switch (mode)
            {
                case SubdivisionMode.BSpline: return Spline.Type.BSpline; 
                case SubdivisionMode.Linear: return Spline.Type.Linear;
                default: return Spline.Type.CatmullRom;
            }
        }


        protected override void BuildMesh()
        {
            if (sampleCount == 0 || _otherComputers.Length == 0)
            {
                AllocateMesh(0, 0);
                return;
            }

            if (_splines.Length != sampleCount)
            {
                _splines = new Spline[sampleCount];
                for (int i = 0; i < _splines.Length; i++)
                {
                    _splines[i] = new Spline(ModeToSplineType(_subdivisionMode));
                }
            } else
            {
                for (int i = 0; i < _splines.Length; i++)
                {
                    _splines[i].type = ModeToSplineType(_subdivisionMode);
                }
            }

            base.BuildMesh();
            AllocateMesh(sampleCount * (iterations + 1), iterations * (sampleCount-1) * 6);
            _tsMesh.triangles = MeshUtility.GeneratePlaneTriangles(sampleCount - 1, iterations + 1, false);
            GenerateVertices();
            _tsMesh.subMeshes.Clear();

            if (_separateMaterialIDs)
            {
                for (int i = 0; i < _otherComputers.Length; i++)
                {
                    int[] newTris = MeshUtility.GeneratePlaneTriangles(sampleCount - 1, subdivisions + 1, false);
                    _tsMesh.subMeshes.Add(newTris);
                    for (int n = 0; n < _tsMesh.subMeshes[i].Length; n++)
                    {
                        _tsMesh.subMeshes[i][n] += i * (_subdivisions * sampleCount);
                    }
                }
            }
        }


        void GenerateVertices()
        {
            if (_otherComputers.Length == 0) return;

            ResetUVDistance();

            SplineSample sample = default;
            SplineSample sample2 = default;

            for (int i = 0; i < _otherComputers.Length + 1; i++)
            {
                SplineComputer splineComp = spline;
                if (i > 0)
                {
                    splineComp = _otherComputers[i - 1];
                }

                for (int j = 0; j < sampleCount; j++)
                {
                    if (_splines[j].points.Length != _otherComputers.Length + 1)
                    {
                        _splines[j].points = new SplinePoint[_otherComputers.Length + 1];
                    }
                    
                    double xPercent = DMath.Lerp(clipFrom, clipTo, (double)j / (sampleCount - 1));
                    if (i > 0)
                    {
                        splineComp.Evaluate(xPercent, ref sample);
                    }
                    else
                    {
                        GetSample(j, ref sample);
                    }

                    _splines[j].points[i].position = sample.position;
                    _splines[j].points[i].normal = sample.up;
                    _splines[j].points[i].color = sample.color;
                }
            }



            for (int x = 0; x < _splines.Length; x++)
            {
                if (uvMode == UVMode.UniformClamp || uvMode == UVMode.UniformClip)
                {
                    AddUVDistance(x);
                } else
                {
                    GetSample(x, ref sample2);
                }
                Vector3 lastPos = sample.position;
                float ydist = 0f;
                float xPercent = Mathf.Lerp((float)clipFrom, (float)clipTo, (float)x / (_splines.Length - 1));
                for (int y = 0; y < iterations + 1; y++)
                {
                    float yPercent = (float)y / iterations;
                    int index = x + y * _splines.Length;
                    _splines[x].Evaluate(yPercent, ref sample);
                    if (y > 0)
                    {
                        ydist += Vector3.Distance(lastPos, sample.position);
                    }
                    lastPos = sample.position;
                    if (uvMode == UVMode.UniformClamp )
                    {
                        __uvs.x = CalculateUVUniformClamp(_vDist);
                        __uvs.y = CalculateUVUniformClamp(ydist);
                    } else if(uvMode == UVMode.UniformClip)
                    {
                        __uvs.x = CalculateUVUniformClip(_vDist);
                        __uvs.y = CalculateUVUniformClip(ydist);
                    }
                    else
                    {
                        CalculateUVs(xPercent, yPercent);
                    }

                    _tsMesh.vertices[index] = sample.position;
                    _tsMesh.normals[index] = sample.up;
                    _tsMesh.colors[index] = sample.color;
                    _tsMesh.uv[index] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(uvRotation + 180f, Vector3.forward) * (Vector2.one * 0.5f - __uvs));
                }
            }
        }


        protected override void WriteMesh()
        {
            base.WriteMesh();
            if (_automaticNormals)
            {
                _mesh.RecalculateNormals();
            }
        }

        public static void DrawSpline(Spline spline, Color color, double from = 0.0, double to = 1.0)
        {
            double add = spline.moveStep;
            int iterations = spline.iterations;
            if (iterations <= 0) return;

            Vector3 prevPoint = spline.EvaluatePosition(from);
            for (int i = 1; i < iterations; i++)
            {
                double p = DMath.Lerp(from, to, (double)i / (iterations - 1));
                Debug.DrawLine(prevPoint, spline.EvaluatePosition(p), color, 1f);
                prevPoint = spline.EvaluatePosition(p);
            }
        }


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ComplexSurfaceGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/EdgeColliderGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d28d465ca9ef341488ba836962159676
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Threading;
namespace Dreamteck.Splines
{
    [AddComponentMenu("Dreamteck/Splines/Users/Edge Collider Generator")]
    [RequireComponent(typeof(EdgeCollider2D))]
    public class EdgeColliderGenerator : SplineUser
    {
        public float offset
        {
            get { return _offset; }
            set
            {
                if (value != _offset)
                {
                    _offset = value;
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private float _offset = 0f;
        [SerializeField]
        [HideInInspector]
        protected EdgeCollider2D edgeCollider;

        [SerializeField]
        [HideInInspector]
        protected Vector2[] vertices = new Vector2[0];

        [HideInInspector]
        public float updateRate = 0.1f;
        protected float lastUpdateTime = 0f;

        private bool updateCollider = false;

        protected override void Awake()
        {
            base.Awake();
            edgeCollider = GetComponent<EdgeCollider2D>();
        }


        protected override void Reset()
        {
            base.Reset();
        }

        protected override void OnEnable()
        {
            base.OnEnable();
        }

        protected override void OnDisable()
        {
            base.OnDisable();
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
        }

        protected override void LateRun()
        {
            base.LateRun();
            if (updateCollider)
            {
                if (edgeCollider != null)
                {
                    if (Time.time - lastUpdateTime >= updateRate)
                    {
                        lastUpdateTime = Time.time;
                        updateCollider = false;
                        edgeCollider.points = vertices;
                    }
                }
            }
        }

        protected override void Build()
        {
            base.Build();
            if (vertices.Length != sampleCount) vertices = new Vector2[sampleCount];
            bool hasOffset = offset != 0f;
            for (int i = 0; i < sampleCount; i++)
            {
                GetSample(i, ref evalResult);
                vertices[i] = evalResult.position;
                if (hasOffset)
                {
                    Vector2 right = new Vector2(-evalResult.forward.y, evalResult.forward.x).normalized * evalResult.size;
                    vertices[i] += right * offset;
                }
            }
        }

        protected override void PostBuild()
        {
            base.PostBuild();
            if (edgeCollider == null) return;
            for(int i = 0; i < vertices.Length; i++) vertices[i] = transform.InverseTransformPoint(vertices[i]);
            
#if UNITY_EDITOR
            if (!Application.isPlaying || updateRate <= 0f)
            {
                edgeCollider.points = vertices;
            } else updateCollider = true;
#else
            if(updateRate == 0f) edgeCollider.points = vertices;
            else updateCollider = true;
#endif
        }
    }

  
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/EdgeColliderGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ISampleModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6f878af9c27e51e4b9b42aee2e444837
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;

namespace Dreamteck.Splines
{
    public interface ISampleModifier
    {
        public void ApplySampleModifiers(ref SplineSample sample);

        public Vector3 GetModifiedSamplePosition(ref SplineSample sample);
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ISampleModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/LengthCalculator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 995701723b428a94c9305a2abf319ad6
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Reflection;
using UnityEngine.Events;

namespace Dreamteck.Splines
{
    [AddComponentMenu("Dreamteck/Splines/Users/Length Calculator")]
    public class LengthCalculator : SplineUser
    {
        [System.Serializable]
        public class LengthEvent
        {
            public bool enabled = true;
            public float targetLength = 0f;
            public UnityEvent onChange = new UnityEvent();
            public enum Type { Growing, Shrinking, Both}
            public Type type = Type.Both;

            public LengthEvent()
            {

            }

            public LengthEvent(Type t)
            {
                type = t;
            }

            public void Check(float fromLength, float toLength)
            {
                if (!enabled) return;
                bool condition = false;
                switch (type)
                {
                    case Type.Growing: condition = toLength >= targetLength && fromLength < targetLength; break;
                    case Type.Shrinking: condition = toLength <= targetLength && fromLength > targetLength; break;
                    case Type.Both: condition = toLength >= targetLength && fromLength < targetLength || toLength <= targetLength && fromLength > targetLength; break;
                }
                if (condition) onChange.Invoke();
            }
        }
        [HideInInspector]
        public LengthEvent[] lengthEvents = new LengthEvent[0];
        [HideInInspector]
        public float idealLength = 1f;
        private float _length = 0f;
        private float lastLength = 0f;
        public float length
        {
            get {
                return _length;
            }
        }

        protected override void Awake()
        {
            base.Awake();
            _length = CalculateLength();
            lastLength = _length;
            for (int i = 0; i < lengthEvents.Length; i++)
            {
                if (lengthEvents[i].targetLength == _length) lengthEvents[i].onChange.Invoke();
            }
        }

        protected override void Build()
        {
            base.Build();
            _length = CalculateLength();
            if (lastLength != _length)
            {
                for (int i = 0; i < lengthEvents.Length; i++)
                {
                    lengthEvents[i].Check(lastLength, _length);
                }
                lastLength = _length;
            }
        }

        public void AddEvent(LengthEvent lengthEvent)
        {
            LengthEvent[] newEvents = new LengthEvent[lengthEvents.Length + 1];
            lengthEvents.CopyTo(newEvents, 0);
            newEvents[newEvents.Length - 1] = lengthEvent;
            lengthEvents = newEvents;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/LengthCalculator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/MeshGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 49c9228d9868e1747b4763bc4cb1d86f
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Threading;
#if UNITY_EDITOR
using UnityEditor;
#endif 

namespace Dreamteck.Splines
{
    public class MeshGenerator : SplineUser
    {
        protected const int UNITY_16_VERTEX_LIMIT = 65535;

        public float size
        {
            get { return _size; }
            set
            {
                if (value != _size)
                {
                    _size = value;
                    Rebuild();
                } else _size = value;
            }
        }

        public Color color
        {
            get { return _color; }
            set
            {
                if (value != _color)
                {
                    _color = value;
                    Rebuild();
                }
            }
        }

        public Vector3 offset
        {
            get { return _offset; }
            set
            {
                if (value != _offset)
                {
                    _offset = value;
                    Rebuild();
                }
            }
        }

        public NormalMethod normalMethod
        {
            get { return _normalMethod; }
            set
            {
                if (value != _normalMethod)
                {
                    _normalMethod = value;
                    Rebuild();
                }
            }
        }

        public bool useSplineSize
        {
            get { return _useSplineSize; }
            set
            {
                if (value != _useSplineSize)
                {
                    _useSplineSize = value;
                    Rebuild();
                }
            }
        }

        public bool useSplineColor
        {
            get { return _useSplineColor; }
            set
            {
                if (value != _useSplineColor)
                {
                    _useSplineColor = value;
                    Rebuild();
                }
            }
        }

        public bool calculateTangents
        {
            get { return _calculateTangents; }
            set
            {
                if (value != _calculateTangents)
                {
                    _calculateTangents = value;
                    Rebuild();
                }
            }
        }

        public float rotation
        {
            get { return _rotation; }
            set
            {
                if (value != _rotation)
                {
                    _rotation = value;
                    Rebuild();
                }
            }
        }

        public bool flipFaces
        {
            get { return _flipFaces; }
            set
            {
                if (value != _flipFaces)
                {
                    _flipFaces = value;
                    Rebuild();
                }
            }
        }

        public bool doubleSided
        {
            get { return _doubleSided; }
            set
            {
                if (value != _doubleSided)
                {
                    _doubleSided = value;
                    Rebuild();
                }
            }
        }

        public UVMode uvMode
        {
            get { return _uvMode; }
            set
            {
                if (value != _uvMode)
                {
                    _uvMode = value;
                    Rebuild();
                }
            }
        }

        public Vector2 uvScale
        {
            get { return _uvScale; }
            set
            {
                if (value != _uvScale)
                {
                    _uvScale = value;
                    Rebuild();
                }
            }
        }

        public Vector2 uvOffset
        {
            get { return _uvOffset; }
            set
            {
                if (value != _uvOffset)
                {
                    _uvOffset = value;
                    Rebuild();
                }
            }
        }

        public float uvRotation
        {
            get { return _uvRotation; }
            set
            {
                if (value != _uvRotation)
                {
                    _uvRotation = value;
                    Rebuild();
                }
            }
        }

        public UnityEngine.Rendering.IndexFormat meshIndexFormat
        {
            get { return _meshIndexFormat; }
            set
            {
                if (value != _meshIndexFormat)
                {
                    _meshIndexFormat = value;
                    RefreshMesh();
                    Rebuild();
                }
            }
        }

        public bool baked
        {
            get
            {
                return _baked;
            }
        }

        public bool markDynamic
        {
            get { return _markDynamic; }
            set
            {
                if (value != _markDynamic)
                {
                    _markDynamic = value;
                    RefreshMesh();
                    Rebuild();
                }
            }
        }

        public enum UVMode { Clip, UniformClip, Clamp, UniformClamp }
        public enum NormalMethod { Recalculate, SplineNormals }
        [SerializeField]
        [HideInInspector]
        private bool _baked = false;
        [SerializeField]
        [HideInInspector]
        private bool _markDynamic = true;
        [SerializeField]
        [HideInInspector]
        private float _size = 1f;
        [SerializeField]
        [HideInInspector]
        private Color _color = Color.white;
        [SerializeField]
        [HideInInspector]
        private Vector3 _offset = Vector3.zero;
        [SerializeField]
        [HideInInspector]
        private NormalMethod _normalMethod = NormalMethod.SplineNormals;
        [SerializeField]
        [HideInInspector]
        private bool _calculateTangents = true;
        [SerializeField]
        [HideInInspector]
        private bool _useSplineSize = true;
        [SerializeField]
        [HideInInspector]
        private bool _useSplineColor = true;
        [SerializeField]
        [HideInInspector]
        [Range(-360f, 360f)]
        private float _rotation = 0f;
        [SerializeField]
        [HideInInspector]
        private bool _flipFaces = false;
        [SerializeField]
        [HideInInspector]
        private bool _doubleSided = false;
        [SerializeField]
        [HideInInspector]
        private UVMode _uvMode = UVMode.Clip;
        [SerializeField]
        [HideInInspector]
        private Vector2 _uvScale = Vector2.one;
        [SerializeField]
        [HideInInspector]
        private Vector2 _uvOffset = Vector2.zero;
        [SerializeField]
        [HideInInspector]
        private float _uvRotation = 0f;
        [SerializeField]
        [HideInInspector]
        private UnityEngine.Rendering.IndexFormat _meshIndexFormat = UnityEngine.Rendering.IndexFormat.UInt16;
        [SerializeField]
        [HideInInspector]
        private Mesh _bakedMesh;

        [HideInInspector]
        public float colliderUpdateRate = 0.2f;
        protected bool _updateCollider = false;
        protected float _lastUpdateTime = 0f;

        protected float _vDist = 0f;
        protected static Vector2 __uvs = Vector2.zero;

        protected virtual string meshName => "Mesh";
        protected TS_Mesh _tsMesh { get; private set; }
        protected Mesh _mesh;

        protected MeshFilter filter;
        protected MeshRenderer meshRenderer;
        protected MeshCollider meshCollider;

#if UNITY_EDITOR

        public void Bake(bool makeStatic, bool lightmapUV)
        {
            if (_mesh == null) return;
            gameObject.isStatic = false;
            UnityEditor.MeshUtility.Optimize(_mesh);
            if (spline != null)
            {
                spline.Unsubscribe(this);
            }
            filter = GetComponent<MeshFilter>();
            meshRenderer = GetComponent<MeshRenderer>();
            filter.hideFlags = meshRenderer.hideFlags = HideFlags.None;
            _bakedMesh = Instantiate(_mesh);
            _bakedMesh.name = meshName + " - Baked";
            if (lightmapUV)
            {
                Unwrapping.GenerateSecondaryUVSet(_bakedMesh);
            }
            filter.sharedMesh = _bakedMesh;
            _mesh = null;
            gameObject.isStatic = makeStatic; 
            _baked = true;
        }

        public void Unbake()
        {
            gameObject.isStatic = false; 
            _baked = false;
            DestroyImmediate(_bakedMesh);
            _bakedMesh = null;
            CreateMesh();
            spline.Subscribe(this);
            Rebuild();
        }

        public override void EditorAwake()
        {
            GetComponents();
            base.EditorAwake();
        }
#endif


        protected override void Awake()
        {
            GetComponents();
            base.Awake();
        }

        protected override void Reset()
        {
            base.Reset();
            GetComponents();
#if UNITY_EDITOR
            bool materialFound = false;
            for (int i = 0; i < meshRenderer.sharedMaterials.Length; i++)
            {
                if (meshRenderer.sharedMaterials[i] != null)
                {
                    materialFound = true;
                    break;
                }
            }
            if (!materialFound) meshRenderer.sharedMaterial = AssetDatabase.GetBuiltinExtraResource<Material>("Default-Diffuse.mat");
#endif
        }

        private void GetComponents()
        {
            filter = GetComponent<MeshFilter>();
            meshRenderer = GetComponent<MeshRenderer>();
            meshCollider = GetComponent<MeshCollider>();
        }

        public override void Rebuild()
        {
            if (_baked) return;
            base.Rebuild();
        }

        public override void RebuildImmediate()
        {
            if (_baked) return;
            base.RebuildImmediate();
        }

        protected override void OnEnable()
        {
            base.OnEnable();
        }

        protected override void OnDisable()
        {
            base.OnDisable();
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            MeshFilter filter = GetComponent<MeshFilter>();
            MeshRenderer rend = GetComponent<MeshRenderer>();
            if (filter != null)  filter.hideFlags = HideFlags.None;
            if (rend != null)  rend.hideFlags = HideFlags.None;
        }


        public void UpdateCollider()
        {
            meshCollider = GetComponent<MeshCollider>();
            if (meshCollider == null) meshCollider = gameObject.AddComponent<MeshCollider>();
            meshCollider.sharedMesh = filter.sharedMesh;
        }

        protected override void LateRun()
        {
            if (_baked) return;
            base.LateRun();
            if (_updateCollider)
            {
                if (meshCollider != null)
                {
                    if (Time.time - _lastUpdateTime >= colliderUpdateRate)
                    {
                        _lastUpdateTime = Time.time;
                        _updateCollider = false;
                        meshCollider.sharedMesh = filter.sharedMesh;
                    }
                }
            }
        }

        protected override void Build()
        {
            base.Build();
            if (_tsMesh == null || _mesh == null)
            {
                CreateMesh();
            }

            if (sampleCount > 1)
            {
                BuildMesh();
            } else
            {
                ClearMesh();
            }
        }

        protected override void PostBuild()
        {
            base.PostBuild();
            WriteMesh();
        }

        protected virtual void ClearMesh()
        {
            _tsMesh.Clear();
            _mesh.Clear();
        }

        protected virtual void BuildMesh()
        {
            //Logic for mesh generation, automatically called in the Build method
        }

        protected virtual void WriteMesh() 
        {
            MeshUtility.TransformMesh(_tsMesh, trs.worldToLocalMatrix);
            if (_doubleSided)
            {
                MeshUtility.MakeDoublesidedHalf(_tsMesh);
            }
            else if (_flipFaces)
            {
                MeshUtility.FlipFaces(_tsMesh);
            }

            if (_calculateTangents)
            {
                MeshUtility.CalculateTangents(_tsMesh);
            }

            if (_meshIndexFormat == UnityEngine.Rendering.IndexFormat.UInt16 && _tsMesh.vertexCount > UNITY_16_VERTEX_LIMIT)
            {
                Debug.LogError("WARNING: The generated mesh for " + name + " exceeds the maximum vertex count for standard meshes in Unity (" + UNITY_16_VERTEX_LIMIT + "). To create bigger meshes, set the Index Format inside the Vertices foldout to 32.");
            }

            _tsMesh.indexFormat = _meshIndexFormat;

            _tsMesh.WriteMesh(ref _mesh);

            if (_markDynamic)
            {
                _mesh.MarkDynamic();
            }

            if (_normalMethod == 0)
            {
                _mesh.RecalculateNormals();
            }

            if (filter != null)
            {
                filter.sharedMesh = _mesh;
            }
            _updateCollider = true;
        }

        protected virtual void AllocateMesh(int vertexCount, int trisCount)
        {
            if(trisCount < 0)
            {
                trisCount = 0;
            }
            if(vertexCount < 0)
            {
                vertexCount = 0;
            }
            if (_doubleSided)
            {
                vertexCount *= 2;
                trisCount *= 2;
            }
            if (_tsMesh.vertexCount != vertexCount)
            {
                _tsMesh.vertices = new Vector3[vertexCount];
                _tsMesh.normals = new Vector3[vertexCount];
                _tsMesh.tangents = new Vector4[vertexCount];
                _tsMesh.colors = new Color[vertexCount];
                _tsMesh.uv = new Vector2[vertexCount];
            }
            if (_tsMesh.triangles.Length != trisCount)
            {
                _tsMesh.triangles = new int[trisCount];
            }
        }

        protected void ResetUVDistance()
        {
            _vDist = 0f;
            if (uvMode == UVMode.UniformClip)
            {
                _vDist = spline.CalculateLength(0.0, GetSamplePercent(0));
            }
        }

        protected void AddUVDistance(int sampleIndex)
        {
            if (sampleIndex == 0) return;
            SplineSample current = new SplineSample();
            SplineSample last = new SplineSample();
            GetSampleRaw(sampleIndex, ref current);
            GetSampleRaw(sampleIndex - 1, ref last);
            _vDist += Vector3.Distance(current.position, last.position);
        }

        protected void CalculateUVs(double percent, float u)
        {
            __uvs.x = u * _uvScale.x - _uvOffset.x;
            switch (uvMode)
            {
                case UVMode.Clip:  __uvs.y = CalculateUVClip(percent); break;
                case UVMode.Clamp: __uvs.y = CalculateUVClamp(percent);  break;
                case UVMode.UniformClamp: __uvs.y = CalculateUVUniformClamp(_vDist); break;
                default: __uvs.y = CalculateUVUniformClip(_vDist); break;
            }
        }

        protected float CalculateUVUniformClamp(float distance)
        {
            return distance * _uvScale.y / (float)span - _uvOffset.y;
        }

        protected float CalculateUVUniformClip(float distance)
        {
            return distance * _uvScale.y - _uvOffset.y;
        }

        protected float CalculateUVClip(double percent)
        {
            return (float)percent * _uvScale.y - _uvOffset.y;
        }

        protected float CalculateUVClamp(double percent)
        {
            return (float)DMath.InverseLerp(clipFrom, clipTo, percent) * _uvScale.y - _uvOffset.y;
        }

        protected float GetBaseSize(SplineSample sample)
        {
            return _useSplineSize? sample.size: 1f;
        }

        protected Color GetBaseColor(SplineSample sample)
        {
            return _useSplineColor ? sample.color : Color.white;
        }

        protected virtual void CreateMesh()
        {
            _tsMesh = new TS_Mesh();
            _mesh = new Mesh();
            _mesh.name = meshName;
            _mesh.indexFormat = _meshIndexFormat;
            _tsMesh.indexFormat = _meshIndexFormat;
            if (_markDynamic)
            {
                _mesh.MarkDynamic();
            }
        }

        private void RefreshMesh()
        {
            if (!Application.isPlaying)
            {
                DestroyImmediate(_mesh);
            } 
            else
            {
                Destroy(_mesh);
            }
            _mesh = null;
            _tsMesh.Clear();
            _tsMesh = null;
            CreateMesh();
        }
    }

  
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/MeshGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Node.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a212c074803b6824cae48ffa7abb84cf
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;

namespace Dreamteck.Splines
{
    [ExecuteInEditMode]
    [AddComponentMenu("Dreamteck/Splines/Node Connector")]
    public class Node : MonoBehaviour
    {
        [System.Serializable]
        public class Connection
        {
            public SplineComputer spline
            {
                get { return _computer; }
            }

            public int pointIndex
            {
                get { return _pointIndex; }
            }

            public bool invertTangents = false;

            [SerializeField]
            private int _pointIndex = 0;
            [SerializeField]
            private SplineComputer _computer = null;
            [SerializeField]
            [HideInInspector]
            internal SplinePoint point;

            internal bool isValid
            {
                get
                {
                    if (_computer == null) return false;
                    if (_pointIndex >= _computer.pointCount) return false;
                    return true;
                }
            }

            internal Connection(SplineComputer comp, int index, SplinePoint inputPoint)
            {
                _pointIndex = index;
                _computer = comp;
                point = inputPoint;
            }
        }
        public enum Type { Smooth, Free }
        [HideInInspector]
        public Type type = Type.Smooth;

        public bool transformNormals
        {
            get { return _transformNormals; }
            set
            {
                if (value != _transformNormals)
                {
                    _transformNormals = value;
                    UpdatePoints();
                }
            }
        }

        public bool transformSize
        {
            get { return _transformSize; }
            set
            {
                if (value != _transformSize)
                {
                    _transformSize = value;
                    UpdatePoints();
                }
            }
        }

        public bool transformTangents
        {
            get { return _transformTangents; }
            set
            {
                if (value != _transformTangents)
                {
                    _transformTangents = value;
                    UpdatePoints();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        protected Connection[] connections = new Connection[0];
        [SerializeField]
        [HideInInspector]
        private bool _transformSize = true;
        [SerializeField]
        [HideInInspector]
        private bool _transformNormals = true;
        [SerializeField]
        [HideInInspector]
        private bool _transformTangents = true;

        private Vector3 _lastPosition, _lastScale;
        private Quaternion _lastRotation;
        private Transform _trs;

        private void Awake()
        {
            _trs = transform;
            SampleTransform();
        }


        void LateUpdate()
        {
            Run();
        }

        void Update()
        {
            Run();
        }

        bool TransformChanged()
        {
#if UNITY_EDITOR
            if(_trs == null) return _lastPosition != transform.position || _lastRotation != transform.rotation || _lastScale != transform.lossyScale;
#endif
            return _lastPosition != _trs.position || _lastRotation != _trs.rotation || _lastScale != _trs.lossyScale;
        }

        void SampleTransform() {
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                _lastPosition = transform.position;
                _lastScale = transform.lossyScale;
                _lastRotation = transform.rotation;
            } 
            else
            {
                _lastPosition = _trs.position;
                _lastScale = _trs.lossyScale;
                _lastRotation = _trs.rotation;
            }
            return;
#else
            _lastPosition = _trs.position;
            _lastScale = _trs.lossyScale;
            _lastRotation = _trs.rotation;
#endif
        }

        private void Run()
        {
            if (TransformChanged())
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                {
                    UnityEditor.EditorUtility.SetDirty(this);
                    for (int i = 0; i < connections.Length; i++)
                    {
                        UnityEditor.EditorUtility.SetDirty(connections[i].spline);
                    }
                }
#endif
                UpdateConnectedComputers();
                SampleTransform();
            }
        }

        public SplinePoint GetPoint(int connectionIndex, bool swapTangents)
        {
            SplinePoint point = PointToWorld(connections[connectionIndex].point);
            if (connections[connectionIndex].invertTangents && swapTangents)
            {
                Vector3 tempTan = point.tangent;
                point.tangent = point.tangent2;
                point.tangent2 = tempTan;
            }
            return point;
        }

        public void SetPoint(int connectionIndex, SplinePoint worldPoint, bool swappedTangents)
        {
            Connection connection = connections[connectionIndex];
            connection.point = PointToLocal(worldPoint);
            if (connection.invertTangents && swappedTangents)
            {
                Vector3 tempTan = connection.point.tangent;
                connection.point.tangent = connection.point.tangent2;
                connection.point.tangent2 = tempTan;
            }
            if (type == Type.Smooth)
            {
                if (connection.point.type == SplinePoint.Type.SmoothFree)
                {
                    for (int i = 0; i < connections.Length; i++)
                    {
                        if (i == connectionIndex) continue;
                        Vector3 tanDir = (connection.point.tangent - connection.point.position).normalized;
                        if (tanDir == Vector3.zero) tanDir = -(connection.point.tangent2 - connection.point.position).normalized;
                        float tan1Length = (connections[i].point.tangent - connections[i].point.position).magnitude;
                        float tan2Length = (connections[i].point.tangent2 - connections[i].point.position).magnitude;
                        connections[i].point = connection.point;
                        connections[i].point.tangent = connections[i].point.position + tanDir * tan1Length;
                        connections[i].point.tangent2 = connections[i].point.position - tanDir * tan2Length;
                    }
                }
                else
                {
                    for (int i = 0; i < connections.Length; i++)
                    {
                        if (i == connectionIndex) continue;
                        connections[i].point = connection.point;
                    }
                }
            }
        }

        void OnDestroy()
        {
            ClearConnections();
        }

        public void ClearConnections()
        {
            for (int i = connections.Length-1; i >= 0; i--)
            {
                if (connections[i].spline != null) connections[i].spline.DisconnectNode(connections[i].pointIndex);
            }
            connections = new Connection[0];
        }

        public void UpdateConnectedComputers(SplineComputer excludeComputer = null)
        {
            for (int i = connections.Length - 1; i >= 0; i--)
            {
                if (!connections[i].isValid)
                {
                    RemoveConnection(i);
                    continue;
                }

                if (connections[i].spline == excludeComputer) continue;

                if (type == Type.Smooth && i != 0)
                {
                    SetPoint(i, GetPoint(0, false), false);
                }
                SplinePoint point = GetPoint(i, true);
                if (!transformNormals)
                {
                    point.normal = connections[i].spline.GetPointNormal(connections[i].pointIndex);
                }
                if (!transformTangents)
                {
                    point.tangent = connections[i].spline.GetPointTangent(connections[i].pointIndex);
                    point.tangent2 = connections[i].spline.GetPointTangent2(connections[i].pointIndex);
                }
                if (!transformSize)
                {
                    point.size = connections[i].spline.GetPointSize(connections[i].pointIndex);
                }
                connections[i].spline.SetPoint(connections[i].pointIndex, point);
            }
        }

        public void UpdatePoint(SplineComputer computer, int pointIndex, SplinePoint point, bool updatePosition = true)
        {
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                transform.position = point.position;
            }
            else
            {
                _trs.position = point.position;
            }
#else
            _trs.position = point.position;
#endif
            for (int i = 0; i < connections.Length; i++)
            {
                if (connections[i].spline == computer && connections[i].pointIndex == pointIndex)
                {
                    SetPoint(i, point, true);
                }
            }
        }

        public void UpdatePoints()
        {
            for (int i = connections.Length - 1; i >= 0; i--)
            {
                if (!connections[i].isValid)
                {
                    RemoveConnection(i);
                    continue;
                }
                SplinePoint point = connections[i].spline.GetPoint(connections[i].pointIndex);
                point.SetPosition(transform.position);
                SetPoint(i, point, true);
            }
        }

#if UNITY_EDITOR
        //Use this to maintain the connections between computers in the editor
        public void EditorMaintainConnections()
        {
            RemoveInvalidConnections();
        }
#endif
        //Remove invalid connections
        protected void RemoveInvalidConnections()
        {
            for (int i = connections.Length - 1; i >= 0; i--)
            {
                if (connections[i] == null || !connections[i].isValid) RemoveConnection(i);
            }
        }

        public virtual void AddConnection(SplineComputer computer, int pointIndex)
        {
            RemoveInvalidConnections();
            Node connected = computer.GetNode(pointIndex);
            if (connected != null)
            {
                Debug.LogError(computer.name + " is already connected to node " + connected.name + " at point " + pointIndex);
                return;
            }
            SplinePoint point = computer.GetPoint(pointIndex);
            point.SetPosition(transform.position);
            ArrayUtility.Add(ref connections, new Connection(computer, pointIndex, PointToLocal(point)));
            if(connections.Length == 1) SetPoint(connections.Length - 1, point, true);
            UpdateConnectedComputers();
        }

        protected SplinePoint PointToLocal(SplinePoint worldPoint)
        {
            worldPoint.position = Vector3.zero;
            worldPoint.tangent = transform.InverseTransformPoint(worldPoint.tangent);
            worldPoint.tangent2 = transform.InverseTransformPoint(worldPoint.tangent2);
            worldPoint.normal = transform.InverseTransformDirection(worldPoint.normal);
            worldPoint.size /= (transform.localScale.x + transform.localScale.y + transform.localScale.z)/ 3f;
            return worldPoint;
        }

        protected SplinePoint PointToWorld(SplinePoint localPoint)
        {
            localPoint.position = transform.position;
            localPoint.tangent = transform.TransformPoint(localPoint.tangent);
            localPoint.tangent2 = transform.TransformPoint(localPoint.tangent2);
            localPoint.normal = transform.TransformDirection(localPoint.normal);
            localPoint.size *= (transform.localScale.x + transform.localScale.y + transform.localScale.z) / 3f;
            return localPoint;
        }

        public virtual void RemoveConnection(SplineComputer computer, int pointIndex)
        {
            int index = -1;
            for (int i = 0; i < connections.Length; i++)
            {
                if (connections[i].pointIndex == pointIndex && connections[i].spline == computer)
                {
                    index = i;
                    break;
                }
            }
            if (index < 0) return;
            RemoveConnection(index);
        }

        private void RemoveConnection(int index)
        {
            Connection[] newConnections = new Connection[connections.Length - 1];
            SplineComputer spline = connections[index].spline;
            int pointIndex = connections[index].pointIndex;
            for (int i = 0; i < connections.Length; i++)
            {
                if (i < index) newConnections[i] = connections[i];
                else if (i == index) continue;
                else newConnections[i - 1] = connections[i];
            }
            connections = newConnections;
        }

        public virtual bool HasConnection(SplineComputer computer, int pointIndex)
        {
            for (int i = connections.Length - 1; i >= 0; i--)
            {
                if (!connections[i].isValid)
                {
                    RemoveConnection(i);
                    continue;
                }
                if (connections[i].spline == computer && connections[i].pointIndex == pointIndex) return true;
            }
            return false;
        }

        public Connection[] GetConnections()
        {
            return connections;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Node.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectBender.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f64d070be79692d449ab6f792ee7fb57
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System.Collections;
using System.Collections.Generic;
using System.Threading;

namespace Dreamteck.Splines
{
    [AddComponentMenu("Dreamteck/Splines/Users/Object Bender")]
    public class ObjectBender : SplineUser
    {
        public enum Axis { X, Y, Z }
        public enum NormalMode { Spline, Auto, Custom }
        public enum ForwardMode { Spline, Custom }
        public bool bend
        {
            get { return _bend; }
            set
            {
               if(_bend != value)
                {
                    _bend = value;
                    if (value)
                    {
                        UpdateReferences();
                        Rebuild();
                    } else Revert();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private bool _bend = false;
        public Axis axis
        {
            get { return _axis; }
            set
            {
                if (spline != null && value != _axis)
                {
                    _axis = value;
                    UpdateReferences();
                    Rebuild();
                }
                else _axis = value;
            }
        }

        public NormalMode upMode
        {
            get { return _normalMode; }
            set
            {
                if (spline != null && value != _normalMode)
                {
                    _normalMode = value;
                    Rebuild();
                } else _normalMode = value;
            }
        }

        public Vector3 customNormal
        {
            get { return _customNormal; }
            set
            {
                if (spline != null && value != _customNormal)
                {
                    _customNormal = value;
                    Rebuild();
                }
                else _customNormal = value;
            }
        }

        public ForwardMode forwardMode
        {
            get { return _forwardMode; }
            set
            {
                if (spline != null && value != _forwardMode)
                {
                    _forwardMode = value;
                    Rebuild();
                } else _forwardMode = value;
            }
        }

        public Vector3 customForward
        {
            get { return _customForward; }
            set
            {
                if (spline != null && value != _customForward)
                {
                    _customForward = value;
                    Rebuild();
                }
                else _customForward = value;
            }
        }
        [HideInInspector]
        public BendProperty[] bendProperties = new BendProperty[0];
        [SerializeField]
        [HideInInspector]
        private bool _parentIsTheSpline = false;
        [SerializeField]
        [HideInInspector]
        private TS_Bounds bounds = null;

        [SerializeField]
        [HideInInspector]
        private Axis _axis = Axis.Z;
        [SerializeField]
        [HideInInspector]
        private NormalMode _normalMode = NormalMode.Auto;
        [SerializeField]
        [HideInInspector]
        private ForwardMode _forwardMode = ForwardMode.Spline;
        [SerializeField]
        [HideInInspector]
        [UnityEngine.Serialization.FormerlySerializedAs("_upVector")]
        private Vector3 _customNormal = Vector3.up;
        [SerializeField]
        [HideInInspector]
        private Vector3 _customForward = Vector3.forward;
        Matrix4x4 normalMatrix = new Matrix4x4();
        Quaternion bendRotation = Quaternion.identity;

        private void GetTransformsRecursively(Transform current, ref List<Transform> transformList)
        {
            transformList.Add(current);
            foreach (Transform child in current)
            {
                GetTransformsRecursively(child, ref transformList);
            }
        }

        private void GetObjects()
        {
            List<Transform> found = new List<Transform>();
            GetTransformsRecursively(transform, ref found);
            BendProperty[] newProperties = new BendProperty[found.Count];
            for (int i = 0; i < found.Count; i++)
            {
                CreateProperty(ref newProperties[i], found[i]);
            }
            bendProperties = newProperties;
            SplineComputer splineComponent = GetComponent<SplineComputer>();
            _parentIsTheSpline = splineComponent == spline;
        }

        public TS_Bounds GetBounds()
        {
            return new TS_Bounds(bounds.min, bounds.max, bounds.center);
        }

#if UNITY_EDITOR
        public void EditorGenerateLightmapUVs()
        {
            for (int i = 0; i < bendProperties.Length; i++)
            {
                if (bendProperties[i].bendMesh)
                {
                    if (bendProperties[i].filter == null) continue;
                    if (bendProperties[i].filter.sharedMesh == null) continue;
                    EditorUtility.DisplayProgressBar("Generating Lightmap UVS", bendProperties[i].filter.sharedMesh.name, (float)i / (bendProperties.Length - 1));
                    Unwrapping.GenerateSecondaryUVSet(bendProperties[i].filter.sharedMesh);
                }
            }
            EditorUtility.ClearProgressBar();
        }
#endif

        private void CreateProperty(ref BendProperty property, Transform t)
        {
            property = new BendProperty(t, t == transform); //Create a new bend property for each child
            for (int i = 0; i < bendProperties.Length; i++)
            {
                //Search for properties that have the same trasform and copy their settings
                if (bendProperties[i].transform.transform == t)
                {
                    property.enabled = bendProperties[i].enabled;
                    property.applyRotation = bendProperties[i].applyRotation;
                    property.applyScale = bendProperties[i].applyScale;
                    property.bendMesh = bendProperties[i].bendMesh;
                    property.bendCollider = bendProperties[i].bendCollider;
                    property.generateLightmapUVs = bendProperties[i].generateLightmapUVs;
                    property.colliderUpdateRate = bendProperties[i].colliderUpdateRate;
                    break;
                }
            }

            if (t.transform != trs)
            {
                property.originalPosition = trs.InverseTransformPoint(t.position);
                property.originalRotation = Quaternion.Inverse(trs.rotation) * t.rotation;
            }
        }

        private void CalculateBounds()
        {
            if (bounds == null) bounds = new TS_Bounds(Vector3.zero, Vector3.zero);
            bounds.min = bounds.max = Vector3.zero;
            for (int i = 0; i < bendProperties.Length; i++)
            {
                CalculatePropertyBounds(ref bendProperties[i]);
            }
            for (int i = 0; i < bendProperties.Length; i++)
            {
                CalculatePercents(bendProperties[i]);
            }
        }

        private void CalculatePropertyBounds(ref BendProperty property)
        {
            if (!property.enabled) return;
            if (property.isParent && _parentIsTheSpline) return;
            if (property.transform.transform == trs)
            {
                if (0f < bounds.min.x) bounds.min.x = 0f;
                if (0f < bounds.min.y) bounds.min.y = 0f;
                if (0f < bounds.min.z) bounds.min.z = 0f;
                if (0f > bounds.max.x) bounds.max.x = 0f;
                if (0f > bounds.max.y) bounds.max.y = 0f;
                if (0f > bounds.max.z) bounds.max.z = 0f;
            }
            else
            {
                if (property.originalPosition.x < bounds.min.x) bounds.min.x = property.originalPosition.x;
                if (property.originalPosition.y < bounds.min.y) bounds.min.y = property.originalPosition.y;
                if (property.originalPosition.z < bounds.min.z) bounds.min.z = property.originalPosition.z;
                if (property.originalPosition.x > bounds.max.x) bounds.max.x = property.originalPosition.x;
                if (property.originalPosition.y > bounds.max.y) bounds.max.y = property.originalPosition.y;
                if (property.originalPosition.z > bounds.max.z) bounds.max.z = property.originalPosition.z;
            }
            if (property.editMesh != null)
            {
                for (int n = 0; n < property.editMesh.vertices.Length; n++)
                {
                    Vector3 localPos = property.transform.TransformPoint(property.editMesh.vertices[n]);
                    localPos = trs.InverseTransformPoint(localPos);
                    if (localPos.x < bounds.min.x) bounds.min.x = localPos.x;
                    if (localPos.y < bounds.min.y) bounds.min.y = localPos.y;
                    if (localPos.z < bounds.min.z) bounds.min.z = localPos.z;
                    if (localPos.x > bounds.max.x) bounds.max.x = localPos.x;
                    if (localPos.y > bounds.max.y) bounds.max.y = localPos.y;
                    if (localPos.z > bounds.max.z) bounds.max.z = localPos.z;
                }
            }

            if (property.editColliderMesh != null)
            {
                for (int n = 0; n < property.editColliderMesh.vertices.Length; n++)
                {
                    Vector3 localPos = property.transform.TransformPoint(property.editColliderMesh.vertices[n]);
                    localPos = trs.InverseTransformPoint(localPos);
                    if (localPos.x < bounds.min.x) bounds.min.x = localPos.x;
                    if (localPos.y < bounds.min.y) bounds.min.y = localPos.y;
                    if (localPos.z < bounds.min.z) bounds.min.z = localPos.z;
                    if (localPos.x > bounds.max.x) bounds.max.x = localPos.x;
                    if (localPos.y > bounds.max.y) bounds.max.y = localPos.y;
                    if (localPos.z > bounds.max.z) bounds.max.z = localPos.z;
                }
            }

            if (property.originalSpline != null)
            {
                for (int n = 0; n < property.originalSpline.points.Length; n++)
                {
                    Vector3 localPos = trs.InverseTransformPoint(property.originalSpline.points[n].position);
                    if (localPos.x < bounds.min.x) bounds.min.x = localPos.x;
                    if (localPos.y < bounds.min.y) bounds.min.y = localPos.y;
                    if (localPos.z < bounds.min.z) bounds.min.z = localPos.z;
                    if (localPos.x > bounds.max.x) bounds.max.x = localPos.x;
                    if (localPos.y > bounds.max.y) bounds.max.y = localPos.y;
                    if (localPos.z > bounds.max.z) bounds.max.z = localPos.z;
                }
            }
            bounds.CreateFromMinMax(bounds.min, bounds.max);
        }

        public void CalculatePercents(BendProperty property)
        {
            if (property.transform.transform != trs) property.positionPercent = GetPercentage(trs.InverseTransformPoint(property.transform.position));
            else property.positionPercent = GetPercentage(Vector3.zero);
            if (property.editMesh != null)
            {
                if (property.vertexPercents.Length != property.editMesh.vertexCount) property.vertexPercents = new Vector3[property.editMesh.vertexCount];
                if (property.editColliderMesh != null)
                {
                    if (property.colliderVertexPercents.Length != property.editMesh.vertexCount) property.colliderVertexPercents = new Vector3[property.editColliderMesh.vertexCount];
                }
                for (int i = 0; i < property.editMesh.vertexCount; i++)
                {
                    Vector3 localVertex = property.transform.TransformPoint(property.editMesh.vertices[i]);
                    localVertex = trs.InverseTransformPoint(localVertex);
                    property.vertexPercents[i] = GetPercentage(localVertex);   
                }
                if (property.editColliderMesh != null)
                {
                    for (int i = 0; i < property.editColliderMesh.vertexCount; i++)
                    {
                        Vector3 localVertex = property.transform.TransformPoint(property.editColliderMesh.vertices[i]);
                        localVertex = trs.InverseTransformPoint(localVertex);
                        property.colliderVertexPercents[i] = GetPercentage(localVertex);
                    }
                }
            }
            if (property.splineComputer != null)
            {
                SplinePoint[] points = property.splineComputer.GetPoints();
                property.splinePointPercents = new Vector3[points.Length];
                property.primaryTangentPercents = new Vector3[points.Length];
                property.secondaryTangentPercents = new Vector3[points.Length];
                for (int i = 0; i < points.Length; i++)
                {
                    property.splinePointPercents[i] = GetPercentage(trs.InverseTransformPoint(points[i].position));
                    property.primaryTangentPercents[i] = GetPercentage(trs.InverseTransformPoint(points[i].tangent));
                    property.secondaryTangentPercents[i] = GetPercentage(trs.InverseTransformPoint(points[i].tangent2));
                }
            }
        }

        private void Revert()
        {
            for (int i = 0; i < bendProperties.Length; i++)
            {
                bendProperties[i].Revert();
            }
        }


        public void UpdateReferences()
        {
            if (!hasTransform)
            {
                CacheTransform();
            }
            if (_bend)
            {
                for (int i = 0; i < bendProperties.Length; i++) bendProperties[i].Revert();
            }
            GetObjects();
            CalculateBounds();
            if (_bend)
            {
                Bend();
                for (int i = 0; i < bendProperties.Length; i++)
                {
                    bendProperties[i].Apply(i > 0 || trs != spline.transform);
                    bendProperties[i].Update();
                }
            }
        }

        private void GetevalResult(Vector3 percentage)
        {
            switch (axis)
            {
                case Axis.X: Evaluate(percentage.x, ref evalResult); break;
                case Axis.Y: Evaluate(percentage.y, ref evalResult); break;
                case Axis.Z: Evaluate(percentage.z, ref evalResult); break;
            }
            switch (_normalMode)
            {
                case NormalMode.Auto: evalResult.up = Vector3.Cross(evalResult.forward, evalResult.right); break;
                case NormalMode.Custom: evalResult.up = _customNormal; break;
            }
            if (_forwardMode == ForwardMode.Custom) evalResult.forward = customForward;
            Vector3 right = evalResult.right;

            Quaternion axisRotation = Quaternion.identity;

            switch (axis)
            {
                case Axis.Z:
                    evalResult.position += right * Mathf.Lerp(bounds.min.x, bounds.max.x, percentage.x) * evalResult.size;
                    evalResult.position += evalResult.up * Mathf.Lerp(bounds.min.y, bounds.max.y, percentage.y) * evalResult.size;
                    break;
                case Axis.X:
                    axisRotation = Quaternion.Euler(0f, -90f, 0f);
                    evalResult.position += right * Mathf.Lerp(bounds.max.z, bounds.min.z, percentage.z) * evalResult.size;
                    evalResult.position += evalResult.up * Mathf.Lerp(bounds.min.y, bounds.max.y, percentage.y) * evalResult.size;
                    break;
                case Axis.Y:
                    axisRotation = Quaternion.Euler(90f, 0f, 0f);
                    evalResult.position += right * Mathf.Lerp(bounds.min.x, bounds.max.x, percentage.x) * evalResult.size;
                    evalResult.position += evalResult.up * Mathf.Lerp(bounds.min.z, bounds.max.z, percentage.z) * evalResult.size;
                    break;
            }

            bendRotation = evalResult.rotation * axisRotation;
            normalMatrix = Matrix4x4.TRS(evalResult.position, bendRotation, Vector3.one * evalResult.size).inverse.transpose;
        }

        private Vector3 GetPercentage(Vector3 point)
        {
            point.x = Mathf.InverseLerp(bounds.min.x, bounds.max.x, point.x);
            point.y = Mathf.InverseLerp(bounds.min.y, bounds.max.y, point.y);
            point.z = Mathf.InverseLerp(bounds.min.z, bounds.max.z, point.z);
            return point;
        }

        protected override void Build()
        {
            base.Build();
            if (_bend) Bend();
        }

        private void Bend()
        {
            if (sampleCount <= 1) return;
            if (bendProperties.Length == 0) return;
            for (int i = 0; i < bendProperties.Length; i++)
            {
                BendObject(bendProperties[i]);
            }
        }

        public void BendObject(BendProperty p)
        {
            if (!p.enabled) return;
            if (p.isParent && _parentIsTheSpline) return;
            GetevalResult(p.positionPercent);
            p.transform.position = evalResult.position;
            if (p.applyRotation)
            {
                //p.transform.rotation = evalResult.rotation * axisRotation * p.originalRotation;
                p.transform.rotation = bendRotation * (Quaternion.Inverse(p.parentRotation) * p.originalRotation);
            } else p.transform.rotation = p.originalRotation; 
            if (p.applyScale) p.transform.scale = p.originalScale * evalResult.size;

            Matrix4x4 toLocalMatrix = Matrix4x4.TRS(p.transform.position, p.transform.rotation, p.transform.scale).inverse;
            if (p.editMesh != null)
            {
                BendMesh(p.vertexPercents, p.normals, p.editMesh, toLocalMatrix);
                p.editMesh.hasUpdate = true;
            }

            if (p._editColliderMesh != null)
            {
                BendMesh(p.colliderVertexPercents, p.colliderNormals, p.editColliderMesh, toLocalMatrix);
                p.editColliderMesh.hasUpdate = true;
            }

            if (p.originalSpline != null && !p.isParent)
            {
                for (int n = 0; n < p.splinePointPercents.Length; n++)
                {
                    SplinePoint point = p.originalSpline.points[n];
                    GetevalResult(p.splinePointPercents[n]);
                    point.position = evalResult.position;
                    GetevalResult(p.primaryTangentPercents[n]);
                    point.tangent = evalResult.position;
                    GetevalResult(p.secondaryTangentPercents[n]);
                    point.tangent2 = evalResult.position;
                    switch (axis)
                    {
                        case Axis.X: point.normal = Quaternion.LookRotation(evalResult.forward, evalResult.up) * Quaternion.FromToRotation(Vector3.up, evalResult.up) * point.normal; break;
                        case Axis.Y: point.normal = Quaternion.LookRotation(evalResult.forward, evalResult.up) * Quaternion.FromToRotation(Vector3.up, evalResult.up) * point.normal; break;
                        case Axis.Z: point.normal = Quaternion.LookRotation(evalResult.forward, evalResult.up) * point.normal; break;
                    }
                    p.destinationSpline.points[n] = point;
                }
            }
        }

        void BendMesh(Vector3[] vertexPercents, Vector3[] originalNormals, TS_Mesh mesh, Matrix4x4 worldToLocalMatrix)
        {
            if(mesh.vertexCount != vertexPercents.Length)
            {
                Debug.LogError("Vertex count mismatch");
                return;
            }
            for (int i = 0; i < mesh.vertexCount; i++)
            {
                Vector3 percent = vertexPercents[i];
                if (axis == Axis.Y) percent.z = 1f - percent.z;
                GetevalResult(percent);
                mesh.vertices[i] = worldToLocalMatrix.MultiplyPoint3x4(evalResult.position);
                mesh.normals[i] = worldToLocalMatrix.MultiplyVector(normalMatrix.MultiplyVector(originalNormals[i]));
            }
        }

        protected override void PostBuild()
        {
            base.PostBuild();
            if (!_bend) return;
            for (int i = 0; i < bendProperties.Length; i++)
            {
                bendProperties[i].Apply(i > 0 || trs != spline.transform);
                bendProperties[i].Update();
            }
        }

        protected override void LateRun()
        {
            base.LateRun();
            for (int i = 0; i < bendProperties.Length; i++)
            {
                bendProperties[i].Update();
            }
        }


        [System.Serializable]
        public class BendProperty
        {
            public bool enabled = true;
            public bool isValid
            {
                get
                {
                    return transform != null && transform.transform != null;
                }
            }
            public TS_Transform transform;
            public bool applyRotation = true;
            public bool applyScale = true;
            public bool bendMesh
            {
                get { return _bendMesh; }
                set
                {
                    if (value != _bendMesh)
                    {
                        _bendMesh = value;
                        if (value)
                        {
                            if (filter != null && filter.sharedMesh != null)
                            {
                                normals = originalMesh.normals;
                                for (int i = 0; i < normals.Length; i++) normals[i] = transform.transform.TransformDirection(normals[i]);
                            }
                        } else RevertMesh();
                    }
                }
            }
            public bool generateLightmapUVs = false;
            public bool bendCollider
            {
                get { return _bendCollider; }
                set
                {
                    if (value != _bendCollider)
                    {
                        _bendCollider = value;
                        if (value)
                        {
                            if (collider != null && collider.sharedMesh != null && collider.sharedMesh != originalMesh) colliderNormals = originalColliderMesh.normals;
                        }
                        else RevertCollider();
                    }
                }
            }
            public bool bendSpline
            {
                get { return _bendSpline; }
                set
                {
                    _bendSpline = value;
                    if (value)
                    {

                    }
                }
            }
            [SerializeField]
            [HideInInspector]
            private bool _bendMesh = true;
            [SerializeField]
            [HideInInspector]
            private bool _bendSpline = true;
            [SerializeField]
            [HideInInspector]
            private bool _bendCollider = true;

            private float colliderUpdateDue = 0f;
            public float colliderUpdateRate = 0.2f;
            private bool updateCollider = false;

            public Vector3 originalPosition = Vector3.zero;
            public Vector3 originalScale = Vector3.one;
            public Quaternion originalRotation = Quaternion.identity;
            public Quaternion parentRotation = Quaternion.identity;
            public Vector3 positionPercent;

            public Vector3[] vertexPercents = new Vector3[0];
            public Vector3[] normals = new Vector3[0];
            public Vector3[] colliderVertexPercents = new Vector3[0];
            public Vector3[] colliderNormals = new Vector3[0];

            [SerializeField]
            [HideInInspector]
            private Mesh originalMesh = null;
            [SerializeField]
            [HideInInspector]
            private Mesh originalColliderMesh = null;
            private Spline _originalSpline;

            [SerializeField]
            [HideInInspector]
            private Mesh destinationMesh = null;
            [SerializeField]
            [HideInInspector]
            private Mesh destinationColliderMesh = null;
            public Spline destinationSpline;

            public TS_Mesh editMesh
            {
                get
                {
                    if (!bendMesh || originalMesh == null) _editMesh = null;
                    else if (_editMesh == null && originalMesh != null) _editMesh = new TS_Mesh(originalMesh);
                    return _editMesh;
                }
            }
            public TS_Mesh editColliderMesh
            {
                get
                {
                    if (!bendCollider || originalColliderMesh == null) _editColliderMesh = null;
                    else if (_editColliderMesh == null && originalColliderMesh != null && originalColliderMesh != originalMesh) _editColliderMesh = new TS_Mesh(originalColliderMesh);
                    return _editColliderMesh;
                }
            }
            public Spline originalSpline
            {
                get
                {
                    if (!bendSpline || splineComputer == null) _originalSpline = null;
                    else if (_originalSpline == null && splineComputer != null) {
                        _originalSpline = new Spline(splineComputer.type);
                        _originalSpline.points = splineComputer.GetPoints();
                    }
                    return _originalSpline;
                }
            }

            public TS_Mesh _editMesh = null;
            public TS_Mesh _editColliderMesh = null;

            public MeshFilter filter = null;
            public MeshCollider collider = null;
            public SplineComputer splineComputer = null;

            public Vector3[] splinePointPercents = new Vector3[0];
            public Vector3[] primaryTangentPercents = new Vector3[0];
            public Vector3[] secondaryTangentPercents = new Vector3[0];

            [SerializeField]
            [HideInInspector]
            private bool parent = false;

            public bool isParent {
                get { return parent;  }
            }


            public BendProperty(Transform t, bool parent = false)
            {
                this.parent = parent;
                transform = new TS_Transform(t);
                originalPosition = t.localPosition;
                originalScale = t.localScale;
                originalRotation = t.localRotation;
                parentRotation = t.transform.rotation;
                if (t.transform.parent != null) parentRotation = t.transform.parent.rotation;
                filter = t.GetComponent<MeshFilter>();
                collider = t.GetComponent<MeshCollider>();
                if (filter != null && filter.sharedMesh != null)
                {
                    originalMesh = filter.sharedMesh;
                    normals = originalMesh.normals;
                    for (int i = 0; i < normals.Length; i++) normals[i] = transform.transform.TransformDirection(normals[i]).normalized;
                }

                if (collider != null && collider.sharedMesh != null)
                {
                    originalColliderMesh = collider.sharedMesh;
                    colliderNormals = originalColliderMesh.normals;
                    for (int i = 0; i < colliderNormals.Length; i++) colliderNormals[i] = transform.transform.TransformDirection(colliderNormals[i]);
                }
                if (!parent) splineComputer = t.GetComponent<SplineComputer>();
                if (splineComputer != null)
                {
                    if (splineComputer.isClosed) originalSpline.Close();
                    destinationSpline = new Spline(originalSpline.type);
                    destinationSpline.points = new SplinePoint[originalSpline.points.Length];
                    destinationSpline.points = splineComputer.GetPoints();
                    if (splineComputer.isClosed) destinationSpline.Close();
                }
            }

            public void Revert()
            {
                if (!isValid) return;
                RevertTransform();
                RevertCollider();
                RevertMesh();
                if (splineComputer != null) splineComputer.SetPoints(_originalSpline.points);
            }

            private void RevertMesh()
            {
                if (filter != null) filter.sharedMesh = originalMesh;
                destinationMesh = null;
            }

            private void RevertTransform()
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                {
                    transform.transform.localPosition = originalPosition;
                    transform.transform.localRotation = originalRotation;
                }
                else
                {
                    transform.localPosition = originalPosition;
                    transform.localRotation = originalRotation;
                    transform.Update();
                }
#else
                transform.localPosition = originalPosition;
                transform.localRotation = originalRotation;
                transform.Update();
#endif
                transform.scale = originalScale;
                transform.Update();
            }

            private void RevertCollider()
            {
                if (collider != null) collider.sharedMesh = originalColliderMesh;
                destinationColliderMesh = null;
            }

            public void Apply(bool applyTransform)
            {
                if (!enabled) return;
                if (!isValid) return;
                if(applyTransform) transform.Update();
                if (editMesh != null && editMesh.hasUpdate)  ApplyMesh();
                if (bendCollider && collider != null)
                {
                    if (!updateCollider)
                    {
                        if((editColliderMesh == null && editMesh != null) || editColliderMesh != null)
                        {
                            updateCollider = true;
                            if(Application.isPlaying) colliderUpdateDue = Time.time + colliderUpdateRate;
                        }
                    }
                }
                if (splineComputer != null) ApplySpline();
            }

            public void Update()
            {
                if (Time.time >= colliderUpdateDue && updateCollider)
                {
                    updateCollider = false;
                    ApplyCollider();
                }
            }

            private void ApplyMesh()
            {
                if (filter == null) return;
                MeshUtility.CalculateTangents(editMesh);
                if (destinationMesh == null)
                {
                    destinationMesh = new Mesh();
                    destinationMesh.name = originalMesh.name;
                }

                editMesh.WriteMesh(ref destinationMesh);
                destinationMesh.RecalculateBounds();
                filter.sharedMesh = destinationMesh;
            }

            private void ApplyCollider()
            {
                if (collider == null) return;
                if (originalColliderMesh == originalMesh) collider.sharedMesh = filter.sharedMesh; //if the collider has the same mesh as the filter - just copy it
                else
                {
                    MeshUtility.CalculateTangents(editColliderMesh);
                    if (destinationColliderMesh == null)
                    {
                        destinationColliderMesh = new Mesh();
                        destinationColliderMesh.name = originalColliderMesh.name;
                    }
                    editColliderMesh.WriteMesh(ref destinationColliderMesh);
                    destinationColliderMesh.RecalculateBounds();
                    collider.sharedMesh = destinationColliderMesh;
                }
            }

            private void ApplySpline()
            {
                if (destinationSpline == null) return;
                splineComputer.SetPoints(destinationSpline.points);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectBender.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerCustomRuleBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a81cd2dca8dd58a46a1ff2451e09a21e
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;

    public class ObjectControllerCustomRuleBase : ScriptableObject
    {
        protected ObjectController currentController;
        protected SplineSample currentSample;
        protected int currentObjectIndex;
        protected int totalObjects;
        protected float currentObjectPercent
        {
            get { return (float)currentObjectIndex / (totalObjects - 1); }
        }

        public void SetContext(ObjectController context, SplineSample sample, int currentObject, int totalObjects)
        {
            currentController = context;
            currentSample = sample;
            this.currentObjectIndex = currentObject;
            this.totalObjects = totalObjects;
        }

        /// <summary>
        /// Implement this method to create custom positioning behaviors. The returned offset should be in local coordinates.
        /// </summary>
        /// <returns>Vector3 offset in local coordinates</returns>
        public virtual Vector3 GetOffset()
        {
            return currentSample.position;
        }

        /// <summary>
        /// Implement this method to create custom rotation behaviors. The returned rotation is in world space
        /// </summary>
        /// <returns>Quaternion rotation in world coordinates</returns>
        public virtual Quaternion GetRotation()
        {
            return currentSample.rotation;
        }

        /// <summary>
        /// Implement this method to create custom scaling behaviors.
        /// </summary>
        /// <returns>Vector3 scale</returns>
        public virtual Vector3 GetScale()
        {
            return Vector3.one * currentSample.size;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerCustomRuleBase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerSineRule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 34dc4bc87da1557438d48f8b38533bd8
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;

    //Use the CreateAssetMenu attribute to add the object to the Create Asset context menu
    //After that, go to Assets/Create/Dreamteck/Splines/... and create the scriptable object
    [CreateAssetMenu(menuName = "Dreamteck/Splines/Object Controller Rules/Sine Rule")]
    public class ObjectControllerSineRule : ObjectControllerCustomRuleBase
    {
        [SerializeField] private bool _useSplinePercent = false;
        [SerializeField] private float _frequency = 1f;
        [SerializeField] private float _amplitude = 1f;
        [SerializeField] private float _angle = 0f;
        [SerializeField] private float _minScale = 1f;
        [SerializeField] private float _maxScale = 1f;
        [SerializeField] [Range(0f, 1f)] private float _offset = 0f;

        public bool useSplinePercent
        {
            get { return _useSplinePercent; }
            set { _useSplinePercent = value; }
        }

        public float frequency
        {
            get { return _frequency; }
            set { _frequency = value; }
        }

        public float amplitude
        {
            get { return _amplitude; }
            set { _amplitude = value; }
        }

        public float angle
        {
            get { return _angle; }
            set { _angle = value; }
        }

        public float minScale
        {
            get { return _minScale; }
            set { _minScale = value; }
        }

        public float maxScale
        {
            get { return _maxScale; }
            set { _maxScale = value; }
        }

        public float offset
        {
            get { return _offset; }
            set { 
                _offset = value;
                if(_offset > 1)
                {
                    _offset -= Mathf.FloorToInt(_offset);
                }
                if(_offset < 0)
                {
                    _offset += Mathf.FloorToInt(-_offset);
                }
            }
        }

        //Override GetOffset, GetRotation and GetScale to implement custom behaviors
        //Use the information from currentSample, currentObjectIndex, totalObjects and currentObjectPercent

        public override Vector3 GetOffset()
        {
            float sin = GetSine();
            return Quaternion.AngleAxis(_angle, Vector3.forward) * Vector3.up * sin * _amplitude;
        }

        public override Vector3 GetScale()
        {
            return Vector3.Lerp(Vector3.one * _minScale, Vector3.one * _maxScale, GetSine());
        }

        private float GetSine()
        {
            float objectPercent = _useSplinePercent ? (float)currentSample.percent : currentObjectPercent;
            return Mathf.Sin((Mathf.PI * _offset) + objectPercent * Mathf.PI * _frequency);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerSineRule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerSpiralRule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: daebc70828e501444b23046e124e96f4
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;

    //Use the CreateAssetMenu attribute to add the object to the Create Asset context menu
    //After that, go to Assets/Create/Dreamteck/Splines/... and create the scriptable object
    [CreateAssetMenu(menuName = "Dreamteck/Splines/Object Controller Rules/Spiral Rule")]
    public class ObjectControllerSpiralRule : ObjectControllerCustomRuleBase
    {
        [SerializeField] private bool _useSplinePercent = false;
        [SerializeField] private float _revolve = 360f;
        [SerializeField] private Vector2 _startSize = Vector2.one;
        [SerializeField] private Vector2 _endSize = Vector2.one;        
        [SerializeField] [Range(0f, 1f)] private float _offset = 0f;

        public bool useSplinePercent
        {
            get { return _useSplinePercent; }
            set { _useSplinePercent = value; }
        }

        public float revolve
        {
            get { return _revolve; }
            set { _revolve = value; }
        }

        public Vector2 startSize
        {
            get { return _startSize; }
            set { _startSize = value; }
        }

        public Vector2 endSize
        {
            get { return _endSize; }
            set { _endSize = value; }
        }

        public float offset
        {
            get { return _offset; }
            set { 
                _offset = value;
                if(_offset > 1)
                {
                    _offset -= Mathf.FloorToInt(_offset);
                }
                if(_offset < 0)
                {
                    _offset += Mathf.FloorToInt(-_offset);
                }
            }
        }

        //Override GetOffset, GetRotation and GetScale to implement custom behaviors
        //Use the information from currentSample, currentObjectIndex, totalObjects and currentObjectPercent

        public override Vector3 GetOffset()
        {
            Vector3 offset = Quaternion.AngleAxis(_revolve * GetPercent(), Vector3.forward) * Vector3.up;
            Vector2 scale = Vector2.Lerp(_startSize, _endSize, GetPercent());
            offset.x *= scale.x;
            offset.y *= scale.y;
            return offset;
        }

        public override Quaternion GetRotation()
        {
            return currentSample.rotation * Quaternion.AngleAxis(_revolve * -GetPercent(), Vector3.forward);
        }

        private float GetPercent()
        {
            float percent = _useSplinePercent ? (float)currentSample.percent : currentObjectPercent + _offset;
            if (percent > 1)
            {
                percent -= Mathf.FloorToInt(percent);
            }
            if (percent < 0)
            {
                percent += Mathf.FloorToInt(-percent);
            }
            return percent;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController CustomRules/Classes/ObjectControllerSpiralRule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: acb0592a986cebb4287d41702ab6ea22
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Dreamteck.Splines
{
    [AddComponentMenu("Dreamteck/Splines/Users/Object Controller")]
    public class ObjectController : SplineUser
    {
        [System.Serializable]
        internal class ObjectControl
        {
            public bool isNull
            {
                get
                {
                    return gameObject == null;
                }
            }
            public Transform transform
            {
                get {
                    if (gameObject == null) return null;
                    return gameObject.transform;  
                }
            }
            public GameObject gameObject;
            public Vector3 position = Vector3.zero;
            public Quaternion rotation = Quaternion.identity;
            public Vector3 scale = Vector3.one;
            public bool active = true;

            public Vector3 baseScale = Vector3.one;

            public ObjectControl(GameObject input)
            {
                gameObject = input;
                baseScale = gameObject.transform.localScale;
            }

            public void Destroy()
            {
                if (gameObject == null) return;
                GameObject.Destroy(gameObject);
            }

            public void DestroyImmediate()
            {
                if (gameObject == null) return;
                GameObject.DestroyImmediate(gameObject);
            }

            public void Apply()
            {
                if (gameObject == null) return;
                transform.position = position;
                transform.rotation = rotation;
                transform.localScale = scale;
                gameObject.SetActive(active);
            }

        }

        public enum SpawnMethod { Count, Points }
        public enum ObjectMethod { Instantiate, GetChildren }
        public enum Positioning { Stretch, Clip }
        public enum Iteration { Ordered, Random }

        [SerializeField]
        [HideInInspector]
        public GameObject[] objects = new GameObject[0];

        public ObjectMethod objectMethod
        {
            get { return _objectMethod; }
            set
            {
                if (value != _objectMethod)
                {
                    if (value == ObjectMethod.GetChildren)
                    {
                        _objectMethod = value;
                        Spawn();
                    }
                    else _objectMethod = value;
                }
            }
        }

        public SpawnMethod spawnMethod
        {
            get { return _spawnMethod; }
            set
            {
                if (value != _spawnMethod)
                {
                    _spawnMethod = value;
                    Rebuild();
                }
            }
        }

        public int spawnCount
        {
            get { return _spawnCount; }
            set
            {
                if (value != _spawnCount)
                {
                    if (value < 0) value = 0;
                    if (_objectMethod == ObjectMethod.Instantiate)
                    {
                        if (value < _spawnCount)
                        {
                            _spawnCount = value;
                            Remove();
                        }
                        else
                        {
                            _spawnCount = value;
                            Spawn();
                        }
                    }
                    else _spawnCount = value;
                }
            }
        }

        public Positioning objectPositioning
        {
            get { return _objectPositioning; }
            set
            {
                if (value != _objectPositioning)
                {
                    _objectPositioning = value;
                    Rebuild();
                }
            }
        }

        public Iteration iteration
        {
            get { return _iteration; }
            set
            {
                if (value != _iteration)
                {
                    _iteration = value;
                    Rebuild();
                }
            }
        }

#if UNITY_EDITOR
        public bool retainPrefabInstancesInEditor
        {
            get { return _retainPrefabInstancesInEditor; }
            set
            {
                if (value != _retainPrefabInstancesInEditor)
                {
                    _retainPrefabInstancesInEditor = value;
                    Clear();
                    Spawn();
                    Rebuild();
                }
            }
        }
#endif

        public int randomSeed
        {
            get { return _randomSeed; }
            set
            {
                if (value != _randomSeed)
                {
                    _randomSeed = value;
                    Rebuild();
                }
            }
        }

        public Vector3 minOffset
        {
            get { return _minOffset; }
            set
            {
                if (value != _minOffset)
                {
                    _minOffset = value;
                    Rebuild();
                }
            }
        }

        public Vector3 maxOffset
        {
            get { return _maxOffset; }
            set
            {
                if (value != _maxOffset)
                {
                    _maxOffset = value;
                    Rebuild();
                }
            }
        }

        public bool offsetUseWorldCoords
        {
            get { return _offsetUseWorldCoords; }
            set
            {
                if (value != _offsetUseWorldCoords)
                {
                    _offsetUseWorldCoords = value;
                    Rebuild();
                }
            }
        }

        public Vector3 minRotation
        {
            get { return _minRotation; }
            set
            {
                if (value != _minRotation)
                {
                    _minRotation = value;
                    Rebuild();
                }
            }
        }

        public Vector3 maxRotation
        {
            get { return _maxRotation; }
            set
            {
                if (value != _maxRotation)
                {
                    _maxRotation = value;
                    Rebuild();
                }
            }
        }

        public Vector3 rotationOffset
        {
            get { return (_maxRotation+_minRotation)/2f; }
            set
            {
                if (value != _minRotation || value != _maxRotation)
                {
                    _minRotation = _maxRotation = value;
                    Rebuild();
                }
            }
        }

        public Vector3 minScaleMultiplier
        {
            get { return _minScaleMultiplier; }
            set
            {
                if (value != _minScaleMultiplier)
                {
                    _minScaleMultiplier = value;
                    Rebuild();
                }
            }
        }

        public Vector3 maxScaleMultiplier
        {
            get { return _maxScaleMultiplier; }
            set
            {
                if (value != _maxScaleMultiplier)
                {
                    _maxScaleMultiplier = value;
                    Rebuild();
                }
            }
        }

        public bool uniformScaleLerp
        {
            get { return _uniformScaleLerp; }
            set
            {
                if(value != _uniformScaleLerp)
                {
                    _uniformScaleLerp = value;
                    Rebuild();
                }
            }
        }

        public bool shellOffset
        {
            get { return _shellOffset; }
            set
            {
                if (value != _shellOffset)
                {
                    _shellOffset = value;
                    Rebuild();
                }
            }
        }

        public bool applyRotation
        {
            get { return _applyRotation; }
            set
            {
                if (value != _applyRotation)
                {
                    _applyRotation = value;
                    Rebuild();
                }
            }
        }

        public bool rotateByOffset
        {
            get { return _rotateByOffset; }
            set
            {
                if (value != _rotateByOffset)
                {
                    _rotateByOffset = value;
                    Rebuild();
                }
            }
        }

        public bool applyScale
        {
            get { return _applyScale; }
            set
            {
                if (value != _applyScale)
                {
                    _applyScale = value;
                    Rebuild();
                }
            }
        }

        public float evaluateOffset
        {
            get { return _evaluateOffset; }
            set
            {
                if (value != _evaluateOffset)
                {
                    _evaluateOffset = value;
                    Rebuild();
                }
            }
        }

        public float minObjectDistance
        {
            get { return _minObjectDistance; }
            set
            {
                if (value != _minObjectDistance)
                {
                    _minObjectDistance = value;
                    Rebuild();
                }
            }
        }

        public float maxObjectDistance
        {
            get { return _maxObjectDistance; }
            set
            {
                if (value != _maxObjectDistance)
                {
                    _maxObjectDistance = value;
                    Rebuild();
                }
            }
        }

        public ObjectControllerCustomRuleBase customOffsetRule
        {
            get { return _customOffsetRule; }
            set
            {
                if (value != _customOffsetRule)
                {
                    _customOffsetRule = value;
                    Rebuild();
                }
            }
        }

        public ObjectControllerCustomRuleBase customRotationRule
        {
            get { return _customRotationRule; }
            set
            {
                if (value != _customRotationRule)
                {
                    _customRotationRule = value;
                    Rebuild();
                }
            }
        }

        public ObjectControllerCustomRuleBase customScaleRule
        {
            get { return _customScaleRule; }
            set
            {
                if (value != _customScaleRule)
                {
                    _customScaleRule = value;
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private float _evaluateOffset = 0f;
        [SerializeField]
        [HideInInspector]
        private SpawnMethod _spawnMethod = SpawnMethod.Count;
        [SerializeField]
        [HideInInspector]
        private int _spawnCount = 0;
#if UNITY_EDITOR
        [SerializeField]
        [HideInInspector]
        private bool _retainPrefabInstancesInEditor = true;
#endif
        [SerializeField]
        [HideInInspector]
        private Positioning _objectPositioning = Positioning.Stretch;
        [SerializeField]
        [HideInInspector]
        private Iteration _iteration = Iteration.Ordered;
        [SerializeField]
        [HideInInspector]
        private int _randomSeed = 1;
        [SerializeField]
        [HideInInspector]
        private Vector3 _minOffset = Vector3.zero;
        [SerializeField]
        [HideInInspector]
        private Vector3 _maxOffset = Vector3.zero;
        [SerializeField]
        [HideInInspector]
        private bool _offsetUseWorldCoords = false;
        [SerializeField]
        [HideInInspector]
        private Vector3 _minRotation = Vector3.zero;
        [SerializeField]
        [HideInInspector]
        private Vector3 _maxRotation = Vector3.zero;
        [SerializeField]
        [HideInInspector]
        private bool _uniformScaleLerp = true;
        [SerializeField]
        [HideInInspector]
        private Vector3 _minScaleMultiplier = Vector3.one;
        [SerializeField]
        [HideInInspector]
        private Vector3 _maxScaleMultiplier = Vector3.one;
        [SerializeField]
        [HideInInspector]
        private bool _shellOffset = false;
        [SerializeField]
        [HideInInspector]
        private bool _applyRotation = true;
        [SerializeField]
        [HideInInspector]
        private bool _rotateByOffset = false;
        [SerializeField]
        [HideInInspector]
        private bool _applyScale = false;
        [SerializeField]
        [HideInInspector]
        private ObjectMethod _objectMethod = ObjectMethod.Instantiate;
        [HideInInspector]
        public bool delayedSpawn = false;
        [HideInInspector]
        public float spawnDelay = 0.1f;
        [SerializeField]
        [HideInInspector]
        private int lastChildCount = 0;
        [SerializeField]
        [HideInInspector]
        private float lastPointCount = 0;
        [SerializeField]
        [HideInInspector]
        private ObjectControl[] spawned = new ObjectControl[0];
        [SerializeField]
        [HideInInspector]
        private bool _useCustomObjectDistance = false;
        [SerializeField]
        [HideInInspector]
        private float _minObjectDistance = 0f;
        [SerializeField]
        [HideInInspector]
        private float _maxObjectDistance = 0f;
        
        [SerializeField]
        [HideInInspector]
        private ObjectControllerCustomRuleBase _customOffsetRule;

        [SerializeField]
        [HideInInspector]
        private ObjectControllerCustomRuleBase _customRotationRule;

        [SerializeField]
        [HideInInspector]
        private ObjectControllerCustomRuleBase _customScaleRule;

        System.Random offsetRandomizer, shellRandomizer, rotationRandomizer, scaleRandomizer, distanceRandomizer;

        private int GetTargetCount()
        {
            switch (_spawnMethod)
            {
                case SpawnMethod.Points:
                    return spline.pointCount;
                case SpawnMethod.Count:
                default:
                    return spawnCount;
            }
        }

        public void Clear()
        {
            for (int i = 0; i < spawned.Length; i++)
            {
                if (spawned[i] == null || spawned[i].transform == null) continue;
                spawned[i].transform.localScale = spawned[i].baseScale;
                if (_objectMethod == ObjectMethod.GetChildren) spawned[i].gameObject.SetActive(false);
                else
                {
#if UNITY_EDITOR
                    if (!Application.isPlaying) spawned[i].DestroyImmediate();
                    else spawned[i].Destroy();
#else
                    spawned[i].Destroy();
#endif

                }
            }
            spawned = new ObjectControl[0];
        }

        private void OnValidate()
        {
            if (_spawnCount < 0) _spawnCount = 0;
        }

        private void Remove()
        {
            int targetCount = GetTargetCount();
            if (targetCount >= spawned.Length) return;
            for (int i = spawned.Length - 1; i >= targetCount; i--)
            {
                if (i >= spawned.Length) break;
                if (spawned[i] == null) continue;
                spawned[i].transform.localScale = spawned[i].baseScale;
                if (_objectMethod == ObjectMethod.GetChildren) spawned[i].gameObject.SetActive(false);
                else
                {
                    if (Application.isEditor) spawned[i].DestroyImmediate();
                    else spawned[i].Destroy();

                }
            }
            ObjectControl[] newSpawned = new ObjectControl[targetCount];
            for (int i = 0; i < newSpawned.Length; i++)
            {
                newSpawned[i] = spawned[i];
            }
            spawned = newSpawned;
            // For consistency, I rebuild immediately here too. That way,
            // the ObjectController behaves without glitching in all cases.
            RebuildImmediate();
        }

        public void GetAll()
        {
            ObjectControl[] newSpawned = new ObjectControl[transform.childCount];
            int index = 0;
            foreach (Transform child in transform)
            {
                if (newSpawned[index] == null)
                {
                    newSpawned[index++] = new ObjectControl(child.gameObject);
                    continue;
                }
                bool found = false;
                for (int i = 0; i < spawned.Length; i++)
                {
                    if (spawned[i].gameObject == child.gameObject)
                    {
                        newSpawned[index++] = spawned[i];
                        found = true;
                        break;
                    }
                }
                if (!found) newSpawned[index++] = new ObjectControl(child.gameObject);
            }
            spawned = newSpawned;
        }

        public void Spawn()
        {
            if (_objectMethod == ObjectMethod.Instantiate)
            {
                if (delayedSpawn && Application.isPlaying)
                {
                    StopCoroutine("InstantiateAllWithDelay");
                    StartCoroutine(InstantiateAllWithDelay());
                }
                else InstantiateAll();
            }
            else GetAll();
            Rebuild();
        }

        protected override void LateRun()
        {
            base.LateRun();
            if (_spawnMethod == SpawnMethod.Points && spline && lastPointCount != spline.pointCount)
            {
                if (_objectMethod != ObjectMethod.GetChildren) Remove();
                Spawn();
                lastPointCount = spline.pointCount;
            }
            if (_objectMethod == ObjectMethod.GetChildren && lastChildCount != transform.childCount)
            {
                Spawn();
                lastChildCount = transform.childCount;
            }
        }


        IEnumerator InstantiateAllWithDelay()
        {
            if (spline == null) yield break;
            if (objects.Length == 0) yield break;

            int targetCount = GetTargetCount();
            for (int i = spawned.Length; i < targetCount; i++)
            {
                InstantiateSingle();
                // Visual artifacts occur if not rebuilding immediately. Normally this can be solved
                // by calling RebuildImmediate on the spline after modifying it,
                // however, with delay this becomes difficult to control.
                // The first object would position correctly, but the rest would
                // have the wrong position for one frame, and the user would have to jump through
                // some hoops to rebuild the user in sync with spawning.
                RebuildImmediate();
                yield return new WaitForSeconds(spawnDelay);
            }
        }

        private void InstantiateAll()
        {
            if (spline == null) return;
            if (objects.Length == 0) return;

            int targetCount = GetTargetCount();
            for (int i = spawned.Length; i < targetCount; i++) InstantiateSingle();
            // For consistency, I rebuild immediately here too. That way, there is no need for the user
            // to figure out if the ObjectController has delay or not and keeps the usage simple.
            RebuildImmediate();
        }

        private void InstantiateSingle()
        {
            if (objects.Length == 0) return;
            int index = 0;
            if (_iteration == Iteration.Ordered)
            {
                index = spawned.Length - Mathf.FloorToInt(spawned.Length / objects.Length) * objects.Length;
            }
            else index = Random.Range(0, objects.Length);
            if (objects[index] == null) return;

            ObjectControl[] newSpawned = new ObjectControl[spawned.Length + 1];
            spawned.CopyTo(newSpawned, 0);
#if UNITY_EDITOR
            if (!Application.isPlaying && retainPrefabInstancesInEditor)
            {
                GameObject go = (GameObject)UnityEditor.PrefabUtility.InstantiatePrefab(objects[index]);
                go.transform.position = transform.position;
                go.transform.rotation = transform.rotation;
                newSpawned[newSpawned.Length - 1] = new ObjectControl(go);
            } else
            {
                newSpawned[newSpawned.Length - 1] = new ObjectControl((GameObject)Instantiate(objects[index], transform.position, transform.rotation));
            }
#else
            newSpawned[newSpawned.Length - 1] = new ObjectControl((GameObject)Instantiate(objects[index], transform.position, transform.rotation));
#endif
            newSpawned[newSpawned.Length - 1].transform.parent = transform;
            spawned = newSpawned;

#if UNITY_EDITOR
            // For prefabs, it is important that the spawned array gets marked as overridden.
            // Otherwise, the Object Controller will lose references to objects that were spawned
            // after prefab instantiation but before editor play/pause, causing it to leave behind
            // objects and instantiating extra ones.
            EditorUtility.SetDirty(this);
#endif
        }

        protected override void Build()
        {
            base.Build();
            offsetRandomizer = new System.Random(_randomSeed);
            if(_shellOffset) shellRandomizer = new System.Random(_randomSeed + 1);
            rotationRandomizer = new System.Random(_randomSeed + 2);
            scaleRandomizer = new System.Random(_randomSeed + 3);
            distanceRandomizer = new System.Random(_randomSeed + 4);

            bool hasCustomOffset = _customOffsetRule != null;
            bool hasCustomRotation = _customRotationRule != null;
            bool hasCustomScale = _customScaleRule != null;

            bool randomScaleMultiplier = _minScaleMultiplier != _maxScaleMultiplier;
            double distancePercentAccum = 0.0;
            for (int i = 0; i < spawned.Length; i++)
            {
                if (spawned[i] == null)
                {
                    Clear();
                    Spawn();
                    break;
                }
                float percent = 0f;
                if (spawned.Length > 1)
                {
                    if(!_useCustomObjectDistance)
                    {
                        if (spline.isClosed)
                        {
                            percent = (float)i / spawned.Length;
                        }
                        else
                        {
                            percent = (float)i / (spawned.Length - 1);
                        }
                    } else
                    {
                        percent = (float)distancePercentAccum;
                    }
                }

                percent += _evaluateOffset;
                if (percent > 1f)
                {
                    percent -= 1f;
                }
                else if (percent < 0f)
                {
                    percent += 1f;
                }
                
                if (objectPositioning == Positioning.Clip)
                {
                    spline.Evaluate(percent, ref evalResult);
                }
                else
                {
                    Evaluate(percent, ref evalResult);
                }

                spawned[i].position = evalResult.position;

                if (_applyScale)
                {
                    if (hasCustomScale)
                    {
                        _customScaleRule.SetContext(this, evalResult, i, spawned.Length);
                        spawned[i].scale = _customOffsetRule.GetScale();
                    } 
                    else
                    {
                        Vector3 scale = spawned[i].baseScale * evalResult.size;
                        Vector3 multiplier = _minScaleMultiplier;

                        if (randomScaleMultiplier)
                        {

                            if (_uniformScaleLerp)
                            {
                                multiplier = Vector3.Lerp(new Vector3(_minScaleMultiplier.x, _minScaleMultiplier.y, _minScaleMultiplier.z), new Vector3(_maxScaleMultiplier.x, _maxScaleMultiplier.y, _maxScaleMultiplier.z), (float)scaleRandomizer.NextDouble());
                            }
                            else
                            {
                                multiplier.x = Mathf.Lerp(_minScaleMultiplier.x, _maxScaleMultiplier.x, (float)scaleRandomizer.NextDouble());
                                multiplier.y = Mathf.Lerp(_minScaleMultiplier.y, _maxScaleMultiplier.y, (float)scaleRandomizer.NextDouble());
                                multiplier.z = Mathf.Lerp(_minScaleMultiplier.z, _maxScaleMultiplier.z, (float)scaleRandomizer.NextDouble());
                            }
                        }
                        scale.x *= multiplier.x;
                        scale.y *= multiplier.y;
                        scale.z *= multiplier.z;
                        spawned[i].scale = scale;
                    }
                }
                else
                {
                    spawned[i].scale = spawned[i].baseScale;
                }

                Vector3 right = Vector3.Cross(evalResult.forward, evalResult.up).normalized;

                Vector3 posOffset = _minOffset;
                if (hasCustomOffset)
                {
                    _customOffsetRule.SetContext(this, evalResult, i, spawned.Length);
                    posOffset = _customOffsetRule.GetOffset();
                } 
                else if (_minOffset != _maxOffset)
                {
                    if(_shellOffset)
                    {
                        float x = _maxOffset.x - _minOffset.x;
                        float y = _maxOffset.y - _minOffset.y;
                        float angleInRadians = (float)shellRandomizer.NextDouble() * 360f * Mathf.Deg2Rad;
                        posOffset = new Vector2(0.5f * Mathf.Cos(angleInRadians), 0.5f * Mathf.Sin(angleInRadians));
                        posOffset.x *= x;
                        posOffset.y *= y;
                    } else
                    {
                        float rnd = (float)offsetRandomizer.NextDouble();
                        posOffset.x = Mathf.Lerp(_minOffset.x, _maxOffset.x, rnd);
                        rnd = (float)offsetRandomizer.NextDouble();
                        posOffset.y = Mathf.Lerp(_minOffset.y, _maxOffset.y, rnd);
                        rnd = (float)offsetRandomizer.NextDouble();
                        posOffset.z = Mathf.Lerp(_minOffset.z, _maxOffset.z, rnd);
                    }
                }

                if (_offsetUseWorldCoords)
                {
                    spawned[i].position += posOffset;
                }
                else
                {
                    spawned[i].position += right * posOffset.x * evalResult.size + evalResult.up * posOffset.y * evalResult.size;
                }

                if (_applyRotation)
                {
                    if (hasCustomRotation)
                    {
                        _customRotationRule.SetContext(this, evalResult, i, spawned.Length);
                        spawned[i].rotation = _customRotationRule.GetRotation();
                    }
                    else
                    {
                        Quaternion offsetRot = Quaternion.Euler(Mathf.Lerp(_minRotation.x, _maxRotation.x, (float)rotationRandomizer.NextDouble()), Mathf.Lerp(_minRotation.y, _maxRotation.y, (float)rotationRandomizer.NextDouble()), Mathf.Lerp(_minRotation.z, _maxRotation.z, (float)rotationRandomizer.NextDouble()));
                        if (_rotateByOffset) spawned[i].rotation = Quaternion.LookRotation(evalResult.forward, spawned[i].position - evalResult.position) * offsetRot;
                        else spawned[i].rotation = evalResult.rotation * offsetRot;
                    }
                }

                if (_objectPositioning == Positioning.Clip)
                {
                    if (percent < clipFrom || percent > clipTo) spawned[i].active = false;
                    else spawned[i].active = true;
                }
                if (_useCustomObjectDistance)
                {
                    if (objectPositioning == Positioning.Clip)
                    {
                        distancePercentAccum = spline.Travel(distancePercentAccum, Mathf.Lerp(_minObjectDistance, _maxObjectDistance, (float)distanceRandomizer.NextDouble()));
                    }
                    else
                    {
                        distancePercentAccum = Travel(distancePercentAccum, Mathf.Lerp(_minObjectDistance, _maxObjectDistance, (float)distanceRandomizer.NextDouble()));
                    }
                }
            }
        }

        protected override void PostBuild()
        {
            base.PostBuild();
            for (int i = 0; i < spawned.Length; i++)
            {
                spawned[i].Apply();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ObjectController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ParticleController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 33cb05eb65206594b9076db71362bf8c
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;
    using System.Collections;
    using System.Collections.Generic;

    [ExecuteInEditMode]
    [AddComponentMenu("Dreamteck/Splines/Users/Particle Controller")]
    public class ParticleController : SplineUser
    {
        public ParticleSystem particleSystemComponent
        {
            get { return _particleSystem; }
            set {
                _particleSystem = value;
                _renderer = _particleSystem.GetComponent<ParticleSystemRenderer>();
            }
        }

        [SerializeField]
        [HideInInspector]
        private ParticleSystem _particleSystem;
        private ParticleSystemRenderer _renderer;
        public enum EmitPoint { Beginning, Ending, Random, Ordered }
        public enum MotionType { None, UseParticleSystem, FollowForward, FollowBackward, ByNormal, ByNormalRandomized }
        public enum Wrap { Default, Loop }

        [HideInInspector]
        public bool pauseWhenNotVisible = false;
        [HideInInspector]
        public Vector2 offset = Vector2.zero;
        [HideInInspector]
        public bool volumetric = false;
        [HideInInspector]
        public bool emitFromShell = false;
        [HideInInspector]
        public bool apply3DRotation = false;
        [HideInInspector]
        public Vector2 scale = Vector2.one;
        [HideInInspector]
        public EmitPoint emitPoint = EmitPoint.Beginning;
        [HideInInspector]
        public MotionType motionType = MotionType.UseParticleSystem;
        [HideInInspector]
        public Wrap wrapMode = Wrap.Default;
        [HideInInspector]
        public float minCycles = 1f;
        [HideInInspector]
        public float maxCycles = 1f;

        private ParticleSystem.Particle[] _particles = new ParticleSystem.Particle[0];
        private Particle[] _controllers = new Particle[0];
        private int _particleCount = 0;
        private int _birthIndex = 0;
        private List<Vector4> _customParticleData = new List<Vector4>();

        protected override void LateRun()
        {
            if (_particleSystem == null) return;
            if (pauseWhenNotVisible)
            {
                if (_renderer == null)
                {
                    _renderer = _particleSystem.GetComponent<ParticleSystemRenderer>();
                }
                if (!_renderer.isVisible) return;
            }

            int maxParticles = _particleSystem.main.maxParticles;
            if (_particles.Length != maxParticles)
            {
                _particles = new ParticleSystem.Particle[maxParticles];
                _customParticleData = new List<Vector4>(maxParticles);
                Particle[] newControllers = new Particle[maxParticles];
                for (int i = 0; i < newControllers.Length; i++)
                {
                    if (i >= _controllers.Length) break;
                    newControllers[i] = _controllers[i];
                }
                _controllers = newControllers;
            }
            _particleCount = _particleSystem.GetParticles(_particles);
            _particleSystem.GetCustomParticleData(_customParticleData, ParticleSystemCustomData.Custom1);

            bool isLocal = _particleSystem.main.simulationSpace == ParticleSystemSimulationSpace.Local;

            Transform particleSystemTransform = _particleSystem.transform;

            for (int i = 0; i < _particleCount; i++)
            {
                if (_controllers[i] == null)
                {
                    _controllers[i] = new Particle();
                }
                if (isLocal)
                {
                    TransformParticle(ref _particles[i], particleSystemTransform);
                }
                if (_customParticleData[i].w < 1f)
                {
                    OnParticleBorn(i);
                }
                HandleParticle(i);
                if (isLocal)
                {
                    InverseTransformParticle(ref _particles[i], particleSystemTransform);
                }
            }

            _particleSystem.SetCustomParticleData(_customParticleData, ParticleSystemCustomData.Custom1);
            _particleSystem.SetParticles(_particles, _particleCount);
        }

        void TransformParticle(ref ParticleSystem.Particle particle, Transform trs)
        {
            particle.position = trs.TransformPoint(particle.position);
            if (apply3DRotation)
            {

            }
            particle.velocity = trs.TransformDirection(particle.velocity);
        }

        void InverseTransformParticle(ref ParticleSystem.Particle particle, Transform trs)
        {
            particle.position = trs.InverseTransformPoint(particle.position);
            particle.velocity = trs.InverseTransformDirection(particle.velocity);
        }

        protected override void Reset()
        {
            base.Reset();
            updateMethod = UpdateMethod.LateUpdate;
            if (_particleSystem == null) _particleSystem = GetComponent<ParticleSystem>();
        }

        void HandleParticle(int index)
        {
            float lifePercent = _particles[index].remainingLifetime / _particles[index].startLifetime;
            if (motionType == MotionType.FollowBackward || motionType == MotionType.FollowForward || motionType == MotionType.None)
            {
                Evaluate(_controllers[index].GetSplinePercent(wrapMode, _particles[index], motionType), ref evalResult);
                Vector3 resultRight = evalResult.right;
                _particles[index].position = evalResult.position;
                if (apply3DRotation)
                {
                    _particles[index].rotation3D = evalResult.rotation.eulerAngles;
                }
                Vector2 finalOffset = offset;
                if (volumetric)
                {
                    if (motionType != MotionType.None)
                    {
                        finalOffset += Vector2.Lerp(_controllers[index].startOffset, _controllers[index].endOffset, 1f - lifePercent);
                        finalOffset.x *= scale.x;
                        finalOffset.y *= scale.y;
                    } else
                    {
                        finalOffset += _controllers[index].startOffset;
                    }
                }
                _particles[index].position += resultRight * (finalOffset.x * evalResult.size) + evalResult.up * (finalOffset.y * evalResult.size);
                _particles[index].velocity = evalResult.forward;
                _particles[index].startColor = _controllers[index].startColor * evalResult.color;
            }
        }

        private void OnParticleBorn(int index)
        {
            Vector4 custom = _customParticleData[index];
            custom.w = 1;
            _customParticleData[index] = custom;
            double percent = 0.0;
            float emissionRate = Mathf.Lerp(_particleSystem.emission.rateOverTime.constantMin, _particleSystem.emission.rateOverTime.constantMax, 0.5f);
            float expectedParticleCount = emissionRate * _particleSystem.main.startLifetime.constantMax;
            _birthIndex++;
            if (_birthIndex > expectedParticleCount)
            {
                _birthIndex = 0;
            }

            switch (emitPoint)
            {
                case EmitPoint.Beginning: percent = 0f; break;
                case EmitPoint.Ending: percent = 1f; break;
                case EmitPoint.Random: percent = Random.Range(0f, 1f); break;
                case EmitPoint.Ordered: percent = expectedParticleCount > 0 ? (float)_birthIndex / expectedParticleCount : 0f;  break;
            }
            Evaluate(percent, ref evalResult);
            _controllers[index].startColor = _particles[index].startColor;
            _controllers[index].startPercent = percent;

            _controllers[index].cycleSpeed = Random.Range(minCycles, maxCycles);
            Vector2 circle = Vector2.zero;
            if (volumetric)
            {
                if (emitFromShell) circle = Quaternion.AngleAxis(Random.Range(0f, 360f), Vector3.forward) * Vector2.right;
                else circle = Random.insideUnitCircle;
            }
            _controllers[index].startOffset = circle * 0.5f;
            _controllers[index].endOffset = Random.insideUnitCircle * 0.5f;


            Vector3 right = Vector3.Cross(evalResult.forward, evalResult.up);
            _particles[index].position = evalResult.position + right * _controllers[index].startOffset.x * evalResult.size * scale.x + evalResult.up * _controllers[index].startOffset.y * evalResult.size * scale.y;

            float forceX = _particleSystem.forceOverLifetime.x.constantMax;
            float forceY = _particleSystem.forceOverLifetime.y.constantMax;
            float forceZ = _particleSystem.forceOverLifetime.z.constantMax;
            if (_particleSystem.forceOverLifetime.randomized)
            {
                forceX = Random.Range(_particleSystem.forceOverLifetime.x.constantMin, _particleSystem.forceOverLifetime.x.constantMax);
                forceY = Random.Range(_particleSystem.forceOverLifetime.y.constantMin, _particleSystem.forceOverLifetime.y.constantMax);
                forceZ = Random.Range(_particleSystem.forceOverLifetime.z.constantMin, _particleSystem.forceOverLifetime.z.constantMax);
            }

            float time = _particles[index].startLifetime - _particles[index].remainingLifetime;
            Vector3 forceDistance = new Vector3(forceX, forceY, forceZ) * 0.5f * (time * time);

            float startSpeed = _particleSystem.main.startSpeed.constantMax;

            if (motionType == MotionType.ByNormal)
            {
                _particles[index].position += evalResult.up * startSpeed * (_particles[index].startLifetime - _particles[index].remainingLifetime);
                _particles[index].position += forceDistance;
                _particles[index].velocity = evalResult.up * startSpeed + new Vector3(forceX, forceY, forceZ) * time;
            }
            else if (motionType == MotionType.ByNormalRandomized)
            {
                Vector3 normal = Quaternion.AngleAxis(Random.Range(0f, 360f), evalResult.forward) * evalResult.up;
                _particles[index].position += normal * startSpeed * (_particles[index].startLifetime - _particles[index].remainingLifetime);
                _particles[index].position += forceDistance;
                _particles[index].velocity = normal * startSpeed + new Vector3(forceX, forceY, forceZ) * time;
            }
            HandleParticle(index);
        }

        public class Particle
        {
            internal Vector2 startOffset = Vector2.zero;
            internal Vector2 endOffset = Vector2.zero;
            internal float cycleSpeed = 0f;
            internal Color startColor = Color.white;
            internal double startPercent = 0.0;

            internal double GetSplinePercent(Wrap wrap, ParticleSystem.Particle particle, MotionType motionType)
            {
                float lifePercent = particle.remainingLifetime / particle.startLifetime;
                if(motionType == MotionType.FollowBackward)
                {
                    lifePercent = 1f - lifePercent;
                }
                switch (wrap)
                {
                    case Wrap.Default: return DMath.Clamp01(startPercent + (1f - lifePercent) * cycleSpeed);
                    case Wrap.Loop:
                        double loopPoint = startPercent + (1.0 - lifePercent) * cycleSpeed;
                        if(loopPoint > 1.0) loopPoint -= Mathf.FloorToInt((float)loopPoint);
                        return loopPoint;
                }
                return 0.0;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/ParticleController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/PathGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2e1690bb01d509a439fc991a10f8278f
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Threading;

namespace Dreamteck.Splines
{
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Dreamteck/Splines/Users/Path Generator")]
    public class PathGenerator : MeshGenerator
    {
        public int slices
        {
            get { return _slices; }
            set
            {
                if (value != _slices)
                {
                    if (value < 1) value = 1;
                    _slices = value;
                    Rebuild();
                }
            }
        }

        public bool useShapeCurve
        {
            get { return _useShapeCurve; }
            set
            {
                if (value != _useShapeCurve)
                {
                    _useShapeCurve = value;
                    if (_useShapeCurve)
                    {
                        _shape = new AnimationCurve();
                        _shape.AddKey(new Keyframe(0, 0));
                        _shape.AddKey(new Keyframe(1, 0));
                    } else _shape = null;
                    Rebuild();
                }
            }
        }

        public bool compensateCorners
        {
            get { return _compensateCorners; }
            set
            {
                if (value != _compensateCorners)
                {
                    _compensateCorners = value;
                    Rebuild();
                }
            }
        }

        public float shapeExposure
        {
            get { return _shapeExposure; }
            set
            {
                if (spline != null && value != _shapeExposure)
                {
                    _shapeExposure = value;
                    Rebuild();
                }
            }
        }

        public AnimationCurve shape
        {
            get { return _shape; }
            set
            {
                if(_lastShape == null) _lastShape = new AnimationCurve();
                bool keyChange = false;
                if (value.keys.Length != _lastShape.keys.Length) keyChange = true;
                else
                {
                    for (int i = 0; i < value.keys.Length; i++)
                    {
                        if (value.keys[i].inTangent != _lastShape.keys[i].inTangent || value.keys[i].outTangent != _lastShape.keys[i].outTangent || value.keys[i].time != _lastShape.keys[i].time || value.keys[i].value != value.keys[i].value)
                        {
                            keyChange = true;
                            break;
                        }
                    }
                }
                if (keyChange) Rebuild();
                _lastShape.keys = new Keyframe[value.keys.Length];
                value.keys.CopyTo(_lastShape.keys, 0);
                _lastShape.preWrapMode = value.preWrapMode;
                _lastShape.postWrapMode = value.postWrapMode;
                _shape = value;

            }
        }

        protected override string meshName => "Path";

        [SerializeField]
        [HideInInspector]
        private int _slices = 1;
        [SerializeField]
        [HideInInspector]
        [Tooltip("This will inflate sample sizes based on the angle between two samples in order to preserve geometry width")]
        private bool _compensateCorners = false;
        [SerializeField]
        [HideInInspector]
        private bool _useShapeCurve = false;
        [SerializeField]
        [HideInInspector]
        private AnimationCurve _shape;
        [SerializeField]
        [HideInInspector]
        private AnimationCurve _lastShape;
        [SerializeField]
        [HideInInspector]
        private float _shapeExposure = 1f;


        protected override void Reset()
        {
            base.Reset();
        }


        protected override void BuildMesh()
        {
           base.BuildMesh();
           GenerateVertices();
           MeshUtility.GeneratePlaneTriangles(ref _tsMesh.triangles, _slices, sampleCount, false);
        }


        void GenerateVertices()
        {
            int vertexCount = (_slices + 1) * sampleCount;
            AllocateMesh(vertexCount, _slices * (sampleCount-1) * 6);
            int vertexIndex = 0;

            ResetUVDistance();

            bool hasOffset = offset != Vector3.zero;
            for (int i = 0; i < sampleCount; i++)
            {
                if (_compensateCorners)
                {
                    GetSampleWithAngleCompensation(i, ref evalResult);
                }
                else
                {
                    GetSample(i, ref evalResult);
                }

                Vector3 center = Vector3.zero;
                try
                {
                   center = evalResult.position;
                } catch (System.Exception ex) { Debug.Log(ex.Message + " for i = " + i); return; }
                Vector3 right = evalResult.right;
                float resultSize = GetBaseSize(evalResult);
                if (hasOffset)
                {
                    center += (offset.x * resultSize) * right + (offset.y * resultSize) * evalResult.up + (offset.z * resultSize) * evalResult.forward;
                }
                float fullSize = size * resultSize;
                Vector3 lastVertPos = Vector3.zero;
                Quaternion rot = Quaternion.AngleAxis(rotation, evalResult.forward);
                if (uvMode == UVMode.UniformClamp || uvMode == UVMode.UniformClip) AddUVDistance(i);
                Color vertexColor = GetBaseColor(evalResult) * color;
                for (int n = 0; n < _slices + 1; n++)
                {
                    float slicePercent = ((float)n / _slices);
                    float shapeEval = 0f;
                    if (_useShapeCurve) shapeEval = _shape.Evaluate(slicePercent);
                    _tsMesh.vertices[vertexIndex] = center + rot * right * (fullSize * 0.5f) - rot * right * (fullSize * slicePercent) + rot * evalResult.up * (shapeEval * _shapeExposure);
                    CalculateUVs(evalResult.percent, 1f - slicePercent);
                    _tsMesh.uv[vertexIndex] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(uvRotation + 180f, Vector3.forward) * (Vector2.one * 0.5f - __uvs));
                    if (_slices > 1)
                    {
                        if (n < _slices)
                        {
                            float forwardPercent = ((float)(n + 1) / _slices);
                            shapeEval = 0f;
                            if (_useShapeCurve) shapeEval = _shape.Evaluate(forwardPercent);
                            Vector3 nextVertPos = center + rot * right * fullSize * 0.5f - rot * right * fullSize * forwardPercent + rot * evalResult.up * shapeEval * _shapeExposure;
                            Vector3 cross1 = -Vector3.Cross(evalResult.forward, nextVertPos - _tsMesh.vertices[vertexIndex]).normalized;

                            if (n > 0)
                            {
                                Vector3 cross2 = -Vector3.Cross(evalResult.forward, _tsMesh.vertices[vertexIndex] - lastVertPos).normalized;
                                _tsMesh.normals[vertexIndex] = Vector3.Slerp(cross1, cross2, 0.5f);
                            } else _tsMesh.normals[vertexIndex] = cross1;
                        }
                        else   _tsMesh.normals[vertexIndex] = -Vector3.Cross(evalResult.forward, _tsMesh.vertices[vertexIndex] - lastVertPos).normalized;
                    }
                    else
                    {
                        _tsMesh.normals[vertexIndex] = evalResult.up;
                        if (rotation != 0f) _tsMesh.normals[vertexIndex] = rot * _tsMesh.normals[vertexIndex];
                    }
                    _tsMesh.colors[vertexIndex] = vertexColor;
                    lastVertPos = _tsMesh.vertices[vertexIndex];
                    vertexIndex++;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/PathGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/PolygonColliderGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a4c6eacf526b59e41ad6bb0134d023f7
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Threading;
namespace Dreamteck.Splines
{
    [AddComponentMenu("Dreamteck/Splines/Users/Polygon Collider Generator")]
    [RequireComponent(typeof(PolygonCollider2D))]
    public class PolygonColliderGenerator : SplineUser
    {
        public enum Type { Path, Shape }
        public Type type
        {
            get
            {
                return _type;
            }
            set
            {
                if (value != _type)
                {
                    _type = value;
                    Rebuild();
                }
            }
        }

        public float size
        {
            get { return _size; }
            set
            {
                if (value != _size)
                {
                    _size = value;
                    Rebuild();
                }
            }
        }

        public float offset
        {
            get { return _offset; }
            set
            {
                if (value != _offset)
                {
                    _offset = value;
                    Rebuild();
                }
            }
        }
        [SerializeField]
        [HideInInspector]
        private Type _type = Type.Path;
        [SerializeField]
        [HideInInspector]
        private float _size = 1f;
        [SerializeField]
        [HideInInspector]
        private float _offset = 0f;
        [SerializeField]
        [HideInInspector]
        protected PolygonCollider2D polygonCollider;

        [SerializeField]
        [HideInInspector]
        protected Vector2[] vertices = new Vector2[0];

        [HideInInspector]
        public float updateRate = 0.1f;
        protected float lastUpdateTime = 0f;

        private bool updateCollider = false;

        protected override void Awake()
        {
            base.Awake();
            polygonCollider = GetComponent<PolygonCollider2D>();
        }


        protected override void Reset()
        {
            base.Reset();
        }

        protected override void OnEnable()
        {
            base.OnEnable();
        }

        protected override void OnDisable()
        {
            base.OnDisable();
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
        }

        protected override void LateRun()
        {
            base.LateRun();
            if (updateCollider)
            {
                if (polygonCollider != null)
                {
                    if (Time.time - lastUpdateTime >= updateRate)
                    {
                        lastUpdateTime = Time.time;
                        updateCollider = false;
                        polygonCollider.SetPath(0, vertices);
                    }
                }
            }
        }

        protected override void Build()
        {
            base.Build();
            switch(type){
                case Type.Path:
                GeneratePath();
                break;
                case Type.Shape: GenerateShape(); break;
            }

        }

        protected override void PostBuild()
        {
            base.PostBuild();
            if (polygonCollider == null) return;
            for(int i = 0; i < vertices.Length; i++)
            {
                vertices[i] = transform.InverseTransformPoint(vertices[i]);
            }
#if UNITY_EDITOR
            if (!Application.isPlaying || updateRate <= 0f) polygonCollider.SetPath(0, vertices);
            else updateCollider = true;
#else
            if(updateRate == 0f) polygonCollider.SetPath(0, vertices);
            else updateCollider = true;
#endif
        }

        private void GeneratePath()
        {
            int vertexCount = sampleCount * 2;
            if (vertices.Length != vertexCount) vertices = new Vector2[vertexCount];
            for (int i = 0; i < sampleCount; i++)
            {
                GetSample(i, ref evalResult);
                Vector2 right = new Vector2(-evalResult.forward.y, evalResult.forward.x).normalized * evalResult.size;
                vertices[i] = new Vector2(evalResult.position.x, evalResult.position.y) + right * size * 0.5f + right * offset;
                vertices[sampleCount + (sampleCount - 1) - i] = new Vector2(evalResult.position.x, evalResult.position.y) - right * size * 0.5f + right * offset;
            }
        }

        private void GenerateShape()
        {
            if (vertices.Length != sampleCount) vertices = new Vector2[sampleCount];
            for (int i = 0; i < sampleCount; i++)
            {
                GetSample(i, ref evalResult);
                vertices[i] = evalResult.position;
                if (offset != 0f)
                {
                    Vector2 right = new Vector2(-evalResult.forward.y, evalResult.forward.x).normalized * evalResult.size;
                    vertices[i] += right * offset;
                }
            }
        }
    }

  
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/PolygonColliderGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/ColorModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 07c5bf379e882994f9828b66623ef12f
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    [System.Serializable]
    public class ColorModifier : SplineSampleModifier
    {
        [System.Serializable]
        public class ColorKey : Key
        {
            public enum BlendMode { Lerp, Multiply, Add, Subtract }
            public Color color = Color.white;
            public BlendMode blendMode = BlendMode.Lerp;

            public ColorKey(double f, double t) : base(f, t)
            {
            }

            public Color Blend(Color input, float percent)
            {
                switch (blendMode)
                {
                    case BlendMode.Lerp: return Color.Lerp(input, color, blend * percent);
                    case BlendMode.Add: return input + color * blend * percent;
                    case BlendMode.Subtract: return input - color * blend * percent;
                    case BlendMode.Multiply: return Color.Lerp(input, input * color, blend * percent);
                    default: return input;
                }
            }
        }

        public override bool hasKeys => keys.Length > 0;
        public ColorKey[] keys = new ColorKey[0];

        public ColorModifier()
        {
            keys = new ColorKey[0];
        }

        public override List<Key> GetKeys()
        {
            return new List<Key>(keys);
        }

        public override void SetKeys(List<Key> input)
        {
            keys = new ColorKey[input.Count];
            for (int i = 0; i < input.Count; i++)
            {
                keys[i] = (ColorKey)input[i];
            }
            base.SetKeys(input);
        }

        public void AddKey(double f, double t)
        {
            ArrayUtility.Add(ref keys, new ColorKey(f, t));
        }

        public override void Apply(ref SplineSample result)
        {
            if (keys.Length == 0) return;
            base.Apply(ref result);
            for (int i = 0; i < keys.Length; i++)
            {
                result.color = keys[i].Blend(result.color, keys[i].Evaluate(result.percent) * blend);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/ColorModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/FollowerSpeedModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8ef79d2db1fdbb54588b21a1643fabd2
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    [System.Serializable]
    public class FollowerSpeedModifier : SplineSampleModifier
    {
        [System.Serializable]
        public class SpeedKey : Key
        {
            public enum Mode { Add, Multiply }
            public float speed = 0f;
            public Mode mode = Mode.Add;

            public SpeedKey(double f, double t) : base(f, t)
            {
            }
        }

        public override bool hasKeys => keys.Count > 0;
        public List<SpeedKey> keys = new List<SpeedKey>();

        public FollowerSpeedModifier()
        {
            keys = new List<SpeedKey>();
        }

        public override List<Key> GetKeys()
        {
            List<Key> output = new List<Key>();
            for (int i = 0; i < keys.Count; i++)
            {
                output.Add(keys[i]);
            }
            return output;
        }

        public override void SetKeys(List<Key> input)
        {
            keys = new List<SpeedKey>();
            for (int i = 0; i < input.Count; i++)
            {
                //input[i]._modifier = this;
                keys.Add((SpeedKey)input[i]);
            }
        }

        public void AddKey(double f, double t)
        {
            keys.Add(new SpeedKey(f, t));
        }

        public override void Apply(ref SplineSample result)
        {
        }

        public float GetSpeed(float input, double percent)
        {
            for (int i = 0; i < keys.Count; i++)
            {
                float lerp = keys[i].Evaluate(percent);
                if(keys[i].mode == SpeedKey.Mode.Add)
                {
                    input += keys[i].speed * lerp;
                } else
                {
                    input *= Mathf.Lerp(1f, keys[i].speed, lerp);
                }
            }
            return input;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/FollowerSpeedModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/MeshScaleModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7be735bc80e43dc43984bdce01839e2e
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    [System.Serializable]
    public class MeshScaleModifier : SplineSampleModifier
    {
        [System.Serializable]
        public class ScaleKey : Key
        {
            public Vector3 scale = Vector3.one;

            public ScaleKey(double f, double t) : base(f, t)
            {
            }
        }

        public override bool hasKeys => keys.Count > 0;
        public List<ScaleKey> keys = new List<ScaleKey>();

        public MeshScaleModifier()
        {
            keys = new List<ScaleKey>();
        }

        public override List<Key> GetKeys()
        {
            List<Key> output = new List<Key>();
            for (int i = 0; i < keys.Count; i++)
            {
                output.Add(keys[i]);
            }
            return output;
        }

        public override void SetKeys(List<Key> input)
        {
            keys = new List<ScaleKey>();
            for (int i = 0; i < input.Count; i++)
            {
                keys.Add((ScaleKey)input[i]);
            }
        }

        public void AddKey(double f, double t)
        {
            keys.Add(new ScaleKey(f, t));
        }

        public override void Apply(ref SplineSample result)
        {
            if (keys.Count == 0)
            {
                return;
            }
            for (int i = 0; i < keys.Count; i++)
            {
                result.size += keys[i].Evaluate(result.percent) * keys[i].scale.magnitude * blend;
            }
        }

        public Vector3 GetScale(SplineSample sample)
        {
            Vector3 scale = Vector3.one;
            for (int i = 0; i < keys.Count; i++)
            {
                float lerp = keys[i].Evaluate(sample.percent);
                Vector3 scaleMultiplier = Vector3.Lerp(Vector3.one, keys[i].scale, lerp);
                scale.x *= scaleMultiplier.x;
                scale.y *= scaleMultiplier.y;
                scale.z *= scaleMultiplier.z;
            }
            return Vector3.Lerp(Vector3.one, scale, blend);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/MeshScaleModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/OffsetModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9d0cc7c794f1e3148acddeb3d008c597
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    [System.Serializable]
    public class OffsetModifier : SplineSampleModifier
    {
        [System.Serializable]
        public class OffsetKey : Key
        {
            public Vector2 offset = Vector2.zero;
            public OffsetKey(Vector2 o, double f, double t) : base(f, t)
            {
                offset = o;
            }
        }

        public override bool hasKeys => keys.Length > 0;
        public OffsetKey[] keys = new OffsetKey[0];

        public OffsetModifier()
        {
            keys = new OffsetKey[0];
        }

        public override List<Key> GetKeys()
        {
            return new List<Key>(keys);
        }

        public override void SetKeys(List<Key> input)
        {
            keys = new OffsetKey[input.Count];
            for (int i = 0; i < input.Count; i++)
            {
                keys[i] = (OffsetKey)input[i];
            }
            base.SetKeys(input);
        }

        public void AddKey(Vector2 offset, double f, double t)
        {
            ArrayUtility.Add(ref keys, new OffsetKey(offset, f, t));
        }

        public override void Apply(ref SplineSample result)
        {
            if (keys.Length == 0) return;
            base.Apply(ref result);
            Vector2 offset = Evaluate(result.percent);
            result.position += result.right * offset.x + result.up * offset.y;
        }

        public Vector2 Evaluate(double time)
        {
            if (keys.Length == 0) return Vector2.zero;
            Vector2 offset = Vector2.zero;
            for (int i = 0; i < keys.Length; i++)
            {
                offset += keys[i].offset * keys[i].Evaluate(time);
            }
            return offset * blend;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/OffsetModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/RotationModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0049066920c0f4549af72ec0044c71c6
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines
{
    [System.Serializable]
    public class RotationModifier : SplineSampleModifier
    {
        [System.Serializable]
        public class RotationKey : Key
        {
            public bool useLookTarget = false;
            public Transform target = null;
            public Vector3 rotation = Vector3.zero;

            public RotationKey(Vector3 rotation, double f, double t) : base(f, t)
            {
                this.rotation = rotation;
            }
        }

        public override bool hasKeys => keys.Length > 0;
        public RotationKey[] keys = new RotationKey[0];

        public RotationModifier()
        {
            keys = new RotationKey[0];
        }

        public override List<Key> GetKeys()
        {
            return new List<Key>(keys);
        }

        public override void SetKeys(List<Key> input)
        {
            keys = new RotationKey[input.Count];
            for (int i = 0; i < input.Count; i++)
            {
                keys[i] = (RotationKey)input[i];
            }
            base.SetKeys(input);
        }

        public void AddKey(Vector3 rotation, double f, double t)
        {
            ArrayUtility.Add(ref keys, new RotationKey(rotation, f, t));
        }

        public override void Apply(ref SplineSample result)
        {
            if (keys.Length == 0) return;
            base.Apply(ref result);

            Quaternion offset = Quaternion.identity, look = result.rotation;
            for (int i = 0; i < keys.Length; i++)
            {
                if (keys[i].useLookTarget && keys[i].target != null)
                {
                    Quaternion lookDir = Quaternion.LookRotation(keys[i].target.position - result.position);
                    look = Quaternion.Slerp(look, lookDir, keys[i].Evaluate(result.percent) * blend);
                }
                else
                {
                    Quaternion euler = Quaternion.Euler(keys[i].rotation.x, keys[i].rotation.y, keys[i].rotation.z);
                    offset = Quaternion.Slerp(offset, offset * euler, keys[i].Evaluate(result.percent) * blend);
                }
            }
            Quaternion rotation = look * offset;
            Vector3 invertedNormal = Quaternion.Inverse(result.rotation) * result.up;
            result.forward = rotation * Vector3.forward;
            result.up = rotation * invertedNormal;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/RotationModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/SizeModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 896008ffd57dfab499f9f0745f7dbb4f
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    [System.Serializable]
    public class SizeModifier : SplineSampleModifier
    {
        [System.Serializable]
        public class SizeKey : Key
        {
            public float size = 0f;

            public SizeKey(double f, double t) : base(f, t)
            {
            }
        }

        public override bool hasKeys => keys.Length > 0;
        public SizeKey[] keys = new SizeKey[0];

        public SizeModifier()
        {
            keys = new SizeKey[0];
        }

        public override List<Key> GetKeys()
        {
            return new List<Key>(keys);
        }

        public override void SetKeys(List<Key> input)
        {
            keys = new SizeKey[input.Count];
            for (int i = 0; i < input.Count; i++)
            {
                keys[i] = (SizeKey)input[i];
            }
            base.SetKeys(input);
        }

        public void AddKey(double f, double t)
        {
            ArrayUtility.Add(ref keys, new SizeKey(f, t));
        }

        public override void Apply(ref SplineSample result)
        {
            if (keys.Length == 0) return;
            base.Apply(ref result);
            for (int i = 0; i < keys.Length; i++)
            {
                result.size += keys[i].Evaluate(result.percent) * keys[i].size * blend;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/SizeModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/SplineSampleModifier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 26a8731450d83c541afa4dd71666f85d
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections.Generic;
    using UnityEngine;


    [System.Serializable]
    public class SplineSampleModifier
    {
        [Range(0f, 1f)]
        public float blend = 1f;
        public bool useClippedPercent = false;

        public virtual bool hasKeys => false;

        public virtual List<Key> GetKeys()
        {
            return new List<Key>();
        }

        public virtual void SetKeys(List<Key> input)
        {
        }

        public virtual void Apply(ref SplineSample result)
        {

        }

        public virtual void Apply(ref SplineSample source, ref SplineSample destination)
        {
            destination = source;
            Apply(ref destination);
        }

        [System.Serializable]
        public class Key
        {
            public double start
            {
                get { return _featherStart; }
                set {
                    if (value != _featherStart)
                    {
                        _featherStart = DMath.Clamp01(value);
                    }
                }
            }

            public double end
            {
                get { return _featherEnd; }
                set {
                    if (value != _featherEnd)
                    {
                        _featherEnd = DMath.Clamp01(value);
                    }
                }

            }

            public double centerStart
            {
                get { return _centerStart; }
                set {
                    if (value != _centerStart)
                    {
                        _centerStart = DMath.Clamp01(value);
                        if (_centerStart > _centerEnd) _centerStart = _centerEnd;
                    }
                }
            }

            public double centerEnd
            {
                get { return _centerEnd; }
                set {
                    if (value != _centerEnd)
                    {
                        _centerEnd = DMath.Clamp01(value);
                        if (_centerEnd < _centerStart) _centerEnd = _centerStart;
                    }
                }
            }


            public double globalCenterStart
            {
                get {
                    return LocalToGlobalPercent(centerStart);
                }
                set
                {
                    centerStart = DMath.Clamp01(GlobalToLocalPercent(value));
                }
            }

            public double globalCenterEnd
            {
                get
                {
                    return LocalToGlobalPercent(centerEnd);
                }
                set
                {
                    centerEnd = DMath.Clamp01(GlobalToLocalPercent(value));
                }
            }

            public double position
            {
                get
                {
                    double center = DMath.Lerp(_centerStart, _centerEnd, 0.5);
                    if (start > end)
                    {
                        double fromToEndDistance = 1.0 - _featherStart;
                        double centerDistance = center * (fromToEndDistance + _featherEnd);
                        double pos = _featherStart + centerDistance;
                        if (pos > 1.0) pos -= 1.0;
                        return pos;
                    }
                    else return DMath.Lerp(_featherStart, _featherEnd, center);

                }
                set
                {
                    double delta = value - position;
                    start += delta;
                    end += delta;
                }
            }

            [SerializeField] private double _featherStart = 0.0, _featherEnd = 0.0, _centerStart = 0.25, _centerEnd = 0.75;
            public AnimationCurve interpolation;
            public float blend = 1f;

            internal Key(double f, double t)
            {
                start = f;
                end = t;
                interpolation = AnimationCurve.Linear(0f, 0f, 1f, 1f);
            }

            private double GlobalToLocalPercent(double t)
            {
                if (_featherStart > _featherEnd)
                {
                    if (t > _featherStart) return DMath.InverseLerp(_featherStart, _featherStart + (1.0 - _featherStart) + _featherEnd, t);
                    else if (t < _featherEnd) return DMath.InverseLerp(-(1.0 - _featherStart), _featherEnd, t);
                    else return 0f;
                }
                return DMath.InverseLerp(_featherStart, _featherEnd, t);
            }

            private double LocalToGlobalPercent(double t)
            {
                if (_featherStart > _featherEnd)
                {
                    t = DMath.Lerp(_featherStart, _featherStart + (1.0 - _featherStart) + _featherEnd, t);
                    if (t > 1.0) t -= 1.0;
                    return t;
                }
                return DMath.Lerp(_featherStart, _featherEnd, t);
            }

            public float Evaluate(double t)
            {
                t = (float)GlobalToLocalPercent(t);
                if (t < _centerStart)
                {
                    return interpolation.Evaluate((float)(t / _centerStart)) * blend;
                }

                if (t > _centerEnd)
                {
                    return interpolation.Evaluate(1f - (float)DMath.InverseLerp(_centerEnd, 1.0, t)) * blend;
                }
                return interpolation.Evaluate(1f) * blend;
            }

            public virtual Key Duplicate()
            {
                Key newKey = new Key(start, end);
                newKey._centerStart = _centerStart;
                newKey._centerEnd = _centerEnd;
                newKey.blend = blend;
                newKey.interpolation = DuplicateUtility.DuplicateCurve(interpolation);
                return newKey;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/Sample Modifiers/SplineSampleModifier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineComputer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 598e68924c9f6324bbfd049d3bae754c
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;
    using System.Collections.Generic;

    public delegate void EmptySplineHandler();
    //MonoBehaviour wrapper for the spline class. It transforms the spline using the object's transform and provides thread-safe methods for sampling
    [AddComponentMenu("Dreamteck/Splines/Spline Computer")]
    [ExecuteInEditMode]
    public partial class SplineComputer : MonoBehaviour
    {
#if UNITY_EDITOR
        public enum EditorUpdateMode { Default, OnMouseUp }
        [HideInInspector]
        public bool editorDrawPivot = true;
        [HideInInspector]
        public Color editorPathColor = Color.white;
        [HideInInspector]
        public bool editorAlwaysDraw = false;
        [HideInInspector]
        public bool editorDrawThickness = false;
        [HideInInspector]
        public bool editorBillboardThickness = true;
        private bool _editorIsPlaying = false;
        [HideInInspector]
        public bool isNewlyCreated = true;
        [HideInInspector]
        public EditorUpdateMode editorUpdateMode = EditorUpdateMode.Default;
#endif
        public enum Space { World, Local };
        public enum EvaluateMode { Cached, Calculate }
        public enum SampleMode { Default, Uniform, Optimized }
        public enum UpdateMode { Update, FixedUpdate, LateUpdate, AllUpdate, None }
        public Space space
        {
            get { return _space; }
            set
            {
                if (value != _space)
                {
                    SplinePoint[] worldPoints = GetPoints();
                    _space = value;
                    SetPoints(worldPoints);
                }
            }
        }
        public Spline.Type type
        {
            get
            {
                return _spline.type;
            }

            set
            {
                if (value != _spline.type)
                {
                    _spline.type = value;
                    Rebuild(true);
                }
            }
        }

        public float knotParametrization
        {
            get { return _spline.knotParametrization; }
            set
            {
                float last = _spline.knotParametrization;
                _spline.knotParametrization = value;
                if(last != _spline.knotParametrization)
                {
                    Rebuild(true);
                }
            }
        }

        public bool linearAverageDirection
        {
            get
            {
                return _spline.linearAverageDirection;
            }

            set
            {
                if (value != _spline.linearAverageDirection)
                {
                    _spline.linearAverageDirection = value;
                    Rebuild(true);
                }
            }
        }

        public bool is2D
        {
            get { return _is2D; }
            set
            {
                if (value != _is2D)
                {
                    _is2D = value;
                    SetPoints(GetPoints());
                }
            }
        }

        public int sampleRate
        {
            get { return _spline.sampleRate; }
            set
            {
                if (value != _spline.sampleRate)
                {
                    if (value < 2) value = 2;
                    _spline.sampleRate = value;
                    Rebuild(true);
                }
            }
        }

        public float optimizeAngleThreshold
        {
            get { return _optimizeAngleThreshold; }
            set
            {
                if (value != _optimizeAngleThreshold)
                {
                    if (value < 0.001f) value = 0.001f;
                    _optimizeAngleThreshold = value;
                    if (_sampleMode == SampleMode.Optimized)
                    {
                        Rebuild(true);
                    }
                }
            }
        }

        public SampleMode sampleMode
        {
            get { return _sampleMode; }
            set
            {
                if (value != _sampleMode)
                {
                    _sampleMode = value;
                    Rebuild(true);
                }
            }
        }
        [HideInInspector]
        public bool multithreaded = false;
        [HideInInspector]
        public UpdateMode updateMode = UpdateMode.Update;
        [HideInInspector]
        public TriggerGroup[] triggerGroups = new TriggerGroup[0];

        public AnimationCurve customValueInterpolation
        {
            get { return _spline.customValueInterpolation; }
            set
            {
                _spline.customValueInterpolation = value;
                Rebuild();
            }
        }

        public AnimationCurve customNormalInterpolation
        {
            get { return _spline.customNormalInterpolation; }
            set
            {
                _spline.customNormalInterpolation = value;
                Rebuild();
            }
        }

        public int iterations
        {
            get
            {
                return _spline.iterations;
            }
        }

        public double moveStep
        {
            get
            {
                return _spline.moveStep;
            }
        }

        public bool isClosed
        {
            get
            {
                return _spline.isClosed;
            }
        }

        public int pointCount
        {
            get
            {
                return _spline.points.Length;
            }
        }

        public int sampleCount
        {
            get { return _sampleCollection.length; }
        }

        /// <summary>
        /// Returns the sample at the index transformed by the object's matrix
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public SplineSample this [int index]
        {
            get
            {
                UpdateSampleCollection();
                return _sampleCollection.samples[index];
            }
        }

        /// <summary>
        /// The raw spline samples without transformation applied
        /// </summary>
        public SplineSample[] rawSamples
        {
            get { return _rawSamples; }
        }

        /// <summary>
        /// Thread-safe transform's position
        /// </summary>
        public Vector3 position
        {
            get {
#if UNITY_EDITOR
                if (!_editorIsPlaying) return transform.position;
#endif
                return _localToWorldMatrix.MultiplyPoint3x4(Vector3.zero);
            }
        }
        /// <summary>
        /// Thread-safe transform's rotation
        /// </summary>
        public Quaternion rotation
        {
            get {
#if UNITY_EDITOR
                if (!_editorIsPlaying) return transform.rotation;
#endif
                return _localToWorldMatrix.rotation;
            }
        }
        /// <summary>
        /// Thread-safe transform's scale
        /// </summary>
        public Vector3 scale
        {
            get {
#if UNITY_EDITOR
                if (!_editorIsPlaying) return transform.lossyScale;
#endif
                return _localToWorldMatrix.lossyScale;
            }
        }

        /// <summary>
        /// returns the number of subscribers this computer has
        /// </summary>
        public int subscriberCount
        {
            get
            {
                return _subscribers.Length;
            }
        }

        [HideInInspector]
        [SerializeField]
        [UnityEngine.Serialization.FormerlySerializedAs("spline")]
        private Spline _spline = new Spline(Spline.Type.CatmullRom);

        [HideInInspector]
        private SampleCollection _sampleCollection = new SampleCollection();

        [HideInInspector]
        [SerializeField]
        [UnityEngine.Serialization.FormerlySerializedAs("originalSamplePercents")]
        private double[] _originalSamplePercents = new double[0];
        [HideInInspector]
        [SerializeField]
        private bool _is2D = false;
        [HideInInspector]
        [SerializeField]
        private bool hasSamples = false;
        [HideInInspector]
        [SerializeField]
        [Range(0.001f, 45f)]
        private float _optimizeAngleThreshold = 0.5f;
        [HideInInspector]
        [SerializeField]
        private Space _space = Space.Local;
        [HideInInspector]
        [SerializeField]
        private SampleMode _sampleMode = SampleMode.Default;
        [HideInInspector]
        [SerializeField]
        private SplineUser[] _subscribers = new SplineUser[0];

        [HideInInspector]
        [SerializeField]
        private SplineSample[] _rawSamples = new SplineSample[0];

        private Matrix4x4 _localToWorldMatrix = Matrix4x4.identity;
        private Matrix4x4 _worldToLocalMatrix = Matrix4x4.identity;

        [HideInInspector]
        [SerializeField]
        [UnityEngine.Serialization.FormerlySerializedAs("nodes")]
        private NodeLink[] _nodes = new NodeLink[0];
        private bool _rebuildPending = false;
        private bool _trsCached = false;
        private Transform _trs = null;


        public Transform trs
        {
            get
            {
#if UNITY_EDITOR
                if (!_editorIsPlaying)
                {
                    return transform;
                }
#endif
                if (!_trsCached)
                {
                    _trs = transform;
                    _trsCached = true;
                }
                return _trs;
            }
        }

        private bool _queueResample = false, _queueRebuild = false;

        public event EmptySplineHandler onRebuild;

        private bool useMultithreading
        {
            get
            {
                return multithreaded
#if UNITY_EDITOR
                && _editorIsPlaying
#endif
                ;
            }
        }

#if UNITY_EDITOR
        /// <summary>
        /// Used by the editor - should not be called from the API
        /// </summary>
        public void EditorAwake()
        {
            UpdateConnectedNodes();
            RebuildImmediate(true, true);
        }

        /// <summary>
        /// Used by the editor - should not be called from the API
        /// </summary>
        public void EditorUpdateConnectedNodes()
        {
            UpdateConnectedNodes();
        }
#endif

        private void Awake()
        {
#if UNITY_EDITOR
            _editorIsPlaying = Application.isPlaying;
#endif
            ResampleTransform();
        }

        void FixedUpdate()
        {
            if (updateMode == UpdateMode.FixedUpdate || updateMode == UpdateMode.AllUpdate)
            {
                RunUpdate();
            }
        }

        void LateUpdate()
        {
            if (updateMode == UpdateMode.LateUpdate || updateMode == UpdateMode.AllUpdate)
            {
                RunUpdate();
            }
        }

        void Update()
        {
            if (updateMode == UpdateMode.Update || updateMode == UpdateMode.AllUpdate)
            {
                RunUpdate();
            }
        }

        private void RunUpdate(bool immediate = false)
        {
            bool transformChanged = ResampleTransformIfNeeded();
            if(_sampleCollection.samples.Length != _rawSamples.Length)
            {
                transformChanged = true;
            }

            if (useMultithreading)
            {
                //Rebuild users at the beginning of the next cycle if multithreaded
                if (_queueRebuild)
                {
                    RebuildUsers(immediate);
                }
            }

            if (_queueResample)
            {
                if (useMultithreading)
                {
                    if (transformChanged)
                    {
                        SplineThreading.Run(CalculateWithoutTransform);
                    } else
                    {
                        SplineThreading.Run(CalculateWithTransform);
                    }
                }
                else
                {
                    CalculateSamples(!transformChanged);
                }
            }

            if (transformChanged)
            {
                if (useMultithreading)
                {
                    SplineThreading.Run(TransformSamples);
                }
                else
                {
                    TransformSamples();
                }
            }

            if (!useMultithreading)
            {
                //If not multithreaded, rebuild users here
                if (_queueRebuild)
                {
                    RebuildUsers(immediate);
                }
            }

            void CalculateWithTransform()
            {
                CalculateSamples();
            }

            void CalculateWithoutTransform()
            {
                CalculateSamples(false);
            }
        }

#if UNITY_EDITOR
        private void Reset()
        {
            editorPathColor = SplinePrefs.defaultColor;
            editorDrawThickness = SplinePrefs.defaultShowThickness;
            is2D = SplinePrefs.default2D;
            editorAlwaysDraw = SplinePrefs.defaultAlwaysDraw;
            editorUpdateMode = SplinePrefs.defaultEditorUpdateMode;
            space = SplinePrefs.defaultComputerSpace;
            type = SplinePrefs.defaultType;
        }
#endif

        void OnEnable()
        {
            if (_rebuildPending)
            {
                _rebuildPending = false;
                Rebuild();
            }
        }

        public void GetSamples(SampleCollection collection)
        {
            UpdateSampleCollection();
            collection.samples = _sampleCollection.samples;
            collection.optimizedIndices = _sampleCollection.optimizedIndices;
            collection.sampleMode = _sampleMode;
        }

        private void UpdateSampleCollection()
        {
            if (_sampleCollection.samples.Length != _rawSamples.Length)
            {
                TransformSamples();
            }
        }

        private bool ResampleTransformIfNeeded()
        {
            bool changed = false;
            //This is used to skip comparing matrices on every frame during runtime
#if UNITY_EDITOR
            if (_editorIsPlaying)
            {
#endif
                if (!trs.hasChanged) return false;
                trs.hasChanged = false;
#if UNITY_EDITOR
            }
#endif

            if (_localToWorldMatrix != trs.localToWorldMatrix)
            {
                ResampleTransform();
                _queueRebuild = true;
                changed = true;
            }
            return changed;
        }

        /// <summary>
        /// Immediately sample the computer's transform (thread-unsafe). Call this before SetPoint(s) if the transform has been modified in the same frame
        /// </summary>
        public void ResampleTransform()
        {
            _localToWorldMatrix = trs.localToWorldMatrix;
            _worldToLocalMatrix = trs.worldToLocalMatrix;
        }

        /// <summary>
        /// Subscribe a SplineUser to this computer. This will rebuild the user automatically when there are changes.
        /// </summary>
        /// <param name="input">The SplineUser to subscribe</param>
        public void Subscribe(SplineUser input)
        {
            if (!IsSubscribed(input))
            {
                ArrayUtility.Add(ref _subscribers, input);
            }
        }

        /// <summary>
        /// Unsubscribe a SplineUser from this computer's updates
        /// </summary>
        /// <param name="input">The SplineUser to unsubscribe</param>
        public void Unsubscribe(SplineUser input)
        {
            for (int i = 0; i < _subscribers.Length; i++)
            {
                if (_subscribers[i] == input)
                {
                    ArrayUtility.RemoveAt(ref _subscribers, i);
                    return;
                }
            }
        }

        /// <summary>
        /// Checks if a user is subscribed to that computer
        /// </summary>
        /// <param name="user"></param>
        /// <returns></returns>
        public bool IsSubscribed(SplineUser user)
        {
            for (int i = 0; i < _subscribers.Length; i++)
            {
                if (_subscribers[i] == user)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Returns an array of subscribed users
        /// </summary>
        /// <returns></returns>
        public SplineUser[] GetSubscribers()
        {
            SplineUser[] subs = new SplineUser[_subscribers.Length];
            _subscribers.CopyTo(subs, 0);
            return subs;
        }

        /// <summary>
        /// Get the points from this computer's spline. All points are transformed in world coordinates.
        /// </summary>
        /// <returns></returns>
        public SplinePoint[] GetPoints(Space getSpace = Space.World)
        {
            SplinePoint[] points = new SplinePoint[_spline.points.Length];
            for (int i = 0; i < points.Length; i++)
            {
                points[i] = _spline.points[i];
                if (_space == Space.Local && getSpace == Space.World)
                {
                    points[i].position = TransformPoint(points[i].position);
                    points[i].tangent = TransformPoint(points[i].tangent);
                    points[i].tangent2 = TransformPoint(points[i].tangent2);
                    points[i].normal = TransformDirection(points[i].normal);
                }
            }
            return points;
        }

        /// <summary>
        /// Get a point from this computer's spline. The point is transformed in world coordinates.
        /// </summary>
        /// <param name="index">Point index</param>
        /// <returns></returns>
        public SplinePoint GetPoint(int index, Space getSpace = Space.World)
        {
            if (index < 0 || index >= _spline.points.Length) return new SplinePoint();
            if (_space == Space.Local && getSpace == Space.World)
            {
                ResampleTransformIfNeeded();
                SplinePoint point = _spline.points[index];
                point.position = TransformPoint(point.position);
                point.tangent = TransformPoint(point.tangent);
                point.tangent2 = TransformPoint(point.tangent2);
                point.normal = TransformDirection(point.normal);
                return point;
            }
            else
            {
                return _spline.points[index];
            }
        }

        public Vector3 GetPointPosition(int index, Space getSpace = Space.World)
        {
            if (_space == Space.Local && getSpace == Space.World)
            {
                ResampleTransformIfNeeded();
                return TransformPoint(_spline.points[index].position);
            }
            else return _spline.points[index].position;
        }

        public Vector3 GetPointNormal(int index, Space getSpace = Space.World)
        {
            if (_space == Space.Local && getSpace == Space.World)
            {
                ResampleTransformIfNeeded();
                return TransformDirection(_spline.points[index].normal).normalized;
            }
            else return _spline.points[index].normal;
        }

        public Vector3 GetPointTangent(int index, Space getSpace = Space.World)
        {
            if (_space == Space.Local && getSpace == Space.World)
            {
                ResampleTransformIfNeeded();
                return TransformPoint(_spline.points[index].tangent);
            }
            else return _spline.points[index].tangent;
        }

        public Vector3 GetPointTangent2(int index, Space getSpace = Space.World)
        {
            if (_space == Space.Local && getSpace == Space.World)
            {
                ResampleTransformIfNeeded();
                return TransformPoint(_spline.points[index].tangent2);
            }
            else return _spline.points[index].tangent2;
        }

        public float GetPointSize(int index, Space getSpace = Space.World)
        {
            return _spline.points[index].size;
        }

        public Color GetPointColor(int index, Space getSpace = Space.World)
        {
            return _spline.points[index].color;
        }

        private void Make2D(ref SplinePoint point)
        {
            point.Flatten(LinearAlgebraUtility.Axis.Z);
        }

        /// <summary>
        /// Set the points of this computer's spline.
        /// </summary>
        /// <param name="points">The points array</param>
        /// <param name="setSpace">Use world or local space</param>
        public void SetPoints(SplinePoint[] points, Space setSpace = Space.World)
        {
            ResampleTransformIfNeeded();
            bool rebuild = false;
            if (points.Length != _spline.points.Length)
            {
                rebuild = true;
                if (points.Length < 3)
                {
                    Break();
                }
                _spline.points = new SplinePoint[points.Length];
                SetAllDirty();
            }

            for (int i = 0; i < points.Length; i++)
            {
                SplinePoint newPoint = points[i];
                if(_spline.points.Length > i)
                {
                    newPoint.isDirty = _spline.points[i].isDirty;
                }
                if (_space == Space.Local && setSpace == Space.World)
                {
                    newPoint.position = InverseTransformPoint(points[i].position);
                    newPoint.tangent = InverseTransformPoint(points[i].tangent);
                    newPoint.tangent2 = InverseTransformPoint(points[i].tangent2);
                    newPoint.normal = InverseTransformDirection(points[i].normal);
                }

                if (_is2D)
                {
                    Make2D(ref newPoint);
                }

                if (newPoint != _spline.points[i])
                {
                    newPoint.isDirty = true;
                    rebuild = true;
                }

                _spline.points[i] = newPoint;

            }

            if (rebuild)
            {
                Rebuild();
                UpdateConnectedNodes(points);
            }
        }

        /// <summary>
        /// Set the position of a control point. This is faster than SetPoint
        /// </summary>
        /// <param name="index"></param>
        /// <param name="pos"></param>
        /// <param name="setSpace"></param>
        public void SetPointPosition(int index, Vector3 pos, Space setSpace = Space.World)
        {
            if (index < 0) return;
            ResampleTransformIfNeeded();
            if (index >= _spline.points.Length)
            {
                AppendPoints((index + 1) - _spline.points.Length);
            }
            Vector3 newPos = pos;
            if (_space == Space.Local && setSpace == Space.World) newPos = InverseTransformPoint(pos);
            if (newPos != _spline.points[index].position)
            {
                SetDirty(index);
                _spline.points[index].SetPosition(newPos);
                Rebuild();
                SetNodeForPoint(index, GetPoint(index));
            }
        }

        /// <summary>
        /// Set the tangents of a control point. This is faster than SetPoint
        /// </summary>
        /// <param name="index"></param>
        /// <param name="tan1"></param>
        /// <param name="tan2"></param>
        /// <param name="setSpace"></param>
        public void SetPointTangents(int index, Vector3 tan1, Vector3 tan2, Space setSpace = Space.World)
        {
            if (index < 0) return;
            ResampleTransformIfNeeded();
            if (index >= _spline.points.Length)
            {
                AppendPoints((index + 1) - _spline.points.Length);
            }
            Vector3 newTan1 = tan1;
            Vector3 newTan2 = tan2;
            if (_space == Space.Local && setSpace == Space.World)
            {
                newTan1 = InverseTransformPoint(tan1);
                newTan2 = InverseTransformPoint(tan2);
            }
            bool rebuild = false;
            if (newTan2 != _spline.points[index].tangent2)
            {
                rebuild = true;
                _spline.points[index].SetTangent2Position(newTan2);
            }
            if (newTan1 != _spline.points[index].tangent)
            {
                rebuild = true;
                _spline.points[index].SetTangentPosition(newTan1);
            }
            if (_is2D) Make2D(ref _spline.points[index]);

            if (rebuild)
            {
                SetDirty(index);
                Rebuild();
                SetNodeForPoint(index, GetPoint(index));
            }
        }

        /// <summary>
        /// Set the normal of a control point. This is faster than SetPoint
        /// </summary>
        /// <param name="index"></param>
        /// <param name="nrm"></param>
        /// <param name="setSpace"></param>
        public void SetPointNormal(int index, Vector3 nrm, Space setSpace = Space.World)
        {
            if (index < 0) return;
            ResampleTransformIfNeeded();
            if (index >= _spline.points.Length)
            {
                AppendPoints((index + 1) - _spline.points.Length);
            }
            Vector3 newNrm = nrm;
            if (_space == Space.Local && setSpace == Space.World) newNrm = InverseTransformDirection(nrm);
            if (newNrm != _spline.points[index].normal)
            {
                SetDirty(index);
                _spline.points[index].normal = newNrm;
                if (_is2D) Make2D(ref _spline.points[index]);
                Rebuild();
                SetNodeForPoint(index, GetPoint(index));
            }
        }

        /// <summary>
        /// Set the size of a control point. This is faster than SetPoint
        /// </summary>
        /// <param name="index"></param>
        /// <param name="size"></param>
        public void SetPointSize(int index, float size)
        {
            if (index < 0) return;
            if (index >= _spline.points.Length)
            {
                AppendPoints((index + 1) - _spline.points.Length);
            }
            if (size != _spline.points[index].size)
            {
                SetDirty(index);
                _spline.points[index].size = size;
                Rebuild();
                SetNodeForPoint(index, GetPoint(index));
            }
        }

        /// <summary>
        /// Set the color of a control point. THis is faster than SetPoint
        /// </summary>
        /// <param name="index"></param>
        /// <param name="color"></param>
        public void SetPointColor(int index, Color color)
        {
            if (index < 0) return;
            if (index >= _spline.points.Length)
            {
                AppendPoints((index + 1) - _spline.points.Length);
            }
            if (color != _spline.points[index].color)
            {
                SetDirty(index);
                _spline.points[index].color = color;
                Rebuild();
                SetNodeForPoint(index, GetPoint(index));
            }
        }

        /// <summary>
        /// Set a control point in world coordinates
        /// </summary>
        /// <param name="index"></param>
        /// <param name="point"></param>
        public void SetPoint(int index, SplinePoint point, Space setSpace = Space.World)
        {
            if (index < 0) return;
            ResampleTransformIfNeeded();
            if (index >= _spline.points.Length)
            {
                AppendPoints((index + 1) - _spline.points.Length);
            }
            SplinePoint newPoint = point;
            if (_space == Space.Local && setSpace == Space.World)
            {
                newPoint.position = InverseTransformPoint(point.position);
                newPoint.tangent = InverseTransformPoint(point.tangent);
                newPoint.tangent2 = InverseTransformPoint(point.tangent2);
                newPoint.normal = InverseTransformDirection(point.normal);
            }

            if (_is2D)
            {
                Make2D(ref newPoint);
            }

            if (newPoint != _spline.points[index])
            {
                newPoint.isDirty = true;
                _spline.points[index] = newPoint;
                Rebuild();
                SetNodeForPoint(index, point);
            }
        }

        private void AppendPoints(int count)
        {
            SplinePoint[] newPoints = new SplinePoint[_spline.points.Length + count];
            _spline.points.CopyTo(newPoints, 0);
            _spline.points = newPoints;
            Rebuild(true);
        }

        /// <summary>
        /// Converts a point index to spline percent
        /// </summary>
        /// <param name="pointIndex">The point index</param>
        /// <returns></returns>
        public double GetPointPercent(int pointIndex)
        {
            double percent = DMath.Clamp01((double)pointIndex / (_spline.points.Length - 1));
            if (_spline.isClosed)
            {
                percent = DMath.Clamp01((double)pointIndex / _spline.points.Length);
            }
            if (_sampleMode != SampleMode.Uniform) return percent;

            if (_originalSamplePercents.Length <= 1) return 0.0;
            for (int i = _originalSamplePercents.Length - 2; i >= 0; i--)
            {
                if (_originalSamplePercents[i] < percent)
                {
                    double inverseLerp = DMath.InverseLerp(_originalSamplePercents[i], _originalSamplePercents[i + 1], percent);
                    return DMath.Lerp(_rawSamples[i].percent, _rawSamples[i+1].percent, inverseLerp);
                }
            }
            return 0.0;
        }

        public int PercentToPointIndex(double percent, Spline.Direction direction = Spline.Direction.Forward)
        {
            int count = _spline.points.Length - 1;
            if (isClosed) count = _spline.points.Length;

            if (_sampleMode == SampleMode.Uniform)
            {
                int index;
                double lerp;
                GetSamplingValues(percent, out index, out lerp);
                if (lerp > 0.0 && index < _originalSamplePercents.Length - 1)
                {
                    lerp = DMath.Lerp(_originalSamplePercents[index], _originalSamplePercents[index + 1], lerp);
                    if (direction == Spline.Direction.Forward)
                    {
                        return DMath.FloorInt(lerp * count);
                    }
                    else
                    {
                        return DMath.CeilInt(lerp * count);
                    }
                }

                if (direction == Spline.Direction.Forward)
                {
                    return DMath.FloorInt(_originalSamplePercents[index] * count);
                }
                else
                {
                    return DMath.CeilInt(_originalSamplePercents[index] * count);
                }
            }

            int point = 0;
            if (direction == Spline.Direction.Forward)
            {
                point = DMath.FloorInt(percent * count);
            }
            else
            {
                point = DMath.CeilInt(percent * count);
            }
            if (point >= _spline.points.Length)
            {
                point = 0;
            }
            return point;
        }

        public Vector3 EvaluatePosition(double percent)
        {
            return EvaluatePosition(percent, EvaluateMode.Cached);
        }

        /// <summary>
        /// Same as Spline.EvaluatePosition but the result is transformed by the computer's transform
        /// </summary>
        /// <param name="percent">Evaluation percent</param>
        /// <param name="mode">Mode to use the method in. Cached uses the cached samples while Calculate is more accurate but heavier</param>
        /// <returns></returns>
        public Vector3 EvaluatePosition(double percent, EvaluateMode mode = EvaluateMode.Cached)
        {
            if (mode == EvaluateMode.Calculate) return TransformPoint(_spline.EvaluatePosition(percent));
            UpdateSampleCollection();
            return _sampleCollection.EvaluatePosition(percent);
        }

        public Vector3 EvaluatePosition(int pointIndex, EvaluateMode mode = EvaluateMode.Cached)
        {
            return EvaluatePosition(GetPointPercent(pointIndex), mode);
        }

        public SplineSample Evaluate(double percent)
        {
            return Evaluate(percent, EvaluateMode.Cached);
        }

        /// <summary>
        /// Same as Spline.Evaluate but the result is transformed by the computer's transform
        /// </summary>
        /// <param name="percent">Evaluation percent</param>
        /// <param name="mode">Mode to use the method in. Cached uses the cached samples while Calculate is more accurate but heavier</param>
        /// <returns></returns>
        public SplineSample Evaluate(double percent, EvaluateMode mode = EvaluateMode.Cached)
        {
            SplineSample result = new SplineSample();
            Evaluate(percent, ref result, mode);
            return result;
        }

        /// <summary>
        /// Evaluate the spline at the position of a given point and return a SplineSample
        /// </summary>
        /// <param name="pointIndex">Point index</param>
        /// <param name="mode">Mode to use the method in. Cached uses the cached samples while Calculate is more accurate but heavier</param>
        public SplineSample Evaluate(int pointIndex)
        {
            SplineSample result = new SplineSample();
            Evaluate(pointIndex, ref result);
            return result;
        }

        /// <summary>
        /// Evaluate the spline at the position of a given point and write in the SplineSample output
        /// </summary>
        /// <param name="pointIndex">Point index</param>
        public void Evaluate(int pointIndex, ref SplineSample result)
        {
            Evaluate(GetPointPercent(pointIndex), ref result);
        }

        public void Evaluate(double percent, ref SplineSample result)
        {
            Evaluate(percent, ref result, EvaluateMode.Cached);
        }
        /// <summary>
        /// Same as Spline.Evaluate but the result is transformed by the computer's transform
        /// </summary>
        /// <param name="result"></param>
        /// <param name="percent"></param>
        public void Evaluate(double percent, ref SplineSample result, EvaluateMode mode = EvaluateMode.Cached)
        {
            if (mode == EvaluateMode.Calculate)
            {
                _spline.Evaluate(percent, ref result);
                TransformSample(ref result);
            } else
            {
                UpdateSampleCollection();
                _sampleCollection.Evaluate(percent, ref result);
            }
        }

        /// <summary>
        /// Same as Spline.Evaluate but the results are transformed by the computer's transform
        /// </summary>
        /// <param name="from">Start position [0-1]</param>
        /// <param name="to">Target position [from-1]</param>
        /// <returns></returns>
        public void Evaluate(ref SplineSample[] results, double from = 0.0, double to = 1.0)
        {
            UpdateSampleCollection();
            _sampleCollection.Evaluate(ref results, from, to);
        }

        /// <summary>
        /// Same as Spline.EvaluatePositions but the results are transformed by the computer's transform
        /// </summary>
        /// <param name="from">Start position [0-1]</param>
        /// <param name="to">Target position [from-1]</param>
        /// <returns></returns>
        public void EvaluatePositions(ref Vector3[] positions, double from = 0.0, double to = 1.0)
        {
            UpdateSampleCollection();
            _sampleCollection.EvaluatePositions(ref positions, from, to);
        }

        /// <summary>
        /// Returns the percent from the spline at a given distance from the start point
        /// </summary>
        /// <param name="start">The start point</param>
        /// /// <param name="distance">The distance to travel</param>
        /// <param name="direction">The direction towards which to move</param>
        /// <returns></returns>
        public double Travel(double start, float distance, out float moved, Spline.Direction direction = Spline.Direction.Forward)
        {
            UpdateSampleCollection();
            return _sampleCollection.Travel(start, distance, direction, out moved);
        }

        public double Travel(double start, float distance, Spline.Direction direction = Spline.Direction.Forward)
        {
            float moved;
            return Travel(start, distance, out moved, direction);
        }


        [System.Obsolete("This project override is obsolete, please use Project(Vector3 position, ref SplineSample result, double from = 0.0, double to = 1.0, EvaluateMode mode = EvaluateMode.Cached, int subdivisions = 4) instead")]
        public void Project(ref SplineSample result, Vector3 position, double from = 0.0, double to = 1.0, EvaluateMode mode = EvaluateMode.Cached, int subdivisions = 4)
        {
            Project(position, ref result, from, to, mode, subdivisions);
        }

        /// <summary>
        /// Same as Spline.Project but the point is transformed by the computer's transform.
        /// </summary>
        /// <param name="worldPoint">Point in world space</param>
        /// <param name="subdivide">Subdivisions default: 4</param>
        /// <param name="from">Sample from [0-1] default: 0f</param>
        /// <param name="to">Sample to [0-1] default: 1f</param>
        /// <param name="mode">Mode to use the method in. Cached uses the cached samples while Calculate is more accurate but heavier</param>
        /// <param name="subdivisions">Subdivisions for the Calculate mode. Don't assign if not using Calculated mode.</param>
        /// <returns></returns>
        public void Project(Vector3 worldPoint, ref SplineSample result, double from = 0.0, double to = 1.0, EvaluateMode mode = EvaluateMode.Cached, int subdivisions = 4)
        {
            if (mode == EvaluateMode.Calculate)
            {
                worldPoint = InverseTransformPoint(worldPoint);
                double percent = _spline.Project(InverseTransformPoint(worldPoint), subdivisions, from, to);
                _spline.Evaluate(percent, ref result);
                TransformSample(ref result);
                return;
            }
            UpdateSampleCollection();
            _sampleCollection.Project(worldPoint, _spline.points.Length, ref result, from, to);
        }

        public SplineSample Project(Vector3 worldPoint, double from = 0.0, double to = 1.0)
        {
            SplineSample result = new SplineSample();
            Project(worldPoint, ref result, from, to);
            return result;
        }

        /// <summary>
        /// Same as Spline.CalculateLength but this takes the computer's transform into account when calculating the length.
        /// </summary>
        /// <param name="from">Calculate from [0-1] default: 0f</param>
        /// <param name="to">Calculate to [0-1] default: 1f</param>
        /// <param name="resolution">Resolution [0-1] default: 1f</param>
        /// <param name="address">Node address of junctions</param>
        /// <returns></returns>
        public float CalculateLength(double from = 0.0, double to = 1.0)
        {
            if (!hasSamples) return 0f;
            UpdateSampleCollection();
            return _sampleCollection.CalculateLength(from, to);
        }

        private void TransformSample(ref SplineSample result)
        {
            result.position = _localToWorldMatrix.MultiplyPoint3x4(result.position);
            result.forward = _localToWorldMatrix.MultiplyVector(result.forward);
            result.up = _localToWorldMatrix.MultiplyVector(result.up);
        }

        public void Rebuild(bool forceUpdateAll = false)
        {
            if (forceUpdateAll)
            {
                SetAllDirty();
            }

#if UNITY_EDITOR
            if (!_editorIsPlaying)
            {
                if (editorUpdateMode == EditorUpdateMode.Default)
                {
                    RebuildImmediate(true);
                }
                return;
            }
#endif

            _queueResample = updateMode != UpdateMode.None;
        }

        public void RebuildImmediate()
        {
            RebuildImmediate(true, true);
        }

        public void RebuildImmediate(bool calculateSamples = true, bool forceUpdateAll = false)
        {
            if (calculateSamples)
            {
                _queueResample = true;
                if (forceUpdateAll)
                {
                    SetAllDirty();
                }
            }
            else
            {
                _queueResample = false;
            }
            RunUpdate(true);
        }

        private void RebuildUsers(bool immediate = false)
        {
            for (int i = _subscribers.Length - 1; i >= 0; i--)
            {
                if (_subscribers[i] != null)
                {
                    if (immediate)
                    {
                        _subscribers[i].RebuildImmediate();
                    }
                    else
                    {
                        _subscribers[i].Rebuild();
                    }
                }
                else
                {
                    ArrayUtility.RemoveAt(ref _subscribers, i);
                }
            }

            if (onRebuild != null)
            {
                onRebuild();
            }
            _queueRebuild = false;
        }

        private void SetAllDirty()
        {
            for (int i = 0; i < _spline.points.Length; i++)
            {
                _spline.points[i].isDirty = true;
            }
        }

        private void SetDirty(int index)
        {
            if (sampleMode == SampleMode.Uniform)
            {
                SetAllDirty();
                return;
            }
            _spline.points[index].isDirty = true;
        }

        private void CalculateSamples(bool transformSamples = true)
        {
            _queueResample = false;
            _queueRebuild = true;
            if (_spline.points.Length == 0)
            {
                if (_rawSamples.Length != 0)
                {
                    _rawSamples = new SplineSample[0];
                    if (transformSamples)
                    {
                        TransformSamples();
                    }
                }
                return;
            }

            if (_spline.points.Length == 1)
            {
                if (_rawSamples.Length != 1)
                {
                    _rawSamples = new SplineSample[1];
                    if (transformSamples)
                    {
                        TransformSamples();
                    }
                }
                _spline.Evaluate(0.0, ref _rawSamples[0]);
                return;
            }

            if (_sampleMode == SampleMode.Uniform)
            {
                _spline.EvaluateUniform(ref _rawSamples, ref _originalSamplePercents);
                if (transformSamples)
                {
                    TransformSamples();
                }
            }
            else
            {
                if (_originalSamplePercents.Length > 0)
                {
                    _originalSamplePercents = new double[0];
                }

                if (_rawSamples.Length != _spline.iterations)
                {
                    _rawSamples = new SplineSample[_spline.iterations];
                    for (int i = 0; i < _rawSamples.Length; i++)
                    {
                        _rawSamples[i] = new SplineSample();
                    }
                }

                if (_sampleCollection.samples.Length != _rawSamples.Length)
                {
                    _sampleCollection.samples = new SplineSample[_rawSamples.Length];
                }

                for (int i = 0; i < _rawSamples.Length; i++)
                {
                    double percent = (double)i / (_rawSamples.Length - 1);
                    if (IsDirtySample(percent))
                    {
                        _spline.Evaluate(percent, ref _rawSamples[i]);
                        _sampleCollection.samples[i].FastCopy(ref _rawSamples[i]);
                        if (transformSamples && _space == Space.Local)
                        {
                            TransformSample(ref _sampleCollection.samples[i]);
                        }
                    }
                }

                if (_sampleMode == SampleMode.Optimized && _rawSamples.Length > 2)
                {
                    OptimizeSamples(space == Space.Local);
                }
                else
                {
                    if (_sampleCollection.optimizedIndices.Length > 0)
                    {
                        _sampleCollection.optimizedIndices = new int[0];
                    }
                }
            }

            _sampleCollection.sampleMode = _sampleMode;
            hasSamples = _sampleCollection.length > 0;

            for (int i = 0; i < _spline.points.Length; i++)
            {
                _spline.points[i].isDirty = false;
            }
        }

        private void OptimizeSamples(bool transformSamples)
        {
            if (_sampleCollection.optimizedIndices.Length != _rawSamples.Length)
            {
                _sampleCollection.optimizedIndices = new int[_rawSamples.Length];
            }

            Vector3 lastDirection = _rawSamples[0].forward;
            List<SplineSample> optimized = new List<SplineSample>();
            for (int i = 0; i < _rawSamples.Length; i++)
            {
                SplineSample sample = _rawSamples[i];
                if (transformSamples)
                {
                    TransformSample(ref sample);
                }
                Vector3 direction = sample.forward;
                if (i < _rawSamples.Length - 1)
                {
                    Vector3 pos = _rawSamples[i + 1].position;
                    if (transformSamples)
                    {
                        pos = _localToWorldMatrix.MultiplyPoint3x4(pos);
                    }
                    direction = pos - sample.position;
                }
                float angle = Vector3.Angle(lastDirection, direction);
                bool includeSample = angle >= _optimizeAngleThreshold || i == 0 || i == _rawSamples.Length - 1;

                if (includeSample)
                {


                    optimized.Add(sample);
                    lastDirection = direction;
                }

                _sampleCollection.optimizedIndices[i] = optimized.Count - 1;
            }

            _sampleCollection.samples = optimized.ToArray();
        }

        private void TransformSamples()
        {
            if (_sampleCollection.samples.Length != _rawSamples.Length)
            {
                _sampleCollection.samples = new SplineSample[_rawSamples.Length];
            }

            if (_sampleMode == SampleMode.Optimized && _rawSamples.Length > 2)
            {
                OptimizeSamples(_space == Space.Local);
            } else
            {
                for (int i = 0; i < _rawSamples.Length; i++)
                {
                    _sampleCollection.samples[i].FastCopy(ref _rawSamples[i]);
                    if (_space == Space.Local)
                    {
                        TransformSample(ref _sampleCollection.samples[i]);
                    }
                }
            }
        }

        bool IsDirtySample(double percent)
        {
            if (_sampleMode == SampleMode.Uniform) return true;

            int currentPoint = PercentToPointIndex(percent);

            int from = currentPoint - 1;
            int to = currentPoint + 2;

            if(_spline.type == Spline.Type.Bezier || _spline.type == Spline.Type.Linear)
            {
                from = currentPoint;
                to = currentPoint + 1;
            }

            int fromClamped = Mathf.Clamp(from, 0, _spline.points.Length - 1);
            int toClamped = Mathf.Clamp(to, 0, _spline.points.Length - 1);

            for (int i = fromClamped; i <= toClamped; i++)
            {
                if (_spline.points[i].isDirty)
                {
                    return true;
                }
            }

            if (_spline.isClosed)
            {
                if(from < 0)
                {
                    for (int i = from + _spline.points.Length; i < _spline.points.Length; i++)
                    {
                        if (_spline.points[i].isDirty)
                        {
                            return true;
                        }
                    }
                }

                if(to >= _spline.points.Length)
                {
                    for (int i = 0; i <= to - _spline.points.Length; i++)
                    {
                        if (_spline.points[i].isDirty)
                        {
                            return true;
                        }
                    }
                }
            }

            if (currentPoint > 0 && !_spline.points[currentPoint].isDirty)
            {
                int count = _spline.points.Length - 1;
                if (_spline.isClosed)
                {
                    count = _spline.points.Length;
                }
                double currentPointPercent = (double)currentPoint / count;

                if(Mathf.Abs((float)(currentPointPercent - percent)) <= 0.00001f)
                {
                    return _spline.points[currentPoint - 1].isDirty;
                }
            }

            return false;
        }

        /// <summary>
        /// Same as Spline.Break() but it will update all subscribed users
        /// </summary>
        public void Break()
        {
            Break(0);
        }

        /// <summary>
        /// Same as Spline.Break(at) but it will update all subscribed users
        /// </summary>
        /// <param name="at"></param>
        public void Break(int at)
        {
            if (_spline.isClosed)
            {
                _spline.Break(at);
                SetAllDirty();
                Rebuild();
            }
        }

        /// <summary>
        /// Same as Spline.Close() but it will update all subscribed users
        /// </summary>
        public void Close()
        {
            if (!_spline.isClosed)
            {
                if(_spline.points.Length >= 3)
                {
                    _spline.Close();
                    SetAllDirty();
                    Rebuild();
                } else
                {
                    Debug.LogError("Spline " + name + " needs at least 3 points before it can be closed. Current points: " + _spline.points.Length);
                }

            }
        }

        /// <summary>
        /// Same as Spline.HermiteToBezierTangents() but it will update all subscribed users
        /// </summary>
        public void CatToBezierTangents()
        {
            _spline.CatToBezierTangents();
            SetPoints(_spline.points, Space.Local);
        }

        /// <summary>
        /// Casts a ray along the transformed spline against all scene colliders.
        /// </summary>
        /// <param name="hit">Hit information</param>
        /// <param name="hitPercent">The percent of evaluation where the hit occured</param>
        /// <param name="layerMask">Layer mask for the raycast</param>
        /// <param name="resolution">Resolution multiplier for precision [0-1] default: 1f</param>
        /// <param name="from">Raycast from [0-1] default: 0f</param>
        /// <param name="to">Raycast to [0-1] default: 1f</param>
        /// <param name="hitTriggers">Should hit triggers? (not supported in 5.1)</param>
        /// <param name="address">Node address of junctions</param>
        /// <returns></returns>
        public bool Raycast(out RaycastHit hit, out double hitPercent, LayerMask layerMask, double resolution = 1.0, double from = 0.0, double to = 1.0 , QueryTriggerInteraction hitTriggers = QueryTriggerInteraction.UseGlobal)
        {
            resolution = DMath.Clamp01(resolution);
            Spline.FormatFromTo(ref from, ref to, false);
            double percent = from;
            Vector3 fromPos = EvaluatePosition(percent);
            hitPercent = 0f;
            while (true)
            {
                double prevPercent = percent;
                percent = DMath.Move(percent, to, moveStep / resolution);
                Vector3 toPos = EvaluatePosition(percent);
                if (Physics.Linecast(fromPos, toPos, out hit, layerMask, hitTriggers))
                {
                    double segmentPercent = (hit.point - fromPos).sqrMagnitude / (toPos - fromPos).sqrMagnitude;
                    hitPercent = DMath.Lerp(prevPercent, percent, segmentPercent);
                    return true;
                }
                fromPos = toPos;
                if (percent == to) break;
            }
            return false;
        }

        /// <summary>
        /// Casts a ray along the transformed spline against all scene colliders and returns all hits. Order is not guaranteed.
        /// </summary>
        /// <param name="hit">Hit information</param>
        /// <param name="hitPercent">The percents of evaluation where each hit occured</param>
        /// <param name="layerMask">Layer mask for the raycast</param>
        /// <param name="resolution">Resolution multiplier for precision [0-1] default: 1f</param>
        /// <param name="from">Raycast from [0-1] default: 0f</param>
        /// <param name="to">Raycast to [0-1] default: 1f</param>
        /// <param name="hitTriggers">Should hit triggers? (not supported in 5.1)</param>
        /// <param name="address">Node address of junctions</param>
        /// <returns></returns>
        public bool RaycastAll(out RaycastHit[] hits, out double[] hitPercents, LayerMask layerMask, double resolution = 1.0, double from = 0.0, double to = 1.0, QueryTriggerInteraction hitTriggers = QueryTriggerInteraction.UseGlobal)
        {
            resolution = DMath.Clamp01(resolution);
            Spline.FormatFromTo(ref from, ref to, false);
            double percent = from;
            Vector3 fromPos = EvaluatePosition(percent);
            List<RaycastHit> hitList = new List<RaycastHit>();
            List<double> percentList = new List<double>();
            bool hasHit = false;
            while (true)
            {
                double prevPercent = percent;
                percent = DMath.Move(percent, to, moveStep / resolution);
                Vector3 toPos = EvaluatePosition(percent);
                RaycastHit[] h = Physics.RaycastAll(fromPos, toPos - fromPos, Vector3.Distance(fromPos, toPos), layerMask, hitTriggers);
                for (int i = 0; i < h.Length; i++)
                {
                    hasHit = true;
                    double segmentPercent = (h[i].point - fromPos).sqrMagnitude / (toPos - fromPos).sqrMagnitude;
                    percentList.Add(DMath.Lerp(prevPercent, percent, segmentPercent));
                    hitList.Add(h[i]);
                }
                fromPos = toPos;
                if (percent == to) break;
            }
            hits = hitList.ToArray();
            hitPercents = percentList.ToArray();
            return hasHit;
        }

        public TriggerGroup AddTriggerGroup()
        {
            TriggerGroup newGroup = new TriggerGroup();
            ArrayUtility.Add(ref triggerGroups, newGroup);
            return newGroup;
        }

        public SplineTrigger AddTrigger(int triggerGroup, double position, SplineTrigger.Type type)
        {
            return AddTrigger(triggerGroup, position, type, "API Trigger", Color.white);
        }

        public SplineTrigger AddTrigger(int triggerGroup, double position, SplineTrigger.Type type, string name, Color color)
        {
            while (triggerGroups.Length <= triggerGroup)
            {
                AddTriggerGroup();
            }
            return triggerGroups[triggerGroup].AddTrigger(position, type, name, color);
        }

        public void RemoveTrigger(int triggerGroup, int triggerIndex)
        {
            if(triggerGroups.Length <= triggerGroup || triggerGroup < 0)
            {
                Debug.LogError("Cannot delete trigger - trigger group " + triggerIndex + " does not exist");
                return;
            }
            triggerGroups[triggerGroup].RemoveTrigger(triggerIndex);
        }

        public void CheckTriggers(double start, double end, SplineUser user = null)
        {
            for (int i = 0; i < triggerGroups.Length; i++)
            {
                triggerGroups[i].Check(start, end);
            }
        }

        public void CheckTriggers(int group, double start, double end)
        {
            if (group < 0 || group >= triggerGroups.Length)
            {
                Debug.LogError("Trigger group " + group + " does not exist");
                return;
            }
            triggerGroups[group].Check(start, end);
        }

        public void ResetTriggers()
        {
            for (int i = 0; i < triggerGroups.Length; i++) triggerGroups[i].Reset();
        }

        public void ResetTriggers(int group)
        {
            if (group < 0 || group >= triggerGroups.Length)
            {
                Debug.LogError("Trigger group " + group + " does not exist");
                return;
            }
            for (int i = 0; i < triggerGroups[group].triggers.Length; i++)
            {
                triggerGroups[group].triggers[i].Reset();
            }
        }

        /// <summary>
        /// Get the available junctions for the given point
        /// </summary>
        /// <param name="pointIndex"></param>
        /// <returns></returns>
        public List<Node.Connection> GetJunctions(int pointIndex)
        {
            for (int i = 0; i < _nodes.Length; i++)
            {
                if(_nodes[i].pointIndex == pointIndex) return _nodes[i].GetConnections(this);
            }
            return new List<Node.Connection>();
        }

        /// <summary>
        /// Get all junctions for all points in the given interval
        /// </summary>
        /// <param name="start"></param>
        /// <param name="direction"></param>
        /// <returns></returns>
        public Dictionary<int, List<Node.Connection>> GetJunctions(double start = 0.0, double end = 1.0)
        {
            int index;
            double lerp;
            UpdateSampleCollection();
            _sampleCollection.GetSamplingValues(start, out index, out lerp);
            Dictionary<int, List<Node.Connection>> junctions = new Dictionary<int, List<Node.Connection>>();
            float startValue = (_spline.points.Length - 1) * (float)start;
            float endValue = (_spline.points.Length - 1) * (float)end;
            for (int i = 0; i < _nodes.Length; i++)
            {
                bool add = false;
                if (end > start && _nodes[i].pointIndex > startValue && _nodes[i].pointIndex < endValue) add = true;
                else if (_nodes[i].pointIndex < startValue && _nodes[i].pointIndex > endValue) add = true;
                if (!add && Mathf.Abs(startValue - _nodes[i].pointIndex) <= 0.0001f) add = true;
                if (!add && Mathf.Abs(endValue - _nodes[i].pointIndex) <= 0.0001f) add = true;
                if (add) junctions.Add(_nodes[i].pointIndex, _nodes[i].GetConnections(this));
            }
            return junctions;
        }

        /// <summary>
        /// Call this to connect a node to a spline's point
        /// </summary>
        /// <param name="node"></param>
        /// <param name="pointIndex"></param>
        public void ConnectNode(Node node, int pointIndex)
        {
            if (node == null)
            {
                Debug.LogError("Missing Node");
                return;
            }

            if (pointIndex < 0 || pointIndex >= _spline.points.Length)
            {
                Debug.Log("Invalid point index " + pointIndex);
                return;
            }

            for (int i = 0; i < _nodes.Length; i++)
            {
                if (_nodes[i].node == null) continue;
                if (_nodes[i].pointIndex == pointIndex || _nodes[i].node == node)
                {
                    Node.Connection[] connections = _nodes[i].node.GetConnections();
                    for (int j = 0; j < connections.Length; j++)
                    {
                        if (connections[j].spline == this)
                        {
                            Debug.LogError("Node " + node.name + " is already connected to spline " + name + " at point " + _nodes[i].pointIndex);
                            return;
                        }
                    }
                    AddNodeLink(node, pointIndex);
                    Debug.Log("Node link already exists");
                    return;
                }
            }
            node.AddConnection(this, pointIndex);
            AddNodeLink(node, pointIndex);
        }

        public void DisconnectNode(int pointIndex)
        {
            for (int i = 0; i < _nodes.Length; i++)
            {
                if (_nodes[i].pointIndex == pointIndex)
                {
                    _nodes[i].node.RemoveConnection(this, pointIndex);
                    ArrayUtility.RemoveAt(ref _nodes, i);
                    return;
                }
            }
        }

        private void AddNodeLink(Node node, int pointIndex)
        {
            NodeLink newLink = new NodeLink();
            newLink.node = node;
            newLink.pointIndex = pointIndex;
            ArrayUtility.Add(ref _nodes, newLink);
            UpdateConnectedNodes();
        }

        public Dictionary<int, Node> GetNodes(double start = 0.0, double end = 1.0)
        {
            int index;
            double lerp;
            UpdateSampleCollection();
            _sampleCollection.GetSamplingValues(start, out index, out lerp);
            Dictionary<int, Node> nodeList = new Dictionary<int, Node>();
            float startValue = (_spline.points.Length - 1) * (float)start;
            float endValue = (_spline.points.Length - 1) * (float)end;
            for (int i = 0; i < _nodes.Length; i++)
            {
                bool add = false;
                if (end > start && _nodes[i].pointIndex > startValue && _nodes[i].pointIndex < endValue) add = true;
                else if (_nodes[i].pointIndex < startValue && _nodes[i].pointIndex > endValue) add = true;
                if (!add && Mathf.Abs(startValue - _nodes[i].pointIndex) <= 0.0001f) add = true;
                if (!add && Mathf.Abs(endValue - _nodes[i].pointIndex) <= 0.0001f) add = true;
                if (add) nodeList.Add(_nodes[i].pointIndex, _nodes[i].node);
            }
            return nodeList;
        }

        public Node GetNode(int pointIndex)
        {
            if (pointIndex < 0 || pointIndex >= _spline.points.Length) return null;
            for (int i = 0; i < _nodes.Length; i++)
            {
                if (_nodes[i].pointIndex == pointIndex) return _nodes[i].node;
            }
            return null;
        }

        public void TransferNode(int pointIndex, int newPointIndex)
        {
            if(newPointIndex < 0 || newPointIndex >= _spline.points.Length)
            {
                Debug.LogError("Invalid new point index " + newPointIndex);
                return;
            }
            if (GetNode(newPointIndex) != null)
            {
                Debug.LogError("Cannot move node to point " + newPointIndex + ". Point already connected to a node");
                return;
            }
            Node node = GetNode(pointIndex);
            if(node == null)
            {
                Debug.LogError("No node connected to point " + pointIndex);
                return;
            }
            DisconnectNode(pointIndex);
            SplineSample sample = Evaluate(newPointIndex);
            node.transform.position = sample.position;
            node.transform.rotation = sample.rotation;
            ConnectNode(node, newPointIndex);
        }

        public void ShiftNodes(int startIndex, int endIndex, int shift)
        {
            int from = endIndex;
            int to = startIndex;
            if(startIndex > endIndex)
            {
                from = startIndex;
                to = endIndex;
            }

            for (int i = from; i >= to; i--)
            {
                Node node = GetNode(i);
                if (node != null)
                {
                    TransferNode(i, i + shift);
                }
            }
        }

        /// <summary>
        /// Gets all connected computers along with the connected indices and connection indices
        /// </summary>
        /// <param name="computers">A list of the connected computers</param>
        /// <param name="connectionIndices">The point indices of this computer where the other computers are connected</param>
        /// <param name="connectedIndices">The point indices of the other computers where they are connected</param>
        /// <param name="percent"></param>
        /// <param name="direction"></param>
        /// <param name="includeEqual">Should point indices that are placed exactly at the percent be included?</param>
        public void GetConnectedComputers(List<SplineComputer> computers, List<int> connectionIndices, List<int> connectedIndices, double percent, Spline.Direction direction, bool includeEqual)
        {
            if (computers == null) computers = new List<SplineComputer>();
            if (connectionIndices == null) connectionIndices = new List<int>();
            if (connectedIndices == null) connectionIndices = new List<int>();
            computers.Clear();
            connectionIndices.Clear();
            connectedIndices.Clear();
            int pointValue = Mathf.FloorToInt((_spline.points.Length - 1) * (float)percent);
            for (int i = 0; i < _nodes.Length; i++)
            {
                bool condition = false;
                if (includeEqual)
                {
                    if (direction == Spline.Direction.Forward) condition = _nodes[i].pointIndex >= pointValue;
                    else condition = _nodes[i].pointIndex <= pointValue;
                } else
                {

                }
                if (condition)
                {
                    Node.Connection[] connections = _nodes[i].node.GetConnections();
                    for (int j = 0; j < connections.Length; j++)
                    {
                        if (connections[j].spline != this) {
                            computers.Add(connections[j].spline);
                            connectionIndices.Add(_nodes[i].pointIndex);
                            connectedIndices.Add(connections[j].pointIndex);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Returns a list of all connected computers. This includes the base computer too.
        /// </summary>
        /// <returns></returns>
        public List<SplineComputer> GetConnectedComputers()
        {
            List<SplineComputer> computers = new List<SplineComputer>();
            computers.Add(this);
            if (_nodes.Length == 0) return computers;
            GetConnectedComputers(ref computers);
            return computers;
        }

        public void GetSamplingValues(double percent, out int index, out double lerp)
        {
            UpdateSampleCollection();
            _sampleCollection.GetSamplingValues(percent, out index, out lerp);
        }

        private void GetConnectedComputers(ref List<SplineComputer> computers)
        {
            SplineComputer comp = computers[computers.Count - 1];
            if (comp == null) return;
            for (int i = 0; i < comp._nodes.Length; i++)
            {
                if (comp._nodes[i].node == null) continue;
                Node.Connection[] connections = comp._nodes[i].node.GetConnections();
                for (int n = 0; n < connections.Length; n++)
                {
                    bool found = false;
                    if (connections[n].spline == this) continue;
                    for (int x = 0; x < computers.Count; x++)
                    {
                        if (computers[x] == connections[n].spline)
                        {
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                    {
                        computers.Add(connections[n].spline);
                        GetConnectedComputers(ref computers);
                    }
                }
            }
        }

        private void RemoveNodeLinkAt(int index)
        {
            //Then remove the node link
            NodeLink[] newLinks = new NodeLink[_nodes.Length - 1];
            for (int i = 0; i < _nodes.Length; i++)
            {
                if (i == index) continue;
                else if (i < index) newLinks[i] = _nodes[i];
                else newLinks[i - 1] = _nodes[i];
            }
            _nodes = newLinks;
        }

        //This "magically" updates the Node's position and all other points, connected to it when a point, linked to a Node is changed.
        private void SetNodeForPoint(int index, SplinePoint worldPoint)
        {
            for (int i = 0; i < _nodes.Length; i++)
            {
                if (_nodes[i].pointIndex == index)
                {
                    _nodes[i].node.UpdatePoint(this, _nodes[i].pointIndex, worldPoint);
                    break;
                }
            }
        }

        private void UpdateConnectedNodes(SplinePoint[] worldPoints)
        {
            for (int i = 0; i < _nodes.Length; i++)
            {
                if (_nodes[i].node == null)
                {
                    RemoveNodeLinkAt(i);
                    i--;
                    Rebuild();
                    continue;
                }
                bool found = false;
                foreach(Node.Connection connection in _nodes[i].node.GetConnections())
                {
                    if(connection.spline == this)
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                {
                    RemoveNodeLinkAt(i);
                    i--;
                    Rebuild();
                    continue;
                }
                _nodes[i].node.UpdatePoint(this, _nodes[i].pointIndex, worldPoints[_nodes[i].pointIndex]);
                _nodes[i].node.UpdateConnectedComputers(this);
            }
        }

        private void UpdateConnectedNodes()
        {
            for (int i = 0; i < _nodes.Length; i++)
            {

                if (_nodes[i] == null || _nodes[i].node == null)
                {
                    RemoveNodeLinkAt(i);
                    Rebuild();
                    i--;
                    continue;
                }
                bool found = false;
                Node.Connection[] connections = _nodes[i].node.GetConnections();
                for (int j = 0; j < connections.Length; j++)
                {
                    if(connections[j].spline == this && connections[j].pointIndex == _nodes[i].pointIndex)
                    {
                        found = true;
                        break;
                    }
                }
                if (found)
                {
                    _nodes[i].node.UpdatePoint(this, _nodes[i].pointIndex, GetPoint(_nodes[i].pointIndex));
                } else
                {
                    RemoveNodeLinkAt(i);
                    Rebuild();
                    i--;
                    continue;
                }
            }
        }

        public Vector3 TransformPoint(Vector3 point)
        {
#if UNITY_EDITOR
            if (!_editorIsPlaying) return transform.TransformPoint(point);
#endif
            return _localToWorldMatrix.MultiplyPoint3x4(point);
        }

        public Vector3 InverseTransformPoint(Vector3 point)
        {
#if UNITY_EDITOR
            if (!_editorIsPlaying) return transform.InverseTransformPoint(point);
#endif
            return _worldToLocalMatrix.MultiplyPoint3x4(point);
        }

        public Vector3 TransformDirection(Vector3 direction)
        {
#if UNITY_EDITOR
            if (!_editorIsPlaying) return transform.TransformDirection(direction);
#endif
            return _localToWorldMatrix.MultiplyVector(direction);
        }

        public Vector3 InverseTransformDirection(Vector3 direction)
        {
#if UNITY_EDITOR
            if (!_editorIsPlaying) return transform.InverseTransformDirection(direction);
#endif
            return _worldToLocalMatrix.MultiplyVector(direction);
        }

#if UNITY_EDITOR
        public void EditorSetPointDirty(int index)
        {
            SetDirty(index);
        }

        public void EditorSetAllPointsDirty()
        {
            SetAllDirty();
        }

#endif

        [System.Serializable]
        internal class NodeLink
        {
            [SerializeField]
            internal Node node = null;
            [SerializeField]
            internal int pointIndex = 0;

            internal List<Node.Connection> GetConnections(SplineComputer exclude)
            {
                Node.Connection[] connections = node.GetConnections();
                List<Node.Connection> connectionList = new List<Node.Connection>();
                for (int i = 0; i < connections.Length; i++)
                {
                    if (connections[i].spline == exclude) continue;
                    connectionList.Add(connections[i]);
                }
                return connectionList;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineComputer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineFollower.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4ddc1a2536715a24095c464a2c394d5d
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using UnityEngine.Events;

namespace Dreamteck.Splines
{
    public delegate void SplineReachHandler();
    [AddComponentMenu("Dreamteck/Splines/Users/Spline Follower")]
    public class SplineFollower : SplineTracer
    {
        public enum FollowMode { Uniform, Time }
        public enum Wrap { Default, Loop, PingPong }
        [HideInInspector]
        public Wrap wrapMode = Wrap.Default;
        [HideInInspector]
        public FollowMode followMode = FollowMode.Uniform;

        [HideInInspector]
        public bool autoStartPosition = false;

        [SerializeField]
        [HideInInspector]
        [UnityEngine.Serialization.FormerlySerializedAs("follow")]
        private bool _follow = true;

        [SerializeField]
        [HideInInspector]
        [Range(0f, 1f)]
        private double _startPosition;

        /// <summary>
        /// If the follow mode is set to Uniform and there is an added offset in the motion panel, this will presserve the uniformity of the follow speed
        /// </summary>
        [HideInInspector]
        public bool preserveUniformSpeedWithOffset = false;

        /// <summary>
        /// Used when follow mode is set to Uniform. Defines the speed of the follower
        /// </summary>
        public float followSpeed
        {
            get { return _followSpeed; }
            set
            {
                if (_followSpeed != value)
                {
                    _followSpeed = value;
                    Spline.Direction lastDirection = _direction;
                    if (Mathf.Approximately(_followSpeed, 0f)) return;
                    if (_followSpeed < 0f)
                    {
                        direction = Spline.Direction.Backward;
                    }
                    if(_followSpeed > 0f)
                    {
                        direction = Spline.Direction.Forward;
                    }
                }
            }
        }

        public override Spline.Direction direction {
            get {
                return base.direction;
            }
            set {
                base.direction = value;
                if(_direction == Spline.Direction.Forward)
                {
                    if(_followSpeed < 0f)
                    {
                        _followSpeed = -_followSpeed;
                    }
                } else
                {
                    if (_followSpeed > 0f)
                    {
                        _followSpeed = -_followSpeed;
                    }
                }
            }
        }

        /// <summary>
        /// Used when follow mode is set to Time. Defines how much time it takes for the follower to travel through the path
        /// </summary>
        public float followDuration
        {
            get { return _followDuration; }
            set
            {
                if (_followDuration != value)
                {
                    if (value < 0f) value = 0f;
                    _followDuration = value;
                }
            }
        }

        public bool follow
        {
            get { return _follow; }
            set
            {
                if(_follow != value)
                {
                    if (autoStartPosition)
                    {
                        Project(GetTransform().position, ref evalResult);
                        SetPercent(evalResult.percent);
                    }
                    _follow = value;
                }
            }
        }

        public event System.Action<double> onEndReached;
        public event System.Action<double> onBeginningReached;

        public FollowerSpeedModifier speedModifier
        {
            get
            {
                return _speedModifier;
            }
        }

        [SerializeField]
        [HideInInspector]
        private float _followSpeed = 1f;
        [SerializeField]
        [HideInInspector]
        private float _followDuration = 1f;

        [SerializeField]
        [HideInInspector]
        private FollowerSpeedModifier _speedModifier = new FollowerSpeedModifier();

        [SerializeField]
        [HideInInspector]
        private FloatEvent _unityOnEndReached = null;
        [SerializeField]
        [HideInInspector]
        private FloatEvent _unityOnBeginningReached = null;

        private double lastClippedPercent = -1.0;

        protected override void Start()
        {
            base.Start();
            if (_follow && autoStartPosition)
            {
                SetPercent(spline.Project(GetTransform().position).percent);
            }
        }

        protected override void LateRun()
        {
            base.LateRun();
#if UNITY_EDITOR
            if (!Application.isPlaying) return;
#endif
            if (_follow)
            {
                Follow();
            }
        }

        protected override void PostBuild()
        {
            base.PostBuild();
            Evaluate(_result.percent, ref _result);
            if (sampleCount > 0)
            {
                if (_follow && !autoStartPosition) ApplyMotion();
            }
        }

        private void Follow()
        {
            switch (followMode)
            {
                case FollowMode.Uniform:
                    double percent = result.percent;
                    if (!_speedModifier.useClippedPercent)
                    {
                        UnclipPercent(ref percent);
                    }
                    float speed = _speedModifier.GetSpeed(Mathf.Abs(_followSpeed), percent);
                    Move(Time.deltaTime * speed); break;
                case FollowMode.Time:
                    if (_followDuration == 0.0) Move(0.0);
                    else Move((double)Time.deltaTime / _followDuration);
                    break;
            }
        }

        public void Restart(double startPosition = 0.0)
        {
            SetPercent(startPosition);
        }

        public override void SetPercent(double percent, bool checkTriggers = false, bool handleJunctions = false)
        {
            base.SetPercent(percent, checkTriggers, handleJunctions);
            lastClippedPercent = percent;

            if (!handleJunctions) return;

            InvokeNodes();
        }

        public override void SetDistance(float distance, bool checkTriggers = false, bool handleJunctions = false)
        {
            base.SetDistance(distance, checkTriggers, handleJunctions);
            lastClippedPercent = ClipPercent(_result.percent);
            if (samplesAreLooped && clipFrom == clipTo && distance > 0f && lastClippedPercent == 0.0) lastClippedPercent = 1.0;

            if (!handleJunctions) return;

            InvokeNodes();
        }

        public void Move(double percent)
        {
            if (percent == 0.0) return;
            if (sampleCount <= 1)
            {
                if (sampleCount == 1)
                {
                    GetSampleRaw(0, ref _result);
                    ApplyMotion();
                }
                return;
            }
            Evaluate(_result.percent, ref _result);
            double startPercent = _result.percent;
            if (wrapMode == Wrap.Default && lastClippedPercent >= 1.0 && startPercent == 0.0) startPercent = 1.0;
            double p = startPercent + (_direction == Spline.Direction.Forward ? percent : -percent);
            bool callOnEndReached = false, callOnBeginningReached = false;
            lastClippedPercent = p;
            if (_direction == Spline.Direction.Forward && p >= 1.0)
            {
                if (startPercent < 1.0)
                {
                    callOnEndReached = true;
                }
                switch (wrapMode)
                {
                    case Wrap.Default:
                        p = 1.0;
                        break;
                    case Wrap.Loop:
                        CheckTriggers(startPercent, 1.0);
                        CheckNodes(startPercent, 1.0);
                        while (p > 1.0) p -= 1.0;
                        startPercent = 0.0;
                        break;
                    case Wrap.PingPong:
                        p = DMath.Clamp01(1.0 - (p - 1.0));
                        startPercent = 1.0;
                        direction = Spline.Direction.Backward;
                        break;
                }
            }
            else if (_direction == Spline.Direction.Backward && p <= 0.0)
            {
                if (startPercent > 0.0)
                {
                    callOnBeginningReached = true;
                }
                switch (wrapMode)
                {
                    case Wrap.Default:
                        p = 0.0;
                        break;
                    case Wrap.Loop:
                        CheckTriggers(startPercent, 0.0);
                        CheckNodes(startPercent, 0.0);
                        while (p < 0.0) p += 1.0;
                        startPercent = 1.0;
                        break;
                    case Wrap.PingPong:
                        p = DMath.Clamp01(-p);
                        startPercent = 0.0;
                        direction = Spline.Direction.Forward;
                        break;
                }
            }
            CheckTriggers(startPercent, p);
            CheckNodes(startPercent, p);
            Evaluate(p, ref _result);
            ApplyMotion();
            if (callOnEndReached)
            {
                if (onEndReached != null)
                {
                    onEndReached(startPercent);
                }
                if (_unityOnEndReached != null)
                {
                    _unityOnEndReached.Invoke((float)startPercent);
                }
            }
            else if (callOnBeginningReached)
            {
                if (onBeginningReached != null)
                {
                    onBeginningReached(startPercent);
                }
                if (_unityOnBeginningReached != null)
                {
                    _unityOnBeginningReached.Invoke((float)startPercent);
                }
            }
            InvokeTriggers();
            InvokeNodes();
        }

        public void Move(float distance)
        {
            bool endReached = false, beginningReached = false;
            float moved = 0f;
            double startPercent = _result.percent;

            double travelPercent = DoTravel(_result.percent, distance, out moved);
            if (startPercent != travelPercent)
            {
                CheckTriggers(startPercent, travelPercent);
                CheckNodes(startPercent, travelPercent);
            }

            if (direction == Spline.Direction.Forward)
            {
                if (travelPercent >= 1.0)
                {
                    if (startPercent < 1.0)
                    {
                        endReached = true;
                    }
                    switch (wrapMode)
                    {
                        case Wrap.Loop:
                            travelPercent = DoTravel(0.0, Mathf.Abs(distance - moved), out moved);
                            CheckTriggers(0.0, travelPercent);
                            CheckNodes(0.0, travelPercent);
                            break;
                        case Wrap.PingPong:
                            direction = Spline.Direction.Backward;
                            travelPercent = DoTravel(1.0, distance - moved, out moved);
                            CheckTriggers(1.0, travelPercent);
                            CheckNodes(1.0, travelPercent);
                            break;
                    }
                }
            } else
            {
                if (travelPercent <= 0.0)
                {
                    if (startPercent > 0.0)
                    {
                        beginningReached = true;
                    }
                    switch (wrapMode)
                    {
                        case Wrap.Loop:
                            travelPercent = DoTravel(1.0, distance - moved, out moved);
                            CheckTriggers(1.0, travelPercent);
                            CheckNodes(1.0, travelPercent);
                            break;
                        case Wrap.PingPong:
                            direction = Spline.Direction.Forward;
                            travelPercent = DoTravel(0.0, Mathf.Abs(distance - moved), out moved);
                            CheckTriggers(0.0, travelPercent);
                            CheckNodes(0.0, travelPercent);
                            break;
                    }
                }
            }

            Evaluate(travelPercent, ref _result);
            ApplyMotion();
            if (endReached)
            {
                if (onEndReached != null)
                {
                    onEndReached(startPercent);
                }
                if (_unityOnEndReached != null)
                {
                    _unityOnEndReached.Invoke((float)startPercent);
                }
            }
            else if (beginningReached)
            {
                if (onBeginningReached != null)
                {
                    onBeginningReached(startPercent);
                }
                if (_unityOnBeginningReached != null)
                {
                    _unityOnBeginningReached.Invoke((float)startPercent);
                }
            }
            InvokeTriggers();
            InvokeNodes();
        }

        protected virtual double DoTravel(double start, float distance, out float moved)
        {
            moved = 0f;
            double result = 0.0;
            if (preserveUniformSpeedWithOffset && _motion.hasOffset)
            {
                result = TravelWithOffset(start, distance, _direction, _motion.offset, out moved);
            } else
            {
                result = Travel(start, distance, _direction, out moved);
            }
            return result;
        }

        [System.Serializable]
        public class FloatEvent : UnityEvent<float> { }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineFollower.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a8e405fbab136934590641eb781310b4
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Threading;

namespace Dreamteck.Splines
{
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Dreamteck/Splines/Users/Spline Mesh")]
    public partial class SplineMesh : MeshGenerator
    {
        //Mesh data
        [SerializeField]
        [HideInInspector, UnityEngine.Serialization.FormerlySerializedAs("channels")]
        private List<Channel> _channels = new List<Channel>();
        private bool _useLastResult = false;
        private List<TS_Mesh> _combineMeshes = new List<TS_Mesh>();

        protected override string meshName => "Custom Mesh";

        private Matrix4x4 _vertexMatrix = new Matrix4x4();
        private Matrix4x4 _normalMatrix = new Matrix4x4();
        private SplineSample _lastResult = new SplineSample();

        protected override void Awake()
        {
            base.Awake();
#if UNITY_EDITOR
            for (int i = 0; i < _channels.Count; i++)
            {
                for (int j = 0; j < _channels[i].GetMeshCount(); j++)
                {
                    _channels[i].GetMesh(j).Refresh();
                }
            }
#endif
        }

        protected override void Reset()
        {
            base.Reset();
            AddChannel("Channel 1");
        }

        public void RemoveChannel(int index)
        {
            _channels.RemoveAt(index);
            Rebuild();
        }

        public void SwapChannels(int a, int b)
        {
            if (a < 0 || a >= _channels.Count || b < 0 || b >= _channels.Count) return;
            Channel temp = _channels[b];
            _channels[b] = _channels[a];
            _channels[a] = temp;
            Rebuild();
        }

        public Channel AddChannel(Mesh inputMesh, string name)
        {
            Channel channel = new Channel(name, inputMesh, this);
            _channels.Add(channel);
            return channel;
        }

        public Channel AddChannel(string name)
        {
            Channel channel = new Channel(name, this);
            _channels.Add(channel);
            return channel;
        }

        public int GetChannelCount()
        {
            return _channels.Count;
        }

        public Channel GetChannel(int index)
        {
            return _channels[index];
        }


        protected override void BuildMesh()
        {
            base.BuildMesh();
            Generate();
        }

        private void Generate()
        {
            int meshCount = 0;
            for (int i = 0; i < _channels.Count; i++)
            {
                if (_channels[i].GetMeshCount() == 0) continue;

                if (_channels[i].autoCount)
                {
                    float avgBounds = 0f;
                    for (int j = 0; j < _channels[i].GetMeshCount(); j++)
                    {
                        avgBounds += _channels[i].GetMesh(j).bounds.size.z;
                    }

                    if (_channels[i].GetMeshCount() > 1)
                    {
                        avgBounds /= _channels[i].GetMeshCount();
                    }

                    if (avgBounds > 0f)
                    {
                        float length = CalculateLength(_channels[i].clipFrom, _channels[i].clipTo, false);
                        int newCount = Mathf.RoundToInt(length / avgBounds);
                        if (newCount < 1)
                        {
                            newCount = 1;
                        }
                        _channels[i].count = newCount;
                    }
                }

                meshCount += _channels[i].count;
            }

            if(meshCount == 0)
            {
                _tsMesh.Clear();
                return;
            }

            if (_combineMeshes.Count < meshCount)
            {
                _combineMeshes.AddRange(new TS_Mesh[meshCount - _combineMeshes.Count]);
            }
            else if (_combineMeshes.Count > meshCount)
            {
                _combineMeshes.RemoveRange((_combineMeshes.Count - 1) - (_combineMeshes.Count - meshCount), _combineMeshes.Count - meshCount);
            }

            int combineMeshIndex = 0;
            for (int i = 0; i < _channels.Count; i++)
            {
                if (_channels[i].GetMeshCount() == 0) continue;
                _channels[i].ResetIteration();
                _useLastResult = false;
                double step = 1.0 / _channels[i].count;
                double space = step * _channels[i].spacing * 0.5;
                
                switch (_channels[i].type)
                {
                    case Channel.Type.Extrude:
                        for (int j = 0; j < _channels[i].count; j++)
                        {
                            double from = DMath.Lerp(_channels[i].clipFrom, _channels[i].clipTo, j * step + space);
                            double to = DMath.Lerp(_channels[i].clipFrom, _channels[i].clipTo, j * step + step - space);
                            if (_combineMeshes[combineMeshIndex] == null)
                            {
                                _combineMeshes[combineMeshIndex] = new TS_Mesh();
                            }
                            Extrude(_channels[i], _combineMeshes[combineMeshIndex], from, to);
                            combineMeshIndex++;
                        }
                        if (space == 0f) _useLastResult = true;
                        break;
                    case Channel.Type.Place:
                        for (int j = 0; j < _channels[i].count; j++)
                        {
                            if (_combineMeshes[combineMeshIndex] == null)
                            {
                                _combineMeshes[combineMeshIndex] = new TS_Mesh();
                            }
                            Place(_channels[i], _combineMeshes[combineMeshIndex], DMath.Lerp(_channels[i].clipFrom, _channels[i].clipTo, (double)j / Mathf.Max(_channels[i].count - 1, 1)));
                            combineMeshIndex++;
                        }
                        break;
                   
                }
            }
            _tsMesh.Combine(_combineMeshes);
        }

        private void Place(Channel channel, TS_Mesh target, double percent)
        {
            Channel.MeshDefinition definition = channel.NextMesh();
            if (target == null) target = new TS_Mesh();
            definition.Write(target, channel.overrideMaterialID ? channel.targetMaterialID : -1);
            Vector2 channelOffset = channel.NextRandomOffset();
            Quaternion channelRotation = channel.NextRandomQuaternion();

            var customValues = channel.GetCustomPlaceValues(percent);

            Vector2 finalOffset = channelOffset + customValues.Item1 + new Vector2(offset.x, offset.y);
            Quaternion finalRotation = channelRotation * Quaternion.AngleAxis(rotation, Vector3.forward) * customValues.Item2;
            Vector3 finalScale = channel.NextPlaceScale();

            Evaluate(percent, ref evalResult);
            Vector3 originalNormal = evalResult.up;
            Vector3 originalRight = evalResult.right;
            Vector3 originalDirection = evalResult.forward;
            if (channel.overrideNormal)
            {
                evalResult.forward = Vector3.Cross(evalResult.right, channel.customNormal);
                evalResult.up = channel.customNormal;
            }

            if (!channel.scaleModifier.useClippedPercent)
            {
                UnclipPercent(ref evalResult.percent);
            }
            Vector3 scaleMod = channel.scaleModifier.GetScale(evalResult);
            finalScale.x *= customValues.Item3.x * scaleMod.x;
            finalScale.y *= customValues.Item3.y * scaleMod.y;
            finalScale.z *= customValues.Item3.z * scaleMod.z;

            if (!channel.scaleModifier.useClippedPercent)
            {
                ClipPercent(ref evalResult.percent);
            }

            float resultSize = GetBaseSize(evalResult);
            _vertexMatrix.SetTRS(evalResult.position + originalRight * (finalOffset.x * resultSize) + originalNormal * (finalOffset.y * resultSize) + originalDirection * offset.z, //Position
                evalResult.rotation * finalRotation, //Rotation
                finalScale * resultSize ); //Scale
            _normalMatrix = _vertexMatrix.inverse.transpose;

            for (int i = 0; i < target.vertexCount; i++)
            {
                target.vertices[i] = _vertexMatrix.MultiplyPoint3x4(definition.vertices[i]);
                target.normals[i] = _normalMatrix.MultiplyVector(definition.normals[i]);
            }
            for (int i = 0; i < Mathf.Min(target.colors.Length, definition.colors.Length); i++)
            {
                target.colors[i] = definition.colors[i] * evalResult.color * color;
            }
        }

        private void Extrude(Channel channel, TS_Mesh target, double from, double to)
        {
            Channel.MeshDefinition definition = channel.NextMesh();
            if (target == null) target = new TS_Mesh();
            definition.Write(target, channel.overrideMaterialID ? channel.targetMaterialID : -1);
            Vector2 uv = Vector2.zero;
            Vector3 trsVector = Vector3.zero;

            Vector3 channelOffset = channel.NextRandomOffset();
            Vector3 channelScale = channel.NextRandomScale();
            float channelRotation = channel.NextRandomAngle();

            for (int i = 0; i < definition.vertexGroups.Count; i++)
            {
                if (_useLastResult && i == definition.vertexGroups.Count)
                {
                    evalResult = _lastResult;
                }
                else
                {
                    Evaluate(DMath.Lerp(from, to, definition.vertexGroups[i].percent), ref evalResult);
                }

                Vector3 originalNormal = evalResult.up;
                Vector3 originalRight = evalResult.right;
                Vector3 originalDirection = evalResult.forward;
                if (channel.overrideNormal)
                {
                    evalResult.forward = Vector3.Cross(evalResult.right, channel.customNormal);
                    evalResult.up = channel.customNormal;
                }
                var customValues = channel.GetCustomExtrudeValues(evalResult.percent);
                Vector3 finalOffset = offset + channelOffset + (Vector3)customValues.Item1;
                float finalRotation = rotation + channelRotation + customValues.Item2;
                Vector3 finalScale = channelScale;
                if (!channel.scaleModifier.useClippedPercent)
                {
                    UnclipPercent(ref evalResult.percent);
                }
                Vector2 scaleMod = channel.scaleModifier.GetScale(evalResult);
                if (!channel.scaleModifier.useClippedPercent)
                {
                    ClipPercent(ref evalResult.percent);
                }
                finalScale.x *= customValues.Item3.x * scaleMod.x;
                finalScale.y *= customValues.Item3.y * scaleMod.y;
                finalScale.z = 1f;
                float resultSize = evalResult.size;
                _vertexMatrix.SetTRS(evalResult.position + originalRight * (finalOffset.x * resultSize) + originalNormal * (finalOffset.y * resultSize) + originalDirection * offset.z, //Position
                    evalResult.rotation * Quaternion.AngleAxis(finalRotation, Vector3.forward), //Rotation
                    finalScale * resultSize); //Scale
                _normalMatrix = _vertexMatrix.inverse.transpose;
                if (i == 0)
                {
                    _lastResult = evalResult;
                }

                for (int n = 0; n < definition.vertexGroups[i].ids.Length; n++)
                {
                    int index = definition.vertexGroups[i].ids[n];
                    trsVector = definition.vertices[index];
                    trsVector.z = 0f;
                    target.vertices[index] = _vertexMatrix.MultiplyPoint3x4(trsVector);
                    trsVector = definition.normals[index];
                    target.normals[index] = _normalMatrix.MultiplyVector(trsVector);
                    target.colors[index] = target.colors[index] * evalResult.color * color;
                    if (target.uv.Length > index)
                    {
                        uv = target.uv[index];
                        switch (channel.overrideUVs)
                        {
                            case Channel.UVOverride.ClampU: uv.x = (float)evalResult.percent; break;
                            case Channel.UVOverride.ClampV: uv.y = (float)evalResult.percent; break;
                            case Channel.UVOverride.UniformU: uv.x = CalculateLength(0.0, evalResult.percent); break;
                            case Channel.UVOverride.UniformV: uv.y = CalculateLength(0.0, evalResult.percent); break;
                        }
                        target.uv[index] = new Vector2(uv.x * uvScale.x * channel.uvScale.x, uv.y * uvScale.y * channel.uvScale.y);
                        target.uv[index] += uvOffset + channel.uvOffset;
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMesh.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMeshChannel.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 116eda7a4c26e224ab08142aea1ddf31
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections.Generic;

namespace Dreamteck.Splines
{
    public partial class SplineMesh : MeshGenerator
    {

        [System.Serializable]
        public class Channel
        {
            public delegate float FloatHandler(double percent);
            public delegate Vector2 Vector2Handler(double percent);
            public delegate Vector3 Vector3Handler(double percent);
            public delegate Quaternion QuaternionHandler(double percent);

            public string name = "Channel";
            public enum Type { Extrude, Place }
            public enum UVOverride { None, ClampU, ClampV, UniformU, UniformV }

            private System.Random iterationRandom;
            [SerializeField]
            [HideInInspector]
            private int _iterationSeed = 0;
            [SerializeField]
            [HideInInspector]
            private int _offsetSeed = 0;
            private System.Random _offsetRandom;
            private Vector2Handler _offsetHandler = null;
            [SerializeField]
            [HideInInspector]
            private int _rotationSeed = 0;
            private System.Random _rotationRandom;
            private QuaternionHandler _placeRotationHandler = null;
            private FloatHandler _extrudeRotationHandler = null;
            [SerializeField]
            [HideInInspector]
            private int _scaleSeed = 0;
            private System.Random _scaleRandom;
            private Vector3Handler _scaleHandler = null;

            [SerializeField]
            internal SplineMesh owner = null;

            [SerializeField]
            [HideInInspector]
            private List<MeshDefinition> meshes = new List<MeshDefinition>();


            [SerializeField]
            [HideInInspector]
            private double _clipFrom = 0.0;
            [SerializeField]
            [HideInInspector]
            private double _clipTo = 1.0;
            [SerializeField]
            [HideInInspector]
            private bool _randomOrder = false;
            [SerializeField]
            [HideInInspector]
            private UVOverride _overrideUVs = UVOverride.None;
            [SerializeField]
            [HideInInspector]
            private Vector2 _uvScale = Vector2.one;
            [SerializeField]
            [HideInInspector]
            private Vector2 _uvOffset = Vector2.zero;
            [SerializeField]
            [HideInInspector]
            private bool _overrideNormal = false;
            [SerializeField]
            [HideInInspector]
            private Vector3 _customNormal = Vector3.up;
            [SerializeField]
            [HideInInspector]
            private Type _type = Type.Extrude;

            [SerializeField]
            [HideInInspector]
            private int _count = 1;
            [SerializeField]
            [HideInInspector]
            private bool _autoCount = false;
            [SerializeField]
            [HideInInspector]
            private double _spacing = 0.0;
            [SerializeField]
            [HideInInspector]
            private bool _randomRotation = false;
            [SerializeField]
            [HideInInspector]
            private Vector3 _minRotation = Vector3.zero;
            [SerializeField]
            [HideInInspector]
            private Vector3 _maxRotation = Vector3.zero;
            [SerializeField]
            [HideInInspector]
            private bool _randomOffset = false;
            [SerializeField]
            [HideInInspector]
            private Vector2 _minOffset = Vector2.one;
            [SerializeField]
            [HideInInspector]
            private Vector2 _maxOffset = Vector2.one;
            [SerializeField]
            [HideInInspector]
            private bool _randomScale = false;
            [SerializeField]
            [HideInInspector]
            private bool _uniformRandomScale = false;
            [SerializeField]
            [HideInInspector]
            private Vector3 _minScale = Vector3.one;
            [SerializeField]
            [HideInInspector]
            private Vector3 _maxScale = Vector3.one;
            private int iterator = 0;
            [SerializeField]
            [HideInInspector]
            private bool _overrideMaterialID = false;
            [SerializeField]
            [HideInInspector]
            private int _targetMaterialID = 0;

            [SerializeField]
            [HideInInspector]
            protected MeshScaleModifier _scaleModifier = new MeshScaleModifier();

            public double clipFrom
            {
                get { return _clipFrom; }
                set
                {
                    if (value != _clipFrom)
                    {
                        _clipFrom = value;
                        Rebuild();
                    }
                }
            }

            public double clipTo
            {
                get { return _clipTo; }
                set
                {
                    if (value != _clipTo)
                    {
                        _clipTo = value;
                        Rebuild();
                    }
                }
            }

            public bool randomOffset
            {
                get { return _randomOffset; }
                set
                {
                    if (value != _randomOffset)
                    {
                        _randomOffset = value;
                        Rebuild();
                    }
                }
            }

            public Vector2Handler offsetHandler
            {
                get { return _offsetHandler; }
                set
                {
                    if (value != _offsetHandler)
                    {
                        _offsetHandler = value;
                        Rebuild();
                    }
                }
            }

            public bool overrideMaterialID
            {
                get { return _overrideMaterialID; }
                set
                {
                    if (value != _overrideMaterialID)
                    {
                        _overrideMaterialID = value;
                        Rebuild();
                    }
                }
            }

            public int targetMaterialID
            {
                get { return _targetMaterialID; }
                set
                {
                    if (value != _targetMaterialID)
                    {
                        _targetMaterialID = value;
                        Rebuild();
                    }
                }
            }

            public bool randomRotation
            {
                get { return _randomRotation; }
                set
                {
                    if (value != _randomRotation)
                    {
                        _randomRotation = value;
                        Rebuild();
                    }
                }
            }

            public QuaternionHandler placeRotationHandler
            {
                get { return _placeRotationHandler; }
                set
                {
                    if (value != _placeRotationHandler)
                    {
                        _placeRotationHandler = value;
                        Rebuild();
                    }
                }
            }

            public FloatHandler extrudeRotationHandler
            {
                get { return _extrudeRotationHandler; }
                set
                {
                    if (value != _extrudeRotationHandler)
                    {
                        _extrudeRotationHandler = value;
                        Rebuild();
                    }
                }
            }

            public bool randomScale
            {
                get { return _randomScale; }
                set
                {
                    if (value != _randomScale)
                    {
                        _randomScale = value;
                        Rebuild();
                    }
                }
            }

            public Vector3Handler scaleHandler
            {
                get { return _scaleHandler; }
                set
                {
                    if (value != _scaleHandler)
                    {
                        _scaleHandler = value;
                        Rebuild();
                    }
                }
            }

            public bool uniformRandomScale
            {
                get { return _uniformRandomScale; }
                set
                {
                    if (value != _uniformRandomScale)
                    {
                        _uniformRandomScale = value;
                        Rebuild();
                    }
                }
            }

            public int offsetSeed
            {
                get { return _offsetSeed; }
                set
                {
                    if (value != _offsetSeed)
                    {
                        _offsetSeed = value;
                        Rebuild();
                    }
                }
            }

            public int rotationSeed
            {
                get { return _rotationSeed; }
                set
                {
                    if (value != _rotationSeed)
                    {
                        _rotationSeed = value;
                        Rebuild();
                    }
                }
            }

            public int scaleSeed
            {
                get { return _scaleSeed; }
                set
                {
                    if (value != _scaleSeed)
                    {
                        _scaleSeed = value;
                        Rebuild();
                    }
                }
            }

            public double spacing
            {
                get { return _spacing; }
                set
                {
                    if (value != _spacing)
                    {
                        _spacing = value;
                        Rebuild();
                    }
                }
            }

            public Vector2 minOffset
            {
                get { return _minOffset; }
                set
                {
                    if (value != _minOffset)
                    {
                        _minOffset = value;
                        Rebuild();
                    }
                }
            }

            public Vector2 maxOffset
            {
                get { return _maxOffset; }
                set
                {
                    if (value != _maxOffset)
                    {
                        _maxOffset = value;
                        Rebuild();
                    }
                }
            }

            public Vector3 minRotation
            {
                get { return _minRotation; }
                set
                {
                    if (value != _minRotation)
                    {
                        _minRotation = value;
                        Rebuild();
                    }
                }
            }

            public Vector3 maxRotation
            {
                get { return _maxRotation; }
                set
                {
                    if (value != _maxRotation)
                    {
                        _maxRotation = value;
                        Rebuild();
                    }
                }
            }

            public Vector3 minScale
            {
                get { return _minScale; }
                set
                {
                    if (value != _minScale)
                    {
                        _minScale = value;
                        Rebuild();
                    }
                }
            }

            public Vector3 maxScale
            {
                get { return _maxScale; }
                set
                {
                    if (value != _maxScale)
                    {
                        _maxScale = value;
                        Rebuild();
                    }
                }
            }

            public Type type
            {
                get { return _type; }
                set
                {
                    if (value != _type)
                    {
                        _type = value;
                        Rebuild();
                    }
                }
            }

            public bool randomOrder
            {
                get { return _randomOrder; }
                set
                {
                    if (value != _randomOrder)
                    {
                        _randomOrder = value;
                        Rebuild();
                    }
                }
            }

            public int randomSeed
            {
                get { return _iterationSeed; }
                set
                {
                    if (value != _iterationSeed)
                    {
                        _iterationSeed = value;
                        if (_randomOrder) Rebuild();
                    }
                }
            }
            public int count
            {
                get { return _count; }
                set
                {
                    if (value != _count)
                    {
                        _count = value;
                        if (_count < 1) _count = 1;
                        Rebuild();
                    }
                }
            }

            public bool autoCount
            {
                get { return _autoCount; }
                set
                {
                    if (value != _autoCount)
                    {
                        _autoCount = value;
                        Rebuild();
                    }
                }
            }

            public UVOverride overrideUVs
            {
                get { return _overrideUVs; }
                set
                {
                    if (value != _overrideUVs)
                    {
                        _overrideUVs = value;
                        Rebuild();
                    }
                }
            }

            public Vector2 uvOffset
            {
                get { return _uvOffset; }
                set
                {
                    if (value != _uvOffset)
                    {
                        _uvOffset = value;
                        Rebuild();
                    }
                }
            }

            public Vector2 uvScale
            {
                get { return _uvScale; }
                set
                {
                    if (value != _uvScale)
                    {
                        _uvScale = value;
                        Rebuild();
                    }
                }
            }

            public bool overrideNormal
            {
                get { return _overrideNormal; }
                set
                {
                    if (value != _overrideNormal)
                    {
                        _overrideNormal = value;
                        Rebuild();
                    }
                }
            }

            public Vector3 customNormal
            {
                get { return _customNormal; }
                set
                {
                    if (value != _customNormal)
                    {
                        _customNormal = value;
                        Rebuild();
                    }
                }
            }

            public MeshScaleModifier scaleModifier
            {
                get
                {
                    return _scaleModifier;
                }
            }

            public Channel(string n, SplineMesh parent)
            {
                name = n;
                owner = parent;
                Init();
            }

            public Channel(string n, Mesh inputMesh, SplineMesh parent)
            {
                name = n;
                owner = parent;
                meshes.Add(new MeshDefinition(inputMesh));
                Init();
                Rebuild();
            }

            void Init()
            {
                _minScale = _maxScale = Vector3.one;
                _minOffset = _maxOffset = Vector3.zero;
                _minRotation = _maxRotation = Vector3.zero;
            }

            public void CopyTo(Channel target)
            {
                target.meshes.Clear();
                for (int i = 0; i < meshes.Count; i++) target.meshes.Add(meshes[i].Copy());
                target._clipFrom = _clipFrom;
                target._clipTo = _clipTo;
                target._customNormal = _customNormal;
                target._iterationSeed = _iterationSeed;
                target._minOffset = _minOffset;
                target._minRotation = _minRotation;
                target._minScale = _minScale;
                target._maxOffset = _maxOffset;
                target._maxRotation = _maxRotation;
                target._maxScale = _maxScale;
                target._randomOffset = _randomOffset;
                target._randomRotation = _randomRotation;
                target._randomScale = _randomScale;
                target._offsetSeed = _offsetSeed;
                target._offsetHandler = _offsetHandler;
                target._rotationSeed = _rotationSeed;
                target._placeRotationHandler = _placeRotationHandler;
                target._extrudeRotationHandler = _extrudeRotationHandler;
                target._scaleSeed = _scaleSeed;
                target._scaleHandler = _scaleHandler;
                target._iterationSeed = _iterationSeed;
                target._count = _count;
                target._spacing = _spacing;
                target._overrideUVs = _overrideUVs;
                target._type = _type;
                target._overrideMaterialID = _overrideMaterialID;
                target._targetMaterialID = _targetMaterialID;
                target._overrideNormal = _overrideNormal;
            }

            public int GetMeshCount()
            {
                return meshes.Count;
            }

            public void SwapMeshes(int a, int b)
            {
                if (a < 0 || a >= meshes.Count || b < 0 || b >= meshes.Count) return;
                MeshDefinition temp = meshes[b];
                meshes[b] = meshes[a];
                meshes[a] = temp;
                Rebuild();
            }

            public void DuplicateMesh(int index)
            {
                if (index < 0 || index >= meshes.Count) return;
                meshes.Add(meshes[index].Copy());
                Rebuild();
            }

            public MeshDefinition GetMesh(int index)
            {
                return meshes[index];
            }

            public void AddMesh(Mesh input)
            {
                meshes.Add(new MeshDefinition(input));
                Rebuild();
            }

            public void AddMesh(MeshDefinition meshDefinition)
            {
                if (!meshes.Contains(meshDefinition))
                {
                    meshes.Add(meshDefinition);
                    Rebuild();
                }
            }

            public void RemoveMesh(int index)
            {
                meshes.RemoveAt(index);
                Rebuild();
            }

            public void ResetIteration()
            {
                if (_randomOrder) iterationRandom = new System.Random(_iterationSeed);
                if (_randomOffset) _offsetRandom = new System.Random(_offsetSeed);
                if (_randomRotation) _rotationRandom = new System.Random(_rotationSeed);
                if (_randomScale) _scaleRandom = new System.Random(_scaleSeed);
                iterator = 0;
            }

            public (Vector2, Quaternion, Vector3) GetCustomPlaceValues(double percent)
            {
                (Vector2, Quaternion, Vector3) values = (Vector2.zero, Quaternion.identity, Vector3.one);
                if (_offsetHandler != null)
                {
                    values.Item1 = _offsetHandler(percent);
                }
                if (_placeRotationHandler != null)
                {
                    values.Item2 = _placeRotationHandler(percent);
                }
                if (_scaleHandler != null)
                {
                    values.Item3 = _scaleHandler(percent);
                }
                return values;
            }

            public (Vector2, float, Vector3) GetCustomExtrudeValues(double percent)
            {
                (Vector2, float, Vector3) values = (Vector2.zero, 0f, Vector3.one);
                if (_offsetHandler != null)
                {
                    values.Item1 = _offsetHandler(percent);
                }
                if (_extrudeRotationHandler != null)
                {
                    values.Item2 = _extrudeRotationHandler(percent);
                }
                if (_scaleHandler != null)
                {
                    values.Item3 = _scaleHandler(percent);
                }
                return values;
            }

            public Vector2 NextRandomOffset()
            {
                if (_randomOffset) return new Vector2(Mathf.Lerp(_minOffset.x, _maxOffset.x, (float)_offsetRandom.NextDouble()), Mathf.Lerp(_minOffset.y, _maxOffset.y, (float)_offsetRandom.NextDouble()));
                return _minOffset;
            }

            public Quaternion NextRandomQuaternion()
            {
                if (_randomRotation) return Quaternion.Euler(new Vector3(Mathf.Lerp(_minRotation.x, _maxRotation.x, (float)_rotationRandom.NextDouble()), Mathf.Lerp(_minRotation.y, _maxRotation.y, (float)_rotationRandom.NextDouble()), Mathf.Lerp(_minRotation.z, _maxRotation.z, (float)_rotationRandom.NextDouble())));
                return Quaternion.Euler(_minRotation);
            }

            public float NextRandomAngle()
            {
                if (_randomRotation) return Mathf.Lerp(_minRotation.z, _maxRotation.z, (float)_rotationRandom.NextDouble());
                return _minRotation.z;
            }

            public Vector3 NextRandomScale()
            {
                if (_randomScale)
                {
                    if (_uniformRandomScale) return Vector3.Lerp(new Vector3(_minScale.x, _minScale.y, 1f), new Vector3(_maxScale.x, _maxScale.y, 1f), (float)_scaleRandom.NextDouble());
                    return new Vector3(Mathf.Lerp(_minScale.x, _maxScale.x, (float)_scaleRandom.NextDouble()), Mathf.Lerp(_minScale.y, _maxScale.y, (float)_scaleRandom.NextDouble()), 1f);
                }
                return new Vector3(_minScale.x, _minScale.y, 1f);
            }

            public Vector3 NextPlaceScale()
            {
                if (_randomScale)
                {
                    if (_uniformRandomScale) return Vector3.Lerp(_minScale, _maxScale, (float)_scaleRandom.NextDouble());
                    return new Vector3(Mathf.Lerp(_minScale.x, _maxScale.x, (float)_scaleRandom.NextDouble()), Mathf.Lerp(_minScale.y, _maxScale.y, (float)_scaleRandom.NextDouble()), Mathf.Lerp(_minScale.z, _maxScale.z, (float)_scaleRandom.NextDouble()));
                }
                return _minScale;
            }

            public MeshDefinition NextMesh()
            {
                if (_randomOrder) return meshes[iterationRandom.Next(meshes.Count)];
                else
                {
                    if (iterator >= meshes.Count) iterator = 0;
                    return meshes[iterator++];
                }
            }

            internal void Rebuild()
            {
                if (owner != null) owner.Rebuild();
            }

            void Refresh()
            {
                for (int i = 0; i < meshes.Count; i++) meshes[i].Refresh();
                Rebuild();
            }

            [System.Serializable]
            public struct BoundsSpacing
            {
                public float front;
                public float back;
            }

            [System.Serializable]
            public class MeshDefinition
            {
                public enum MirrorMethod { None, X, Y, Z }
                [SerializeField]
                [HideInInspector]
                public Vector3[] vertices = new Vector3[0];
                [SerializeField]
                [HideInInspector]
                public Vector3[] normals = new Vector3[0];
                [SerializeField]
                [HideInInspector]
                public Vector4[] tangents = new Vector4[0];
                [SerializeField]
                [HideInInspector]
                public Color[] colors = new Color[0];
                [SerializeField]
                [HideInInspector]
                public Vector2[] uv = new Vector2[0];
                [SerializeField]
                [HideInInspector]
                public Vector2[] uv2 = new Vector2[0];
                [SerializeField]
                [HideInInspector]
                public Vector2[] uv3 = new Vector2[0];
                [SerializeField]
                [HideInInspector]
                public Vector2[] uv4 = new Vector2[0];
                [SerializeField]
                [HideInInspector]
                public int[] triangles = new int[0];
                [SerializeField]
                [HideInInspector]
                public List<Submesh> subMeshes = new List<Submesh>();
                [SerializeField]
                [HideInInspector]
                public TS_Bounds bounds = new TS_Bounds(Vector3.zero, Vector3.zero);
                [SerializeField]
                [HideInInspector]
                public List<VertexGroup> vertexGroups = new List<VertexGroup>();
                [SerializeField]
                [HideInInspector]
                private Mesh _mesh = null;
                [SerializeField]
                [HideInInspector]
                private Vector3 _rotation = Vector3.zero;
                [SerializeField]
                [HideInInspector]
                private Vector3 _offset = Vector3.zero;
                [SerializeField]
                [HideInInspector]
                private Vector3 _scale = Vector3.one;
                [SerializeField]
                [HideInInspector]
                private Vector2 _uvScale = Vector2.one;
                [SerializeField]
                [HideInInspector]
                private Vector2 _uvOffset = Vector2.zero;
                [SerializeField]
                [HideInInspector]
                private float _uvRotation = 0f;
                [SerializeField]
                [HideInInspector]
                private MirrorMethod _mirror = MirrorMethod.None;
                [SerializeField]
                [HideInInspector]
                public BoundsSpacing _spacing = new BoundsSpacing();

                [SerializeField]
                [HideInInspector]
                private float _vertexGroupingMargin = 0f;
                [SerializeField]
                [HideInInspector]
                private bool _removeInnerFaces = false;
                [SerializeField]
                [HideInInspector]
                private bool _flipFaces = false;
                [SerializeField]
                [HideInInspector]
                private bool _doubleSided = false;

                public Mesh mesh
                {
                    get
                    {
                        return _mesh;
                    }
                    set
                    {
                        if (_mesh != value)
                        {
                            _mesh = value;
                            Refresh();
                        }
                    }
                }

                public Vector3 rotation
                {
                    get
                    {
                        return _rotation;
                    }
                    set
                    {
                        if (rotation != value)
                        {
                            _rotation = value;
                            Refresh();
                        }
                    }
                }

                public Vector3 offset
                {
                    get
                    {
                        return _offset;
                    }
                    set
                    {
                        if (_offset != value)
                        {
                            _offset = value;
                            Refresh();
                        }
                    }
                }

                public Vector3 scale
                {
                    get
                    {
                        return _scale;
                    }
                    set
                    {
                        if (_scale != value)
                        {
                            _scale = value;
                            Refresh();
                        }
                    }
                }

                public BoundsSpacing spacing
                {
                    get
                    {
                        return _spacing;
                    }
                    set
                    {
                        if (_spacing.back != value.back || _spacing.front != value.front)
                        {
                            _spacing = value;
                            Refresh();
                        }
                    }
                }

                public Vector2 uvScale
                {
                    get
                    {
                        return _uvScale;
                    }
                    set
                    {
                        if (_uvScale != value)
                        {
                            _uvScale = value;
                            Refresh();
                        }
                    }
                }

                public Vector2 uvOffset
                {
                    get
                    {
                        return _uvOffset;
                    }
                    set
                    {
                        if (_uvOffset != value)
                        {
                            _uvOffset = value;
                            Refresh();
                        }
                    }
                }

                public float uvRotation
                {
                    get
                    {
                        return _uvRotation;
                    }
                    set
                    {
                        if (_uvRotation != value)
                        {
                            _uvRotation = value;
                            Refresh();
                        }
                    }
                }

                public float vertexGroupingMargin
                {
                    get
                    {
                        return _vertexGroupingMargin;
                    }
                    set
                    {
                        if (_vertexGroupingMargin != value)
                        {
                            _vertexGroupingMargin = value;
                            Refresh();
                        }
                    }
                }

                public MirrorMethod mirror
                {
                    get { return _mirror; }
                    set
                    {
                        if (_mirror != value)
                        {
                            _mirror = value;
                            Refresh();
                        }
                    }
                }

                public bool removeInnerFaces
                {
                    get { return _removeInnerFaces; }
                    set
                    {
                        if (_removeInnerFaces != value)
                        {
                            _removeInnerFaces = value;
                            Refresh();
                        }
                    }
                }

                public bool flipFaces
                {
                    get { return _flipFaces; }
                    set
                    {
                        if (_flipFaces != value)
                        {
                            _flipFaces = value;
                            Refresh();
                        }
                    }
                }

                public bool doubleSided
                {
                    get { return _doubleSided; }
                    set
                    {
                        if (_doubleSided != value)
                        {
                            _doubleSided = value;
                            Refresh();
                        }
                    }
                }

                internal MeshDefinition Copy()
                {
                    MeshDefinition target = new MeshDefinition(_mesh);
                    target.vertices = new Vector3[vertices.Length];
                    target.normals = new Vector3[normals.Length];
                    target.colors = new Color[colors.Length];
                    target.tangents = new Vector4[tangents.Length];
                    target.uv = new Vector2[uv.Length];
                    target.uv2 = new Vector2[uv2.Length];
                    target.uv3 = new Vector2[uv3.Length];
                    target.uv4 = new Vector2[uv4.Length];
                    target.triangles = new int[triangles.Length];

                    vertices.CopyTo(target.vertices, 0);
                    normals.CopyTo(target.normals, 0);
                    colors.CopyTo(target.colors, 0);
                    tangents.CopyTo(target.tangents, 0);
                    uv.CopyTo(target.uv, 0);
                    uv2.CopyTo(target.uv2, 0);
                    uv3.CopyTo(target.uv3, 0);
                    uv4.CopyTo(target.uv4, 0);
                    triangles.CopyTo(target.triangles, 0);

                    target.bounds = new TS_Bounds(bounds.min, bounds.max);
                    target.subMeshes = new List<Submesh>();
                    for (int i = 0; i < subMeshes.Count; i++)
                    {
                        target.subMeshes.Add(new Submesh(new int[subMeshes[i].triangles.Length]));
                        subMeshes[i].triangles.CopyTo(target.subMeshes[target.subMeshes.Count - 1].triangles, 0);
                    }

                    target._mirror = _mirror;
                    target._offset = _offset;
                    target._rotation = _rotation;
                    target._scale = _scale;
                    target._uvOffset = _uvOffset;
                    target._uvScale = _uvScale;
                    target._uvRotation = _uvRotation;
                    target._flipFaces = _flipFaces;
                    target._doubleSided = _doubleSided;
                    return target;
                }

                public MeshDefinition(Mesh input)
                {
                    _mesh = input;
                    Refresh();
                }

                public void Refresh()
                {
                    if (_mesh == null)
                    {
                        vertices = new Vector3[0];
                        normals = new Vector3[0];
                        colors = new Color[0];
                        uv = new Vector2[0];
                        uv2 = new Vector2[0];
                        uv3 = new Vector2[0];
                        uv4 = new Vector2[0];
                        tangents = new Vector4[0];
                        triangles = new int[0];
                        subMeshes = new List<Submesh>();
                        vertexGroups = new List<VertexGroup>();
                        return;
                    }
                    if (vertices.Length != _mesh.vertexCount) vertices = new Vector3[_mesh.vertexCount];
                    if (normals.Length != _mesh.normals.Length) normals = new Vector3[_mesh.normals.Length];
                    if (colors.Length != _mesh.colors.Length) colors = new Color[_mesh.colors.Length];
                    if (uv.Length != _mesh.uv.Length) uv = new Vector2[_mesh.uv.Length];
                    if (uv2.Length != _mesh.uv2.Length) uv2 = new Vector2[_mesh.uv2.Length];
                    if (uv3.Length != _mesh.uv3.Length) uv3 = new Vector2[_mesh.uv3.Length];
                    if (uv4.Length != _mesh.uv4.Length) uv4 = new Vector2[_mesh.uv4.Length];
                    if (tangents.Length != _mesh.tangents.Length) tangents = new Vector4[_mesh.tangents.Length];
                    if (triangles.Length != _mesh.triangles.Length) triangles = new int[_mesh.triangles.Length];

                    vertices = _mesh.vertices;
                    normals = _mesh.normals;
                    colors = _mesh.colors;
                    uv = _mesh.uv;
                    uv2 = _mesh.uv2;
                    uv3 = _mesh.uv3;
                    uv4 = _mesh.uv4;
                    tangents = _mesh.tangents;
                    triangles = _mesh.triangles;
                    colors = _mesh.colors;

                    while (subMeshes.Count > _mesh.subMeshCount) subMeshes.RemoveAt(0);
                    while (subMeshes.Count < _mesh.subMeshCount) subMeshes.Add(new Submesh(new int[0]));
                    for (int i = 0; i < subMeshes.Count; i++) subMeshes[i].triangles = _mesh.GetTriangles(i);


                    if (colors.Length != vertices.Length)
                    {
                        colors = new Color[vertices.Length];
                        for (int i = 0; i < colors.Length; i++) colors[i] = Color.white;
                    }
                    Mirror();
                    if (_doubleSided) DoubleSided();
                    else if (_flipFaces) FlipFaces();
                    TransformVertices();
                    CalculateBounds();
                    if (_removeInnerFaces) RemoveInnerFaces();
                    GroupVertices();

                    if (bounds.size.z < 0.002f || bounds.size.x < 0.002f || bounds.size.y < 0.002f)
                    {
                        Debug.LogWarning($"The size of [{_mesh.name}]'s bounds is too small! This could cause an issue if the [Auto Count] option is enabled!");
                    }
                }

                void RemoveInnerFaces()
                {
                    float min = float.MaxValue, max = 0f;
                    for (int i = 0; i < vertices.Length; i++)
                    {
                        if (vertices[i].z < min) min = vertices[i].z;
                        if (vertices[i].z > max) max = vertices[i].z;
                    }

                    for (int i = 0; i < subMeshes.Count; i++)
                    {
                        List<int> newTris = new List<int>();
                        for (int j = 0; j < subMeshes[i].triangles.Length; j += 3)
                        {
                            bool innerMax = true, innerMin = true;
                            for (int k = j; k < j + 3; k++)
                            {
                                int index = subMeshes[i].triangles[k];
                                if (!Mathf.Approximately(vertices[index].z, max)) innerMax = false;
                                if (!Mathf.Approximately(vertices[index].z, min)) innerMin = false;
                            }
                            if (!innerMax && !innerMin)
                            {
                                newTris.Add(subMeshes[i].triangles[j]);
                                newTris.Add(subMeshes[i].triangles[j + 1]);
                                newTris.Add(subMeshes[i].triangles[j + 2]);
                            }
                        }
                        subMeshes[i].triangles = newTris.ToArray();
                    }
                }

                void FlipFaces()
                {
                    TS_Mesh temp = new TS_Mesh();
                    temp.normals = normals;
                    temp.tangents = tangents;
                    temp.triangles = triangles;
                    for (int i = 0; i < subMeshes.Count; i++) temp.subMeshes.Add(subMeshes[i].triangles);
                    MeshUtility.FlipFaces(temp);
                }

                void DoubleSided()
                {
                    TS_Mesh temp = new TS_Mesh();
                    temp.vertices = vertices;
                    temp.normals = normals;
                    temp.tangents = tangents;
                    temp.colors = colors;
                    temp.uv = uv;
                    temp.uv2 = uv2;
                    temp.uv3 = uv3;
                    temp.uv4 = uv4;
                    temp.triangles = triangles;
                    for (int i = 0; i < subMeshes.Count; i++) temp.subMeshes.Add(subMeshes[i].triangles);
                    MeshUtility.MakeDoublesided(temp);
                    vertices = temp.vertices;
                    normals = temp.normals;
                    tangents = temp.tangents;
                    colors = temp.colors;
                    uv = temp.uv;
                    uv2 = temp.uv2;
                    uv3 = temp.uv3;
                    uv4 = temp.uv4;
                    triangles = temp.triangles;
                    for (int i = 0; i < subMeshes.Count; i++) subMeshes[i].triangles = temp.subMeshes[i];
                }

                public void Write(TS_Mesh target, int forceMaterialId = -1)
                {
                    if (target.vertices.Length != vertices.Length) target.vertices = new Vector3[vertices.Length];
                    if (target.normals.Length != normals.Length) target.normals = new Vector3[normals.Length];
                    if (target.colors.Length != colors.Length) target.colors = new Color[colors.Length];
                    if (target.uv.Length != uv.Length) target.uv = new Vector2[uv.Length];
                    if (target.uv2.Length != uv2.Length) target.uv2 = new Vector2[uv2.Length];
                    if (target.uv3.Length != uv3.Length) target.uv3 = new Vector2[uv3.Length];
                    if (target.uv4.Length != uv4.Length) target.uv4 = new Vector2[uv4.Length];
                    if (target.tangents.Length != tangents.Length) target.tangents = new Vector4[tangents.Length];
                    if (target.triangles.Length != triangles.Length) target.triangles = new int[triangles.Length];

                    vertices.CopyTo(target.vertices, 0);
                    normals.CopyTo(target.normals, 0);
                    colors.CopyTo(target.colors, 0);
                    uv.CopyTo(target.uv, 0);
                    uv2.CopyTo(target.uv2, 0);
                    uv3.CopyTo(target.uv3, 0);
                    uv4.CopyTo(target.uv4, 0);
                    tangents.CopyTo(target.tangents, 0);
                    triangles.CopyTo(target.triangles, 0);

                    if (target.subMeshes == null) target.subMeshes = new List<int[]>();

                    if (forceMaterialId >= 0)
                    {
                        while (target.subMeshes.Count > forceMaterialId + 1) target.subMeshes.RemoveAt(0);
                        while (target.subMeshes.Count < forceMaterialId + 1) target.subMeshes.Add(new int[0]);
                        for (int i = 0; i < target.subMeshes.Count; i++)
                        {
                            if (i != forceMaterialId)
                            {
                                if (target.subMeshes[i].Length > 0) target.subMeshes[i] = new int[0];
                            }
                            else
                            {
                                if (target.subMeshes[i].Length != triangles.Length) target.subMeshes[i] = new int[triangles.Length];
                                triangles.CopyTo(target.subMeshes[i], 0);
                            }
                        }
                    }
                    else
                    {
                        while (target.subMeshes.Count > subMeshes.Count) target.subMeshes.RemoveAt(0);
                        while (target.subMeshes.Count < subMeshes.Count) target.subMeshes.Add(new int[0]);
                        for (int i = 0; i < subMeshes.Count; i++)
                        {
                            if (subMeshes[i].triangles.Length != target.subMeshes[i].Length) target.subMeshes[i] = new int[subMeshes[i].triangles.Length];
                            subMeshes[i].triangles.CopyTo(target.subMeshes[i], 0);
                        }
                    }
                }

                void CalculateBounds()
                {
                    Vector3 min = Vector3.zero;
                    Vector3 max = Vector3.zero;
                    for (int i = 0; i < vertices.Length; i++)
                    {
                        if (vertices[i].x < min.x) min.x = vertices[i].x;
                        else if (vertices[i].x > max.x) max.x = vertices[i].x;
                        if (vertices[i].y < min.y) min.y = vertices[i].y;
                        else if (vertices[i].y > max.y) max.y = vertices[i].y;
                        if (vertices[i].z < min.z) min.z = vertices[i].z;
                        else if (vertices[i].z > max.z) max.z = vertices[i].z;
                    }

                    min.z -= spacing.back;
                    max.z += spacing.front;
                    bounds.CreateFromMinMax(min, max);
                }

                private void Mirror()
                {
                    if (_mirror == MirrorMethod.None) return;
                    switch (_mirror)
                    {
                        case MirrorMethod.X:
                            for (int i = 0; i < vertices.Length; i++)
                            {
                                vertices[i].x *= -1f;
                                normals[i].x = -normals[i].x;
                            }
                            break;
                        case MirrorMethod.Y:
                            for (int i = 0; i < vertices.Length; i++)
                            {
                                vertices[i].y *= -1f;
                                normals[i].y = -normals[i].y;
                            }
                            break;
                        case MirrorMethod.Z:
                            for (int i = 0; i < vertices.Length; i++)
                            {
                                vertices[i].z *= -1f;
                                normals[i].z = -normals[i].z;
                            }
                            break;
                    }
                    for (int i = 0; i < triangles.Length; i += 3)
                    {
                        int temp = triangles[i];
                        triangles[i] = triangles[i + 2];
                        triangles[i + 2] = temp;
                    }
                    for (int i = 0; i < subMeshes.Count; i++)
                    {
                        for (int j = 0; j < subMeshes[i].triangles.Length; j += 3)
                        {
                            int temp = subMeshes[i].triangles[j];
                            subMeshes[i].triangles[j] = subMeshes[i].triangles[j + 2];
                            subMeshes[i].triangles[j + 2] = temp;
                        }
                    }
                    CalculateTangents();
                }

                void TransformVertices()
                {
                    Matrix4x4 vertexMatrix = new Matrix4x4();
                    vertexMatrix.SetTRS(_offset, Quaternion.Euler(_rotation), _scale);
                    Matrix4x4 normalMatrix = vertexMatrix.inverse.transpose;
                    for (int i = 0; i < vertices.Length; i++)
                    {
                        vertices[i] = vertexMatrix.MultiplyPoint3x4(vertices[i]);
                        normals[i] = normalMatrix.MultiplyVector(normals[i]).normalized;
                    }
                    for (int i = 0; i < tangents.Length; i++) tangents[i] = normalMatrix.MultiplyVector(tangents[i]);
                    for (int i = 0; i < uv.Length; i++)
                    {
                        uv[i].x *= _uvScale.x;
                        uv[i].y *= _uvScale.y;
                        uv[i] += _uvOffset;
                        uv[i] = Quaternion.AngleAxis(uvRotation, Vector3.forward) * uv[i];
                    }
                }

                void GroupVertices()
                {
                    vertexGroups = new List<VertexGroup>();

                    for (int i = 0; i < vertices.Length; i++)
                    {
                        float value = vertices[i].z;
                        double percent = DMath.Clamp01(DMath.InverseLerp(bounds.min.z, bounds.max.z, value));
                        int index = FindInsertIndex(vertices[i], value);
                        if (index >= vertexGroups.Count) vertexGroups.Add(new VertexGroup(value, percent, new int[] { i }));
                        else
                        {
                            float valueDelta = Mathf.Abs(vertexGroups[index].value - value);
                            if (valueDelta < vertexGroupingMargin || Mathf.Approximately(valueDelta, vertexGroupingMargin)) vertexGroups[index].AddId(i);
                            else if (vertexGroups[index].value < value) vertexGroups.Insert(index, new VertexGroup(value, percent, new int[] { i }));
                            else
                            {
                                if (index < vertexGroups.Count - 1) vertexGroups.Insert(index + 1, new VertexGroup(value, percent, new int[] { i }));
                                else vertexGroups.Add(new VertexGroup(value, percent, new int[] { i }));
                            }
                        }
                    }
                }

                int FindInsertIndex(Vector3 pos, float value)
                {
                    int lower = 0;
                    int upper = vertexGroups.Count - 1;

                    while (lower <= upper)
                    {
                        int middle = lower + (upper - lower) / 2;
                        if (vertexGroups[middle].value == value) return middle;
                        else if (vertexGroups[middle].value < value) upper = middle - 1;
                        else lower = middle + 1;
                    }
                    return lower;
                }

                void CalculateTangents()
                {
                    if (vertices.Length == 0)
                    {
                        tangents = new Vector4[0];
                        return;
                    }
                    tangents = new Vector4[vertices.Length];
                    Vector3[] tan1 = new Vector3[vertices.Length];
                    Vector3[] tan2 = new Vector3[vertices.Length];
                    for (int i = 0; i < subMeshes.Count; i++)
                    {
                        for (int j = 0; j < subMeshes[i].triangles.Length; j += 3)
                        {
                            int i1 = subMeshes[i].triangles[j];
                            int i2 = subMeshes[i].triangles[j + 1];
                            int i3 = subMeshes[i].triangles[j + 2];
                            float x1 = vertices[i2].x - vertices[i1].x;
                            float x2 = vertices[i3].x - vertices[i1].x;
                            float y1 = vertices[i2].y - vertices[i1].y;
                            float y2 = vertices[i3].y - vertices[i1].y;
                            float z1 = vertices[i2].z - vertices[i1].z;
                            float z2 = vertices[i3].z - vertices[i1].z;
                            float s1 = uv[i2].x - uv[i1].x;
                            float s2 = uv[i3].x - uv[i1].x;
                            float t1 = uv[i2].y - uv[i1].y;
                            float t2 = uv[i3].y - uv[i1].y;
                            float div = s1 * t2 - s2 * t1;
                            float r = div == 0f ? 0f : 1f / div;
                            Vector3 sdir = new Vector3((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
                            Vector3 tdir = new Vector3((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
                            tan1[i1] += sdir;
                            tan1[i2] += sdir;
                            tan1[i3] += sdir;
                            tan2[i1] += tdir;
                            tan2[i2] += tdir;
                            tan2[i3] += tdir;
                        }
                    }
                    for (int i = 0; i < vertices.Length; i++)
                    {
                        Vector3 n = normals[i];
                        Vector3 t = tan1[i];
                        Vector3.OrthoNormalize(ref n, ref t);
                        tangents[i].x = t.x;
                        tangents[i].y = t.y;
                        tangents[i].z = t.z;
                        tangents[i].w = (Vector3.Dot(Vector3.Cross(n, t), tan2[i]) < 0.0f) ? -1.0f : 1.0f;
                    }
                }

                [System.Serializable]
                public class Submesh
                {
                    public int[] triangles = new int[0];

                    public Submesh()
                    {

                    }

                    public Submesh(int[] input)
                    {
                        triangles = new int[input.Length];
                        input.CopyTo(triangles, 0);
                    }
                }

                [System.Serializable]
                public class VertexGroup
                {
                    public float value = 0f;
                    public double percent = 0.0;
                    public int[] ids;

                    public VertexGroup(float val, double perc, int[] vertIds)
                    {
                        percent = perc;
                        value = val;
                        ids = vertIds;
                    }

                    public void AddId(int id)
                    {
                        int[] newIds = new int[ids.Length + 1];
                        ids.CopyTo(newIds, 0);
                        newIds[newIds.Length - 1] = id;
                        ids = newIds;
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMeshChannel.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMorph.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f3bc3656a791f444ca225a99f9333768
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;
    [AddComponentMenu("Dreamteck/Splines/Morph")]
    public class SplineMorph : MonoBehaviour
    {
        [HideInInspector]
        public SplineComputer.Space space = SplineComputer.Space.Local;
        [HideInInspector]
        public bool cycle = false;
        public enum CycleMode {Default, Loop, PingPong}
        public enum UpdateMode {Update, FixedUpdate, LateUpdate}
        [HideInInspector]
        public CycleMode cycleMode = CycleMode.Default;
        [HideInInspector]
        public UpdateMode cycleUpdateMode = UpdateMode.Update;
        [HideInInspector]
        public float cycleDuration = 1f;
        public SplineComputer spline
        {
            get { return _spline; }
            set
            {
                if (Application.isPlaying)
                {
                    if(channels.Length > 0 && value.pointCount != channels[0].points.Length)
                    {
                        value.SetPoints(channels[0].points, space);
                    }
                }
                _spline = value;
            }
        }

        [SerializeField]
        [HideInInspector]
        private SplineComputer _spline;
        private SplinePoint[] points = new SplinePoint[0];
        private float cycleValue = 0f;
        private short cycleDirection = 1;


        [System.Serializable]
        public class Channel
        {
            public enum Interpolation { Linear, Spherical }
            [SerializeField]
            internal SplinePoint[] points = new SplinePoint[0];
            [SerializeField]
            internal float percent = 1f;
            public string name = "";
            public AnimationCurve curve;
            public Interpolation interpolation = Interpolation.Linear;
        }
        [HideInInspector]
        [SerializeField]
        [UnityEngine.Serialization.FormerlySerializedAs("morphStates")]
        private Channel[] channels = new Channel[0];

        private void Reset()
        {
            spline = GetComponent<SplineComputer>();
        }

        private void Update()
        {
            if (cycleUpdateMode == UpdateMode.Update) RunUpdate();
        }

        private void FixedUpdate()
        {
            if (cycleUpdateMode == UpdateMode.FixedUpdate) RunUpdate();
        }

        private void LateUpdate()
        {
            if (cycleUpdateMode == UpdateMode.LateUpdate) RunUpdate();
        }

        void RunUpdate()
        {
            if (!cycle) return;
            if (cycleMode != CycleMode.PingPong) cycleDirection = 1;
            cycleValue += Time.deltaTime / cycleDuration * cycleDirection;
            switch (cycleMode)
            {
                case CycleMode.Default:
                    if (cycleValue > 1f) cycleValue = 1f;
                    break;
                case CycleMode.Loop:
                    if (cycleValue > 1f) cycleValue -= Mathf.Floor(cycleValue);
                    break;
                case CycleMode.PingPong:
                    if (cycleValue > 1f)
                    {
                        cycleValue = 1f - (cycleValue - Mathf.Floor(cycleValue));
                        cycleDirection = -1;
                    } else if (cycleValue < 0f)
                    {
                        cycleValue = -cycleValue - Mathf.Floor(-cycleValue);
                        cycleDirection = 1;
                    }
                    break;
            }
            SetWeight(cycleValue, cycleMode == CycleMode.Loop);
        }

        public void SetCycle(float value)
        {
            cycleValue = Mathf.Clamp01(value);
        }

        public void SetWeight(int index, float weight)
        {
            channels[index].percent = Mathf.Clamp01(weight);
            UpdateMorph();
        }

        public void SetWeight(string name, float weight)
        {
            int index = GetChannelIndex(name);
            channels[index].percent = Mathf.Clamp01(weight);
            UpdateMorph();
        }

        public void SetWeight(float percent, bool loop = false)
        {
            float channelValue = percent * (loop ? channels.Length : channels.Length - 1);
            for (int i = 0; i < channels.Length; i++)
            {
                float delta = Mathf.Abs(i - channelValue);
                if (delta > 1f)
                {
                    SetWeight(i, 0f);
                }
                else
                {
                    if (channelValue <= i)
                    {
                        SetWeight(i, 1f - (i - channelValue));
                    }
                    else
                    {
                        SetWeight(i, 1f - (channelValue - i));
                    }
                }
            }
            if (loop && channelValue >= channels.Length - 1)
            {
                SetWeight(0, channelValue - (channels.Length - 1));
            }
        }

        public void CaptureSnapshot(string name)
        {
            CaptureSnapshot(GetChannelIndex(name));
        }

        public void CaptureSnapshot(int index)
        {
            if (_spline == null) return;
            if ((channels.Length > 0 && _spline.pointCount != channels[0].points.Length && index != 0))
            {
                Debug.LogError("Point count must be the same as " + _spline.pointCount);
                return;
            }
            channels[index].points = _spline.GetPoints(space);
            UpdateMorph();
        }

        public void Clear()
        {
            channels = new Channel[0];
        }

        public SplinePoint[] GetSnapshot(int index)
        {
            return channels[index].points;
        }
        public void SetSnapshot(int index, SplinePoint[] points)
        {
            channels[index].points = points;
        }


        public SplinePoint[] GetSnapshot(string name)
        {
            int index = GetChannelIndex(name);
            return channels[index].points;
        }

        public float GetWeight(int index)
        {
            return channels[index].percent;
        }

        public float GetWeight(string name)
        {
            int index = GetChannelIndex(name);
            return channels[index].percent;
        }

        public void AddChannel(string name)
        {
            if (_spline == null) return;
            if (channels.Length > 0 && _spline.pointCount != channels[0].points.Length)
            {
                Debug.LogError("Point count must be the same as " + channels[0].points.Length);
                return;
            }
            Channel newMorph = new Channel();
            newMorph.points = _spline.GetPoints(space);
            newMorph.name = name;
            newMorph.curve = new AnimationCurve();
            newMorph.curve.AddKey(new Keyframe(0, 0, 0, 1));
            newMorph.curve.AddKey(new Keyframe(1, 1, 1, 0));
            ArrayUtility.Add(ref channels, newMorph);
            UpdateMorph();
        }

        public void RemoveChannel(string name)
        {
            int index = GetChannelIndex(name);
            RemoveChannel(index);
        }

        public void RemoveChannel(int index)
        {
            if (index < 0 || index >= channels.Length) return;
            Channel[] newStates = new Channel[channels.Length - 1];
            for (int i = 0; i < channels.Length; i++)
            {
                if (i == index) continue;
                else if (i < index) newStates[i] = channels[i];
                else if (i >= index) newStates[i - 1] = channels[i];
            }
            channels = newStates;
            UpdateMorph();
        }

        private int GetChannelIndex(string name)
        {
            for (int i = 0; i < channels.Length; i++)
            {
                if (channels[i].name == name)
                {
                    return i;
                }
            }
            Debug.Log("Channel not found " + name);
            return 0;
        }

        public int GetChannelCount()
        {
            if (channels == null) return 0;
            return channels.Length;
        }

        public Channel GetChannel(int index)
        {
            return channels[index];
        }

        public Channel GetChannel(string name)
        {
            return channels[GetChannelIndex(name)];
        }

        public void UpdateMorph()
        {
            if (_spline == null) return;
            if (channels.Length == 0) return;
            if(points.Length != channels[0].points.Length)
            {
                points = new SplinePoint[channels[0].points.Length];
            }

            for (int i = 0; i < channels.Length; i++)
            {
                for (int j = 0; j < points.Length; j++)
                {
                    if(i == 0)
                    {
                        points[j] = channels[0].points[j];
                        continue;
                    }

                    float percent = channels[i].curve.Evaluate(channels[i].percent);
                    if (channels[i].interpolation == Channel.Interpolation.Linear)
                    {
                        points[j].position += (channels[i].points[j].position - channels[0].points[j].position) * percent;
                        points[j].tangent += (channels[i].points[j].tangent - channels[0].points[j].tangent) * percent;
                        points[j].tangent2 += (channels[i].points[j].tangent2 - channels[0].points[j].tangent2) * percent;
                        points[j].normal += (channels[i].points[j].normal - channels[0].points[j].normal) * percent;
                    } else
                    {
                        points[j].position = Vector3.Slerp(points[j].position, points[j].position + (channels[i].points[j].position - channels[0].points[j].position), percent);
                        points[j].tangent = Vector3.Slerp(points[j].tangent, points[j].tangent + (channels[i].points[j].tangent - channels[0].points[j].tangent), percent);
                        points[j].tangent2 = Vector3.Slerp(points[j].tangent2, points[j].tangent2 + (channels[i].points[j].tangent2 - channels[0].points[j].tangent2), percent);
                        points[j].normal = Vector3.Slerp(points[j].normal, points[j].normal + (channels[i].points[j].normal - channels[0].points[j].normal), percent);
                    }

                    points[j].color += (channels[i].points[j].color - channels[0].points[j].color) * percent;
                    points[j].size += (channels[i].points[j].size - channels[0].points[j].size) * percent;

                    if(points[j].type == SplinePoint.Type.SmoothMirrored) points[j].type = channels[i].points[j].type;
                    else if(points[j].type == SplinePoint.Type.SmoothFree)
                    {
                        if (channels[i].points[j].type == SplinePoint.Type.Broken) points[j].type = SplinePoint.Type.Broken;
                    }
                }
            }

            for (int i = 0; i < points.Length; i++)
            {
                points[i].normal.Normalize();
            }
            _spline.SetPoints(points, space);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineMorph.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplinePositioner.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0def5156137c6d14082064fa7b5d5247
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;

namespace Dreamteck.Splines
{
    [AddComponentMenu("Dreamteck/Splines/Users/Spline Positioner")]
    [ExecuteInEditMode]
    public class SplinePositioner : SplineTracer
    {
        public enum Mode { Percent, Distance }

        public GameObject targetObject
        {
            get
            {
                if (_targetObject == null) return gameObject;
                return _targetObject;
            }

            set
            {
                if (value != _targetObject)
                {
                    _targetObject = value;
                    RefreshTargets();
                    Rebuild();
                }
            }
        }

        public SplineTracer followTarget
        {
            get { return _followTarget; }
            set
            {
                if(value != _followTarget)
                {
                    if(_followTarget != null)
                    {
                        _followTarget.onMotionApplied -= OnFollowTargetMotionApplied;
                    }
                    if(value == this)
                    {
                        Debug.Log("You should not be assigning a self-reference to the followTarget field.");
                        return;
                    }
                    _followTarget = value;
                    if(_followTarget != null)
                    {
                        _followTarget.onMotionApplied += OnFollowTargetMotionApplied;
                        OnFollowTargetMotionApplied();
                    }
                }
            }
        }

        public float followTargetDistance
        {
            get { return _followTargetDistance;  }
            set
            {
                if(value != _followTargetDistance)
                {
                    _followTargetDistance = value;
                    if(followTarget != null)
                    {
                        OnFollowTargetMotionApplied();
                    }
                }
            }
        }

        public bool followLoop
        {
            get { return _followLoop; }
            set
            {
                if (value != _followLoop)
                {
                    _followLoop = value;
                    if (followTarget != null)
                    {
                        OnFollowTargetMotionApplied();
                    }
                }
            }
        }

        public Spline.Direction followTargetDirection
        {
            get { return _followTargetDirection; }
            set
            {
                if (value != _followTargetDirection)
                {
                    _followTargetDirection = value;
                    if (followTarget != null)
                    {
                        OnFollowTargetMotionApplied();
                    }
                }
            }
        }

        public double position
        {
            get
            {
                return _result.percent;
            }
            set
            {
                if (value != _position)
                {
                    _position = (float)value;
                    if (mode == Mode.Distance)
                    {
                        SetDistance(_position, true, true);
                    }
                    else
                    {
                        SetPercent(value, true, true);
                    }
                }
            }
        }

        public Mode mode
        {
            get { return _mode;  }
            set
            {
                if (value != _mode)
                {
                    _mode = value;
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private GameObject _targetObject;
        [SerializeField]
        [HideInInspector]
        private SplineTracer _followTarget;
        [SerializeField]
        [HideInInspector]
        private float _followTargetDistance;
        [SerializeField]
        [HideInInspector]
        private bool _followLoop;
        [SerializeField]
        [HideInInspector]
        private Spline.Direction _followTargetDirection = Spline.Direction.Backward;
        [SerializeField]
        [HideInInspector]
        private float _position = 0f;
        [SerializeField]
        [HideInInspector]
        private Mode _mode = Mode.Percent;
        private float _lastPosition = 0f;

        private void OnFollowTargetMotionApplied()
        {
            float moved;
            double percent = Travel(followTarget.result.percent, _followTargetDistance, _followTargetDirection, out moved);
            if (_followLoop)
            {
                if (_followTargetDistance - moved > 0.000001f)
                {
                    if (percent <= 0.000001)
                    {
                        percent = Travel(1.0, _followTargetDistance - moved, _followTargetDirection, out moved);
                    }
                    else if (percent >= 0.999999)
                    {
                        percent = Travel(0.0, _followTargetDistance - moved, _followTargetDirection, out moved);
                    }
                }
            }
            SetPercent(percent, true);
        }

        protected override void Awake()
        {
            base.Awake();
            if(_followTarget != null)
            {
                _followTarget.onMotionApplied += OnFollowTargetMotionApplied;
            }
        }

        protected override void OnDestroy()
        {
            base.OnDestroy();
            if (_followTarget != null)
            {
                _followTarget.onMotionApplied -= OnFollowTargetMotionApplied;
            }
        }


        protected override void OnDidApplyAnimationProperties()
        {
            if (_lastPosition != _position)
            {
                _lastPosition = _position;
                if (mode == Mode.Distance)
                {
                    SetDistance(_position, true);
                }
                else
                {
                    SetPercent(_position, true);
                }
            }
            base.OnDidApplyAnimationProperties();
        }

        protected override Transform GetTransform()
        {
            return targetObject.transform;
        }

        protected override Rigidbody GetRigidbody()
        {
            return targetObject.GetComponent<Rigidbody>();
        }

        protected override Rigidbody2D GetRigidbody2D()
        {
            return targetObject.GetComponent<Rigidbody2D>();
        }

        protected override void PostBuild()
        {
            base.PostBuild();
            if (mode == Mode.Distance) SetDistance((float)_position, true);
            else SetPercent(_position, true);
        }

        public override void SetPercent(double percent, bool checkTriggers = false, bool handleJunctions = false)
        {
            base.SetPercent(percent, checkTriggers, handleJunctions);
            _position = (float)percent;

            if (!handleJunctions) return;

            InvokeNodes();
        }

        public override void SetDistance(float distance, bool checkTriggers = false, bool handleJunctions = false)
        {
            double lastPercent = _result.percent;
            double travel = Travel(0.0, distance, Spline.Direction.Forward);
            Evaluate(travel, ref _result);
            ApplyMotion();

            if (checkTriggers)
            {
                CheckTriggers(lastPercent, _result.percent);
                InvokeTriggers();
            }
            if (handleJunctions)
            {
                CheckNodes(lastPercent, _result.percent);
            }

            _position = mode == Mode.Distance ? distance : (float)travel;

            if (!handleJunctions) return;

            InvokeNodes();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplinePositioner.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineProjector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 453ef2bcc92003342b9fe6a327abc98c
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using UnityEngine.Events;
using System.Collections;
using UnityEngine.Serialization;

namespace Dreamteck.Splines
{
    [ExecuteInEditMode]
    [AddComponentMenu("Dreamteck/Splines/Users/Spline Projector")]
    public class SplineProjector : SplineTracer
    {
        public enum Mode {Accurate, Cached}
        public Mode mode
        {
            get { return _mode; }
            set
            {
                if(value != _mode)
                {
                    _mode = value;
                    Rebuild();
                }
            }
        }

        public bool autoProject
        {
            get { return _autoProject; }
            set
            {
                if(value != _autoProject)
                {
                    _autoProject = value;
                    if (_autoProject) Rebuild();
                }
            }
        }

        public int subdivide
        {
            get { return _subdivide; }
            set
            {
                if (value != _subdivide)
                {
                    _subdivide = value;
                    if (_mode == Mode.Accurate) Rebuild();
                }
            }
        }

        public Transform projectTarget
        {
            get {
                if (_projectTarget == null) return transform;
                return _projectTarget; 
            }
            set
            {
                if (value != _projectTarget)
                {
                    _projectTarget = value;
                    Rebuild();
                }
            }
        }

        public GameObject targetObject
        {
            get
            {
                if (_targetObject == null)
                {
                    if (applyTarget != null) //Temporary check to migrate SplineProjectors that use target
                    {
                        _targetObject = applyTarget.gameObject;
                        applyTarget = null;
                        return _targetObject;
                    }
                }
                return _targetObject;
            }

            set
            {
                if (value != _targetObject)
                {
                    _targetObject = value;
                    RefreshTargets();
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private Mode _mode = Mode.Cached;
        [SerializeField]
        [HideInInspector]
        private bool _autoProject = true;
        [SerializeField]
        [HideInInspector]
        [Range(3, 8)]
        private int _subdivide = 4;
        [SerializeField]
        [HideInInspector]
        private Transform _projectTarget;


        [SerializeField]
        [HideInInspector]
        private Transform applyTarget = null;
        [SerializeField]
        [HideInInspector]
        private GameObject _targetObject;

        [SerializeField]
        [HideInInspector]
        public Vector2 _offset;
        [SerializeField]
        [HideInInspector]
        public Vector3 _rotationOffset = Vector3.zero;

        public event SplineReachHandler onEndReached;
        public event SplineReachHandler onBeginningReached;

        [SerializeField]
        [HideInInspector]
        Vector3 lastPosition = Vector3.zero;

        protected override void Reset()
        {
            base.Reset();
            _projectTarget = transform;
        }

        protected override Transform GetTransform()
        {
            if (targetObject == null) return null;
            return targetObject.transform;
        }

        protected override Rigidbody GetRigidbody()
        {
            if (targetObject == null) return null;
            return targetObject.GetComponent<Rigidbody>();
        }

        protected override Rigidbody2D GetRigidbody2D()
        {
            if (targetObject == null) return null;
            return targetObject.GetComponent<Rigidbody2D>();
        }


        protected override void LateRun()
        {
            base.LateRun();
            if (autoProject)
            {
                if (projectTarget && lastPosition != projectTarget.position)
                {
                    lastPosition = projectTarget.position;
                    CalculateProjection();
                }
            }
         }

        protected override void PostBuild()
        {
            base.PostBuild();
            CalculateProjection();
        }

        protected override void OnSplineChanged()
        {
            if (spline != null)
            {
                if (_mode == Mode.Accurate)
                {
                    spline.Project(_projectTarget.position, ref _result, clipFrom, clipTo, SplineComputer.EvaluateMode.Calculate, subdivide);
                } 
                else
                {
                    spline.Project(_projectTarget.position, ref _result, clipFrom, clipTo);
                }
                _result.percent = ClipPercent(_result.percent);
            }
        }


        private void Project()
        {
            if (_mode == Mode.Accurate && spline != null)
            {
                spline.Project(_projectTarget.position, ref _result, clipFrom, clipTo, SplineComputer.EvaluateMode.Calculate, subdivide);
                _result.percent = ClipPercent(_result.percent);
            }
            else
            {
                Project(_projectTarget.position, ref _result);
            }
        }

        public void CalculateProjection()
        {
            if (_projectTarget == null) return;
            double lastPercent = _result.percent;
            Project();

            if (onBeginningReached != null && _result.percent <= clipFrom)
            {
                if (!Mathf.Approximately((float)lastPercent, (float)_result.percent))
                {
                    onBeginningReached();
                    if (samplesAreLooped)
                    {
                        CheckTriggers(lastPercent, 0.0);
                        CheckNodes(lastPercent, 0.0);
                        lastPercent = 1.0;
                    }
                }
            }
            else if (onEndReached != null && _result.percent >= clipTo)
            {
                if (!Mathf.Approximately((float)lastPercent, (float)_result.percent))
                {
                    onEndReached();
                    if (samplesAreLooped)
                    {
                        CheckTriggers(lastPercent, 1.0);
                        CheckNodes(lastPercent, 1.0);
                        lastPercent = 0.0;
                    }
                }
            }

            CheckTriggers(lastPercent, _result.percent);
            CheckNodes(lastPercent, _result.percent);
            

            if (targetObject != null)
            {
                ApplyMotion();
            }

            InvokeTriggers();
            InvokeNodes();
            lastPosition = projectTarget.position;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineProjector.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineRenderer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bf69cfa06c48dba428c5c4d626d57ab7
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using Dreamteck.Splines;

namespace Dreamteck.Splines
{
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Dreamteck/Splines/Users/Spline Renderer")]
    [ExecuteInEditMode]
    public class SplineRenderer : MeshGenerator
    {
        public int slices
        {
            get { return _slices; }
            set
            {
                if (value != _slices)
                {
                    if (value < 1) value = 1;
                    _slices = value;
                    Rebuild();
                }
            }
        }
        [HideInInspector]
        public bool autoOrient = true;
        [HideInInspector]
        public int updateFrameInterval = 0;
        [SerializeField]
        [HideInInspector]
        private int _slices = 1;

        private int _currentFrame = 0;
        private Vector3 _vertexDirection = Vector3.up;
        private bool _orthographic = false;
        private bool _init = false;

        void Start()
        {
            if (Camera.current != null)
            {
                _orthographic = Camera.current.orthographic;
            } 
            else if (Camera.main != null)
            {
                _orthographic = Camera.main.orthographic;
            }

            CreateMesh();
        }

        protected override void LateRun()
        {
            if (updateFrameInterval > 0)
            {
                _currentFrame++;
                if (_currentFrame > updateFrameInterval) _currentFrame = 0;
            }
        }

        protected override void BuildMesh()
        {
            base.BuildMesh();
            GenerateVertices(_vertexDirection, _orthographic);
            MeshUtility.GeneratePlaneTriangles(ref _tsMesh.triangles, _slices, sampleCount, false, 0, 0);
        }

        public void RenderWithCamera(Camera cam)
        {
            _orthographic = cam.orthographic;
            if (_orthographic)
            {
                _vertexDirection = -cam.transform.forward;
            }
            else
            {
                _vertexDirection = cam.transform.position;
            }
            BuildMesh();
            WriteMesh();
        }

        void OnWillRenderObject()
        {
            if (!autoOrient) return;
            if (updateFrameInterval > 0)
            {
                if (_currentFrame != 0) return;
            }

            if (!Application.isPlaying)
            {
                if (!_init)
                {
                    Awake();
                    _init = true;
                }
            }

            if (Camera.current != null)
            {
                RenderWithCamera(Camera.current);
            } 
            else if(Camera.main)
            {
                RenderWithCamera(Camera.main);
            }
        }

        public void GenerateVertices(Vector3 vertexDirection, bool orthoGraphic)
        {
            AllocateMesh((_slices + 1) * sampleCount, _slices * (sampleCount - 1) * 6);
            int vertexIndex = 0;
            ResetUVDistance();
            bool hasOffset = offset != Vector3.zero;
            for (int i = 0; i < sampleCount; i++)
            {
                GetSample(i, ref evalResult);
                Vector3 center = evalResult.position;
                if (hasOffset) center += offset.x * -Vector3.Cross(evalResult.forward, evalResult.up) + offset.y * evalResult.up + offset.z * evalResult.forward;
                Vector3 vertexNormal;
                if(orthoGraphic) vertexNormal = vertexDirection;
                else vertexNormal = (vertexDirection - center).normalized;
                Vector3 vertexRight = Vector3.Cross(evalResult.forward, vertexNormal).normalized;
                if (uvMode == UVMode.UniformClamp || uvMode == UVMode.UniformClip) AddUVDistance(i);
                Color vertexColor = evalResult.color * color;
                for (int n = 0; n < _slices + 1; n++)
                {
                    float slicePercent = ((float)n / _slices);
                    _tsMesh.vertices[vertexIndex] = center - vertexRight * evalResult.size * 0.5f * size + vertexRight * evalResult.size * slicePercent * size;
                    CalculateUVs(evalResult.percent, slicePercent);
                    _tsMesh.uv[vertexIndex] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(uvRotation + 180f, Vector3.forward) * (Vector2.one * 0.5f - __uvs));
                    _tsMesh.normals[vertexIndex] = vertexNormal;
                    _tsMesh.colors[vertexIndex] = vertexColor;
                    vertexIndex++;
                }
            }
        }


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineRenderer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineTracer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 868482a8001bf104dbe8c2415d018860
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines
{
    public class SplineTracer : SplineUser
    {
        public class NodeConnection
        {
            public Node node;
            public int point = 0;

            public NodeConnection(Node node, int point)
            {
                this.node = node;
                this.point = point;
            }
        }

        public enum PhysicsMode { Transform, Rigidbody, Rigidbody2D }
        public PhysicsMode physicsMode
        {
            get { return _physicsMode; }
            set
            {
                _physicsMode = value;
                RefreshTargets();
            }
        }

        public TransformModule motion
        {
            get
            {
                if (_motion == null) _motion = new TransformModule();
                return _motion;
            }
        }

        /// <summary>
        /// Returns the unmodified result from the evaluation
        /// </summary>
        public SplineSample result
        {
            get { return _result; }
        }

        public bool dontLerpDirection
        {
            get { return _dontLerpDirection; }
            set
            {
                if (value != _dontLerpDirection)
                {
                    _dontLerpDirection = value;
                    ApplyMotion();
                }
            }
        }

        public virtual Spline.Direction direction
        {
            get { return _direction; }
            set
            {
                if (value != _direction)
                {
                    _direction = value;
                    ApplyMotion();
                }
            }
        }

        [HideInInspector]
        public bool applyDirectionRotation = true;
        [HideInInspector]
        public bool useTriggers = false;
        [HideInInspector]
        public int triggerGroup = 0;
        [SerializeField]
        [HideInInspector]
        protected Spline.Direction _direction = Spline.Direction.Forward;

        [SerializeField]
        [HideInInspector]
        protected bool _dontLerpDirection = false;

        [SerializeField]
        [HideInInspector]
        protected PhysicsMode _physicsMode = PhysicsMode.Transform;
        [SerializeField]
        [HideInInspector]
        protected TransformModule _motion = null;


        [SerializeField]
        [HideInInspector]
        protected Rigidbody targetRigidbody = null;
        [SerializeField]
        [HideInInspector]
        protected Rigidbody2D targetRigidbody2D = null;
        [SerializeField]
        [HideInInspector]
        protected Transform targetTransform = null;
        [SerializeField]
        [HideInInspector]
        protected SplineSample _result = new SplineSample();

        public delegate void JunctionHandler(List<NodeConnection> passed);

        public event JunctionHandler onNode;
        public event EmptySplineHandler onMotionApplied;

        private SplineTrigger[] triggerInvokeQueue = new SplineTrigger[0];
        private List<NodeConnection> nodeConnectionQueue = new List<NodeConnection>();
        private int addTriggerIndex = 0;

        private const double MIN_DELTA = 0.000001;

#if UNITY_EDITOR
        public override void EditorAwake()
        {
            base.EditorAwake();
            RefreshTargets();
            ApplyMotion();
        }
#endif 

        protected override void Awake()
        {
            base.Awake();
            RefreshTargets();
        }

        protected virtual void Start()
        {

        }

        public virtual void SetPercent(double percent, bool checkTriggers = false, bool handleJunctions = false)
        {
            if (sampleCount == 0) return;
            double lastPercent = _result.percent;
            Evaluate(percent, ref _result);
            ApplyMotion();
            if (checkTriggers)
            {
                CheckTriggers(lastPercent, percent);
                InvokeTriggers();
            }
            if (handleJunctions)
            {
                CheckNodes(lastPercent, percent);
            }
        }

        public double GetPercent()
        {
            return _result.percent;
        }

        public virtual void SetDistance(float distance, bool checkTriggers = false, bool handleJunctions = false)
        {
            double lastPercent = _result.percent;
            Evaluate(Travel(0.0, distance, Spline.Direction.Forward), ref _result);
            ApplyMotion();
            if (checkTriggers)
            {
                CheckTriggers(lastPercent, _result.percent);
                InvokeTriggers();
            }
            if (handleJunctions)
            {
                CheckNodes(lastPercent, _result.percent);
            }
        }

        protected virtual Rigidbody GetRigidbody()
        {
            return GetComponent<Rigidbody>();
        }

        protected virtual Rigidbody2D GetRigidbody2D()
        {
            return GetComponent<Rigidbody2D>();
        }

        protected virtual Transform GetTransform()
        {
            return transform;
        }

        protected void ApplyMotion()
        {
            if (sampleCount == 0) return;
            if (_dontLerpDirection)
            {
                double unclippedPercent = UnclipPercent(_result.percent);
                int index;
                double lerp;
                spline.GetSamplingValues(unclippedPercent, out index, out lerp);
                _result.forward = spline[index].forward;
                _result.up = spline[index].up;
            }

            motion.targetUser = this;
            motion.splineResult = _result;
            if (applyDirectionRotation) motion.direction = _direction;
            else motion.direction = Spline.Direction.Forward;

            switch (_physicsMode)
            {
                case PhysicsMode.Transform:
                    if (targetTransform == null) RefreshTargets();
                    if (targetTransform == null) return;
                    motion.ApplyTransform(targetTransform);
                    if (onMotionApplied != null) onMotionApplied();
                    break;
                case PhysicsMode.Rigidbody:
                    if (targetRigidbody == null)
                    {
                        RefreshTargets();
                        if (targetRigidbody == null)  throw new MissingComponentException("There is no Rigidbody attached to " + name + " but the Physics mode is set to use one.");
                    }
                    motion.ApplyRigidbody(targetRigidbody);
                    if (onMotionApplied != null) onMotionApplied();
                    break;
                case PhysicsMode.Rigidbody2D:
                    if (targetRigidbody2D == null)
                    {
                        RefreshTargets();
                        if (targetRigidbody2D == null) throw new MissingComponentException("There is no Rigidbody2D attached to " + name + " but the Physics mode is set to use one.");
                    }
                    motion.ApplyRigidbody2D(targetRigidbody2D);
                    if (onMotionApplied != null) onMotionApplied();
                    break;
            }
        }

        protected void CheckNodes(double from, double to)
        {
#if UNITY_EDITOR
            if (!Application.isPlaying) return;
#endif
            if (onNode == null) return;
            if (from == to) return;
            UnclipPercent(ref from);
            UnclipPercent(ref to);
            Spline.FormatFromTo(ref from, ref to, true);
            int fromPoint, toPoint;
            fromPoint = spline.PercentToPointIndex(from, _direction);
            toPoint = spline.PercentToPointIndex(to, _direction);

            if (fromPoint != toPoint)
            {
                if (_direction == Spline.Direction.Forward)
                {
                    for (int i = fromPoint + 1; i <= toPoint; i++)
                    {
                        NodeConnection junction = GetJunction(i);
                        if (junction != null) nodeConnectionQueue.Add(junction);
                    }
                }
                else
                {
                    for (int i = toPoint - 1; i >= fromPoint; i--)
                    {
                        NodeConnection junction = GetJunction(i);
                        if (junction != null) nodeConnectionQueue.Add(junction);
                    }
                }
            }
            else if (from < MIN_DELTA && to > from)
            {
                NodeConnection junction = GetJunction(0);
                if (junction != null) nodeConnectionQueue.Add(junction);
            }
            else if (to > 1.0 - MIN_DELTA && from < to)
            {
                int pointCount = spline.pointCount - 1;
                if (spline.isClosed)
                {
                    pointCount = spline.pointCount;
                }
                NodeConnection junction = GetJunction(pointCount);
                if (junction != null) nodeConnectionQueue.Add(junction);
            }
        }

        protected void InvokeNodes()
        {
            if(nodeConnectionQueue.Count > 0)
            {
                onNode(nodeConnectionQueue);
                nodeConnectionQueue.Clear();
            }
        }

        protected void CheckTriggers(double from, double to)
        {
#if UNITY_EDITOR
            if (!Application.isPlaying) return;
#endif
            if (!useTriggers) return;
            if (from == to) return;
            UnclipPercent(ref from);
            UnclipPercent(ref to);
            if (triggerGroup < 0 || triggerGroup >= spline.triggerGroups.Length) return;
            for (int i = 0; i < spline.triggerGroups[triggerGroup].triggers.Length; i++)
            {
                if (spline.triggerGroups[triggerGroup].triggers[i] == null) continue;
                if (spline.triggerGroups[triggerGroup].triggers[i].Check(from, to)) AddTriggerToQueue(spline.triggerGroups[triggerGroup].triggers[i]);
            }
        }

        NodeConnection GetJunction(int pointIndex)
        {
            Node node = spline.GetNode(pointIndex);
            if (node == null) return null;
            return new NodeConnection(node, pointIndex);
        }

        protected void InvokeTriggers()
        {
#if UNITY_EDITOR
            if (!Application.isPlaying) return;
#endif
            for (int i = 0; i < addTriggerIndex; i++)
            {
                if (triggerInvokeQueue[i] != null)
                {
                    triggerInvokeQueue[i].Invoke(this);
                }
            }
            addTriggerIndex = 0;
        }

        protected void RefreshTargets()
        {
            switch (_physicsMode)
            {
                case PhysicsMode.Transform:
                    targetTransform = GetTransform();
                    break;
                case PhysicsMode.Rigidbody:
                    targetRigidbody = GetRigidbody();
                    break;
                case PhysicsMode.Rigidbody2D:
                    targetRigidbody2D = GetRigidbody2D();
                    break;
            }
        }

        private void AddTriggerToQueue(SplineTrigger trigger)
        {
            if (addTriggerIndex >= triggerInvokeQueue.Length)
            {
                SplineTrigger[] newQueue = new SplineTrigger[triggerInvokeQueue.Length + spline.triggerGroups[triggerGroup].triggers.Length];
                triggerInvokeQueue.CopyTo(newQueue, 0);
                triggerInvokeQueue = newQueue;
            }
            triggerInvokeQueue[addTriggerIndex] = trigger;
            addTriggerIndex++;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineTracer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineUser.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8abf799a17be8264daa9759d95e6de99
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;

namespace Dreamteck.Splines {
    [ExecuteInEditMode]
    public class SplineUser : MonoBehaviour, ISerializationCallbackReceiver, ISampleModifier
    {
        public enum UpdateMethod { Update, FixedUpdate, LateUpdate }
        [HideInInspector]
        public UpdateMethod updateMethod = UpdateMethod.Update;

        public SplineComputer spline
        {
            get {
                return _spline;
            }
            set
            {
                if (value != _spline)
                {
                    if (_spline != null)
                    {
                        _spline.Unsubscribe(this);
                    }
                    _spline = value;
                    if (_spline != null)
                    {
                        _spline.Subscribe(this);
                        Rebuild();
                    }
                    OnSplineChanged();
                }
            }
        }

        public double clipFrom
        {
            get
            {
                return _clipFrom;
            }
            set
            {
                if (value != _clipFrom)
                {
                    animClipFrom = (float)_clipFrom;
                    _clipFrom = DMath.Clamp01(value);
                    if (_clipFrom > _clipTo)
                    {
                        if (!_spline.isClosed) _clipTo = _clipFrom;
                    }
                    getSamples = true;
                    Rebuild();
                }
            }
        }

        public double clipTo
        {
            get
            {
                return _clipTo;
            }
            set
            {

                if (value != _clipTo)
                {
                    animClipTo = (float)_clipTo;
                    _clipTo = DMath.Clamp01(value);
                    if (_clipTo < _clipFrom)
                    {
                        if (!_spline.isClosed) _clipFrom = _clipTo;
                    }
                    getSamples = true;
                    Rebuild();
                }
            }
        }

        public bool autoUpdate
        {
            get
            {
                return _autoUpdate;
            }
            set
            {
                if (value != _autoUpdate)
                {
                    _autoUpdate = value;
                    if (value) Rebuild();
                }
            }
        }

        public bool loopSamples
        {
            get
            {
                return _loopSamples;
            }
            set
            {
                if (value != _loopSamples)
                {
                    _loopSamples = value;
                    if(!_loopSamples && _clipTo < _clipFrom)
                    {
                        double temp = _clipTo;
                        _clipTo = _clipFrom;
                        _clipFrom = temp;
                    }
                    Rebuild();
                }
            }
        }

        //The percent of the spline that we're traversing
        public double span
        {
            get
            {
                if (samplesAreLooped) return (1.0 - _clipFrom) + _clipTo;
                return _clipTo - _clipFrom;
            }
        }

        public bool samplesAreLooped
        {
            get
            {
                return _loopSamples && _clipFrom >= _clipTo;
            }
        }

        public RotationModifier rotationModifier
        {
            get
            {
                return _rotationModifier;
            }
        }

        public OffsetModifier offsetModifier
        {
            get
            {
                return _offsetModifier;
            }
        }

        public ColorModifier colorModifier
        {
            get
            {
                return _colorModifier;
            }
        }

        public SizeModifier sizeModifier
        {
            get
            {
                return _sizeModifier;
            }
        }

        //Serialized values
        [SerializeField]
        [HideInInspector]
        private SplineComputer _spline;
        [SerializeField]
        [HideInInspector]
        private bool _autoUpdate = true;
        [SerializeField]
        [HideInInspector]
        protected RotationModifier _rotationModifier = new RotationModifier();
        [SerializeField]
        [HideInInspector]
        protected OffsetModifier _offsetModifier = new OffsetModifier();
        [SerializeField]
        [HideInInspector]
        protected ColorModifier _colorModifier = new ColorModifier();
        [SerializeField]
        [HideInInspector]
        protected SizeModifier _sizeModifier = new SizeModifier();
        [SerializeField]
        [HideInInspector]
        private SplineSample _clipFromSample = new SplineSample(), _clipToSample = new SplineSample();

        [SerializeField]
        [HideInInspector]
        private bool _loopSamples = false;
        [SerializeField]
        [HideInInspector]
        private double _clipFrom = 0.0;
        [SerializeField]
        [HideInInspector]
        private double _clipTo = 1.0;

        //float values used for making animations
        [SerializeField]
        [HideInInspector]
        private float animClipFrom = 0f;
        [SerializeField]
        [HideInInspector]
        private float animClipTo = 1f;

        private SampleCollection _sampleCollection = new SampleCollection();
        private bool rebuild = false, getSamples = false, postBuild = false;
        private Transform _trs = null;
        private bool _hasTransform = false;
        private SplineSample _workSample = new SplineSample();
#if UNITY_EDITOR
        private bool _isPlaying = false;
        protected bool isPlaying => _isPlaying;
#endif

        protected Transform trs
        {
            get {  return _trs;  }
        }
        protected bool hasTransform
        {
            get { return _hasTransform; }
        }
        public int sampleCount
        {
            get { return _sampleCount; }
        }

        private int _sampleCount = 0, _startSampleIndex = 0;
        /// <summary>
        /// Use this to work with the Evaluate and Project methods
        /// </summary>
        protected SplineSample evalResult = new SplineSample();

        //Threading values
        [HideInInspector]
        public volatile bool multithreaded = false;
        [HideInInspector]
        public bool buildOnAwake = true;
        [HideInInspector]
        public bool buildOnEnable = false;

        public event EmptySplineHandler onPostBuild;

#if UNITY_EDITOR
        public virtual void EditorAwake()
        {

        }
#endif

        protected virtual void Awake() {
#if UNITY_EDITOR
            _isPlaying = Application.isPlaying;
            if (!_isPlaying)
            {
                if (spline != null)
                {
                    if (!_spline.IsSubscribed(this))
                    {
                        _spline.Subscribe(this);
                        UnityEditor.EditorUtility.SetDirty(spline);
                    }
                }
            }
#endif

            CacheTransform();
            if (buildOnAwake && Application.isPlaying)
            {
                RebuildImmediate();
            } else
            {
                GetSamples();
            }

#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                RebuildImmediate();
            }
#endif
        }

        protected void CacheTransform()
        {
            _trs = transform;
            _hasTransform = true;
        }

        protected virtual void Reset()
        {
#if UNITY_EDITOR
            spline = GetComponent<SplineComputer>();
            Awake();
#endif
        }

        protected virtual void OnEnable()
        {
#if UNITY_EDITOR
            if (!_isPlaying || buildOnEnable)
            {
                RebuildImmediate();
            }
#else
            if (buildOnEnable){
                RebuildImmediate();
            }
#endif
        }

        protected virtual void OnDisable()
        {
        }

        protected virtual void OnDestroy()
        {
#if UNITY_EDITOR
            if (!_isPlaying && spline != null)
            {
                _spline.Unsubscribe(this); //Unsubscribe if DestroyImmediate is called
            }
#endif
        }

        protected virtual void OnDidApplyAnimationProperties()
        {
            bool clip = false;
            if (_clipFrom != animClipFrom || _clipTo != animClipTo) clip = true;
            _clipFrom = animClipFrom;
            _clipTo = animClipTo;
            Rebuild();
            if (clip) GetSamples();
        }

        /// <summary>
        /// Gets the sample at the given index without modifications
        /// </summary>
        /// <param name="index">Sample index</param>
        /// <returns></returns>
        public void GetSampleRaw(int index, ref SplineSample sample)
        {
            if (index == 0)
            {
                sample.FastCopy(ref _clipFromSample);
                return;
            }
            if (index == _sampleCount - 1)
            {
                sample.FastCopy(ref _clipToSample);
                return;
            }

            ClampLoopSampleIndex(ref index);
            sample.FastCopy(ref _sampleCollection.samples[index]);
        }

        public double GetSamplePercent(int index)
        {
            if (index == 0)
            {
                return _clipFromSample.percent;
            }
            if (index == _sampleCount - 1)
            {
                return _clipToSample.percent;
            }

            ClampLoopSampleIndex(ref index);
            return _sampleCollection.samples[index].percent;
        }

        private void ClampLoopSampleIndex(ref int index)
        {
            if (index >= _sampleCount)
            {
                index = _sampleCount - 1;
            }

            if (samplesAreLooped)
            {
                int start;
                double lerp;
                _sampleCollection.GetSamplingValues(clipFrom, out start, out lerp);

                index = start + index;
                if (index >= _sampleCollection.length)
                {
                    index -= _sampleCollection.length;
                }
            }
            else
            {
                index = _startSampleIndex + index;
            }
        }


        /// <summary>
        /// Returns the sample at the given index with modifiers applied
        /// </summary>
        /// <param name="index">Sample index</param>
        /// <param name="target">Sample to write to</param>
        public void GetSample(int index, ref SplineSample target)
        {
            GetSampleRaw(index, ref target);
            ApplySampleModifiers(ref target);
        }

        /// <summary>
        /// Returns the sample at the given index with modifiers applied and
        /// applies compensation to the size parameter based on the angle between the samples
        /// </summary>
        public void GetSampleWithAngleCompensation(int index, ref SplineSample target)
        {
            GetSampleRaw(index, ref target);
            ApplySampleModifiers(ref target);
            if (index > 0 && index < sampleCount - 1)
            {
                GetSampleRaw(index - 1, ref _workSample);
                ApplySampleModifiers(ref target);
                Vector3 prev = target.position - _workSample.position;
                GetSampleRaw(index + 1, ref _workSample);
                ApplySampleModifiers(ref target);
                Vector3 next = _workSample.position - target.position;
                target.size *= 1 / Mathf.Sqrt(Vector3.Dot(prev.normalized, next.normalized) * 0.5f + 0.5f);
            }
        }


        /// <summary>
        /// Rebuild the SplineUser. This will cause Build and Build_MT to be called.
        /// </summary>
        /// <param name="sampleComputer">Should the SplineUser sample the SplineComputer</param>
        public virtual void Rebuild()
        {
#if UNITY_EDITOR
            if (!_hasTransform)
            {
                CacheTransform();
            }

            //If it's the editor and it's not playing, then rebuild immediate
            if (_isPlaying)
            {
                if (!autoUpdate) return;
                rebuild = getSamples = true;
            }
            else
            {
                RebuildImmediate();
            }
#else
             if (!autoUpdate) return;
             rebuild = getSamples = true;
#endif
        }

        /// <summary>
        /// Rebuild the SplineUser immediate. This method will call sample samples and call Build as soon as it's called even if the component is disabled.
        /// </summary>
        /// <param name="sampleComputer">Should the SplineUser sample the SplineComputer</param>
        public virtual void RebuildImmediate()
        {
#if UNITY_EDITOR
            if (!_hasTransform)
            {
                CacheTransform();
            }
#endif
            try
            {
                GetSamples();
                Build();
                PostBuild();
            }
            catch (System.Exception ex)
            {
                Debug.LogError(ex.Message);
            }
            rebuild = false;
            getSamples = false;
        }

        private void Update()
        {
            if (updateMethod == UpdateMethod.Update)
            {
                Run();
                RunUpdate();
                LateRun();
            }
        }

        private void LateUpdate()
        {
            if (updateMethod == UpdateMethod.LateUpdate)
            {
                Run();
                RunUpdate();
                LateRun();
            }
#if UNITY_EDITOR
            if(!_isPlaying && updateMethod == UpdateMethod.FixedUpdate)
            {
                Run();
                RunUpdate();
                LateRun();
            }
#endif
        }

        private void FixedUpdate()
        {
            if (updateMethod == UpdateMethod.FixedUpdate)
            {
                Run();
                RunUpdate();
                LateRun();
            }
        }

        //Update logic for handling threads and rebuilding
        private void RunUpdate()
        {
#if UNITY_EDITOR
            if (!_isPlaying) return;
#endif
            //Handle rebuilding
            if (rebuild)
            {
                if (multithreaded)
                {
                    if (getSamples) SplineThreading.Run(ResampleAndBuildThreaded);
                    else SplineThreading.Run(BuildThreaded);
                }
                else
                {
                    if (getSamples || _spline.sampleMode == SplineComputer.SampleMode.Optimized) GetSamples();
                    Build();
                    postBuild = true;
                }
                rebuild = false;
            }
            if (postBuild)
            {
                PostBuild();
                EmptySplineHandler postBuildHandler = onPostBuild;
                if(postBuildHandler != null)
                {
                    postBuildHandler();
                }
                postBuild = false;
            }
        }

        void BuildThreaded()
        {
            while (postBuild)
            {
                //Wait if the main thread is still running post build operations
            }
            Build();
            postBuild = true;
        }

        private void ResampleAndBuildThreaded()
        {
            while (postBuild)
            {
                //Wait if the main thread is still running post build operations
            }
            GetSamples();
            Build();
            postBuild = true;
        }

        /// Code to run every Update/FixedUpdate/LateUpdate before any building has taken place
        protected virtual void Run()
        {

        }

        /// Code to run every Update/FixedUpdate/LateUpdate after any rabuilding has taken place
        protected virtual void LateRun()
        {

        }

        //Used for calculations. Called on the main or the worker thread.
        protected virtual void Build()
        {
        }

        //Called on the Main thread only - used for applying the results from Build
        protected virtual void PostBuild()
        {
        }

        protected virtual void OnSplineChanged()
        {

        }

        /// <summary>
        /// Applies the SplineUser modifiers to the provided sample
        /// </summary>
        /// <param name="sample">The sample to modify</param>
        public void ApplySampleModifiers(ref SplineSample sample)
        {
            ApplyModifier(_offsetModifier, ref sample);
            ApplyModifier(_rotationModifier, ref sample);
            ApplyModifier(_colorModifier, ref sample);
            ApplyModifier(_sizeModifier, ref sample);
        }

        public Vector3 GetModifiedSamplePosition(ref SplineSample sample)
        {
            if (_offsetModifier.hasKeys)
            {
                Vector2 offset = _offsetModifier.Evaluate(sample.percent);
                return sample.position + sample.right * offset.x + sample.up * offset.y; ;
            }
            return sample.position;
        }

        private void ApplyModifier(SplineSampleModifier modifier, ref SplineSample sample)
        {
            if (!modifier.hasKeys) return;
            if (modifier.useClippedPercent)
            {
                ClipPercent(ref sample.percent);
            }

            modifier.Apply(ref sample);

            if (modifier.useClippedPercent)
            {
                UnclipPercent(ref sample.percent);
            }
        }

        /// <summary>
        /// Sets the clip range of the SplineUser. Same as setting clipFrom and clipTo
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        public void SetClipRange(double from, double to)
        {
            if (!_spline.isClosed && to < from) to = from;
            _clipFrom = DMath.Clamp01(from);
            _clipTo = DMath.Clamp01(to);
            GetSamples();
            Rebuild();
        }

        /// <summary>
        /// Gets the clipped samples defined by clipFrom and clipTo
        /// </summary>
        private void GetSamples()
        {
            getSamples = false;
            if (spline == null)
            {
                _sampleCollection.samples = new SplineSample[0];
                _sampleCount = 0;
                return;
            }

            _spline.GetSamples(_sampleCollection);

            if (_sampleCollection.length == 0)
            {
                _sampleCount = 0;
                return;
            }

            if (_clipFrom != 0.0)
            {
                _sampleCollection.Evaluate(clipFrom, ref _clipFromSample);
            } else
            {
                _clipFromSample = _sampleCollection.samples[0];
            }

            if(_clipTo != 1.0)
            {
                _sampleCollection.Evaluate(_clipTo, ref _clipToSample);
            } else
            {
                _clipToSample = _sampleCollection.samples[_sampleCollection.length - 1];
            }

            int start, end;
            _sampleCount = _sampleCollection.GetClippedSampleCount(_clipFrom, _clipTo, out start, out end);
            double lerp;
            _sampleCollection.GetSamplingValues(_clipFrom, out _startSampleIndex, out lerp);
        }

        /// <summary>
        /// Takes a regular 0-1 percent mapped to the start and end of the spline and maps it to the clipFrom and clipTo valies. Useful for working with clipped samples
        /// </summary>
        /// <param name="percent"></param>
        /// <returns></returns>
        public double ClipPercent(double percent)
        {
            ClipPercent(ref percent);
            return percent;
        }

        /// <summary>
        /// Takes a regular 0-1 percent mapped to the start and end of the spline and maps it to the clipFrom and clipTo valies. Useful for working with clipped samples
        /// </summary>
        /// <param name="percent"></param>
        /// <returns></returns>
        public void ClipPercent(ref double percent)
        {
            if (_sampleCollection.length == 0)
            {
                percent = 0.0;
                return;
            }

            if (samplesAreLooped)
            {
                if (percent >= clipFrom && percent <= 1.0) { percent = DMath.InverseLerp(clipFrom, clipFrom + span, percent); }//If in the range clipFrom - 1.0
                else if (percent <= clipTo) { percent = DMath.InverseLerp(clipTo - span, clipTo, percent); } //if in the range 0.0 - clipTo
                else
                {
                    //Find the nearest clip start
                    if (DMath.InverseLerp(clipTo, clipFrom, percent) < 0.5) percent = 1.0;
                    else percent = 0.0;
                }
            }
            else percent = DMath.InverseLerp(clipFrom, clipTo, percent);
        }

        public double UnclipPercent(double percent)
        {
            UnclipPercent(ref percent);
            return percent;
        }

        public void UnclipPercent(ref double percent)
        {
            if (samplesAreLooped)
            {
                if (span <= 0.00001)
                {
                    percent = clipFrom;
                    return;
                }
                double fromRatio = (1.0 - clipFrom) / span;
                if (percent < fromRatio)
                {
                    percent = DMath.Lerp(clipFrom, 1.0, percent / fromRatio);
                }
                else if (clipTo == 0.0)
                {
                    percent = 0.0;
                    return;
                }
                else percent = DMath.Lerp(0.0, clipTo, (percent - fromRatio) / (clipTo / span));
            }
            else
            {
                if (percent == 0.0)
                {
                    percent = clipFrom;
                    return;
                }
                else if (percent == 1.0)
                {
                    percent = clipTo;
                    return;
                }

                percent = DMath.Lerp(clipFrom, clipTo, percent);
            }
            percent = DMath.Clamp01(percent);
        }

        private int GetSampleIndex(double percent)
        {
            int index;
            double lerp;
            _sampleCollection.GetSamplingValues(UnclipPercent(percent), out index, out lerp);
            return index;
        }

        public Vector3 EvaluatePosition(double percent)
        {
            return _sampleCollection.EvaluatePosition(UnclipPercent(percent));
        }

        public void Evaluate(double percent, ref SplineSample result)
        {
            _sampleCollection.Evaluate(UnclipPercent(percent), ref result);
            result.percent = DMath.Clamp01(percent);
            ApplySampleModifiers(ref result);
        }

        public SplineSample Evaluate(double percent)
        {
            SplineSample result = new SplineSample();
            Evaluate(percent, ref result);
            result.percent = DMath.Clamp01(percent);
            ApplySampleModifiers(ref result);
            return result;
        }

        public void Evaluate(ref SplineSample[] results, double from = 0.0, double to = 1.0)
        {
            _sampleCollection.Evaluate(ref results, UnclipPercent(from), UnclipPercent(to));
            for (int i = 0; i < results.Length; i++)
            {
                ClipPercent(ref results[i].percent);
                ApplySampleModifiers(ref results[i]);
            }
        }

        public void EvaluatePositions(ref Vector3[] positions, double from = 0.0, double to = 1.0)
        {
            _sampleCollection.EvaluatePositions(ref positions, UnclipPercent(from), UnclipPercent(to));
        }

        public double Travel(double start, float distance, Spline.Direction direction, out float moved)
        {
            moved = 0f;
            if (direction == Spline.Direction.Forward && start >= 1.0)
            {
                return 1.0;
            }
            else if (direction == Spline.Direction.Backward && start <= 0.0)
            {
                return 0.0;
            }
            if (distance == 0f)
            {
                return DMath.Clamp01(start);
            }

            double result = _sampleCollection.Travel(UnclipPercent(start), distance, direction, out moved, clipFrom, clipTo);
            double clippedResult = ClipPercent(result);

            if (result > clipTo)
            {
                moved -= _sampleCollection.CalculateLength(clipTo, result);
            }
            else if (result < clipFrom)
            {
                moved -= _sampleCollection.CalculateLength(result, clipFrom);
            }

            return clippedResult;
        }

        public double Travel(double start, float distance, Spline.Direction direction = Spline.Direction.Forward)
        {
            float moved;
            return Travel(start, distance, direction, out moved);
        }

        public double TravelWithOffset(double start, float distance, Spline.Direction direction, Vector3 offset, out float moved)
        {
            moved = 0f;
            if (direction == Spline.Direction.Forward && start >= 1.0)
            {
                return 1.0;
            }
            else if (direction == Spline.Direction.Backward && start <= 0.0)
            {
                return 0.0;
            }
            if (distance == 0f)
            {
                return DMath.Clamp01(start);
            }
            double result = _sampleCollection.TravelWithOffset(UnclipPercent(start), distance, direction, offset, out moved, clipFrom, clipTo);
            return ClipPercent(result);
        }

        public virtual void Project(Vector3 position, ref SplineSample result, double from = 0.0, double to = 1.0)
        {
            if (_spline == null) return;
            _sampleCollection.Project(position, _spline.pointCount, ref result, UnclipPercent(from), UnclipPercent(to), this);
            ClipPercent(ref result.percent);
        }

        public float CalculateLength(double from = 0.0, double to = 1.0, bool preventInvert = true)
        {
            return _sampleCollection.CalculateLength(UnclipPercent(from), UnclipPercent(to), preventInvert);
        }

        public float CalculateLengthWithOffset(Vector3 offset, double from = 0.0, double to = 1.0)
        {
            return _sampleCollection.CalculateLengthWithOffset(offset, UnclipPercent(from), UnclipPercent(to));
        }

        public virtual void OnBeforeSerialize()
        {
        }

        public virtual void OnAfterDeserialize()
        {
        }

        /// <summary>
        /// Returns the offset transformed by the sample
        /// </summary>
        /// <param name="sample">Source sample</param>
        /// <param name="localOffset">Local offset to apply</param>
        /// <returns></returns>
        protected static Vector3 TransformOffset(SplineSample sample, Vector3 localOffset)
        {
            return (sample.right * localOffset.x + sample.up * localOffset.y + sample.forward * localOffset.z) * sample.size;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SplineUser.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SurfaceGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ff5f5220af00e574287547dab664b9ab
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;

namespace Dreamteck.Splines
{
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Dreamteck/Splines/Users/Surface Generator")]
    public class SurfaceGenerator : MeshGenerator
    {
        public float expand
        {
            get { return _expand; }
            set
            {
                if (value != _expand)
                {
                    _expand = value;
                    Rebuild();
                }
            }
        }

        public float extrude
        {
            get { return _extrude; }
            set
            {
                if (value != _extrude)
                {
                    _extrude = value;
                    Rebuild();
                }
            }
        }

        public double extrudeClipFrom
        {
            get { return _extrudeFrom; }
            set
            {
                if (value != _extrudeFrom)
                {
                    _extrudeFrom = value;
                    Rebuild();
                }
            }
        }

        public double extrudeClipTo
        {
            get { return _extrudeTo; }
            set
            {
                if (value != _extrudeTo)
                {
                    _extrudeTo = value;
                    Rebuild();
                }
            }
        }

        public Vector2 sideUvScale
        {
            get { return _sideUvScale; }
            set
            {
                if (value != _sideUvScale)
                {
                    _sideUvScale = value;
                    Rebuild();
                }
                else
                {
                    _sideUvScale = value;
                }
            }
        }

        public Vector2 sideUvOffset
        {
            get { return _sideUvOffset; }
            set
            {
                if (value != _sideUvOffset)
                {
                    _sideUvOffset = value;
                    Rebuild();
                }
                else
                {
                    _sideUvOffset = value;
                }
            }
        }

        public float sideUvRotation
        {
            get { return _sideUvRotation; }
            set
            {
                if (value != _sideUvRotation)
                {
                    _sideUvRotation = value;
                    Rebuild();
                }
                else
                {
                    _sideUvRotation = value;
                }
            }
        }

        public SplineComputer extrudeSpline
        {
            get { return _extrudeSpline; }
            set
            {
                if (value != _extrudeSpline)
                {
                    if (_extrudeSpline != null)
                    {
                        _extrudeSpline.Unsubscribe(this);
                    }
                    _extrudeSpline = value;
                    if (value != null)
                    {
                        _extrudeSpline.Subscribe(this);
                    }
                    Rebuild();
                }
            }
        }

        public Vector3 extrudeOffset
        {
            get { return _extrudeOffset; }
            set { 
                if(value != _extrudeOffset)
                {
                    _extrudeOffset = value;
                    Rebuild();
                } 
            }
        }

        public bool uniformUvs
        {
            get { return _uniformUvs; }
            set
            {
                if (value != _uniformUvs)
                {
                    _uniformUvs = value;
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private float _expand = 0f;
        [SerializeField]
        [HideInInspector]
        private float _extrude = 0f;
        [SerializeField]
        [HideInInspector]
        private Vector2 _sideUvScale = Vector2.one;
        [SerializeField]
        [HideInInspector]
        private Vector2 _sideUvOffset = Vector2.zero;
        [SerializeField]
        [HideInInspector]
        private float _sideUvRotation = 0f;
        [SerializeField]
        [HideInInspector]
        private SplineComputer _extrudeSpline;
        [SerializeField]
        [HideInInspector]
        private Vector3 _extrudeOffset = Vector3.zero;
        [SerializeField]
        [HideInInspector]
        private SplineSample[] extrudeResults = new SplineSample[0];
        [SerializeField]
        [HideInInspector]
        private Vector3[] identityVertices = new Vector3[0];
        [SerializeField]
        [HideInInspector]
        private Vector3[] identityNormals = new Vector3[0];
        [SerializeField]
        [HideInInspector]
        private Vector2[] projectedVerts = new Vector2[0];
        [SerializeField]
        [HideInInspector]
        private int[] surfaceTris = new int[0];
        [SerializeField]
        [HideInInspector]
        private int[] wallTris = new int[0];

        [SerializeField]
        [HideInInspector]
        private double _extrudeFrom = 0.0;
        [SerializeField]
        [HideInInspector]
        private double _extrudeTo = 1.0;
        [SerializeField]
        [HideInInspector]
        private bool _uniformUvs = false;

        private Vector3 _trsRight = Vector3.right;
        private Vector3 _trsUp = Vector3.up;
        private Vector3 _trsForward = Vector3.forward;

        protected override string meshName => "Surface";

        protected override void Awake()
        {
            base.Awake();
            _trsRight = trs.right;
            _trsUp = trs.up;
            _trsForward = trs.forward;
        }

        protected override void BuildMesh()
        {
            if (spline.pointCount == 0) return;
            base.BuildMesh();
            Generate();
        }

        private void LateUpdate()
        {
            if (multithreaded && trs.hasChanged)
            {
                _trsRight = trs.right;
                _trsUp = trs.up;
                _trsForward = trs.forward;
            }
        }

        public void Generate()
        {
            if (!multithreaded)
            {
                _trsRight = trs.right;
                _trsUp = trs.up;
                _trsForward = trs.forward;
            }
            int surfaceVertexCount = sampleCount;
            if (spline.isClosed) surfaceVertexCount--;
            int vertexCount = surfaceVertexCount;
            bool pathExtrude = false;
            if (_extrudeSpline != null)
            {
                _extrudeSpline.Evaluate(ref extrudeResults, _extrudeFrom, _extrudeTo);
                pathExtrude = extrudeResults.Length > 0;
            } else if(extrudeResults.Length > 0)
            {
                extrudeResults = new SplineSample[0];
            }

            bool simpleExtrude = !pathExtrude && _extrude != 0f;

            if (pathExtrude)
            {
                vertexCount *= 2;
                vertexCount += sampleCount * extrudeResults.Length;
            }
            else if (simpleExtrude)
            {
                vertexCount *= 4;
                vertexCount += 2;
            }
            
            Vector3 center, normal;
            GetProjectedVertices(surfaceVertexCount, out center, out normal);

            bool clockwise = IsClockwise(projectedVerts);
            bool flipCap = false;
            bool flipSide = false;
            if (!clockwise) flipSide = !flipSide;
            if (simpleExtrude && _extrude < 0f)
            {
                flipCap = !flipCap;
                flipSide = !flipSide;
            }

            GenerateSurfaceTris(flipCap);
            int totalTrisCount = surfaceTris.Length;
            if (simpleExtrude)
            {
                totalTrisCount *= 2;
                totalTrisCount += 2 * sampleCount * 2 * 3;
            } else
            {
                totalTrisCount *= 2;
                totalTrisCount += extrudeResults .Length * sampleCount * 2 * 3;
            }
            AllocateMesh(vertexCount, totalTrisCount);
            Vector3 off = _trsRight * offset.x + _trsUp * offset.y + _trsForward * offset.z;
            for (int i = 0; i < surfaceVertexCount; i++)
            {
                GetSample(i, ref evalResult);
                _tsMesh.vertices[i] = evalResult.position + off;
                _tsMesh.normals[i] = evalResult.up;
                _tsMesh.colors[i] = evalResult.color * color;
            }

            #region UVs
            Vector2 min = projectedVerts[0];
            Vector2 max = projectedVerts[0];
            for (int i = 1; i < projectedVerts.Length; i++)
            {
                if (min.x < projectedVerts[i].x) min.x = projectedVerts[i].x;
                if (min.y < projectedVerts[i].y) min.y = projectedVerts[i].y;
                if (max.x > projectedVerts[i].x) max.x = projectedVerts[i].x;
                if (max.y > projectedVerts[i].y) max.y = projectedVerts[i].y;
            }

            for (int i = 0; i < projectedVerts.Length; i++)
            {
                _tsMesh.uv[i].x = Mathf.InverseLerp(max.x, min.x, projectedVerts[i].x) * uvScale.x - uvScale.x * 0.5f + uvOffset.x + 0.5f;
                _tsMesh.uv[i].y = Mathf.InverseLerp(min.y, max.y, projectedVerts[i].y) * uvScale.y - uvScale.y * 0.5f + uvOffset.y + 0.5f;
                _tsMesh.uv[i] = Quaternion.AngleAxis(uvRotation, Vector3.forward) * _tsMesh.uv[i];
            }
            #endregion


            if (flipCap)
            {
                for (int i = 0; i < surfaceVertexCount; i++)
                {
                    _tsMesh.normals[i] *= -1f;
                }
            }

            if (_expand != 0f)
            {
                for (int i = 0; i < surfaceVertexCount; i++)
                {
                    GetSample(i, ref evalResult);
                    _tsMesh.vertices[i] += (clockwise ? -evalResult.right : evalResult.right) * _expand;
                }
            }

            if (pathExtrude)
            {
                GetIdentityVerts(center, normal, clockwise);
                //Generate cap vertices with flipped normals
                for (int i = 0; i < surfaceVertexCount; i++)
                {
                    Vector3 vertexOffset = TransformOffset(extrudeResults[0], _extrudeOffset);
                    _tsMesh.vertices[i + surfaceVertexCount] = extrudeResults[0].position + (extrudeResults[0].rotation * identityVertices[i] + off) + vertexOffset;
                    _tsMesh.normals[i + surfaceVertexCount] = -extrudeResults[0].forward;
                    _tsMesh.colors[i + surfaceVertexCount] = _tsMesh.colors[i] * extrudeResults[0].color;
                    _tsMesh.uv[i + surfaceVertexCount] = new Vector2(1f - _tsMesh.uv[i].x, _tsMesh.uv[i].y);

                    vertexOffset = TransformOffset(extrudeResults[extrudeResults.Length - 1], _extrudeOffset);
                    _tsMesh.vertices[i] = extrudeResults[extrudeResults.Length - 1].position + (extrudeResults[extrudeResults.Length - 1].rotation * identityVertices[i] + off) + vertexOffset;
                    _tsMesh.normals[i] = extrudeResults[extrudeResults.Length - 1].forward;
                    _tsMesh.colors[i] *= extrudeResults[extrudeResults.Length - 1].color;
                }
                //Add wall vertices
                float totalLength = 0f;
                for (int i = 0; i < extrudeResults.Length; i++)
                {
                    if (_uniformUvs && i > 0) totalLength += Vector3.Distance(extrudeResults[i].position, extrudeResults[i - 1].position);
                    int startIndex = surfaceVertexCount * 2 + i * sampleCount;
                    for (int n = 0; n < identityVertices.Length; n++)
                    {
                        Vector3 vertexOffset = TransformOffset(extrudeResults[i], _extrudeOffset);
                        _tsMesh.vertices[startIndex + n] = extrudeResults[i].position + (extrudeResults[i].rotation * identityVertices[n] + off) + vertexOffset;
                        _tsMesh.normals[startIndex + n] = extrudeResults[i].rotation * identityNormals[n];
                        if (_uniformUvs)
                        {
                            _tsMesh.uv[startIndex + n] = new Vector2((float)n / (identityVertices.Length - 1) * _sideUvScale.x + _sideUvOffset.x, totalLength * _sideUvScale.y + _sideUvOffset.y);
                        }
                        else
                        {
                            _tsMesh.uv[startIndex + n] = new Vector2((float)n / (identityVertices.Length - 1) * _sideUvScale.x + _sideUvOffset.x, (float)i / (extrudeResults.Length - 1) * _sideUvScale.y + _sideUvOffset.y);
                        }
                        if (_sideUvRotation != 0f)
                        {
                            _tsMesh.uv[startIndex + n] = Quaternion.AngleAxis(_sideUvRotation, Vector3.forward) * _tsMesh.uv[startIndex + n];
                        }

                        if (clockwise)
                        {
                            _tsMesh.uv[startIndex + n].x = 1f - _tsMesh.uv[startIndex + n].x;
                        }
                    }
                }
                int written = WriteTris(ref surfaceTris, ref _tsMesh.triangles, 0, 0, false);
                written = WriteTris(ref surfaceTris, ref _tsMesh.triangles, surfaceVertexCount, written, true);

                MeshUtility.GeneratePlaneTriangles(ref wallTris, sampleCount - 1, extrudeResults.Length, flipSide, 0, 0, true);
                WriteTris(ref wallTris, ref _tsMesh.triangles, surfaceVertexCount * 2, written, false);
            }
            else if (simpleExtrude)
            {
                //Duplicate cap vertices with flipped normals
                for (int i = 0; i < surfaceVertexCount; i++)
                {
                    _tsMesh.vertices[i + surfaceVertexCount] = _tsMesh.vertices[i];
                    _tsMesh.normals[i + surfaceVertexCount] = -_tsMesh.normals[i];
                    _tsMesh.colors[i + surfaceVertexCount] = _tsMesh.colors[i];
                    _tsMesh.uv[i + surfaceVertexCount] = new Vector2(1f - _tsMesh.uv[i].x, _tsMesh.uv[i].y);
                    _tsMesh.vertices[i] += normal * _extrude;
                }

                //Add wall vertices
                for (int i = 0; i < surfaceVertexCount + 1; i++)
                {
                    int index = i;
                    if (i >= surfaceVertexCount) index = i - surfaceVertexCount;
                    GetSample(index, ref evalResult);
                    _tsMesh.vertices[i + surfaceVertexCount * 2] = _tsMesh.vertices[index] - normal * _extrude;
                    _tsMesh.normals[i + surfaceVertexCount * 2] = clockwise ? -evalResult.right : evalResult.right;
                    _tsMesh.colors[i + surfaceVertexCount * 2] = _tsMesh.colors[index];
                    _tsMesh.uv[i + surfaceVertexCount * 2] = new Vector2((float)i / (surfaceVertexCount - 1) * _sideUvScale.x + _sideUvOffset.x, 0f + _sideUvOffset.y);
                    if (clockwise)
                    {
                        _tsMesh.uv[i + surfaceVertexCount * 2].x = 1f - _tsMesh.uv[i + surfaceVertexCount * 2].x;
                    }

                    int offsetIndex = i + surfaceVertexCount * 3 + 1;
                    _tsMesh.vertices[offsetIndex] = _tsMesh.vertices[index];
                    _tsMesh.normals[offsetIndex] = _tsMesh.normals[i + surfaceVertexCount * 2];
                    _tsMesh.colors[offsetIndex] = _tsMesh.colors[index];
                    if (_uniformUvs)
                    {
                        _tsMesh.uv[offsetIndex] = new Vector2((float)i / surfaceVertexCount * _sideUvScale.x + _sideUvOffset.x, _extrude * _sideUvScale.y + _sideUvOffset.y);
                    }
                    else
                    {
                        _tsMesh.uv[offsetIndex] = new Vector2((float)i / surfaceVertexCount * _sideUvScale.x + _sideUvOffset.x, 1f * _sideUvScale.y + _sideUvOffset.y);
                    }
                    if (_sideUvRotation != 0f)
                    {
                        _tsMesh.uv[offsetIndex] = Quaternion.AngleAxis(_sideUvRotation, Vector3.forward) * _tsMesh.uv[offsetIndex];
                    }
                    if (clockwise)
                    {
                        _tsMesh.uv[offsetIndex].x = 1f - _tsMesh.uv[offsetIndex].x;
                    }
                }
                int written = WriteTris(ref surfaceTris, ref _tsMesh.triangles, 0, 0, false);
                written = WriteTris(ref surfaceTris, ref _tsMesh.triangles, surfaceVertexCount, written, true);

                MeshUtility.GeneratePlaneTriangles(ref wallTris, sampleCount - 1, 2, flipSide, 0, 0, true);
                WriteTris(ref wallTris, ref _tsMesh.triangles, surfaceVertexCount * 2, written, false);
            }
            else
            {
                WriteTris(ref surfaceTris, ref _tsMesh.triangles, 0, 0, false);
            }
        }

        private void GenerateSurfaceTris(bool flip)
        {
            MeshUtility.Triangulate(projectedVerts, ref surfaceTris);
            if (flip) MeshUtility.FlipTriangles(ref surfaceTris);
        }

        private int WriteTris(ref int[] tris, ref int[] target, int vertexOffset, int trisOffset, bool flip)
        {
            for (int i = trisOffset; i < trisOffset + tris.Length; i += 3)
            {
                if (flip)
                {
                    target[i] = tris[i + 2 - trisOffset] + vertexOffset;
                    target[i + 1] = tris[i + 1 - trisOffset] + vertexOffset;
                    target[i + 2] = tris[i - trisOffset] + vertexOffset;
                }
                else
                {
                    target[i] = tris[i - trisOffset] + vertexOffset;
                    target[i + 1] = tris[i + 1 - trisOffset] + vertexOffset;
                    target[i + 2] = tris[i + 2 - trisOffset] + vertexOffset;
                }
            }
            return trisOffset + tris.Length;
        }

        bool IsClockwise(Vector2[] points2D)
        {
            float sum = 0f;
            for (int i = 1; i < points2D.Length; i++)
            {
                Vector2 v1 = points2D[i];
                Vector2 v2 = points2D[(i + 1) % points2D.Length];
                sum += (v2.x - v1.x) * (v2.y + v1.y);
            }
            sum += (points2D[0].x - points2D[points2D.Length - 1].x) * (points2D[0].y + points2D[points2D.Length - 1].y);
            return sum <= 0f;
        }

        void GetIdentityVerts(Vector3 center, Vector3 normal, bool clockwise)
        {
            Quaternion vertsRotation = Quaternion.Inverse(Quaternion.LookRotation(normal));
            if (identityVertices.Length != sampleCount)
            {
                identityVertices = new Vector3[sampleCount];
                identityNormals = new Vector3[sampleCount];
            }
            for (int i = 0; i < sampleCount; i++)
            {
                GetSampleRaw(i, ref evalResult);
                Vector3 right = evalResult.right;
                identityVertices[i] = vertsRotation * (evalResult.position - center + (clockwise ? -right : right) * _expand);
                identityNormals[i] = vertsRotation * (clockwise ? -right : right);
            }
        }

        void GetProjectedVertices(int count, out Vector3 center, out Vector3 normal)
        {
            center = Vector3.zero;
            normal = Vector3.zero;
            Vector3 off = _trsRight * offset.x + _trsUp * offset.y + _trsForward * offset.z;
            for (int i = 0; i < count; i++)
            {
                GetSampleRaw(i, ref evalResult);
                center += evalResult.position + off;
                normal += evalResult.up;
            }
            normal.Normalize();
            center /= count;

            Quaternion rot = Quaternion.LookRotation(normal, Vector3.up);
            Vector3 up = rot * Vector3.up;
            Vector3 right = rot * Vector3.right;
            if (projectedVerts.Length != count) projectedVerts = new Vector2[count];
            for (int i = 0; i < count; i++)
            {
                GetSampleRaw(i, ref evalResult);
                Vector3 point = evalResult.position + off - center;
                float projectionPointX = Vector3.Project(point, right).magnitude;
                if (Vector3.Dot(point, right) < 0.0f) projectionPointX *= -1f;
                float projectionPointY = Vector3.Project(point, up).magnitude;
                if (Vector3.Dot(point, up) < 0.0f) projectionPointY *= -1f;
                projectedVerts[i].x = projectionPointX;
                projectedVerts[i].y = projectionPointY;
            }
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/SurfaceGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/TubeGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 77ab80dc0820f9d4a8cd9fddbbc89057
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Threading;

namespace Dreamteck.Splines
{
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Dreamteck/Splines/Users/Tube Generator")]
    public class TubeGenerator : MeshGenerator
    {
        public enum CapMethod { None, Flat, Round }

        public int sides
        {
            get { return _sides; }
            set
            {
                if (value != _sides)
                {
                    if (value < 3) value = 3;
                    _sides = value;
                    Rebuild();
                }
            }
        }

        public CapMethod capMode
        {
            get { return _capMode; }
            set
            {
                if (value != _capMode)
                {
                    _capMode = value;
                    Rebuild();
                }
            }
        }

        public int roundCapLatitude
        {
            get { return _roundCapLatitude; }
            set
            {
                if (value < 1) value = 1;
                if (value != _roundCapLatitude)
                {
                    _roundCapLatitude = value;
                    if(_capMode == CapMethod.Round) Rebuild();
                }
            }
        }

        public float revolve
        {
            get { return _revolve; }
            set
            {
                if (value != _revolve)
                {
                    _revolve = value;
                    Rebuild();
                }
            }
        }

        public float capUVScale
        {
            get { return _capUVScale; }
            set
            {
                if (value != _capUVScale)
                {
                    _capUVScale = value;
                    Rebuild();
                }
            }
        }

        public float uvTwist
        {
            get { return _uvTwist; }
            set
            {
                if (value != _uvTwist)
                {
                    _uvTwist = value;
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private int _sides = 12;
        [SerializeField]
        [HideInInspector]
        private int _roundCapLatitude = 6;
        [SerializeField]
        [HideInInspector]
        private CapMethod _capMode = CapMethod.None;
        [SerializeField]
        [HideInInspector]
        [Range(0f, 360f)]
        private float _revolve = 360f;
        [SerializeField]
        [HideInInspector]
        private float _capUVScale = 1f;
        [SerializeField]
        [HideInInspector]
        private float _uvTwist = 0f;

        private bool useCap
        {
            get
            {
                bool isCapSet = _capMode != CapMethod.None;
                if (spline != null) return isCapSet && (!spline.isClosed || span < 1f);
                return isCapSet;
            }
        }

        protected override string meshName => "Tube";

        private int bodyVertexCount = 0;
        private int bodyTrisCount = 0;
        private int capVertexCount = 0;
        private int capTrisCount = 0;

        protected override void Reset()
        {
            base.Reset();
        }

        protected override void BuildMesh()
        {
            if (_sides <= 2) return;
            base.BuildMesh();
            bodyVertexCount = (_sides + 1) * sampleCount;
            CapMethod _capModeFinal = _capMode;
            if (!useCap)
            {
                _capModeFinal = CapMethod.None;
            }
            switch (_capModeFinal)
            {
                case CapMethod.Flat: capVertexCount = _sides + 1; break;
                case CapMethod.Round: capVertexCount = _roundCapLatitude * (sides + 1); break;
                default: capVertexCount = 0; break;
            }
            int vertexCount = bodyVertexCount + capVertexCount * 2;

            bodyTrisCount = _sides * (sampleCount - 1) * 2 * 3;
            switch (_capModeFinal)
            {
                case CapMethod.Flat: capTrisCount = (_sides - 1) * 3 * 2; break;
                case CapMethod.Round: capTrisCount = _sides * _roundCapLatitude * 6; break;
                default: capTrisCount = 0; break;
            }
            AllocateMesh(vertexCount, bodyTrisCount + capTrisCount * 2);

            Generate();
            switch (_capModeFinal)
            {
                case CapMethod.Flat: GenerateFlatCaps(); break;
                case CapMethod.Round: GenerateRoundCaps(); break;
            }
        }

        void Generate()
        {
            int vertexIndex = 0;
            ResetUVDistance();
            bool hasOffset = offset != Vector3.zero;
            for (int i = 0; i < sampleCount; i++)
            {
                GetSample(i, ref evalResult);
                Vector3 center = evalResult.position;
                Vector3 right = evalResult.right;
                float resultSize = GetBaseSize(evalResult);
                if (hasOffset)
                {
                    center += (offset.x * resultSize) * right + (offset.y * resultSize) * evalResult.up + (offset.z * resultSize) * evalResult.forward;
                }
                if (uvMode == UVMode.UniformClamp || uvMode == UVMode.UniformClip)
                {
                    AddUVDistance(i);
                }
                Color vertexColor = GetBaseColor(evalResult) * color;
                for (int n = 0; n < _sides + 1; n++)
                {
                    float anglePercent = (float)(n) / _sides;
                    Quaternion rot = Quaternion.AngleAxis(_revolve * anglePercent + rotation + 180f, evalResult.forward);
                    _tsMesh.vertices[vertexIndex] = center + rot * right * (size * resultSize * 0.5f);
                    CalculateUVs(evalResult.percent, anglePercent);
                    _tsMesh.uv[vertexIndex] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(uvRotation + 180f, Vector3.forward) * (Vector2.one * 0.5f - (__uvs + Vector2.right * ((float)evalResult.percent * _uvTwist))));
                    _tsMesh.normals[vertexIndex] = Vector3.Normalize(_tsMesh.vertices[vertexIndex] - center);
                    _tsMesh.colors[vertexIndex] = vertexColor;
                    vertexIndex++;
                }
            }
            MeshUtility.GeneratePlaneTriangles(ref _tsMesh.triangles, _sides, sampleCount, false);
        }

        void GenerateFlatCaps()
        {
            //Start Cap

            GetSample(0, ref evalResult);
            for (int i = 0; i < _sides+1; i++)
            {
                int index = bodyVertexCount + i;
                _tsMesh.vertices[index] = _tsMesh.vertices[i];
                _tsMesh.normals[index] = -evalResult.forward;
                _tsMesh.colors[index] = _tsMesh.colors[i];
                _tsMesh.uv[index] = Quaternion.AngleAxis(_revolve * (((float)i) / (_sides - 1)), Vector3.forward) * Vector2.right * (0.5f * capUVScale) + Vector3.right * 0.5f + Vector3.up * 0.5f;
            }

            //End Cap
            GetSample(sampleCount - 1, ref evalResult);
            for (int i = 0; i < _sides + 1; i++)
            {
                int index = bodyVertexCount + (_sides + 1) + i;
                int bodyIndex = bodyVertexCount - (_sides + 1) + i;
                _tsMesh.vertices[index] = _tsMesh.vertices[bodyIndex];
                _tsMesh.normals[index] = evalResult.forward;
                _tsMesh.colors[index] = _tsMesh.colors[bodyIndex];
                _tsMesh.uv[index] = Quaternion.AngleAxis(_revolve * ((float)(bodyIndex) / (_sides - 1)), Vector3.forward) * Vector2.right * (0.5f * capUVScale) + Vector3.right * 0.5f + Vector3.up * 0.5f;
            }

            int t = bodyTrisCount;
            bool fullIntegrity = _revolve == 360f;
            int finalSides = fullIntegrity ? _sides - 1 : _sides;
            //Start cap
            for (int i = 0; i < finalSides - 1; i++)
            {
                _tsMesh.triangles[t++] = i + bodyVertexCount + 2;
                _tsMesh.triangles[t++] = i + +bodyVertexCount + 1;
                _tsMesh.triangles[t++] = bodyVertexCount;
            }

            //End cap
            for (int i = 0; i < finalSides - 1; i++)
            {
                _tsMesh.triangles[t++] = bodyVertexCount + (_sides + 1);
                _tsMesh.triangles[t++] = i + 1 + bodyVertexCount + (_sides + 1);
                _tsMesh.triangles[t++] = i + 2 + bodyVertexCount + (_sides + 1);
            }
        }

        void GenerateRoundCaps()
        {
            //Start Cap
            GetSample(0, ref evalResult);
            Vector3 center = evalResult.position;
            bool hasOffset = offset != Vector3.zero;
            float resultSize = GetBaseSize(evalResult);
            if (hasOffset)
            {
                center += (offset.x * resultSize) * evalResult.right + (offset.y * resultSize) * evalResult.up + (offset.z * resultSize) * evalResult.forward;
            }
            Quaternion lookRot = Quaternion.LookRotation(-evalResult.forward, evalResult.up);
            float startV = 0f;
                        float capLengthPercent = 0f;
            switch (uvMode)
            {
                case UVMode.Clip: startV = (float)evalResult.percent;
                    capLengthPercent = (size * 0.5f) / spline.CalculateLength(); break;
                case UVMode.UniformClip:
                    startV = spline.CalculateLength(0.0, evalResult.percent);
                    capLengthPercent = size * 0.5f; break;
                case UVMode.UniformClamp:
                    startV = 0f;
                    capLengthPercent = size * 0.5f / (float)span;
                    break;
                case UVMode.Clamp: capLengthPercent = (size * 0.5f) / spline.CalculateLength(clipFrom, clipTo); break;
            }

            Color vertexColor = GetBaseColor(evalResult) * color;
            for (int lat = 1; lat < _roundCapLatitude+1; lat++)
            {
                float latitudePercent = ((float)lat / _roundCapLatitude);
                float latAngle = 90f * latitudePercent;
                for (int lon = 0; lon <= sides; lon++)
                {
                    float anglePercent = (float)lon / sides;
                    int index = bodyVertexCount + lon + (lat-1) * (sides + 1);
                    Quaternion rot = Quaternion.AngleAxis(_revolve * anglePercent + rotation + 180f, -Vector3.forward) * Quaternion.AngleAxis(latAngle, Vector3.up);
                    _tsMesh.vertices[index] = center + lookRot * rot * -Vector3.right * (size * 0.5f * evalResult.size);
                    _tsMesh.colors[index] = vertexColor;
                    _tsMesh.normals[index] = (_tsMesh.vertices[index] - center).normalized;
                    float baseV = startV + capLengthPercent * latitudePercent;
                    Vector2 baseUV = new Vector2(anglePercent * uvScale.x - baseV * _uvTwist, baseV * uvScale.y) - uvOffset;
                    _tsMesh.uv[index] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(uvRotation + 180f, Vector3.forward) * (Vector2.one * 0.5f - baseUV));
                }
            }


            //Triangles
            int t = bodyTrisCount;
            for (int z = -1; z < _roundCapLatitude - 1; z++)
            {
                for (int x = 0; x < sides; x++)
                {
                    int current = bodyVertexCount + x + z * (sides + 1);
                    int next = current + (sides + 1);
                    if (z == -1)
                    {
                        current = x;
                        next = bodyVertexCount + x;
                    }
                    _tsMesh.triangles[t++] = next + 1;
                    _tsMesh.triangles[t++] = current + 1;
                    _tsMesh.triangles[t++] = current;
                    _tsMesh.triangles[t++] = next;
                    _tsMesh.triangles[t++] = next + 1;
                    _tsMesh.triangles[t++] = current;
                }
            }


            //End Cap
            GetSample(sampleCount - 1, ref evalResult);
            center = evalResult.position;
            resultSize = GetBaseSize(evalResult);
            if (hasOffset)
            {
                center += (offset.x * resultSize) * evalResult.right + (offset.y * resultSize) * evalResult.up + (offset.z * resultSize) * evalResult.forward;
            }
            lookRot = Quaternion.LookRotation(evalResult.forward, evalResult.up);
            switch (uvMode)
            {
                case UVMode.Clip: startV = (float)evalResult.percent; break;
                case UVMode.UniformClip: startV = spline.CalculateLength(0.0, evalResult.percent); break;
                case UVMode.Clamp: startV = 1f; break;
                case UVMode.UniformClamp: startV = spline.CalculateLength(); break;
            }

            vertexColor = GetBaseColor(evalResult) * color;
            for (int lat = 1; lat < _roundCapLatitude+1; lat++)
            {
                float latitudePercent = ((float)lat / _roundCapLatitude);
                float latAngle = 90f * latitudePercent;
                for (int lon = 0; lon <= sides; lon++)
                {
                    float anglePercent = (float)lon / sides;
                    int index = bodyVertexCount + capVertexCount + lon + (lat - 1) * (sides + 1);
                    Quaternion rot = Quaternion.AngleAxis(_revolve * anglePercent + rotation + 180f, Vector3.forward) * Quaternion.AngleAxis(latAngle, -Vector3.up);
                    _tsMesh.vertices[index] = center + lookRot * rot * Vector3.right * size * 0.5f * evalResult.size;
                    _tsMesh.normals[index] = (_tsMesh.vertices[index] - center).normalized;
                    _tsMesh.colors[index] = vertexColor;
                    float baseV = startV + capLengthPercent * latitudePercent;
                    Vector2 baseUV = new Vector2(anglePercent * uvScale.x + baseV * _uvTwist, baseV * uvScale.y) - uvOffset;
                    _tsMesh.uv[index] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(uvRotation + 180f, Vector3.forward) * (Vector2.one * 0.5f - baseUV));
                } 
            }

            //Triangles
            for (int z = -1; z < _roundCapLatitude - 1; z++)
            {
                for (int x = 0; x < sides; x++)
                {
                    int current = bodyVertexCount + capVertexCount + x + z * (sides + 1);
                    int next = current + (sides + 1);
                    if (z == -1)
                    {
                        current = bodyVertexCount - (_sides+1) + x;
                        next = bodyVertexCount + capVertexCount + x;
                    }

                    _tsMesh.triangles[t++] = current+1;
                    _tsMesh.triangles[t++] = next + 1;
                    _tsMesh.triangles[t++] = next;
                    _tsMesh.triangles[t++] = next;
                    _tsMesh.triangles[t++] = current;
                    _tsMesh.triangles[t++] = current + 1;
                }
            }
            
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/TubeGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/WaveformGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0082a2f973246db418d848df591b7667
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace Dreamteck.Splines
{
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Dreamteck/Splines/Users/Waveform Generator")]
    public class WaveformGenerator : MeshGenerator
    {
        public enum Axis { X, Y, Z }
        public enum Space { World, Local }
        public enum UVWrapMode { Clamp, UniformX, UniformY, Uniform }

        public Axis axis
        {
            get { return _axis; }
            set
            {
                if (value != _axis)
                {
                    _axis = value;
                    Rebuild();
                }
            }
        }

        public bool symmetry
        {
            get { return _symmetry; }
            set
            {
                if (value != _symmetry)
                {
                    _symmetry = value;
                    Rebuild();
                }
            }
        }

        public UVWrapMode uvWrapMode
        {
            get { return _uvWrapMode; }
            set
            {
                if (value != _uvWrapMode)
                {
                    _uvWrapMode = value;
                    Rebuild();
                }
            }
        }

        public int slices
        {
            get { return _slices; }
            set
            {
                if (value != _slices)
                {
                    if (value < 1) value = 1;
                    _slices = value;
                    Rebuild();
                }
            }
        }

        [SerializeField]
        [HideInInspector]
        private Axis _axis = Axis.Y;
        [SerializeField]
        [HideInInspector]
        private bool _symmetry = false;
        [SerializeField]
        [HideInInspector]
        private UVWrapMode _uvWrapMode = UVWrapMode.Clamp;
        [SerializeField]
        [HideInInspector]
        private int _slices = 1;

        protected override string meshName => "Waveform";

        protected override void BuildMesh()
        {
            base.BuildMesh();
            Generate();
        }

        protected override void Build()
        {
            base.Build();
        }

        protected override void LateRun()
        {
            base.LateRun();
        }

        private void Generate()
        {
            int vertexCount = sampleCount * (_slices + 1);
            AllocateMesh(vertexCount, _slices * (sampleCount - 1) * 6);
            int vertIndex = 0;
            float avgTop = 0f;
            float totalLength = 0f;
            Vector3 computerPosition = spline.position;
            Vector3 normal = spline.TransformDirection(Vector3.right);
            switch (_axis)
            {
                case Axis.Y: normal = spline.TransformDirection(Vector3.up); break;
                case Axis.Z: normal = spline.TransformDirection(Vector3.forward); break;
            }

            Vector3 lastPosition = Vector3.zero;
            for (int i = 0; i < sampleCount; i++)
            {
                GetSample(i, ref evalResult);
                float resultSize = GetBaseSize(evalResult);
                Vector3 samplePosition = evalResult.position;
                Vector3 localSamplePosition = spline.InverseTransformPoint(samplePosition);
                Vector3 bottomPosition = localSamplePosition;
                Vector3 sampleDirection = evalResult.forward;
                Vector3 sampleNormal = evalResult.up;

                float heightPercent = 1f;
                if (_uvWrapMode == UVWrapMode.UniformX || _uvWrapMode == UVWrapMode.Uniform)
                {
                    if (i > 0)
                    {
                        totalLength += Vector3.Distance(evalResult.position, lastPosition);
                    }
                }
                switch (_axis)
                {
                    case Axis.X: bottomPosition.x = _symmetry ? -localSamplePosition.x : 0f;  heightPercent = uvScale.y * Mathf.Abs(localSamplePosition.x); avgTop += localSamplePosition.x; break;
                    case Axis.Y: bottomPosition.y = _symmetry ? -localSamplePosition.y : 0f;  heightPercent = uvScale.y * Mathf.Abs(localSamplePosition.y); avgTop += localSamplePosition.y; break;
                    case Axis.Z: bottomPosition.z = _symmetry ? -localSamplePosition.z : 0f;  heightPercent = uvScale.y * Mathf.Abs(localSamplePosition.z); avgTop += localSamplePosition.z; break;
                }
                bottomPosition = spline.TransformPoint(bottomPosition);
                Vector3 right = Vector3.Cross(normal, sampleDirection).normalized;
                Vector3 offsetRight = Vector3.Cross(sampleNormal, sampleDirection);
                
                for (int n = 0; n < _slices + 1; n++)
                {
                    float slicePercent = ((float)n / _slices);
                    _tsMesh.vertices[vertIndex] = Vector3.Lerp(bottomPosition, samplePosition, slicePercent) + normal * (offset.y * resultSize) + offsetRight * (offset.x * resultSize);
                    _tsMesh.normals[vertIndex] = right;
                    switch (_uvWrapMode)
                    {
                        case UVWrapMode.Clamp: _tsMesh.uv[vertIndex] = new Vector2((float)evalResult.percent * uvScale.x + uvOffset.x, slicePercent * uvScale.y + uvOffset.y); break;
                        case UVWrapMode.UniformX: _tsMesh.uv[vertIndex] = new Vector2(totalLength * uvScale.x + uvOffset.x, slicePercent * uvScale.y + uvOffset.y); break;
                        case UVWrapMode.UniformY: _tsMesh.uv[vertIndex] = new Vector2((float)evalResult.percent * uvScale.x + uvOffset.x, heightPercent * slicePercent * uvScale.y + uvOffset.y); break;
                        case UVWrapMode.Uniform: _tsMesh.uv[vertIndex] = new Vector2(totalLength * uvScale.x + uvOffset.x, heightPercent * slicePercent * uvScale.y + uvOffset.y); break;
                    }
                    _tsMesh.colors[vertIndex] = GetBaseColor(evalResult) * color;
                    vertIndex++;
                }
                lastPosition = evalResult.position;
            }
            if (sampleCount > 0) avgTop /= sampleCount;
            MeshUtility.GeneratePlaneTriangles(ref _tsMesh.triangles, _slices, sampleCount, avgTop < 0f);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Components/WaveformGenerator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/CSV.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c2313af4c5f59614393edd640d06f36c
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using System.Text.RegularExpressions;

namespace Dreamteck.Splines.IO
{
    public class CSV : SplineParser
    {
        public enum ColumnType { Position, Tangent, Tangent2, Normal, Size, Color }
        public List<ColumnType> columns = new List<ColumnType>();

        private System.Globalization.CultureInfo culture = new System.Globalization.CultureInfo("en-US");
        private System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Any;

        public CSV(SplineComputer computer)
        {
            Spline spline = new Spline(computer.type, computer.sampleRate);
            spline.points = computer.GetPoints();
            if (spline.type != Spline.Type.Bezier && spline.type != Spline.Type.Linear) spline.CatToBezierTangents();
            if (computer.isClosed) spline.Close();
            buffer = new SplineDefinition(computer.name, spline);
            fileName = computer.name;
            columns.Add(ColumnType.Position);
            columns.Add(ColumnType.Tangent);
            columns.Add(ColumnType.Tangent2);
        }

        public CSV(string filePath, List<ColumnType> customColumns = null)
        {
            if (File.Exists(filePath))
            {
                string ext = Path.GetExtension(filePath).ToLower();
                fileName = Path.GetFileNameWithoutExtension(filePath);
                if (ext != ".csv")
                {
                    Debug.LogError("CSV Parsing ERROR: Wrong format. Please use SVG or XML");
                    return;
                }
                string[] lines = File.ReadAllLines(filePath);
                if (customColumns == null)
                {
                    columns.Add(ColumnType.Position);
                    columns.Add(ColumnType.Tangent);
                    columns.Add(ColumnType.Tangent2);
                    columns.Add(ColumnType.Normal);
                    columns.Add(ColumnType.Size);
                    columns.Add(ColumnType.Color);
                } else columns = new List<ColumnType>(customColumns);
                buffer = new SplineDefinition(fileName, Spline.Type.CatmullRom);
                Read(lines);
            }
        }

        void Read(string[] lines)
        {
            int expectedElementCount = 0;
            foreach (ColumnType col in columns)
            {
                switch (col)
                {
                    case ColumnType.Position: expectedElementCount +=3; break;
                    case ColumnType.Tangent: expectedElementCount += 3; break;
                    case ColumnType.Tangent2: expectedElementCount += 3; break;
                    case ColumnType.Normal: expectedElementCount += 3; break;
                    case ColumnType.Size: expectedElementCount ++; break;
                    case ColumnType.Color: expectedElementCount += 4; break;
                }
            }
            for (int i = 1; i < lines.Length; i++)
            {
                lines[i] = Regex.Replace(lines[i], @"\s+", "");
                string[] elements = lines[i].Split(',');
                if(elements.Length != expectedElementCount)
                {
                    Debug.LogError("Unexpected element count on row " + i + ". Expected " + expectedElementCount +  " found " + elements.Length + " Please make sure that all values exist and the column order is correct.");
                    continue;
                }
                float[] values = new float[elements.Length];
                for (int j = 0; j < elements.Length; j++)
                {
                    float.TryParse(elements[j], style, culture, out values[j]);
                }
                int currentValue = 0;
                foreach (ColumnType col in columns)
                {
                    switch (col)
                    {
                        case ColumnType.Position: buffer.position = new Vector3(values[currentValue++], values[currentValue++], values[currentValue++]); break;
                        case ColumnType.Tangent: buffer.tangent = new Vector3(values[currentValue++], values[currentValue++], values[currentValue++]); break;
                        case ColumnType.Tangent2: buffer.tangent2 = new Vector3(values[currentValue++], values[currentValue++], values[currentValue++]); break;
                        case ColumnType.Normal: buffer.normal = new Vector3(values[currentValue++], values[currentValue++], values[currentValue++]); break;
                        case ColumnType.Size: buffer.size = values[currentValue++]; break;
                        case ColumnType.Color: buffer.color = new Color(values[currentValue++], values[currentValue++], values[currentValue++], values[currentValue++]); break;
                    }
                }
                buffer.CreateSmooth();
            }
        }

        public SplineComputer CreateSplineComputer(Vector3 position, Quaternion rotation)
        {
            return buffer.CreateSplineComputer(position, rotation);
        }

        public Spline CreateSpline()
        {
            return buffer.CreateSpline();
        }


        public void FlatX()
        {
            for (int i = 0; i < buffer.pointCount; i++)
            {
                buffer.points[i].Flatten(LinearAlgebraUtility.Axis.X);
            }
        }

        public void FlatY()
        {
            for (int i = 0; i < buffer.pointCount; i++)
            {
                buffer.points[i].Flatten(LinearAlgebraUtility.Axis.Y);
            }
        }

        public void FlatZ()
        {
            for (int i = 0; i < buffer.pointCount; i++)
            {
                buffer.points[i].Flatten(LinearAlgebraUtility.Axis.Z);
            }
        }

        void AddTitle(ref string[] content, string title)
        {
            if (!string.IsNullOrEmpty(content[0])) content[0] += ",";
            content[0] += title;
        }

        void AddVector3Title(ref string[] content, string prefix)
        {
            AddTitle(ref content, prefix + "X," + prefix + "Y," + prefix + "Z");
        }

        void AddColorTitle(ref string[] content, string prefix)
        {
            AddTitle(ref content, prefix + "R," + prefix + "G," + prefix + "B" + prefix + "A");
        }

        void AddVector3(ref string[] content, int index, Vector3 vector)
        {
            AddFloat(ref content, index, vector.x);
            AddFloat(ref content, index, vector.y);
            AddFloat(ref content, index, vector.z);
        }

        void AddColor(ref string[] content, int index, Color color)
        {
            AddFloat(ref content, index, color.r);
            AddFloat(ref content, index, color.g);
            AddFloat(ref content, index, color.b);
            AddFloat(ref content, index, color.a);
        }

        void AddFloat(ref string[] content, int index, float value)
        {
            if (!string.IsNullOrEmpty(content[index])) content[index] += ",";
            content[index] += value.ToString();
        }

        public void Write(string filePath)
        {
            if (!Directory.Exists(Path.GetDirectoryName(filePath)))  throw new DirectoryNotFoundException("The file is being saved to a non-existing directory.");
            List<SplinePoint> csvPoints = buffer.points;
            string[] content = new string[csvPoints.Count+1];
            //Add the column titles
            foreach(ColumnType col in columns)
            {
                switch (col)
                {
                    case ColumnType.Position: AddVector3Title(ref content, "Position"); break;
                    case ColumnType.Tangent: AddVector3Title(ref content, "Tangent"); break;
                    case ColumnType.Tangent2: AddVector3Title(ref content, "Tangent2"); break;
                    case ColumnType.Normal: AddVector3Title(ref content, "Normal"); break;
                    case ColumnType.Size: AddTitle(ref content, "Size"); break;
                    case ColumnType.Color: AddColorTitle(ref content, "Color"); break;
                }
            }
            //Add the content for each column
            foreach (ColumnType col in columns)
            {
                for (int i = 1; i <= csvPoints.Count; i++)
                {
                    int index = i - 1;
                    switch (col)
                    {
                        case ColumnType.Position: AddVector3(ref content, i, csvPoints[index].position); break;
                        case ColumnType.Tangent: AddVector3(ref content, i, csvPoints[index].tangent); break;
                        case ColumnType.Tangent2: AddVector3(ref content, i, csvPoints[index].tangent2); break;
                        case ColumnType.Normal: AddVector3(ref content, i, csvPoints[index].normal); break;
                        case ColumnType.Size: AddFloat(ref content, i, csvPoints[index].size); break;
                        case ColumnType.Color: AddColor(ref content, i, csvPoints[index].color); break;
                    }
                }
            }
            File.WriteAllLines(filePath, content);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/CSV.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/SplineParser.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 62e998669a36f6946b5d107a292616b0
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.IO
{
    public class SplineParser 
    {
        protected string fileName = "";
        public string name
        {
            get { return fileName; }
        }

        private System.Globalization.CultureInfo culture = new System.Globalization.CultureInfo("en-US");
        private System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Any;

        internal class Transformation
        {
            protected static Matrix4x4 matrix = new Matrix4x4();

            internal static void ResetMatrix()
            {
                matrix.SetTRS(Vector3.zero, Quaternion.identity, Vector3.one);
            }

            internal virtual void Push()
            {

            }

            internal static void Apply(SplinePoint[] points)
            {
                for (int i = 0; i < points.Length; i++)
                {
                    SplinePoint p = points[i];
                    p.position = matrix.MultiplyPoint(p.position);
                    p.tangent = matrix.MultiplyPoint(p.tangent);
                    p.tangent2 = matrix.MultiplyPoint(p.tangent2);
                    points[i] = p;
                }
            }
        }

        internal class Translate : Transformation
        {
            private Vector2 offset = Vector2.zero;
            public Translate(Vector2 o)
            {
                offset = o;
            }

            internal override void Push()
            {
                Matrix4x4 translate = new Matrix4x4();
                translate.SetTRS(new Vector2(offset.x, -offset.y), Quaternion.identity, Vector3.one);
                matrix = matrix * translate;
            }
        }

        internal class Rotate : Transformation
        {
            private float angle = 0f;
            public Rotate(float a)
            {
                angle = a;
            }

            internal override void Push()
            {
                Matrix4x4 rotate = new Matrix4x4();
                rotate.SetTRS(Vector3.zero, Quaternion.AngleAxis(angle, Vector3.back), Vector3.one);
                matrix = matrix * rotate;
            }
        }

        internal class Scale : Transformation
        {
            private Vector2 multiplier = Vector2.one;
            public Scale(Vector2 s)
            {
                multiplier = s;
            }

            internal override void Push()
            {
                Matrix4x4 scale = new Matrix4x4();
                scale.SetTRS(Vector3.zero, Quaternion.identity, multiplier);
                matrix = matrix * scale;
            }
        }

        internal class SkewX : Transformation
        {
            private float amount = 0f;
            public SkewX(float a)
            {
                amount = a;
            }

            internal override void Push()
            {
                Matrix4x4 skew = new Matrix4x4();
                skew[0, 0] = 1.0f;
                skew[1, 1] = 1.0f;
                skew[2, 2] = 1.0f;
                skew[3, 3] = 1.0f;
                skew[0, 1] = Mathf.Tan(-amount * Mathf.Deg2Rad);
                matrix = matrix * skew;
            }
        }

        internal class SkewY : Transformation
        {
            private float amount = 0f;
            public SkewY(float a)
            {
                amount = a;
            }

            internal override void Push()
            {
                Matrix4x4 skew = new Matrix4x4();
                skew[0, 0] = 1.0f;
                skew[1, 1] = 1.0f;
                skew[2, 2] = 1.0f;
                skew[3, 3] = 1.0f;
                skew[1, 0] = Mathf.Tan(-amount * Mathf.Deg2Rad);
                matrix = matrix *skew;
            }
        }

        internal class MatrixTransform : Transformation
        {
            private Matrix4x4 transformMatrix = new Matrix4x4();

            public MatrixTransform(float a, float b, float c, float d, float e, float f)
            { 
                transformMatrix.SetRow(0, new Vector4(a, c, 0f, e));
                transformMatrix.SetRow(1, new Vector4(b, d, 0f, -f));
                transformMatrix.SetRow(2, new Vector4(0f, 0f, 1f, 0f));
                transformMatrix.SetRow(3, new Vector4(0f, 0f, 0f, 1f));
            }

            internal override void Push()
            {
                matrix = matrix * transformMatrix;
            }
        }


        internal class SplineDefinition
        {
            internal string name = "";
            internal Spline.Type type = Spline.Type.Linear;
            internal List<SplinePoint> points = new List<SplinePoint>();
            internal bool closed = false;

            internal int pointCount
            {
                get { return points.Count; }
            }

            internal Vector3 position = Vector3.zero;
            internal Vector3 tangent = Vector3.zero;
            internal Vector3 tangent2 = Vector3.zero;
            internal Vector3 normal = Vector3.back;
            internal float size = 1f;
            internal Color color = Color.white;

            internal SplineDefinition(string n, Spline.Type t)
            {
                name = n;
                type = t;
            }

            internal SplineDefinition(string n, Spline spline)
            {
                name = n;
                type = spline.type;
                closed = spline.isClosed;
                points = new List<SplinePoint>(spline.points);
            }

            internal SplinePoint GetLastPoint()
            {
                if (points.Count == 0) return new SplinePoint();
                return points[points.Count - 1];
            }

            internal void SetLastPoint(SplinePoint point)
            {
                if (points.Count == 0) return;
                points[points.Count - 1] = point;
            }

            internal void CreateClosingPoint()
            {
                SplinePoint p = new SplinePoint(points[0]);
                points.Add(p);
            }

            internal void CreateSmooth()
            {
                points.Add(new SplinePoint(position, tangent, normal, size, color));
            }

            internal void CreateBroken()
            {
                SplinePoint point = new SplinePoint(new SplinePoint(position, tangent, normal, size, color));
                point.type = SplinePoint.Type.Broken;
                point.SetTangent2Position(point.position);
                point.normal = normal;
                point.color = color;
                point.size = size;
                points.Add(point);
            }

            internal void CreateLinear()
            {
                tangent = position;
                CreateSmooth();
            }

            internal SplineComputer CreateSplineComputer(Vector3 position, Quaternion rotation)
            {
                GameObject go = new GameObject(name);
                go.transform.position = position;
                go.transform.rotation = rotation;
                SplineComputer computer = go.AddComponent<SplineComputer>();
#if UNITY_EDITOR
                if(Application.isPlaying) computer.ResampleTransform();
#endif
                computer.type = type;
                if(closed)
                {
                    if (points[0].type == SplinePoint.Type.Broken) points[0].SetTangentPosition(GetLastPoint().tangent2);
                }
                computer.SetPoints(points.ToArray(), SplineComputer.Space.Local);
                if (closed) computer.Close();
                return computer;
            }

            internal Spline CreateSpline()
            {
                Spline spline = new Spline(type);
                spline.points = points.ToArray();
                if (closed) spline.Close();
                return spline;
            }

            internal void Transform(List<Transformation> trs)
            {
                SplinePoint[] p = points.ToArray();
                Transformation.ResetMatrix();
                foreach(Transformation t in trs) t.Push();
                Transformation.Apply(p);
                for (int i = 0; i < p.Length; i++) points[i] = p[i];
                SplinePoint[] debugPoints = new SplinePoint[1];
                debugPoints[0] = new SplinePoint();
                Transformation.Apply(debugPoints);
            }
        }

        internal SplineDefinition buffer = null;

        internal Vector2[] ParseVector2(string coord)
        {
            List<float> list = ParseFloatArray(coord.Substring(1));
            int count = list.Count / 2;
            if (count == 0)
            {
                Debug.Log("Error in " + coord);
                return new Vector2[] { Vector2.zero };
            }
            Vector2[] vectors = new Vector2[count];
            for (int i = 0; i < count; i++)
            {
                vectors[i] = new Vector2(list[0 + i * 2], -list[1 + i * 2]);
            }
            return vectors;
        }

        internal float[] ParseFloat(string coord)
        {
            List<float> list = ParseFloatArray(coord.Substring(1));
            if (list.Count < 1)
            {
                Debug.Log("Error in " + coord);
                return new float[] { 0f };
            }
            return list.ToArray();
        }

        internal List<float> ParseFloatArray(string content)
        {
            string accumulated = "";
            List<float> list = new List<float>();
            foreach (char c in content)
            {
                if (c == ',' || c == '-' || char.IsWhiteSpace(c) || (accumulated.Contains(".") && c == '.'))
                {
                    if (!IsWHiteSpace(accumulated))
                    {
                        float parsed = 0f;
                        float.TryParse(accumulated, style, culture, out parsed);
                        list.Add(parsed);
                        accumulated = "";
                        if (c == '-') accumulated = "-";
                        if (c == '.') accumulated = "0.";
                        continue;
                    }
                }
                if (!char.IsWhiteSpace(c)) accumulated += c;
            }
            if (!IsWHiteSpace(accumulated))
            {
                float p = 0f;
                float.TryParse(accumulated, style, culture, out p);
                list.Add(p);
            }
            return list;
        }

        public bool IsWHiteSpace(string s)
        {
            foreach (char c in s)
            {
                if (!char.IsWhiteSpace(c))
                {
                    return false;
                }
            }
            return true;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/SplineParser.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/SVG.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9b2394d649216f5479fddeb2b08a6628
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Text.RegularExpressions;
using System.Linq;
using Dreamteck.Splines.Primitives;
using System;

namespace Dreamteck.Splines.IO
{
    public class SVG : SplineParser
    {
        public enum Axis { X, Y, Z }
        internal class PathSegment 
        {
            internal Vector3 startTangent = Vector3.zero;
            internal Vector3 endTangent = Vector3.zero;
            internal Vector3 endPoint = Vector3.zero;
            internal enum Type { Cubic, CubicShort, Quadratic, QuadraticShort }

            internal PathSegment(Vector2 s, Vector2 e, Vector2 c)
            {
                startTangent = s;
                endTangent = e;
                endPoint = c;
            }

            internal PathSegment()
            {

            }
        }

        public enum Element { All, Path, Polygon, Ellipse, Rectangle, Line }
        private System.Globalization.CultureInfo culture = new System.Globalization.CultureInfo("en-US");
        private System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Any;
        List<SplineDefinition> paths = new List<SplineDefinition>();
        List<SplineDefinition> polygons = new List<SplineDefinition>();
        List<SplineDefinition> ellipses = new List<SplineDefinition>();
        List<SplineDefinition> rectangles = new List<SplineDefinition>();
        List<SplineDefinition> lines = new List<SplineDefinition>();

        List<Transformation> transformBuffer = new List<Transformation>();

        public SVG(string filePath)
        {
            if (File.Exists(filePath))
            {
                string ext = Path.GetExtension(filePath).ToLower();
                fileName = Path.GetFileNameWithoutExtension(filePath);
                if (ext != ".svg" && ext != ".xml")
                {
                    Debug.LogError("SVG Parsing ERROR: Wrong format. Please use SVG or XML");
                    return;
                }
                XmlDocument doc = new XmlDocument();
                doc.XmlResolver = null;
                try
                {
                    doc.Load(filePath);
                }
                catch (XmlException ex)
                {
                    Debug.LogError(ex.Message);
                    return;
                }
                Read(doc);
            }
        }

        public SVG(List<SplineComputer> computers)
        {
            paths = new List<SplineDefinition>(computers.Count);
            for (int i = 0; i < computers.Count; i++)
            {
                if (computers[i] == null) continue;
                Spline spline = new Spline(computers[i].type, computers[i].sampleRate);
                spline.points = computers[i].GetPoints();
                if (spline.type != Spline.Type.Bezier && spline.type != Spline.Type.Linear) spline.CatToBezierTangents();
                if (computers[i].isClosed) spline.Close();
                paths.Add(new SplineDefinition(computers[i].name, spline));
            }
        }

        public void Write(string filePath, Axis ax = Axis.Z)
        {
            XmlDocument doc = new XmlDocument();
            XmlElement svg = doc.CreateElement("svg");
            foreach (SplineDefinition path in paths)
            {
                string elementName = "path";
                string attributeName = "d";
                if (path.type == Spline.Type.Linear)
                {
                    attributeName = "points";
                    if (path.closed) elementName = "polygon";
                    else elementName = "polyline";
                }
                XmlElement splineNode = doc.CreateElement(elementName);
                XmlAttribute splineAttribute = doc.CreateAttribute("id");
                splineAttribute.Value = path.name;
                splineNode.Attributes.Append(splineAttribute);
                splineAttribute = doc.CreateAttribute(attributeName);
                if (path.type == Spline.Type.Linear) splineAttribute.Value = EncodePolygon(path, ax);
                else splineAttribute.Value = EncodePath(path, ax);
                splineNode.Attributes.Append(splineAttribute);
                splineAttribute = doc.CreateAttribute("stroke");
                splineAttribute.Value = "black";
                splineNode.Attributes.Append(splineAttribute);
                splineAttribute = doc.CreateAttribute("stroke-width");
                splineAttribute.Value = "3";
                splineNode.Attributes.Append(splineAttribute);
                splineAttribute = doc.CreateAttribute("fill");
                splineAttribute.Value = "none";
                splineNode.Attributes.Append(splineAttribute);
                svg.AppendChild(splineNode);
            }
            XmlAttribute svgAttribute = doc.CreateAttribute("version");
            svgAttribute.Value = "1.1";
            svg.Attributes.Append(svgAttribute);
            svgAttribute = doc.CreateAttribute("xmlns");
            svgAttribute.Value = "http://www.w3.org/2000/svg";
            svg.Attributes.Append(svgAttribute);
            doc.AppendChild(svg);
            doc.Save(filePath);
        }

        Vector2 MapPoint(Vector3 original, Axis ax)
        {
            switch (ax)
            {
                case Axis.X: return new Vector2(original.z, -original.y);
                case Axis.Y: return new Vector2(original.x, -original.z);
                case Axis.Z: return new Vector2(original.x, -original.y);
            }
            return original;
        }

        private void Read(XmlDocument doc)
        {
            transformBuffer.Clear();
            Traverse(doc.ChildNodes);
        }

        private void Traverse(XmlNodeList nodes)
        {
            foreach (XmlNode node in nodes)
            {
                int addedTransforms = 0;
                switch (node.Name)
                {
                    case "g": addedTransforms = ParseTransformation(node); break;
                    case "path": addedTransforms = ReadPath(node); break;
                    case "polygon": addedTransforms = ReadPolygon(node, true); break;
                    case "polyline": addedTransforms = ReadPolygon(node, false); break;
                    case "ellipse": addedTransforms = ReadEllipse(node); break;
                    case "circle": addedTransforms = ReadEllipse(node); break;
                    case "line": addedTransforms = ReadLine(node); break;
                    case "rect": addedTransforms = ReadRectangle(node); break;
                }
                Traverse(node.ChildNodes);
                if (addedTransforms > 0) transformBuffer.RemoveRange(transformBuffer.Count - addedTransforms, addedTransforms);
            }
        }

        public List<SplineComputer> CreateSplineComputers(Vector3 position, Quaternion rotation, Element elements = Element.All)
        {
            List<SplineComputer> computers = new List<SplineComputer>();
            if (elements == Element.All || elements == Element.Path)
            {
                foreach (SplineDefinition definition in paths) computers.Add(definition.CreateSplineComputer(position, rotation));
            }
            if (elements == Element.All || elements == Element.Polygon)
            {
                foreach (SplineDefinition definition in polygons) computers.Add(definition.CreateSplineComputer(position, rotation));
            }
            if (elements == Element.All || elements == Element.Ellipse)
            {
                foreach (SplineDefinition definition in ellipses) computers.Add(definition.CreateSplineComputer(position, rotation));
            }
            if (elements == Element.All || elements == Element.Rectangle)
            {
                foreach (SplineDefinition definition in rectangles) computers.Add(definition.CreateSplineComputer(position, rotation));
            }
            if (elements == Element.All || elements == Element.Line)
            {
                foreach (SplineDefinition definition in lines) computers.Add(definition.CreateSplineComputer(position, rotation));
            }
            return computers;
        }

        public List<Spline> CreateSplines(Element elements = Element.All)
        {
            List<Spline> splines = new List<Spline>();
            if (elements == Element.All || elements == Element.Path)
            {
                foreach (SplineDefinition definition in paths) splines.Add(definition.CreateSpline());
            }
            if (elements == Element.All || elements == Element.Polygon)
            {
                foreach (SplineDefinition definition in polygons) splines.Add(definition.CreateSpline());
            }
            if (elements == Element.All || elements == Element.Ellipse)
            {
                foreach (SplineDefinition definition in ellipses) splines.Add(definition.CreateSpline());
            }
            if (elements == Element.All || elements == Element.Rectangle)
            {
                foreach (SplineDefinition definition in rectangles) splines.Add(definition.CreateSpline());
            }
            if (elements == Element.All || elements == Element.Line)
            {
                foreach (SplineDefinition definition in lines) splines.Add(definition.CreateSpline());
            }
            return splines;
        }

        private int ReadRectangle(XmlNode rectNode)
        {
            float x = 0f, y = 0f, w = 0f, h = 0f, rx = -1f, ry = -1f;
            string attribute = GetAttributeContent(rectNode, "x");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out x);
            attribute = GetAttributeContent(rectNode, "y");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out y);
            attribute = GetAttributeContent(rectNode, "width");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out w);
            attribute = GetAttributeContent(rectNode, "height");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out h);
            attribute = GetAttributeContent(rectNode, "rx");
            if (attribute != "ERROR") float.TryParse(attribute, style, culture, out rx);
            attribute = GetAttributeContent(rectNode, "ry");
            if (attribute != "ERROR") float.TryParse(attribute, style, culture, out ry);
            else ry = rx;
            string elementName = GetAttributeContent(rectNode, "id");

            if (rx == -1f && ry == -1f)
            {
                Rectangle rect = new Rectangle();
                rect.offset = new Vector2(x + w / 2f, -y - h / 2f);
                rect.size = new Vector2(w, h);
                if (elementName == "ERROR") elementName = fileName + "_rectangle" + (rectangles.Count + 1);
                buffer = new SplineDefinition(elementName, rect.CreateSpline());
            }
            else
            {
                RoundedRectangle rect = new RoundedRectangle();
                rect.offset = new Vector2(x + w / 2f, -y - h / 2f);
                rect.size = new Vector2(w, h);
                rect.xRadius = rx;
                rect.yRadius = ry;
                if (elementName == "ERROR") elementName = fileName + "_roundedRectangle" + (rectangles.Count + 1);
                buffer = new SplineDefinition(elementName, rect.CreateSpline());
            }
            int addedTransforms = ParseTransformation(rectNode);
            WriteBufferTo(rectangles);
            return addedTransforms;
        }

        private int ReadLine(XmlNode lineNode)
        {
            float startX = 0f, startY = 0f, endX = 0f, endY = 0f;
            string attribute = GetAttributeContent(lineNode, "x1");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out startX);
            attribute = GetAttributeContent(lineNode, "y1");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out startY);
            attribute = GetAttributeContent(lineNode, "x2");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out endX);
            attribute = GetAttributeContent(lineNode, "y2");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out endY);
            string elementName = GetAttributeContent(lineNode, "id");
            if (elementName == "ERROR") elementName = fileName + "_line" + (ellipses.Count + 1);
            buffer = new SplineDefinition(elementName, Spline.Type.Linear);
            buffer.position = new Vector2(startX, -startY);
            buffer.CreateLinear();
            buffer.position = new Vector2(endX, -endY);
            buffer.CreateLinear();
            int addedTransforms = ParseTransformation(lineNode);
            WriteBufferTo(lines);
            return addedTransforms;
        }

        private int ReadEllipse(XmlNode ellipseNode)
        {
            float x = 0f, y = 0f, rx = 0f, ry = 0f;
            string attribute = GetAttributeContent(ellipseNode, "cx");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out x);
            attribute = GetAttributeContent(ellipseNode, "cy");
            if (attribute == "ERROR") return 0;
            float.TryParse(attribute, style, culture, out y);
            attribute = GetAttributeContent(ellipseNode, "r");
            string shapeName = "circle";
            if (attribute == "ERROR") //It might be an ellipse
            {
                shapeName = "ellipse";
                attribute = GetAttributeContent(ellipseNode, "rx");
                if (attribute == "ERROR") return 0;
                float.TryParse(attribute, style, culture, out rx);
                attribute = GetAttributeContent(ellipseNode, "ry");
                if (attribute == "ERROR") return 0;
            }
            else //Nope, it's a circle
            {
                float.TryParse(attribute, style, culture, out rx);
                ry = rx;
            }
            float.TryParse(attribute, style, culture, out ry);
            Ellipse ellipse = new Ellipse();
            ellipse.offset = new Vector2(x, -y);
            ellipse.xRadius = rx;
            ellipse.yRadius = ry;

            string elementName = GetAttributeContent(ellipseNode, "id");
            if (elementName == "ERROR") elementName = fileName + "_" + shapeName + (ellipses.Count + 1);
            buffer = new SplineDefinition(elementName, ellipse.CreateSpline());
            int addedTransforms = ParseTransformation(ellipseNode);
            WriteBufferTo(ellipses);
            return addedTransforms;
        }

        private int ReadPolygon(XmlNode polyNode, bool closed)
        {
            string contents = GetAttributeContent(polyNode, "points");
            if (contents == "ERROR") return 0;
            List<float> coords = ParseFloatArray(contents);
            if (coords.Count % 2 != 0)
            {
                Debug.LogWarning("There is an error with one of the polygon shapes.");
                return 0;
            }
            string elementName = GetAttributeContent(polyNode, "id");
            if (elementName == "ERROR") elementName = fileName + (closed ? "_polygon " : "_polyline") + (polygons.Count + 1);
            buffer = new SplineDefinition(elementName, Spline.Type.Linear);
            int count = coords.Count / 2;
            for (int i = 0; i < count; i++)
            {
                buffer.position = new Vector2(coords[0 + 2 * i], -coords[1 + 2 * i]);
                buffer.CreateLinear();
            }
            if (closed)
            {
                buffer.CreateClosingPoint();
                buffer.closed = true;
            }
            int addedTransforms = ParseTransformation(polyNode);
            WriteBufferTo(polygons);
            return addedTransforms;
        }

        private int ParseTransformation(XmlNode node)
        {
            string transformAttribute = GetAttributeContent(node, "transform");
            if (transformAttribute == "ERROR") return 0;
            List<Transformation> trs = ParseTransformations(transformAttribute);
            transformBuffer.AddRange(trs);
            return trs.Count;
        }

        private List<Transformation> ParseTransformations(string transformContent)
        {
            List<Transformation> trs = new List<Transformation>();
            MatchCollection matches = Regex.Matches(transformContent.ToLower(), @"(?<function>translate|rotate|scale|skewx|skewy|matrix)\s*\((\s*(?<param>-?\s*\d+(\.\d+)?)\s*\,*\s*)+\)");
            foreach (Match match in matches)
            {
                if (match.Groups["function"].Success)
                {
                    CaptureCollection parameters = match.Groups["param"].Captures;
                    switch (match.Groups["function"].Value)
                    {
                        case "translate":
                            if (parameters.Count < 2) break;
                            trs.Add(new Translate(new Vector2(float.Parse(parameters[0].Value), float.Parse(parameters[1].Value))));
                            break;
                        case "rotate":
                            if (parameters.Count < 1) break;
                            trs.Add(new Rotate(float.Parse(parameters[0].Value)));
                            break;
                        case "scale":
                            if (parameters.Count < 2) break;
                            trs.Add(new Scale(new Vector2(float.Parse(parameters[0].Value), float.Parse(parameters[1].Value))));
                            break;
                        case "skewx":
                            if (parameters.Count < 1) break;
                            trs.Add(new SkewX(float.Parse(parameters[0].Value)));
                            break;
                        case "skewy":
                            if (parameters.Count < 1) break;
                            trs.Add(new SkewY(float.Parse(parameters[0].Value)));
                            break;
                        case "matrix":
                            if (parameters.Count < 6) break;
                            trs.Add(new MatrixTransform(float.Parse(parameters[0].Value), float.Parse(parameters[1].Value), float.Parse(parameters[2].Value), float.Parse(parameters[3].Value), float.Parse(parameters[4].Value), float.Parse(parameters[5].Value)));
                            break;
                    }
                }
            }
            return trs;
        }

        private int ReadPath(XmlNode pathNode)
        {
            string contents = GetAttributeContent(pathNode, "d");
            if (contents == "ERROR") return 0;
            string elementName = GetAttributeContent(pathNode, "id");
            if (elementName == "ERROR") elementName = fileName + "_path " + (paths.Count + 1);
            IEnumerable<string> tokens = Regex.Split(contents, @"(?=[A-Za-z])").Where(t => !string.IsNullOrEmpty(t));
            int numSplines = 0;
            foreach (string token in tokens)
            {
                char cmd = token.Substring(0, 1).Single();
                switch (cmd)
                {
                    case 'M':
                        PathStart(elementName, token, false);
                        ++numSplines;
                        break;
                    case 'm':
                        PathStart(elementName, token, true);
                        ++numSplines;
                        break;
                    case 'Z':
                        PathClose();
                        break;
                    case 'z':
                        PathClose();
                        break;
                    case 'L':
                        PathLineTo(token, false);
                        break;
                    case 'l':
                        PathLineTo(token, true);
                        break;
                    case 'H':
                        PathHorizontalLineTo(token, false);
                        break;
                    case 'h':
                        PathHorizontalLineTo(token, true);
                        break;
                    case 'V':
                        PathVerticalLineTo(token, false);
                        break;
                    case 'v':
                        PathVerticalLineTo(token, true);
                        break;
                    case 'C':
                        PathCurveTo(token, PathSegment.Type.Cubic, false);
                        break;
                    case 'c':
                        PathCurveTo(token, PathSegment.Type.Cubic, true);
                        break;
                    case 'S':
                        PathCurveTo(token, PathSegment.Type.CubicShort, false);
                        break;
                    case 's':
                        PathCurveTo(token, PathSegment.Type.CubicShort, true);
                        break;
                    case 'Q':
                        PathCurveTo(token, PathSegment.Type.Quadratic, false);
                        break;
                    case 'q':
                        PathCurveTo(token, PathSegment.Type.Quadratic, true);
                        break;
                    case 'T':
                        PathCurveTo(token, PathSegment.Type.QuadraticShort, false);
                        break;
                    case 't':
                        PathCurveTo(token, PathSegment.Type.QuadraticShort, true);
                        break;
                    case 'A':
                        PathArcTo(token, false);
                        break;
                    case 'a':
                        PathArcTo(token, true);
                        break;
                }
            }
            if (buffer != null) WriteBufferTo(paths);
            int addedTransforms = ParseTransformation(pathNode);
            for (int i = paths.Count - 1; i >= paths.Count - numSplines; --i) paths[i].Transform(transformBuffer);
            return addedTransforms;
        }

        private void PathStart(string name, string coords, bool relative)
        {
            if (buffer != null) WriteBufferTo(paths);
            buffer = new SplineDefinition(name, Spline.Type.Bezier);
            if (relative) buffer.position = paths.Last().GetLastPoint().position;
            Vector2[] vectors = ParseVector2(coords);
            foreach (Vector3 vector in vectors)
            {
                if (relative) buffer.position += vector;
                else buffer.position = vector;
                buffer.CreateLinear();
            }
        }

        private void PathClose()
        {
            buffer.CreateClosingPoint();
            buffer.closed = true;
        }

        private void PathLineTo(string coords, bool relative)
        {
            Vector2[] vectors = ParseVector2(coords);
            foreach (Vector3 vector in vectors)
            {
                if (relative) buffer.position += vector;
                else buffer.position = vector;
                buffer.CreateLinear();
            }
        }

        private void PathHorizontalLineTo(string coords, bool relative)
        {
            float[] floats = ParseFloat(coords);
            foreach (float f in floats)
            {
                if (relative) buffer.position.x += f;
                else buffer.position.x = f;
                buffer.CreateLinear();
            }
        }

        private void PathVerticalLineTo(string coords, bool relative)
        {
            float[] floats = ParseFloat(coords);
            foreach (float f in floats)
            {
                if (relative) buffer.position.y -= f;
                else buffer.position.y = -f;
                buffer.CreateLinear();
            }
        }

        private void PathCurveTo(string coords, PathSegment.Type type, bool relative)
        {
            PathSegment[] segment = ParsePathSegment(coords, type);
            for (int i = 0; i < segment.Length; i++)
            {
                SplinePoint p = buffer.GetLastPoint();
                p.type = SplinePoint.Type.Broken;

                //Get the control points
                Vector3 startPoint = p.position;
                Vector3 endPoint = segment[i].endPoint;
                Vector3 startTangent = segment[i].startTangent;
                Vector3 endTangent = segment[i].endTangent;

                switch (type)
                {
                    case PathSegment.Type.CubicShort: startTangent = startPoint - p.tangent; break;
                    case PathSegment.Type.Quadratic:
                        buffer.tangent = segment[i].startTangent;
                        startTangent = startPoint + 2f / 3f * (buffer.tangent - startPoint);
                        endTangent = endPoint + 2f / 3f * (buffer.tangent - endPoint);
                        break;
                    case PathSegment.Type.QuadraticShort:
                        Vector3 reflection = startPoint + (startPoint - buffer.tangent);
                        startTangent = startPoint + 2f / 3f * (reflection - startPoint);
                        endTangent = endPoint + 2f / 3f * (reflection - endPoint);
                        break;
                }

                if (type == PathSegment.Type.CubicShort || type == PathSegment.Type.QuadraticShort) p.type = SplinePoint.Type.SmoothMirrored; //Smooth the previous point
                else
                {
                    if (relative) p.SetTangent2Position(startPoint + startTangent);
                    else p.SetTangent2Position(startTangent);
                }
                buffer.SetLastPoint(p);
                if (relative)
                {
                    buffer.position += endPoint;
                    buffer.tangent = startPoint + endTangent;
                }
                else
                {
                    buffer.position = endPoint;
                    buffer.tangent = endTangent;
                }
                buffer.CreateBroken();
            }
        }

        private void PathArcTo(string coords, bool relative)
        {
            // Get Arc Arguments
            float[] floats = ParseFloat(coords);
            float rx = floats[0];
            float ry = floats[1];
            float rotation = floats[2] * Mathf.Deg2Rad;
            bool largeArc = floats[3] > 0.5f;
            bool sweep = floats[4] > 0.5f;
            float x = floats[5];
            float y = floats[6];

            // Set the last buffer point to broken
            SplinePoint p = buffer.GetLastPoint();
            p.type = SplinePoint.Type.Broken;

            // Get the start and end point. Note: Flip Y, as the Ellipse Parameters calculation assumes positive Y values
            Vector3 sp = p.position;
            sp.y *= -1;
            Vector3 ep = new Vector3(x, y, 0);
            if (relative) ep += sp;

            Vector2 c;
            float theta1;
            float sweepTheta;
            float adjustedRx;
            float adjustedRy;

            // Get the Ellipse Parameters
            CalculateEllipseParams(sp, ep, rotation, rx, ry, largeArc, sweep,
                out c, out theta1, out sweepTheta, out adjustedRx, out adjustedRy);

            // Flip the center Y back
            c.y *= -1;

            // Generate the ellipse primitive. Note: Rotated by -90 degrees and flipped, so first point starts at +X and goes clockwise
            Ellipse ellipse = new Ellipse();
            ellipse.offset = c;
            ellipse.rotation = new Vector3(0, 0, -90 - rotation * Mathf.Rad2Deg);
            ellipse.xRadius = adjustedRx;
            ellipse.yRadius = adjustedRy;
            var ellipseSpline = ellipse.CreateSpline();
            var esp = ellipseSpline.points;

            
            var tmpp = esp[1];
            esp[1] = esp[3];
            esp[3] = tmpp;
            for (int i = 0; i < esp.Length; i++)
            {
                FlipTangents(ref esp[i]);
            }

            // Find the percentages to sample the ellipse at
            var startP = theta1 / (Mathf.PI * 2);
            startP = ModP(startP, 1f);
            var sweepP = sweepTheta / (Mathf.PI * 2);
            var endP = startP + sweepP;

            var percentages = GetArcSegmentPercentages(startP, endP);

            // Sample the ellipse and add points to buffer
            for (int i = 1; i < percentages.Length; ++i)
            {
                double pp = percentages[i - 1];
                double pc = percentages[i];
                double pr = pc - pp;
                int sgn = Math.Sign(pr); // This sign indicates a reversed range if < 0; The sampled tangents need to be flipped if this is the case
                pr *= sgn;
                if (pr < 0.0001d) continue; // Sample error margin
                double d = 0.75d / pr;
                pc = ModP(pc, 1d);
                pp = ModP(pp, 1d);

                // New point in buffer
                Vector3 posc = Vector3.zero, tanc = Vector3.zero, tanp = Vector3.zero;
                ellipseSpline.EvaluatePosition(pc, ref posc);
                ellipseSpline.EvaluateTangent(pc, ref tanc);
                tanc *= sgn;
                tanc /= (float)d;
                buffer.position = posc;
                buffer.tangent = posc - tanc; 

                // Modify tangent2 of last point in buffer
                ellipseSpline.EvaluateTangent(pp, ref tanp);
                tanp *= sgn;
                tanp /= (float)d;
                p = buffer.GetLastPoint();
                p.type = SplinePoint.Type.Broken;
                p.SetTangent2Position(p.position + tanp);
                buffer.SetLastPoint(p);

                buffer.CreateBroken();
            }
        }

        private void FlipTangents(ref SplinePoint point)
        {
            var tmpt = point.tangent;
            point.tangent = point.tangent2;
            point.tangent2 = tmpt;
        }

        private void CalculateEllipseParams(Vector2 p0, Vector2 p1, float phi, float rx, float ry, bool fa, bool fs, out Vector2 c, out float theta1, out float sweepTheta, out float adjustedRx, out float adjustedRy)
        {
            // From https://observablehq.com/@toja/ellipse-and-elliptical-arc-conversion
            float sinPhi = Mathf.Sin(phi);
            float cosPhi = Mathf.Cos(phi);

            float x = cosPhi * (p0.x - p1.x) / 2 + sinPhi * (p0.y - p1.y) / 2;
            float y = -sinPhi * (p0.x - p1.x) / 2 + cosPhi * (p0.y - p1.y) / 2;

            float px = x * x, py = y * y, prx = rx * rx, pry = ry * ry;

            rx = Mathf.Abs(rx);
            ry = Mathf.Abs(ry);
            float l = px / prx + py / pry;
            if (l > 1)
            {
                float sqrtl = Mathf.Sqrt(l);
                rx = sqrtl * rx;
                ry = sqrtl * ry;
                prx = rx * rx;
                pry = ry * ry;
            }
            adjustedRx = rx;
            adjustedRy = ry;

            float sign = fa == fs ? -1 : 1;
            float m = Mathf.Sqrt((prx * pry - prx * py - pry * px) / (prx * py + pry * px)) * sign;

            float ccx = m * (rx * y) / ry;
            float ccy = m * (-ry * x) / rx;

            c = new Vector2(
                cosPhi * ccx - sinPhi * ccy + (p0.x + p1.x) / 2,
                sinPhi * ccx + cosPhi * ccy + (p0.y + p1.y) / 2
            );

            theta1 = VectorAngle(new Vector2(1, 0), new Vector2((x - ccx) / rx, (y - ccy) / ry));
            sweepTheta = VectorAngle(new Vector2((x - ccx) / rx, (y - ccy) / ry), new Vector2((-x - ccx) / rx, (-y - ccy) / ry));
            sweepTheta *= Mathf.Rad2Deg;
            sweepTheta %= 360;

            if (!fs && sweepTheta > 0) sweepTheta -= 360;
            if (fs && sweepTheta < 0) sweepTheta += 360;
            sweepTheta *= Mathf.Deg2Rad;
        }

        private double[] GetArcSegmentPercentages(double start, double end)
        {
            List<double> percentages = new List<double>();
            bool swap = start > end;
            if (swap) { double tmp = start; start = end; end = tmp; }

            percentages.Add(start);
            double rsM = Math.Ceiling(start * 4d) * 0.25d;
            if (rsM > end)
            {
                percentages.Add(end);
                return ReturnPercentage(swap, percentages);
            }
            else if (start < rsM)
            {
                percentages.Add(rsM);
            }

            double rem = rsM + 0.25d;
            for (; rem <= end; rem += 0.25d)
            {
                percentages.Add(rem);
            }
            rem -= 0.25d;
            if (rem < end)
            {
                percentages.Add(end);
            }

            return ReturnPercentage(swap, percentages);
        }

        private double[] ReturnPercentage(bool swap, List<double> percentages)
        {
            var ret = new double[percentages.Count];
            for (int i = 0; i < percentages.Count; ++i)
            {
                var r = swap ? percentages.Count - 1 - i : i;
                var p = percentages[r];
                ret[i] = p;
            }
            return ret;
        }

        private float VectorAngle(Vector2 u, Vector2 v)
        {
            float sign = u.x * v.y - u.y * v.x < 0 ? -1 : 1;
            float ua = Mathf.Sqrt(u.x * u.x + u.y * u.y);
            float va = Mathf.Sqrt(v.x * v.x + v.y * v.y);
            float dot = u.x * v.x + u.y * v.y;
            return sign * Mathf.Acos(dot / (ua * va));
        }

        private float ModP(float f, float div)
        {
            return ((f % div) + div) % div;
        }

        private double ModP(double d, double div)
        {
            return ((d % div) + div) % div;
        }

        private void WriteBufferTo(List<SplineDefinition> list)
        {
            buffer.Transform(transformBuffer);
            list.Add(buffer);
            buffer = null;
        }

        private PathSegment[] ParsePathSegment(string coord, PathSegment.Type type)
        {
            List<float> list = ParseFloatArray(coord.Substring(1));
            int count = 0;
            switch (type)
            {
                case PathSegment.Type.Cubic: count = list.Count / 6; break;
                case PathSegment.Type.Quadratic: count = list.Count / 4; break;
                case PathSegment.Type.CubicShort: count = list.Count / 4; break;
                case PathSegment.Type.QuadraticShort: count = list.Count / 2; break;
            }

            if (count == 0)
            {
                Debug.Log("Error in " + coord + " " + type);
                return new PathSegment[] { new PathSegment() };
            }
            PathSegment[] data = new PathSegment[count];
            for (int i = 0; i < count; i++)
            {
                switch (type)
                {
                    case PathSegment.Type.Cubic: data[i] = new PathSegment(new Vector2(list[0 + 6 * i], -list[1 + 6 * i]), new Vector2(list[2 + 6 * i], -list[3 + 6 * i]), new Vector2(list[4 + 6 * i], -list[5 + 6 * i])); break;
                    case PathSegment.Type.Quadratic: data[i] = new PathSegment(new Vector2(list[0 + 4 * i], -list[1 + 4 * i]), Vector2.zero, new Vector2(list[2 + 4 * i], -list[3 + 4 * i])); break;
                    case PathSegment.Type.CubicShort: data[i] = new PathSegment(Vector2.zero, new Vector2(list[0 + 4 * i], -list[1 + 4 * i]), new Vector2(list[2 + 4 * i], -list[3 + 4 * i])); break;
                    case PathSegment.Type.QuadraticShort: data[i] = new PathSegment(Vector2.zero, Vector2.zero, new Vector2(list[0 + 4 * i], -list[1 + 4 * i])); break;
                }
            }
            return data;
        }

        private string EncodePath(SplineDefinition definition, Axis ax)
        {
            string text = "M";
            for (int i = 0; i < definition.pointCount; i++)
            {
                SplinePoint p = definition.points[i];
                Vector3 tangent = MapPoint(p.tangent, ax);
                Vector3 position = MapPoint(p.position, ax);
                if (i == 0) text += position.x + "," + position.y;
                else
                {
                    SplinePoint lp = definition.points[i - 1];
                    Vector3 tangent2 = MapPoint(lp.tangent2, ax);
                    text += "C" + tangent2.x + "," + tangent2.y + "," + tangent.x + "," + tangent.y + "," + position.x + "," + position.y;
                }
            }
            if (definition.closed) text += "z";
            return text;
        }

        private string EncodePolygon(SplineDefinition definition, Axis ax)
        {
            string text = "";
            for (int i = 0; i < definition.pointCount; i++)
            {
                Vector3 position = MapPoint(definition.points[i].position, ax);
                if (text != "") text += ",";
                text += position.x + "," + position.y;
            }
            return text;
        }

        private string GetAttributeContent(XmlNode node, string attributeName)
        {
            for (int j = 0; j < node.Attributes.Count; j++)
            {
                if (node.Attributes[j].Name == attributeName) return node.Attributes[j].InnerText;
            }
            return "ERROR";
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/IO/SVG.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/ObjectSequence.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 810a671b1d2fb20408afff3c04f7be70
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines
{
    [System.Serializable]
    public class ObjectSequence<T>
    {
        public T startObject;
        public T endObject;
        public T[] objects;
        public enum Iteration { Ordered, Random }
        public Iteration iteration = Iteration.Ordered;
        public int randomSeed
        {
            get { return _randomSeed; }
            set
            {
                if (value != _randomSeed)
                {
                    _randomSeed = value;
                    randomizer = new System.Random(_randomSeed);
                }
            }
        }
        [SerializeField]
        [HideInInspector]
        private int _randomSeed = 1;
        [SerializeField]
        [HideInInspector]
        private int index = 0;
        [SerializeField]
        [HideInInspector]
        System.Random randomizer;
        
        public ObjectSequence(){
            randomizer = new System.Random(_randomSeed);
        }

        public T GetFirst()
        {
            if (startObject != null) return startObject;
            else return Next();
        }

        public T GetLast()
        {
            if (endObject != null) return endObject;
            else return Next();
        }

        public T Next()
        {
            if (iteration == Iteration.Ordered)
            {
                if (index >= objects.Length) index = 0;
                return objects[index++];
            } else
            {
                int randomIndex = randomizer.Next(objects.Length-1);
                return objects[randomIndex];
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/ObjectSequence.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Capsule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e39006c982d03b3409b070eab24d0843
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives
{
    public class Capsule : SplinePrimitive
    {
        public float radius = 1f;
        public float height = 2f;

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Bezier;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = true;
            CreatePoints(6, SplinePoint.Type.SmoothMirrored);
            points[0].position = Vector3.right / 2f * radius + Vector3.up * height * 0.5f;
            points[0].SetTangentPosition(points[0].position + Vector3.down * 2 * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
            points[1].position = Vector3.up / 2f * radius + Vector3.up * height * 0.5f;
            points[1].SetTangentPosition(points[1].position + Vector3.right * 2 * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
            points[2].position = Vector3.left / 2f * radius + Vector3.up * height * 0.5f;
            points[2].SetTangentPosition(points[2].position + Vector3.up * 2 * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
            points[3].position = Vector3.left / 2f * radius + Vector3.down * height * 0.5f;
            points[3].SetTangentPosition(points[3].position + Vector3.up * 2 * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
            points[4].position = Vector3.down / 2f * radius + Vector3.down * height * 0.5f;
            points[4].SetTangentPosition(points[4].position + Vector3.left * 2 * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
            points[5].position = Vector3.right / 2f * radius + Vector3.down * height * 0.5f;
            points[5].SetTangentPosition(points[5].position + Vector3.down * 2 * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Capsule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Ellipse.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4ff5eb5b93412154ea3ec2e48ca9ca4d
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine; 

namespace Dreamteck.Splines.Primitives
{
    public class Ellipse : SplinePrimitive
    {
        public float xRadius = 1f;
        public float yRadius = 1f;

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Bezier;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = true;
            CreatePoints(4, SplinePoint.Type.SmoothMirrored);
            points[0].position = Vector3.up * yRadius;
            points[0].SetTangentPosition(points[0].position + Vector3.right * 2 * (Mathf.Sqrt(2f) - 1f) / 1.5f * xRadius);
            points[1].position = Vector3.left * xRadius;
            points[1].SetTangentPosition(points[1].position + Vector3.up * 2 * (Mathf.Sqrt(2f) - 1f) / 1.5f * yRadius);
            points[2].position = Vector3.down * yRadius;
            points[2].SetTangentPosition(points[2].position + Vector3.left * 2 * (Mathf.Sqrt(2f) - 1f) / 1.5f * xRadius);
            points[3].position = Vector3.right * xRadius;
            points[3].SetTangentPosition(points[3].position + Vector3.down * 2 * (Mathf.Sqrt(2f) - 1f) / 1.5f * yRadius);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Ellipse.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Line.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8c7d365eea2f73048be2306c775e3df4
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives
{
    public class Line : SplinePrimitive
    {
        public bool mirror = true;
        public float length = 1f;
        public int segments = 1;

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Linear;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = false;
            CreatePoints(segments + 1, SplinePoint.Type.SmoothMirrored);
            Vector3 origin = Vector3.zero;
            if (mirror) origin = -Vector3.up * length * 0.5f;
            for (int i = 0; i < points.Length; i++)
            {
                points[i].position = origin + Vector3.up * length * ((float)i / (points.Length - 1));
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Line.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Ngon.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 79792b94d3f3fc2489022f36d48a41d4
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives
{
    public class Ngon : SplinePrimitive
    {
        public float radius = 1f;
        public int sides = 3;

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Linear;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = true;
            CreatePoints(sides, SplinePoint.Type.SmoothMirrored);
            for (int i = 0; i < sides; i++)
            {
                float percent = (float)i / sides;
                Vector3 pos = Quaternion.AngleAxis(360f * percent, Vector3.forward) * Vector3.up * radius;
                points[i].SetPosition(pos);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Ngon.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Rectangle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e39c41817ed55504cbef2a470c95599d
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives
{
    public class Rectangle : SplinePrimitive
    {
        public Vector2 size = Vector2.one;

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Linear;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = true;
            CreatePoints(4, SplinePoint.Type.SmoothMirrored);
            points[0].position = points[0].tangent = Vector3.up / 2f * size.y + Vector3.left / 2f * size.x;
            points[1].position = points[1].tangent = Vector3.up / 2f * size.y + Vector3.right / 2f * size.x;
            points[2].position = points[2].tangent = Vector3.down / 2f * size.y + Vector3.right / 2f * size.x;
            points[3].position = points[3].tangent = Vector3.down / 2f * size.y + Vector3.left / 2f * size.x;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Rectangle.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/RoundedRectangle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a6ad8207cf520e94aa15dea4fae0027d
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives
{
    public class RoundedRectangle : SplinePrimitive
    {
        public Vector2 size = Vector2.one;
        public float xRadius = 0.25f;
        public float yRadius = 0.25f;

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Bezier;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = true;
            CreatePoints(8, SplinePoint.Type.Broken);
            Vector2 edgeSize = size - new Vector2(xRadius, yRadius) * 2f;
            points[0].SetPosition(Vector3.up / 2f * edgeSize.y + Vector3.left / 2f * size.x);
            points[1].SetPosition(Vector3.up / 2f * size.y + Vector3.left / 2f * edgeSize.x);
            points[2].SetPosition(Vector3.up / 2f * size.y + Vector3.right / 2f * edgeSize.x);
            points[3].SetPosition(Vector3.up / 2f * edgeSize.y + Vector3.right / 2f * size.x);
            points[4].SetPosition(Vector3.down / 2f * edgeSize.y + Vector3.right / 2f * size.x);
            points[5].SetPosition(Vector3.down / 2f * size.y + Vector3.right / 2f * edgeSize.x);
            points[6].SetPosition(Vector3.down / 2f * size.y + Vector3.left / 2f * edgeSize.x);
            points[7].SetPosition(Vector3.down / 2f * edgeSize.y + Vector3.left / 2f * size.x);

            float xRad = 2f * (Mathf.Sqrt(2f) - 1f) / 3f * xRadius * 2f;
            float yRad = 2f * (Mathf.Sqrt(2f) - 1f) / 3f * yRadius * 2f;
            points[0].SetTangent2Position(points[0].position + Vector3.up * yRad);
            points[1].SetTangentPosition(points[1].position + Vector3.left * xRad);
            points[2].SetTangent2Position(points[2].position + Vector3.right * xRad);
            points[3].SetTangentPosition(points[3].position + Vector3.up * yRad);
            points[4].SetTangent2Position(points[4].position + Vector3.down * yRad);
            points[5].SetTangentPosition(points[5].position + Vector3.right * xRad);
            points[6].SetTangent2Position(points[6].position + Vector3.left * xRad);
            points[7].SetTangentPosition(points[7].position + Vector3.down * yRad);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/RoundedRectangle.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Spiral.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d4c765265077e6a4d9bc4e5d2cc75f3c
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives
{
    public class Spiral : SplinePrimitive
    {
        public float startRadius = 1f;
        public float endRadius = 1f;
        public float stretch = 1f;
        public int iterations = 3;
        public bool clockwise = true;
        public AnimationCurve curve = new AnimationCurve();

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Bezier;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = false;
            CreatePoints(iterations * 4 + 1, SplinePoint.Type.SmoothMirrored);
            float radiusDelta = Mathf.Abs(endRadius - startRadius);
            float radiusDeltaPercent = radiusDelta / Mathf.Max(Mathf.Abs(endRadius), Mathf.Abs(startRadius));
            float multiplier = 1f;
            if (endRadius > startRadius) multiplier = -1;
            float angle = 0f;
            float str = 0f;
            float angleDirection = clockwise ? 1f : -1f;
            for (int i = 0; i <= iterations * 4; i++)
            {
                float percent = curve.Evaluate((float)i / (iterations * 4));
                float radius = Mathf.Lerp(startRadius, endRadius, percent);
                Quaternion rot = Quaternion.AngleAxis(angle, Vector3.up);
                points[i].position = rot * Vector3.forward / 2f * radius + Vector3.up * str;
                Quaternion tangentRot = Quaternion.identity;
                if (multiplier > 0) tangentRot = Quaternion.AngleAxis(Mathf.Lerp(0f, 90f * 0.16f * angleDirection, radiusDeltaPercent * percent), Vector3.up);
                else tangentRot = Quaternion.AngleAxis(Mathf.Lerp(0f, -90f * 0.16f * angleDirection, (1f - percent) * radiusDeltaPercent), Vector3.up);
                if (clockwise) points[i].tangent = points[i].position - (tangentRot * rot * Vector3.right * radius + Vector3.up * stretch / 4f) * 2 * (Mathf.Sqrt(2f) - 1f) / 3f;
                else points[i].tangent = points[i].position + (tangentRot * rot * Vector3.right * radius - Vector3.up * stretch / 4f) * 2 * (Mathf.Sqrt(2f) - 1f) / 3f;
                points[i].tangent2 = points[i].position - (points[i].tangent - points[i].position);
                str += stretch / 4f;
                angle += 90f * angleDirection;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Spiral.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/SplinePrimitive.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: acb225539fdaf0d479f2ca1a7694afcc
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives {
    public class SplinePrimitive
    {
        protected bool closed = false;
        protected SplinePoint[] points = new SplinePoint[0];

        public Vector3 offset = Vector3.zero;
        public Vector3 rotation = Vector3.zero;
        public bool is2D = false;

        public virtual void Calculate()
        {
            Generate();
            ApplyOffset();
        }

        protected virtual void Generate()
        {
        
        }

        public Spline CreateSpline()
        {
            Generate();
            ApplyOffset();
            Spline spline = new Spline(GetSplineType());
            spline.points = points;
            if (closed) spline.Close();
            return spline;
        }

        public void UpdateSpline(Spline spline)
        {
            Generate();
            ApplyOffset();
            spline.type = GetSplineType();
            spline.points = points;
            if (closed) spline.Close();
            else if (spline.isClosed) spline.Break();
        }

        public SplineComputer CreateSplineComputer(string name, Vector3 position, Quaternion rotation)
        {
            Generate();
            ApplyOffset();
            GameObject go = new GameObject(name);
            SplineComputer comp = go.AddComponent<SplineComputer>();
            comp.SetPoints(points, SplineComputer.Space.Local);
            if (closed) comp.Close();
            comp.transform.position = position;
            comp.transform.rotation = rotation;
            return comp;
        }

        public void UpdateSplineComputer(SplineComputer comp)
        {
            Generate();
            ApplyOffset();
            comp.type = GetSplineType();
            comp.SetPoints(points, SplineComputer.Space.Local);
            if (closed) comp.Close();
            else if (comp.isClosed) comp.Break();
        }

        public SplinePoint[] GetPoints()
        {
            return points;
        }

        public virtual Spline.Type GetSplineType()
        {
            return Spline.Type.CatmullRom;
        }

        public bool GetIsClosed()
        {
            return closed;
        }

        void ApplyOffset()
        {
            Quaternion freeRot = Quaternion.Euler(rotation);
            if (is2D) freeRot = Quaternion.AngleAxis(-rotation.z, Vector3.forward) * Quaternion.AngleAxis(90f, Vector3.right);
            for (int i = 0; i < points.Length; i++)
            {
                points[i].position = freeRot * points[i].position;
                points[i].tangent = freeRot *  points[i].tangent;
                points[i].tangent2 = freeRot * points[i].tangent2;
                points[i].normal = freeRot * points[i].normal;
            }
            for (int i = 0; i < points.Length; i++) points[i].SetPosition(points[i].position + offset);
        }

        protected void CreatePoints(int count, SplinePoint.Type type)
        {
            if (points.Length != count) points = new SplinePoint[count];
            for (int i = 0; i < points.Length; i++)
            {
                points[i].type = type;
                points[i].normal = Vector3.up;
                points[i].color = Color.white;
                points[i].size = 1f;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/SplinePrimitive.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Star.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 30808d4ccaa42844698780f3f2af4308
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Splines.Primitives
{
    public class Star : SplinePrimitive
    {
        public float radius = 1f;
        public float depth = 0.5f;
        public int sides = 5;

        public override Spline.Type GetSplineType()
        {
            return Spline.Type.Linear;
        }

        protected override void Generate()
        {
            base.Generate();
            closed = true;
            CreatePoints(sides * 2, SplinePoint.Type.SmoothMirrored);
            float innerRadius = radius * depth;
            for (int i = 0; i < sides * 2; i++)
            {
                float percent = (float)i / (float)(sides * 2);
                Vector3 pos = Quaternion.AngleAxis(180 + 360f * percent, Vector3.forward) * Vector3.up * ((float)i % 2f == 0 ? radius : innerRadius);
                points[i].SetPosition(pos);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Primitives/Star.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SampleCollection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2ab72bc0d28ecbe4c8a42a5e1c8e2da5
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using UnityEngine;

    [System.Serializable]
    public class SampleCollection
    {
        [HideInInspector]
        [UnityEngine.Serialization.FormerlySerializedAs("samples")]
        public SplineSample[] samples = new SplineSample[0];
        private static bool __useModifier = false;
        private static ISampleModifier __modifier = null;

        public int length
        {
            get { return samples.Length; }
        }
        public int[] optimizedIndices = new int[0];
        bool hasSamples
        {
            get { return samples.Length > 0; }
        }
        public SplineComputer.SampleMode sampleMode = SplineComputer.SampleMode.Default;
        private SplineSample _workSample = new SplineSample();

        public SampleCollection()
        {
        }

        public SampleCollection(SampleCollection input)
        {
            samples = input.samples;
            optimizedIndices = input.optimizedIndices;
            sampleMode = input.sampleMode;
        }

        public int GetClippedSampleCount(double clipFrom, double clipTo, out int startIndex, out int endIndex)
        {
            startIndex = endIndex = 0;
            if (sampleMode == SplineComputer.SampleMode.Default)
            {
                startIndex = DMath.FloorInt((samples.Length - 1) * clipFrom);
                endIndex = DMath.CeilInt((samples.Length - 1) * clipTo);
            }
            else
            {
                double clipFromLerp = 0.0, clipToLerp = 0.0;
                GetSamplingValues(clipFrom, out startIndex, out clipFromLerp);
                GetSamplingValues(clipTo, out endIndex, out clipToLerp);
                if (clipToLerp > 0.0 && endIndex < samples.Length - 1) endIndex++;
            }

            if (clipTo < clipFrom) //Handle looping segments
            {
                int toSamples = endIndex + 1;
                int fromSamples = samples.Length - startIndex;
                return toSamples + fromSamples;
            }
            return endIndex - startIndex + 1;
        }

        public void GetSamplingValues(double percent, out int sampleIndex, out double lerp)
        {
            lerp = 0.0;
            if (sampleMode == SplineComputer.SampleMode.Optimized)
            {
                double indexValue = percent * (optimizedIndices.Length - 1);
                int index = DMath.FloorInt(indexValue);
                sampleIndex = optimizedIndices[index];
                double lerpPercent = 0.0;
                if (index < optimizedIndices.Length - 1)
                {
                    //Percent 0-1 between the sampleIndex and the next sampleIndex
                    double indexLerp = indexValue - index;
                    double sampleIndexPercent = (double)index / (optimizedIndices.Length - 1);
                    double nextSampleIndexPercent = (double)(index + 1) / (optimizedIndices.Length - 1);
                    //Percent 0-1 of the sample between the sampleIndices' percents
                    lerpPercent = DMath.Lerp(sampleIndexPercent, nextSampleIndexPercent, indexLerp);
                }
                if (sampleIndex < samples.Length - 1)
                {
                    lerp = DMath.InverseLerp(samples[sampleIndex].percent, samples[sampleIndex + 1].percent, lerpPercent);
                }
                return;
            }

            sampleIndex = DMath.FloorInt(percent * (samples.Length - 1));
            lerp = (samples.Length - 1) * percent - sampleIndex;
        }

        /// <summary>
        /// Same as Spline.EvaluatePosition but the result is transformed by the computer's transform
        /// </summary>
        /// <param name="percent">Evaluation percent</param>
        /// <param name="mode">Mode to use the method in. Cached uses the cached samples while Calculate is more accurate but heavier</param>
        /// <returns></returns>
        public Vector3 EvaluatePosition(double percent)
        {
            if (!hasSamples) return Vector3.zero;
            int index;
            double lerp;
            GetSamplingValues(percent, out index, out lerp);
            if (lerp > 0.0)
            {
                return Vector3.Lerp(samples[index].position, samples[index + 1].position, (float)lerp);
            }
            return samples[index].position;
        }

        /// <summary>
        /// Same as Spline.Evaluate but the result is transformed by the computer's transform
        /// </summary>
        /// <param name="percent">Evaluation percent</param>
        /// <param name="mode">Mode to use the method in. Cached uses the cached samples while Calculate is more accurate but heavier</param>
        /// <returns></returns>
        public SplineSample Evaluate(double percent)
        {
            SplineSample result = new SplineSample();
            Evaluate(percent, ref result);
            return result;
        }

        /// <summary>
        /// Evaluates the sample collection and transforms the result by the <see cref="localToWorldMatrix"/>
        /// </summary>
        /// <param name="result"></param>
        /// <param name="percent"></param>
        public void Evaluate(double percent, ref SplineSample result)
        {
            if (!hasSamples)
            {
                result = new SplineSample();
                return;
            }
            int index;
            double lerp;
            GetSamplingValues(percent, out index, out lerp);
            if (lerp > 0.0)
            {
                SplineSample.Lerp(ref samples[index], ref samples[index + 1], lerp, ref result);
            }
            else
            {
                result.FastCopy(ref samples[index]);
            }
        }

        /// <summary>
        /// Evaluates the sample collection and transforms the results by the <see cref="localToWorldMatrix"/>
        /// </summary>
        /// <param name="from">Start position [0-1]</param>
        /// <param name="to">Target position [from-1]</param>
        /// <returns></returns>
        public void Evaluate(ref SplineSample[] results, double from = 0.0, double to = 1.0)
        {
            if (!hasSamples)
            {
                results = new SplineSample[0];
                return;
            }
            Spline.FormatFromTo(ref from, ref to);
            int fromIndex, toIndex;
            double lerp;
            GetSamplingValues(from, out fromIndex, out lerp);
            GetSamplingValues(to, out toIndex, out lerp);
            if (lerp > 0.0 && toIndex < samples.Length - 1)
            {
                toIndex++;
            }
            int clippedIterations = toIndex - fromIndex + 1;
            if (results == null)
            {
                results = new SplineSample[clippedIterations];
            }
            else if (results.Length != clippedIterations)
            {
                results = new SplineSample[clippedIterations];
            }

            results[0] = Evaluate(from);
            results[results.Length - 1] = Evaluate(to);
            for (int i = 1; i < results.Length - 1; i++)
            {
                results[i].FastCopy(ref samples[i + fromIndex]);
            }
        }

        /// <summary>
        /// Same as Spline.EvaluatePositions but the results are transformed by the computer's transform
        /// </summary>
        /// <param name="from">Start position [0-1]</param>
        /// <param name="to">Target position [from-1]</param>
        /// <returns></returns>
        public void EvaluatePositions(ref Vector3[] positions, double from = 0.0, double to = 1.0)
        {
            if (!hasSamples)
            {
                positions = new Vector3[0];
                return;
            }

            Spline.FormatFromTo(ref from, ref to);
            int fromIndex, toIndex;
            double lerp;
            GetSamplingValues(from, out fromIndex, out lerp);
            GetSamplingValues(to, out toIndex, out lerp);
            if (lerp > 0.0 && toIndex < samples.Length - 1)
            {
                toIndex++;
            }
            int clippedIterations = toIndex - fromIndex + 1;

            if (positions == null)
            {
                positions = new Vector3[clippedIterations];
            }
            else if (positions.Length != clippedIterations)
            {
                positions = new Vector3[clippedIterations];
            }

            positions[0] = EvaluatePosition(from);
            positions[positions.Length - 1] = EvaluatePosition(to);
            for (int i = 1; i < positions.Length - 1; i++)
            {
                positions[i] = samples[i + fromIndex].position;
            }
        }

        /// <summary>
        /// Returns the percent from the spline at a given distance from the start point
        /// </summary>
        /// <param name="start">The start point</param>
        /// <param name="distance">The distance to travel</param>
        /// <param name="direction">The direction towards which to move</param>
        /// <returns></returns>
        public double Travel(double start, float distance, Spline.Direction direction, out float moved, double clipFrom = 0.0, double clipTo = 1.0)
        {
            moved = 0f;
            if (!hasSamples) return 0.0;
            if (direction == Spline.Direction.Forward && start >= 1.0) return clipTo;
            else if (direction == Spline.Direction.Backward && start <= 0.0) return clipFrom;

            double lastPercent = start;
            if (distance == 0f) return lastPercent;
            Vector3 lastPos = EvaluatePosition(start);
            int sampleIndex;
            double lerp;
            GetSamplingValues(lastPercent, out sampleIndex, out lerp);
            if (direction == Spline.Direction.Forward && lerp > 0.0) sampleIndex++;
            float lastDistance = 0f;
            int minIndex = 0;
            int maxIndex = samples.Length - 1;

            bool samplesAreLooped = clipTo < clipFrom;

            if (samplesAreLooped)
            {
                GetSamplingValues(clipFrom, out minIndex, out lerp);
                GetSamplingValues(clipTo, out maxIndex, out lerp);
                if (lerp > 0.0) maxIndex++;
            }

            while (moved < distance)
            {
                Vector3 transformedPos = samples[sampleIndex].position;
                lastDistance = Vector3.Distance(transformedPos, lastPos);
                moved += lastDistance;
                if (moved >= distance) break;
                lastPos = transformedPos;
                lastPercent = samples[sampleIndex].percent;
                if (direction == Spline.Direction.Forward)
                {
                    if (sampleIndex == samples.Length - 1)
                    {
                        if (samplesAreLooped)
                        {
                            lastPos = samples[0].position;
                            lastPercent = samples[0].percent;
                            sampleIndex = 1;
                        }
                        else break;
                    }
                    if (samplesAreLooped && sampleIndex == maxIndex) break;
                    sampleIndex++;
                }
                else
                {
                    if (sampleIndex == 0)
                    {
                        if (samplesAreLooped)
                        {
                            lastPos = samples[samples.Length - 1].position;
                            lastPercent = samples[samples.Length - 1].percent;
                            sampleIndex = samples.Length - 2;
                        }
                        else break;
                    }
                    if (samplesAreLooped && sampleIndex == minIndex) break;
                    sampleIndex--;
                }
            }
            float moveExcess = 0f;
            if (moved > distance)
            {
                moveExcess = moved - distance;
            }


            double lerpPercent = 0.0;
            if(lastDistance > 0.0)
            {
                lerpPercent = moveExcess / lastDistance;
            }
            double p = DMath.Lerp(lastPercent, samples[sampleIndex].percent, 1f - lerpPercent);
            moved -= moveExcess;
            return p;
        }

        /// <summary>
        /// Returns the percent from the spline at a given distance from the start point while applying a local <paramref name="offset"/> to each sample
        /// The offset is multiplied by the sample sizes
        /// </summary>
        /// <param name="start">The start point</param>
        /// /// <param name="distance">The distance to travel</param>
        /// <param name="direction">The direction towards which to move</param>
        /// <returns></returns>
        public double TravelWithOffset(double start, float distance, Spline.Direction direction, Vector3 offset, out float moved, double clipFrom = 0.0, double clipTo = 1.0)
        {
            moved = 0f;
            if (!hasSamples) return 0.0;
            if (direction == Spline.Direction.Forward && start >= 1.0) return clipTo;
            else if (direction == Spline.Direction.Backward && start <= 0.0) return clipFrom;

            double lastPercent = start;
            if (distance == 0f) return lastPercent;

            Evaluate(start, ref _workSample);
            Vector3 lastPos = _workSample.position + _workSample.up * (offset.y * _workSample.size) + _workSample.right * (offset.x * _workSample.size) + _workSample.forward * (offset.z * _workSample.size);

            int sampleIndex;
            double lerp;
            GetSamplingValues(lastPercent, out sampleIndex, out lerp);
            if (direction == Spline.Direction.Forward && lerp > 0.0) sampleIndex++;
            float lastDistance = 0f;
            int minIndex = 0;
            int maxIndex = length - 1;

            bool samplesAreLooped = clipTo < clipFrom;

            if (samplesAreLooped)
            {
                GetSamplingValues(clipFrom, out minIndex, out lerp);
                GetSamplingValues(clipTo, out maxIndex, out lerp);
                if (lerp > 0.0) maxIndex++;
            }

            while (moved < distance)
            {
                Vector3 newPos = samples[sampleIndex].position +
                    samples[sampleIndex].up * (offset.y * samples[sampleIndex].size) +
                    samples[sampleIndex].right * (offset.x * samples[sampleIndex].size) +
                    samples[sampleIndex].forward * (offset.z * samples[sampleIndex].size);
                lastDistance = Vector3.Distance(newPos, lastPos);
                moved += lastDistance;
                if (moved >= distance)
                {
                    break;
                }
                lastPos = newPos;
                lastPercent = samples[sampleIndex].percent;
                if (direction == Spline.Direction.Forward)
                {
                    if (sampleIndex == length - 1)
                    {
                        if (samplesAreLooped)
                        {
                            lastPos = samples[0].position +
                                samples[0].up * (offset.y * samples[0].size) +
                                samples[0].right * (offset.x * samples[0].size) +
                                samples[0].forward * (offset.z * samples[0].size);
                            lastPercent = samples[0].percent;
                            sampleIndex = 1;
                        }
                        else break;
                    }
                    if (samplesAreLooped && sampleIndex == maxIndex) break;
                    sampleIndex++;
                }
                else
                {
                    if (sampleIndex == 0)
                    {
                        if (samplesAreLooped)
                        {
                            int lastIndex = samples.Length - 1;
                            lastPos = samples[lastIndex].position +
                                samples[lastIndex].up * (offset.y * samples[lastIndex].size) +
                                samples[lastIndex].right * (offset.x * samples[lastIndex].size) +
                                samples[lastIndex].forward * (offset.z * samples[lastIndex].size);
                            lastPercent = samples[lastIndex].percent;
                            sampleIndex = samples.Length - 2;
                        }
                        else break;
                    }
                    if (samplesAreLooped && sampleIndex == minIndex) break;
                    sampleIndex--;
                }
            }
            float moveExcess = 0f;
            if (moved > distance)
            {
                moveExcess = moved - distance;
            }

            double p = DMath.Lerp(lastPercent, samples[sampleIndex].percent, 1f - moveExcess / lastDistance);
            moved -= moveExcess;
            return p;
        }

        public double Travel(double start, float distance, Spline.Direction direction = Spline.Direction.Forward)
        {
            float moved;
            return Travel(start, distance, direction, out moved);
        }

        private Vector3 GetModifiedPosition(ref SplineSample sample)
        {
            if (!__useModifier) return sample.position;
            return __modifier.GetModifiedSamplePosition(ref sample);
        }

        /// <summary>
        /// Same as Spline.Project but the point is transformed by the computer's transform.
        /// </summary>
        /// <param name="position">Point in space</param>
        /// <param name="subdivide">Subdivisions default: 4</param>
        /// <param name="from">Sample from [0-1] default: 0f</param>
        /// <param name="to">Sample to [0-1] default: 1f</param>
        /// <param name="mode">Mode to use the method in. Cached uses the cached samples while Calculate is more accurate but heavier</param>
        /// <param name="subdivisions">Subdivisions for the Calculate mode. Don't assign if not using Calculated mode.</param>
        /// <returns></returns>
        public void Project(Vector3 position, int controlPointCount, ref SplineSample result, double from = 0.0, double to = 1.0, ISampleModifier modifier = null)
        {
            if (!hasSamples) return;
            if (samples.Length == 1)
            {
                result.FastCopy(ref samples[0]);
                return;
            }
            __useModifier = modifier != null;
            __modifier = modifier;
            Spline.FormatFromTo(ref from, ref to);
            //First make a very rough sample of the from-to region
            int steps = (controlPointCount - 1) * 4; //Sampling four points per segment is enough to find the closest point range
            int step = samples.Length / steps;
            if (step < 1) step = 1;

            float minDist = (position - GetModifiedPosition(ref samples[0])).sqrMagnitude;
            int fromIndex = 0;
            int toIndex = samples.Length - 1;
            double lerp;
            if (from != 0.0) GetSamplingValues(from, out fromIndex, out lerp);
            if (to != 1.0)
            {
                GetSamplingValues(to, out toIndex, out lerp);
                if (lerp > 0.0 && toIndex < samples.Length - 1) toIndex++;
            }
            int checkFrom = fromIndex;
            int checkTo = toIndex;

            //Find the closest point range which will be checked in detail later
            for (int i = fromIndex; i < toIndex; i += step)
            {
                if (i >= toIndex) i = toIndex-1;
                Vector3 pos1 = GetModifiedPosition(ref samples[i]);
                Vector3 pos2 = GetModifiedPosition(ref samples[Mathf.Min(i + step, toIndex)]);
                Vector3 projected = LinearAlgebraUtility.ProjectOnLine(pos1, pos2, position);
                float dist = (position - projected).sqrMagnitude;
                if (dist < minDist)
                {
                    minDist = dist;
                    checkFrom = Mathf.Max(i - step, 0);
                    checkTo = Mathf.Min(i + step, samples.Length - 1);
                }
                if (i == toIndex) break;
            }
            minDist = (position - samples[checkFrom].position).sqrMagnitude;

            int index = checkFrom;
            //Find the closest result within the range
            for (int i = checkFrom + 1; i <= checkTo; i++)
            {
                float dist = (position - GetModifiedPosition(ref samples[i])).sqrMagnitude;
                if (dist < minDist)
                {
                    minDist = dist;
                    index = i;
                }
            }
            //Project the point on the line between the two closest samples
            int backIndex = index - 1;
            if (backIndex < 0) backIndex = 0;
            int frontIndex = index + 1;
            if (frontIndex > samples.Length - 1) frontIndex = samples.Length - 1;

            Vector3 backPos = GetModifiedPosition(ref samples[backIndex]);
            Vector3 currentPos = GetModifiedPosition(ref samples[index]);
            Vector3 frontPos = GetModifiedPosition(ref samples[frontIndex]);

            Vector3 back = LinearAlgebraUtility.ProjectOnLine(backPos, currentPos, position);
            Vector3 front = LinearAlgebraUtility.ProjectOnLine(currentPos, frontPos, position);
            float backLength = (currentPos - backPos).magnitude;
            float frontLength = (currentPos - frontPos).magnitude;
            float backProjectDist = (back - backPos).magnitude;
            float frontProjectDist = (front - frontPos).magnitude;
            if (backIndex < index && index < frontIndex)
            {
                if ((position - back).sqrMagnitude < (position - front).sqrMagnitude)
                {
                    SplineSample.Lerp(ref samples[backIndex], ref samples[index], backProjectDist / backLength, ref result);
                    if (sampleMode == SplineComputer.SampleMode.Uniform) result.percent = DMath.Lerp(GetSamplePercent(backIndex), GetSamplePercent(index), backProjectDist / backLength);
                }
                else
                {
                    SplineSample.Lerp(ref samples[frontIndex], ref samples[index], frontProjectDist / frontLength, ref result);
                    if (sampleMode == SplineComputer.SampleMode.Uniform) result.percent = DMath.Lerp(GetSamplePercent(frontIndex), GetSamplePercent(index), frontProjectDist / frontLength);
                }
            }
            else if (backIndex < index)
            {
                SplineSample.Lerp(ref samples[backIndex], ref samples[index], backProjectDist / backLength, ref result);
                if (sampleMode == SplineComputer.SampleMode.Uniform) result.percent = DMath.Lerp(GetSamplePercent(backIndex), GetSamplePercent(index), backProjectDist / backLength);
            }
            else
            {
                SplineSample.Lerp(ref samples[frontIndex], ref samples[index], frontProjectDist / frontLength, ref result);
                if (sampleMode == SplineComputer.SampleMode.Uniform) result.percent = DMath.Lerp(GetSamplePercent(frontIndex), GetSamplePercent(index), frontProjectDist / frontLength);
            }

            if (from == 0.0 && to == 1.0 && result.percent < samples[1].percent) //Handle looped splines
            {
                Vector3 pos1 = GetModifiedPosition(ref samples[samples.Length - 1]);
                Vector3 pos2 = GetModifiedPosition(ref samples[samples.Length - 2]);

                Vector3 projected = LinearAlgebraUtility.ProjectOnLine(pos1, pos2, position);
                if ((position - projected).sqrMagnitude < (position - result.position).sqrMagnitude)
                {
                    double l = LinearAlgebraUtility.InverseLerp(pos1, pos2, projected);
                    SplineSample.Lerp(ref samples[samples.Length - 1], ref samples[samples.Length - 2], l, ref result);
                    if (sampleMode == SplineComputer.SampleMode.Uniform) result.percent = DMath.Lerp(GetSamplePercent(samples.Length - 1), GetSamplePercent(samples.Length - 2), l);
                }
            }

            if (__useModifier)
            {
                modifier.ApplySampleModifiers(ref result);
            }
        }

        private double GetSamplePercent(int sampleIndex)
        {
            if (sampleMode == SplineComputer.SampleMode.Optimized)
            {
                return samples[optimizedIndices[sampleIndex]].percent;
            }
            return (double)sampleIndex / (samples.Length - 1);
        }

        /// <summary>
        /// Same as Spline.CalculateLength but this takes the computer's transform into account when calculating the length.
        /// </summary>
        /// <param name="from">Calculate from [0-1] default: 0f</param>
        /// <param name="to">Calculate to [0-1] default: 1f</param>
        /// <param name="resolution">Resolution [0-1] default: 1f</param>
        /// <param name="address">Node address of junctions</param>
        /// <returns></returns>
        public float CalculateLength(double from = 0.0, double to = 1.0, bool preventInvert = true)
        {
            if (!hasSamples) return 0f;
            Spline.FormatFromTo(ref from, ref to, preventInvert);
            float length = 0f;
            Vector3 lastPos = EvaluatePosition(from);
            int fromIndex, toIndex;
            double lerp;
            GetSamplingValues(from, out fromIndex, out lerp);
            GetSamplingValues(to, out toIndex, out lerp);

            if (lerp > 0.0 && toIndex < this.length - 1)
            {
                toIndex++;
            }

            for (int i = fromIndex + 1; i < toIndex; i++)
            {
                Vector3 currentPos = samples[i].position;
                length += Vector3.Distance(currentPos, lastPos);
                lastPos = currentPos;
            }
            length += Vector3.Distance(EvaluatePosition(to), lastPos);

            return length;
        }

        /// <summary>
        /// Calculates the length between <paramref name="from"/> and <paramref name="to"/> with applied local offset to to the samples
        /// The offset is multiplied by the sample sizes
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="offset"></param>
        /// <returns></returns>
        public float CalculateLengthWithOffset(Vector3 offset, double from = 0.0, double to = 1.0)
        {
            if (!hasSamples) return 0f;
            Spline.FormatFromTo(ref from, ref to);
            float length = 0f;
            Evaluate(from, ref _workSample);
            Vector3 lastPos = _workSample.position + _workSample.up * (offset.y * _workSample.size) + _workSample.right * (offset.x * _workSample.size) + _workSample.forward * (offset.z * _workSample.size);
            int fromIndex, toIndex;
            double lerp;
            GetSamplingValues(from, out fromIndex, out lerp);
            GetSamplingValues(to, out toIndex, out lerp);

            if (lerp > 0.0 && toIndex < this.length - 1)
            {
                toIndex++;
            }

            for (int i = fromIndex + 1; i < toIndex; i++)
            {
                Vector3 newPos = samples[i].position + samples[i].up * (offset.y * samples[i].size) + samples[i].right * (offset.x * samples[i].size) + samples[i].forward * (offset.z * samples[i].size);
                length += Vector3.Distance(newPos, lastPos);
                lastPos = newPos;
            }

            Evaluate(to, ref _workSample);
            _workSample.position += _workSample.up * (offset.y * _workSample.size) + _workSample.right * (offset.x * _workSample.size) + _workSample.forward * (offset.z * _workSample.size);
            length += Vector3.Distance(_workSample.position, lastPos);
            return length;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SampleCollection.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Spline.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d8bb4e3c138e5124b9ea58db9d93e1f4
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Dreamteck;

namespace Dreamteck.Splines {
    //The Spline class defines a spline with world coordinates. It comes with various sampling methods
    [System.Serializable]
    public class Spline {
        public enum Direction { Forward = 1, Backward = -1 }
        public enum Type { CatmullRom, BSpline, Bezier, Linear };
        public SplinePoint[] points = new SplinePoint[0];
        public Type type = Type.Bezier;
        public bool linearAverageDirection = true;
        public AnimationCurve customValueInterpolation = null;
        public AnimationCurve customNormalInterpolation = null;
        public int sampleRate = 10;

        /// <summary>
        /// Returns true if the spline is closed
        /// </summary>
        public bool isClosed
        {
            get
            {
                return closed && points.Length >= 3;
            }
        }
        /// <summary>
        /// The step size of the percent incrementation when evaluating a spline (based on percision)
        /// </summary>
        public double moveStep
        {
            get {
                if (type == Type.Linear) return 1f / (points.Length-1);
                return 1f / (iterations-1);
            }
            set { }
        }
       /// <summary>
        /// The total count of samples for the spline (based on the sample rate)
       /// </summary>
       public int iterations
        {
            get {
                if (type == Type.Linear) return closed ? points.Length + 1 : points.Length;
                int segments = closed ? points.Length : points.Length - 1;
                return sampleRate * segments - segments + 1;
            }
        }

        public float knotParametrization
        {
            get { return _knotParametrization; }
            set
            {
                _knotParametrization = Mathf.Clamp01(value);
            }
        }

        private static Vector3[] P = new Vector3[4];
        private static Vector3 A1;
        private static Vector3 A2;
        private static Vector3 A3;
        private static Vector3 B1;
        private static Vector3 B2;
        private static float t1;
        private static float t2;
        private static float t3;

        [SerializeField]
        private bool closed = false;
        [SerializeField, Range(0f, 1f)]
        private float _knotParametrization;

        public Spline(Type type){
			this.type = type;
			points = new SplinePoint[0];
		}

        public Spline(Type type, int sampleRate)
        {
            this.type = type;
            this.sampleRate = sampleRate;
            points = new SplinePoint[0];
        }

        /// <summary>
        /// Calculate the length of the spline
        /// </summary>
        /// <param name="from">Calculate from [0-1] default: 0f</param>
        /// <param name="to">Calculate to [0-1] default: 1f</param>
        /// <param name="resolution">Resolution multiplier for precision [0-1] default: 1f</param>
        /// <returns></returns>
        public float CalculateLength(double from = 0.0, double to = 1.0, double resolution = 1.0)
        {
            if (points.Length == 0) return 0f;
            resolution = DMath.Clamp01(resolution);
            if (resolution == 0.0) return 0f;
            from = DMath.Clamp01(from);
            to = DMath.Clamp01(to);
            if (to < from) to = from;
            double percent = from;
            Vector3 lastPos = EvaluatePosition(percent);
            float sum = 0f;
            while (true)
            {
                percent = DMath.Move(percent, to, moveStep / resolution);
                Vector3 pos = EvaluatePosition(percent);
                sum += (pos - lastPos).magnitude;
                lastPos = pos;
                if (percent == to) break;
            }
            return sum;
        }

        /// <summary>
        /// Project point on the spline. Returns evaluation percent.
        /// </summary>
        /// <param name="position">3D Point</param>
        /// <param name="subdivide">Subdivisions default: 4</param>
        /// <param name="from">Sample from [0-1] default: 0f</param>
        /// <param name="to">Sample to [0-1] default: 1f</param>
        /// <returns></returns>
        public double Project(Vector3 position, int subdivide = 4, double from = 0.0, double to = 1.0)
        {
            if (points.Length == 0) return 0.0;
            if (closed && from == 0.0 && to == 1.0) //Handle looped splines
            {
                double closest = GetClosestPoint(subdivide, position, from, to, Mathf.RoundToInt(Mathf.Max(iterations / points.Length, 10)) * 5);
                if (closest < moveStep)
                {
                    double nextClosest = GetClosestPoint(subdivide, position, 0.5, to, Mathf.RoundToInt(Mathf.Max(iterations / points.Length, 10)) * 5);
                    if (Vector3.Distance(position, EvaluatePosition(nextClosest)) < Vector3.Distance(position, EvaluatePosition(closest))) return nextClosest;
                }
                return closest;
            }
            return GetClosestPoint(subdivide, position, from, to, Mathf.RoundToInt(Mathf.Max(iterations / points.Length, 10)) * 5);
        }

        /// <summary>
        /// Casts rays along the spline against all colliders in the scene
        /// </summary>
        /// <param name="hit">Hit information</param>
        /// <param name="hitPercent">The percent of evaluation where the hit occured</param>
        /// <param name="layerMask">Layer mask for the raycast</param>
        /// <param name="resolution">Resolution multiplier for precision [0-1] default: 1f</param>
        /// <param name="from">Raycast from [0-1] default: 0f</param>
        /// <param name="to">Raycast to [0-1] default: 1f</param>
        /// <param name="hitTriggers">Should hit triggers? (not supported in 5.1)</param>
        /// <returns></returns>
        public bool Raycast(out RaycastHit hit, out double hitPercent, LayerMask layerMask, double resolution = 1.0, double from = 0.0, double to = 1.0, QueryTriggerInteraction hitTriggers = QueryTriggerInteraction.UseGlobal
        )
        {
            resolution = DMath.Clamp01(resolution);
            from = DMath.Clamp01(from);
            to = DMath.Clamp01(to);
            double percent = from;
            Vector3 fromPos = EvaluatePosition(percent);
            hitPercent = 0f;
            if (resolution == 0f)
            {
                hit = new RaycastHit();
                hitPercent = 0f;
                return false;
            }
            while (true)
            {
                double prevPercent = percent;
                percent = DMath.Move(percent, to, moveStep / resolution);
                Vector3 toPos = EvaluatePosition(percent);
                if (Physics.Linecast(fromPos, toPos, out hit, layerMask, hitTriggers))
                {
                    double segmentPercent = (hit.point - fromPos).sqrMagnitude / (toPos - fromPos).sqrMagnitude;
                    hitPercent = DMath.Lerp(prevPercent, percent, segmentPercent);
                    return true;
                }
                fromPos = toPos;
                if (percent == to) break;
            }
            return false;
        }


        /// <summary>
        /// Casts rays along the spline against all colliders in the scene and returns all hits. Order is not guaranteed.
        /// </summary>
        /// <param name="hits">Hit information</param>
        /// <param name="hitPercents">The percents of evaluation where each hit occured</param>
        /// <param name="layerMask">Layer mask for the raycast</param>
        /// <param name="resolution">Resolution multiplier for precision [0-1] default: 1f</param>
        /// <param name="from">Raycast from [0-1] default: 0f</param>
        /// <param name="to">Raycast to [0-1] default: 1f</param>
        /// <param name="hitTriggers">Should hit triggers? (not supported in 5.1)</param>
        /// <returns></returns>
        public bool RaycastAll(out RaycastHit[] hits, out double[] hitPercents, LayerMask layerMask, double resolution = 1.0, double from = 0.0, double to = 1.0, QueryTriggerInteraction hitTriggers = QueryTriggerInteraction.UseGlobal
            )
        {
            resolution = DMath.Clamp01(resolution);
            from = DMath.Clamp01(from);
            to = DMath.Clamp01(to);
            double percent = from;
            Vector3 fromPos = EvaluatePosition(percent);
            List<RaycastHit> hitList = new List<RaycastHit>();
            List<double> percentList = new List<double>();
            if (resolution == 0f)
            {
                hits = new RaycastHit[0];
                hitPercents = new double[0];
                return false;
            }
            bool hasHit = false;
            while (true)
            {
                double prevPercent = percent;
                percent = DMath.Move(percent, to, moveStep / resolution);
                Vector3 toPos = EvaluatePosition(percent);
                RaycastHit[] h = Physics.RaycastAll(fromPos, toPos - fromPos, Vector3.Distance(fromPos, toPos), layerMask, hitTriggers);
                for (int i = 0; i < h.Length; i++)
                {
                    hasHit = true;
                    double segmentPercent = (h[i].point - fromPos).sqrMagnitude / (toPos - fromPos).sqrMagnitude;
                    percentList.Add(DMath.Lerp(prevPercent, percent, segmentPercent));
                    hitList.Add(h[i]);
                }
                fromPos = toPos;
                if (percent == to) break;
            }
            hits = hitList.ToArray();
            hitPercents = percentList.ToArray();
            return hasHit;
        } 

        /// <summary>
        /// Converts a point index to spline percent
        /// </summary>
        /// <param name="pointIndex">The point index</param>
        /// <returns></returns>
        public double GetPointPercent(int pointIndex)
        {
            if (closed)
            {
                return DMath.Clamp01((double)pointIndex / points.Length);
            }
            return DMath.Clamp01((double)pointIndex / (points.Length - 1));
        }

        /// <summary>
        /// Evaluate the spline and return position. This is simpler and faster than Evaluate.
        /// </summary>
        /// <param name="percent">Percent of evaluation [0-1]</param>
        public Vector3 EvaluatePosition(double percent)
        {
            if (points.Length == 0) return Vector3.zero;
            Vector3 position = new Vector3();
            EvaluatePosition(percent, ref position);
            return position;
        }

        /// <summary>
        /// Evaluate the spline at the given time and return a SplineSample
        /// </summary>
        /// <param name="percent">Percent of evaluation [0-1]</param>
        public SplineSample Evaluate(double percent)
        {
            SplineSample result = new SplineSample();
            Evaluate(percent, ref result);
            return result;
		}

        /// <summary>
        /// Evaluate the spline at the position of a given point and return a SplineSample
        /// </summary>
        /// <param name="pointIndex">Point index</param>
        public SplineSample Evaluate(int pointIndex)
        {
            SplineSample result = new SplineSample();
            Evaluate(GetPointPercent(pointIndex), ref result);
            return result;
        }

        /// <summary>
        /// Evaluate the splien at the given point and write the result to the "result" object
        /// </summary>
        /// <param name="result">The result output</param>
        /// <param name="pointIndex">Point index</param>
        public void Evaluate(int pointIndex, ref SplineSample result)
        {
            Evaluate(GetPointPercent(pointIndex), ref result);
        }

        /// <summary>
        /// Evaluate the splien at the given time and write the result to the "result" object
        /// </summary>
        /// <param name="sample">The result output</param>
        /// <param name="percent">Percent of evaluation [0-1]</param>
        public void Evaluate(double percent, ref SplineSample sample)
        {
            if (points.Length == 0)
            {
                sample = new SplineSample();
                return;
            }
            percent = DMath.Clamp01(percent);
            if (closed && points.Length <= 2)
            {
                closed = false;
            }
            if (points.Length == 1)
            {
                sample.position = points[0].position;
                sample.up = points[0].normal;
                sample.forward = Vector3.forward;
                sample.size = points[0].size;
                sample.color = points[0].color;
                sample.percent = percent;
                return;
            }

            double doubleIndex = (points.Length - 1) * percent;
            if (closed)
            {
                doubleIndex = points.Length * percent;
            }
            int fromIndex = DMath.FloorInt(doubleIndex);
            int toIndex = fromIndex + 1;
            if (closed)
            {
                if (fromIndex >= points.Length - 1)
                {
                    fromIndex = points.Length - 1;
                }
                if(toIndex > points.Length - 1)
                {
                    toIndex = 0;
                }
            } else
            {
                if(toIndex > points.Length-1)
                {
                    toIndex = points.Length - 1;
                }
            }
            double getPercent = doubleIndex - fromIndex;

            sample.percent = percent;

            float valueInterpolation = (float)getPercent;
            if (customValueInterpolation != null)
            {
                if (customValueInterpolation.length > 0)
                {
                    valueInterpolation = customValueInterpolation.Evaluate(valueInterpolation);
                }
            }
            float normalInterpolation = (float)getPercent;
            if (customNormalInterpolation != null)
            {
                if (customNormalInterpolation.length > 0)
                {
                    normalInterpolation = customNormalInterpolation.Evaluate(normalInterpolation);
                }
            }
            sample.size = Mathf.Lerp(points[fromIndex].size, points[toIndex].size, valueInterpolation);
            sample.color = Color.Lerp(points[fromIndex].color, points[toIndex].color, valueInterpolation);
            sample.up = Vector3.Slerp(points[fromIndex].normal, points[toIndex].normal, normalInterpolation);

            EvaluatePositionAndTangent(ref sample.position, ref sample.forward, percent);

            if (type == Type.BSpline)
            {
                double step = 1.0 / (iterations - 1);
                if (percent <= 1.0 - step && percent >= step)
                {
                    sample.forward = EvaluatePosition(percent + step) - EvaluatePosition(percent - step);
                }
                else
                {
                    Vector3 back = Vector3.zero, front = Vector3.zero;
                    if (closed)
                    {
                        if (percent < step) EvaluatePosition(1.0 - (step - percent), ref back);
                        else  EvaluatePosition(percent - step, ref back);
                        if (percent > 1.0 - step) EvaluatePosition(step - (1.0 - percent), ref front);
                        else EvaluatePosition(percent + step, ref front);
                        sample.forward = front - back;
                    }
                    else
                    {
                        EvaluatePosition(percent - step, ref back);
                        back = sample.position - back;
                        EvaluatePosition(percent + step, ref front);
                        front = front - sample.position;
                        sample.forward = Vector3.Slerp(front, back, back.magnitude / front.magnitude);
                    }
                }
            }
            
            sample.forward.Normalize();
        }

        [System.Obsolete("This override is obsolete. Use Evaluate(int pointIndex, ref SplineSample sample) instead")]
        public void Evaluate(ref SplineSample sample, int pointIndex)
        {
            Evaluate(pointIndex, ref sample);
        }

        [System.Obsolete("This override is obsolete. Use Evaluate(double percent, ref SplineSample sample) instead")]
        public void Evaluate(ref SplineSample sample, double percent)
        {
            Evaluate(percent, ref sample);
        }

        /// <summary>
        /// Evaluates the spline segment and writes the results to the array
        /// </summary>
        /// <param name="from">Start position [0-1]</param>
        /// <param name="to">Target position [from-1]</param>
        /// <returns></returns>
        public void Evaluate(ref SplineSample[] samples, double from = 0.0, double to = 1.0)
        {
            if (points.Length == 0) {
                samples = new SplineSample[0];
                return;
            }
            from = DMath.Clamp01(from);
            to = DMath.Clamp(to, from, 1.0);
            double fromValue = from * (iterations - 1);
            double toValue = to * (iterations - 1);
            int clippedIterations = DMath.CeilInt(toValue) - DMath.FloorInt(fromValue) + 1;
            if (samples == null) samples = new SplineSample[clippedIterations];
            else if (samples.Length != clippedIterations) samples = new SplineSample[clippedIterations];
            double percent = from;
            double ms = moveStep;
            int index = 0;
            while (true)
            {
                samples[index] = Evaluate(percent);
                index++;
                if (index >= samples.Length) break;
                percent = DMath.Move(percent, to, ms);
            }
        }

        /// <summary>
        /// Evaluates the spline segment and writes uniformly spaced results to the array
        /// </summary>
        /// <param name="from">Start position [0-1]</param>
        /// <param name="to">Target position [from-1]</param>
        /// <returns></returns>
        public void EvaluateUniform(ref SplineSample[] samples, ref double[] originalSamplePercents, double from = 0.0, double to = 1.0)
        {
            if (points.Length == 0)
            {
                samples = new SplineSample[0];
                return;
            }
            from = DMath.Clamp01(from);
            to = DMath.Clamp(to, from, 1.0);
            double fromValue = from * (iterations - 1);
            double toValue = to * (iterations - 1);
            int clippedIterations = DMath.CeilInt(toValue) - DMath.FloorInt(fromValue) + 1;
            if (samples == null || samples.Length != clippedIterations) samples = new SplineSample[clippedIterations];
            if (originalSamplePercents == null || originalSamplePercents.Length != clippedIterations)
            {
                originalSamplePercents = new double[clippedIterations];
            }
            float lengthStep = CalculateLength(from, to) / (iterations - 1);
            Evaluate(from, ref samples[0]);
            samples[0].percent = originalSamplePercents[0] = from;
            double lastPercent = from;
            float moved = 0f;
            for (int i = 1; i < samples.Length - 1; i++)
            {
                Evaluate(Travel(lastPercent, lengthStep, out moved, Direction.Forward), ref samples[i]);
                lastPercent = samples[i].percent;
                originalSamplePercents[i] = lastPercent;
                samples[i].percent = DMath.Lerp(from, to, (double)i/ (samples.Length - 1));
            }
            Evaluate(to, ref samples[samples.Length - 1]);
            samples[samples.Length - 1].percent = originalSamplePercents[originalSamplePercents.Length - 1] = to;
        }

        /// <summary>
        /// Evaluates the spline segment based on the spline's precision and returns only the position. 
        /// </summary>
        /// <param name="positions">The position buffer</param>
        /// <param name="from">Start position [0-1]</param>
        /// <param name="to">Target position [from-1]</param>
        /// <returns></returns>
        public void EvaluatePositions(ref Vector3[] positions, double from = 0.0, double to = 1.0)
        {
            if (points.Length == 0) {
                positions = new Vector3[0];
                return;
            }
            from = DMath.Clamp01(from);
            to = DMath.Clamp(to, from, 1.0);
            double fromValue = from * (iterations - 1);
            double toValue = to * (iterations - 1);
            int clippedIterations = DMath.CeilInt(toValue) - DMath.FloorInt(fromValue) + 1;
            if (positions.Length != clippedIterations) positions = new Vector3[clippedIterations];
            double percent = from;
            double ms = moveStep;
            int index = 0;
            while (true)
            {
                positions[index] = EvaluatePosition(percent);
                index++;
                if (index >= positions.Length) break;
                percent = DMath.Move(percent, to, ms);
            }
        }

        /// <summary>
        /// Returns the percent from the spline at a given distance from the start point
        /// </summary>
        /// <param name="start">The start point</param>
        /// /// <param name="distance">The distance to travel</param>
        /// <param name="direction">The direction towards which to move</param>
        /// <returns></returns>
        public double Travel(double start, float distance, out float moved, Direction direction)
        {
            moved = 0f;
            if (points.Length <= 1) return 0.0;
            if (direction == Direction.Forward && start >= 1.0) return 1.0;
            else if (direction == Direction.Backward && start <= 0.0) return 0.0; ;
            if (distance == 0f) return DMath.Clamp01(start);
            Vector3 pos = Vector3.zero;
            EvaluatePosition(start, ref pos);
            Vector3 lastPosition = pos;
            double lastPercent = start;
            int i = iterations - 1;
            int nextSampleIndex = direction == Spline.Direction.Forward ? DMath.CeilInt(start * i) : DMath.FloorInt(start * i);
            float lastDistance = 0f;
            double percent = start;
            while (true)
            {
                percent = (double)nextSampleIndex / i;
                pos = EvaluatePosition(percent);
                lastDistance = Vector3.Distance(pos, lastPosition);
                lastPosition = pos;
                moved += lastDistance;
                if (moved >= distance) break;
                lastPercent = percent;
                if (direction == Spline.Direction.Forward)
                {
                    if (nextSampleIndex == i) break;
                    nextSampleIndex++;
                }
                else
                {
                    if (nextSampleIndex == 0) break;
                    nextSampleIndex--;
                }
            }
            return DMath.Lerp(lastPercent, percent, 1f - (moved - distance) / lastDistance);
        }

        public double Travel(double start, float distance, Spline.Direction direction = Spline.Direction.Forward)
        {
            float moved;
            return Travel(start, distance, out moved, direction);
        }

        public void EvaluatePosition(double percent, ref Vector3 position)
        {
            if (points.Length == 0)
            {
                position = Vector3.zero;
                return;
            }

            if (points.Length == 1)
            {
                position = points[0].position;
                return;
            }

            percent = DMath.Clamp01(percent);
            double doubleIndex = (points.Length - 1) * percent;
            if (closed)
            {
                doubleIndex = points.Length * percent;
            }
            int pointIndex = DMath.FloorInt(doubleIndex);
            if (type == Type.Bezier)
            {
                pointIndex = Mathf.Clamp(pointIndex, 0, Mathf.Max(points.Length - 1, 0));
            }
            CalculatePosition(ref position, doubleIndex - pointIndex, pointIndex);
        }

        [System.Obsolete("This override is obsolete. Use EvaluatePosition(double percent, ref Vector3 position) instead")]

        public void EvaluatePosition(ref Vector3 position, double percent)
        {
            EvaluatePosition(percent, ref position);
        }

        public void EvaluateTangent(double percent, ref Vector3 tangent)
        {
            if (points.Length < 2)
            {
                tangent = Vector3.forward;
                return;
            }

            percent = DMath.Clamp01(percent);
            double doubleIndex = (points.Length - 1) * percent;
            if (closed)
            {
                doubleIndex = points.Length * percent;
            }
            int pointIndex = DMath.FloorInt(doubleIndex);
            if (type == Type.Bezier)
            {
                pointIndex = Mathf.Clamp(pointIndex, 0, Mathf.Max(points.Length - 1, 0));
            }
            CalculateTangent(ref tangent, doubleIndex - pointIndex, pointIndex);
        }

        public void EvaluatePositionAndTangent(ref Vector3 position, ref Vector3 tangent, double percent)
        {
            if (points.Length == 0)
            {
                position = Vector3.zero;
                tangent = Vector3.forward;
                return;
            }

            if (points.Length == 1)
            {
                position = points[0].position;
                tangent = Vector3.forward;
                return;
            }

            percent = DMath.Clamp01(percent);
            double doubleIndex = (points.Length - 1) * percent;
            if (closed)
            {
                doubleIndex = points.Length * percent;
            }
            int pointIndex = DMath.FloorInt(doubleIndex);
            if (type == Type.Bezier)
            {
                pointIndex = Mathf.Clamp(pointIndex, 0, Mathf.Max(points.Length - 1, 0));
            }
            CalculatePositionAndTangent(doubleIndex - pointIndex, pointIndex, ref position, ref tangent);
        }

        //Get closest point in spline segment. Used for projection
        private double GetClosestPoint(int iterations, Vector3 point, double start, double end, int slices)
        {
            if (iterations <= 0)
            {
                float startDist = (point - EvaluatePosition(start)).sqrMagnitude;
                float endDist = (point - EvaluatePosition(end)).sqrMagnitude;
                if (startDist < endDist) return start;
                else if (endDist < startDist) return end;
                else return (start + end) / 2;
            }
            double closestPercent = 0.0;
            float closestDistance = Mathf.Infinity;
            double tick = (end - start) / slices;
            double t = start;
            Vector3 pos = Vector3.zero;
            while (true)
            {
                EvaluatePosition(t, ref pos);
                float dist = (point - pos).sqrMagnitude;
                if (dist < closestDistance)
                {
                    closestDistance = dist;
                    closestPercent = t;
                }
                if (t == end) break;
                t = DMath.Move(t, end, tick);
            }
            double newStart = closestPercent - tick;
            if (newStart < start) newStart = start;
            double newEnd = closestPercent + tick;
            if (newEnd > end) newEnd = end;
            return GetClosestPoint(--iterations, point, newStart, newEnd, slices);
        }

        /// <summary>
        /// Break the closed spline
        /// </summary>
        public void Break()
        {
            Break(0);
        }

        /// <summary>
        /// Break the closed spline at given point
        /// </summary>
        /// <param name="at"></param>
        public void Break(int at)
        {
            if (!closed) return;
            if (at >= points.Length) return;
            if (at < 0) return;
            SplinePoint[] previousPoints = new SplinePoint[points.Length];
            points.CopyTo(previousPoints, 0);

            for (int i = at; i < previousPoints.Length; i++)
            {
                points[i - at] = previousPoints[i];
            }

            for (int i = 0; i < at; i++)
            {
                points[(points.Length - at) + i] = previousPoints[i];
            }

            closed = false;
        }

        /// <summary>
        /// Close the spline. This will cause the first and last points of the spline to merge
        /// </summary>
        public void Close()
        {
            if (points.Length < 3)
            {
                Debug.LogError("Points need to be at least 3 to close the spline");
                return;
            }
            closed = true;
        }

        /// <summary>
        /// Convert the spline to a Bezier path
        /// </summary>
        public void CatToBezierTangents()
        {
            switch (type)
            {
                case Type.Linear:
                    for (int i = 0; i < points.Length; i++)
                    {
                        points[i].type = SplinePoint.Type.Broken;
                        points[i].SetTangentPosition(points[i].position);
                        points[i].SetTangent2Position(points[i].position);
                    }
                    break;
                case Type.CatmullRom:
                    for (int i = 0; i < points.Length; i++)
                    {
                        points[i].type = SplinePoint.Type.SmoothMirrored;
                        double percent = GetPointPercent(i);
                        Vector3 tangent = Vector3.forward;
                        EvaluateTangent(percent, ref tangent);
                        if(_knotParametrization > 0f)
                        {
                            ComputeCatPoints(i);
                            points[i].SetTangent2Position(points[i].position + tangent.normalized * Vector3.Distance(P[0], P[2]) / 6f);
                        } else
                        {
                            points[i].SetTangent2Position(points[i].position + tangent / 3f);
                        }
                    }
                    break;
                case Type.BSpline:
                    //No BSPline support yet
                    break;
            }
            type = Type.Bezier;
        }

        /// <summary>
        /// Evaluates the position of the spline using one of the algorithms
        /// </summary>
        private void CalculatePosition(ref Vector3 position, double percent, int pointIndex)
        {
            switch (type)
            {
                case Type.CatmullRom:
                    ComputeCatPoints(pointIndex);
                    if (_knotParametrization < 0.000001f)
                    {
                        CalculateCatmullRomPositionFast(ref position, percent, pointIndex);
                    } else
                    {
                        CalculateCatmullRomComponents(percent);
                        CalculateCatmullRomPosition(percent, ref position);
                    }
                    break;
                case Type.Bezier: CalculateBezierPosition(ref position, percent, pointIndex); break;
                case Type.BSpline:
                    ComputeCatPoints(pointIndex);
                    CalculateBSplinePosition(ref position, percent, pointIndex); break;
                case Type.Linear:
                    ComputeCatPoints(pointIndex);
                    CalculateLinearPosition(ref position, percent, pointIndex); 
                    break;
            }
        }

        /// <summary>
        /// Evaluates the direction of the spline using one of the algorithms
        /// </summary>
        private void CalculateTangent(ref Vector3 tangent, double percent, int pointIndex)
        {
            switch (type)
            {
                case Type.CatmullRom:
                    ComputeCatPoints(pointIndex);
                    if (_knotParametrization < 0.000001f)
                    {
                        CalculateCatmullRomTangentFast(ref tangent, percent, pointIndex);
                    }
                    else
                    {
                        CalculateCatmullRomComponents(percent);
                        CalculateCatmullRomTangent(percent, ref tangent);
                    }
                    break;
                case Type.Bezier: 
                    CalculateBezierTangent(ref tangent, percent, pointIndex); 
                    break;
                case Type.Linear:
                    ComputeCatPoints(pointIndex);
                    CalculateLinearTangent(ref tangent, percent, pointIndex); 
                    break;
            }
        }

        /// <summary>
        /// Slightly faster than calling GetPoint and GetTangent separately
        /// </summary>
        private void CalculatePositionAndTangent(double percent, int pointIndex, ref Vector3 position, ref Vector3 tangent)
        {
            switch (type)
            {
                case Type.CatmullRom:
                    ComputeCatPoints(pointIndex);
                    if (_knotParametrization < 0.000001f)
                    {
                        CalculateCatmullRomPositionFast(ref position, percent, pointIndex);
                        CalculateCatmullRomTangentFast(ref tangent, percent, pointIndex);
                    }
                    else
                    {
                        CalculateCatmullRomComponents(percent);
                        CalculateCatmullRomPosition(percent, ref position);
                        CalculateCatmullRomTangent(percent, ref tangent);
                    }
                    break;
                case Type.Bezier: 
                    CalculateBezierPosition(ref position, percent, pointIndex);
                    CalculateBezierTangent(ref tangent, percent, pointIndex);
                    break;
                case Type.BSpline:
                    ComputeCatPoints(pointIndex);
                    CalculateBSplinePosition(ref position, percent, pointIndex); 
                    break;
                case Type.Linear:
                    ComputeCatPoints(pointIndex);
                    CalculateLinearPosition(ref position, percent, pointIndex);
                    CalculateLinearTangent(ref tangent, percent, pointIndex);
                    break;
            }
        }

        private void CalculateLinearPosition(ref Vector3 position, double t, int i)
        {
            if (points.Length == 0)
            {
                position = Vector3.zero;
                return;
            }

            position = Vector3.Lerp(P[1], P[2], (float)t);
        }

        private void CalculateLinearTangent(ref Vector3 tangent, double t, int i)
        {
            if (points.Length == 0)
            {
                tangent = Vector3.forward;
                return;
            }

            if (linearAverageDirection) tangent = Vector3.Slerp(P[1] - P[0], P[2] - P[1], 0.5f);
            else tangent = P[2] - P[1];
        }

        private void CalculateBSplinePosition(ref Vector3 position, double time, int i)
        {
            if (points.Length > 0) position = points[0].position;
            if (points.Length > 1)
            {
                float tf = (float)DMath.Clamp01(time);
                position = ((-P[0] + P[2]) / 2f 
                + tf * ((P[0] - 2f * P[1] + P[2]) / 2f 
                + tf * (-P[0] + 3f * P[1] - 3f * P[2] + P[3]) / 6f)) * tf 
                + (P[0] + 4f * P[1] + P[2]) / 6f;
            }
        }

        private void CalculateBezierPosition(ref Vector3 position, double t, int i)
        {
            if (points.Length > 0) position = points[0].position;
            else return;
            if (!closed && points.Length == 1) return;
            t = DMath.Clamp01(t);
            int it = i + 1;
            if (it >= points.Length)
            {
                it = 0;
            }

            float ft = (float)t;
            float nt = 1f - ft;
            position = nt * nt * nt * points[i].position + 
                3f * nt * nt * ft * points[i].tangent2 + 
                3f * nt * ft * ft * points[it].tangent + 
                ft * ft * ft * points[it].position;
        }

        private void CalculateBezierTangent(ref Vector3 tangent, double t, int i)
        {
            if (points.Length > 0) tangent = points[0].tangent;
            else return;
            if (!closed && points.Length == 1) return;
            t = DMath.Clamp01(t);
            int it = i + 1;
            if (it >= points.Length)
            {
                it = 0;
            }
            float ft = (float)t;
            float nt = 1f - ft;
            tangent = -3f * nt * nt * points[i].position + 
                3f * nt * nt * points[i].tangent2 - 
                6f * ft * nt * points[i].tangent2 - 
                3f * ft * ft * points[it].tangent + 
                6f * ft * nt * points[it].tangent + 
                3f * ft * ft * points[it].position;
           
        }

        private void CalculateCatmullRomComponents(double t)
        {
            const float t0 = 0f;
            t1 = GetInterval(P[0], P[1]);
            t2 = GetInterval(P[1], P[2]) + t1;
            t3 = GetInterval(P[2], P[3]) + t2;
            float tf = Mathf.LerpUnclamped(t1, t2, (float)t);

            A1 = (t1 - tf) / (t1 - t0) * P[0] + (tf - t0) / (t1 - t0) * P[1];
            A2 = (t2 - tf) / (t2 - t1) * P[1] + (tf - t1) / (t2 - t1) * P[2];
            A3 = (t3 - tf) / (t3 - t2) * P[2] + (tf - t2) / (t3 - t2) * P[3];

            B1 = (t2 - tf) / (t2 - t0) * A1 + (tf - t0) / (t2 - t0) * A2;
            B2 = (t3 - tf) / (t3 - t1) * A2 + (tf - t1) / (t3 - t1) * A3;
            

            float GetInterval(Vector3 a, Vector3 b)
            {
                return Mathf.Pow((a - b).sqrMagnitude, _knotParametrization * 0.5f);
            }
        }

        private void CalculateCatmullRomPosition(double t, ref Vector3 position)
        {
            float tf = Mathf.LerpUnclamped(t1, t2, (float)t);
            position = (t2 - tf) / (t2 - t1) * B1 + (tf - t1) / (t2 - t1) * B2;
        }

        private void CalculateCatmullRomTangent(double t, ref Vector3 tangent)
        {
            float tf = Mathf.LerpUnclamped(t1, t2, (float)t);
            Vector3 A1p = (P[1] - P[0]) / t1;
            Vector3 A2p = (P[2] - P[1]) / (t2 - t1);
            Vector3 A3p = (P[3] - P[2]) / (t3 - t2);

            Vector3 B1p = (A2 - A1) / t2  + (t2 - tf) / t2 * A1p + tf / t2  * A2p;
            Vector3 B2p = (A3 - A2) / (t3 - t1) + (t3 - tf) / (t3 - t1) * A2p + (tf - t1) / (t3 - t1) * A3p;

            tangent = (B2 - B1) / (t2 - t1) + (t2 - tf) / (t2 - t1) * B1p + (tf - t1) / (t2 - t1) * B2p;
        }

        private void CalculateCatmullRomPositionFast(ref Vector3 position, double t, int i)
        {
            float t1 = (float)t;
            float t2 = t1 * t1;
            float t3 = t2 * t1;
            if (points.Length > 0)
            {
                position = points[0].position;
            }

            if (!closed && i >= points.Length) return;

            if (points.Length > 1)
            {
                position = 0.5f * ((2f * P[1]) + (-P[0] + P[2]) * t1
                + (2f * P[0] - 5f * P[1] + 4f * P[2] - P[3]) * t2
                + (-P[0] + 3f * P[1] - 3f * P[2] + P[3]) * t3);
            }
        }

        private void CalculateCatmullRomTangentFast(ref Vector3 tangent, double t, int i)
        {
            float t1 = (float)t;
            float t2 = t1 * t1;
            if (!closed && i >= points.Length) return;
            if (points.Length > 1)
            {
                tangent = (6 * t2 - 6 * t1) * P[1]
                + (3 * t2 - 4 * t1 + 1) * (P[2] - P[0]) * 0.5f
                + (-6 * t2 + 6 * t1) * P[2]
                + (3 * t2 - 2 * t1) * (P[3] - P[1]) * 0.5f;
            }
        }

        private void ComputeCatPoints(int i)
        {
            int p1 = i - 1;
            int p2 = i;
            int p3 = i + 1;
            int p4 = i + 2;

            if (closed)
            {
                if(p1 < 0)
                {
                    p1 += points.Length;
                }
                if (p2 >= points.Length)
                {
                    p2 -= points.Length;
                }
                if (p3 >= points.Length)
                {
                    p3 -= points.Length;
                }
                if(p4 >= points.Length)
                {
                    p4 -= points.Length;
                }
                P[0] = points[p1].position;
                P[1] = points[p2].position;
                P[2] = points[p3].position;
                P[3] = points[p4].position;
            } else
            {
                if(p1 < 0)
                {
                    P[0] = points[0].position;
                    P[0] += (P[0] - points[1].position);
                } else 
                {
                    P[0] = points[p1].position;
                }

                P[1] = points[p2].position;

                if (p3 >= points.Length)
                {
                    P[2] = points[points.Length - 1].position;
                    Vector3 pos = P[2];
                    P[2] += P[2] - points[points.Length - 2].position;
                    P[3] = P[2] + (P[2] - pos);
                }
                else
                {
                    P[2] = points[p3].position;
                    if(p4 >= points.Length)
                    {
                        P[3] = P[2] + (P[2] - points[p3 - 1].position);
                    } 
                    else
                    {
                        P[3] = points[p4].position;
                    }
                }
            }
        }

        public static void FormatFromTo(ref double from, ref double to, bool preventInvert = true)
        {
            from = DMath.Clamp01(from);
            to = DMath.Clamp01(to);
            if (preventInvert && from > to)
            {
                double tmp = from;
                from = to;
                to = tmp;
            } else  to = DMath.Clamp(to, 0.0, 1.0);
        }
    }


}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/Spline.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplinePoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 373843b4b8b230a4d83d3257cb163ae6
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using UnityEngine.Serialization;
using System;

namespace Dreamteck.Splines{
	[System.Serializable]
    //A control point used by the SplineClass
	public struct SplinePoint {
        public enum Type {SmoothMirrored, Broken, SmoothFree};
        public Type type
        {
            get { return _type; }
            set
            {
                isDirty = _type != value;
                _type = value;
                if (value == Type.SmoothMirrored)
                {
                    SmoothMirrorTangent2();
                }
            }
        }

        /// <summary>
        /// Getting the value of isDirty will set the point not dirty
        /// </summary>
        [NonSerialized]
        public bool isDirty;
       
        [FormerlySerializedAs("type")]
        [SerializeField]
        [HideInInspector]
        private Type _type;

        [HideInInspector]
        [FormerlySerializedAs("_position")]
        public Vector3 position;

        [HideInInspector]
        [FormerlySerializedAs("_color")]
        public Color color;

        [HideInInspector]
        [FormerlySerializedAs("_normal")]
        public Vector3 normal;

        [HideInInspector]
        [FormerlySerializedAs("_size")]
        public float size;

        [HideInInspector]
        [FormerlySerializedAs("_tangent")]
        public Vector3 tangent;

        [HideInInspector]
        [FormerlySerializedAs("_tangent2")]
        public Vector3 tangent2;

        public static SplinePoint Lerp(SplinePoint a, SplinePoint b, float t)
        {
            SplinePoint result = a;
            if (a.type == Type.Broken || b.type == Type.Broken) result.type = Type.Broken;
            else if (a.type == Type.SmoothFree || b.type == Type.SmoothFree) result.type = Type.SmoothFree;
            else result.type = Type.SmoothMirrored;
            result.position = Vector3.Lerp(a.position, b.position, t);
            GetInterpolatedTangents(a, b, t, ref result);
            result.color = Color.Lerp(a.color, b.color, t);
            result.size = Mathf.Lerp(a.size, b.size, t);
            result.normal = Vector3.Slerp(a.normal, b.normal, t);
            return result;
        }

        private static void GetInterpolatedTangents(SplinePoint a, SplinePoint b, float t, ref SplinePoint target)
        {
            Vector3 P0_1 = (1f - t) * a.position + t * a.tangent2;
            Vector3 P1_2 = (1f - t) * a.tangent2 + t * b.tangent;
            Vector3 P2_3 = (1f - t) * b.tangent + t * b.position;
            Vector3 P01_12 = (1 - t) * P0_1 + t * P1_2;
            Vector3 P12_23 = (1 - t) * P1_2 + t * P2_3;
            target.tangent = P01_12;
            target.tangent2 = P12_23;
        }

        public override bool Equals(object obj)
        {
            if(obj is SplinePoint)
            {
                return EqualsFast((SplinePoint)obj);
            }
            return false;
        }

        private bool EqualsFast(SplinePoint obj)
        {
            SplinePoint other = (SplinePoint)obj;
            if (position != other.position) return false;
            if (tangent != other.tangent) return false;
            if (tangent2 != other.tangent2) return false;
            if (normal != other.normal) return false;
            if (_type != other._type) return false;
            if (size != other.size) return false;
            if (color != other.color) return false;
            return true;
        }


        public static bool operator == (SplinePoint p1, SplinePoint p2)
        {
            return p1.EqualsFast(p2);
        }

        public static bool operator != (SplinePoint p1, SplinePoint p2)
        {
            return !p1.EqualsFast(p2);
        }

        public void SetPosition(Vector3 pos)
        {
            tangent -= position - pos;
            tangent2 -= position - pos;
            position = pos;
        }

        public void SetTangentPosition(Vector3 pos)
        {
            tangent = pos;
            switch (_type)
            {
                case Type.SmoothMirrored: SmoothMirrorTangent2(); break;
                case Type.SmoothFree: SmoothFreeTangent2(); break;
            }
        }

        public void SetTangent2Position(Vector3 pos)
        {
            tangent2 = pos;
            switch (_type)
            {
                case Type.SmoothMirrored: SmoothMirrorTangent(); break;
                case Type.SmoothFree: SmoothFreeTangent(); break;
            }
        }

        public SplinePoint(Vector3 p)
        {
            position = p;
            tangent = p;
            tangent2 = p;
            color = Color.white;
            normal = Vector3.up;
            size = 1f;
            _type = Type.SmoothMirrored;
            isDirty = false;
            SmoothMirrorTangent2();
        }
		
		public SplinePoint(Vector3 p, Vector3 t){
            position = p;
            tangent = t;
            tangent2 = p + (p - t);
            color = Color.white;
            normal = Vector3.up;
            size = 1f;
            _type = Type.SmoothMirrored;
            isDirty = false;
            SmoothMirrorTangent2();
        }	
		
		public SplinePoint(Vector3 pos, Vector3 tan, Vector3 nor, float s, Color col){
            position = pos;
            tangent = tan;
            tangent2 = pos + (pos - tan);
            normal = nor;
            size = s;
            color = col;
            _type = Type.SmoothMirrored;
            isDirty = false;
            SmoothMirrorTangent2();
        }

        public SplinePoint(Vector3 pos, Vector3 tan, Vector3 tan2, Vector3 nor, float s, Color col)
        {
            position = pos;
            tangent = tan;
            tangent2 = tan2;
            normal = nor;
            size = s;
            color = col;
            _type = Type.Broken;
            isDirty = false;
            switch (_type)
            {
                case Type.SmoothMirrored: SmoothMirrorTangent2(); break;
                case Type.SmoothFree: SmoothFreeTangent2(); break;
            }
        }

        public SplinePoint(SplinePoint source)
        {
            position = source.position;
            tangent = source.tangent;
            tangent2 = source.tangent2;
            color = source.color;
            normal = source.normal;
            size = source.size;
            _type = source.type;
            isDirty = false;
            switch (_type)
            {
                case Type.SmoothMirrored: SmoothMirrorTangent2(); break;
                case Type.SmoothFree: SmoothFreeTangent2(); break;
            }
        }

        public void Flatten(LinearAlgebraUtility.Axis axis, float flatValue = 0f)
        {
            position = LinearAlgebraUtility.FlattenVector(position, axis, flatValue);
            tangent = LinearAlgebraUtility.FlattenVector(tangent, axis, flatValue);
            tangent2 = LinearAlgebraUtility.FlattenVector(tangent2, axis, flatValue);
            switch (axis)
            {
                case LinearAlgebraUtility.Axis.X: normal = Vector3.right; break;
                case LinearAlgebraUtility.Axis.Y: normal = Vector3.up; break;
                case LinearAlgebraUtility.Axis.Z: normal = Vector3.forward; break;
            }
        }

        public void SetPositionX(float value)
        {
            if(position.x != value)
            {
                isDirty = true;
            }
            position.x = value;
        }

        public void SetPositionY(float value)
        {
            if(position.y != value)
            {
                isDirty = true;
            }
            position.y = value;
        }

        public void SetPositionZ(float value)
        {
            if(position.z != value)
            {
                isDirty = true;
            }
            position.z = value;
        }

        public void SetTangentX(float value)
        {
            if(tangent.x != value)
            {
                isDirty = true;
            }
            tangent.x = value;
        }

        public void SetTangentY(float value)
        {
            if (tangent.y != value)
            {
                isDirty = true;
            }
            tangent.y = value;
        }

        public void SetTangentZ(float value)
        {
            if(tangent.z != value)
            {
                isDirty = true;
            }
            tangent.z = value;
        }

        public void SetTangent2X(float value)
        {
            if (tangent2.x != value)
            {
                isDirty = true;
            }
            tangent2.x = value;
        }

        public void SetTangent2Y(float value)
        {
            if (tangent2.y != value)
            {
                isDirty = true;
            }
            tangent2.y = value;
        }

        public void SetTangent2Z(float value)
        {
            if (tangent2.z != value)
            {
                isDirty = true;
            }
            tangent2.z = value;
        }

        public void SetNormalX(float value)
        {
            if (normal.x != value)
            {
                isDirty = true;
            }
            normal.x = value;
        }

        public void SetNormalY(float value)
        {
            if (normal.y != value)
            {
                isDirty = true;
            }
            normal.y = value;
        }

        public void SetNormalZ(float value)
        {
            if(normal.z != value)
            {
                isDirty = true;
            }
            normal.z = value;
        }

        public void SetColorR(float value)
        {
            if (color.r != value)
            {
                isDirty = true;
            }
            color.r = value;
        }

        public void SetColorG(float value)
        {
            if (color.g != value)
            {
                isDirty = true;
            }
            color.g = value;
        }

        public void SetColorB(float value)
        {
            if(color.b != value)
            {
                isDirty = true;
            }
            color.b = value;
        }

        public void SetColorA(float value)
        {
            if (color.a != value)
            {
                isDirty = true;
            }
            color.a = value;
        }

        private void SmoothMirrorTangent2()
        {
            tangent2 = position + (position - tangent);
            isDirty = true;
        }

        private void SmoothMirrorTangent()
        {
            tangent = position + (position - tangent2);
            isDirty = true;
        }

        private void SmoothFreeTangent2()
        {
            tangent2 = position + (position - tangent).normalized * (tangent2 - position).magnitude;
            isDirty = true;
        }

        private void SmoothFreeTangent()
        {
            tangent = position + (position - tangent2).normalized * (tangent - position).magnitude;
            isDirty = true;
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hash = 17;
                hash *= hash * 23 + _type.GetHashCode();
                hash = hash * 23 + position.GetHashCode();
                hash = hash * 23 + normal.GetHashCode();
                hash = hash * 23 + tangent.GetHashCode();
                hash = hash * 23 + tangent2.GetHashCode();
                hash = hash * 23 + color.GetHashCode();
                hash = hash * 23 + size.GetHashCode();
                return hash;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplinePoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplinePrefs.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7baa0d1cc3b5f744aa07790170949167
# ASMDEF: Dreamteck.Splines.dll
# ---
#if UNITY_EDITOR
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;

namespace Dreamteck.Splines
{
    public static class SplinePrefs
    {
        private static bool loaded = false;
        public static Spline.Direction duplicationDirection = Spline.Direction.Forward;
        public static bool defaultAlwaysDraw = false;
        public static SplineComputer.EditorUpdateMode defaultEditorUpdateMode = SplineComputer.EditorUpdateMode.Default;
        public static bool defaultShowThickness = false;
        public static bool default2D = false;
        public static bool startInCreationMode = false;
        public static SplineComputer.Space pointEditSpace = SplineComputer.Space.Local;
        public static Color defaultColor = Color.white;
        public static Color highlightColor = Color.white;
        public static Color outlineColor = Color.black;
        public static Color highlightContentColor = new Color(1f, 1f, 1f, 0.95f);
        public static bool showPointNumbers = false;
        public static SplineComputer.Space defaultComputerSpace = SplineComputer.Space.Local;
        public static Spline.Type defaultType = Spline.Type.CatmullRom;
        public static float createPointSize = 1f;
        public static Color createPointColor = Color.white;

        static SplinePrefs()
        {
            LoadPrefs();
        }

#if UNITY_2019_1_OR_NEWER
        [SettingsProvider]
        public static SettingsProvider SplinesSettingsProvider()
        {
            SettingsProvider provider = new SettingsProvider("Dreamteck/Splines", SettingsScope.User)
            {
                label = "Splines",
                guiHandler = (searchContext) =>
                {
                    OnGUI();
                },
                keywords = new HashSet<string>(new[] { "Dreamteck", "Splines", "Path", "Curve"})
            };

            return provider;
        }
#else
        [PreferenceItem("DTK Splines")]
#endif
        public static void OnGUI()
        {
            if (!loaded) LoadPrefs();
            EditorGUILayout.LabelField("Newly created splines:", EditorStyles.boldLabel);
            startInCreationMode = EditorGUILayout.Toggle("Start in Creation Mode", startInCreationMode);
            defaultComputerSpace = (SplineComputer.Space)EditorGUILayout.EnumPopup("Space", defaultComputerSpace);
            defaultType = (Spline.Type)EditorGUILayout.EnumPopup("Type", defaultType);
            defaultAlwaysDraw = EditorGUILayout.Toggle("Always draw", defaultAlwaysDraw);
            defaultEditorUpdateMode = (SplineComputer.EditorUpdateMode)EditorGUILayout.EnumPopup("Default Editor Update Mode", defaultEditorUpdateMode);
            defaultShowThickness = EditorGUILayout.Toggle("Show thickness", defaultShowThickness);
            default2D = EditorGUILayout.Toggle("2D Mode", default2D);
            defaultColor = EditorGUILayout.ColorField("Spline color", defaultColor);
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Newly created points:", EditorStyles.boldLabel);
            createPointSize = EditorGUILayout.FloatField("Default Size", createPointSize);
            createPointColor = EditorGUILayout.ColorField("Default Color", createPointColor);
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Editor", EditorStyles.boldLabel);
            outlineColor = EditorGUILayout.ColorField("Outline color", outlineColor);
            highlightColor = EditorGUILayout.ColorField("Highlight color", highlightColor);
            highlightContentColor = EditorGUILayout.ColorField("Highlight content color", highlightContentColor);
            duplicationDirection = (Spline.Direction)EditorGUILayout.EnumPopup("Duplicate Direction", duplicationDirection);
            showPointNumbers = EditorGUILayout.Toggle("Show point numbers", showPointNumbers);

            if (GUILayout.Button("Use Defaults", GUILayout.Width(120)))
            {
                duplicationDirection = Spline.Direction.Forward;
                defaultAlwaysDraw = false;
                defaultEditorUpdateMode = SplineComputer.EditorUpdateMode.Default;
                defaultShowThickness = false;
                default2D = false;
                startInCreationMode = true;
                defaultColor = Color.white;
                highlightColor = new Color(0.0313f, 0.737f, 0.796f, 1f);
                outlineColor = Color.Lerp(defaultColor, Color.black, 0.65f);
                highlightContentColor = new Color(1f, 1f, 1f, 0.95f);
                showPointNumbers = false;
                defaultComputerSpace = SplineComputer.Space.Local;
                defaultType = Spline.Type.CatmullRom;
                createPointSize = 1f;
                createPointColor = Color.white;
                SavePrefs();
            }
            if (GUI.changed) SavePrefs();
        }

        public static void LoadPrefs()
        {
            defaultAlwaysDraw = EditorPrefs.GetBool("Dreamteck.Splines.defaultAlwaysDraw", false);
            defaultEditorUpdateMode = (SplineComputer.EditorUpdateMode) EditorPrefs.GetInt("Dreamteck.Splines.defaultEditorUpdateMode", 0);
            defaultShowThickness = EditorPrefs.GetBool("Dreamteck.Splines.defaultShowThickness", false);
            default2D = EditorPrefs.GetBool("Dreamteck.Splines.default2D", false);
            startInCreationMode = EditorPrefs.GetBool("Dreamteck.Splines.startInCreationMode", true);
            showPointNumbers = EditorPrefs.GetBool("Dreamteck.Splines.showPointNumbers", false);
            pointEditSpace = (SplineComputer.Space)EditorPrefs.GetInt("Dreamteck.Splines.pointEditSpace", 1);
            defaultColor = LoadColor("Dreamteck.Splines.defaultColor", Color.white);
            highlightColor = LoadColor("Dreamteck.Splines.highlightColor", new Color(0f, 0.564f, 1f, 1f));
            outlineColor = LoadColor("Dreamteck.Splines.outlineColor", Color.Lerp(defaultColor, Color.black, 0.65f));
            highlightContentColor = LoadColor("Dreamteck.Splines.highlightContentColor", new Color(1f, 1f, 1f, 0.95f));
            defaultComputerSpace = (SplineComputer.Space)EditorPrefs.GetInt("Dreamteck.Splines.defaultComputerSpace", 1);
            defaultType = (Spline.Type)EditorPrefs.GetInt("Dreamteck.Splines.defaultType", 0);
            duplicationDirection = (Spline.Direction)EditorPrefs.GetInt("Dreamteck.Splines.duplicationDirection", 0);
            createPointSize = EditorPrefs.GetFloat("Dreamteck.Splines.createPointSize", 1f);
            createPointColor = LoadColor("Dreamteck.Splines.createPointColor", Color.white);
            loaded = true;
        }

        private static Color LoadColor(string name, Color defaultValue)
        {
            Color col = Color.white;
            string colorString = EditorPrefs.GetString(name, defaultValue.r+":"+defaultValue.g+ ":" + defaultValue.b+ ":" + defaultValue.a);
            string[] elements = colorString.Split(':');
            if (elements.Length < 4) return col;
            float r = 0f, g = 0f, b = 0f, a = 0f;
            float.TryParse(elements[0], out r);
            float.TryParse(elements[1], out g);
            float.TryParse(elements[2], out b);
            float.TryParse(elements[3], out a);
            col = new Color(r, g, b, a);
            return col;
        }

        public static void SavePrefs()
        {
            EditorPrefs.SetBool("Dreamteck.Splines.startInCreationMode", startInCreationMode);
            EditorPrefs.SetBool("Dreamteck.Splines.defaultAlwaysDraw", defaultAlwaysDraw);
            EditorPrefs.SetInt("Dreamteck.Splines.defaultEditorUpdateMode", (int)defaultEditorUpdateMode);
            EditorPrefs.SetBool("Dreamteck.Splines.defaultShowThickness", defaultShowThickness);
            EditorPrefs.SetBool("Dreamteck.Splines.default2D", default2D);
            EditorPrefs.SetBool("Dreamteck.Splines.showPointNumbers", showPointNumbers);
            EditorPrefs.SetInt("Dreamteck.Splines.pointEditSpace", (int)pointEditSpace);
            EditorPrefs.SetString("Dreamteck.Splines.defaultColor", defaultColor.r+ ":" + defaultColor.g+ ":" + defaultColor.b+ ":" + defaultColor.a);
            EditorPrefs.SetString("Dreamteck.Splines.highlightColor", highlightColor.r + ":" + highlightColor.g + ":" + highlightColor.b + ":" + highlightColor.a);
            EditorPrefs.SetString("Dreamteck.Splines.outlineColor", outlineColor.r + ":" + outlineColor.g + ":" + outlineColor.b + ":" + outlineColor.a);
            EditorPrefs.SetString("Dreamteck.Splines.highlightContentColor", highlightContentColor.r + ":" + highlightContentColor.g + ":" + highlightContentColor.b + ":" + highlightContentColor.a);
            EditorPrefs.SetInt("Dreamteck.Splines.defaultComputerSpace", (int)defaultComputerSpace);
            EditorPrefs.SetInt("Dreamteck.Splines.defaultType", (int)defaultType);
            EditorPrefs.SetInt("Dreamteck.Splines.duplicationDirection", (int)duplicationDirection);
            EditorPrefs.SetFloat("Dreamteck.Splines.createPointSize", createPointSize);
            EditorPrefs.SetString("Dreamteck.Splines.createPointColor", createPointColor.r + ":" + createPointColor.g + ":" + createPointColor.b + ":" + createPointColor.a);
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplinePrefs.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineSample.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4dd959ac300a1db4da9527c1e10ac8e2
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using Dreamteck;

namespace Dreamteck.Splines{
    [System.Serializable]
	public struct SplineSample {
        public Vector3 position;
        public Vector3 up;
        public Vector3 forward;
        public Color color;
        public float size;
        public double percent;

        public void FastCopy(ref SplineSample sample)
        {
            position = sample.position;
            up = sample.up;
            forward = sample.forward;
            color = sample.color;
            size = sample.size;
            percent = sample.percent;
        }
         

        public Quaternion rotation
        {
            get {
                if (up == forward)
                {
                    if (up == Vector3.up) return Quaternion.LookRotation(Vector3.up, Vector3.back);
                    else return Quaternion.LookRotation(forward, Vector3.up);
                }
                return Quaternion.LookRotation(forward, up); }
        }

        public Vector3 right
        {
            get {
                if(up == forward)
                {
                    if (up == Vector3.up) return Vector3.right;
                    else return Vector3.Cross(Vector3.up, forward).normalized;
                }
                return Vector3.Cross(up, forward).normalized; }
        }


        public static SplineSample Lerp(ref SplineSample a, ref SplineSample b, float t)
        {
            SplineSample result = new SplineSample();
            Lerp(ref a, ref b, t, ref result);
            return result;
        }

        public static SplineSample Lerp(ref SplineSample a, ref SplineSample b, double t)
        {
            SplineSample result = new SplineSample();
            Lerp(ref a, ref b, t, ref result);
            return result;
        }

        public static void Lerp(ref SplineSample a, ref SplineSample b, double t, ref SplineSample target)
        {
            float ft = (float)t;
            DMath.LerpVector3NonAlloc(a.position, b.position, t, ref target.position);
            target.forward = Vector3.Slerp(a.forward, b.forward, ft);
            target.up = Vector3.Slerp(a.up, b.up, ft);
            target.color = Color.Lerp(a.color, b.color, ft);
            target.size = Mathf.Lerp(a.size, b.size, ft);
            target.percent = DMath.Lerp(a.percent, b.percent, t);
        }

        public static void Lerp(ref SplineSample a, ref SplineSample b, float t, ref SplineSample target)
        {
            DMath.LerpVector3NonAlloc(a.position, b.position, t, ref target.position);
            target.forward = Vector3.Slerp(a.forward, b.forward, t);
            target.up = Vector3.Slerp(a.up, b.up, t);
            target.color = Color.Lerp(a.color, b.color, t);
            target.size = Mathf.Lerp(a.size, b.size, t);
            target.percent = DMath.Lerp(a.percent, b.percent, t);
        }

        public void Lerp(ref SplineSample b, double t)
        {
            Lerp(ref this, ref b, t, ref this);
        }

        public void Lerp(ref SplineSample b, float t)
        {
            Lerp(ref this, ref b, t, ref this);
        }
		
        public SplineSample(Vector3 position, Vector3 up, Vector3 forward, Color color, float size, double percent)
        {
            this.position = position;
            this.up = up;
            this.forward = forward;
            this.color = color;
            this.size = size;
            this.percent = percent;
        }
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineSample.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineThreading.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3accda9a749b24c459cb983529284d01
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEngine.SceneManagement;
#if !UNITY_WSA
    using System.Threading;
#endif

    public static class SplineThreading
    {
        public delegate void EmptyHandler();
        public static int threadCount
        {
            get {
#if UNITY_WSA
                return 0;
#else
                return threads.Length;
#endif
            }
            set
            {
#if !UNITY_WSA
                if(value > threads.Length)
                {
                    while (threads.Length < value)
                    {
                        ThreadDef thread = new ThreadDef();
#if UNITY_EDITOR
                        if (Application.isPlaying)
                        {
                            thread.Restart();
                        }
#else
                        thread.Restart();
#endif
                        ArrayUtility.Add(ref threads, thread);
                    }
                }
#endif
            }
        }
#if !UNITY_WSA
        internal class ThreadDef
        {
            internal class Worker
            {
                internal bool computing = false;
                internal Queue<EmptyHandler> instructions = new Queue<EmptyHandler>();
            }
            internal delegate void BoolHandler(bool flag);
            private ParameterizedThreadStart start = null;
            internal Thread thread = null;
            private Worker worker = new Worker();
            internal bool isAlive
            {
                get { return thread != null && thread.IsAlive; }
            }
            internal bool computing
            {
                get
                {
                    return worker.computing;
                }
            }

            internal ThreadDef()
            {
                start = new ParameterizedThreadStart(RunThread);
            }

            internal void Queue(EmptyHandler handler)
            {
                worker.instructions.Enqueue(handler);
            }

            internal void Interrupt()
            {
                thread.Interrupt();
            }

            internal void Restart()
            {
                thread = new Thread(start);
                thread.Start(worker);
            }

            internal void Abort()
            {
                if (isAlive)
                {
                    thread.Abort();
                }
            }
        }
        internal static ThreadDef[] threads = new ThreadDef[2];
        internal static readonly object locker = new object();
        static SplineThreading()
        {
            Application.quitting += Quitting;
            for (int i = 0; i < threads.Length; i++)
            {
                threads[i] = new ThreadDef();
            }

#if UNITY_EDITOR
            PrewarmThreads();
            UnityEditor.EditorApplication.playModeStateChanged += OnPlayStateChanged;
#endif
        }

#if UNITY_EDITOR
        static void OnPlayStateChanged(UnityEditor.PlayModeStateChange state)
        {
            if (state == UnityEditor.PlayModeStateChange.ExitingPlayMode)
            {
                Quitting();
            }
        }
#endif

        static void Quitting()
        {
            Stop();
        }

        static void RunThread(object o)
        {
            ThreadDef.Worker work = (ThreadDef.Worker)o;
            while (true)
            {
                try
                {
                    work.computing = false;
                    Thread.Sleep(Timeout.Infinite);
                }
                catch (ThreadInterruptedException)
                {
                    work.computing = true;
                    lock (locker)
                    {
                        while (work.instructions.Count > 0)
                        {
                            EmptyHandler h = work.instructions.Dequeue();
                            if (h != null) h();
                        }
                    }
                }
                catch (System.Exception ex)
                {
                    if(ex.Message != "") Debug.LogError("THREAD EXCEPTION " + ex.Message);
                    break;
                }
            }
            Debug.Log("Thread stopped");
            work.computing = false;
        }
#endif

            public static void Run(EmptyHandler handler)
        {
#if !UNITY_WSA
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                handler();
                return;
            }
#endif
            for (int i = 0; i < threads.Length; i++)
            {
                if (!threads[i].isAlive) threads[i].Restart();
                if (!threads[i].computing || i == threads.Length - 1)
                {
                    threads[i].Queue(handler);
                    if(!threads[i].computing)threads[i].Interrupt();
                    break;
                }
            }
#endif
        }

        public static void PrewarmThreads()
        {
#if !UNITY_WSA
            for (int i = 0; i < threads.Length; i++)
            {
                if (!threads[i].isAlive)
                {
                    threads[i].Restart();
                }
            }
#endif
        }

        public static void Stop()
        {
#if !UNITY_WSA
            for (int i = 0; i < threads.Length; i++)
            {
                threads[i].Abort();
            }
#endif
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineThreading.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineTrigger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 49af47eda040af44b8003635251e89cc
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEngine.Events;

    [System.Serializable]
    public class TriggerGroup{
#if UNITY_EDITOR
        public bool open = false;
#endif

        public bool enabled = true;
        public string name = "";
        public Color color = Color.white;
        public SplineTrigger[] triggers = new SplineTrigger[0];

        public void Check(double start, double end, SplineUser user = null)
        {
            for (int i = 0; i < triggers.Length; i++)
            {
                if (triggers[i] == null)
                {
                    continue;
                }

                if (triggers[i].Check(start, end))
                {
                    triggers[i].Invoke(user);
                }
            }
        }

        public void Reset()
        {
            for (int i = 0; i < triggers.Length; i++) triggers[i].Reset();
        }

        /// <summary>
        /// Returns all triggers within the specified range
        /// </summary>
        public List<SplineTrigger> GetTriggers(double from, double to)
        {
            List<SplineTrigger> triggerList = new List<SplineTrigger>();
            for (int i = 0; i < triggers.Length; i++)
            {
                if (triggers[i] == null)
                {
                    continue;
                }
                if(triggers[i].position >= from  && triggers[i].position <= to)
                {
                    triggerList.Add(triggers[i]);
                }
            }
            return triggerList;
        }

        /// <summary>
        /// Creates a new trigger inside the group
        /// </summary>
        public SplineTrigger AddTrigger(double position, SplineTrigger.Type type)
        {
            return AddTrigger(position, type, "Trigger " + (triggers.Length + 1), Color.white);
        }

        /// <summary>
        /// Creates a new trigger inside the group
        /// </summary>
        public SplineTrigger AddTrigger(double position, SplineTrigger.Type type, string name, Color color)
        {
            SplineTrigger newTrigger = new SplineTrigger(type);
            newTrigger.position = position;
            newTrigger.color = color;
            newTrigger.name = name;
            ArrayUtility.Add(ref triggers, newTrigger);
            return newTrigger;
        }

        /// <summary>
        /// Removes the trigger at the given index from the group
        /// </summary>
        public void RemoveTrigger(int index)
        {
            ArrayUtility.RemoveAt(ref triggers, index);
        }
    }

    [System.Serializable]
    public class SplineTrigger
    {
        public string name = "Trigger";
        public enum Type { Double, Forward, Backward}
        [SerializeField]
        public Type type = Type.Double;
        public bool workOnce = false;
        private bool worked = false;
        [Range(0f, 1f)]
        public double position = 0.5;
        [SerializeField]
        public bool enabled = true;
        [SerializeField]
        public Color color = Color.white;
        [SerializeField]
        [HideInInspector]
        public TriggerEvent onCross = new TriggerEvent();

        public SplineTrigger(Type t)
        {
            type = t;
            enabled = true;
            onCross = new TriggerEvent();
        }

        /// <summary>
        /// Add a new UnityAction to the trigger
        /// </summary>
        /// <param name="action"></param>
        public void AddListener(UnityAction<SplineUser> action)
        {
            onCross.AddListener(action);
        }

        public void AddListener(UnityAction action)
        {
            UnityAction<SplineUser> addAction = new UnityAction<SplineUser>((user) => { action.Invoke(); });
            onCross.AddListener(addAction);
        }

        public void RemoveListener(UnityAction<SplineUser> action)
        {
            onCross.RemoveListener(action);
        }

        public void RemoveAllListeners()
        {
            onCross.RemoveAllListeners();
        }

        public void Reset()
        {
            worked = false;
        }

        public bool Check(double previousPercent, double currentPercent)
        {
            if (!enabled) return false;
            if (workOnce && worked) return false;
            bool passed = false;
            switch (type)
            {
                case Type.Double: passed = (previousPercent <= position && currentPercent >= position) || (currentPercent <= position && previousPercent >= position); break;
                case Type.Forward: passed = previousPercent <= position && currentPercent >= position; break;
                case Type.Backward: passed = currentPercent <= position && previousPercent >= position; break;
            }
            if (passed) worked = true;
            return passed;
        }

        public void Invoke(SplineUser user = null)
        {
#if UNITY_EDITOR
            if (!Application.isPlaying) return;
#endif
            onCross.Invoke(user);
        }

        [System.Serializable]
        public class TriggerEvent : UnityEvent<SplineUser>
        { 
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineTrigger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 74914877e76bc924eaa2e97157f84f95
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public static class SplineUtility
    {
        public enum MergeSide { Start, End }

        /// <summary>
        /// Merges two spline objects into one. The result will be merged into <paramref name="baseSpline"/>
        /// </summary>
        /// <param name="baseSpline">The base spline object that</param>
        /// <param name="addedSpline">The object that will be merged into the base spline</param>
        /// <param name="side">Which side of the base spline to append to - beginning or end?</param>
        /// <param name="mergeEndpoints">Should the end points of the splines be merged or should they be bridged?</param>
        /// <param name="destroyAddedSpline">If true, the added spline's game object will be destroyed after merge</param>
        public static void Merge(SplineComputer baseSpline, SplineComputer addedSpline, MergeSide side, bool mergeEndpoints = false, bool destroyAddedSpline = false)
        {
            SplinePoint[] mergedPoints = addedSpline.GetPoints();
            SplinePoint[] basePoints = baseSpline.GetPoints();
            List<SplinePoint> pointsList = new List<SplinePoint>();
            SplinePoint[] points;
            if (!mergeEndpoints) points = new SplinePoint[mergedPoints.Length + basePoints.Length];
            else points = new SplinePoint[mergedPoints.Length + basePoints.Length - 1];

            if (side == MergeSide.End)
            {
                if (side == MergeSide.Start)
                {
                    for (int i = 0; i < basePoints.Length; i++) pointsList.Add(basePoints[i]);
                    for (int i = mergeEndpoints ? 1 : 0; i < mergedPoints.Length; i++) pointsList.Add(mergedPoints[i]);
                }
                else
                {
                    for (int i = 0; i < basePoints.Length; i++) pointsList.Add(basePoints[i]);
                    for (int i = 0; i < mergedPoints.Length - (mergeEndpoints ? 1 : 0); i++) pointsList.Add(mergedPoints[(mergedPoints.Length - 1) - i]);
                }
            }
            else
            {
                if (side == MergeSide.Start)
                {
                    for (int i = 0; i < mergedPoints.Length - (mergeEndpoints ? 1 : 0); i++) pointsList.Add(mergedPoints[(mergedPoints.Length - 1) - i]);
                    for (int i = 0; i < basePoints.Length; i++) pointsList.Add(basePoints[i]);
                }
                else
                {
                    for (int i = mergeEndpoints ? 1 : 0; i < mergedPoints.Length; i++) pointsList.Add(mergedPoints[i]);
                    for (int i = 0; i < basePoints.Length; i++) pointsList.Add(basePoints[i]);
                }
            }
            points = pointsList.ToArray();
            double mergedPercent = (double)(mergedPoints.Length - 1) / (points.Length - 1);
            double from = 0.0;
            double to = 1.0;
            if (side == MergeSide.End)
            {
                from = 1.0 - mergedPercent;
                to = 1.0;
            }
            else
            {
                from = 0.0;
                to = mergedPercent;
            }


            List<Node> mergedNodes = new List<Node>();
            List<int> mergedIndices = new List<int>();

            for (int i = 0; i < addedSpline.pointCount; i++)
            {
                Node node = addedSpline.GetNode(i);
                if (node != null)
                {
                    mergedNodes.Add(node);
                    mergedIndices.Add(i);
                    addedSpline.DisconnectNode(i);
                    i--;
                }
            }

            SplineUser[] subs = addedSpline.GetSubscribers();
            for (int i = 0; i < subs.Length; i++)
            {
                addedSpline.Unsubscribe(subs[i]);
                subs[i].spline = baseSpline;
                subs[i].clipFrom = DMath.Lerp(from, to, subs[i].clipFrom);
                subs[i].clipTo = DMath.Lerp(from, to, subs[i].clipTo);
            }
            baseSpline.SetPoints(points);

            if (side == MergeSide.Start)
            {
                baseSpline.ShiftNodes(0, baseSpline.pointCount - 1, addedSpline.pointCount);
                for (int i = 0; i < mergedNodes.Count; i++)
                {
                    baseSpline.ConnectNode(mergedNodes[i], mergedIndices[i]);
                }
            }
            else
            {
                for (int i = 0; i < mergedNodes.Count; i++)
                {
                    int connectIndex = mergedIndices[i] + basePoints.Length;
                    if (mergeEndpoints) connectIndex--;
                    baseSpline.ConnectNode(mergedNodes[i], connectIndex);
                }
            }
            if (destroyAddedSpline)
            {
                Object.Destroy(addedSpline.gameObject);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/SplineUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/TransformModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b4d0258b139ab2142a6d1ba90331008a
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

namespace Dreamteck.Splines
{

    [System.Serializable]
    public class TransformModule : ISerializationCallbackReceiver
    {
        public Vector2 offset
        {
            get { return _offset; }
            set
            {
                if (value != _offset)
                {
                    _offset = value;
                    _hasOffset = _offset != Vector2.zero;
                    if (targetUser != null)
                    {
                        targetUser.Rebuild();
                    }
                }
            }
        }
        public Vector3 rotationOffset
        {
            get { return _rotationOffset; }
            set
            {
                if (value != _rotationOffset)
                {
                    _rotationOffset = value;
                    _hasRotationOffset = _rotationOffset != Vector3.zero;
                    if (targetUser != null)
                    {
                        targetUser.Rebuild();
                    }
                }
            }
        }

        public bool hasOffset
        {
            get { return _hasOffset; }
        }

        public bool hasRotationOffset
        {
            get { return _hasRotationOffset; }
        }

        public Vector3 baseScale
        {
            get { return _baseScale; }
            set
            {
                if (value != _baseScale)
                {
                    _baseScale = value;
                    if (targetUser != null)
                    {
                        targetUser.Rebuild();
                    }
                }
            }
        }

        public bool is2D
        {
            get { return _2dMode; }
            set
            {
                _2dMode = value;
            }
        }

        [SerializeField]
        [HideInInspector]
        private bool _hasOffset = false;
        [SerializeField]
        [HideInInspector]
        private bool _hasRotationOffset = false;

        [SerializeField]
        [HideInInspector]
        private Vector2 _offset;
        [SerializeField]
        [HideInInspector]
        private Vector3 _rotationOffset = Vector3.zero;
        [SerializeField]
        [HideInInspector]
        private Vector3 _baseScale = Vector3.one;
        [SerializeField]
        [HideInInspector]
        private bool _2dMode = false;
        public enum VelocityHandleMode { Zero, Preserve, Align, AlignRealistic }
        public VelocityHandleMode velocityHandleMode = VelocityHandleMode.Zero;
        public SplineSample splineResult
        {
            get
            {
                return _splineResult;
            }
            set
            {
                _splineResult = value;
            }
        }
        private SplineSample _splineResult;

        public bool applyPositionX = true;
        public bool applyPositionY = true;
        public bool applyPositionZ = true;
        public bool applyPosition2D = true;
        public bool retainLocalPosition = false;

        public Spline.Direction direction = Spline.Direction.Forward;
        public bool applyPosition
        {
            get
            {
                if (_2dMode)
                {
                    return applyPosition2D;
                }
                return applyPositionX || applyPositionY || applyPositionZ;
            }
            set
            {
                applyPositionX = applyPositionY = applyPositionZ = applyPosition2D = value;
            }
        }

        public bool applyRotationX = true;
        public bool applyRotationY = true;
        public bool applyRotationZ = true;
        public bool applyRotation2D = true;
        public bool retainLocalRotation = false;
        public bool applyRotation
        {
            get
            {
                if (_2dMode)
                {
                    return applyRotation2D;
                }
                return applyRotationX || applyRotationY || applyRotationZ;
            }
            set
            {
                applyRotationX = applyRotationY = applyRotationZ = applyRotation2D = value;
            }
        }

        public bool applyScaleX = false;
        public bool applyScaleY = false;
        public bool applyScaleZ = false;
        public bool applyScale
        {
            get
            {
                return applyScaleX || applyScaleY || applyScaleZ;
            }
            set
            {
                applyScaleX = applyScaleY = applyScaleZ = value;
            }
        }
        [HideInInspector]
        public SplineUser targetUser = null;

        //These are used to save allocations
        private static Vector3 position = Vector3.zero;
        private static Quaternion rotation = Quaternion.identity;

        public void ApplyTransform(Transform input)
        {
            input.position = GetPosition(input.position);
            input.rotation = GetRotation(input.rotation);
            input.localScale = GetScale(input.localScale);
        }

        public void ApplyRigidbody(Rigidbody input)
        {
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                ApplyTransform(input.transform);
                return;
            }
#endif
            input.transform.localScale = GetScale(input.transform.localScale);
            input.MovePosition(GetPosition(input.position));
            if (!input.isKinematic)
            {
#if UNITY_6000_0_OR_NEWER
                input.linearVelocity = HandleVelocity(input.linearVelocity);
#else
                input.velocity = HandleVelocity(input.velocity);
#endif
            }
            input.MoveRotation(GetRotation(input.rotation));
            Vector3 angularVelocity = input.angularVelocity;
            if (applyRotationX)
            {
                angularVelocity.x = 0f;
            }
            if (applyRotationY)
            {
                angularVelocity.y = 0f;
            }
            if (applyRotationZ || applyRotation2D)
            {
                angularVelocity.z = 0f;
            }
            input.angularVelocity = angularVelocity;
        }

        public void ApplyRigidbody2D(Rigidbody2D input)
        {
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                ApplyTransform(input.transform);
                input.transform.rotation = Quaternion.AngleAxis(GetRotation(Quaternion.Euler(0f, 0f, input.rotation)).eulerAngles.z, Vector3.forward);
                return;
            }
#endif
            input.transform.localScale = GetScale(input.transform.localScale);
            input.position = GetPosition(input.position);
            if (!input.isKinematic)
            {
#if UNITY_6000_OR_NEWER
            input.linearVelocity = HandleVelocity(input.linearVelocity);
#else
                input.linearVelocity = HandleVelocity(input.linearVelocity);
#endif
            }
            input.rotation = GetRotation(Quaternion.Euler(0f, 0f, input.rotation)).eulerAngles.z;
            if (applyRotationX)
            {
                input.angularVelocity = 0f;
            }
        }

        Vector3 HandleVelocity(Vector3 velocity)
        {
            Vector3 idealVelocity = Vector3.zero;
            Vector3 direction = Vector3.right;
            switch (velocityHandleMode)
            {
                case VelocityHandleMode.Preserve: idealVelocity = velocity; break;
                case VelocityHandleMode.Align:
                    direction = _splineResult.forward;
                    if (Vector3.Dot(velocity, direction) < 0f) direction *= -1f;
                    idealVelocity = direction * velocity.magnitude; break;
                case VelocityHandleMode.AlignRealistic:
                    direction = _splineResult.forward;
                    if (Vector3.Dot(velocity, direction) < 0f) direction *= -1f;
                    idealVelocity = direction * velocity.magnitude * Vector3.Dot(velocity.normalized, direction); break;
            }
            if (applyPositionX) velocity.x = idealVelocity.x;
            if (applyPositionY) velocity.y = idealVelocity.y;
            if (applyPositionZ) velocity.z = idealVelocity.z;
            return velocity;
        }

        private Vector3 GetPosition(Vector3 inputPosition)
        {
            position = _splineResult.position;
            Vector2 finalOffset = _offset;
            if (finalOffset != Vector2.zero)
            {
                position += _splineResult.right * finalOffset.x * _splineResult.size + _splineResult.up * finalOffset.y * _splineResult.size;
            }
            if (retainLocalPosition)
            {
                Matrix4x4 matrix = Matrix4x4.TRS(position, _splineResult.rotation, Vector3.one);
                Vector3 splineLocalPosition = matrix.inverse.MultiplyPoint3x4(targetUser.transform.position);
                splineLocalPosition.x = applyPositionX ? 0f : splineLocalPosition.x;
                splineLocalPosition.y = applyPositionY ? 0f : splineLocalPosition.y;
                splineLocalPosition.z = applyPositionZ ? 0f : splineLocalPosition.z;
                inputPosition = matrix.MultiplyPoint3x4(splineLocalPosition);
            } else
            {
                if (applyPositionX) inputPosition.x = position.x;
                if (applyPositionY) inputPosition.y = position.y;
                if (applyPositionZ) inputPosition.z = position.z;
            }
            return inputPosition;
        }

        private Quaternion GetRotation(Quaternion inputRotation)
        {
            rotation = Quaternion.LookRotation(_splineResult.forward * (direction == Spline.Direction.Forward ? 1f : -1f), _splineResult.up);
            if (_2dMode)
            {
                if (applyRotation2D)
                {
                    rotation *= Quaternion.Euler(90, -90, 0);
                    inputRotation = Quaternion.AngleAxis(rotation.eulerAngles.z + _rotationOffset.z, Vector3.forward);
                }
                return inputRotation;
            }
            else
            {
                if (_rotationOffset != Vector3.zero)
                {
                    rotation = rotation * Quaternion.Euler(_rotationOffset);
                }
            }

            if (retainLocalRotation)
            {
                Quaternion localRotation = Quaternion.Inverse(rotation) * inputRotation;
                Vector3 targetEuler = localRotation.eulerAngles;
                targetEuler.x = applyRotationX ? 0f : targetEuler.x;
                targetEuler.y = applyRotationY ? 0f : targetEuler.y;
                targetEuler.z = applyRotationZ ? 0f : targetEuler.z;
                inputRotation = rotation * Quaternion.Euler(targetEuler);
            } else
            {
                if (!applyRotationX || !applyRotationY || !applyRotationZ)
                {
                    Vector3 targetEuler = rotation.eulerAngles;
                    Vector3 sourceEuler = inputRotation.eulerAngles;
                    if (!applyRotationX) targetEuler.x = sourceEuler.x;
                    if (!applyRotationY) targetEuler.y = sourceEuler.y;
                    if (!applyRotationZ) targetEuler.z = sourceEuler.z;
                    inputRotation.eulerAngles = targetEuler;
                }
                else 
                {
                    inputRotation = rotation;
                }
            }

            return inputRotation;
        }

        private Vector3 GetScale(Vector3 inputScale)
        {
            if (applyScaleX) inputScale.x = _baseScale.x * _splineResult.size;
            if (applyScaleY) inputScale.y = _baseScale.y * _splineResult.size;
            if (applyScaleZ) inputScale.z = _baseScale.z * _splineResult.size;
            return inputScale;
        }

        public void OnBeforeSerialize()
        {
            
        }

        public void OnAfterDeserialize()
        {
            _hasRotationOffset = _rotationOffset != Vector3.zero;
            _hasOffset = _offset != Vector2.zero;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Core/TransformModule.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/AudioVisualization/SpectrumVisualizer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a96d0f6951e54f54aa61fa5b357652d0
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;


namespace Dreamteck.Splines.Examples
{
    public class SpectrumVisualizer : MonoBehaviour
    {
        public int samples = 1024;
        [Tooltip("The starting percent of the spectrum. 0 is 20Hz and 1 is 20KHz")]
        [Range(0f, 1f)]
        public float minSpectrumRange = 0f;
        [Tooltip("The ending percent of the spectrum. 0 is 20Hz and 1 is 20KHz")]
        [Range(0f, 1f)]
        public float maxSpectrumRange = 1f;
        public float increaseSpeed = 50f;
        public float decreaseSpeed = 10f;
        public float maxOffset = 10f;
        public AudioSource source;
        private SplineComputer computer;
        private Vector3[] positions;
        public AnimationCurve spectrumMultiply; //lower frequencies have bigger values, this is used to even the values
        private float[] spectrumLerp;


        
        // Use this for initialization
        void Start()
        {
            if(source == null) source = GetComponent<AudioSource>();
            computer = GetComponent<SplineComputer>();
            SplinePoint[] points = computer.GetPoints();
            positions = new Vector3[points.Length];
            for (int i = 0; i < points.Length; i++)
            {
                positions[i] = points[i].position;
            }
            spectrumLerp = new float[points.Length];
        }

        // Update is called once per frame
        void Update()
        {
            float[] left = new float[samples];
            float[] right = new float[samples];
            source.GetSpectrumData(left, 0, FFTWindow.Hanning);
            source.GetSpectrumData(right, 1, FFTWindow.Hanning);
            float[] spectrum = new float[left.Length];
            for (int i = 0; i < spectrum.Length; i++)
            {
                spectrum[i] = (left[i] + right[i])/2f;
            }
            SplinePoint[] points = computer.GetPoints();
            int samplesPerPoint = Mathf.FloorToInt((spectrum.Length / points.Length) * (maxSpectrumRange-minSpectrumRange));
            int spectrumIndexStart = Mathf.FloorToInt((spectrum.Length - 1) * minSpectrumRange);
            for (int i = 0; i < points.Length; i++)
            {
                float avg = 0f;
                for (int n = 0; n < samplesPerPoint ; n++) avg += spectrum[spectrumIndexStart + samplesPerPoint * i + n];
                avg /= samplesPerPoint;
                if (avg > spectrumLerp[i]) spectrumLerp[i] = Mathf.Lerp(spectrumLerp[i], avg, Time.deltaTime * increaseSpeed);
                else spectrumLerp[i] = Mathf.Lerp(spectrumLerp[i], avg, Time.deltaTime * decreaseSpeed);
               
                float percent = (float)i / (points.Length - 1);
                points[i].position = positions[i] + Vector3.up * maxOffset * spectrumLerp[i] * spectrumMultiply.Evaluate(percent);
            }
            computer.SetPoints(points);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/AudioVisualization/SpectrumVisualizer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Following/Scripts/CameraSmoothRotation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1db240e16ae54c34796776d2116027a0
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines.Examples
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class CameraSmoothRotation : MonoBehaviour
    {
        //Simple script to smooth out the rotation of the camera
        //Since getting the rotation directly from the spline might not look good 
        //When looking from first person perspective
        public float damp = 0f;
        SplineFollower follower;
        Transform trs;

        void Start()
        {
            trs = transform;
            follower = GetComponent<SplineFollower>();
        }

        void Update()
        {
            if(damp <= 0f)
            {
                //if no damp is used, then make the follower apply the rotation automatically
                follower.motion.applyRotation = true;
                return;
            }
            //if damp > 0 then handle rotation manually here
            follower.motion.applyRotation = false;
            trs.rotation = Quaternion.Slerp(trs.rotation, follower.result.rotation, Time.deltaTime / damp);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Following/Scripts/CameraSmoothRotation.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Following/Scripts/URLButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5ec15fe9037467446879410642c099da
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class URLButton : MonoBehaviour
{
    public string url = "";

    public void Click()
    {
        Application.OpenURL(url);
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Following/Scripts/URLButton.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/JunctionSwitch.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 785b8ec86cde0874bac4115ccaf2ad20
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines.Examples
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class JunctionSwitch : MonoBehaviour
    {
        [System.Serializable]
        public class Bridge
        {
            public enum Direction { Forward = 1, Backward = -1, None = 0 }
            public bool active = true;
            public int a;
            public Direction aDirection = Direction.None;
            public int b;
            public Direction bDirection = Direction.None;
        }

        public Bridge[] bridges;

        private void OnValidate()
        {
            Node node = GetComponent<Node>();
            Node.Connection[] connections = node.GetConnections();
            if (bridges == null) return;
            for (int i = 0; i < bridges.Length; i++)
            {
                if (bridges[i].a < 0) bridges[i].a = 0;
                if (bridges[i].b < 0) bridges[i].b = 0;
                if (bridges[i].a >= connections.Length) bridges[i].a = connections.Length - 1;
                if (bridges[i].b >= connections.Length) bridges[i].b = connections.Length - 1;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/JunctionSwitch.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/TrainCamera.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6e4c289b236b9d94891dcdf70b12b513
# ASMDEF: Dreamteck.Splines.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TrainCamera : MonoBehaviour
{
    public Transform target;
    public Vector3 offset;
    public float speed = 1f;
    Transform trs;

    private void Awake()
    {
        trs = transform;
    }

    void LateUpdate()
    {
        Vector3 targetPos = target.position + target.right * offset.x + target.up * offset.y + target.forward * offset.z;
        Quaternion rotation = Quaternion.LookRotation(targetPos - trs.position);
        trs.rotation = Quaternion.Slerp(trs.rotation, rotation, Time.deltaTime * speed);
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/TrainCamera.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/TrainEngine.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0ba50a673a77e124fa87e009ea3055d6
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines.Examples
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using Dreamteck.Splines;
    using System;

    public class TrainEngine : MonoBehaviour
    {
        private SplineTracer _tracer = null;
        private double _lastPercent = 0.0;
        private Wagon _wagon;

        private void Awake()
        {
            _wagon = GetComponent<Wagon>();
        }

        void Start()
        {
            _tracer = GetComponent<SplineTracer>();
            //Subscribe to the onNode event to receive junction information automatically when a Node is passed
            _tracer.onNode += OnJunction;
            //Subscribe to the onMotionApplied event so that we can immediately update the wagons' positions once the engine's position is set
            _tracer.onMotionApplied += OnMotionApplied;

            //If the tracer is a SplineFollower (which should be the the case), subscribe to onEndReached and onOnBeginningReached
            if (_tracer is SplineFollower)
            {
                SplineFollower follower = (SplineFollower)_tracer;
                Debug.Log("Subscribing to follower");
                follower.onBeginningReached += FollowerOnBeginningReached;
                follower.onEndReached += FollowerOnEndReached;
            }
        }

        private void OnMotionApplied()
        {
            //Apply the wagon's offset (this will recursively apply the offsets to the rest of the wagons in the chain)
            _lastPercent = _tracer.result.percent;
            _wagon.UpdateOffset();
        }

        /// <summary>
        /// Gets the last follower percent before reaching the beginning and looping / ping-ponging
        /// </summary>
        private void FollowerOnBeginningReached(double lastPercent)
        {
            _lastPercent = lastPercent;
        }

        /// <summary>
        /// Gets the last follower percent before reaching the end and looping / ping-ponging
        /// </summary>
        private void FollowerOnEndReached(double lastPercent)
        {
            _lastPercent = lastPercent;
        }

        //Called when the tracer has passed a junction (a Node)
        private void OnJunction(List<SplineTracer.NodeConnection> passed)
        {
            Node node = passed[0].node; //Get the node of the junction
            JunctionSwitch junctionSwitch = node.GetComponent<JunctionSwitch>(); //Look for a JunctionSwitch component
            if (junctionSwitch == null) return; //No JunctionSwitch - ignore it - this isn't a real junction
            if (junctionSwitch.bridges.Length == 0) return; //The JunctionSwitch does not have bridge elements
            foreach (JunctionSwitch.Bridge bridge in junctionSwitch.bridges)
            {
                //Look for a suitable bridge element based on the spline we are currently traversing
                if (!bridge.active) continue;
                if (bridge.a == bridge.b) continue; //Skip bridge if it points to the same spline  
                int currentConnection = 0;
                Node.Connection[] connections = node.GetConnections();
                //get the connected splines and find the index of the tracer's current spline
                for (int i = 0; i < connections.Length; i++)
                {
                    if (connections[i].spline == _tracer.spline)
                    {
                        currentConnection = i;
                        break;
                    }
                }
                //Skip the bridge if we are not on one of the splines that the switch connects
                if (currentConnection != bridge.a && currentConnection != bridge.b) continue;
                if (currentConnection == bridge.a)
                {
                    if ((int)_tracer.direction != (int)bridge.bDirection) continue;
                    //This bridge is suitable and should use it
                    SwitchSpline(connections[bridge.a], connections[bridge.b]);
                    return;
                }
                else
                {
                    if ((int)_tracer.direction != (int)bridge.aDirection) continue;
                    //This bridge is suitable and should use it
                    SwitchSpline(connections[bridge.b], connections[bridge.a]);
                    return;
                }
            }
        }

        void SwitchSpline(Node.Connection from, Node.Connection to)
        {
            //See how much units we have travelled past that Node in the last frame
           
            float excessDistance = from.spline.CalculateLength(from.spline.GetPointPercent(from.pointIndex), _tracer.UnclipPercent(_lastPercent));
            //Set the spline to the tracer
            _tracer.spline = to.spline;
            _tracer.RebuildImmediate();
            //Get the location of the junction point in percent along the new spline
            double startpercent = _tracer.ClipPercent(to.spline.GetPointPercent(to.pointIndex));
            if (Vector3.Dot(from.spline.Evaluate(from.pointIndex).forward, to.spline.Evaluate(to.pointIndex).forward) < 0f)
            {
                if (_tracer.direction == Spline.Direction.Forward) _tracer.direction = Spline.Direction.Backward;
                else _tracer.direction = Spline.Direction.Forward;
            }
            //Position the tracer at the new location and travel excessDistance along the new spline
            _tracer.SetPercent(_tracer.Travel(startpercent, excessDistance, _tracer.direction));
            //Notify the wagon that we have entered a new spline segment
            _wagon.EnterSplineSegment(from.pointIndex, _tracer.spline, to.pointIndex, _tracer.direction);
            _wagon.UpdateOffset();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/TrainEngine.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/Wagon.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2c5b28aa5a478e44297c3dd32a5c35f1
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines.Examples
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class Wagon : MonoBehaviour
    {
        //A helper class which contains an information for a spline and the points 
        //between which the spline is traversed (start and end)
        //If one of the points is equal to -1 it means that there is no constraint
        public class SplineSegment
        {
            public SplineComputer spline;
            public int start = -1, end = -1;
            public Spline.Direction direction;

            public SplineSegment(SplineComputer spline, int entryPoint, Spline.Direction direction)
            {
                this.spline = spline;
                start = entryPoint;
                this.direction = direction;
            }

            public SplineSegment(SplineSegment input)
            {
                spline = input.spline;
                start = input.start;
                end = input.end;
                direction = input.direction;
            }

            public double Travel(double percent, float distance, Spline.Direction direction, out float moved, bool loop)
            {
                double max = direction == Spline.Direction.Forward ? 1.0 : 0.0;
                if (start >= 0) max = spline.GetPointPercent(start);
                return TravelClamped(percent, distance, direction, max, out moved, loop);
            }

            //Travel the spline segment by automatically starting at the segment's exit (end)
            public double Travel(float distance, Spline.Direction direction, out float moved, bool loop)
            {
                double startPercent = spline.GetPointPercent(end);
                double max = direction == Spline.Direction.Forward ? 1.0 : 0.0;
                if (start >= 0) max = spline.GetPointPercent(start);
                return TravelClamped(startPercent, distance, direction, max, out moved, loop);
            }

            //Travel the spline segment while not exceeding the "max" percent
            //It also supports looping splines unlike the standard Travel methods found in SplineComputer and SplineUser
            double TravelClamped(double percent, float distance, Spline.Direction direction, double max, out float moved, bool loop)
            {
                moved = 0f;
                float traveled = 0f;
                double result = spline.Travel(percent, distance, out traveled, direction);
                moved += traveled;
                if (loop && moved < distance) {
                    if (direction == Spline.Direction.Forward && Mathf.Approximately((float)result, 1f))
                    {
                        result = spline.Travel(0.0, distance - moved, out traveled, direction);
                    } else if (direction == Spline.Direction.Backward && Mathf.Approximately((float)result, 0f))
                    {
                        result = spline.Travel(1.0, distance - moved, out traveled, direction);
                    }
                    moved += traveled;
                }
                if (direction == Spline.Direction.Forward && percent <= max)
                {
                    if (result > max)
                    {
                        moved -= spline.CalculateLength(result, max);
                        result = max;
                    }
                }
                else if (direction == Spline.Direction.Backward && percent >= max)
                {
                    if (result < max)
                    {
                        moved -= spline.CalculateLength(max, result);
                        result = max;
                    }
                }
                return result;
            }
        }

        SplineTracer tracer;
        public bool isEngine = false;
        public Wagon back;
        public float offset = 0f;
        Wagon front;
        SplineSegment segment, tempSegment;

        private void Awake()
        {
            tracer = GetComponent<SplineTracer>();
            //Wagon compoenent that is attached to the train engine and is marked as "isEngine" will
            //run a recursive setup for the rest of the wagons
            if (isEngine) SetupRecursively(null, new SplineSegment(tracer.spline, -1, tracer.direction));
        }

        void SetupRecursively(Wagon frontWagon, SplineSegment inputSegment)
        {
            front = frontWagon;
            segment = inputSegment;
            if (back != null) back.SetupRecursively(this, segment);
        }

        public void UpdateOffset()
        {
            ApplyOffset();
            if (back != null) back.UpdateOffset();
        }

        Wagon GetRootWagon()
        {
            Wagon current = this;
            while (current.front != null) current = current.front;
            return current;
        }

        void ApplyOffset()
        {
            if (isEngine)
            {
                ResetSegments();
                return;
            }
            float totalMoved = 0f, moved = 0f;
            double start = front.tracer.UnclipPercent(front.tracer.result.percent);
            //Travel backwards along the front wagon's spline
            Spline.Direction inverseDirection = front.segment.direction;
            InvertDirection(ref inverseDirection);
            SplineComputer spline = front.segment.spline;
            double percent = front.segment.Travel(start, offset, inverseDirection, out moved, front.segment.spline.isClosed);
            totalMoved += moved;
            //Finalize if moved fully without reaching a spline end or a junction
            if (Mathf.Approximately(totalMoved, offset))
            {
                if (segment != front.segment)
                {
                    if (back != null) back.segment = segment;
                }
                if(segment != front.segment) segment = front.segment;
                ApplyTracer(spline, percent, front.tracer.direction);
                return;
            }

            //Otherwise, move along the current recorded spline segment
            if (segment != front.segment)
            {
                inverseDirection = segment.direction;
                InvertDirection(ref inverseDirection);
                spline = segment.spline;
                percent = segment.Travel(offset - totalMoved, inverseDirection, out moved, segment.spline.isClosed);
                totalMoved += moved;
            }
            ApplyTracer(spline, percent, segment.direction);
        }

        void ResetSegments()
        {
            Wagon current = back;
            bool same = true;
            while (current != null)
            {
                if(current.segment != segment)
                {
                    same = false;
                    break;
                }
                current = current.back;
            }
            //if all wagons are on the same segment, remove the segment entrance so that they can loop
            if(same) segment.start = -1; 
        }

        void ApplyTracer(SplineComputer spline, double percent, Spline.Direction direction)
        {
            bool rebuild = tracer.spline != spline;
            tracer.spline = spline;
            if (rebuild) tracer.RebuildImmediate();
            tracer.direction = direction;
            tracer.SetPercent(tracer.ClipPercent(percent));
        }

        public void EnterSplineSegment(int previousSplineExitPoint, SplineComputer spline, int entryPoint, Spline.Direction direction)
        {
            if (!isEngine) return;
            if (back != null)
            {
                segment.end = previousSplineExitPoint;
                back.segment = segment;
            }
            segment = new SplineSegment(spline, entryPoint, direction);
        }

        static void InvertDirection(ref Spline.Direction direction)
        {
            if (direction == Spline.Direction.Forward) direction = Spline.Direction.Backward;
            else direction = Spline.Direction.Forward;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Junctions/Scripts/Wagon.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/LengthEvents/SetMaterialColor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ead07211d73ff3848bedef5c9a977eb0
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;

namespace Dreamteck.Splines.Examples
{
    public class SetMaterialColor : MonoBehaviour
    {
        public Color[] colors;
        SplineRenderer rend;

        private void Start()
        {
            rend = GetComponent<SplineRenderer>();
        }

        public void SetColor(int index)
        {
            if (!Application.isPlaying) return;
            rend.color = colors[index];
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/LengthEvents/SetMaterialColor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/AddForceAlongPath.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6238ae714f0e21c4d81ecfff7fa4e25f
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines.Examples
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class AddForceAlongPath : MonoBehaviour
    {
        public float force = 10f;
        Rigidbody rb;
        SplineProjector projector;

        void Start()
        {
            rb = GetComponent<Rigidbody>();
            projector = GetComponent<SplineProjector>();
        }

        void Update()
        {
            if (Input.GetKeyDown(KeyCode.Space))
            {
                rb.AddForce(projector.result.forward * force, ForceMode.Impulse);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/AddForceAlongPath.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/BallCamera.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ac3147ab308bce045b6fb97d983b610b
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines.Examples
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class BallCamera : MonoBehaviour
    {
        public Rigidbody rb;
        public SplineProjector projector;
        public float positionSpeed = 10f;
        public Vector3 offset = Vector3.zero;
        public float rotationSpeed = 0.5f;
        public Vector3 rotationOffset = Vector3.zero;

        Transform trs;

        private void Awake()
        {
            trs = transform;
            trs.position = rb.position + projector.result.rotation * offset;
            trs.rotation = projector.result.rotation * Quaternion.Euler(rotationOffset);
        }

        void FixedUpdate()
        {
            Vector3 idealPosition = rb.position + trs.rotation * offset;
            Quaternion idealRotation = projector.result.rotation * Quaternion.Euler(rotationOffset);
            trs.position = Vector3.Lerp(trs.position, idealPosition, Time.deltaTime * positionSpeed);
            trs.rotation = Quaternion.Slerp(trs.rotation, idealRotation, Time.deltaTime * rotationSpeed);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/BallCamera.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/LapCounter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a8386d58bfae1c049a2b1428bfff6b85
# ASMDEF: Dreamteck.Splines.dll
# ---
namespace Dreamteck.Splines.Examples
{
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class LapCounter : MonoBehaviour
    {
        int currentLap;
        public TextMesh text;

        public void CountLap()
        {
            currentLap++;
            text.text = "LAP " + currentLap;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/Projection/Scripts/LapCounter.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/RollerCoaster/Scripts/CameraLook.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7834d8d9fc100c3428eac25d2c967646
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;

namespace Dreamteck.Splines.Examples
{
    public class CameraLook : MonoBehaviour
    {
        public float sensitivity = 3f;
        public float dampSpeed = 0f;
        public float lookRange = 45f;
        private float x = 0f;
        private float y = 0f;

        private float xMove = 0f;
        private float yMove = 0f;

        private float crosshairZ = 5f;
        private float idealCrosshairZ = 3f;

        public Transform crosshairSphere;

        // Update is called once per frame
        void Update()
        {
            xMove = Mathf.MoveTowards(xMove, 0f, Time.deltaTime * dampSpeed);
            yMove = Mathf.MoveTowards(yMove, 0f, Time.deltaTime * dampSpeed);
            xMove += Input.GetAxis("Mouse X") / 10f;
            yMove -= Input.GetAxis("Mouse Y") / 10f;
            xMove = Mathf.Clamp(xMove, -1f, 1f);
            yMove = Mathf.Clamp(yMove, -1f, 1f);
            float halfLookRange = lookRange / 2f;
            x += xMove * Time.deltaTime * sensitivity;
            y += yMove * Time.deltaTime * sensitivity;

            if (x > halfLookRange)
            {
                x = halfLookRange;
                if (xMove > 0f) xMove = 0f;
            }
            else if (x < -halfLookRange)
            {
                x = -halfLookRange;
                if (xMove < 0f) xMove = 0f;
            }
            if (y > halfLookRange)
            {
                y = halfLookRange;
                if (yMove > 0f) yMove = 0f;
            }
            else if (y < -halfLookRange)
            {
                y = -halfLookRange;
                if (yMove < 0f) yMove = 0f;
            }
            if (crosshairSphere != null && crosshairSphere.gameObject.activeSelf)
            {
                idealCrosshairZ += Input.GetAxis("Mouse ScrollWheel") * 4f;
                idealCrosshairZ = Mathf.Clamp(idealCrosshairZ, 2f, 6f);
                crosshairZ = Mathf.MoveTowards(crosshairZ, idealCrosshairZ, Time.deltaTime * 8f);
                Vector3 localPos = crosshairSphere.localPosition;
                localPos.z = crosshairZ;
                crosshairSphere.localPosition = localPos;
            }
            this.transform.localRotation = Quaternion.AngleAxis(x, Vector3.up) * Quaternion.AngleAxis(y, Vector3.right);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/RollerCoaster/Scripts/CameraLook.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/RollerCoaster/Scripts/RollerCoaster.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 604a3d1981eee7543a0d98eb9bca640d
# ASMDEF: Dreamteck.Splines.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace Dreamteck.Splines.Examples
{
    public class RollerCoaster : MonoBehaviour
    {
        [System.Serializable]
        public class CoasterSound
        {
            public float startPercent = 0f;
            public float endPercent = 1f;
            public AudioSource source;
            public float startPitch = 1f;
            public float endPitch = 1f;
        }

        public float speed = 10f;
        public float minSpeed = 1f;
        public float maxSpeed = 20f;
        public float frictionForce = 0.1f;
        public float gravityForce = 1f;
        public float slopeRange = 60f;
        SplineFollower follower;
        public AnimationCurve speedGain;
        public AnimationCurve speedLoss;
        public float brakeSpeed = 0f;
        public float brakeReleaseSpeed = 0f;

        private float brakeTime = 0f;
        private float brakeForce = 0f;
        private float addForce = 0f;

        public CoasterSound[] sounds;
        public AudioSource brakeSound;
        public AudioSource boostSound;
        public float soundFadeLength = 0.15f;


        // Use this for initialization
        void Start()
        {
            follower = GetComponent<SplineFollower>();
            follower.onEndReached += OnEndReached;
            Cursor.lockState = CursorLockMode.Locked;
        }

        void OnEndReached(double last)
        {
            //Detect when the wagon has reached the end of the spline
            List<SplineComputer> computers = new List<SplineComputer>();
            List<int> connections = new List<int>();
            List<int> connected = new List<int>();
            follower.spline.GetConnectedComputers(computers, connections, connected, 1.0, follower.direction, true); //Get the avaiable connected computers at the end of the spline
            if (computers.Count == 0) return;
            //Do not select computers that are not connected at the first point so that we don't reverse direction
            for (int i = 0; i < computers.Count; i++)
            {
                if(connected[i] != 0)
                {
                    computers.RemoveAt(i);
                    connections.RemoveAt(i);
                    connected.RemoveAt(i);
                    i--;
                    continue;
                }
            }
            float distance = follower.CalculateLength(0.0, follower.result.percent); //Get the excess distance after looping
            follower.spline = computers[Random.Range(0, computers.Count)]; //Change the spline computer to the new spline
            follower.SetDistance(distance); //Set the excess distance along the new spline
        }

        // Update is called once per frame
        void Update()
        {
            if (Input.GetKeyDown(KeyCode.Escape)) Cursor.lockState = CursorLockMode.None;
            float dot = Vector3.Dot(this.transform.forward, Vector3.down);
            float dotPercent = Mathf.Lerp(-slopeRange / 90f, slopeRange / 90f, (dot + 1f) / 2f);
            speed -= Time.deltaTime * frictionForce * (1f - brakeForce);
            float speedAdd = 0f;
            float speedPercent = Mathf.InverseLerp(minSpeed, maxSpeed, speed);
            if (dotPercent > 0f)
            {
                speedAdd = gravityForce * dotPercent * speedGain.Evaluate(speedPercent) * Time.deltaTime;
            }
            else
            {
                speedAdd = gravityForce * dotPercent * speedLoss.Evaluate(1f-speedPercent) * Time.deltaTime;
            }
            speed += speedAdd * (1f-brakeForce);
            speed = Mathf.Clamp(speed, minSpeed, maxSpeed);
            if (addForce > 0f) {
                float lastAdd = addForce;
                addForce = Mathf.MoveTowards(addForce, 0f, Time.deltaTime * 30f);
                speed += lastAdd - addForce;
             }
            follower.followSpeed = speed;
            follower.followSpeed *= (1f - brakeForce);
            if (brakeTime > Time.time) brakeForce = Mathf.MoveTowards(brakeForce, 1f, Time.deltaTime * brakeSpeed);
            else brakeForce = Mathf.MoveTowards(brakeForce, 0f, Time.deltaTime * brakeReleaseSpeed);

            speedPercent = Mathf.Clamp01(speed/maxSpeed)*(1f-brakeForce);
            for (int i = 0; i < sounds.Length; i++) {
                if (speedPercent < sounds[i].startPercent - soundFadeLength || speedPercent > sounds[i].endPercent + soundFadeLength)
                {
                    if (sounds[i].source.isPlaying) sounds[i].source.Pause();
                    continue;
                }
                else if (!sounds[i].source.isPlaying) sounds[i].source.UnPause();
                float volume = 1f;
                if (speedPercent < sounds[i].startPercent+soundFadeLength) volume = Mathf.InverseLerp(sounds[i].startPercent, sounds[i].startPercent+soundFadeLength, speedPercent);
                else if (speedPercent > sounds[i].endPercent) volume = Mathf.InverseLerp(sounds[i].endPercent + soundFadeLength, sounds[i].endPercent, speedPercent);
                float pitchPercent = Mathf.InverseLerp(sounds[i].startPercent, sounds[i].endPercent, speedPercent);
                sounds[i].source.volume = volume;
                sounds[i].source.pitch = Mathf.Lerp(sounds[i].startPitch, sounds[i].endPitch, pitchPercent);
            }

        }

        public void AddBrake(float time)
        {
            brakeTime = Time.time + time;
            brakeSound.Stop();
            brakeSound.Play();
        }

        public void RemoveBrake()
        {
            brakeTime = 0f;
        }

        public void AddForce(float amount)
        {
            addForce = amount;
            boostSound.Stop();
            boostSound.Play();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Splines/Examples/RollerCoaster/Scripts/RollerCoaster.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/ArrayUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 82febc9d0aa4907478f53a8dd5e86318
# ASMDEF: Dreamteck.Utilities.dll
# ---
namespace Dreamteck
{
    using System;

    public static class ArrayUtility
    {
        public static void Add<T>(ref T[] array, T item)
        {
            T[] newArray = new T[array.Length + 1];
            array.CopyTo(newArray, 0);
            newArray[newArray.Length - 1] = item;
            array = newArray;
        }
        public static bool Contains<T>(T[] array, T item)
        {
            for (int i = 0; i < array.Length; i++)
            {
                try
                {
                    if (array[i].Equals(item)) return true;
                }
                catch
                {

                }
            }
            return false;
        }
        public static int IndexOf<T>(T[] array, T value)
        {
            for (int i = 0; i < array.Length; i++)
            {
                if (array[i].Equals(value)) return i;
            }
            return 0;
        }
        public static void Insert<T>(ref T[] array, int index, T item)
        {
            T[] newArray = new T[array.Length + 1];
            for (int i = 0; i < newArray.Length; i++)
            {
                if (i < index) newArray[i] = array[i];
                else if (i > index) newArray[i] = array[i - 1];
                else newArray[i] = item;
            }
            array = newArray;
        }


        public static void RemoveAt<T>(ref T[] array, int index)
        {
            if (array.Length == 0) return;
            T[] newArray = new T[array.Length - 1];
            for (int i = 0; i < array.Length; i++)
            {
                if (i < index) newArray[i] = array[i];
                else if (i > index) newArray[i-1] = array[i];
            }
            array = newArray;
        }

        public static void ForEach<T>(this T[] source, Action<T> onLoop)
        {
            foreach (var item in source)
            {
                onLoop(item);
            }
        }

        public static void SetLength<T>(ref T[] source, int newCount)
        {
            T[] newArray = new T[newCount];
            for (int i = 0; i < UnityEngine.Mathf.Min(newCount, source.Length); i++)
            {
                newArray[i] = source[i];
            }
            source = newArray;
        }

        public static void ShiftLeft<T>(this T[] source, int startIndex = 0, bool loop = true)
        {
            var startItem = source[startIndex];
            for (int i = startIndex; i < source.Length-1; i++)
            {
                source[i] = source[i + 1];
            }
            source[source.Length - 1] = loop ? startItem : default;
        }

        public static void ShiftRight<T>(this T[] source, int startIndex = 0, bool loop = true)
        {
            var startItem = source[source.Length - 1];
            for (int i = startIndex + 1; i < source.Length; i++)
            {
                source[i] = source[i - 1];
            }
            source[startIndex] = loop ? startItem : default;
        }

        public static TArray[] QuickSort<TArray,T> (this TArray[] array, Func<TArray,T> getProperty, int leftIndex, int rightIndex) where T : IComparable
        {
            
            var i = leftIndex;
            var j = rightIndex;
            var pivot = getProperty(array[leftIndex]);
            while (i <= j)
            {
                while (getProperty(array[i]).CompareTo(pivot) == -1)
                {
                    i++;
                }

                while (getProperty(array[j]).CompareTo(pivot) == 1)
                {
                    j--;
                }
                if (i <= j)
                {
                    var temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                    i++;
                    j--;
                }
            }

            if (leftIndex < j)
                QuickSort(array, getProperty, leftIndex, j);
            if (i < rightIndex)
                QuickSort(array,getProperty, i, rightIndex);
            return array;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/ArrayUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/AsyncJobSystem.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b5b5fc53001826741b2918682cb3c804
# ASMDEF: Dreamteck.Utilities.dll
# ---
using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Debug = UnityEngine.Debug;

namespace Dreamteck
{
    public class AsyncJobSystem : MonoBehaviour
    {
        private Queue<IJobData> _jobs = new Queue<IJobData>();

        private IJobData _currentJob = null;

        private bool _isWorking = false;

        public AsyncJobOperation ScheduleJob<T>(JobData<T> data)
        {
            _jobs.Enqueue(data);
            return new AsyncJobOperation(data);
        }

        private void Update()
        {
            if (_jobs.Count > 0 && !_isWorking)
            {
                StartCoroutine(JobCoroutine());
            }
        }

        private IEnumerator JobCoroutine()
        {
            _isWorking = true;
            
            while (_jobs.Count > 0)
            {
                _currentJob = _jobs.Dequeue();
                _currentJob.Initialize();

                while (!_currentJob.done)
                {
                    _currentJob.Next();
                    yield return null;
                }

                _currentJob.Complete();
                _currentJob = null;

                yield return null;
            }

            _isWorking = false;
        }


        public class AsyncJobOperation : CustomYieldInstruction
        {
            private IJobData _job;
            
            public AsyncJobOperation(IJobData job)
            {
                _job = job;
            }

            public override bool keepWaiting {
                get { return !_job.done; }
            }
        }

        public interface IJobData
        {
            bool done { get; }

            void Initialize();

            void Next();

            void Complete();
        }

        public class JobData<T> : IJobData
        {
            private int _index;

            private int _iterations = 0;

            private IEnumerable<T> _collection;

            private Action<JobData<T>> _onComplete;

            private Action<JobData<T>> _onIteration;

            private IEnumerator<T> _enumerator;

            public T current { get { return _enumerator.Current; } }

            public int index  { get  { return _index; } }

            public IEnumerable<T> collection { get { return _collection; } }

            public bool done { get; private set; }

            public JobData(IEnumerable<T> collection, int iterations, Action<JobData<T>> onIteration)
            {
                _collection = collection;
                _onIteration = onIteration;
                _iterations = iterations;
                done = false;
            }

            public JobData(IEnumerable<T> collection, int iterations, Action<JobData<T>> onIteration, Action<JobData<T>> onComplete) :
                this(collection, iterations, onIteration)
            {
                _onComplete = onComplete;
            }

            public void Initialize()
            {
                _enumerator = _collection.GetEnumerator();
                _index = -1;
                done = !_enumerator.MoveNext();
            }

            public void Complete()
            {
                _enumerator.Dispose();

                try
                {
                    if (_onComplete != null) {
                        _onComplete(this);
                    }
                }
                catch (Exception e)
                {
                    Debug.LogException(e);
                }
            }

            public void Next()
            {
                int counter = _iterations;

                if (done)
                {
                    return;
                }
                do
                {
                    _index++;

                    try
                    {
                        if(_onIteration != null)
                        {
                            _onIteration(this);
                        }
                    }
                    catch (Exception e)
                    {
                        Debug.LogException(e);
                    }
                    done = !_enumerator.MoveNext();
                }
                while (!done && --counter > 0);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/AsyncJobSystem.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/DMath.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 012b8f43a890d8248b810901033c66a3
# ASMDEF: Dreamteck.Utilities.dll
# ---
using UnityEngine;
using System.Collections;
using System;

namespace Dreamteck
{
    public static class DMath
    {
        public static double Sin(double a)
        {
            return Math.Sin(a);
        }

        public static double Cos(double a)
        {
            return Math.Cos(a);
        }

        public static double Tan(double a)
        {
            return Math.Tan(a);
        }

        public static double Pow(double x, double y)
        {
            return Math.Pow(x, y);
        }

        public static double Log(double a, double newBase)
        {
            return Math.Log(a, newBase);
        }

        public static double Log10(double a)
        {
            return Math.Log10(a);
        }

        public static double Clamp01(double a)
        {
            if (a > 1.0) return 1.0;
            if (a < 0.0) return 0.0;
            return a;
        }

        public static double Clamp(double a, double min, double max)
        {
            if (a > max) return max;
            if (a < min) return min;
            return a;
        }

        public static double Lerp(double a, double b, double t)
        {
            t = Clamp01(t);
            return a + (b - a) * t;
        }

        public static double InverseLerp(double a, double b, double t)
        {
            if (a == b) return 0.0;
            return Clamp01((t-a)/(b-a));
        }

        public static void LerpVector3NonAlloc(Vector3 a, Vector3 b, double t, ref Vector3 target)
        {
            t = Clamp01(t);
            Vector3 delta = (b - a);
            target.x = (float)(a.x + delta.x * t);
            target.y = (float)(a.y + delta.y * t);
            target.z = (float)(a.z + delta.z * t);
        }

        public static Vector3 LerpVector3(Vector3 a, Vector3 b, double t)
        {
            Vector3 result = Vector3.zero;
            LerpVector3NonAlloc(a, b, t, ref result);
            return result;
        }

        public static double Round(double a)
        {
            return Math.Round(a);
        }

        public static int RoundInt(double a)
        {
            return (int)Math.Round(a);
        }

        public static double Ceil(double a)
        {
            return Math.Ceiling(a);
        }

        public static int CeilInt(double a)
        {
            return (int)Math.Ceiling(a);
        }

        public static double Floor(double a)
        {
            return Math.Floor(a);
        }

        public static int FloorInt(double a)
        {
            return (int)Math.Floor(a);
        }

        public static double Move(double current, double target, double amount)
        {
            if (target > current)
            {
                current += amount;
                if (current > target) return target;
            }
            else
            {
                current -= amount;
                if (current < target) return target;
            }
            return current;
        }

        public static double Abs(double a)
        {
            if (a < 0.0) return a * -1.0;
            return a;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/DMath.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/DuplicateUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1a72578399b94604b8ad3f608ef130ea
# ASMDEF: Dreamteck.Utilities.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck
{
    public static class DuplicateUtility
    {
        public static AnimationCurve DuplicateCurve(AnimationCurve input)
        {
            AnimationCurve target = new AnimationCurve();
            target.postWrapMode = input.postWrapMode;
            target.preWrapMode = input.preWrapMode;
            for (int i = 0; i < input.keys.Length; i++) target.AddKey(input.keys[i]);
            return target;
        }

        public static Gradient DuplicateGradient(Gradient input)
        {
            //yet to implement
            return null;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/DuplicateUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/LinearAlgebraUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c9db18633d04e91409973e2ca7ab9c76
# ASMDEF: Dreamteck.Utilities.dll
# ---
using UnityEngine;
using System.Collections;
using System.IO;

namespace Dreamteck
{
    public static class LinearAlgebraUtility
    {
        public enum Axis
        {
            X = 0,
            Y = 1,
            Z = 2
        }

        public static Vector3 ProjectOnLine(Vector3 fromPoint, Vector3 toPoint, Vector3 project)
        {
            Vector3 projectedPoint = Vector3.Project((project - fromPoint), (toPoint - fromPoint)) + fromPoint;
            Vector3 dir = toPoint - fromPoint;
            Vector3 projectedDir = projectedPoint - fromPoint;
            float dot = Vector3.Dot(projectedDir, dir);
            if(dot > 0f)
            {
                if(projectedDir.sqrMagnitude <= dir.sqrMagnitude) return projectedPoint;
                else return toPoint;
            } else return fromPoint;
        }

        public static float InverseLerp(Vector3 a, Vector3 b, Vector3 value)
        {
            Vector3 ab = b - a;
            Vector3 av = value - a;
            return Vector3.Dot(av, ab) / Vector3.Dot(ab, ab);
        }

        public static float DistanceOnSphere(Vector3 from, Vector3 to, float radius)
        {
            float distance = 0;
            
            if (from == to)
            {
                distance = 0;
            }
            else if (from == -to)
            {
                distance = Mathf.PI * radius;
            }
            else
            {
                distance = Mathf.Sqrt(2) * radius * Mathf.Sqrt(1.0f - Vector3.Dot(from, to));
            }

            return distance;
        }

        public static Vector3 FlattenVector(Vector3 input, Axis axis, float flatValue = 0f)
        {
            switch (axis)
            {
                case Axis.X: input.x = flatValue; break;
                case Axis.Y: input.y = flatValue; break;
                case Axis.Z: input.z = flatValue; break;
            }
            return input;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/LinearAlgebraUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/MeshUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 81cc5b669f819ca42a81d2c18c654e23
# ASMDEF: Dreamteck.Utilities.dll
# ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace Dreamteck
{
    public class MeshUtility
    {
        private static Vector3[] tan1 = new Vector3[0];
        private static Vector3[] tan2 = new Vector3[0];

        public static int[] GeneratePlaneTriangles(int x, int z, bool flip, int startTriangleIndex = 0, int startVertex = 0)
        {
            int nbFaces = x * (z - 1);
            int[] triangles = new int[nbFaces * 6];
            GeneratePlaneTriangles(ref triangles, x, z, flip);
            return triangles;
        }

        public static int[] GeneratePlaneTriangles(ref int[] triangles, int x, int z, bool flip, int startTriangleIndex = 0, int startVertex = 0, bool reallocateArray = false)
        {
            int nbFaces = x * (z - 1);
            if (reallocateArray && triangles.Length != nbFaces * 6)
            {
                if(startTriangleIndex > 0)
                {
                    int[] newTris = new int[startTriangleIndex + nbFaces * 6];
                    for(int i = 0; i < startTriangleIndex; i++) newTris[i] = triangles[i];
                    triangles = newTris;
                } else triangles = new int[nbFaces * 6];
            }
            int g = x + 1;
            int t = startTriangleIndex;
            for (int face = 0; face < nbFaces + z - 2; face++)
            {
                if ((float)(face + 1) % (float)g == 0f && face != 0) face++;
                if (flip)
                {
                    triangles[t++] = face + x + 1 + startVertex;
                    triangles[t++] = face + 1 + startVertex;
                    triangles[t++] = face + startVertex;

                    triangles[t++] = face + x + 1 + startVertex;
                    triangles[t++] = face + x + 2 + startVertex;
                    triangles[t++] = face + 1 + startVertex;
                }
                else
                {
                    triangles[t++] = face + startVertex;
                    triangles[t++] = face + 1 + startVertex;
                    triangles[t++] = face + x + 1 + startVertex;

                    triangles[t++] = face + 1 + startVertex;
                    triangles[t++] = face + x + 2 + startVertex;
                    triangles[t++] = face + x + 1 + startVertex;
                }
            } 
            return triangles;
        }

        public static void CalculateTangents(TS_Mesh mesh)
        {
            int triangleCount = mesh.triangles.Length / 3;
            if (mesh.tangents.Length != mesh.vertexCount)  mesh.tangents = new Vector4[mesh.vertexCount];
            if (tan1.Length != mesh.vertexCount)
            {
                tan1 = new Vector3[mesh.vertexCount];
                tan2 = new Vector3[mesh.vertexCount];
            }

            int tri = 0;
            for (int i = 0; i < triangleCount; i++)
            {
                int i1 = mesh.triangles[tri];
                int i2 = mesh.triangles[tri + 1];
                int i3 = mesh.triangles[tri + 2];

                float x1 = mesh.vertices[i2].x - mesh.vertices[i1].x;
                float x2 = mesh.vertices[i3].x - mesh.vertices[i1].x;
                float y1 = mesh.vertices[i2].y - mesh.vertices[i1].y;
                float y2 = mesh.vertices[i3].y - mesh.vertices[i1].y;
                float z1 = mesh.vertices[i2].z - mesh.vertices[i1].z;
                float z2 = mesh.vertices[i3].z - mesh.vertices[i1].z;

                float s1 = mesh.uv[i2].x - mesh.uv[i1].x;
                float s2 = mesh.uv[i3].x - mesh.uv[i1].x;
                float t1 = mesh.uv[i2].y - mesh.uv[i1].y;
                float t2 = mesh.uv[i3].y - mesh.uv[i1].y;

                float div = s1 * t2 - s2 * t1;
                float r = div == 0f ? 0f : 1f / div;

                Vector3 sdir = new Vector3((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
                Vector3 tdir = new Vector3((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);

                tan1[i1] += sdir;
                tan1[i2] += sdir;
                tan1[i3] += sdir;

                tan2[i1] += tdir;
                tan2[i2] += tdir;
                tan2[i3] += tdir;

                tri += 3;
            }

            for (int i = 0; i < mesh.vertexCount; i++)
            {
                Vector3 n = mesh.normals[i];
                Vector3 t = tan1[i];
                Vector3.OrthoNormalize(ref n, ref t);
                mesh.tangents[i].x = t.x;
                mesh.tangents[i].y = t.y;
                mesh.tangents[i].z = t.z;
                mesh.tangents[i].w = (Vector3.Dot(Vector3.Cross(n, t), tan2[i]) < 0.0f) ? -1.0f : 1.0f;
            }
        }

        public static void MakeDoublesided(Mesh input)
        {
            Vector3[] vertices = input.vertices;
            Vector3[] normals = input.normals;
            Vector2[] uvs = input.uv;
            Color[] colors = input.colors;
            int[] triangles = input.triangles;
            List<int[]> submeshes = new List<int[]>();
            for (int i = 0; i < input.subMeshCount; i++) submeshes.Add(input.GetTriangles(i));

            Vector3[] newVertices = new Vector3[vertices.Length * 2];
            Vector3[] newNormals = new Vector3[normals.Length * 2];
            Vector2[] newUvs = new Vector2[uvs.Length * 2];
            Color[] newColors = new Color[colors.Length * 2];
            int[] newTris = new int[triangles.Length * 2];
            List<int[]> newSubmeshes = new List<int[]>();
            for (int i = 0; i < submeshes.Count; i++)
            {
                newSubmeshes.Add(new int[submeshes[i].Length * 2]);
                submeshes[i].CopyTo(newSubmeshes[i], 0);
            }

            for (int i = 0; i < vertices.Length; i++)
            {
                newVertices[i] = vertices[i];
                newNormals[i] = normals[i];
                newUvs[i] = uvs[i];
                if (colors.Length > i) newColors[i] = colors[i];

                newVertices[i + vertices.Length] = vertices[i];
                newNormals[i + vertices.Length] = -normals[i];
                newUvs[i + vertices.Length] = uvs[i];
                if (colors.Length > i) newColors[i + vertices.Length] = colors[i];
            }

            for (int i = 0; i < triangles.Length; i += 3)
            {
                int index1 = triangles[i];
                int index2 = triangles[i + 1];
                int index3 = triangles[i + 2];
                newTris[i] = index1;
                newTris[i + 1] = index2;
                newTris[i + 2] = index3;

                newTris[i + triangles.Length] = index3 + vertices.Length;
                newTris[i + triangles.Length + 1] = index2 + vertices.Length;
                newTris[i + triangles.Length + 2] = index1 + vertices.Length;
            }

            for (int i = 0; i < submeshes.Count; i++)
            {
                for (int n = 0; n < submeshes[i].Length; n += 3)
                {
                    int index1 = submeshes[i][n];
                    int index2 = submeshes[i][n + 1];
                    int index3 = submeshes[i][n + 2];
                    newSubmeshes[i][n] = index1;
                    newSubmeshes[i][n + 1] = index2;
                    newSubmeshes[i][n + 2] = index3;

                    newSubmeshes[i][n + submeshes[i].Length] = index3 + vertices.Length;
                    newSubmeshes[i][n + submeshes[i].Length + 1] = index2 + vertices.Length;
                    newSubmeshes[i][n + submeshes[i].Length + 2] = index1 + vertices.Length;
                }
            }

            input.vertices = newVertices;
            input.normals = newNormals;
            input.uv = newUvs;
            input.colors = newColors;
            input.triangles = newTris;
            for (int i = 0; i < newSubmeshes.Count; i++) input.SetTriangles(newSubmeshes[i], i);
        }

        public static void MakeDoublesided(TS_Mesh input)
        {
            Vector3[] vertices = input.vertices;
            Vector3[] normals = input.normals;
            Vector2[] uvs = input.uv;
            Color[] colors = input.colors;
            int[] triangles = input.triangles;
            List<int[]> submeshes = input.subMeshes;

            Vector3[] newVertices = new Vector3[vertices.Length * 2];
            Vector3[] newNormals = new Vector3[normals.Length * 2];
            Vector2[] newUvs = new Vector2[uvs.Length * 2];
            Color[] newColors = new Color[colors.Length * 2];
            int[] newTris = new int[triangles.Length * 2];
            List<int[]> newSubmeshes = new List<int[]>();
            for(int i = 0; i < submeshes.Count; i++)
            {
                newSubmeshes.Add(new int[submeshes[i].Length * 2]);
                submeshes[i].CopyTo(newSubmeshes[i], 0);
            }

            for (int i = 0; i < vertices.Length; i++)
            {
                newVertices[i] = vertices[i];
                newNormals[i] = normals[i];
                newUvs[i] = uvs[i];
                if(colors.Length > i) newColors[i] = colors[i];

                newVertices[i + vertices.Length] = vertices[i];
                newNormals[i + vertices.Length] = -normals[i];
                newUvs[i + vertices.Length] = uvs[i];
                if (colors.Length > i) newColors[i + vertices.Length] = colors[i];
            }

            for (int i = 0; i < triangles.Length; i += 3)
            {
                int index1 = triangles[i];
                int index2 = triangles[i + 1];
                int index3 = triangles[i + 2];
                newTris[i] = index1;
                newTris[i + 1] = index2;
                newTris[i + 2] = index3;

                newTris[i + triangles.Length] = index3 + vertices.Length;
                newTris[i + triangles.Length + 1] = index2 + vertices.Length;
                newTris[i + triangles.Length + 2] = index1 + vertices.Length;
            }

            for(int i = 0; i < submeshes.Count; i++)
            {
                for(int n = 0; n < submeshes[i].Length; n+= 3)
                {
                    int index1 = submeshes[i][n];
                    int index2 = submeshes[i][n + 1];
                    int index3 = submeshes[i][n + 2];
                    newSubmeshes[i][n] = index1;
                    newSubmeshes[i][n + 1] = index2;
                    newSubmeshes[i][n + 2] = index3;

                    newSubmeshes[i][n + submeshes[i].Length] = index3 + vertices.Length;
                    newSubmeshes[i][n + submeshes[i].Length + 1] = index2 + vertices.Length;
                    newSubmeshes[i][n + submeshes[i].Length + 2] = index1 + vertices.Length;
                }
            }

            input.vertices = newVertices;
            input.normals = newNormals;
            input.uv = newUvs;
            input.colors = newColors;
            input.triangles = newTris;
            input.subMeshes = newSubmeshes;
        }

        public static void MakeDoublesidedHalf(TS_Mesh input)
        {
            int vertexHalf = input.vertices.Length / 2;
            int trisHalf = input.triangles.Length / 2;
            for (int i = 0; i < vertexHalf; i++)
            {
                input.vertices[i + vertexHalf] = input.vertices[i];
                if (input.normals.Length > i) input.normals[i + vertexHalf] = -input.normals[i];
                if (input.tangents.Length > i) input.tangents[i + vertexHalf] = input.tangents[i];
                if (input.uv.Length > i) input.uv[i + vertexHalf] = input.uv[i];
                if (input.uv2.Length > i) input.uv2[i + vertexHalf] = input.uv2[i];
                if (input.uv3.Length > i) input.uv3[i + vertexHalf] = input.uv3[i];
                if (input.uv4.Length > i) input.uv4[i + vertexHalf] = input.uv4[i];
                if (input.colors.Length > i) input.colors[i + vertexHalf] = input.colors[i];
            }

            for (int i = 0; i < trisHalf; i += 3)
            {
                input.triangles[i + trisHalf + 2] = input.triangles[i] + vertexHalf;
                input.triangles[i + trisHalf + 1] = input.triangles[i + 1] + vertexHalf;
                input.triangles[i + trisHalf] = input.triangles[i + 2] + vertexHalf;
            }

            for (int i = 0; i < input.subMeshes.Count; i++)
            {
                trisHalf = input.subMeshes[i].Length / 2;
                for (int n = 0; n < trisHalf; n += 3)
                {
                    input.subMeshes[i][n + trisHalf + 2] = input.subMeshes[i][n] + vertexHalf;
                    input.subMeshes[i][n + trisHalf + 1] = input.subMeshes[i][n + 1] + vertexHalf;
                    input.subMeshes[i][n + trisHalf] = input.subMeshes[i][n + 2] + vertexHalf;
                }
            }
        }

        public static void TransformMesh(TS_Mesh input, Matrix4x4 matrix)
        {
            if (input.vertices == null || input.normals == null) return;
            for (int i = 0; i < input.vertices.Length; i++)
            {
                input.vertices[i] = matrix.MultiplyPoint3x4(input.vertices[i]);
                input.normals[i] = matrix.MultiplyVector(input.normals[i]);
            }
        }

        public static void TransformMesh(Mesh input, Matrix4x4 matrix)
        {
            Vector3[] vertices = input.vertices;
            Vector3[] normals = input.vertices;
            if (input.vertices == null || input.normals == null) return;
            for (int i = 0; i < input.vertices.Length; i++)
            {
                vertices[i] = matrix.MultiplyPoint3x4(vertices[i]);
                normals[i] = matrix.MultiplyVector(normals[i]);
            }
            input.vertices = vertices;
            input.normals = normals;
        }


        public static void TransformVertices(Vector3[] vertices, Matrix4x4 matrix)
        {
            for (int i = 0; i < vertices.Length; i++)
            {
                vertices[i] = matrix.MultiplyPoint3x4(vertices[i]);
            }
        }

        public static void TransformNormals(Vector3[] normals, Matrix4x4 matrix)
        {
            for (int i = 0; i < normals.Length; i++)
            {
                normals[i] = matrix.MultiplyVector(normals[i]);
            }
        }

        public static string ToOBJString(Mesh mesh, Material[] materials)
        {
            int numVertices = 0;
            if (mesh == null)
            {
                return "####Error####";
            }

            StringBuilder sb = new StringBuilder();
            sb.Append("g " + mesh.name +"\n");
            foreach (Vector3 v in mesh.vertices)
            {
                numVertices++;
                sb.Append(string.Format("v {0} {1} {2}\n", -v.x, v.y, v.z));
            }
            sb.Append("\n");
            foreach (Vector3 n in mesh.normals)
            {
                sb.Append(string.Format("vn {0} {1} {2}\n", -n.x, n.y, n.z));
            }
            sb.Append("\n");
            foreach (Vector3 v in mesh.uv)
            {
                sb.Append(string.Format("vt {0} {1}\n", v.x, v.y));
            }
            sb.Append("\n");
            foreach (Vector2 v in mesh.uv2)
            {
                sb.Append(string.Format("vt2 {0} {1}\n", v.x, v.y));
            }
            sb.Append("\n");
            foreach (Vector2 v in mesh.uv3)
            {
                sb.Append(string.Format("vt2 {0} {1}\n", v.x, v.y));
            }
            sb.Append("\n");
            foreach (Color c in mesh.colors)
            {
                sb.Append(string.Format("vc {0} {1} {2} {3}\n", c.r, c.g, c.b, c.a));
            }
            for (int material = 0; material < mesh.subMeshCount; material++)
            {
                sb.Append("\n");
                sb.Append("usemtl ").Append(materials[material].name).Append("\n");
                sb.Append("usemap ").Append(materials[material].name).Append("\n");

                int[] triangles = mesh.GetTriangles(material);
                for (int i = 0; i < triangles.Length; i += 3)
                {
                    sb.Append(string.Format("f {2}/{2}/{2} {1}/{1}/{1} {0}/{0}/{0}\n",
                        triangles[i] + 1, triangles[i + 1] + 1, triangles[i + 2] + 1));
                }
            }
            return sb.ToString().Replace(',', '.');
        }

        public static Mesh Copy(Mesh input)
        {
            Mesh copy = new Mesh();
            copy.name = input.name;
            copy.vertices = input.vertices;
            copy.normals = input.normals;
            copy.colors = input.colors;
            copy.uv = input.uv;
            copy.uv2 = input.uv2;
            copy.uv3 = input.uv3;
            copy.uv4 = input.uv4;
            copy.tangents = input.tangents;
            copy.boneWeights = input.boneWeights;
            copy.bindposes = input.bindposes;
            copy.triangles = input.triangles;
            copy.subMeshCount = input.subMeshCount;
            for (int i = 0; i < input.subMeshCount; i++)
            {
                copy.SetTriangles(input.GetTriangles(i), i);
            }
            return copy;
        }

        public static void Triangulate(Vector2[] points, ref int[] output)
        {
            List<int> indices = new List<int>();
            int pointsLength = points.Length;
            if (pointsLength < 3)
            {
                output = new int[0];
                return;
            }

            int[] V = new int[pointsLength];
            if (Area(points, pointsLength) > 0)
            {
                for (int v = 0; v < pointsLength; v++)
                    V[v] = v;
            }
            else
            {
                for (int v = 0; v < pointsLength; v++)
                    V[v] = (pointsLength - 1) - v;
            }

            int nv = pointsLength;
            int count = 2 * nv;
            for (int m = 0, v = nv - 1; nv > 2;)
            {
                if ((count--) <= 0)
                {
                    if (output.Length != indices.Count) output = new int[indices.Count];
                    indices.CopyTo(output, 0);
                    return;
                }

                int u = v;
                if (nv <= u)
                    u = 0;
                v = u + 1;
                if (nv <= v)
                    v = 0;
                int w = v + 1;
                if (nv <= w)
                    w = 0;

                if (Snip(points, u, v, w, nv, V))
                {
                    int a, b, c, s, t;
                    a = V[u];
                    b = V[v];
                    c = V[w];
                    indices.Add(c);
                    indices.Add(b);
                    indices.Add(a);
                    m++;
                    for (s = v, t = v + 1; t < nv; s++, t++)
                        V[s] = V[t];
                    nv--;
                    count = 2 * nv;
                }
            }

            indices.Reverse();
            if (output.Length != indices.Count) output = new int[indices.Count];
            indices.CopyTo(output, 0);
        }

        public static void FlipTriangles(ref int[] triangles)
        {
            for (int i = 0; i < triangles.Length; i += 3)
            {
                int temp = triangles[i];
                triangles[i] = triangles[i + 2];
                triangles[i + 2] = temp;
            }
        }

        public static void FlipFaces(TS_Mesh input)
        {
            for (int i = 0; i < input.subMeshes.Count; i++)
            {
                int[] array = input.subMeshes[i];
                FlipTriangles(ref array);
            }
            FlipTriangles(ref input.triangles);
            for (int i = 0; i < input.normals.Length; i++)
            {
                input.normals[i] *= -1f;
            }
        }

        public static void BreakMesh(Mesh input, bool keepNormals = true)
        {
            Vector3[] newVertices = new Vector3[input.triangles.Length];
            Vector3[] newNormals = new Vector3[newVertices.Length];
            Vector2[] newUVs = new Vector2[newVertices.Length];
            Vector4[] newTangents = new Vector4[newVertices.Length];
            Color[] newColors = new Color[newVertices.Length];
            BoneWeight[] newBoneWeights = new BoneWeight[newVertices.Length];

            Vector3[] oldVertices = input.vertices;
            Vector2[] oldUvs = input.uv;
            Vector3[] oldNormals = input.normals;
            Vector4[] oldTangents = input.tangents;
            Color[] oldColors = input.colors;
            BoneWeight[] oldBoneWeights = input.boneWeights;

            if (oldColors.Length != oldVertices.Length)
            {
                oldColors = new Color[oldVertices.Length];
                for (int i = 0; i < oldColors.Length; i++) oldColors[i] = Color.white;
            }

            List<int[]> submeshList = new List<int[]>();
            int submeshes = input.subMeshCount;
            int vertIndex = 0;
            for (int i = 0; i < submeshes; i++)
            {
                int[] submesh = input.GetTriangles(i);
                for (int n = 0; n < submesh.Length; n += 3)
                {
                    newVertices[vertIndex] = oldVertices[submesh[n]];
                    newVertices[vertIndex + 1] = oldVertices[submesh[n + 1]];
                    newVertices[vertIndex + 2] = oldVertices[submesh[n + 2]];

                    if (oldNormals.Length > submesh[n + 2])
                    {
                        if (!keepNormals)
                        {
                            newNormals[vertIndex] = newNormals[vertIndex + 1] = newNormals[vertIndex + 2] = (oldNormals[submesh[n]] + oldNormals[submesh[n + 1]] + oldNormals[submesh[n + 2]]).normalized;
                        }
                        else
                        {
                            newNormals[vertIndex] = oldNormals[submesh[n]];
                            newNormals[vertIndex + 1] = oldNormals[submesh[n + 1]];
                            newNormals[vertIndex + 2] = oldNormals[submesh[n + 2]];
                        }

                    }

                    if (oldColors.Length > submesh[n + 2])
                        newColors[vertIndex] = newColors[vertIndex + 1] = newColors[vertIndex + 2] = (oldColors[submesh[n]] + oldColors[submesh[n + 1]] + oldColors[submesh[n + 2]]) / 3f;

                    if (oldUvs.Length > submesh[n + 2])
                    {
                        newUVs[vertIndex] = oldUvs[submesh[n]];
                        newUVs[vertIndex + 1] = oldUvs[submesh[n + 1]];
                        newUVs[vertIndex + 2] = oldUvs[submesh[n + 2]];
                    }

                    if (oldTangents.Length > submesh[n + 2])
                    {
                        newTangents[vertIndex] = oldTangents[submesh[n]];
                        newTangents[vertIndex + 1] = oldTangents[submesh[n + 1]];
                        newTangents[vertIndex + 2] = oldTangents[submesh[n + 2]];
                    }

                    if (oldBoneWeights.Length > submesh[n + 2])
                    {
                        newBoneWeights[vertIndex] = oldBoneWeights[submesh[n]];
                        newBoneWeights[vertIndex + 1] = oldBoneWeights[submesh[n + 1]];
                        newBoneWeights[vertIndex + 2] = oldBoneWeights[submesh[n + 2]];
                    }

                    submesh[n] = vertIndex;
                    submesh[n + 1] = vertIndex + 1;
                    submesh[n + 2] = vertIndex + 2;
                    vertIndex += 3;
                }
                submeshList.Add(submesh);
            }

            input.vertices = newVertices;
            input.normals = newNormals;
            input.colors = newColors;
            input.uv = newUVs;
            input.tangents = newTangents;
            input.subMeshCount = submeshList.Count;
            input.boneWeights = newBoneWeights;
            for (int i = 0; i < submeshList.Count; i++)
            {
                input.SetTriangles(submeshList[i], i);
            }
        }

        private static float Area(Vector2[] points, int maxCount)
        {
            float A = 0.0f;
            for (int p = maxCount - 1, q = 0; q < maxCount; p = q++)
            {
                Vector2 pval = points[p];
                Vector2 qval = points[q];
                A += pval.x * qval.y - qval.x * pval.y;
            }
            return (A * 0.5f);
        }

        private static bool Snip(Vector2[] points, int u, int v, int w, int n, int[] V)
        {
            int p;
            Vector2 A = points[V[u]];
            Vector2 B = points[V[v]];
            Vector2 C = points[V[w]];
            if (Mathf.Epsilon > (((B.x - A.x) * (C.y - A.y)) - ((B.y - A.y) * (C.x - A.x))))
                return false;
            for (p = 0; p < n; p++)
            {
                if ((p == u) || (p == v) || (p == w))
                    continue;
                Vector2 P = points[V[p]];
                if (InsideTriangle(A, B, C, P))
                    return false;
            }
            return true;
        }

        private static bool InsideTriangle(Vector2 A, Vector2 B, Vector2 C, Vector2 P)
        {
            float ax, ay, bx, by, cx, cy, apx, apy, bpx, bpy, cpx, cpy;
            float cCROSSap, bCROSScp, aCROSSbp;

            ax = C.x - B.x; ay = C.y - B.y;
            bx = A.x - C.x; by = A.y - C.y;
            cx = B.x - A.x; cy = B.y - A.y;
            apx = P.x - A.x; apy = P.y - A.y;
            bpx = P.x - B.x; bpy = P.y - B.y;
            cpx = P.x - C.x; cpy = P.y - C.y;

            aCROSSbp = ax * bpy - ay * bpx;
            cCROSSap = cx * apy - cy * apx;
            bCROSScp = bx * cpy - by * cpx;

            return ((aCROSSbp >= 0.0f) && (bCROSScp >= 0.0f) && (cCROSSap >= 0.0f));
        }

    }

}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/MeshUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/PrivateSingleton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fb49526ef2768364fb4acea66dc04ffd
# ASMDEF: Dreamteck.Utilities.dll
# ---
namespace Dreamteck
{
    using System.Linq;
    using UnityEngine;

    public class PrivateSingleton<T> : MonoBehaviour where T : Component
    {
        [SerializeField] protected bool _dontDestryOnLoad = true;
        [SerializeField] protected bool _overrideInstance = false;

        protected static T _instance;

        protected virtual void Awake()
        {
            if (_instance != null && _instance != this)
            {
                if (_overrideInstance)
                {
                    Destroy(_instance.gameObject);
                    _instance = this as T;
                    Init();
                }
                else
                {
                    Destroy(this.gameObject);
                }
            }
            else
            {
                _instance = this as T;

                if (_dontDestryOnLoad)
                {
                    DontDestroyOnLoad(gameObject);
                }
                Init();
            }
        }

        protected virtual void Init()
        {
        }

        protected virtual void OnDestroy()
        {
            if (_instance == this && !_overrideInstance)
            {
                _instance = null;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/PrivateSingleton.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Randomizer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6d76cd13905daa94587b47d8dc4d2ee5
# ASMDEF: Dreamteck.Utilities.dll
# ---
namespace Dreamteck.Utilities
{
    using UnityEngine;

    public class Randomizer
    {
        private int _seed;
        private System.Random _random;

        public System.Random random => _random;

        public Randomizer(int seed)
        {
            _seed = seed;
            _random = new System.Random(_seed);
        }

        public float Random01()
        {
            return (float)_random.NextDouble();
        }

        public float Random(float min, float max)
        {
            return (float)DMath.Lerp(min, max, _random.NextDouble());
        }

        public int Random(int min, int max)
        {
            return (int)DMath.Lerp(min, max, _random.NextDouble());
        }

        public Vector2 RandomVector2(float min, float max)
        {
            return new Vector2(Random(min, max), Random(min, max));
        }

        public Vector3 RandomVector3(float min, float max)
        {
            return new Vector3(Random(min, max), Random(min, max), Random(min, max));
        }

        public Vector3 OnUnitSphere()
        {
            return Quaternion.Euler(Random(0f, 360f), Random(0f, 360f), Random(0f, 360f)) * Vector3.forward;
        }

        public Vector3 OnUnitCircle()
        {
            return Quaternion.AngleAxis(Random(0f, 360f), Vector3.forward) * Vector3.up;
        }

        public Vector3 InsideUnitSphere()
        {
            return OnUnitSphere() * Random01();
        }

        public Vector3 InsideUnitCircle()
        {
            return OnUnitCircle() * Random01();
        }

        public void Reset()
        {
            _random = new System.Random(_seed);
        }

        public void Reset(int seed)
        {
            _random = new System.Random(seed);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Randomizer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/SceneUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b5c6af18f0a94e34b8500b13d07331d6
# ASMDEF: Dreamteck.Utilities.dll
# ---
namespace Dreamteck
{
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEngine.SceneManagement;

    public static class SceneUtility
    {
        public static List<Transform> childrenList = new List<Transform>();

        public static void GetChildrenRecursively(Transform current)
        {
            childrenList.Clear();
            GetChildrenRecursivelyInternal(current);
        }

        private static void GetChildrenRecursivelyInternal(Transform current)
        {
            childrenList.Add(current);
            int childCount = current.childCount;
            for (int i = 0; i < childCount; i++)
            {
                GetChildrenRecursivelyInternal(current.GetChild(i));
            }
        }

        public static T[] GetComponentsInChildrenRecusrively<T>(this GameObject gameObject) where T : Component
        {
            GetChildrenRecursively(gameObject.transform);
            List<T> components = new List<T>();
            for (int i = 0; i < childrenList.Count; i++)
            {
                T component = childrenList[i].GetComponent<T>();
                if(component != null)
                {
                    components.Add(component);
                }
            }
            return components.ToArray();
        }

        public static void GetChildrenRecursively(Transform current, ref List<Transform> transformList)
        {
            transformList.Add(current);
            foreach (Transform child in current) GetChildrenRecursively(child, ref transformList);
        }

        public static T GetComponentInScene<T>(this Scene scene, string objectName = null) where T : Component
        {
            var component = default(T);
            var rootObjects = scene.GetRootGameObjects();

            foreach (var obj in rootObjects)
            {
                if (objectName != null && obj.name != objectName) continue;
                component = obj.GetComponentInChildren<T>();
                if(component != null)
                {
                    break;
                }
            }

            return component;
        }

        public static T[] GetComponentsInScene<T>(this Scene scene, string objectName = null, bool includeInactive = false)
        {
            var rootObjects = scene.GetRootGameObjects();
            var components = new List<T>();

            foreach (var obj in rootObjects)
            {
                var rootComponent = obj.GetComponent<T>();

                if (rootComponent != null && (objectName == null || (objectName != null && obj.gameObject.name == obj.name)))
                {
                    components.Add(rootComponent);
                }

                var foundComponents = obj.GetComponentsInChildren<T>(includeInactive);

                for (int i = 0; i < foundComponents.Length; i++)
                {
                    var component = foundComponents[i] as Component;

                    if (objectName != null && component != null && component.gameObject.name != objectName) continue;

                    components.Add(foundComponents[i]);
                }
            }

            return components.ToArray();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/SceneUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/ScriptableObjectUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 85e4f0317c6ed394cb416b5bf4fe4c59
# ASMDEF: Dreamteck.Utilities.dll
# ---
#if UNITY_EDITOR
namespace Dreamteck {
    using UnityEngine;
    using UnityEditor;
    using System.IO;

    public static class ScriptableObjectUtility
    {
        public static T CreateAsset<T>(string name = "", bool selectAfterCreation = true) where T : ScriptableObject
        {
            T asset = ScriptableObject.CreateInstance<T>();
            SaveAsset(asset, name, selectAfterCreation);
            return asset;
        }

        public static ScriptableObject CreateAsset(string type, string name = "", bool selectAfterCreation = true)
        {
            ScriptableObject asset = ScriptableObject.CreateInstance(type);
            SaveAsset<ScriptableObject>(asset, name, selectAfterCreation);
            return asset;
        }

        static void SaveAsset<T>(T asset, string name = "", bool selectAfterCreation = true) where T : ScriptableObject
        {
            string path = AssetDatabase.GetAssetPath(Selection.activeObject);
            if (path == "")
            {
                path = "Assets";
            }
            else if (Path.GetExtension(path) != "")
            {
                path = path.Replace(Path.GetFileName(AssetDatabase.GetAssetPath(Selection.activeObject)), "");
            }
            string assetName = "New " + typeof(T).ToString();
            if (name != "") assetName = name;
            if(!path.EndsWith("/"))
            {
                path += "/";
            }
            string assetPathAndName = AssetDatabase.GenerateUniqueAssetPath(path + assetName + ".asset");
            AssetDatabase.CreateAsset(asset, assetPathAndName);

            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
            EditorUtility.FocusProjectWindow();
            if (selectAfterCreation)
            {
                Selection.activeObject = asset;
            }
        }
    }
}
#endif
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/ScriptableObjectUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Singleton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 656f05929b8fd1b4eb519de915c24212
# ASMDEF: Dreamteck.Utilities.dll
# ---
namespace Dreamteck
{
    using System.Linq;
    using UnityEngine;

    public class Singleton<T> : PrivateSingleton<T> where T : Component
    {
        public static T instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = Object.FindObjectsOfType<T>().FirstOrDefault();
                }

                return _instance;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Singleton.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TransformUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 157259bef35b27e4ebcccdd7e3eee86b
# ASMDEF: Dreamteck.Utilities.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck
{
    public static class TransformUtility
    {
        public static Vector3 GetPosition(Matrix4x4 m)
        {
            return m.GetColumn(3);
        }

        public static Quaternion GetRotation(Matrix4x4 m)
        {
            return Quaternion.LookRotation(m.GetColumn(2), m.GetColumn(1));
        }

        public static Vector3 GetScale(Matrix4x4 m)
        {
            return new Vector3(m.GetColumn(0).magnitude, m.GetColumn(1).magnitude, m.GetColumn(2).magnitude);
        }

        public static void SetPosition(ref Matrix4x4 m, ref Vector3 p)
        {
            m.SetColumn(3, new Vector4(p.x, p.y, p.z, 1f));
        }

        public static void GetChildCount(Transform parent, ref int count)
        {
            foreach (Transform child in parent)
            {
                count++;
                GetChildCount(child, ref count);
            }
        }

        public static void MergeBoundsRecursively(this Transform rootParent, Transform tr, ref Bounds bounds, string nameToIgnore = null)
        {
            foreach (Transform child in tr)
            {
                if (!string.IsNullOrEmpty(nameToIgnore) && child.name == nameToIgnore)
                {
                    continue;
                }

                rootParent.MergeBoundsRecursively(child, ref bounds);

                var meshFilter = child.GetComponent<MeshFilter>();

                if (meshFilter == null) continue;
                if (meshFilter.sharedMesh == null)
                {
                    Debug.LogError("MESH FILTER " + meshFilter.name + " IS MISSING A MESH");
                    continue;
                }
                var min = child.TransformPoint(meshFilter.sharedMesh.bounds.min);
                var max = child.TransformPoint(meshFilter.sharedMesh.bounds.max);

                bounds.Encapsulate(rootParent.InverseTransformPoint(min));
                bounds.Encapsulate(rootParent.InverseTransformPoint(max));
            }
        }

        public static void DestroyChildren(this Transform src)
        {
            int count = src.childCount;
            for (int i = 0; i < count; i++)
            {
                UnityEngine.Object.Destroy(src.GetChild(i).gameObject);
            }
        }

        public static bool IsParent(Transform child, Transform parent)
        {
            Transform current = child;
            while(current.parent != null)
            {
                current = current.parent;
                if (current == parent) return true;
            }
            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TransformUtility.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Bounds.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2c28a6bb56e8cee4fb7dd9a493afbf83
# ASMDEF: Dreamteck.Utilities.dll
# ---
using UnityEngine;
using System.Collections;

namespace Dreamteck
{
    [System.Serializable]
    public class TS_Bounds
    {
        public Vector3 center = Vector3.zero;
        public Vector3 extents = Vector3.zero;
        public Vector3 max = Vector3.zero;
        public Vector3 min = Vector3.zero;
        public Vector3 size = Vector3.zero;

        public TS_Bounds()
        {

        }

        public TS_Bounds(Bounds bounds)
        {
            center = bounds.center;
            extents = bounds.extents;
            max = bounds.max;
            min = bounds.min;
            size = bounds.size;
        }

        public TS_Bounds(Vector3 c, Vector3 s)
        {
            center = c;
            size = s;
            extents = s / 2;
            max = center + extents;
            min = center - extents;
        }

        public TS_Bounds(Vector3 min, Vector3 max, Vector3 center)
        {
            size = new Vector3(max.x - min.x, max.y - min.y, max.z - min.z);
            extents = size / 2f;
            this.min = min;
            this.max = max;
            this.center = center;
        }

        public void CreateFromMinMax(Vector3 min, Vector3 max)
        {
            size.x = max.x - min.x;
            size.y = max.y - min.y;
            size.z = max.z - min.z;
            extents = size / 2f;
            this.min = min;
            this.max = max;
            center = (Vector3.Lerp(min, max, 0.5f));
        }

        public bool Contains(Vector3 point)
        {
            if (point.x < min.x || point.x > max.x) return false;
            if (point.y < min.y || point.y > max.y) return false;
            if (point.z < min.z || point.z > max.z) return false;
            return true;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Bounds.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Mesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9ca64fd6869620449bcb61d4f66c798e
# ASMDEF: Dreamteck.Utilities.dll
# ---
namespace Dreamteck
{
    using UnityEngine;
    using System.Collections;
    using System.Collections.Generic;
    //Thread-safe mesh & bounds classes for working with threads.
    public class TS_Mesh
    {
        public int vertexCount
        {
            get { return vertices.Length; }
            set { }
        }
        public Vector3[] vertices = new Vector3[0];
        public Vector3[] normals = new Vector3[0];
        public Vector4[] tangents = new Vector4[0];
        public Color[] colors = new Color[0];
        public Vector2[] uv = new Vector2[0];
        public Vector2[] uv2 = new Vector2[0];
        public Vector2[] uv3 = new Vector2[0];
        public Vector2[] uv4 = new Vector2[0];
        public int[] triangles = new int[0];
        public List<int[]> subMeshes = new List<int[]>();
        public TS_Bounds bounds = new TS_Bounds(Vector3.zero, Vector3.zero);
        public UnityEngine.Rendering.IndexFormat indexFormat = UnityEngine.Rendering.IndexFormat.UInt16;

        public volatile bool hasUpdate = false;

        private int[] _submeshTrisCount = new int[0];
        private int[] _submeshOffsets = new int[0];


        public TS_Mesh()
        {

        }

        public TS_Mesh(Mesh mesh)
        {
            CreateFromMesh(mesh);
        }

        public void Clear()
        {
            vertices = new Vector3[0];
            normals = new Vector3[0];
            tangents = new Vector4[0];
            colors = new Color[0];
            uv = new Vector2[0];
            uv2 = new Vector2[0];
            uv3 = new Vector2[0];
            uv4 = new Vector2[0];
            triangles = new int[0];
            subMeshes = new List<int[]>();
            bounds = new TS_Bounds(Vector3.zero, Vector3.zero);
        }

        public void CreateFromMesh(Mesh mesh)
        {
            vertices = mesh.vertices;
            normals = mesh.normals;
            tangents = mesh.tangents;
            colors = mesh.colors;
            uv = mesh.uv;
            uv2 = mesh.uv2;
            uv3 = mesh.uv3;
            uv4 = mesh.uv4;
            triangles = mesh.triangles;
            bounds = new TS_Bounds(mesh.bounds);
            indexFormat = mesh.indexFormat;
            for (int i = 0; i < mesh.subMeshCount; i++)
            {
                subMeshes.Add(mesh.GetTriangles(i));
            }
        }

        /// <summary>
        /// Writes the combineMeshes array to the current TS_Mesh object and tries to not allocate memory
        /// </summary>
        /// <param name="combineMeshes"></param>
        public void Combine(List<TS_Mesh> combineMeshes)
        {
            int totalVertexCount = 0;
            int totalTrisCount = 0;
            int addedSubmeshCount = 0;

            for (int i = 0; i < combineMeshes.Count; i++)
            {
                totalVertexCount += combineMeshes[i].vertices.Length;
                totalTrisCount += combineMeshes[i].triangles.Length;
                if (combineMeshes[i].subMeshes.Count > addedSubmeshCount)
                {
                    addedSubmeshCount = combineMeshes[i].subMeshes.Count;
                }
            }

            if (_submeshTrisCount.Length != addedSubmeshCount)
            {
                _submeshTrisCount = new int[addedSubmeshCount];
            }
            else
            {
                for (int i = 0; i < _submeshTrisCount.Length; i++)
                {
                    _submeshTrisCount[i] = 0;
                }
            }


            for (int i = 0; i < combineMeshes.Count; i++)
            {
                for (int j = 0; j < combineMeshes[i].subMeshes.Count; j++)
                {
                    _submeshTrisCount[j] += combineMeshes[i].subMeshes[j].Length;
                }
            }

            if (vertices.Length != totalVertexCount) vertices = new Vector3[totalVertexCount];
            if (normals.Length != totalVertexCount) normals = new Vector3[totalVertexCount];
            if (uv.Length != totalVertexCount) uv = new Vector2[totalVertexCount];
            if (uv2.Length != totalVertexCount) uv2 = new Vector2[totalVertexCount];
            if (uv3.Length != totalVertexCount) uv3 = new Vector2[totalVertexCount];
            if (uv4.Length != totalVertexCount) uv4 = new Vector2[totalVertexCount];
            if (colors.Length != totalVertexCount) colors = new Color[totalVertexCount];
            if (tangents.Length != totalVertexCount) tangents = new Vector4[totalVertexCount];
            if (triangles.Length != totalTrisCount) triangles = new int[totalTrisCount];
            if (subMeshes.Count > addedSubmeshCount) subMeshes.Clear();

            int vertexOffset = 0;
            int trisOffset = 0;

            if(_submeshOffsets.Length != addedSubmeshCount)
            {
                _submeshOffsets = new int[addedSubmeshCount];
            } else
            {
                for (int i = 0; i < _submeshOffsets.Length; i++)
                {
                    _submeshOffsets[i] = 0;
                }
            }


            for (int i = 0; i < combineMeshes.Count; i++)
            {
                combineMeshes[i].vertices.CopyTo(vertices, vertexOffset);
                combineMeshes[i].normals.CopyTo(normals, vertexOffset);
                combineMeshes[i].uv.CopyTo(uv, vertexOffset);
                combineMeshes[i].uv2.CopyTo(uv2, vertexOffset);
                combineMeshes[i].uv3.CopyTo(uv3, vertexOffset);
                combineMeshes[i].uv4.CopyTo(uv4, vertexOffset);
                combineMeshes[i].colors.CopyTo(colors, vertexOffset);
                combineMeshes[i].tangents.CopyTo(tangents, vertexOffset);

                for (int t = 0; t < combineMeshes[i].triangles.Length; t++)
                {
                    int index = t + trisOffset;
                    triangles[index] = combineMeshes[i].triangles[t] + vertexOffset;
                }

                trisOffset += combineMeshes[i].triangles.Length;

                for (int j = 0; j < combineMeshes[i].subMeshes.Count; j++)
                {
                    if (j >= subMeshes.Count)
                    {
                        subMeshes.Add(new int[_submeshTrisCount[j]]);
                    }
                    else if (subMeshes[j].Length != _submeshTrisCount[j])
                    {
                        subMeshes[j] = new int[_submeshTrisCount[j]];
                    }
                    int[] submesh = combineMeshes[i].subMeshes[j];

                    for (int x = 0; x < submesh.Length; x++)
                    {
                        int index = _submeshOffsets[j] + x;
                        subMeshes[j][index] = submesh[x] + vertexOffset;
                    }
                    _submeshOffsets[j] += submesh.Length;
                }
                vertexOffset += combineMeshes[i].vertices.Length;
            }
        }

        /// <summary>
        /// Adds the provieded mesh list to the current mesh and allocates memory
        /// </summary>
        /// <param name="addedMeshes"></param>
        public void AddMeshes(List<TS_Mesh> addedMeshes)
        {
            int newVerts = 0;
            int newTris = 0;
            int submeshCount = 0;
            for (int i = 0; i < addedMeshes.Count; i++)
            {
                newVerts += addedMeshes[i].vertexCount;
                newTris += addedMeshes[i].triangles.Length;
                if (addedMeshes[i].subMeshes.Count > submeshCount)
                {
                    submeshCount = addedMeshes[i].subMeshes.Count;
                }
            }
            int[] submeshTrisCount = new int[submeshCount];
            int[] submeshOffsets = new int[submeshCount];
            for (int i = 0; i < addedMeshes.Count; i++)
            {
                for (int j = 0; j < addedMeshes[i].subMeshes.Count; j++)
                {
                    submeshTrisCount[j] += addedMeshes[i].subMeshes[j].Length;
                }
            }

            
            Vector3[] newVertices = new Vector3[vertices.Length + newVerts];
            Vector3[] newNormals = new Vector3[vertices.Length + newVerts];
            Vector2[] newUvs = new Vector2[vertices.Length + newVerts];
            Vector2[] newUvs2 = new Vector2[vertices.Length + newVerts];
            Vector2[] newUvs3 = new Vector2[vertices.Length + newVerts];
            Vector2[] newUvs4 = new Vector2[vertices.Length + newVerts];
            Color[] newColors = new Color[vertices.Length + newVerts];
            Vector4[] newTangents = new Vector4[tangents.Length + newVerts];
            int[] newTriangles = new int[triangles.Length + newTris];
            List<int[]> newSubmeshes = new List<int[]>();

            for (int i = 0; i < submeshTrisCount.Length; i++)
            {
                newSubmeshes.Add(new int[submeshTrisCount[i]]);
                if (i < subMeshes.Count)
                {
                    submeshTrisCount[i] = subMeshes[i].Length;
                }
                else
                {
                    submeshTrisCount[i] = 0;
                }
            }

            newVerts = vertexCount;
            newTris = triangles.Length;
            vertices.CopyTo(newVertices, 0);
            normals.CopyTo(newNormals, 0);
            uv.CopyTo(newUvs, 0);
            uv2.CopyTo(newUvs2, 0);
            uv3.CopyTo(newUvs3, 0);
            uv4.CopyTo(newUvs4, 0);
            colors.CopyTo(newColors, 0);
            tangents.CopyTo(newTangents, 0);
            triangles.CopyTo(newTriangles, 0);

            for (int i = 0; i < addedMeshes.Count; i++)
            {
                addedMeshes[i].vertices.CopyTo(newVertices, newVerts);
                addedMeshes[i].normals.CopyTo(newNormals, newVerts);
                addedMeshes[i].uv.CopyTo(newUvs, newVerts);
                addedMeshes[i].uv2.CopyTo(newUvs2, newVerts);
                addedMeshes[i].uv3.CopyTo(newUvs3, newVerts);
                addedMeshes[i].uv4.CopyTo(newUvs4, newVerts);
                addedMeshes[i].colors.CopyTo(newColors, newVerts);
                addedMeshes[i].tangents.CopyTo(newTangents, newVerts);

                for (int n = newTris; n < newTris + addedMeshes[i].triangles.Length; n++)
                {
                    newTriangles[n] = addedMeshes[i].triangles[n - newTris] + newVerts;
                }


                for (int n = 0; n < addedMeshes[i].subMeshes.Count; n++)
                {
                    for (int x = submeshTrisCount[n]; x < submeshTrisCount[n] + addedMeshes[i].subMeshes[n].Length; x++)
                    {
                        newSubmeshes[n][x] = addedMeshes[i].subMeshes[n][x - submeshTrisCount[n]] + newVerts;
                    }
                    submeshTrisCount[n] += addedMeshes[i].subMeshes[n].Length;
                }
                newTris += addedMeshes[i].triangles.Length;
                newVerts += addedMeshes[i].vertexCount;
            }

            vertices = newVertices;
            normals = newNormals;
            uv = newUvs;
            uv2 = newUvs2;
            uv3 = newUvs3;
            uv4 = newUvs4;
            colors = newColors;
            tangents = newTangents;
            triangles = newTriangles;
            subMeshes = newSubmeshes;
        }

        public static TS_Mesh Copy(TS_Mesh input)
        {
            TS_Mesh result = new TS_Mesh();
            result.vertices = new Vector3[input.vertices.Length];
            input.vertices.CopyTo(result.vertices, 0);
            result.normals = new Vector3[input.normals.Length];
            input.normals.CopyTo(result.normals, 0);
            result.uv = new Vector2[input.uv.Length];
            input.uv.CopyTo(result.uv, 0);
            result.uv2 = new Vector2[input.uv2.Length];
            input.uv2.CopyTo(result.uv2, 0);
            result.uv3 = new Vector2[input.uv3.Length];
            input.uv3.CopyTo(result.uv3, 0);
            result.uv4 = new Vector2[input.uv4.Length];
            input.uv4.CopyTo(result.uv4, 0);
            result.colors = new Color[input.colors.Length];
            input.colors.CopyTo(result.colors, 0);
            result.tangents = new Vector4[input.tangents.Length];
            input.tangents.CopyTo(result.tangents, 0);
            result.triangles = new int[input.triangles.Length];
            input.triangles.CopyTo(result.triangles, 0);
            result.subMeshes = new List<int[]>();
            for(int i = 0; i < input.subMeshes.Count; i++)
            {
                result.subMeshes.Add(new int[input.subMeshes[i].Length]);
                input.subMeshes[i].CopyTo(result.subMeshes[i], 0);
            }
            result.bounds = new TS_Bounds(input.bounds.center, input.bounds.size);
            result.indexFormat = input.indexFormat;
            return result;
        }

        public void Absorb(TS_Mesh input)
        {
            if (vertices.Length != input.vertexCount) vertices = new Vector3[input.vertexCount];
            if (normals.Length != input.normals.Length) normals = new Vector3[input.normals.Length];
            if (colors.Length != input.colors.Length) colors = new Color[input.colors.Length];
            if (uv.Length != input.uv.Length) uv = new Vector2[input.uv.Length];
            if (uv2.Length != input.uv2.Length) uv2 = new Vector2[input.uv2.Length];
            if (uv3.Length != input.uv3.Length) uv3 = new Vector2[input.uv3.Length];
            if (uv4.Length != input.uv4.Length) uv4 = new Vector2[input.uv4.Length];
            if (tangents.Length != input.tangents.Length) tangents = new Vector4[input.tangents.Length];
            if (triangles.Length != input.triangles.Length) triangles = new int[input.triangles.Length];

            input.vertices.CopyTo(vertices, 0);
            input.normals.CopyTo(normals, 0);
            input.colors.CopyTo(colors, 0);
            input.uv.CopyTo(uv, 0);
            input.uv2.CopyTo(uv2, 0);
            input.uv3.CopyTo(uv3, 0);
            input.uv4.CopyTo(uv4, 0);
            input.tangents.CopyTo(tangents, 0);
            input.triangles.CopyTo(triangles, 0);

            if (subMeshes.Count == input.subMeshes.Count)
            {
                for (int i = 0; i < subMeshes.Count; i++)
                {
                    if (input.subMeshes[i].Length != subMeshes[i].Length) subMeshes[i] = new int[input.subMeshes[i].Length];
                    input.subMeshes[i].CopyTo(subMeshes[i], 0);
                }
            }
            else
            {
                subMeshes = new List<int[]>();
                for (int i = 0; i < input.subMeshes.Count; i++)
                {
                    subMeshes.Add(new int[input.subMeshes[i].Length]);
                    input.subMeshes[i].CopyTo(subMeshes[i], 0);
                }
            }
            bounds = new TS_Bounds(input.bounds.center, input.bounds.size);
        }

        public void WriteMesh(ref Mesh input)
        {
            if (input == null) input = new Mesh();
            input.Clear();
            input.indexFormat = indexFormat;
            input.vertices = vertices;
            input.normals = normals;
            if (tangents.Length == vertices.Length) input.tangents = tangents;
            if (colors.Length == vertices.Length) input.colors = colors;
            if (uv.Length == vertices.Length) input.uv = uv;
            if (uv2.Length == vertices.Length) input.uv2 = uv2;
            if (uv3.Length == vertices.Length) input.uv3 = uv3;
            if (uv4.Length == vertices.Length) input.uv4 = uv4;
            input.triangles = triangles;
            if (subMeshes.Count > 0)
            {
                input.subMeshCount = subMeshes.Count;
                for (int i = 0; i < subMeshes.Count; i++)
                {
                    input.SetTriangles(subMeshes[i], i);
                }
            }
            input.RecalculateBounds();
            hasUpdate = false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Mesh.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Transform.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c22a5076c8dce1b40a2a12e5bc7abc69
# ASMDEF: Dreamteck.Utilities.dll
# ---
using UnityEngine;
using System.Collections;

namespace Dreamteck
{
    [System.Serializable]
    public class TS_Transform
    {
        public Vector3 position
        {
            get { return new Vector3(posX, posY, posZ); }
            set
            {
                setPosition = true;
                setLocalPosition = false;
                posX = value.x;
                posY = value.y;
                posZ = value.z;
            }
        }
        public Quaternion rotation
        {
            get { return new Quaternion(rotX, rotY, rotZ, rotW); }
            set
            {
                setRotation = true;
                setLocalRotation = false;
                rotX = value.x;
                rotY = value.y;
                rotZ = value.z;
                rotW = value.w;
            }
        }
        public Vector3 scale
        {
            get { return new Vector3(scaleX, scaleY, scaleZ); }
            set
            {
                setScale = true;
                scaleX = value.x;
                scaleY = value.y;
                scaleZ = value.z;
            }
        }

        public Vector3 lossyScale
        {
            get { return new Vector3(lossyScaleX, lossyScaleY, lossyScaleZ); }
            set
            {
                setScale = true;
                lossyScaleX = value.x;
                lossyScaleY = value.y;
                lossyScaleZ = value.z;
            }
        }

        public Vector3 localPosition
        {
            get { return new Vector3(lposX, lposY, lposZ); }
            set
            {
                setLocalPosition = true;
                setPosition = false;
                lposX = value.x;
                lposY = value.y;
                lposZ = value.z;
            }
        }
        public Quaternion localRotation
        {
            get { return new Quaternion(lrotX, lrotY, lrotZ, lrotW); }
            set
            {
                setLocalRotation = true;
                setRotation = false;
                lrotX = value.x;
                lrotY = value.y;
                lrotZ = value.z;
                lrotW = value.w;
            }
        }

        private bool setPosition = false;
        private bool setRotation = false;
        private bool setScale = false;
        private bool setLocalPosition = false;
        private bool setLocalRotation = false;

        public Transform transform
        {
            get
            {
                return _transform;
            }
        }

        [SerializeField]
        [HideInInspector]
        private Transform _transform;

        [SerializeField]
        [HideInInspector]
        private volatile float posX = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float posY = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float posZ = 0f;

        [SerializeField]
        [HideInInspector]
        private volatile float scaleX = 1f;
        [SerializeField]
        [HideInInspector]
        private volatile float scaleY = 1f;
        [SerializeField]
        [HideInInspector]
        private volatile float scaleZ = 1f;

        [SerializeField]
        [HideInInspector]
        private volatile float lossyScaleX = 1f;
        [SerializeField]
        [HideInInspector]
        private volatile float lossyScaleY = 1f;
        [SerializeField]
        [HideInInspector]
        private volatile float lossyScaleZ = 1f;

        [SerializeField]
        [HideInInspector]
        private volatile float rotX = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float rotY = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float rotZ = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float rotW = 0f;


        [SerializeField]
        [HideInInspector]
        private volatile float lposX = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float lposY = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float lposZ = 0f;

        [SerializeField]
        [HideInInspector]
        private volatile float lrotX = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float lrotY = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float lrotZ = 0f;
        [SerializeField]
        [HideInInspector]
        private volatile float lrotW = 0f;
#if UNITY_EDITOR
        private volatile bool isPlaying = false;
#endif

        public TS_Transform(Transform input)
        {
            SetTransform(input);
        }

        /// <summary>
        /// Update the TS_Transform. Call this regularly on every frame you need it to update. Should ALWAYS be called from the main thread
        /// </summary>
        public void Update()
        {
            if (transform == null) return;
#if UNITY_EDITOR
            isPlaying = Application.isPlaying;
#endif
            if (setPosition) _transform.position = position;
            else if (setLocalPosition) _transform.localPosition = localPosition;
            else
            {
                position = _transform.position;
                localPosition = _transform.localPosition;
            }

            if (setScale) _transform.localScale = scale;
            else scale = _transform.localScale;
            lossyScale = _transform.lossyScale;
            

            if (setRotation) _transform.rotation = rotation;
            else if (setLocalRotation) _transform.localRotation = localRotation;
            else
            {
                rotation = _transform.rotation;
                localRotation = _transform.localRotation;
            }
            setPosition = setLocalPosition = setRotation = setLocalRotation = setScale = false;
        }

        /// <summary>
        /// Set the transform reference. Should ALWAYS be called from the main thread
        /// </summary>
        /// <param name="input">Transform reference</param>
        public void SetTransform(Transform input)
        {
            _transform = input;
            setPosition = setLocalPosition = setRotation = setLocalRotation = setScale = false;
            Update();
        }

        /// <summary>
        /// Returns true if there's any change in the transform. Should ALWAYS be called from the main thread
        /// </summary>
        /// <returns></returns>
        public bool HasChange()
        {
            return HasPositionChange() || HasRotationChange() || HasScaleChange();
        }

        /// <summary>
        /// Returns true if there's a change in the position. Should ALWAYS be called from the main thread
        /// </summary>
        /// <returns></returns>
        public bool HasPositionChange()
        {
            return posX != _transform.position.x || posY != _transform.position.y || posZ != _transform.position.z;
        }

        /// <summary>
        /// Returns true if there is a change in the rotation. Should ALWAYS be called from the main thread
        /// </summary>
        /// <returns></returns>
        public bool HasRotationChange()
        {
            return rotX != _transform.rotation.x || rotY != _transform.rotation.y || rotZ != _transform.rotation.z || rotW != _transform.rotation.w;
        }

        /// <summary>
        /// Returns true if there is a change in the scale. Should ALWAYS be called from the main thread
        /// </summary>
        /// <returns></returns>
        public bool HasScaleChange()
        {
            return lossyScaleX != _transform.lossyScale.x || lossyScaleY != _transform.lossyScale.y || lossyScaleZ != _transform.lossyScale.z;
        }

        /// <summary>
        /// Thread-safe TransformPoint
        /// </summary>
        /// <param name="point"></param>
        /// <returns></returns>
        public Vector3 TransformPoint(Vector3 point)
        {
#if UNITY_EDITOR
            if (!isPlaying) return transform.TransformPoint(point);
#endif
            Vector3 scaled = new Vector3(point.x * lossyScaleX, point.y * lossyScaleY, point.z * lossyScaleZ);
            Vector3 rotated = rotation * scaled;
            return position + rotated;
        }

        /// <summary>
        /// Thread-safe TransformDirection
        /// </summary>
        /// <param name="direction"></param>
        /// <returns></returns>
        public Vector3 TransformDirection(Vector3 direction)
        {
#if UNITY_EDITOR
            if (!isPlaying) return transform.TransformDirection(direction);
#endif
            return TransformPoint(direction) - position;
        }

        /// <summary>
        /// Thread-safe InverseTransformPoint
        /// </summary>
        /// <param name="point"></param>
        /// <returns></returns>
        public Vector3 InverseTransformPoint(Vector3 point)
        {
#if UNITY_EDITOR
            if (!isPlaying) return transform.InverseTransformPoint(point);
#endif
            return InverseTransformDirection(point - position);
        }

        /// <summary>
        /// Thread-safe InverseTransformDirection
        /// </summary>
        /// <param name="direction"></param>
        /// <returns></returns>
        public Vector3 InverseTransformDirection(Vector3 direction)
        {
#if UNITY_EDITOR
            if (!isPlaying) return transform.InverseTransformDirection(direction);
#endif
            Vector3 rotated = Quaternion.Inverse(rotation) * direction;
            return new Vector3(rotated.x / lossyScaleX, rotated.y / lossyScaleY, rotated.z / lossyScaleZ);
        }

        public T GetComponent<T>()
        {
            return _transform.GetComponent<T>();
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/TS_Transform.cs

# FILE: Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Utilities.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6d12765602d6ee04cbcfeb790254c378
# ASMDEF: Dreamteck.Utilities.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Dreamteck.Utilities
{
    public static class Utilities
    {
        public static T SerializableClone<T>(this T obj)
        {
            return JsonUtility.FromJson<T>(JsonUtility.ToJson(obj));
        }

        public static void Shuffle<T>(this IList<T> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = UnityEngine.Random.Range(0, n + 1);
                list.Swap(k, n);
            }
        }
        public static void RemoveAtUnsorted<T>(this List<T> list, int i)
        {
            var last = list.Count - 1;
            list[i--] = list[last];
            list.RemoveAt(last);
        }

        public static T PopLast<T>(this IList<T> list)
        {
            T last = list[list.Count - 1];
            list.RemoveAt(list.Count - 1);
            return last;
        }

        public static void Swap<T>(this IList<T> list, int left, int right)
        {
            T value = list[left];
            list[left] = list[right];
            list[right] = value;
        }

        public static void SafeInvoke(this Delegate del, params object[] parameters)
        {
            foreach (var handler in del.GetInvocationList())
            {
                try
                {
                    handler.Method.Invoke(handler.Target, parameters);
                }
                catch (Exception exception)
                {
                    Debug.LogException(exception);
                }
            }
        }

        public static T PopRandom<T>(this List<T> list)
        {
            if (list.Count > 0)
            {
                int index = UnityEngine.Random.Range(0, list.Count);
                T element = list[index];
                list.RemoveAt(index);
                return element;
            }

            throw new ArgumentException("Attempting to remove an element from an empty list");
        }

        public static bool HasCommandLineArgument(string name)
        {
            var args = Environment.GetCommandLineArgs();
            for (int i = 0; i < args.Length; i++)
            {
                if (args[i] == name)
                {
                    return true;
                }
            }
            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/Dreamteck/Utilities/Utilities.cs

