# CONSOLIDATED: Framework.Runtime
# GENERATED: 2025-11-17 11:55:11
# PART: 2
# FILE COUNT (part): 375
# LINE ENDINGS: LF
# ENCODING: UTF-8 (no BOM)
# INDEX BEGIN
# SYSTEM: com_ldx_frameworkSystem (375 files)
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/Base/SplineInputModuleBase.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/Base/TRSModuleBase.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildRasterizedPath.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildShapeExtrusion.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildVolumeCaps.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildVolumeMesh.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildVolumeSpots.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ConformPath.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/CreateGameObject.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/CreateMesh.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/CreatePathLineRenderer.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/DebugRasterizedPath.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/DebugVMesh.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/DebugVolume.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/DeformMesh.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/GameObjectToMesh.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputGameObject.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputMesh.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputSplinePath.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputSplineShape.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputSpots.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputTransformSpots.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierMixPaths.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierMixShapes.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierPathRelativeTranslation.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierTRSMesh.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierTRSPath.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierTRSShape.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierVariableMixShapes.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/Note.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ResourceExportingModule.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGBoundsGroup.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGClasses.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGData.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGDataRequests.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGEvents.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGInterfaces.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGMeshResource.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModule.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModuleLink.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModuleSlot.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGResource.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGUtility.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CurvyGenerator.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CurvyPropertyAttributes.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/MetaCGOptions.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/ConnectedControlPointsSelector.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/ControllersEvents.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/CurvyController.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/MotionConstraints.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/MovementDirection.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/OnPositionReachedSettings.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/PathController.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/SplineController.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/TargetComponent.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/UITextSplineController.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/VolumeController.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/CurvySerializationSpace.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/FileFormat.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/SplineJsonConverter.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/SplineSvgConverter.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/Wrappers.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/BSplineHelper.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CodeContractsUtility.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyClasses.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyEvents.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyUtility.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/Base/SplineProcessor.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyGlobalManager.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyGLRenderer.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyLineRenderer.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvySplineToEdgeCollider2D.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/NearestSplinePoint.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Pools/ArrayPools.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Pools/ArrayPoolsSettings.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSCircle.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSPie.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSRectangle.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSRoundedRectangle.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSSpiral.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSStar.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CurvyShape.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CurvyShape2D.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Connections/ConnectionHeadingEnum.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Connections/CurvyConnection.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySpline.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineDefaultValues.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment.ControlPointExtrinsicProperties.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegmentDefaultValues.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment_private.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySpline_private.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvyUISpline.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Metadata/CurvyInterpolatableMetadataBaseGeneric.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Metadata/CurvyMetadataBase.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/SplineDirtyingType.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/SplineEvents.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Attributes.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Couple.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Data.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTEase.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTObjectDump.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTUtility.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/PropertyAttributes.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/ThreadPoolWorker.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/ComponentPool.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DTSingleton.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DTVersionedMonoBehaviour.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DuplicateEditorMesh.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/InspectorNote.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/PoolManager.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/PrefabPool.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Extensions/Extensions.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Dict.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Geom.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/LTMesh.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/MeshUtils.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/PriorityHeap.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/PriorityQueue.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Sweep.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Tess.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/UnityUtility.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/Matrix2D.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/SVGParser.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/SVGStyleSheet.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorEllipse.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorRectangle.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorScene.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorSprite.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorTessellation.cs
#   Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorUtils.cs
#   Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/DestroyHelper.cs
#   Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/ImageWithIndependentRoundedCorners.cs
#   Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/ImageWithRoundedCorners.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn13dShaderDemoController.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn13DShaderShaderPropertyCurveAnim.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1AutoRotate.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1CanvasFader.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1DemoButtonPress.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1DemoScaleTween.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1FadeLight.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1MainLightController.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1MouseTransformRotator.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1TimeControl.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Billboard.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoCameraController.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElement.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementColorRamp.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementData.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementIntersectionGlow.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoEnvironment.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoExpositor.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoExpositorData.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoInfoUI.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoLightUrpIntensity.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoSceneConfiguration.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoUI.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoUtils.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/EnvironmentController.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/EnvironmentSpotlightController.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/InputHandler.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/MaterialPrewarmer.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/OptionsDemo.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/PostProcessConfigurator.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/SkyController.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/AlphaTween.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PositionTween.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTween.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenCollection.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenFader.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenSinWave.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/SinVerticalPositionTween.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/TransformScaler.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn13DShaderComponent.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn13DShaderRandomTimeSeed.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn1DepthColoringProperties.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ConstantsRuntime.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/DepthColoringCamera.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/FakeLightConfigurator.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/FastLightingConfigurator.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ShaderGlobalTimeController.cs
#   Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ShadowsConfigurator.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/Desktop/HandDesktopControllerLink.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandFingerGestureEvent.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandFingerGestureTracker.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandGestureEvent.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandGestureEventTextWriter.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandMapper.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandTracking.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandTrackingGrabber.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/InputActionEnabler.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRAutoHandAxisFingerBender.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRAutoHandFingerBender.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRControllerEvent.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRGrabbableInput.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandControllerLink.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandPlayerControllerLink.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandPointGrabLink.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHeldGrabbableInput.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRMover.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRTeleporterLink.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/XRProviderPicker.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRAutoHandAxisFingerBender.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRAutoHandFingerBender.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRControllerEvent.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandControllerLink.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandOffset.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandPlayerControllerLink.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandPointGrabLink.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHeadTracking.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRMover.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRTeleporterLink.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/InteractionAnimation.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/LineAnimation.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/PlacePointAnimation.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoHeaderAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoLineAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoSmallHeaderAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoToggleHeaderAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/AllowNestingAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/AnimatorParamAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/CurveRangeAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/DrawerAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/DropdownAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/EnumFlagsAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/Expandable.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/HorizontalLineAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/InfoBoxAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/InputAxisAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/LayerAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/MinMaxSliderAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ProgressBarAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ResizableTextAreaAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/SceneAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ShowAssetPreviewAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/TagAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ButtonAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ReorderableListAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ShowNativePropertyAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ShowNonSerializedFieldAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/SpecialCaseDrawerAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/INaughtyAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/BoxGroupAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/DisableIfAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/EnableIfAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/EnableIfAttributeBase.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/FoldoutAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/HideIfAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/IGroupAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/LabelAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/MetaAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/OnValueChangedAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ReadOnlyAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ShowIfAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ShowIfAttributeBase.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/Utility/EColor.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/Utility/EConditionOperator.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/MaxValueAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/MinValueAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/RequiredAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/ValidateInputAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/ValidatorAttribute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/AutoHandExtensions.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoAmmo.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoAnimation.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoArrow.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoBow.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGun.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGunEffects.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGunTarget.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/GrabbableHeldJoint.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/GrabbablePoseAnimaion.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/HeldPlaceJoint.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/PlaceJoint.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/BowlingManager.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/BoxingGlove.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Briefcase.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/CubeBreak.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/DemoExitCondition.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/DemoFlyingToggle.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Door.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ExplosionSource.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Grenade.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/HandPoseCopier.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/HandSwapper.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/JointBreakStopForce1.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/OpenLink.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Pistol.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/PlatformMover.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/PlayerFallCatcher.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ReloadSceneByName.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ScaleHighlight.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Spinner.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ToggleAutoMoveFlying.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ToggleHandProjection.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/TomatoSpawner.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/UnlockChest.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/ButtonDemoRespawn.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/DialHandScaler.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/JoystickObjectMover.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/MoverLever.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/PhysicsSliderPositionMover.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/WheelRotator.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/LeverTextChanger.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/SliderTextChanger.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextChanger.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextFieldInspector.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextGrabEvent.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextInformation.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextPlacePointEvent.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TMPSizeProtector.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/HandTouchButton.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/JointExtensions.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetButton.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetConfigurableLimitReader.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetHingeAngleReader.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetJoystick.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetLever.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetSlider.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/DispenserPoint.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/DistanceGrabbable.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/Grabbable.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableChild.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableCollisionHaptics.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableExtensions.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableExtraEvents.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableOnlyJoint.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePose.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseAdvanced.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseCombiner.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseGizmo.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableSubstitute.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableThrowEvent.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabLock.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/PlacePoint.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/PlacePointSoundEffects.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/WeightlessFollower.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/Finger.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerGizmo.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerTriggerAreaEvents.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerTriggerAreaToggleEvents.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/Hand.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandAdvancedOptions.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandClippingGuard.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandCollisionHaptics.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandControllerLink.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandDistanceGrabber.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandExtensions.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandFingerTouch.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPoseArea.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPoseDataContainer.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandProjector.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPublicEvents.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTeleportGuard.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTouchEvent.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTriggerAreaEvents.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/IgnoreHandLayer.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/WristLookEvent.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Helpers/BoxColliderSerializationFixer.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Helpers/OnPlaceIgnoreHands.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/DynamicTimestepSetter.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/EditorHand.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/GrabbableBase.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandAnimator.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandBase.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandFollow.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandGizmos.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandGrabbableHighlighter.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandPoseData.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandPoseScriptable.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandStabilizer.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandVelocityTracker.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/IGrabbableEvents.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/KeyboardHand.cs
#   Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedJointDrive.cs
# INDEX END
#
# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/Base/SplineInputModuleBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b8f3587212d475f45852a2fea648e4c6
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Pools;
using FluffyUnderware.Curvy.Utils;
using ToolBuddy.Pooling.Pools;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Base class for spline input modules
    /// </summary>
    public abstract class SplineInputModuleBase : CGModule
    {
        #region ### Serialized Fields ###
        /// <summary>
        /// Makes this module use the cached approximations of the spline's positions and tangents
        /// </summary>
        [Tab("General")]
        [SerializeField]
        [Tooltip("Makes this module use the cached approximations of the spline's positions and tangents")]
        private bool m_UseCache;
        [Tooltip("Whether to use local or global coordinates of the input's control points.\r\nUsing the global space when the input's transform is updating every frame will lead to the generator refreshing too frequently")]
        [SerializeField]
        private bool m_UseGlobalSpace;

        /*! \cond PRIVATE */

        [Tab("Range")]
        [SerializeField]
        protected CurvySplineSegment m_StartCP;
        [FieldCondition(nameof(m_StartCP), null, true, Action = ActionAttribute.ActionEnum.Enable)]
        [SerializeField]
        protected CurvySplineSegment m_EndCP;

        /*! \endcond */
        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Makes this module use the cached approximations of the spline's positions and tangents
        /// </summary>
        public bool UseCache
        {
            get { return m_UseCache; }
            set
            {
                if (m_UseCache != value)
                    m_UseCache = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// If not null, the input spline will not be considered fully, but only the range between <see cref="StartCP"/> and <see cref="EndCP"/>.
        /// </summary>
        /// <remarks>Valid values of <see cref="StartCP"/> and <see cref="EndCP"/> are such as those CPs are part of <see cref="InputSpline"/>, and <see cref="StartCP"/> is prior to <see cref="EndCP"/> in that spline</remarks>
        public CurvySplineSegment StartCP
        {
            get { return m_StartCP; }
            set
            {
                if (m_StartCP != value)
                {
                    m_StartCP = value;
                    ValidateStartAndEndCps();
                }
                Dirty = true;
            }
        }

        /// <summary>
        /// If not null, the input spline will not be considered fully, but only the range between <see cref="StartCP"/> and <see cref="EndCP"/>.
        /// </summary>
        /// <remarks>Valid values of <see cref="StartCP"/> and <see cref="EndCP"/> are such as those CPs are part of <see cref="InputSpline"/>, and <see cref="StartCP"/> is prior to <see cref="EndCP"/> in that spline</remarks>
        public CurvySplineSegment EndCP
        {
            get { return m_EndCP; }
            set
            {
                if (m_EndCP != value)
                {
                    m_EndCP = value;
                    ValidateStartAndEndCps();
                }
                Dirty = true;
            }
        }

        /// <summary>
        /// Whether to use local or global coordinates of the input's control points.
        /// Using the global space will dirty the module whenever the spline's transform is updated
        /// </summary>
        public bool UseGlobalSpace
        {
            get { return m_UseGlobalSpace; }
            set
            {
                m_UseGlobalSpace = value;
                Dirty = true;
            }
        }

        public override bool IsConfigured
        {
            get
            {
                return base.IsConfigured && InputSpline != null;
            }
        }

        public override bool IsInitialized
        {
            get
            {
                return base.IsInitialized && (InputSpline == null || InputSpline.IsInitialized);
            }
        }

        public bool PathIsClosed
        {
            get { return IsConfigured && getPathClosed(InputSpline); }
        }

        #endregion

        #region Public mehtods

        /// <summary>
        /// Set the input range, defined by <see cref="StartCP"/> and <see cref="EndCP"/>
        /// </summary>
        public void SetRange(CurvySplineSegment rangeStart, CurvySplineSegment rangeEnd)
        {
            m_StartCP = rangeStart;
            m_EndCP = rangeEnd;
            ValidateStartAndEndCps();
            Dirty = true;
        }

        /// <summary>
        /// Clear the input range, defined by <see cref="StartCP"/> and <see cref="EndCP"/>
        /// </summary>
        public void ClearRange()
        {
            SetRange(null, null);
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected override void OnEnable()
        {
            base.OnEnable();
            Properties.MinWidth = 250;
            OnSplineAssigned();
        }


        protected override void OnDisable()
        {
            base.OnDisable();
            if (InputSpline)
            {
                InputSpline.OnRefresh.RemoveListener(OnSplineRefreshed);
                InputSpline.OnGlobalCoordinatesChanged -= OnInputSplineCoordinatesChanged;
            }
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            if (isActiveAndEnabled)
                ValidateStartAndEndCps();
            OnSplineAssigned();
            Dirty = true;
        }
#endif

        public override void Reset()
        {
            base.Reset();
            InputSpline = null;
            UseCache = false;
            StartCP = null;
            EndCP = null;
            UseGlobalSpace = false;
        }

        /*! \endcond */
        #endregion

        /// <summary>
        /// Checks that StartCP and EndCp values are correct, and fix them if they are not.
        /// </summary>
        private void OnSplineRefreshed(CurvySplineEventArgs e)
        {
            if (!enabled || !gameObject.activeInHierarchy)
                return;
            if (InputSpline == e.Spline)
                ForceRefresh();
            else
                e.Spline.OnRefresh.RemoveListener(OnSplineRefreshed);
        }

        private void OnInputSplineCoordinatesChanged(CurvySpline sender)
        {
            if (!enabled || !gameObject.activeInHierarchy)
                return;
            if (InputSpline == sender)
            {
                if (UseGlobalSpace)
                    ForceRefresh();
            }
            else
                InputSpline.OnGlobalCoordinatesChanged -= OnInputSplineCoordinatesChanged;
        }

        private void ForceRefresh()
        {
            Dirty = true;
#if UNITY_EDITOR
            // The Update order makes the spline and CP update happen before the generator, so from first look, no need to force the generator update, it should happen naturally. But unfortunately things are not that simple :(
            // So the explanation is that the whole chain of actions that lead to this method being called starts with the change of the transform of a CP. For some reason (I am sure about this for 90%) the transform change's is acknowledged in the spline's (or CP's) Update while in Play mode, but only in editorUpdate when in Edit mode. And editorUpdate gets called after all the Updates (including the generator's update), so to make sure the generator is up to date after the spline's update we have to force it's update when not in Play mode
            if (!Application.isPlaying)
                Generator.TryAutoRefresh();
#endif
        }

        private bool getPathClosed(CurvySpline spline)
        {
            if (!spline || !spline.Closed)
                return false;
            return EndCP == null;
        }

        #region GetSplineData

        protected CGData GetSplineData(CurvySpline spline, bool fullPath /*is spline a path*/, CGDataRequestRasterization raster, CGDataRequestMetaCGOptions options)
        {
            if (spline == null || spline.Count == 0)
                return null;

            // calc start & end point (distance)
            float pathLength = StartCP && EndCP ? EndCP.Distance - StartCP.Distance : spline.Length;
            float startDist;
            float endDist;
            {
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(raster.Start >= 0);
                Assert.IsTrue(raster.Start <= 1);
#endif
                startDist = pathLength * raster.Start;
                if (StartCP)
                    startDist = (startDist + StartCP.Distance) % spline.Length;
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(startDist >= 0);
                Assert.IsTrue(startDist <= spline.Length);

                Assert.IsTrue(raster.RasterizedRelativeLength >= 0);
                Assert.IsTrue(raster.RasterizedRelativeLength <= 1);
#endif
                endDist = startDist + pathLength * raster.RasterizedRelativeLength;

            }

            float stepDist;
            {
                float samplingPointsPerUnit = CurvySpline.CalculateSamplingPointsPerUnit(
                    raster.Resolution,
                    spline.MaxPointsPerUnit);

                float sampledDistance = (endDist - startDist);
                stepDist = Mathf.Min(
                    sampledDistance / (pathLength * raster.RasterizedRelativeLength * samplingPointsPerUnit),
                    //To ensure that rasterized shapes have at least 3 vertices to generate valid meshes
                    sampledDistance / 3f);
            }

            CGShape data;
            {
                data = (fullPath) ? new CGPath() : new CGShape();
                data.Length = endDist - startDist;
                data.SourceIsManaged = IsManagedResource(spline);
                data.Closed = spline.Closed;
                data.Seamless = spline.Closed && raster.RasterizedRelativeLength == 1;
            }


            if (data.Length == 0)
                return data;

            // Scan input spline and fetch a list of control points that provide special options (Hard Edge, MaterialID etc...)
            int materialID;
            float maxStep;
            List<ControlPointOption> controlPointsOptions;
            {
                if (options)
                {
                    controlPointsOptions = CGUtility.GetControlPointsWithOptions(options,
                        spline,
                        startDist,
                        endDist,
                        raster.Mode == CGDataRequestRasterization.ModeEnum.Optimized,
                        out materialID,
                        out maxStep);
                }
                else
                {
                    controlPointsOptions = new List<ControlPointOption>();
                    materialID = 0;
                    maxStep = float.MaxValue;
                }
            }

            // initialize with start TF
            float tf = spline.DistanceToTF(startDist);
            float startTF = tf;
            float endTF = (endDist > spline.Length && spline.Closed) ? spline.DistanceToTF(endDist - spline.Length) + 1 : spline.DistanceToTF(endDist);
            float currentDistance = startDist;

            // Setup vars
            SubArrayList<Vector3> positions, tangents, normals;
            SubArrayList<float> sourceFs, relativeFs;
            {
                int initialArraysLength;
                switch (raster.Mode)
                {
                    case CGDataRequestRasterization.ModeEnum.Even:
                        initialArraysLength = Mathf.Max(20, Mathf.CeilToInt(1.1f * (endDist - startDist) / stepDist));
                        break;
                    case CGDataRequestRasterization.ModeEnum.Optimized:
                        initialArraysLength = Mathf.Max(20, Mathf.CeilToInt(0.2f * (endDist - startDist) / stepDist));
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }

                positions = new SubArrayList<Vector3>(initialArraysLength, ArrayPools.Vector3);
                relativeFs = new SubArrayList<float>(initialArraysLength, ArrayPools.Single);
                sourceFs = new SubArrayList<float>(initialArraysLength, ArrayPools.Single);
                tangents = new SubArrayList<Vector3>(fullPath ? initialArraysLength : 0, ArrayPools.Vector3);
                normals = new SubArrayList<Vector3>(fullPath ? initialArraysLength : 0, ArrayPools.Vector3);
            }

            List<DuplicateSamplePoint> duplicatePoints = new List<DuplicateSamplePoint>();
            List<SamplePointUData> extendedUVData = new List<SamplePointUData>();
            bool duplicatePoint = false;//TODO BUG? why is duplicatePoint not used before assigning it in the ModeEnum.Optimized case?
            // we have at least one Material Group
            SamplePointsMaterialGroup materialGroup = new SamplePointsMaterialGroup(materialID);
            // and at least one patch within that group
            SamplePointsPatch patch = new SamplePointsPatch(0);
            CurvyClamping clampMode = (data.Closed) ? CurvyClamping.Loop : CurvyClamping.Clamp;
            int dead = 2000000;

            //BUG? there is a lot of code that is quite the same, but not completly, between the two following cases. I sens potential bugs here
            //OPTIM in the following, a lot of spline methods have a call to TFToSegment inside them. Instead of letting each one of these methods call TFToSegment, call it once and give it to all the methods
            switch (raster.Mode)
            {
                case CGDataRequestRasterization.ModeEnum.Even:
                    #region --- Even ---
                    {
                        // we advance the spline using a fixed distance
                        while (currentDistance <= endDist && --dead > 0)
                        {
                            tf = spline.DistanceToTF(spline.ClampDistance(currentDistance, clampMode));

                            float currentF;
                            {
                                currentF = (currentDistance - startDist) / data.Length;//curDist / endDist;
                                if (Mathf.Approximately(1, currentF))
                                    currentF = 1;
                            }

                            //Position, tangent and up
                            Vector3 currentPosition;
                            Vector3 currentTangent;
                            Vector3 currentUp;
                            {
                                float localF;
                                CurvySplineSegment segment = spline.TFToSegment(tf, out localF, CurvyClamping.Clamp);
                                if (fullPath) // add path values
                                {
                                    if (UseCache)
                                        segment.InterpolateAndGetTangentFast(localF, out currentPosition, out currentTangent);
                                    else
                                        segment.InterpolateAndGetTangent(localF, out currentPosition, out currentTangent);

                                    //OPTIM get orientation at the same time you get position and tangent
                                    currentUp = segment.GetOrientationUpFast(localF);
                                }
                                else
                                {
                                    currentPosition = (UseCache) ? segment.InterpolateFast(localF) : segment.Interpolate(localF);
                                    currentTangent = Vector3.zero;
                                    currentUp = Vector3.zero;
                                }
                            }

                            AddPoint(currentDistance / spline.Length,
                                currentF,
                                fullPath,
                                currentPosition,
                                currentTangent,
                                currentUp,
                                ref sourceFs,
                                ref relativeFs,
                                ref positions,
                                ref tangents,
                                ref normals);

                            if (duplicatePoint) // HardEdge, IncludeCP, MaterialID changes etc. need an extra vertex
                            {
                                AddPoint(currentDistance / spline.Length,
                                    currentF,
                                    fullPath,
                                    currentPosition,
                                    currentTangent,
                                    currentUp,
                                    ref sourceFs,
                                    ref relativeFs,
                                    ref positions,
                                    ref tangents,
                                    ref normals);
                                duplicatePoint = false;
                            }

                            // Advance
                            currentDistance += stepDist;

                            // Check next Sample Point's options. If the next point would be past a CP with options
                            if (controlPointsOptions.Count > 0 && currentDistance >= controlPointsOptions[0].Distance)
                            {
                                ControlPointOption cpOptions = controlPointsOptions[0];

                                ProcessControlPointOptions(cpOptions, positions.Count, data.MaterialGroups, extendedUVData, duplicatePoints, ref materialGroup, ref patch, out currentDistance, out duplicatePoint);

                                // and remove the CP from the options
                                controlPointsOptions.RemoveAt(0);
                            }

                            // Ensure last sample point position is at the desired end distance
                            if (currentDistance > endDist && currentF < 1) // next loop curF will be 1
                                currentDistance = endDist;
                        }
                        if (dead <= 0)
                            Debug.LogError("[Curvy] He's dead, Jim! Deadloop in SplineInputModuleBase.GetSplineData (Even)! Please send a bug report.");
                        // store the last open patch
                        patch.End = positions.Count - 1;
                        materialGroup.Patches.Add(patch);
                        // ExplicitU on last Vertex?
                        //if (optionsSegs.Count > 0 && optionsSegs[0].UVShift)
                        //    extendedUVData.Add(new SamplePointUData(pos.Count - 1, optionsSegs[0].UVEdge, optionsSegs[0].FirstU, optionsSegs[0].SecondU));
                        // if path is closed and no hard edges involved, we need to smooth first normal
                        if (data.Closed)
                            duplicatePoints.Add(new DuplicateSamplePoint(positions.Count - 1, 0, spline[0].GetMetadata<MetaCGOptions>(true).CorrectedHardEdge));

                        FillData(data,
                            materialGroup,
                            sourceFs,
                            relativeFs,
                            fullPath,
                            positions,
                            tangents,
                            normals,
                            UseGlobalSpace,
                            spline.transform,
                            Generator.transform);

                    }
                    #endregion
                    break;
                case CGDataRequestRasterization.ModeEnum.Optimized:
                    #region --- Optimized ---
                    {
                        float stepSizeTF = stepDist / spline.Length;
                        float maxAngle = raster.AngleThreshold;

                        Vector3 currentPosition;
                        Vector3 currentTangent;
                        {
                            if (UseCache)
                                spline.InterpolateAndGetTangentFast(tf, out currentPosition, out currentTangent);
                            else
                                spline.InterpolateAndGetTangent(tf, out currentPosition, out currentTangent);
                        }

                        while (tf < endTF && dead-- > 0)
                        {
                            AddPoint(currentDistance / spline.Length,
                                (currentDistance - startDist) / data.Length,
                                fullPath,
                                currentPosition,
                                currentTangent,
                                spline.GetOrientationUpFast(tf % 1),
                                ref sourceFs,
                                ref relativeFs,
                                ref positions,
                                ref tangents,
                                ref normals);
                            // Advance
                            float stopAt = (controlPointsOptions.Count > 0) ? controlPointsOptions[0].TF : endTF;

                            bool atStopPoint = MoveByAngleExt(spline,
                                UseCache,
                                ref tf,
                                maxStep,
                                maxAngle,
                                out currentPosition,
                                out currentTangent,
                                stopAt,
                                data.Closed,
                                stepSizeTF);

                            currentDistance = spline.TFToDistance(tf, clampMode);
                            if (currentDistance < startDist)
                                currentDistance += spline.Length;

                            if (Mathf.Approximately(tf, endTF) || tf > endTF)
                            {
                                currentDistance = endDist;
                                endTF = (data.Closed) ? DTMath.Repeat(endTF, 1) : Mathf.Clamp01(endTF);
                                if (fullPath)
                                {
                                    if (UseCache)
                                        spline.InterpolateAndGetTangentFast(endTF, out currentPosition, out currentTangent);
                                    else
                                        spline.InterpolateAndGetTangent(endTF, out currentPosition, out currentTangent);
                                }
                                else
                                    currentPosition = (UseCache) ? spline.InterpolateFast(endTF) : spline.Interpolate(endTF);

                                AddPoint(currentDistance / spline.Length,
                                    (currentDistance - startDist) / data.Length,
                                    fullPath,
                                    currentPosition,
                                    currentTangent,
                                    spline.GetOrientationUpFast(endTF),
                                    ref sourceFs,
                                    ref relativeFs,
                                    ref positions,
                                    ref tangents,
                                    ref normals);
                                break;
                            }
                            if (atStopPoint)
                            {
                                if (controlPointsOptions.Count > 0)
                                {
                                    ControlPointOption cpOptions = controlPointsOptions[0];
                                    ProcessControlPointOptions(cpOptions, positions.Count, data.MaterialGroups, extendedUVData,
                                        duplicatePoints, ref materialGroup, ref patch, out currentDistance, out duplicatePoint);
                                    // and remove the CP from the options
                                    controlPointsOptions.RemoveAt(0);

                                    maxStep = (cpOptions.MaxStepDistance);
                                    if (duplicatePoint)
                                        AddPoint(currentDistance / spline.Length,
                                            (currentDistance - startDist) / data.Length,
                                            fullPath,
                                            currentPosition,
                                            currentTangent,
                                            spline.GetOrientationUpFast(tf),
                                            ref sourceFs,
                                            ref relativeFs,
                                            ref positions,
                                            ref tangents,
                                            ref normals);

                                }
                                else
                                {
                                    AddPoint(currentDistance / spline.Length,
                                        (currentDistance - startDist) / data.Length,
                                        fullPath,
                                        currentPosition,
                                        currentTangent,
                                        spline.GetOrientationUpFast(tf),
                                        ref sourceFs,
                                        ref relativeFs,
                                        ref positions,
                                        ref tangents,
                                        ref normals);
                                    break;
                                }
                            }

                        }
                        if (dead <= 0)
                            Debug.LogError("[Curvy] He's dead, Jim! Deadloop in SplineInputModuleBase.GetSplineData (Optimized)! Please send a bug report.");
                        // store the last open patch
                        patch.End = positions.Count - 1;
                        materialGroup.Patches.Add(patch);
                        // ExplicitU on last Vertex?
                        if (controlPointsOptions.Count > 0 && controlPointsOptions[0].UVShift)
                            extendedUVData.Add(new SamplePointUData(positions.Count - 1, controlPointsOptions[0]));

                        // if path is closed and no hard edges involved, we need to smooth first normal
                        if (data.Closed)
                            duplicatePoints.Add(new DuplicateSamplePoint(positions.Count - 1, 0, spline[0].GetMetadata<MetaCGOptions>(true).CorrectedHardEdge));

                        FillData(data,
                            materialGroup,
                            sourceFs,
                            relativeFs,
                            fullPath,
                            positions,
                            tangents,
                            normals,
                            UseGlobalSpace,
                            spline.transform,
                            Generator.transform);
                    }
                    #endregion
                    break;
            }

            data.CustomValues = ArrayPools.Single.Clone(data.RelativeDistances);
            data.DuplicatePoints = duplicatePoints;

            if (!fullPath)
            {
                data.RecalculateNormals();
                if (extendedUVData.Count > 0)
                {
                    CalculateExtendedUV(spline, startTF, endTF, extendedUVData, data);
                    if (spline.Closed)
                        UIMessages.Add("Extended UV features (UV Edge, Explicit U) are used in the Meta CG Options of a closed spline. Those features are supported only for open splines");
                }
            }

            return data;
        }

        private static void ProcessControlPointOptions(ControlPointOption options,
            int positionsCount,
            List<SamplePointsMaterialGroup> shapeMaterialGroups,
            List<SamplePointUData> extendedUVData,
            List<DuplicateSamplePoint> duplicatePoints,
            ref SamplePointsMaterialGroup currentMaterialGroup,
            ref SamplePointsPatch currentPatch,
            out float currentDistance,
            out bool duplicatePoint)
        {
            if (options.UVEdge || options.UVShift)
                extendedUVData.Add(new SamplePointUData(positionsCount, options));

            // clamp point at CP and maybe duplicate the next sample point
            currentDistance = options.Distance;
            duplicatePoint = options.HardEdge || options.MaterialID != currentMaterialGroup.MaterialID || options.UVEdge;
            // end the current patch...
            if (duplicatePoint)
            {
                duplicatePoints.Add(new DuplicateSamplePoint(positionsCount, positionsCount + 1, options.HardEdge));

                currentPatch.End = positionsCount;
                currentMaterialGroup.Patches.Add(currentPatch);
                // if MaterialID changes, we start a new MaterialGroup
                if (currentMaterialGroup.MaterialID != options.MaterialID)
                {
                    shapeMaterialGroups.Add(currentMaterialGroup);
                    currentMaterialGroup = new SamplePointsMaterialGroup(options.MaterialID);
                }

                // in any case we start a new patch
                currentPatch = new SamplePointsPatch(positionsCount + 1);
                // Extended UV
                if (options.UVEdge || options.UVShift)
                    extendedUVData.Add(new SamplePointUData(positionsCount + 1, options));
            }
        }

        private static void FillData(CGShape dataToFill,
            SamplePointsMaterialGroup materialGroup,
            SubArrayList<float> sourceFs,
            SubArrayList<float> relativeFs,
            bool isFullPath,
            SubArrayList<Vector3> positions,
            SubArrayList<Vector3> tangents,
            SubArrayList<Vector3> normals,
            bool considerSplineTransform,
            Transform splineTransform,
            Transform generatorTransform)
        {
            if (considerSplineTransform)
            {
                //OPTIM do not do the transform if the spline and generator transforms are the same
                Vector3[] positionsArray = positions.Array;
                for (int i = 0; i < positions.Count; i++)
                    positionsArray[i] = generatorTransform.InverseTransformPoint(splineTransform.TransformPoint(positionsArray[i]));

                if (isFullPath)
                {
                    Vector3[] normalsArray = normals.Array;
                    Vector3[] tangentsArray = tangents.Array;
                    for (int i = 0; i < tangents.Count; i++)
                        tangentsArray[i] = generatorTransform.InverseTransformDirection(splineTransform.TransformDirection(tangentsArray[i]));
                    for (int i = 0; i < normals.Count; i++)
                        normalsArray[i] = generatorTransform.InverseTransformDirection(splineTransform.TransformDirection(normalsArray[i]));
                }
            }

            //OPTIM find a way to have the inputs already as arrays, instead of calling ToArray on them
            dataToFill.MaterialGroups.Add(materialGroup);

            dataToFill.SourceRelativeDistances = sourceFs.ToSubArray();
            dataToFill.RelativeDistances = relativeFs.ToSubArray();
            dataToFill.Positions = positions.ToSubArray();

            if (isFullPath)
            {
                ((CGPath)dataToFill).Directions = tangents.ToSubArray();
                dataToFill.Normals = normals.ToSubArray();
            }
        }

        static private void AddPoint(float sourceF,
            float relativeF,
            bool isFullPath,
            Vector3 position,
            Vector3 tangent,
            Vector3 up,
            ref SubArrayList<float> sourceFList,
            ref SubArrayList<float> relativeFList,
            ref SubArrayList<Vector3> positionList,
            ref SubArrayList<Vector3> tangentList,
            ref SubArrayList<Vector3> upList)
        {
            sourceF = sourceF.Approximately(1f) ? 1f : (sourceF % 1);

#if CURVY_SANITY_CHECKS
            if (relativeF < 0 || relativeF > 1)
                DTLog.LogError("[Curvy] Invalid point's relativeF value " + relativeF);

            if (sourceF < 0 || sourceF > 1)
                DTLog.LogError("[Curvy] Invalid point's sourceF value " + sourceF);
#endif
            sourceFList.Add(sourceF);
            positionList.Add(position);
            relativeFList.Add(relativeF);
            if (isFullPath)
            {
                tangentList.Add(tangent);
                upList.Add(up);
            }
        }


        private static bool MoveByAngleExt(CurvySpline spline,
            bool useCache,
            ref float tf,
            float maxDistance,
            float maxAngle,
            out Vector3 pos,
            out Vector3 tan,
            float stopTF,
            bool loop,
            float stepDist)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(maxAngle >= 0);
            Assert.IsTrue(spline.Count != 0);
#endif

            if (!loop)
                tf = Mathf.Clamp01(tf);
            float tn = (loop) ? tf % 1 : tf;
            float localF;
            CurvySplineSegment segment;

            segment = spline.TFToSegment(tn, out localF, CurvyClamping.Clamp);
            if (useCache)
                segment.InterpolateAndGetTangentFast(localF, out pos, out tan);
            else
                segment.InterpolateAndGetTangent(localF, out pos, out tan);
            Vector3 lastPos = pos;
            Vector3 lastTan = tan;

            float movedDistance = 0;
            float angleAccumulator = 0;

            if (stopTF < tf && loop)
                stopTF++;

            bool earlyExitConditionMet = false;
            while (tf < stopTF && earlyExitConditionMet == false)
            {
                tf = Mathf.Min(stopTF, tf + stepDist);
                tn = (loop) ? tf % 1 : tf;

                segment = spline.TFToSegment(tn, out localF, CurvyClamping.Clamp);
                if (useCache)
                    segment.InterpolateAndGetTangentFast(localF, out pos, out tan);
                else
                    segment.InterpolateAndGetTangent(localF, out pos, out tan);

                Vector3 movement;
                {
                    //Optimized way of substracting lastPos from pos. Optimization works with Mono platforms
                    movement.x = pos.x - lastPos.x;
                    movement.y = pos.y - lastPos.y;
                    movement.z = pos.z - lastPos.z;
                }
                movedDistance += movement.magnitude;

                float tangentsAngle = Vector3.Angle(lastTan, tan);
                angleAccumulator += tangentsAngle;

                // Check if conditions are met
                if (movedDistance >= maxDistance // max distance reached
                    || angleAccumulator >= maxAngle // max angle reached
                    || (tangentsAngle == 0 && angleAccumulator > 0))// current step is linear while the whole movement is not.
                    earlyExitConditionMet = true;
                else
                {
                    lastPos = pos;
                    lastTan = tan;
                }
            }

            return Mathf.Approximately(tf, stopTF);
        }

        #region CalculateExtendedUV

        private static void CalculateExtendedUV(CurvySpline spline, float startTF, float endTF, List<SamplePointUData> ext, CGShape data)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(ext.Count > 0);
            Assert.IsTrue(startTF.IsBetween0And1());
            if (spline.Closed)
                DTLog.LogWarning($"[Curvy] Extended UV is supported only on open splines. Spline name: {spline.name}", spline);
#endif

            // we have a list of data, either UV Edge (double then) or Explicit
            // unlike easy mode, U is bound to Shape's SourceRelativeDistances, not RelativeDistances!

            // for the first vertex, find the reference CP and calculate starting U (first vertex never has matching Udata, even if it's over a reference CP!!!)    
            {
                CurvySplineSegment previousReferenceCP, nextReferenceCP;
                MetaCGOptions previousReferenceCPOptions, nextReferenceCPOptions;
                {
                    previousReferenceCPOptions = findPreviousReferenceCPOptions(spline, startTF, out previousReferenceCP);
                    nextReferenceCPOptions = findNextReferenceCPOptions(spline, startTF, out nextReferenceCP);
                }

                // we now know the U range the first vertex is in, so let's calculate it's actual U value
                // get the distance delta within that range
                float frag;
                {
                    float nextReferenceCPDistance;
                    if (spline.FirstVisibleControlPoint == nextReferenceCP)
                    {
                        // Special case: nextReferenceCP is first CP (implies closed spline)
                        nextReferenceCPDistance = spline.Length;
#if CURVY_SANITY_CHECKS
                        Assert.IsTrue(spline.Closed);
#endif
                    }
                    else
                        nextReferenceCPDistance = nextReferenceCP.Distance;

                    frag = ((data.SourceRelativeDistances.Array[0] * spline.Length) - previousReferenceCP.Distance) / (nextReferenceCPDistance - previousReferenceCP.Distance);
                }


                float firstU = Mathf.LerpUnclamped(previousReferenceCPOptions.GetDefinedFirstU(0), nextReferenceCPOptions.GetDefinedFirstU(0), frag);

                float secondU = previousReferenceCPOptions.GetDefinedSecondU(0);

                ext.Insert(0,
                    new SamplePointUData(0,
                        (startTF == 0 && previousReferenceCPOptions.CorrectedUVEdge),
                        (startTF == 0 && previousReferenceCPOptions.CorrectedUVEdge),
                        firstU,
                        secondU));
            }

            // Do the same for the last vertex, find the reference CP and calculate starting U (first vertex never has matching Udata, even if it's over a reference CP!!!)
            if (ext[ext.Count - 1].Vertex < data.Count - 1)
            {
                CurvySplineSegment previousReferenceCP, nextReferenceCP;
                MetaCGOptions previousReferenceCPOptions, nextReferenceCPOptions;
                {
                    previousReferenceCPOptions = findPreviousReferenceCPOptions(spline, endTF, out previousReferenceCP);
                    nextReferenceCPOptions = findNextReferenceCPOptions(spline, endTF, out nextReferenceCP);
                }

                float nextReferenceCPU;
                // Special case: nextReferenceCP is first CP (implies closed spline)
                float frag;
                if (spline.FirstVisibleControlPoint == nextReferenceCP)
                {
#if CURVY_SANITY_CHECKS
                    Assert.IsTrue(spline.Closed);
#endif
                    frag = ((data.SourceRelativeDistances.Array[data.Count - 1] * spline.Length) - previousReferenceCP.Distance) / (spline.Length - previousReferenceCP.Distance);
                    // either take the ending U from 2nd U of first CP or raise last U to next int
                    if (nextReferenceCPOptions.CorrectedUVEdge)
                        nextReferenceCPU = nextReferenceCPOptions.FirstU;
                    else if (ext.Count > 1)
                        nextReferenceCPU = Mathf.FloorToInt((ext[ext.Count - 1].UVEdge) ? ext[ext.Count - 1].SecondU : ext[ext.Count - 1].FirstU) + 1;
                    else
                        nextReferenceCPU = 1;
                }
                else
                {
                    frag = ((data.SourceRelativeDistances.Array[data.Count - 1] * spline.Length) - previousReferenceCP.Distance) / (nextReferenceCP.Distance - previousReferenceCP.Distance);
                    nextReferenceCPU = nextReferenceCPOptions.GetDefinedFirstU(1);
                }

                ext.Add(new SamplePointUData(data.Count - 1,
                    false,
                    false,
                    Mathf.LerpUnclamped(previousReferenceCPOptions.GetDefinedSecondU(0), nextReferenceCPU, frag),
                    0));
            }

            float startF = 0;
            float lowerBoundU = (ext[0].UVEdge) ? ext[0].SecondU : ext[0].FirstU;
            float upperBoundU = ext[1].FirstU;
            float length = data.RelativeDistances.Array[ext[1].Vertex] - data.RelativeDistances.Array[ext[0].Vertex];
            int current = 1;
            for (int vertexIndex = 0; vertexIndex < data.Count - 1; vertexIndex++)
            {
                float curF = (data.RelativeDistances.Array[vertexIndex] - startF) / length;
                data.CustomValues.Array[vertexIndex] = (upperBoundU - lowerBoundU) * curF + lowerBoundU;

                if (ext[current].Vertex == vertexIndex
                    //reached last iteration, so no need to update data that will not get used, especially that
                    //the update leads to exceptions in certain cases, where  upperBoundU = ext[current + 1].FirstU accesses
                    //the "ext" array with out of bound index. This happens with open spline of 4 CPs, all having
                    //Hard Edge, and only the last one having Explicit U set
                    && vertexIndex + 1 < data.Count - 1)
                {
                    float nextDistance = data.RelativeDistances.Array[ext[current + 1].Vertex];
                    float currentDistance = data.RelativeDistances.Array[ext[current].Vertex];
                    bool isDuplicatedVertex = nextDistance.Approximately(currentDistance);

                    if (isDuplicatedVertex)
                    {
                        lowerBoundU = (ext[current].UVEdge) ? ext[current].SecondU : ext[current].FirstU;
                        current++;
                        //update distances
                        currentDistance = nextDistance;
                        nextDistance = data.RelativeDistances.Array[ext[current + 1].Vertex];
                    }
                    else
                        lowerBoundU = ext[current].FirstU;

                    upperBoundU = ext[current + 1].FirstU;
                    length = nextDistance - currentDistance;
                    startF = data.RelativeDistances.Array[vertexIndex];
                    current++;
                }
            }
            data.CustomValues.Array[data.Count - 1] = ext[ext.Count - 1].FirstU;
        }

        private static MetaCGOptions findPreviousReferenceCPOptions(CurvySpline spline, float tf, out CurvySplineSegment cp)
        {
            MetaCGOptions options;
            cp = spline.TFToSegment(tf);
            do
            {
                options = cp.GetMetadata<MetaCGOptions>(true);
                if (spline.FirstVisibleControlPoint == cp)
                    return options;
                cp = spline.GetPreviousSegment(cp);
            }
            while (cp && !options.CorrectedUVEdge && !options.ExplicitU);
            return options;
        }

        private static MetaCGOptions findNextReferenceCPOptions(CurvySpline spline, float tf, out CurvySplineSegment cp)
        {
            MetaCGOptions options;
            cp = spline.TFToSegment(tf, out _);

            do
            {
                cp = spline.GetNextControlPoint(cp);
                options = cp.GetMetadata<MetaCGOptions>(true);
                if (!spline.Closed && spline.LastVisibleControlPoint == cp)
                    return options;
            }
            while (!options.CorrectedUVEdge && !options.ExplicitU && !(spline.FirstSegment == cp));
            return options;
        }
        #endregion

        #endregion

        #region Protected members

        protected abstract CurvySpline InputSpline
        {
            get;
            set;
        }

        protected virtual void OnSplineAssigned()
        {
            if (InputSpline)
            {
                InputSpline.OnRefresh.AddListenerOnce(OnSplineRefreshed);
                InputSpline.OnGlobalCoordinatesChanged += OnInputSplineCoordinatesChanged;
            }
        }

        protected void ValidateStartAndEndCps()
        {
            if (InputSpline == null)
                return;

            if (m_StartCP && m_StartCP.Spline != InputSpline)
            {
                DTLog.LogError(string.Format(System.Globalization.CultureInfo.InvariantCulture, "[Curvy] Input module {0}: StartCP is not part of the input spline ({1})", name, InputSpline.name), this);
                m_StartCP = null;
            }

            if (m_EndCP && m_EndCP.Spline != InputSpline)
            {
                DTLog.LogError(string.Format(System.Globalization.CultureInfo.InvariantCulture, "[Curvy] Input module {0}: EndCP is not part of the input spline ({1})", name, InputSpline.name), this);
                m_EndCP = null;
            }

            if (InputSpline.IsInitialized && m_EndCP != null && m_StartCP != null
                && InputSpline.GetControlPointIndex(m_EndCP) <= InputSpline.GetControlPointIndex(m_StartCP))
            {
                DTLog.LogError(string.Format(System.Globalization.CultureInfo.InvariantCulture, "[Curvy] Input module {0}: EndCP has an index ({1}) less or equal than StartCP ({2})", name, InputSpline.GetControlPointIndex(m_EndCP), InputSpline.GetControlPointIndex(m_StartCP)), this);
                m_EndCP = null;
            }
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/Base/SplineInputModuleBase.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/Base/TRSModuleBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 65257de41cf532441ab1b94533a88ea6
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Base class for TRS Modules
    /// </summary>
    public abstract class TRSModuleBase : CGModule
    {

        #region ### Serialized Fields ###

        [SerializeField]
        [VectorEx]
        private Vector3 m_Transpose;
        [SerializeField]
        [VectorEx]
        private Vector3 m_Rotation;
        [SerializeField]
        [VectorEx]
        private Vector3 m_Scale = Vector3.one;

        #endregion

        #region ### Public Properties ###

        public Vector3 Transpose
        {
            get { return m_Transpose; }
            set
            {
                if (m_Transpose != value)
                    m_Transpose = value;
                Dirty = true;
            }
        }

        public Vector3 Rotation
        {
            get { return m_Rotation; }
            set
            {
                if (m_Rotation != value)
                    m_Rotation = value;
                Dirty = true;
            }
        }

        public Vector3 Scale
        {
            get { return m_Scale; }
            set
            {
                if (m_Scale != value)
                    m_Scale = value;
                Dirty = true;
            }
        }

        public Matrix4x4 Matrix
        {
            get { return Matrix4x4.TRS(Transpose, Quaternion.Euler(Rotation), Scale); }
        }

        #endregion

        #region ### Private Fields & Properties ###
        #endregion

        protected Matrix4x4 ApplyTrsOnShape(CGShape shape)
        {
            Matrix4x4 mat = Matrix;
            Matrix4x4 scaleLessMatrix = Matrix4x4.TRS(Transpose, Quaternion.Euler(Rotation), Vector3.one);
            for (int i = 0; i < shape.Count; i++)
            {
                shape.Positions.Array[i] = mat.MultiplyPoint3x4(shape.Positions.Array[i]);
                shape.Normals.Array[i] = scaleLessMatrix.MultiplyVector(shape.Normals.Array[i]);
            }

            if (Scale != Vector3.one)
                shape.Recalculate();

            return scaleLessMatrix;
        }

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected override void OnEnable()
        {
            base.OnEnable();
            Properties.MinWidth = 250;
            Properties.LabelWidth = 50;
        }

        public override void Reset()
        {
            base.Reset();
            Transpose = Vector3.zero;
            Rotation = Vector3.zero;
            Scale = Vector3.one;
        }
#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Transpose = m_Transpose;
            Rotation = m_Rotation;
            Scale = m_Scale;
        }
#endif

        /*! \endcond */
        #endregion




    }

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/Base/TRSModuleBase.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildRasterizedPath.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a4dd47aa60d1b454886133ad3297289c
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Build/Rasterize Path", ModuleName = "Rasterize Path", Description = "Rasterizes a virtual path")]
    [HelpURL(CurvySpline.DOCLINK + "cgbuildrasterizedpath")]
    public class BuildRasterizedPath : CGModule, IPathProvider
    {
        [HideInInspector]
        [InputSlotInfo(typeof(CGPath), Name = "Path", RequestDataOnly = true)]
        public CGModuleInputSlot InPath = new CGModuleInputSlot();
        [HideInInspector]
        [OutputSlotInfo(typeof(CGPath), Name = "Path", DisplayName = "Rasterized Path")]
        public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();

        #region ### Serialized Fields ###

        [FloatRegion(UseSlider = true, RegionOptionsPropertyName = nameof(RangeOptions), Precision = 4)]
        [SerializeField]
        private FloatRegion m_Range = FloatRegion.ZeroOne;
        [SerializeField, RangeEx(1, 100, "Resolution", "Defines how densely the path spline's sampling points are. When the value is 100, the number of sampling points per world distance unit is equal to the spline's Max Points Per Unit")]
        private int m_Resolution = 50;
        [SerializeField] private bool m_Optimize;
        [FieldCondition(nameof(m_Optimize), true)]
        [SerializeField, RangeEx(0.1f, 120)]
        private float m_AngleTreshold = 10;

        [SerializeField]
        [Section("Backward Compatibility", false)]
        [Tooltip("Curvy versions prior to 8.0.0 had a bug in the computation of the rasterization range for closed splines. Enable this value to keep that bugged behaviour if your project depends on it")]
        private bool useBuggedRange;
        #endregion

        #region ### Public Properties ###

        //TODO DESIGN this code should be unified with BuildShapeExtrusion's

        public float From
        {
            get { return m_Range.From; }
            set
            {
                float v = DTMath.Repeat(value, 1);
                if (m_Range.From != v)
                    m_Range.From = v;

                Dirty = true;
            }
        }

        public float To
        {
            get { return m_Range.To; }
            set
            {
                float v = Mathf.Max(From, value);
                if (ClampPath)
                    v = Mathf.Repeat(value, 1);
                if (m_Range.To != v)
                    m_Range.To = v;

                Dirty = true;
            }
        }

        public float Length
        {
            get
            {
                return (ClampPath) ? m_Range.To - m_Range.From : m_Range.To;
            }
            set
            {
                float v = (ClampPath) ? value - m_Range.To : value;
                if (m_Range.To != v)
                    m_Range.To = v;
                Dirty = true;
            }
        }

        /// <summary>
        /// Defines how densely the path spline's sampling points are. When the value is 100, the number of sampling points per world distance unit is equal to the spline's MaxPointsPerUnit
        /// </summary>
        public int Resolution
        {
            get { return m_Resolution; }
            set
            {
                int v = Mathf.Clamp(value, 1, 100);
                if (m_Resolution != v)
                    m_Resolution = v;
                Dirty = true;
            }
        }

        public bool Optimize
        {
            get { return m_Optimize; }
            set
            {
                if (m_Optimize != value)
                    m_Optimize = value;
                Dirty = true;
            }
        }

        public float AngleThreshold
        {
            get { return m_AngleTreshold; }
            set
            {
                float v = Mathf.Clamp(value, 0.1f, 120);
                if (m_AngleTreshold != v)
                    m_AngleTreshold = v;
                Dirty = true;
            }
        }

        public CGPath Path
        {
            get
            {
                return OutPath.GetData<CGPath>();
            }
        }

        public bool PathIsClosed
        {
            get
            {
                return !IsConfigured || InPath.SourceSlot().PathProvider.PathIsClosed;
            }
        }

        /// <summary>
        /// Curvy versions prior to 8.0.0 had a bug in the computation of the rasterization range for closed splines. Enable this value to keep that bugged behaviour if your project depends on it
        /// </summary>
        public bool UseBuggedRange
        {
            get { return useBuggedRange; }
            set
            {
                if (useBuggedRange != value)
                {
                    useBuggedRange = value;
                    Dirty = true;
                }
            }
        }

        #endregion

        #region ### Private Fields & Properties ###

        private bool ClampPath { get { return UseBuggedRange ? PathIsClosed : !PathIsClosed; } }

        private RegionOptions<float> RangeOptions
        {
            get
            {

                if (!PathIsClosed)
                {
                    return RegionOptions<float>.MinMax(0, 1);
                }
                else
                {
                    return new RegionOptions<float>()
                    {
                        LabelFrom = "Start",
                        ClampFrom = DTValueClamping.Min,
                        FromMin = 0,
                        LabelTo = "Length",
                        ClampTo = DTValueClamping.Range,
                        ToMin = 0,
                        ToMax = 1
                    };
                }
            }
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected override void OnEnable()
        {
            base.OnEnable();
            Properties.MinWidth = 250;
            Properties.LabelWidth = 112;
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            //From = m_Range.From;
            //To = m_Range.To;
            Resolution = m_Resolution;
            Optimize = m_Optimize;
        }
#endif

        public override void Reset()
        {
            base.Reset();
            m_Range = FloatRegion.ZeroOne;
            Resolution = 50;
            AngleThreshold = 10;
            OutPath.ClearData();
            Optimize = false;
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public override void Refresh()
        {
            base.Refresh();
            if (Length == 0)
            {
                OutPath.ClearData();
            }
            else
            {
                List<CGDataRequestParameter> req = new List<CGDataRequestParameter>();
                req.Add(new CGDataRequestRasterization(
                    From, Length, Resolution,
                    AngleThreshold, (Optimize) ? CGDataRequestRasterization.ModeEnum.Optimized : CGDataRequestRasterization.ModeEnum.Even));
                CGPath path = InPath.GetData<CGPath>(out bool isDisposable, req.ToArray());
#if CURVY_SANITY_CHECKS
                // I forgot why I added this assertion, but I trust my past self
                Assert.IsTrue(path == null || isDisposable);
#endif
                OutPath.SetData(path);
            }
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */


        /*! \endcond */
        #endregion


    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildRasterizedPath.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildShapeExtrusion.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 40872b673c65afa41a034045c5bcda65
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using ToolBuddy.Pooling.Pools;
using FluffyUnderware.DevTools;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools.Extensions;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Build/Shape Extrusion", ModuleName = "Shape Extrusion", Description = "Simple Shape Extrusion")]
    [HelpURL(CurvySpline.DOCLINK + "cgbuildshapeextrusion")]
    public class BuildShapeExtrusion : ScalingModule, IPathProvider
    {
        #region ### Enums ###

        /// <summary>
        /// <see cref="FluffyUnderware.Curvy.Generator.Modules.ScaleMode"/>
        /// </summary>
        [Obsolete("Use FluffyUnderware.Curvy.Generator.Modules.ScaleMode instead")]
        public enum ScaleModeEnum
        {
            Simple,
            Advanced
        }

        public enum CrossShiftModeEnum
        {
            /// <summary>
            /// The start of the Shape is used
            /// </summary>
            None,
            /// <summary>
            /// The starting point is shifted to the collision point of the Path's orientation with the cross shape
            /// </summary>
            ByOrientation,//TODO rename to ByPathOrientation?
            /// <summary>
            /// The starting point is shifted by a user defined value
            /// </summary>
            Custom
        }

        #endregion

        [HideInInspector]
        [InputSlotInfo(typeof(CGPath), RequestDataOnly = true)]
        public CGModuleInputSlot InPath = new CGModuleInputSlot();

        [HideInInspector]
        [InputSlotInfo(typeof(CGShape), Array = true, ArrayType = SlotInfo.SlotArrayType.Hidden, RequestDataOnly = true)]
        public CGModuleInputSlot InCross = new CGModuleInputSlot();

        [HideInInspector]
        [OutputSlotInfo(typeof(CGVolume))]
        public CGModuleOutputSlot OutVolume = new CGModuleOutputSlot();

        [HideInInspector]
        [OutputSlotInfo(typeof(CGVolume))]
        public CGModuleOutputSlot OutVolumeHollow = new CGModuleOutputSlot();

        #region ### Serialized Fields ###

        #region TAB: Path
        [Tab("Path")]
        [FloatRegion(UseSlider = true, RegionOptionsPropertyName = nameof(RangeOptions), Precision = 4)]
        [SerializeField]
        private FloatRegion m_Range = FloatRegion.ZeroOne;
        [SerializeField, RangeEx(1, 100, "Resolution", "Defines how densely the path spline's sampling points are. When the value is 100, the number of sampling points per world distance unit is equal to the spline's Max Points Per Unit")]
        private int m_Resolution = 50;
        [SerializeField] private bool m_Optimize = true;
        [FieldCondition(nameof(m_Optimize), true)]
        [SerializeField, RangeEx(0.1f, 120, Tooltip = "Max angle")]
        private float m_AngleThreshold = 10;

        #endregion

        #region TAB: Cross
        [Tab("Cross")]
        [FieldAction("CBEditCrossButton", Position = ActionAttribute.ActionPositionEnum.Above)]
        [FloatRegion(UseSlider = true, RegionOptionsPropertyName = nameof(CrossRangeOptions), Precision = 4)]
        [SerializeField]
        private FloatRegion m_CrossRange = FloatRegion.ZeroOne;
        [SerializeField, RangeEx(1, 100, "Resolution", Tooltip = "Defines how densely the cross spline's sampling points are. When the value is 100, the number of sampling points per world distance unit is equal to the spline's Max Points Per Unit")]
        private int m_CrossResolution = 50;
        [SerializeField, Label("Optimize")] private bool m_CrossOptimize = true;
        [FieldCondition(nameof(m_CrossOptimize), true)]
        [SerializeField, RangeEx(0.1f, 120, "Angle Threshold", Tooltip = "Max angle")]
        private float m_CrossAngleThreshold = 10;

        //[Header("Options")]
        [SerializeField, Label("Include CPs")]
        [Tooltip("If enabled, vertices are guaranteed to be created for all the Cross shape's Control Points.")]
        private bool m_CrossIncludeControlpoints;

        [SerializeField, Label("Hard Edges"), HideInInspector]
        [Obsolete("This option is now always assumed to be true")]
        private bool m_CrossHardEdges;

        [SerializeField, Label("Materials"), HideInInspector]
        [Obsolete("This option is now always assumed to be true")]
        private bool m_CrossMaterials;

        [SerializeField, Label("Extended UV"), HideInInspector]
        [Obsolete("This option is now always assumed to be true")]
        private bool m_CrossExtendedUV;

        [SerializeField, Label("Shift", Tooltip = "Defines a shift to be applied on the output volume's cross.\r\nThis shift is used when interpolating values (position, normal, ...) along the volume's surface.")]
        private CrossShiftModeEnum m_CrossShiftMode = CrossShiftModeEnum.ByOrientation;
        [SerializeField]
        [RangeEx(0, 1, "Value", "Shift By", Slider = true)]
        [FieldCondition(nameof(m_CrossShiftMode), CrossShiftModeEnum.Custom)]
        private float m_CrossShiftValue;
        [Label("Reverse Normal", "Reverse Vertex Normals?")]
        [SerializeField]
        private bool m_CrossReverseNormals;
        #endregion

        #region TAB: Hollow
        [Tab("Hollow", Sort = 102)]
        [RangeEx(0, 1, Slider = true, Label = "Inset")]
        [SerializeField]
        private float m_HollowInset;
        [Label("Reverse Normal", "Reverse Vertex Normals?")]
        [SerializeField]
        private bool m_HollowReverseNormals;
        #endregion


        #endregion

        #region ### Public Properties ###

        #region TAB: Path

        //TODO DESIGN this code should be unified with BuildRasterizedPath's

        public float From
        {
            get { return m_Range.From; }
            set
            {
                float v = Mathf.Repeat(value, 1);
                if (m_Range.From != v)
                    m_Range.From = v;

                Dirty = true;
            }
        }

        public float To
        {
            get { return m_Range.To; }
            set
            {
                float v = Mathf.Max(From, value);
                if (ClampPath)
                    v = DTMath.Repeat(value, 1);
                if (m_Range.To != v)
                    m_Range.To = v;

                Dirty = true;
            }
        }

        public float Length
        {
            get
            {
                return (ClampPath) ? m_Range.To - m_Range.From : m_Range.To;
            }
            set
            {
                float v = (ClampPath) ? value - m_Range.To : value;
                if (m_Range.To != v)
                    m_Range.To = v;
                Dirty = true;
            }
        }

        /// <summary>
        /// Defines how densely the path spline's sampling points are. When the value is 100, the number of sampling points per world distance unit is equal to the spline's MaxPointsPerUnit
        /// </summary>
        public int Resolution
        {
            get { return m_Resolution; }
            set
            {
                int v = Mathf.Clamp(value, 1, 100);
                if (m_Resolution != v)
                    m_Resolution = v;
                Dirty = true;
            }
        }

        public bool Optimize
        {
            get { return m_Optimize; }
            set
            {
                if (m_Optimize != value)
                    m_Optimize = value;
                Dirty = true;
            }
        }

        public float AngleThreshold
        {
            get { return m_AngleThreshold; }
            set
            {
                float v = Mathf.Clamp(value, 0.1f, 120);
                if (m_AngleThreshold != v)
                    m_AngleThreshold = v;
                Dirty = true;
            }
        }


        #endregion
        #region TAB: Cross
        public float CrossFrom
        {
            get { return m_CrossRange.From; }
            set
            {
                float v = Mathf.Repeat(value, 1);
                if (m_CrossRange.From != v)
                    m_CrossRange.From = v;

                Dirty = true;
            }
        }

        public float CrossTo
        {
            get { return m_CrossRange.To; }
            set
            {
                float v = Mathf.Max(CrossFrom, value);
                if (ClampCross)
                    v = DTMath.Repeat(value, 1);
                if (m_CrossRange.To != v)
                    m_CrossRange.To = v;

                Dirty = true;
            }
        }

        public float CrossLength
        {
            get
            {
                return (ClampCross) ? m_CrossRange.To - m_CrossRange.From : m_CrossRange.To;
            }
            set
            {
                float v = (ClampCross) ? value - m_CrossRange.To : value;
                if (m_CrossRange.To != v)
                    m_CrossRange.To = v;
                Dirty = true;
            }
        }

        /// <summary>
        /// Defines how densely the cross spline's sampling points are. When the value is 100, the number of sampling points per world distance unit is equal to the spline's MaxPointsPerUnit
        /// </summary>
        public int CrossResolution
        {
            get { return m_CrossResolution; }
            set
            {
                int v = Mathf.Clamp(value, 1, 100);
                if (m_CrossResolution != v)
                    m_CrossResolution = v;
                Dirty = true;
            }
        }

        public bool CrossOptimize
        {
            get { return m_CrossOptimize; }
            set
            {
                if (m_CrossOptimize != value)
                    m_CrossOptimize = value;
                Dirty = true;
            }
        }

        public float CrossAngleThreshold
        {
            get { return m_CrossAngleThreshold; }
            set
            {
                float v = Mathf.Clamp(value, 0.1f, 120);
                if (m_CrossAngleThreshold != v)
                    m_CrossAngleThreshold = v;
                Dirty = true;
            }
        }


        public bool CrossIncludeControlPoints
        {
            get { return m_CrossIncludeControlpoints; }
            set
            {
                if (m_CrossIncludeControlpoints != value)
                    m_CrossIncludeControlpoints = value;
                Dirty = true;
            }
        }

        [Obsolete("This option is now always assumed to be true")]
        public bool CrossHardEdges
        {
            get { return m_CrossHardEdges; }
            set
            {
                if (m_CrossHardEdges != value)
                    m_CrossHardEdges = value;
                Dirty = true;
            }
        }

        [Obsolete("This option is now always assumed to be true")]
        public bool CrossMaterials
        {
            get { return m_CrossMaterials; }
            set
            {
                if (m_CrossMaterials != value)
                    m_CrossMaterials = value;
                Dirty = true;
            }
        }

        [Obsolete("This option is now always assumed to be true")]
        public bool CrossExtendedUV
        {
            get { return m_CrossExtendedUV; }
            set
            {
                if (m_CrossExtendedUV != value)
                    m_CrossExtendedUV = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// Defines how the <see cref="CGVolume.CrossFShift"/> value is defined.
        /// </summary>
        public CrossShiftModeEnum CrossShiftMode
        {
            get { return m_CrossShiftMode; }
            set
            {
                if (m_CrossShiftMode != value)
                    m_CrossShiftMode = value;
                Dirty = true;
            }
        }

        public float CrossShiftValue
        {
            get { return m_CrossShiftValue; }
            set
            {
                float v = Mathf.Repeat(value, 1);
                if (m_CrossShiftValue != v)
                    m_CrossShiftValue = v;
                Dirty = true;
            }
        }

        public bool CrossReverseNormals
        {
            get { return m_CrossReverseNormals; }
            set
            {
                if (m_CrossReverseNormals != value)
                    m_CrossReverseNormals = value;
                Dirty = true;
            }
        }


        #endregion

        #region TAB: Scale

        /// <summary>
        /// <see cref="ScalingModule.ScaleMode"/>
        /// </summary>
        [Obsolete("Use parent class ScalingModule's ScaleMode instead")]
        public new ScaleModeEnum ScaleMode
        {
            get
            {
                return base.ScaleMode == Modules.ScaleMode.Simple ? ScaleModeEnum.Simple : ScaleModeEnum.Advanced;
            }
            set
            {
                if (value == ScaleModeEnum.Simple)
                    base.ScaleMode = Modules.ScaleMode.Simple;
                else
                    base.ScaleMode = Modules.ScaleMode.Advanced;
            }
        }
        #endregion

        #region TAB: Hollow

        public float HollowInset
        {
            get { return m_HollowInset; }
            set
            {
                float v = Mathf.Clamp01(value);
                if (m_HollowInset != v)
                    m_HollowInset = v;
                Dirty = true;
            }
        }

        public bool HollowReverseNormals
        {
            get { return m_HollowReverseNormals; }
            set
            {
                if (m_HollowReverseNormals != value)
                    m_HollowReverseNormals = value;
                Dirty = true;
            }
        }

        #endregion

        public int PathSamples
        {
            get;
            private set;
        }

        public int CrossSamples
        {
            get;
            private set;
        }

        public int CrossGroups { get; private set; }

        public IExternalInput Cross
        {
            get
            {
                return (IsConfigured) ? InCross.SourceSlot().ExternalInput : null;
            }
        }

        public Vector3 CrossPosition { get; protected set; }

        public Quaternion CrossRotation { get; protected set; }

        public bool PathIsClosed
        {
            get { return InPath.SourceSlot().PathProvider.PathIsClosed; }
        }

        #endregion

        #region ### Private Fields & Properties ###

        private bool ClampPath { get { return !InPath.IsLinked || !InPath.SourceSlot().PathProvider.PathIsClosed; } }
        private bool ClampCross { get { return !InCross.IsLinked || !InCross.SourceSlot().PathProvider.PathIsClosed; } }

        private RegionOptions<float> RangeOptions
        {
            get
            {

                if (ClampPath)
                {
                    return RegionOptions<float>.MinMax(0, 1);
                }
                else
                {
                    return new RegionOptions<float>()
                    {
                        LabelFrom = "Start",
                        ClampFrom = DTValueClamping.Min,
                        FromMin = 0,
                        LabelTo = "Length",
                        ClampTo = DTValueClamping.Range,
                        ToMin = 0,
                        ToMax = 1
                    };
                }
            }
        }

        private RegionOptions<float> CrossRangeOptions
        {
            get
            {

                if (ClampCross)
                {
                    return RegionOptions<float>.MinMax(0, 1);
                }
                else
                {
                    return new RegionOptions<float>()
                    {
                        LabelFrom = "Start",
                        ClampFrom = DTValueClamping.Min,
                        FromMin = 0,
                        LabelTo = "Length",
                        ClampTo = DTValueClamping.Range,
                        ToMin = 0,
                        ToMax = 1
                    };
                }
            }
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected override void OnEnable()
        {
            base.OnEnable();
            Properties.MinWidth = 270;
            Properties.LabelWidth = 100;
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            //TODO OPTIM each one of the following properties setting will set Dirty to true, and trigger a lot of work. You can avoid that by Dirty to true only once per OnValidate call
            Resolution = m_Resolution;
            Optimize = m_Optimize;

            CrossResolution = m_CrossResolution;
            CrossOptimize = m_CrossOptimize;

            CrossIncludeControlPoints = m_CrossIncludeControlpoints;
#pragma warning disable 618
            CrossHardEdges = m_CrossHardEdges;
#pragma warning restore 618
        }
#endif

        public override void Reset()
        {
            base.Reset();
            From = 0;
            To = 1;
            Resolution = 50;
            AngleThreshold = 10;
            Optimize = true;
            CrossFrom = 0;
            CrossTo = 1;
            CrossResolution = 50;
            CrossAngleThreshold = 10;
            CrossOptimize = true;
            CrossIncludeControlPoints = false;
#pragma warning disable 618
            CrossHardEdges = false;
#pragma warning restore 618
#pragma warning disable 618
            CrossMaterials = false;
#pragma warning restore 618
            CrossShiftMode = CrossShiftModeEnum.ByOrientation;
            HollowInset = 0;
#pragma warning disable 618
            CrossExtendedUV = false;
#pragma warning restore 618
            CrossReverseNormals = false;
            HollowReverseNormals = false;
        }


        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public override void Refresh()
        {
            base.Refresh();
            if (Length == 0)
            {
                OutVolume.SetData(null);
                OutVolumeHollow.SetData(null);
            }
            else
            {
                //OPTIM make it an array
                List<CGDataRequestParameter> req = new List<CGDataRequestParameter>();

                CGPath path;
                bool isPathDisposable;
                {
                    req.Add(new CGDataRequestRasterization(
                        this.From, this.Length,
                        Resolution,
                        AngleThreshold, Optimize ? CGDataRequestRasterization.ModeEnum.Optimized : CGDataRequestRasterization.ModeEnum.Even));
                    path = InPath.GetData<CGPath>(out isPathDisposable, req.ToArray());
                    req.Clear();
                }

                List<CGShape> crosses;
                bool isCrossesDisposable;
                {
                    CGDataRequestRasterization rasterizationRequest;
                    {
                        bool useVariableShape = InCross.LinkedSlots.Count == 1 && InCross.LinkedSlots[0].Info is ShapeOutputSlotInfo && (InCross.LinkedSlots[0].Info as ShapeOutputSlotInfo).OutputsVariableShape;

                        if (useVariableShape && path)
                            rasterizationRequest = new CGDataRequestShapeRasterization(path.RelativeDistances,
                                this.CrossFrom, this.CrossLength,
                                CrossResolution,
                                CrossAngleThreshold, CrossOptimize ? CGDataRequestRasterization.ModeEnum.Optimized : CGDataRequestRasterization.ModeEnum.Even);
                        else
                            rasterizationRequest = new CGDataRequestRasterization(
                                this.CrossFrom, this.CrossLength,
                                CrossResolution,
                                CrossAngleThreshold, CrossOptimize ? CGDataRequestRasterization.ModeEnum.Optimized : CGDataRequestRasterization.ModeEnum.Even);
                    }

                    req.Add(rasterizationRequest);

#pragma warning disable 618
                    req.Add(new CGDataRequestMetaCGOptions(CrossHardEdges, CrossMaterials, CrossIncludeControlPoints, CrossExtendedUV));
#pragma warning restore 618

                    crosses = InCross.GetAllData<CGShape>(out isCrossesDisposable, req.ToArray());
                }


                bool isPathInvalid = !path || path.Count == 0;

                bool areCrossesInvalid;
                {
                    List<int> distinctCrossCounts = crosses.Select(c => c == null ? 0 : c.Count).Distinct().ToList();
                    if (distinctCrossCounts.Count() != 1 || distinctCrossCounts.First() == 0)
                    {
                        areCrossesInvalid = true;
                        UIMessages.Add("Shape Extrusion: All input Crosses are expected to have the same non zero number of sample points.");
                    }
                    else
                        areCrossesInvalid = false;
                }

                if (isPathInvalid || areCrossesInvalid)
                {
                    OutVolume.ClearData();
                    OutVolumeHollow.ClearData();
                    return;
                }

                CGShape initialCross = crosses[0];

#if UNITY_EDITOR
                //TODO move these warnings, and modify them, inside the raterizing modules themselves. Because the way it is done now, if there is a module between the InputSplineShape module and the current module, the warning will not happen

                //TODO add warnings to the "Rasterize Path" module similar to those below
                //Warning messages
                {
                    for (int index = 0; index < InPath.LinkedSlots.Count; index++)
                    {
                        CGModuleSlot linkedSlot = InPath.LinkedSlots[index];
                        if (linkedSlot.Module is InputSplinePath)
                        {
                            InputSplinePath inputSplineModule = linkedSlot.Module as InputSplinePath;
                            if (inputSplineModule
                                && inputSplineModule.UseCache
                                && path.Count > inputSplineModule.Spline.CacheSize * 1.30f
                                && path.Count > inputSplineModule.Spline.CacheSize + 30)
                                UIMessages.Add(String.Format(System.Globalization.CultureInfo.InvariantCulture, "The Cache Density of \"{0}\" might be too small for this module's Path Resolution. To get a more detailed extruded volume, you might need to increase Cache Density, or set the input module's Use Cache to false", inputSplineModule.Spline.gameObject.name));
                        }
                    }

                    for (int index = 0; index < InCross.LinkedSlots.Count; index++)
                    {
                        CGModuleSlot linkedSlot = InCross.LinkedSlots[index];
                        if (linkedSlot.Module is InputSplineShape)
                        {
                            InputSplineShape inputSplineModule = linkedSlot.Module as InputSplineShape;
                            if (inputSplineModule
                                && inputSplineModule.UseCache
                                && initialCross.Count > inputSplineModule.Shape.CacheSize * 1.30f
                                && initialCross.Count > inputSplineModule.Shape.CacheSize + 30)
                                UIMessages.Add(String.Format(System.Globalization.CultureInfo.InvariantCulture, "The Cache Density of \"{0}\" might be too small for this module's Cross Resolution. To get a more detailed extruded volume, you might need to increase Cache Density, or set the input module's Use Cache to false", inputSplineModule.Shape.gameObject.name));
                        }
                    }
                }
#endif
                CGVolume vol = CGVolume.Get(OutVolume.GetData<CGVolume>(), path, initialCross);
                CGVolume volHollow = OutVolumeHollow.IsLinked ? CGVolume.Get(OutVolumeHollow.GetData<CGVolume>(), path, initialCross) : null;
                bool hasHollowVolume = volHollow;
                PathSamples = path.Count;
                CrossSamples = initialCross.Count;
                CrossGroups = initialCross.MaterialGroups.Count;
                CrossPosition = vol.Positions.Array[0];
                CrossRotation = Quaternion.LookRotation(vol.Directions.Array[0], vol.Normals.Array[0]);

                int vtIdx = 0;

                Vector2[] scalesArray = vol.Scales.Array;

                float crossNormalMul = CrossReverseNormals ? -1 : 1;
                float hollowNormalMul = HollowReverseNormals ? -1 : 1;

                bool hasSingleCross = crosses.Count == 1;

                int samplesCount = path.Count;
                for (int sample = 0; sample < samplesCount; sample++)
                {
                    CGShape currentCross;
                    if (hasSingleCross)
                        currentCross = initialCross;
                    else
                    {
                        int crossIndex = Mathf.RoundToInt((crosses.Count - 1) * path.RelativeDistances.Array[sample]);
#if CURVY_SANITY_CHECKS
                        Assert.IsTrue(path.RelativeDistances.Array[sample] >= 0);
                        Assert.IsTrue(path.RelativeDistances.Array[sample] <= 1);
                        Assert.IsTrue(crossIndex >= 0);
                        Assert.IsTrue(crossIndex < crosses.Count);
#endif
                        currentCross = crosses[crossIndex];
                    }

                    SubArray<Vector3> crossPositions = currentCross.Positions;
                    SubArray<Vector3> crossNormals = currentCross.Normals;

                    Quaternion pathRotation = Quaternion.LookRotation(path.Directions.Array[sample], path.Normals.Array[sample]);

                    //Numbers used in the quaternion multiplication formula
                    float forumlaNumber4;
                    float forumlaNumber5;
                    float forumlaNumber6;
                    float forumlaNumber7;
                    float forumlaNumber8;
                    float forumlaNumber9;
                    float forumlaNumber10;
                    float forumlaNumber11;
                    float forumlaNumber12;
                    {
                        float num1 = pathRotation.x * 2f;
                        float num2 = pathRotation.y * 2f;
                        float num3 = pathRotation.z * 2f;
                        forumlaNumber4 = pathRotation.x * num1;
                        forumlaNumber5 = pathRotation.y * num2;
                        forumlaNumber6 = pathRotation.z * num3;
                        forumlaNumber7 = pathRotation.x * num2;
                        forumlaNumber8 = pathRotation.x * num3;
                        forumlaNumber9 = pathRotation.y * num3;
                        forumlaNumber10 = pathRotation.w * num1;
                        forumlaNumber11 = pathRotation.w * num2;
                        forumlaNumber12 = pathRotation.w * num3;
                    }

                    Vector2 scale = GetScale(sample, path.RelativeDistances, path.SourceRelativeDistances);
                    Matrix4x4 mat = Matrix4x4.TRS(path.Positions.Array[sample], pathRotation, scale);
                    Matrix4x4 matHollow = hasHollowVolume
                        ? Matrix4x4.TRS(path.Positions.Array[sample], pathRotation, scale * (1 - HollowInset))
                        : default;

                    scalesArray[sample].x = scale.x;
                    scalesArray[sample].y = scale.y;

                    int currentCrossCount = currentCross.Count;
                    for (int c = 0; c < currentCrossCount; c++)
                    {
                        vol.Vertices.Array[vtIdx] = mat.MultiplyPoint3x4(crossPositions.Array[c]);

                        Vector3 crossNormal = crossNormals.Array[c];

                        // inlined version of  Vector3 rotatedCrossNormal = pathRotation * crossNormal;
                        float rotatedCrossNormalX = (1.0f - (forumlaNumber5 + forumlaNumber6)) * crossNormal.x + (forumlaNumber7 - forumlaNumber12) * crossNormal.y + (forumlaNumber8 + forumlaNumber11) * crossNormal.z;
                        float rotatedCrossNormalY = (forumlaNumber7 + forumlaNumber12) * crossNormal.x + (1.0f - (forumlaNumber4 + forumlaNumber6)) * crossNormal.y + (forumlaNumber9 - forumlaNumber10) * crossNormal.z;
                        float rotatedCrossNormalZ = (forumlaNumber8 - forumlaNumber11) * crossNormal.x + (forumlaNumber9 + forumlaNumber10) * crossNormal.y + (1.0f - (forumlaNumber4 + forumlaNumber5)) * crossNormal.z;

                        vol.VertexNormals.Array[vtIdx].x = rotatedCrossNormalX * crossNormalMul;
                        vol.VertexNormals.Array[vtIdx].y = rotatedCrossNormalY * crossNormalMul;
                        vol.VertexNormals.Array[vtIdx].z = rotatedCrossNormalZ * crossNormalMul;

                        if (hasHollowVolume)
                        {
                            volHollow.Vertices.Array[vtIdx] = matHollow.MultiplyPoint3x4(crossPositions.Array[c]);
                            volHollow.VertexNormals.Array[vtIdx].x = rotatedCrossNormalX * hollowNormalMul;
                            volHollow.VertexNormals.Array[vtIdx].y = rotatedCrossNormalY * hollowNormalMul;
                            volHollow.VertexNormals.Array[vtIdx].z = rotatedCrossNormalZ * hollowNormalMul;
                        }

                        vtIdx++;
                    }
                }

                switch (CrossShiftMode)
                {
                    case CrossShiftModeEnum.ByOrientation:
                        vol.CrossFShift = 0;
                        // shift CrossF to match Path Orientation
                        Vector2 hit;
                        float frag;
                        for (int i = 0; i < initialCross.Count - 1; i++)
                            if (DTMath.RayLineSegmentIntersection(vol.Positions.Array[0], vol.Normals.Array[0], vol.Vertices.Array[i], vol.Vertices.Array[i + 1], out hit, out frag))
                            {
                                vol.CrossFShift = DTMath.SnapPrecision(vol.CrossRelativeDistances.Array[i] + (vol.CrossRelativeDistances.Array[i + 1] - vol.CrossRelativeDistances.Array[i]) * frag, 2);
                                break;
                            }

                        break;
                    case CrossShiftModeEnum.Custom:
                        vol.CrossFShift = CrossShiftValue;
                        break;
                    case CrossShiftModeEnum.None:
                        vol.CrossFShift = 0;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException("CrossShiftMode");
                }

                if (volHollow != null)
                    volHollow.CrossFShift = vol.CrossFShift;

                OutVolume.SetData(vol);
                OutVolumeHollow.SetData(volHollow);

                if (isPathDisposable)
                {
                    path.Dispose();
                }

                if (isCrossesDisposable)
                {
                    crosses.ForEach(c => c.Dispose());
                }
            }
        }

        /// <summary>
        /// <see cref="ScalingModule.GetScale"/>
        /// </summary>
        [Obsolete("Use parent class ScalingModule's GetScale instead")]
        public new Vector3 GetScale(float relativeDistance)
        {
            Vector2 scaleVector = base.GetScale(relativeDistance);
            return new Vector3(scaleVector.x, scaleVector.y, 1);
        }

        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildShapeExtrusion.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildVolumeCaps.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 81201693d1fd6b04ebb00aa8dd268476
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Pools;
using ToolBuddy.Pooling.Pools;
using UnityEngine;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevTools;
using FluffyUnderware.Curvy.Utils;
using UnityEngine.Serialization;
using FluffyUnderware.Curvy.ThirdParty.LibTessDotNet;
using ToolBuddy.Pooling.Collections;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Build/Volume Caps", ModuleName = "Volume Caps", Description = "Build volume caps")]
    [HelpURL(CurvySpline.DOCLINK + "cgbuildvolumecaps")]
    public class BuildVolumeCaps : CGModule
    {

        [HideInInspector]
        [InputSlotInfo(typeof(CGVolume))]
        public CGModuleInputSlot InVolume = new CGModuleInputSlot();

        [HideInInspector]
        [InputSlotInfo(typeof(CGVolume), Optional = true, Array = true)]
        public CGModuleInputSlot InVolumeHoles = new CGModuleInputSlot();

        // change this to fit your requirements
        [HideInInspector]
        [OutputSlotInfo(typeof(CGVMesh), Array = true)]
        public CGModuleOutputSlot OutVMesh = new CGModuleOutputSlot();

        #region ### Serialized Fields ###

        [Tab("General")]
        [SerializeField]
        private CGYesNoAuto m_StartCap = CGYesNoAuto.Auto;
        [SerializeField] private CGYesNoAuto m_EndCap = CGYesNoAuto.Auto;
        [SerializeField, FormerlySerializedAs("m_ReverseNormals")]
        private bool m_ReverseTriOrder;
        [SerializeField] private bool m_GenerateUV = true;
        [SerializeField] private bool m_GenerateUV2 = true;

        [Tab("Start Cap")]
        [Inline]
        [SerializeField]
        private CGMaterialSettings m_StartMaterialSettings = new CGMaterialSettings();
        [Label("Material")]
        [SerializeField]
        private Material m_StartMaterial;
        [Tab("End Cap")]
        [SerializeField]
        private bool m_CloneStartCap = true;
        [AsGroup(Invisible = true)]
        [GroupCondition(nameof(m_CloneStartCap), false)]
        [SerializeField]
        private CGMaterialSettings m_EndMaterialSettings = new CGMaterialSettings();
        [Group("Default/End Cap")]
        [Label("Material")]
        [FieldCondition(nameof(m_CloneStartCap), false)]
        [SerializeField]
        private Material m_EndMaterial;

        #endregion

        #region ### Public Properties ###

        public bool GenerateUV
        {
            get { return m_GenerateUV; }
            set
            {
                if (m_GenerateUV != value)
                    m_GenerateUV = value;
                Dirty = true;
            }
        }
        public bool GenerateUV2
        {
            get { return m_GenerateUV2; }
            set
            {
                if (m_GenerateUV2 != value)
                    m_GenerateUV2 = value;
                Dirty = true;
            }
        }

        public bool ReverseTriOrder
        {
            get { return m_ReverseTriOrder; }
            set
            {
                if (m_ReverseTriOrder != value)
                    m_ReverseTriOrder = value;
                Dirty = true;
            }
        }

        public CGYesNoAuto StartCap
        {
            get { return m_StartCap; }
            set
            {
                if (m_StartCap != value)
                    m_StartCap = value;
                Dirty = true;
            }
        }

        public Material StartMaterial
        {
            get { return m_StartMaterial; }
            set
            {
                if (m_StartMaterial != value)
                    m_StartMaterial = value;
                Dirty = true;
            }
        }

        public CGMaterialSettings StartMaterialSettings
        {
            get { return m_StartMaterialSettings; }
        }

        public CGYesNoAuto EndCap
        {
            get { return m_EndCap; }
            set
            {
                if (m_EndCap != value)
                    m_EndCap = value;
                Dirty = true;
            }
        }

        public bool CloneStartCap
        {
            get { return m_CloneStartCap; }
            set
            {
                if (m_CloneStartCap != value)
                    m_CloneStartCap = value;
                Dirty = true;
            }
        }

        public CGMaterialSettings EndMaterialSettings
        {
            get { return m_EndMaterialSettings; }
        }

        public Material EndMaterial
        {
            get { return m_EndMaterial; }
            set
            {
                if (m_EndMaterial != value)
                    m_EndMaterial = value;
                Dirty = true;
            }
        }

        #endregion

        #region ### Private Fields & Properties ###
        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected override void Awake()
        {
            base.Awake();

            if (StartMaterial == null)
                StartMaterial = CurvyUtility.GetDefaultMaterial();
            if (EndMaterial == null)
                EndMaterial = CurvyUtility.GetDefaultMaterial();
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            GenerateUV = m_GenerateUV;
            GenerateUV2 = m_GenerateUV2;
            ReverseTriOrder = m_ReverseTriOrder;
            StartCap = m_StartCap;
            EndCap = m_EndCap;
        }
#endif

        public override void Reset()
        {
            base.Reset();
            StartCap = CGYesNoAuto.Auto;
            EndCap = CGYesNoAuto.Auto;
            ReverseTriOrder = false;
            GenerateUV = true;
            GenerateUV2 = true;
            m_StartMaterialSettings = new CGMaterialSettings();
            m_EndMaterialSettings = new CGMaterialSettings();
            StartMaterial = CurvyUtility.GetDefaultMaterial();
            EndMaterial = CurvyUtility.GetDefaultMaterial();
            CloneStartCap = true;
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public override void Refresh()
        {
            base.Refresh();
            CGVolume vol = InVolume.GetData<CGVolume>(out bool isVolumeDisposable);
            List<CGVolume> holes = InVolumeHoles.GetAllData<CGVolume>(out bool isHolesDisposable);

            if (vol)
            {
                bool genStart = (StartCap == CGYesNoAuto.Yes || (StartCap == CGYesNoAuto.Auto && !vol.Seamless));
                bool genEnd = (EndCap == CGYesNoAuto.Yes || (EndCap == CGYesNoAuto.Auto && !vol.Seamless));

                if (!genStart && !genEnd)
                {
                    OutVMesh.SetData(null);
                    return;
                }

                CGVMesh vmesh = new CGVMesh();
                SubArray<Vector3> vtStart = ArrayPools.Vector3.Allocate(0);

                vmesh.AddSubMesh(new CGVSubMesh());
                CGVSubMesh submesh = vmesh.SubMeshes[0];

                if (genStart)
                {
                    #region --- Start Cap ---

                    Tess tess = new Tess();
                    tess.UsePooling = true;
                    tess.AddContour(make2DSegment(vol, 0));

                    for (int h = 0; h < holes.Count; h++)
                    {
                        if (holes[h].Count < 3)
                        {
                            OutVMesh.SetData(null);
                            UIMessages.Add("Hole Cross has less than 3 Vertices: Can't create Caps!");
                            return;
                        }
                        tess.AddContour(make2DSegment(holes[h], 0));
                    }
                    tess.Tessellate(WindingRule.EvenOdd, ElementType.Polygons, 3);
                    ArrayPools.Vector3.Free(vtStart);
                    vtStart = UnityLibTessUtility.ContourVerticesToPositions(tess.Vertices);
                    Bounds b;
                    int capIndex = 0;
                    vmesh.Vertices = applyMatrix(vtStart, getMatrix(vol, capIndex, true), out b);
                    //normals
                    {
                        SubArray<Vector3> normals = ArrayPools.Vector3.Allocate(vmesh.Vertices.Count);
                        {
                            Vector3 capNormal = -vol.Directions.Array[capIndex];
                            for (int i = 0; i < normals.Count; i++)
                                normals.Array[i] = capNormal;
                        }

                        vmesh.NormalsList = normals;
                    }

                    submesh.Material = StartMaterial;
                    submesh.TrianglesList = tess.ElementsArray.Value;
                    if (ReverseTriOrder)
                        flipTris(submesh.TrianglesList, 0, submesh.TrianglesList.Count);
                    if (GenerateUV)
                    {
                        vmesh.UVs = ArrayPools.Vector2.Allocate(vtStart.Count);
                        applyUV(vtStart, vmesh.UVs, 0, vtStart.Count, StartMaterialSettings, b);
                    }

                    if (GenerateUV2)
                    {
                        vmesh.UV2s = ArrayPools.Vector2.Allocate(vtStart.Count);
                        applyUV2(vtStart, vmesh.UV2s, 0, vtStart.Count, b);
                    }
                    #endregion
                }

                if (genEnd)
                {
                    #region --- End Cap ---

                    Tess tess = new Tess();
                    tess.UsePooling = true;
                    tess.AddContour(make2DSegment(vol, vol.Count - 1));

                    for (int h = 0; h < holes.Count; h++)
                    {
                        if (holes[h].Count < 3)
                        {
                            OutVMesh.SetData(null);
                            UIMessages.Add("Hole Cross has <3 Vertices: Can't create Caps!");
                            return;
                        }
                        tess.AddContour(make2DSegment(holes[h], holes[h].Count - 1));
                    }
                    tess.Tessellate(WindingRule.EvenOdd, ElementType.Polygons, 3);

                    SubArray<Vector3> vtEnd = UnityLibTessUtility.ContourVerticesToPositions(tess.Vertices);
                    Bounds b;
                    int preEndCapVertexLength = vmesh.Vertices.Count;
                    int capIndex = vol.Count - 1;
                    SubArray<Vector3> subVertices = applyMatrix(
                        vtEnd,
                        getMatrix(vol, capIndex, true), out b);

                    SubArray<Vector3> newVertices;
                    {
                        newVertices = ArrayPools.Vector3.Allocate(vmesh.Vertices.Count + subVertices.Count);
                        Array.Copy(vmesh.Vertices.Array, 0, newVertices.Array, 0, vmesh.Vertices.Count);
                        Array.Copy(subVertices.Array, 0, newVertices.Array, vmesh.Vertices.Count, subVertices.Count);
                    }

                    vmesh.Vertices = newVertices;

                    ArrayPools.Vector3.Free(subVertices);

                    //normals
                    {
                        SubArray<Vector3> normals = ArrayPools.Vector3.Allocate(preEndCapVertexLength);
                        {
                            Vector3 capNormal = vol.Directions.Array[capIndex];
                            for (int i = 0; i < normals.Count; i++)
                                normals.Array[i] = capNormal;
                        }

                        SubArray<Vector3> newNormals;
                        {
                            newNormals = ArrayPools.Vector3.Allocate(vmesh.NormalsList.Count + normals.Count);
                            Array.Copy(vmesh.NormalsList.Array, 0, newNormals.Array, 0, vmesh.NormalsList.Count);
                            Array.Copy(normals.Array, 0, newNormals.Array, vmesh.NormalsList.Count, normals.Count);
                        }
                        vmesh.NormalsList = newNormals;

                        ArrayPools.Vector3.Free(normals);
                    }
                    SubArray<int> tris = tess.ElementsArray.Value;
                    if (!ReverseTriOrder)
                        flipTris(tris, 0, tris.Count);
                    for (int i = 0; i < tris.Count; i++)
                        tris.Array[i] += preEndCapVertexLength;
                    if (!CloneStartCap && StartMaterial != EndMaterial)
                    {
                        vmesh.AddSubMesh(new CGVSubMesh(tris, EndMaterial));
                    }
                    else
                    {
                        submesh.Material = StartMaterial;

                        SubArray<int> newTrianglesList;
                        {
                            newTrianglesList = ArrayPools.Int32.Allocate(submesh.TrianglesList.Count + tris.Count);
                            Array.Copy(submesh.TrianglesList.Array, 0, newTrianglesList.Array, 0, submesh.TrianglesList.Count);
                            Array.Copy(tris.Array, 0, newTrianglesList.Array, submesh.TrianglesList.Count, tris.Count);
                        }
                        submesh.TrianglesList = newTrianglesList;
                    }

                    if (GenerateUV)
                    {
                        SubArray<Vector2> newUVs = ArrayPools.Vector2.Allocate(vmesh.UVs.Count + vtEnd.Count);
                        Array.Copy(vmesh.UVs.Array, 0, newUVs.Array, 0, vmesh.UVs.Count);
                        vmesh.UVs = newUVs;

                        applyUV(vtEnd, vmesh.UVs, vtStart.Count, vtEnd.Count, (CloneStartCap) ? StartMaterialSettings : EndMaterialSettings, b);
                    }

                    if (GenerateUV2)
                    {
                        SubArray<Vector2> newUV2s = ArrayPools.Vector2.Allocate(vmesh.UV2s.Count + vtEnd.Count);
                        Array.Copy(vmesh.UV2s.Array, 0, newUV2s.Array, 0, vmesh.UV2s.Count);
                        vmesh.UV2s = newUV2s;
                        applyUV2(vtEnd, vmesh.UV2s, vtStart.Count, vtEnd.Count, b);
                    }

                    ArrayPools.Vector3.Free(vtEnd);

                    #endregion
                }

                ArrayPools.Vector3.Free(vtStart);

                OutVMesh.SetData(vmesh);
            }

            if (isVolumeDisposable)
                vol.Dispose();

            if (isHolesDisposable)
                holes.ForEach(h => h.Dispose());
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */

        private static Matrix4x4 getMatrix(CGVolume vol, int index, bool inverse)
        {
            if (inverse)
            {
                Quaternion Q = Quaternion.LookRotation(vol.Directions.Array[index], vol.Normals.Array[index]);
                return Matrix4x4.TRS(vol.Positions.Array[index], Q, Vector3.one);
            }
            else
            {
                Quaternion Q = Quaternion.Inverse(Quaternion.LookRotation(vol.Directions.Array[index], vol.Normals.Array[index]));
                return Matrix4x4.TRS(-(Q * vol.Positions.Array[index]), Q, Vector3.one);
            }
        }


        private static void flipTris(SubArray<int> indices, int start, int end)
        {
            int tmp;
            for (int i = start; i < end; i += 3)
            {
                tmp = indices.Array[i];
                indices.Array[i] = indices.Array[i + 2];
                indices.Array[i + 2] = tmp;
            }
        }

        private static SubArray<Vector3> applyMatrix(SubArray<Vector3> vt, Matrix4x4 matrix, out Bounds bounds)
        {
            SubArray<Vector3> res = ArrayPools.Vector3.Allocate(vt.Count);
            float lx = float.MaxValue;
            float ly = float.MaxValue;
            float hx = float.MinValue;
            float hy = float.MinValue;

            for (int i = 0; i < vt.Count; i++)
            {
                lx = Mathf.Min(vt.Array[i].x, lx);
                ly = Mathf.Min(vt.Array[i].y, ly);
                hx = Mathf.Max(vt.Array[i].x, hx);
                hy = Mathf.Max(vt.Array[i].y, hy);
                res.Array[i] = matrix.MultiplyPoint3x4(vt.Array[i]);
            }
            Vector3 sz = new Vector3(Mathf.Abs(hx - lx), Mathf.Abs(hy - ly));
            bounds = new Bounds(new Vector3(lx + sz.x / 2, ly + sz.y / 2, 0), sz);
            return res;
        }



        /// <summary>
        /// trs vertices to eliminate Z and eliminate duplicates
        /// </summary>
        private static ContourVertex[] make2DSegment(CGVolume vol, int segmentIndex)
        {
            Matrix4x4 m = getMatrix(vol, segmentIndex, false);
            int vertexIndex = vol.GetSegmentIndex(segmentIndex);

            ContourVertex[] res = new ContourVertex[vol.CrossSize];
            for (int i = 0; i < vol.CrossSize; i++)
                res[i] = m.MultiplyPoint3x4(vol.Vertices.Array[vertexIndex + i]).ContourVertex();

            return res;
        }

        // Attention: p needs to be 2D (X/Y-Plane)
        private static void applyUV(SubArray<Vector3> vts, SubArray<Vector2> uvArray, int index, int count, CGMaterialSettings mat, Bounds bounds)
        {
            float u, v;
            float w = bounds.size.x;
            float h = bounds.size.y;

            float mx = bounds.min.x;
            float my = bounds.min.y;

            float fx = mat.UVScale.x;
            float fy = mat.UVScale.y;

            switch (mat.KeepAspect)
            {
                case CGKeepAspectMode.ScaleU:
                    float sw = w * mat.UVScale.y;
                    float sh = h * mat.UVScale.x;
                    fx *= sw / sh;
                    break;
                case CGKeepAspectMode.ScaleV:
                    float sw1 = w * mat.UVScale.y;
                    float sh1 = h * mat.UVScale.x;
                    fy *= sh1 / sw1;
                    break;
            }

            bool swapUv = mat.SwapUV;

            if (mat.UVRotation != 0)
            {
                float uvRotRad = (mat.UVRotation) * Mathf.Deg2Rad;
                float sn = Mathf.Sin(uvRotRad);
                float cs = Mathf.Cos(uvRotRad);
                float ox, oy;
                float fx2 = fx * 0.5f;
                float fy2 = fy * 0.5f;
                for (int i = 0; i < count; i++)
                {
                    u = (vts.Array[i].x - mx) / w * fx;
                    v = (vts.Array[i].y - my) / h * fy;
                    ox = u - fx2;
                    oy = v - fy2;
                    u = (cs * ox - sn * oy + fx2) + mat.UVOffset.x;
                    v = (sn * ox + cs * oy + fy2) + mat.UVOffset.y;

                    int uvArrayIndex = i + index;
                    Vector2 uv;
                    uv.x = swapUv ? v : u;
                    uv.y = swapUv ? u : v;
                    uvArray.Array[uvArrayIndex] = uv;

                }
            }
            else
            {
                for (int i = 0; i < count; i++)
                {
                    u = mat.UVOffset.x + (vts.Array[i].x - mx) / w * fx;
                    v = mat.UVOffset.y + (vts.Array[i].y - my) / h * fy;
                    int uvArrayIndex = i + index;
                    Vector2 uv;
                    uv.x = swapUv ? v : u;
                    uv.y = swapUv ? u : v;
                    uvArray.Array[uvArrayIndex] = uv;
                }
            }
        }

        private static void applyUV2(SubArray<Vector3> vertice, SubArray<Vector2> uv2Array, int index, int count, Bounds bounds)
        {

            float inverseW = 1 / bounds.size.x;
            float inverseH = 1 / bounds.size.y;

            float mx = bounds.min.x;
            float my = bounds.min.y;

            for (int i = 0; i < count; i++)
            {
                Vector2 uv;
                uv.x = (vertice.Array[i].x - mx) * inverseW;
                uv.y = (vertice.Array[i].y - my) * inverseH;
                uv2Array.Array[i + index] = uv;
            }
        }


        /*! \endcond */
        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildVolumeCaps.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildVolumeMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 379291f9fb9edce4d9c19b219feb999b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Pools;
using ToolBuddy.Pooling.Pools;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.DevTools;
using FluffyUnderware.Curvy.Utils;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;
using UnityEngine.Serialization;


namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Build/Volume Mesh", ModuleName = "Volume Mesh", Description = "Build a volume mesh")]
    [HelpURL(CurvySpline.DOCLINK + "cgbuildvolumemesh")]
    public class BuildVolumeMesh : CGModule
    {


        [HideInInspector]
        [InputSlotInfo(typeof(CGVolume))]
        public CGModuleInputSlot InVolume = new CGModuleInputSlot();

        [HideInInspector]
        [OutputSlotInfo(typeof(CGVMesh), Array = true)]
        public CGModuleOutputSlot OutVMesh = new CGModuleOutputSlot();

        #region ### Serialized Fields ###

        [Tab("General")]

        [FieldAction("CBAddMaterial")]
        [SerializeField, FormerlySerializedAs("m_ReverseNormals")]
        private bool m_ReverseTriOrder;

        [Section("Default/General/UV")]

        [SerializeField]
        private bool m_GenerateUV = true;

        [SerializeField]
        [Tooltip("When set to true, and if the input Shape Extrusion module is set to apply scaling, the U coordinate of the generated mesh will be modified to compensate that scaling.\nOnly the X component of the scaling is taken into consideration.\nThe unscaling works best on volumes with flat shapes.")]
        [FieldCondition(nameof(m_GenerateUV), true)]
        private bool unscaleU = false;

        [SerializeField]
        [FieldCondition(nameof(unscaleU), true, false, ConditionalAttribute.OperatorEnum.AND, nameof(m_GenerateUV), true, false)]
        [Tooltip("When unscaling the U coordinate, this field defines what is the scaling origin.\n0.5 gives usually the best results, but you might need to set it to a different value, usually between 0 and 1")]
        private float unscalingOrigin = 0.5f;

        [SerializeField] private bool m_GenerateUV2 = true;

        [Section("Default/General/Split")]

        [Tooltip("Split the mesh into submeshes")]
        [SerializeField]
        private bool m_Split;

        [Positive(MinValue = 1)]
        [FieldCondition(nameof(m_Split), true)]
        [SerializeField]
        private float m_SplitLength = 100;

        [Group("Default/General/Backward Compatibility", Expanded = false)]
        [Tooltip("Is ignored when Split or Generate UV2 is false.\nIf enabled, UV2s of a split mesh will be computed as in Curvy versions prior to 8.0.0, which had a bug: all the split submeshes used the full range of UV2 coordinates, instead of keeping the same UV2s from the unsplit mesh.")]
        [FieldCondition(nameof(IsSplitUV2Togglable), true, false, ActionAttribute.ActionEnum.Enable)]
        [SerializeField]
        private bool splitUV2 = false;

        // SubMesh-Settings

        [SerializeField, HideInInspector] private List<CGMaterialSettingsEx> m_MaterialSettings = new List<CGMaterialSettingsEx>();

        [SerializeField, HideInInspector] private Material[] m_Material = new Material[0];

        #endregion

        #region ### Public Properties ###

        public bool GenerateUV
        {
            get { return m_GenerateUV; }
            set
            {
                if (m_GenerateUV != value)
                    m_GenerateUV = value;
                Dirty = true;
            }
        }
        
        public bool GenerateUV2
        {
            get { return m_GenerateUV2; }
            set
            {
                if (m_GenerateUV2 != value)
                    m_GenerateUV2 = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// When set to true, and if the input Shape Extrusion module is set to apply scaling, the U coordinate of the generated mesh will be modified to compensate that scaling.
        /// Only the X component of the scaling is taken into consideration.
        /// The unscaling works best on volumes with flat shapes.
        /// </summary>
        public bool UnscaleU
        {
            get { return unscaleU; }
            set
            {
                if (unscaleU != value)
                    unscaleU = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// When unscaling the U coordinate, this field defines what is the scaling origin.
        /// 0.5 gives usually the best results, but you might need to set it to a different value, usually between 0 and 1
        /// </summary>
        public float UnscalingOrigin
        {
            get { return unscalingOrigin; }
            set
            {
                if (unscalingOrigin != value)
                    unscalingOrigin = value;
                Dirty = true;
            }
        }

        public bool ReverseTriOrder
        {
            get { return m_ReverseTriOrder; }
            set
            {
                if (m_ReverseTriOrder != value)
                    m_ReverseTriOrder = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// Split the mesh into submeshes
        /// </summary>
        public bool Split
        {
            get { return m_Split; }
            set
            {
                if (m_Split != value)
                    m_Split = value;
                Dirty = true;
            }
        }

        public float SplitLength
        {
            get { return m_SplitLength; }
            set
            {
                float v = Mathf.Max(1, value);
                if (m_SplitLength != v)
                    m_SplitLength = v;
                Dirty = true;
            }
        }

        /// <summary>
        /// For backward compatibility only.
        /// Is ignored when Split or Generate UV2 is false.
        /// If enabled, UV2s of a split mesh will be computed as in Curvy versions prior to 8.0.0, which had a bug: all the split submeshes used the full range of UV2 coordinates, instead of keeping the same UV2s from the unsplit mesh.
        /// </summary>
        public bool SplitUV2
        {
            get { return splitUV2; }
            set
            {
                if (splitUV2 != value)
                    splitUV2 = value;
                Dirty = true;
            }
        }

        [System.Obsolete("Use MaterialSettings (with the correct number of Ts) instead")]
        public List<CGMaterialSettingsEx> MaterialSetttings
        {
            get { return MaterialSettings; }
        }

        public List<CGMaterialSettingsEx> MaterialSettings
        {
            get { return m_MaterialSettings; }
        }

        public int MaterialCount
        {
            get { return m_MaterialSettings.Count; }
        }

        #endregion

        #region ### Private Fields & Properties ###

        private List<SamplePointsMaterialGroupCollection> groupsByMatID;

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected override void Awake()
        {
            base.Awake();
            if (MaterialCount == 0)
                AddMaterial();
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            GenerateUV = m_GenerateUV;
            GenerateUV2 = m_GenerateUV2;
            UnscaleU = unscaleU;
            UnscalingOrigin = unscalingOrigin;
            SplitUV2 = splitUV2;
            ReverseTriOrder = m_ReverseTriOrder;
        }
#endif

        public override void Reset()
        {
            base.Reset();
            GenerateUV = true;
            GenerateUV2 = true;
            UnscaleU = false;
            UnscalingOrigin = 0.5f;
            Split = false;
            SplitLength = 100;
            SplitUV2 = false;
            ReverseTriOrder = false;
            m_MaterialSettings = new List<CGMaterialSettingsEx>(new CGMaterialSettingsEx[1] { new CGMaterialSettingsEx() });
            m_Material = new Material[1] { CurvyUtility.GetDefaultMaterial() };
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public override void Refresh()
        {
            base.Refresh();
            CGVolume vol = InVolume.GetData<CGVolume>(out bool isDisposable);

            if (vol && vol.Count > 0 && vol.CrossSize > 0 && vol.CrossMaterialGroups.Count > 0)
            {
                List<IntRegion> volSets = new List<IntRegion>();
                if (Split)
                {

                    float dist;
                    float lastdist = 0;
                    int lastIndex = 0;
                    for (int sample = 0; sample < vol.Count; sample++)
                    {
                        /*OPTIM F here, contrary to splines, is proportional to distance. So instead of working with distances, which means a call to vol.FToDistance at each iteration, just work with Fs
                         After some tests, this optimization is really not important for now. Maybe in the future, when other parts will be optimized, it would be worth doing
                         */
                        dist = vol.FToDistance(vol.RelativeDistances.Array[sample]);
                        if (dist - lastdist >= SplitLength)
                        {
                            volSets.Add(new IntRegion(lastIndex, sample));
                            lastdist = dist;
                            lastIndex = sample;
                        }
                    }
                    if (lastIndex < vol.Count - 1)
                        volSets.Add(new IntRegion(lastIndex, vol.Count - 1));

                }
                else
                    volSets.Add(new IntRegion(0, vol.Count - 1));

                CGVMesh[] data = OutVMesh.GetAllData<CGVMesh>();
                System.Array.Resize(ref data, volSets.Count);

                prepare(vol);
                for (int sub = 0; sub < volSets.Count; sub++)
                {
                    data[sub] = CGVMesh.Get(data[sub], vol, volSets[sub], GenerateUV, GenerateUV2, ReverseTriOrder);
                    build(data[sub], vol, volSets[sub]);
                }

                OutVMesh.SetData(data);
            }
            else
                OutVMesh.SetData(null);

            if (isDisposable)
                vol.Dispose();

        }

        public int AddMaterial()
        {
            m_MaterialSettings.Add(new CGMaterialSettingsEx());
            m_Material = m_Material.Add(CurvyUtility.GetDefaultMaterial());
            Dirty = true;
            return MaterialCount;
        }

        public void RemoveMaterial(int index)
        {
            if (!validateMaterialIndex(index))
                return;
            m_MaterialSettings.RemoveAt(index);
            m_Material = m_Material.RemoveAt(index);
            Dirty = true;
        }

        public void SetMaterial(int index, Material mat)
        {
            if (!validateMaterialIndex(index) || mat == m_Material[index])
                return;
            if (m_Material[index] != mat)
            {
#if UNITY_EDITOR
                UnityEditor.Undo.RegisterCompleteObjectUndo(this, "Set Material");
#endif
                m_Material[index] = mat;
                Dirty = true;
            }
        }

        public Material GetMaterial(int index)
        {
            if (!validateMaterialIndex(index))
                return null;
            return m_Material[index];
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */

        private void prepare(CGVolume vol)
        {
            // We have groups (different MaterialID) of patches (e.g. by Hard Edges).
            // Create Collection of groups sharing the same material ID
            groupsByMatID = getMaterialIDGroups(vol);
        }

        private void build(CGVMesh vmesh, CGVolume vol, IntRegion subset)
        {

            // Because each Material ID forms a submesh
            // Do we need to calculate localU?

#if CURVY_SANITY_CHECKS
            UnityEngine.Assertions.Assert.IsTrue(GenerateUV == false || vmesh.UVs.Count == vmesh.Vertices.Count);
            UnityEngine.Assertions.Assert.IsTrue(GenerateUV2 == false || vmesh.UV2s.Count == vmesh.Vertices.Count);
#endif

            // Prepare Submeshes
            prepareSubMeshes(vmesh, groupsByMatID, subset.Length, ref m_Material);
            //prepareSubMeshes(vmesh, groupsByMatID, vol.Count - 1, ref m_Material);

            SamplePointsMaterialGroupCollection col;
            SamplePointsMaterialGroup grp;

            int vtIdx = 0;
            var triIdx = ArrayPools.Int32.Allocate(groupsByMatID.Count); // triIdx for each submesh
            // for all sample segments (except the last) along the path, create Triangles to the next segment 
            for (int sample = subset.From; sample < subset.To; sample++)
            {
                // for each submesh (collection)
                for (int subMeshIdx = 0; subMeshIdx < groupsByMatID.Count; subMeshIdx++)
                {
                    col = groupsByMatID[subMeshIdx];
                    // create UV and triangles for all groups in submesh
                    for (int g = 0; g < col.Count; g++)
                    {
                        grp = col[g];
                        if (GenerateUV)
                            createMaterialGroupUV(vmesh, vol, grp, col.MaterialID, col.AspectCorrectionV, col.AspectCorrectionU, sample, vtIdx);

                        if (GenerateUV2)
                            createMaterialGroupUV2(vmesh, vol, grp, sample, vtIdx);
                        for (int p = 0; p < grp.Patches.Count; p++)
                            createPatchTriangles(vmesh.SubMeshes[subMeshIdx].TrianglesList.Array, ref triIdx.Array[subMeshIdx], vtIdx + grp.Patches[p].Start, grp.Patches[p].Count, vol.CrossSize, ReverseTriOrder);
                    }
                }
                vtIdx += vol.CrossSize;
            }

            // UV && UV2 for last path segment
            // for each submesh (collection)
            for (int subMeshIdx = 0; subMeshIdx < groupsByMatID.Count; subMeshIdx++)
            {
                col = groupsByMatID[subMeshIdx];
                // create triangles
                for (int g = 0; g < col.Count; g++)
                {
                    grp = col[g];
                    if (GenerateUV)
                        createMaterialGroupUV(vmesh, vol, grp, col.MaterialID, col.AspectCorrectionV, col.AspectCorrectionU, subset.To, vtIdx);

                    if (GenerateUV2)
                        createMaterialGroupUV2(vmesh, vol, grp, subset.To, vtIdx);

                }
            }

            ArrayPools.Int32.Free(triIdx);

            //normalize UV2's V coordinate
            if (Split && GenerateUV2 && SplitUV2)
            {
                var uv2sArray = vmesh.UV2s.Array;

                float minV = uv2sArray[0].y;
                float maxV = uv2sArray[vmesh.UV2s.Count - 1].y;

#if CURVY_SANITY_CHECKS_PRIVATE
                {
                    //Checks the assumption used in finding max an min V values
                    float minVTest = float.MaxValue;
                    float maxVTest = 0;
                    for (int i = 0; i < vmesh.UV2s.Count; i++)
                    {
                        minVTest = Mathf.Min(minVTest, uv2sArray[i].y);
                        maxVTest = Mathf.Max(maxVTest, uv2sArray[i].y);
                    }
                    Assert.IsTrue(maxVTest.Approximately(maxV));
                    Assert.IsTrue(minVTest.Approximately(minV));
                }
#endif

                float vCorrection = 1f / (maxV - minV);
                for (int i = 0; i < vmesh.UV2s.Count; i++)
                    uv2sArray[i].y = (uv2sArray[i].y - minV) * vCorrection;
            }
        }

        private static void prepareSubMeshes(CGVMesh vmesh, List<SamplePointsMaterialGroupCollection> groupsBySubMeshes, int extrusions, ref Material[] materials)
        {
            vmesh.SetSubMeshCount(groupsBySubMeshes.Count);
            for (int g = 0; g < groupsBySubMeshes.Count; g++)
            {
                CGVSubMesh sm = vmesh.SubMeshes[g];
                vmesh.SubMeshes[g] = CGVSubMesh.Get(sm, groupsBySubMeshes[g].TriangleCount * extrusions * 3, materials[Mathf.Min(groupsBySubMeshes[g].MaterialID, materials.Length - 1)]);
            }
        }

        // OPTIMIZE: Store array of U values and just copy them
        private void createMaterialGroupUV(CGVMesh vmesh, CGVolume volume, SamplePointsMaterialGroup materialGroup, int matIndex, float aspectCorrectionV, float aspectCorrectionU, int sample, int baseVertex)
        {
            CGMaterialSettingsEx mat = m_MaterialSettings[matIndex];
            int hi = materialGroup.EndVertex;
            bool swapUV = mat.SwapUV;
            Vector2[] uvsArray = vmesh.UVs.Array;
            float[] crossCustomValues = volume.CrossCustomValues.Array;

            float uMultiplier;
            {
                uMultiplier = mat.UVScale.x * aspectCorrectionU;
                if (UnscaleU)
                    uMultiplier *= volume.Scales.Array[sample].x;
            }

            float v = mat.UVOffset.y + volume.RelativeDistances.Array[sample] * mat.UVScale.y * aspectCorrectionV;

            for (int c = materialGroup.StartVertex; c <= hi; c++)
            {
                float u = UnscaleU
                    ? mat.UVOffset.x + unscalingOrigin + (crossCustomValues[c] - unscalingOrigin) * uMultiplier
                    : mat.UVOffset.x + crossCustomValues[c] * uMultiplier;
                uvsArray[baseVertex + c].x = swapUV ? v : u;
                uvsArray[baseVertex + c].y = swapUV ? u : v;
            }
        }

        private void createMaterialGroupUV2(CGVMesh vmesh, CGVolume volume, SamplePointsMaterialGroup materialGroup, int sample, int baseVertex)
        {
            int hi = materialGroup.EndVertex;
            Vector2[] uv2sArray = vmesh.UV2s.Array;
            for (int c = materialGroup.StartVertex; c <= hi; c++)
            {
                uv2sArray[baseVertex + c].x = volume.CrossRelativeDistances.Array[c];
                uv2sArray[baseVertex + c].y = volume.RelativeDistances.Array[sample];
            }
        }

        /// <summary>
        /// Creates triangles for a cross section
        /// </summary>
        /// <param name="triangles">the triangle array</param>
        /// <param name="triIdx">current tri index</param>
        /// <param name="curVTIndex">base vertex index of this cross section (i.e. the first vertex)</param>
        /// <param name="patchSize"></param>
        /// <param name="crossSize">number of vertices per cross section</param>
        /// <param name="reverse">whether triangles should flip (i.e. a reversed triangle order should be used)</param>
        /// <param name="patchEndVT">size of the cross group (i.e. number of sample points to connect)</param>
        /// <returns></returns>
        private static void createPatchTriangles(int[] triangles, ref int triIdx, int curVTIndex, int patchSize, int crossSize, bool reverse)
        {
            int rv0 = (reverse) ? 1 : 0; // flipping +0 and +1 when reversing
            int rv1 = 1 - rv0;
            int nextCrossVT = curVTIndex + crossSize;
            for (int vt = 0; vt < patchSize; vt++)
            {
                triangles[triIdx + rv0] = curVTIndex + vt;
                triangles[triIdx + rv1] = nextCrossVT + vt;
                triangles[triIdx + 2] = curVTIndex + vt + 1;
                triangles[triIdx + rv0 + 3] = curVTIndex + vt + 1;
                triangles[triIdx + rv1 + 3] = nextCrossVT + vt;
                triangles[triIdx + 5] = nextCrossVT + vt + 1;
                triIdx += 6;
            }
        }

        /// <summary>
        /// Create collections of groups sharing same Material ID. Also ensures collection's MaterialID is valid!
        /// </summary>
        /// <param name="groups"></param>
        /// <returns></returns>
        private List<SamplePointsMaterialGroupCollection> getMaterialIDGroups(CGVolume volume)
        {

            Dictionary<int, SamplePointsMaterialGroupCollection> matCollections = new Dictionary<int, SamplePointsMaterialGroupCollection>();

            SamplePointsMaterialGroupCollection col;

            for (int g = 0; g < volume.CrossMaterialGroups.Count; g++)
            {
                int materialID;
                if (volume.CrossMaterialGroups[g].MaterialID <= MaterialCount - 1)
                    materialID = volume.CrossMaterialGroups[g].MaterialID;
                else
                {
                    UIMessages.Add($"Input Volume is using material id {volume.CrossMaterialGroups[g].MaterialID}, which has no associate Material in this module. Use the 'Add Material Group'");
                    materialID = MaterialCount - 1;
                }

                if (!matCollections.TryGetValue(materialID, out col))
                {
                    col = new SamplePointsMaterialGroupCollection();
                    col.MaterialID = materialID;
                    matCollections.Add(materialID, col);
                }
                col.Add(volume.CrossMaterialGroups[g]);
            }

            List<SamplePointsMaterialGroupCollection> res = new List<SamplePointsMaterialGroupCollection>();

            foreach (SamplePointsMaterialGroupCollection item in matCollections.Values)
            {
                item.CalculateAspectCorrection(volume, MaterialSettings[item.MaterialID]);
                res.Add(item);
            }
            return res;

        }

        private bool validateMaterialIndex(int index)
        {
            if (index < 0 || index >= m_MaterialSettings.Count)
            {
                Debug.LogError("TriangulateTube: Invalid Material Index!");
                return false;
            }
            return true;
        }

        private bool IsSplitUV2Togglable => Split && GenerateUV2;


        /*! \endcond */
        #endregion






    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildVolumeMesh.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildVolumeSpots.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ca7e92a8a4be4584da4f4e7d14a02b16
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.Curvy.Pools;
using ToolBuddy.Pooling.Pools;
using FluffyUnderware.Curvy.Utils;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;
using Random = UnityEngine.Random;


namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Build/Volume Spots", ModuleName = "Volume Spots", Description = "Generate spots along a path/volume", UsesRandom = true)]
    [HelpURL(CurvySpline.DOCLINK + "cgvolumespots")]
    public class BuildVolumeSpots : CGModule, ISerializationCallbackReceiver
    {
        public BuildVolumeSpots()
        {
            Version = "1";
        }

        [HideInInspector]
        [InputSlotInfo(typeof(CGPath), Name = "Path/Volume", DisplayName = "Volume/Rasterized Path")]
        public CGModuleInputSlot InPath = new CGModuleInputSlot();

        [HideInInspector]
        [InputSlotInfo(typeof(CGBounds), Array = true)]
        public CGModuleInputSlot InBounds = new CGModuleInputSlot();

        [HideInInspector]
        [OutputSlotInfo(typeof(CGSpots))]
        public CGModuleOutputSlot OutSpots = new CGModuleOutputSlot();

        #region ### Serialized Fields ###

        [SerializeField, HideInInspector]
#pragma warning disable 414
        private bool m_WasUpgraded;
#pragma warning restore 414

        [Tab("General")]

        [Section("Default/General/Volume Path")]
        [FloatRegion(RegionOptionsPropertyName = nameof(RangeOptions), Precision = 4)]
        [SerializeField]
        private FloatRegion m_Range = FloatRegion.ZeroOne;

        [Section("Default/General/Volume Cross")]
        [Tooltip("When the source is a Volume, you can choose if you want to use it's path or the volume")]
        [FieldCondition(nameof(isInputAVolume), false, true)]
        [SerializeField]
        [Label("Use Volume's Surface")]
        private bool m_UseVolume = true;
        [SerializeField]
        [RangeEx(-1, 1)]
        [Tooltip("Shifts the Cross origin value by constant value")]
        private float m_CrossBase;
        [SerializeField]
        [Label("Cross Base Variation")]
        [Tooltip("Shifts the Cross origin value by a value that varies along the Volume's length. The Curve's X axis has values between 0 (start of the Range) and 1 (its end)")]
        private AnimationCurve m_CrossCurve = AnimationCurve.Linear(0, 0, 1, 0);

        [Section("Default/General/Advanced Settings", false)]
        [Tooltip("Check to run a dry run without actually creating spots")]
        [SerializeField]
        private bool m_Simulate;

        [SerializeField]
        [Tooltip("Until version 6.3.1, this module had a bug in the computation of the randomized values. Enable this value to keep that bugged behaviour if your project depends on it")]
        private bool m_UseBuggedRNG;

        [Tab("Groups")]
        [ArrayEx(Space = 10)]
        [SerializeField]
        private List<CGBoundsGroup> m_Groups = new List<CGBoundsGroup>();

        [IntRegion(UseSlider = false, RegionOptionsPropertyName = nameof(RepeatingGroupsOptions), Options = AttributeOptionsFlags.Compact)]
        [SerializeField]
        [Tooltip("The range of groups that will be placed repetitively along the volume. Groups that are not in this range will be placed only once")]
        private IntRegion m_RepeatingGroups;
        [SerializeField] private CurvyRepeatingOrderEnum m_RepeatingOrder = CurvyRepeatingOrderEnum.Row;

        [SerializeField]
        [FieldCondition(nameof(ShowFitEnd), true)]
        [Label("Fits The End")]
        [Tooltip("If checked, the last non repeating group is placed exactly at the end of the volume used for spots. If not, the last group is placed at the first available spot, which might leave some space between it and the end of the volume")]
        private bool m_FitEnd;

        #endregion

        #region ### Public Properties ###

        #region - General Tab -

        public FloatRegion Range
        {
            get { return m_Range; }
            set
            {
                if (m_Range != value)
                    m_Range = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// If the source is a Volume you can choose if you want to use it's path or the volume
        /// </summary>
        public bool UseVolume
        {
            get { return m_UseVolume; }
            set
            {
                if (m_UseVolume != value)
                    m_UseVolume = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// Set to true to dry run without actually creating spots
        /// </summary>
        public bool Simulate
        {
            get { return m_Simulate; }
            set
            {
                if (m_Simulate != value)
                    m_Simulate = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// Until version 6.3.1, this module had a bug in the computation of the randomized values. Set this to true to keep that bugged behaviour if your project depends on it
        /// </summary>
        public bool UseBuggedRng
        {
            get { return m_UseBuggedRNG; }
            set
            {
                if (m_UseBuggedRNG != value)
                    m_UseBuggedRNG = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// Shifts the Cross origin value by a constant value
        /// </summary>
        public float CrossBase
        {
            get { return m_CrossBase; }
            set
            {
                float v = Mathf.Repeat(value, 1);
                if (m_CrossBase != v)
                    m_CrossBase = v;
                Dirty = true;
            }
        }

        /// <summary>
        /// Shifts the Cross origin value by a value that varies along the Volume's length. The Curve's X axis has values between 0 (start of the <seealso cref="Range"/>) and 1 (its end)
        /// </summary>
        public AnimationCurve CrossCurve
        {
            get { return m_CrossCurve; }
            set
            {
                if (m_CrossCurve != value)
                    m_CrossCurve = value;
                Dirty = true;
            }
        }


        #endregion

        public List<CGBoundsGroup> Groups
        {
            get { return m_Groups; }
            set
            {
                if (m_Groups != value)
                    m_Groups = value;
            }
        }

        public CurvyRepeatingOrderEnum RepeatingOrder
        {
            get { return m_RepeatingOrder; }
            set
            {
                if (m_RepeatingOrder != value)
                    m_RepeatingOrder = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// First index of the range of groups that will be placed repetitively along the volume. Groups that are not in this range will be placed only once
        /// </summary>
        public int FirstRepeating
        {
            get { return m_RepeatingGroups.From; }
            set
            {
                int v = Mathf.Clamp(value, 0, Mathf.Max(0, GroupCount - 1));
                if (m_RepeatingGroups.From != v)
                    m_RepeatingGroups.From = v;

                Dirty = true;
            }
        }

        /// <summary>
        /// Last index of the range of groups that will be placed repetitively along the volume. Groups that are not in this range will be placed only once
        /// </summary>
        public int LastRepeating
        {
            get { return m_RepeatingGroups.To; }
            set
            {
                int v = Mathf.Clamp(value, FirstRepeating, Mathf.Max(0, GroupCount - 1));
                if (m_RepeatingGroups.To != v)
                    m_RepeatingGroups.To = v;
                Dirty = true;
            }
        }

        /// <summary>
        /// If true, the last non repeating group is placed exactly at the end of the volume used for spots. If not, the last group is placed at the first available spot, which might leave some space between it and the end of the volume
        /// </summary>
        public bool FitEnd
        {
            get { return m_FitEnd; }
            set
            {
                if (m_FitEnd != value)
                    m_FitEnd = value;
                Dirty = true;
            }
        }


        public int GroupCount { get { return Groups.Count; } }

        public GUIContent[] BoundsNames
        {
            get
            {
                if (mBounds == null)
                    return new GUIContent[0];
                GUIContent[] v = new GUIContent[mBounds.Count];
                for (int i = 0; i < mBounds.Count; i++)
                    v[i] = new GUIContent(string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}:{1}", i.ToString(System.Globalization.CultureInfo.InvariantCulture), mBounds[i].Name));
                return v;
            }
        }

        public int[] BoundsIndices
        {
            get
            {
                if (mBounds == null)
                    return new int[0];
                int[] v = new int[mBounds.Count];
                for (int i = 0; i < mBounds.Count; i++)
                    v[i] = i;
                return v;
            }
        }

        public int Count { get; private set; }

        public CGSpots SimulatedSpots;//TODO Understand the namming behind this variable, and rename it if needed


        #endregion

        #region ### Private Fields & Properties ###

        /// <summary>
        /// holds data that will be used to place groups at a later time
        /// </summary>
        private sealed class EndGroupData : IDisposable
        {
            internal CGBoundsGroup BoundsGroup { get; private set; }
            internal SubArray<int> ItemIndices { get; private set; }
            internal float GroupDepth { get; }
            internal CGBounds[] ItemBounds { get; }
            internal float SpaceBefore { get; }
            internal float SpaceAfter { get; }

            internal EndGroupData(CGBoundsGroup boundsGroup, SubArray<int> itemIndices, float groupDepth, CGBounds[] itemBounds, float spaceBefore, float spaceAfter)
            {
                BoundsGroup = boundsGroup;
                ItemIndices = itemIndices;
                GroupDepth = groupDepth;
                ItemBounds = itemBounds;
                SpaceBefore = spaceBefore;
                SpaceAfter = spaceAfter;
            }

            #region Dispose pattern

            private bool disposed = false;

            private bool Dispose(bool disposing)
            {
                if (disposed)
                {
                    DTLog.LogWarning("[Curvy] Attempt to dispose an EndGroupData twice. Please raise a bug report.");
                    return false;
                }

                ArrayPools.Int32.Free(ItemIndices);

                disposed = true;
                return true;
            }

            /// <summary>
            /// Disposes an instance that is no more used, allowing it to free its resources immediately.
            /// Dispose is called automatically when an instance is <see cref="Finalize()"/>d
            /// </summary>
            public void Dispose()
            {
                Dispose(true);
                GC.SuppressFinalize(this);
            }

            ~EndGroupData()
            {
                Dispose(false);
            }

            #endregion
        }

        private WeightedRandom<int> mGroupBag;
        private List<CGBounds> mBounds;
        private bool isBoundsDisposable;
        private bool isInputAVolume;

        //do not remove, used by attributes. Edit: really? Can't find any code using this
        private int lastGroupIndex { get { return Mathf.Max(0, GroupCount - 1); } }

        private RegionOptions<float> RangeOptions
        {
            get
            {
                return RegionOptions<float>.MinMax(0, 1);
            }
        }

        private RegionOptions<int> RepeatingGroupsOptions
        {
            get
            {
                return RegionOptions<int>.MinMax(0, Mathf.Max(0, GroupCount - 1));
            }
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected override void OnEnable()
        {
            base.OnEnable();
            Properties.MinWidth = 350;
            //Properties.LabelWidth = 80;
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            RepeatingOrder = m_RepeatingOrder;
        }
#endif

        public override void Reset()
        {
            base.Reset();
            m_Range = FloatRegion.ZeroOne;
            UseVolume = true;
            Simulate = false;
            CrossBase = 0;
            CrossCurve = AnimationCurve.Linear(0, 0, 1, 0);
            RepeatingOrder = CurvyRepeatingOrderEnum.Row;
            FirstRepeating = 0;
            LastRepeating = 0;
            FitEnd = false;

            Groups.Clear();
            AddGroup("Group");
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public override void OnStateChange()
        {
            base.OnStateChange();
            if (!IsConfigured)
                Clear();
        }

        public void Clear()
        {
            Count = 0;
            SimulatedSpots = new CGSpots();
            OutSpots.SetData(SimulatedSpots);
        }

        public override void Refresh()
        {
            base.Refresh();

            if (mBounds != null && isBoundsDisposable)
                mBounds.ForEach(b => b.Dispose());
            mBounds = InBounds.GetAllData<CGBounds>(out isBoundsDisposable);

            const float MinimumAllowedBoundDepth = 0.001f;

            bool isModuleMisconfigured = false;
            {
                if (mBounds.Count == 0)
                {
                    isModuleMisconfigured = true;
                    UIMessages.Add("The input bounds list is empty. Add some to enable spots generation.");
                }

                if (Groups.Count == 0)
                {
                    isModuleMisconfigured = true;
                    UIMessages.Add("No group created. Create a group in the Groups tab to enable spots generation");
                }

                for (int i = 0; i < mBounds.Count; i++)
                {
                    CGBounds cgBounds = mBounds[i];//TODO DESIGN BUG? elements of the mBounds array can be null. Should this scenario be made impossible (as with any CGData arrays passed between modules) or is this ok, in which case this code should handle null. I got null while implementing a new module that did not return its data properly, so no know issue in release code so far
                    if (cgBounds is CGGameObject && ((CGGameObject)cgBounds).Object == null)
                    {
                        isModuleMisconfigured = true;
                        UIMessages.Add(String.Format("Input object of index {0} has no Game Object attached to it. Correct this to enable spots generation.", i));
                    }
                    //Correcting invalid bounds
                    else if (cgBounds.Depth <= MinimumAllowedBoundDepth)
                    {
#if CURVY_SANITY_CHECKS
                        Assert.IsTrue(cgBounds.Bounds.size.z <= 0);
#endif
                        CGBounds correctedBounds = new CGBounds(cgBounds);

                        UIMessages.Add(String.Format("Input object \"{0}\" has bounds with a depth of {1}. The minimal accepted depth is {2}. The depth value was overriden.", correctedBounds.Name, cgBounds.Depth, MinimumAllowedBoundDepth));

                        correctedBounds.Bounds = new Bounds(cgBounds.Bounds.center, new Vector3(cgBounds.Bounds.size.x, cgBounds.Bounds.size.y, MinimumAllowedBoundDepth));
                        mBounds[i] = correctedBounds;
                    }
                }

                foreach (CGBoundsGroup cgBoundsGroup in Groups)
                {
                    if (cgBoundsGroup.ItemCount == 0)
                    {
                        isModuleMisconfigured = true;
                        UIMessages.Add(String.Format("Group \"{0}\" has 0 item in it. Add some to enable spots generation.", cgBoundsGroup.Name));
                    }
                    else foreach (CGBoundsGroupItem cgBoundsGroupItem in cgBoundsGroup.Items)
                        {
                            int itemIndex = cgBoundsGroupItem.Index;
                            if (itemIndex < 0 || itemIndex >= mBounds.Count)//This might happen when changing the module inputs
                            {
                                isModuleMisconfigured = true;
                                UIMessages.Add(String.Format("Group \"{0}\" has a reference to an nonexistent item of index {1}. Correct the reference to enable spots generation.", cgBoundsGroup.Name, itemIndex));
                                break;
                            }

                        }
                }
            }

            CGPath path = InPath.GetData<CGPath>(out bool isdiDisposable);
            isInputAVolume = path is CGVolume;
            SubArrayList<CGSpot> spots = new SubArrayList<CGSpot>(100, ArrayPools.CGSpot);

            Dictionary<CGBoundsGroup, WeightedRandom<int>> itemsBagDictionary = Prepare();

            if (path && isModuleMisconfigured == false)
            {
                const int MaxSpotsCount = 10000;
                bool reachedMaxSpotsCount = false;

                float endDistance = path.FToDistance(m_Range.To);
                float startDistance = path.FToDistance(m_Range.Low);
                float currentDistance = startDistance;

                // Place groups that are before the repeating items range
                for (int g = 0; g < FirstRepeating; g++)
                {
                    int groupIndex = g;
                    bool failedAddingAllItems;

                    reachedMaxSpotsCount = AddGroupItems(path, groupIndex, ref spots, endDistance - currentDistance, startDistance, ref currentDistance, out failedAddingAllItems, itemsBagDictionary, MaxSpotsCount);
                    if (reachedMaxSpotsCount)
                        break;
                }

                List<EndGroupData> nonRepeatingEndGroups;
                // Compute data needed to place groups that are after the repeating range. They will be actually placed a the end of this method
                bool hasNonRepeatingEndGroups = GroupCount - LastRepeating - 1 > 0;
                if (reachedMaxSpotsCount == false && hasNonRepeatingEndGroups)
                {
                    nonRepeatingEndGroups = new List<EndGroupData>();
                    for (int g = LastRepeating + 1; g < GroupCount; g++)
                    {
                        CGBoundsGroup cgBoundsGroup = Groups[g];
#if CURVY_SANITY_CHECKS
                        Assert.IsTrue(cgBoundsGroup.ItemCount > 0);
#endif
                        SubArray<int> itemIndices = GetGroupItemIndices(cgBoundsGroup, itemsBagDictionary[cgBoundsGroup]);

                        float spaceBefore = UseBuggedRng ? cgBoundsGroup.SpaceBefore.Next : GetRegionNextValue(cgBoundsGroup.SpaceBefore);
                        float spaceAfter = UseBuggedRng ? cgBoundsGroup.SpaceAfter.Next : GetRegionNextValue(cgBoundsGroup.SpaceAfter);

                        CGBounds[] itemBounds;
                        float groupDepth = GetGroupDepth(itemIndices, spaceBefore, spaceAfter, out itemBounds);

                        nonRepeatingEndGroups.Add(new EndGroupData(cgBoundsGroup, itemIndices, groupDepth, itemBounds, spaceBefore, spaceAfter));
                    }
                }
                else
                    nonRepeatingEndGroups = null;

                float repeatGroupsEndDistance;
                {
                    repeatGroupsEndDistance = endDistance;
                    if (hasNonRepeatingEndGroups)
                        foreach (EndGroupData endGroupData in nonRepeatingEndGroups)
                        {
                            float availableSpace = repeatGroupsEndDistance - currentDistance;

                            // the multiplication is to ensure a margin, otherwise float imprecision create issue
                            //The issue being that when FitEnd is true, we start spawning the end group starting from repeatGroupsEndDistance which is supposed to be enough to fit all end groups, but sometimes the last item of the end group has no place to be fit in
                            float possibleRepeatGroupsEndDistance = repeatGroupsEndDistance - endGroupData.GroupDepth * 1.00001f;

                            //the group can fit
                            if (endGroupData.GroupDepth <= availableSpace)
                            {
                                repeatGroupsEndDistance = possibleRepeatGroupsEndDistance;
                                continue;
                            }

                            //the whole group can't be fit
                            if (endGroupData.BoundsGroup.KeepTogether)
                                //group will not be spawned because it can't fit, so we ignore it
                                continue;

                            //Can we fit at least one item?
                            if (false == endGroupData.ItemBounds.Any(i =>
                                i.Depth + endGroupData.SpaceBefore + endGroupData.SpaceAfter <= availableSpace))
                                continue;

                            repeatGroupsEndDistance = possibleRepeatGroupsEndDistance;
                        }
                }

                // Place groups that are in the repeating items range
                if (RepeatingOrder == CurvyRepeatingOrderEnum.Row)
                {
                    int g = FirstRepeating;
                    bool failedAddingAllItems = false;
                    while (reachedMaxSpotsCount == false && failedAddingAllItems == false && repeatGroupsEndDistance > currentDistance)
                    {
                        int groupIndex = g++;
                        if (g > LastRepeating)
                            g = FirstRepeating;

                        reachedMaxSpotsCount = AddGroupItems(path, groupIndex, ref spots, repeatGroupsEndDistance - currentDistance, startDistance, ref currentDistance, out failedAddingAllItems, itemsBagDictionary, MaxSpotsCount);
                        if (reachedMaxSpotsCount)
                            break;
                    }
                }
                else
                {
                    bool failedAddingAllItems = false;
                    while (reachedMaxSpotsCount == false && failedAddingAllItems == false && repeatGroupsEndDistance > currentDistance)
                    {
                        int groupIndex = mGroupBag.Next();

                        reachedMaxSpotsCount = AddGroupItems(path, groupIndex, ref spots, repeatGroupsEndDistance - currentDistance, startDistance, ref currentDistance, out failedAddingAllItems, itemsBagDictionary, MaxSpotsCount);
                        if (reachedMaxSpotsCount)
                            break;
                    }
                }

                // Now we actually Place groups that are after the repeating items range
                if (reachedMaxSpotsCount == false && hasNonRepeatingEndGroups)
                {
                    if (FitEnd)
                        //BUG in the case where repeatGroupsEndDistance is smaller than currentDistance, FitEnd will have no effect. To fix that, you will need to compute a new repeatGroupsEndDistance that is bigger than currentDistance, that will consider not all end groups, but only the ones that can fit
                        currentDistance = Mathf.Max(currentDistance, repeatGroupsEndDistance);

                    foreach (EndGroupData endGroupData in nonRepeatingEndGroups)
                    {
                        bool failedAddingAllItems;
                        AddGroupItems(path, endGroupData.BoundsGroup, ref spots, endDistance - currentDistance, startDistance, ref currentDistance, out failedAddingAllItems, endGroupData.ItemIndices, endGroupData.GroupDepth, endGroupData.ItemBounds, endGroupData.SpaceBefore, endGroupData.SpaceAfter);

                        if (spots.Count >= MaxSpotsCount)
                        {
                            reachedMaxSpotsCount = true;
                            break;
                        }
                    }
                }

                if (reachedMaxSpotsCount)
                {
                    string errorMessage = String.Format("Number of generated spots reached the maximal allowed number, which is {0}. Spots generation was stopped. Try to reduce the number of spots needed by using bigger Bounds as inputs and/or setting bigger space between two spots.", MaxSpotsCount);
                    UIMessages.Add(errorMessage);
                    DTLog.LogError("[Curvy] Volume spots: " + errorMessage, this);
                }

                if (nonRepeatingEndGroups != null)
                {
                    foreach (var endGroup in nonRepeatingEndGroups)
                        endGroup.Dispose();
                    nonRepeatingEndGroups = null;
                }
            }

            Count = spots.Count;

            SimulatedSpots = new CGSpots(spots.ToSubArray());
            if (Simulate)
                OutSpots.SetData(new CGSpots());
            else
                OutSpots.SetData(SimulatedSpots);

            if (isdiDisposable)
                path.Dispose();
        }

        public CGBoundsGroup AddGroup(string name)
        {
            //TODO unify this code with the one in BuildVolumeSpotEditor.SetupArrayEx()

            CGBoundsGroup grp = new CGBoundsGroup(name);
            grp.Items.Add(new CGBoundsGroupItem());
            Groups.Add(grp);
            Dirty = true;
            return grp;
        }

        public void RemoveGroup(CGBoundsGroup group)
        {
            Groups.Remove(group);
            Dirty = true;
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */
        private static SubArray<int> GetGroupItemIndices(CGBoundsGroup boundsGroup, WeightedRandom<int> groupItemBag)
        {
            var result = ArrayPools.Int32.Allocate(boundsGroup.ItemCount, false);
            for (int i = 0; i < boundsGroup.ItemCount; i++)
            {
                int itemId =
                    boundsGroup.RandomizeItems && i >= boundsGroup.FirstRepeating && i <= boundsGroup.LastRepeating
                        ? groupItemBag.Next()
                        : i;

                result.Array[i] = boundsGroup.Items[itemId].Index;
            }

            return result;
        }

        private float GetGroupDepth(SubArray<int> groupItemIndices, float spaceBefore, float spaceAfter, out CGBounds[] itemsBounds)
        {
            itemsBounds = new CGBounds[groupItemIndices.Count];
            float groupDepth = spaceBefore + spaceAfter;
            {
                for (int i = 0; i < groupItemIndices.Count; i++)
                {
                    CGBounds itemBounds = mBounds[groupItemIndices.Array[i]];
                    itemsBounds[i] = itemBounds;
                    groupDepth += itemBounds.Depth;
#if CURVY_SANITY_CHECKS
                    Assert.IsTrue(itemBounds.Depth > 0);
#endif
                }
            }
            return groupDepth;
        }


        private bool AddGroupItems(CGPath path, int groupIndex, ref SubArrayList<CGSpot> spots, float remainingLength, float startDistance, ref float currentDistance, out bool failedAddingAllItems, Dictionary<CGBoundsGroup, WeightedRandom<int>> itemsBagDictionary, int MaxSpotsCount)
        {
            CGBoundsGroup cgBoundsGroup = Groups[groupIndex];
            WeightedRandom<int> groupItemBag = itemsBagDictionary[cgBoundsGroup];

            SubArray<int> itemIndices = GetGroupItemIndices(cgBoundsGroup, groupItemBag);

            float spaceBefore = UseBuggedRng ? cgBoundsGroup.SpaceBefore.Next : GetRegionNextValue(cgBoundsGroup.SpaceBefore);
            float spaceAfter = UseBuggedRng ? cgBoundsGroup.SpaceAfter.Next : GetRegionNextValue(cgBoundsGroup.SpaceAfter);

            CGBounds[] itemBounds;
            float groupDepth = GetGroupDepth(itemIndices, spaceBefore, spaceAfter, out itemBounds);

            AddGroupItems(path, cgBoundsGroup, ref spots, remainingLength, startDistance,
                ref currentDistance, out failedAddingAllItems, itemIndices, groupDepth, itemBounds, spaceBefore, spaceAfter);
            ArrayPools.Int32.Free(itemIndices);

            return spots.Count >= MaxSpotsCount;
        }

        private void AddGroupItems(CGPath path, CGBoundsGroup group, ref SubArrayList<CGSpot> spots, float remainingLength, float startDistance, ref float currentDistance, out bool failedAddingAllItems, SubArray<int> itemIndices, float groupDepth, CGBounds[] itemBounds, float spaceBefore, float spaceAfter)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(group.ItemCount > 0);
#endif
            if (remainingLength >= groupDepth || group.KeepTogether == false)
            {
                failedAddingAllItems = false;
                for (int index = 0; index < itemIndices.Count; index++)
                {
                    float distanceAtIterationStart = currentDistance;

                    int itemId = itemIndices.Array[index];
                    CGBounds currentBounds = itemBounds[index];

                    bool canAddItem;
                    if (index == 0)
                    {
                        canAddItem = remainingLength > spaceBefore + currentBounds.Depth;
                        if (canAddItem)
                            currentDistance += spaceBefore;
                    }
                    else if (index == itemIndices.Count - 1)
                        canAddItem = remainingLength > spaceAfter + currentBounds.Depth;
                    else
                        canAddItem = remainingLength > currentBounds.Depth;

                    if (canAddItem == false)
                    {
                        failedAddingAllItems = true;
                        break;
                    }

                    spots.Add(GetSpot(path, itemId, group, currentBounds, currentDistance, startDistance));

                    if (index == itemIndices.Count - 1)
                        currentDistance += currentBounds.Depth + spaceAfter;
                    else
                        currentDistance += currentBounds.Depth;

                    remainingLength -= currentDistance - distanceAtIterationStart;
                }
            }
            else
                failedAddingAllItems = true;
        }

        private CGSpot GetSpot(CGPath path, int itemID, CGBoundsGroup boundsGroup, CGBounds bounds, float currentDistance, float startDistance)
        {
            float pathRelativeDistance = path.DistanceToF(currentDistance + bounds.Depth / 2);

            float pathLength = path.Length * m_Range.Length;
            float globalF = (currentDistance - startDistance) / pathLength;
            float crossF;
            {
                float rawCrossF = UseBuggedRng ? boundsGroup.CrossBase.Next : GetRegionNextValue(boundsGroup.CrossBase);
                if (boundsGroup.IgnoreModuleCrossBase == false)
                    rawCrossF += CrossBase + m_CrossCurve.Evaluate(globalF);

                //Warning, crossF can be beyond the range -0.5f;0.5f
                crossF = DTMath.MapValue(-0.5f, 0.5f, rawCrossF, -1f, 1f);
            }

            Vector3 interpolatedPosition;
            Vector3 tangent;
            Vector3 up;
            CGVolume volume = path as CGVolume;
            bool useVolume = UseVolume && volume;
            switch (boundsGroup.RotationMode)
            {
                case CGBoundsGroup.RotationModeEnum.Full:
                    {
                        if (useVolume)
                            volume.InterpolateVolume(pathRelativeDistance, crossF, out interpolatedPosition, out tangent, out up);
                        else
                        {
                            path.Interpolate(pathRelativeDistance, out interpolatedPosition, out tangent, out up);
                            if (crossF != 0)
                                up = Quaternion.AngleAxis(crossF * -360, tangent) * up;
                        }
                    }
                    break;
                case CGBoundsGroup.RotationModeEnum.Direction:
                case CGBoundsGroup.RotationModeEnum.Horizontal:
                    {
                        if (useVolume)
                            volume.InterpolateVolume(pathRelativeDistance, crossF, out interpolatedPosition, out tangent, out _);
                        else
                            path.Interpolate(pathRelativeDistance, out interpolatedPosition, out tangent, out _);

                        up = Vector3.up;
                        if (boundsGroup.RotationMode == CGBoundsGroup.RotationModeEnum.Horizontal)
                            tangent.y = 0;
                    }
                    break;
                case CGBoundsGroup.RotationModeEnum.Independent:
                    {
                        if (useVolume)
                            interpolatedPosition = volume.InterpolateVolumePosition(pathRelativeDistance, crossF);
                        else
                            interpolatedPosition = path.InterpolatePosition(pathRelativeDistance);
                        up = Vector3.up;
                        tangent = Vector3.forward;
                    }
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }


            Vector3 translation;
            Quaternion rotation;
            Vector3 scale;
            if (UseBuggedRng)
                GetTRS630(boundsGroup, tangent, up, out rotation, out translation, out scale);
            else
                GetTRS(boundsGroup, tangent, up, out rotation, out translation, out scale);

            return new CGSpot(itemID, interpolatedPosition.Addition(boundsGroup.RelativeTranslation ? rotation * translation : translation), rotation, scale);
        }

        private static float GetRegionNextValue(FloatRegion floatRegion)
        {
            float result;
            if (floatRegion.SimpleValue)
            {
                result = floatRegion.From;
                //So that at the end of the if statement, whatever the value of SimpleValue is, the RNG has the same state.
                //Otherwise, the next FloatRegion's randomly generated value will be different depending on this FloatRegion's SimpleValue 
                Random.Range(0f, 1f);
            }
            else
                result = Random.Range(floatRegion.From, floatRegion.To);

            return result;
        }

        private void GetTRS(CGBoundsGroup boundsGroup, Vector3 tangent, Vector3 up, out Quaternion rotation,
            out Vector3 translation, out Vector3 scale)
        {
            //rotation
            {
                Vector3 eulerVector;
                {
                    eulerVector.x = GetRegionNextValue(boundsGroup.RotationX);
                    eulerVector.y = GetRegionNextValue(boundsGroup.RotationY);
                    eulerVector.z = GetRegionNextValue(boundsGroup.RotationZ);
                }
                rotation = Quaternion.LookRotation(tangent, up) * Quaternion.Euler(eulerVector);
            }

            //translation
            {
                translation.x = GetRegionNextValue(boundsGroup.TranslationX);
                translation.y = GetRegionNextValue(boundsGroup.TranslationY);
                translation.z = GetRegionNextValue(boundsGroup.TranslationZ);
            }

            //Scale
            {
                scale.x = GetRegionNextValue(boundsGroup.ScaleX);

                if (boundsGroup.UniformScaling)
                {
                    scale.y = scale.z = scale.x;

                    //So that at the end of the if statement, whatever the value of UniformScaling is, the RNG has the same state.
                    //Otherwise, the next FloatRegion's randomly generated value will be different depending on UniformScaling 
                    Random.Range(0f, 1f);
                    Random.Range(0f, 1f);
                }
                else
                {
                    scale.y = GetRegionNextValue(boundsGroup.ScaleY);
                    scale.z = GetRegionNextValue(boundsGroup.ScaleZ);
                }
            }
        }

        private void GetTRS630(CGBoundsGroup boundsGroup, Vector3 tangent, Vector3 up, out Quaternion rotation,
            out Vector3 translation, out Vector3 scale)
        {
#pragma warning disable 618

            Vector3 boundsGroupRotationScatter = new Vector3(
                boundsGroup.RotationX.SimpleValue ? 0 : ((boundsGroup.RotationX.High - boundsGroup.RotationX.Low) * 0.5f),
                boundsGroup.RotationY.SimpleValue ? 0 : ((boundsGroup.RotationY.High - boundsGroup.RotationY.Low) * 0.5f),
                boundsGroup.RotationZ.SimpleValue ? 0 : ((boundsGroup.RotationZ.High - boundsGroup.RotationZ.Low) * 0.5f));
            Vector3 boundsGroupRotationOffset = new Vector3(
                boundsGroup.RotationX.SimpleValue ? boundsGroup.RotationX.From : ((boundsGroup.RotationX.From + boundsGroup.RotationX.To) * 0.5f),
                boundsGroup.RotationY.SimpleValue ? boundsGroup.RotationY.From : ((boundsGroup.RotationY.From + boundsGroup.RotationY.To) * 0.5f),
                boundsGroup.RotationZ.SimpleValue ? boundsGroup.RotationZ.From : ((boundsGroup.RotationZ.From + boundsGroup.RotationZ.To) * 0.5f));
            rotation = Quaternion.LookRotation(tangent, up) *
                       Quaternion.Euler(
                           boundsGroupRotationOffset.x + boundsGroupRotationScatter.x * Random.Range(-1, 1),
                           boundsGroupRotationOffset.y + boundsGroupRotationScatter.y * Random.Range(-1, 1),
                           boundsGroupRotationOffset.z + boundsGroupRotationScatter.z * Random.Range(-1, 1));
#pragma warning restore 618

            //The calls to Next can lead to calls to Random. To keep the random generations independent, the seed is saved and restored before each call to Next. This isn't done for all the calls to keep the same behaviour as in 6.3.0
            Random.State postRotationSeed; //OPTIM assign this variable only if reading it is needed, i.e we need to call Random.Range on one of boundsGroup members
            {
                FloatRegion positionX = boundsGroup.TranslationX;
                FloatRegion positionY = boundsGroup.TranslationY;
                FloatRegion positionZ = boundsGroup.TranslationZ;

                if (positionY.SimpleValue)
                    translation.y = positionY.From;
                else
                    translation.y = Random.Range(positionY.From, positionY.To);

                postRotationSeed = Random.state;

                if (positionX.SimpleValue)
                    translation.x = positionX.From;
                else
                {
                    translation.x = Random.Range(positionX.From, positionX.To);
                    Random.state = postRotationSeed;
                }

                if (positionZ.SimpleValue)
                    translation.z = positionZ.From;
                else
                {
                    translation.z = Random.Range(positionZ.From, positionZ.To);
                    Random.state = postRotationSeed;
                }
            }

            //Scale
            {
                FloatRegion scaleX = boundsGroup.ScaleX;

                if (scaleX.SimpleValue)
                    scale.x = scaleX.From;
                else
                {
                    scale.x = Random.Range(scaleX.From, scaleX.To);
                    Random.state = postRotationSeed;
                }

                if (boundsGroup.UniformScaling)
                    scale.y = scale.z = scale.x;
                else
                {
                    FloatRegion scaleY = boundsGroup.ScaleY;
                    FloatRegion scaleZ = boundsGroup.ScaleZ;

                    if (scaleY.SimpleValue)
                        scale.y = scaleY.From;
                    else
                    {
                        scale.y = Random.Range(scaleY.From, scaleY.To);
                        Random.state = postRotationSeed;
                    }

                    if (scaleZ.SimpleValue)
                        scale.z = scaleZ.From;
                    else
                    {
                        scale.z = Random.Range(scaleZ.From, scaleZ.To);
                        Random.state = postRotationSeed;
                    }
                }
            }
        }

        private Dictionary<CGBoundsGroup, WeightedRandom<int>> Prepare()
        {
            Dictionary<CGBoundsGroup, WeightedRandom<int>> itemsBagDictionary = new Dictionary<CGBoundsGroup, WeightedRandom<int>>();
            m_RepeatingGroups.MakePositive();
            m_RepeatingGroups.Clamp(0, GroupCount - 1);
            // Groups
            mGroupBag = new WeightedRandom<int>(0, UseBuggedRng ? 0 : Random.Range(0, Int32.MaxValue));
            if (RepeatingOrder == CurvyRepeatingOrderEnum.Random)
            {
                List<CGWeightedItem> cgWeightedItems = Groups.Cast<CGWeightedItem>().ToList();
                CGBoundsGroup.FillItemBag(mGroupBag, cgWeightedItems, FirstRepeating, LastRepeating);
            }

            // Prepare Groups & ItemBags
            for (int g = 0; g < Groups.Count; g++)
            {
                CGBoundsGroup boundsGroup = Groups[g];
                boundsGroup.RepeatingItems.MakePositive();
                boundsGroup.RepeatingItems.Clamp(0, boundsGroup.ItemCount - 1);
                WeightedRandom<int> itemsBag;
                {
                    //We save and restore the random state to avoid that the number of groups would modify the randomly generated numbers inside the groups
                    Random.State previousState = Random.state;
                    itemsBag = new WeightedRandom<int>(0, UseBuggedRng ? 0 : Random.Range(0, Int32.MaxValue));
                    Random.state = previousState;
                }
                itemsBagDictionary[boundsGroup] = itemsBag;
                if (boundsGroup.Items.Count != 0 && boundsGroup.RandomizeItems)
                {
                    List<CGWeightedItem> cgWeightedItems = boundsGroup.Items.Cast<CGWeightedItem>().ToList();
                    CGBoundsGroup.FillItemBag(itemsBag, cgWeightedItems, boundsGroup.FirstRepeating,
                        boundsGroup.LastRepeating);
                }
            }

            return itemsBagDictionary;
        }

        //Used in field condition
        private bool ShowFitEnd
        {
            get
            {
                return LastRepeating != Groups.Count - 1;
            }
        }


        /*! \endcond */
        #endregion

        #region ISerializationCallbackReceiver
        /*! \cond PRIVATE */
        /// <summary>
        /// Implementation of UnityEngine.ISerializationCallbackReceiver
        /// Called automatically by Unity, is not meant to be called by Curvy's users
        /// </summary>
        public void OnBeforeSerialize()
        {

        }

        /// <summary>
        /// Implementation of UnityEngine.ISerializationCallbackReceiver
        /// Called automatically by Unity, is not meant to be called by Curvy's users
        /// </summary>
        public void OnAfterDeserialize()
        {
            if (String.IsNullOrEmpty(Version))
            {
                Version = "1";
                m_WasUpgraded = true;

                for (int index = 0; index < Groups.Count; index++)
                {
                    CGBoundsGroup cgBoundsGroup = Groups[index];
                    cgBoundsGroup.RelativeTranslation = true;
                    cgBoundsGroup.TranslationX = new FloatRegion(0f);
                    cgBoundsGroup.TranslationY = new FloatRegion(0f);
                    cgBoundsGroup.TranslationZ = new FloatRegion(0f);
                    cgBoundsGroup.RotationX = new FloatRegion(0f);
                    cgBoundsGroup.RotationY = new FloatRegion(0f);
                    cgBoundsGroup.RotationZ = new FloatRegion(0f);
                    cgBoundsGroup.UniformScaling = true;
                    cgBoundsGroup.ScaleX = new FloatRegion(1f);
                    cgBoundsGroup.ScaleY = new FloatRegion(1f);
                    cgBoundsGroup.ScaleZ = new FloatRegion(1f);
#pragma warning disable 618
                    cgBoundsGroup.ConvertObsoleteData();
#pragma warning restore 618
                }
            }
        }
        /*! \endcond */
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/BuildVolumeSpots.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ConformPath.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 013f55592f4a5d4408ed23aed18bdece
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Modifier/Conform Path", ModuleName = "Conform Path", Description = "Projects a path")]
    [HelpURL(CurvySpline.DOCLINK + "cgconformpath")]
#pragma warning disable 618
    public class ConformPath : CGModule, IOnRequestProcessing, IPathProvider
#pragma warning restore 618
    {

        [HideInInspector]
        [InputSlotInfo(typeof(CGPath), Name = "Path", ModifiesData = true)]
        public CGModuleInputSlot InPath = new CGModuleInputSlot();

        [HideInInspector]
        [OutputSlotInfo(typeof(CGPath))]
        public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();

        #region ### Serialized Fields ###

        [SerializeField]
        [VectorEx]
        [Tooltip("The direction to raycast in ")]
        private Vector3 m_Direction = new Vector3(0, -1, 0);
        [SerializeField]
        [Tooltip("The maximum raycast distance")]
        private float m_MaxDistance = 100;
        [SerializeField]
        [Tooltip("Defines an offset shift along the raycast direction")]
        private float m_Offset;
        [SerializeField]
        [Tooltip("If enabled, the entire path is moved to the nearest possible distance. If disabled, each path point is moved individually")]
        private bool m_Warp;
        [SerializeField]
        [Tooltip("The layers to raycast against")]
        private LayerMask m_LayerMask;

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// The direction to raycast in 
        /// </summary>
        public Vector3 Direction
        {
            get
            {
                return m_Direction;
            }
            set
            {
                if (m_Direction != value)
                    m_Direction = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// The maximum raycast distance
        /// </summary>
        public float MaxDistance
        {
            get { return m_MaxDistance; }
            set
            {
                if (m_MaxDistance != value)
                    m_MaxDistance = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// Defines an offset shift along the raycast direction
        /// </summary>
        public float Offset
        {
            get { return m_Offset; }
            set
            {
                if (m_Offset != value)
                    m_Offset = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// If enabled, the entire path is moved to the nearest possible distance. If disabled, each path point is moved individually
        /// </summary>
        public bool Warp
        {
            get { return m_Warp; }
            set
            {
                if (m_Warp != value)
                    m_Warp = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// The layers to raycast against
        /// </summary>
        public LayerMask LayerMask
        {
            get { return m_LayerMask; }
            set
            {
                if (m_LayerMask != value)
                    m_LayerMask = value;
                Dirty = true;
            }
        }

        #endregion

        #region ### Private Fields & Properties ###
        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected override void OnEnable()
        {
            base.OnEnable();
            //Properties.MinWidth = 250;
            Properties.LabelWidth = 80;
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Direction = m_Direction;
            MaxDistance = m_MaxDistance;
            Offset = m_Offset;
            LayerMask = m_LayerMask;
        }
#endif

        public override void Reset()
        {
            base.Reset();
            Direction = new Vector3(0, -1, 0);
            MaxDistance = 100;
            Offset = 0;
            Warp = false;
            LayerMask = 0;
        }


        /*! \endcond */
        #endregion

        #region ### IOnRequestProcessing ###

        public bool PathIsClosed
        {
            get
            {
                return (IsConfigured) && InPath.SourceSlot().PathProvider.PathIsClosed;
            }
        }

        public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
        {
            CGDataRequestRasterization raster = GetRequestParameter<CGDataRequestRasterization>(ref requests);
            if (!raster)
                return null;

            if (LayerMask == 0)//0 is Nothing
                UIMessages.Add("Please set a Layer Mask different than Nothing.");

            CGPath path = InPath.GetData<CGPath>(out bool isDisposable, requests);
#if CURVY_SANITY_CHECKS
            // I forgot why I added this assertion, but I trust my past self
            Assert.IsTrue(path == null || isDisposable);
#endif
            Conform(path, Generator.transform, LayerMask, Direction, Offset, MaxDistance, Warp);

            return new CGData[1] { path };
        }

        /// <summary>
        /// Conforms a path by projecting it on top of objects (with a collider) of a specific layer
        /// </summary>
        /// <param name="pathTransform"></param>
        /// <param name="path"></param>
        /// <param name="layers"></param>
        /// <param name="projectionDirection"></param>
        /// <param name="offset"></param>
        /// <param name="rayLength"></param>
        /// <param name="warp">If true, the projected path will keep its shape</param>
        public static void Conform(CGPath path, Transform pathTransform, LayerMask layers, Vector3 projectionDirection, float offset, float rayLength, bool warp)
        {
#pragma warning disable 618
            Conform(pathTransform, path, layers, projectionDirection, offset, rayLength, warp);
#pragma warning restore 618
        }

        /// <summary>
        /// Conforms a path by projecting it on top of objects (with a collider) of a specific layer
        /// </summary>
        /// <param name="pathTransform"></param>
        /// <param name="path"></param>
        /// <param name="layers"></param>
        /// <param name="projectionDirection"></param>
        /// <param name="offset"></param>
        /// <param name="rayLength"></param>
        /// <param name="warp">If true, the projected path will keep its shape</param>
        /// <returns>The same path as the input parameter 'path'</returns>
        [Obsolete("Use the other override")]
        public static CGPath Conform(Transform pathTransform, CGPath path, LayerMask layers, Vector3 projectionDirection, float offset, float rayLength, bool warp)
        {
            if (path == null)
                return null;

            int pathCount = path.Count;
            if (projectionDirection != Vector3.zero && rayLength > 0 && pathCount > 0)
            {
                RaycastHit raycastHit;

                if (warp)
                {
                    float minDist = float.MaxValue;

                    for (int i = 0; i < pathCount; i++)
                        if (Physics.Raycast(pathTransform.TransformPoint(path.Positions.Array[i]), projectionDirection, out raycastHit, rayLength, layers))
                            if (raycastHit.distance < minDist)
                                minDist = raycastHit.distance;
                    if (minDist != float.MaxValue)
                    {
                        Vector3 positionTranslation = projectionDirection * (minDist + offset);
                        for (int i = 0; i < path.Count; i++)
                            path.Positions.Array[i] += positionTranslation;
                    }
                }
                else
                {


                    for (int i = 0; i < pathCount; i++)
                        if (Physics.Raycast(pathTransform.TransformPoint(path.Positions.Array[i]), projectionDirection, out raycastHit, rayLength, layers))
                            path.Positions.Array[i] += projectionDirection * (raycastHit.distance + offset);
                }
                
                path.Recalculate();

                /* //TODO a lot to fix before being able to execute the commented code

                //preferably should compute the directions as in SplineInputModuleBase (based on spline, and not on approximations positions)
                //Does not compute Directions[0]

                //needs the soft edges list
                //need for RecalculateNormals to use the same logic as in SplineInputModuleBase (current logic handles only 2D shapes)
                //recomputing orientations without the information of the CPs' rotations, which is available only at spline input module level, gives different result. Here is the comment I wrote at the time: //En gros, recalculer les normals sans les infos d'orientation des cps, qui n-est available seulement dans l'Input Spline Path module, cre des orientations bizarres. Ca a l'air de marcher,  moiti, que pour Input Spline Shape

                path.RecalculateNormals(new List<int>());
                */

            }
            return path;
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */


        /*! \endcond */
        #endregion



    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ConformPath.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/CreateGameObject.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 89a49fda31b97d84787924dbf8bd2a94
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections.Generic;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Create/GameObject", ModuleName = "Create GameObject")]
    [HelpURL(CurvySpline.DOCLINK + "cgcreategameobject")]
    public class CreateGameObject : ResourceExportingModule
    {
        [HideInInspector]
        [InputSlotInfo(typeof(CGGameObject), Array = true, Name = "GameObject")]
        public CGModuleInputSlot InGameObjectArray = new CGModuleInputSlot();

        [HideInInspector]
        [InputSlotInfo(typeof(CGSpots), Name = "Spots")]
        public CGModuleInputSlot InSpots = new CGModuleInputSlot();

        [SerializeField, CGResourceCollectionManager("GameObject", ShowCount = true)]
        private CGGameObjectResourceCollection m_Resources = new CGGameObjectResourceCollection();

        #region ### Serialized Fields ###

        [Tab("General")]
        [SerializeField]
        private bool m_MakeStatic;

        [SerializeField]
        [Layer]
        private int m_Layer;

        [Tooltip("Whether Layer should be applied only on the root of a created game object, or it should be applied on its whole hierarchy")]
        [SerializeField]
        private bool applyLayerOnChildren;

        #endregion

        #region ### Public Properties ###

        public int Layer
        {
            get { return m_Layer; }
            set
            {
                int v = Mathf.Clamp(value, 0, 32);
                if (m_Layer != v)
                    m_Layer = v;
                Dirty = true;
            }
        }

        /// <summary>
        /// Whether the layer defined in <see cref="Layer"/> should be applied only on the root of a created game object, or it should be applied on its whole hierarchy
        /// </summary>
        public bool ApplyLayerOnChildren
        {
            get { return applyLayerOnChildren; }
            set
            {
                if (applyLayerOnChildren != value)
                    applyLayerOnChildren = value;
                Dirty = true;
            }
        }
        public bool MakeStatic
        {
            get { return m_MakeStatic; }
            set
            {
                if (m_MakeStatic != value)
                    m_MakeStatic = value;
                Dirty = true;
            }
        }

        public CGGameObjectResourceCollection GameObjects
        {
            get { return m_Resources; }
        }

        public int GameObjectCount
        {
            get { return GameObjects.Count; }
        }

        #endregion

        #region ### Private Fields & Properties ###
        /// <summary>
        /// Key is the created game objects' transforms. Value is the associated pool name. Is filled in the Refresh method.
        /// </summary>
        private readonly Dictionary<Transform, string> usedPoolsDictionary = new Dictionary<Transform, string>();
        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Dirty = true;
        }
#endif

        public override void Reset()
        {
            base.Reset();
            MakeStatic = false;
            Layer = 0;
            ApplyLayerOnChildren = false;
        }

        protected override void OnDestroy()
        {
            if (!Generator.Destroying)
                DeleteAllPrefabPools();
            base.OnDestroy();
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public override bool DeleteAllOutputManagedResources()
        {
            bool result = base.DeleteAllOutputManagedResources();

            //delete all children
            int childCount = transform.childCount;
            result |= childCount > 0;

            Transform[] destructionTargets = new Transform[childCount];
            for (int i = 0; i < childCount; i++)
                destructionTargets[i] = transform.GetChild(i);

            //it might seem a good idea to not use destructionTargets, and just iterate through all children and delete them, but the deletion code can, depending on different on edit/play mode and prefab status, either delete instantly the object, delete it at the end of the frame, or not delete it at all, leading to the iteration logic having to handle all of those cases in deciding what should be the iteration index. I prefer to play it safe, and use the destructionTargets list
            foreach (Transform child in destructionTargets)
            {
                if (usedPoolsDictionary.TryGetValue(child, out string poolName))
                    DeleteManagedResource("GameObject", child, poolName, false);
                else
                    DeleteManagedResource("GameObject", child, string.Empty, true);
            }

            GameObjects.Items.Clear();
            GameObjects.PoolNames.Clear();
            usedPoolsDictionary.Clear();

            return result;
        }

        [Obsolete("Use DeleteAllOutputManagedResources instead")]
        public void Clear()
        {
            DeleteAllOutputManagedResources();
        }

        public override void Refresh()
        {
            base.Refresh();

            TryDeleteChildrenFromAssociatedPrefab();
            DeleteAllOutputManagedResources();

            List<CGGameObject> VGO = InGameObjectArray.GetAllData<CGGameObject>(out bool isGOsDisposable);
            CGSpots Spots = InSpots.GetData<CGSpots>(out bool isSpotsDisposable);

            List<IPool> existingPools = GetAllPrefabPools();
            HashSet<string> usedPools = new HashSet<string>();

            GameObjects.Items.Clear();
            GameObjects.PoolNames.Clear();
            usedPoolsDictionary.Clear();

            if (VGO.Count > 0 && Spots.Count > 0)
            {
                CGSpot spot;
                for (int s = 0; s < Spots.Count; s++)
                {
                    spot = Spots.Spots.Array[s];
                    int id = spot.Index;
                    if (id >= 0 && id < VGO.Count && VGO[id].Object != null)
                    {
                        CGGameObject inputCGGameObject = VGO[id];

                        string poolIdent = GetPrefabPool(inputCGGameObject.Object).Identifier;
                        usedPools.Add(poolIdent);
                        Transform res = (Transform)AddManagedResource("GameObject", poolIdent, s);
                        res.gameObject.isStatic = MakeStatic;
                        res.gameObject.layer = Layer;
                        if (ApplyLayerOnChildren)
                        {
                            //Optim: GetComponentsInChildren does an allocation to make the array, which GetChild doesn't need. So an alternative would be to make a recursive method that goes through all children an apply an action on them. For now, I will just stick with the simplest implementation
                            Transform[] descendants = res.gameObject.GetComponentsInChildren<Transform>(true);
                            foreach (Transform descendantTransform in descendants)
                                descendantTransform.gameObject.layer = Layer;
                        }
                        res.localPosition = spot.Position;
                        res.localRotation = spot.Rotation;
                        res.localScale = new Vector3(inputCGGameObject.Object.transform.localScale.x * spot.Scale.x * inputCGGameObject.Scale.x, inputCGGameObject.Object.transform.localScale.y * spot.Scale.y * inputCGGameObject.Scale.y, inputCGGameObject.Object.transform.localScale.z * spot.Scale.z * inputCGGameObject.Scale.z);

                        if (inputCGGameObject.Translate != Vector3.zero)
                            res.Translate(inputCGGameObject.Translate);
                        if (inputCGGameObject.Rotate != Vector3.zero)
                            res.Rotate(inputCGGameObject.Rotate);

                        GameObjects.Items.Add(res);
                        GameObjects.PoolNames.Add(poolIdent);

                        usedPoolsDictionary[res] = poolIdent;
                    }
                }
            }

            // Remove unused pools
            foreach (IPool pool in existingPools)
            {
                if (!usedPools.Contains(pool.Identifier))
                    Generator.PoolManager.DeletePool(pool);
            }

            if (isGOsDisposable)
                VGO.ForEach(d => d.Dispose());
            if (isSpotsDisposable)
                Spots.Dispose();

        }

        #endregion

        protected override GameObject SaveResourceToScene(Component managedResource, Transform newParent)
        {
            GameObject duplicateGameObject = managedResource.gameObject.DuplicateGameObject(newParent);
            duplicateGameObject.name = managedResource.name;
            return duplicateGameObject;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/CreateGameObject.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/CreateMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c6892ca2de7dc0741889c5dcd62ef9cc
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using ToolBuddy.Pooling.Pools;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Pools;
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using JetBrains.Annotations;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;
using UnityEngine.Rendering;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Create/Mesh", ModuleName = "Create Mesh")]
    [HelpURL(CurvySpline.DOCLINK + "cgcreatemesh")]
    public class CreateMesh : ResourceExportingModule, ISerializationCallbackReceiver
    {
        /// <summary>
        /// The default value of Tag of created objects
        /// </summary>
        private const string DefaultTag = "Untagged";


        [HideInInspector]
        [InputSlotInfo(typeof(CGVMesh), Array = true, Name = "VMesh")]
        public CGModuleInputSlot InVMeshArray = new CGModuleInputSlot();

        [HideInInspector]
        [InputSlotInfo(typeof(CGSpots), Array = true, Name = "Spots", Optional = true)]
        public CGModuleInputSlot InSpots = new CGModuleInputSlot();

        /// <summary>
        /// The created meshes at the last update (call to Refresh). This list is not maintained outside of module updates, so if a user manually deletes one of the created meshes, its entry in this list will still be there, but with a null value (since deleted objects are equal to null in Unity's world) 
        /// </summary>
        [SerializeField, CGResourceCollectionManager("Mesh", ShowCount = true)]
        private CGMeshResourceCollection m_MeshResources = new CGMeshResourceCollection();

        #region ### Serialized Fields ###

        [Tab("General")]

        [Tooltip("Merge meshes")]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        [SerializeField]
        private bool m_Combine;

        [SerializeField]
        [Tooltip("Warning: this operation is Editor only (not available in builds) and CPU intensive.\nWhen combining multiple meshes, the UV2s are by default kept as is. Use this option to recompute them by uwrapping the combined mesh.")]
        [FieldCondition(nameof(m_Combine), true, Action = ConditionalAttribute.ActionEnum.Show)]
        private bool unwrapUV2;

        [Tooltip("When Combine is true, combine only meshes sharing the same index\nIs used only if Spots are provided")]
#if UNITY_EDITOR
        [FieldCondition(nameof(m_Combine), true, false, Action = ConditionalAttribute.ActionEnum.Show)]
        [FieldCondition(nameof(CanUpdate), true, false, ConditionalAttribute.OperatorEnum.AND, nameof(CanGroupMeshes), true, false, Action = ConditionalAttribute.ActionEnum.Enable)]
#endif
        [SerializeField]
        private bool m_GroupMeshes = false;

        [SerializeField]
        [Tooltip("If true, the generated mesh will have normals")]
        private bool includeNormals = true;

        [SerializeField]
        [Tooltip("If true, the generated mesh will have tangents")]
        private bool includeTangents = false;

        [SerializeField, HideInInspector]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private CGYesNoAuto m_AddNormals = CGYesNoAuto.Auto;

        [SerializeField, HideInInspector]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private CGYesNoAuto m_AddTangents = CGYesNoAuto.No;

        [SerializeField, HideInInspector]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private bool m_AddUV2 = true;

        [SerializeField]
        [Tooltip("If enabled, meshes will have the Static flag set, and will not be generated/updated in Play Mode")]
        [FieldCondition(nameof(CanModifyStaticFlag), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private bool m_MakeStatic;

        [SerializeField]
        [Tooltip("The Layer of the created game object")]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        [Layer]
        private int m_Layer;

        [SerializeField]
        [Tooltip("The Tag of the created game object")]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        [Tag]
        private string m_Tag = DefaultTag;

        [Tab("Renderer")]
        [SerializeField]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private bool m_RendererEnabled = true;

        [SerializeField]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private ShadowCastingMode m_CastShadows = ShadowCastingMode.On;

        [SerializeField]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private bool m_ReceiveShadows = true;

        [SerializeField]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private LightProbeUsage m_LightProbeUsage = LightProbeUsage.BlendProbes;

        [HideInInspector]
        [SerializeField]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private bool m_UseLightProbes = true;


        [SerializeField]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private ReflectionProbeUsage m_ReflectionProbes = ReflectionProbeUsage.BlendProbes;
        [SerializeField]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private Transform m_AnchorOverride;

        [Tab("Collider")]
        [SerializeField]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private CGColliderEnum m_Collider = CGColliderEnum.Mesh;

        [FieldCondition(nameof(m_Collider), CGColliderEnum.Mesh)]
        [SerializeField]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private bool m_Convex;

        [SerializeField]
        [FieldCondition(nameof(EnableIsTrigger), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private bool m_IsTrigger;

        [Tooltip("Options used to enable or disable certain features in Collider mesh cooking. See Unity's MeshCollider.cookingOptions for more details")]
        [FieldCondition(nameof(m_Collider), CGColliderEnum.Mesh)]
        [SerializeField]
        [EnumFlag]
        [FieldCondition(nameof(CanUpdate), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        private MeshColliderCookingOptions m_CookingOptions = CGMeshResource.EverMeshColliderCookingOptions;

#if UNITY_EDITOR
        [FieldCondition(nameof(CanUpdate), true, false, ConditionalAttribute.OperatorEnum.AND, "m_Collider", CGColliderEnum.None, true, Action = ConditionalAttribute.ActionEnum.Enable)]
#endif
        [Label("Auto Update")]
        [SerializeField]
        private bool m_AutoUpdateColliders = true;

#if UNITY_EDITOR
        [FieldCondition(nameof(CanUpdate), true, false, ConditionalAttribute.OperatorEnum.AND, "m_Collider", CGColliderEnum.None, true, Action = ConditionalAttribute.ActionEnum.Enable)]
#endif
        [SerializeField]
        private PhysicsMaterial m_Material;

        #endregion

        #region ### Public Properties ###

        #region --- General ---
        public bool Combine
        {
            get { return m_Combine; }
            set
            {
                if (m_Combine != value)
                    m_Combine = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// Warning: this operation is Editor only (not available in builds) and CPU intensive
        /// When combining multiple meshes, the UV2s are by default kept as is. Use this option to recompute them by uwrapping the combined mesh.
        /// </summary>
        public bool UnwrapUV2
        {
            get
            {
#if UNITY_EDITOR == false
            DTLog.Log("[Curvy] UV2 Unwrapping is not available outside of the editor", this);    
#endif
                return unwrapUV2;
            }
            set
            {
#if UNITY_EDITOR == false
            DTLog.Log("[Curvy] UV2 Unwrapping is not available outside of the editor", this);    
#endif
                if (unwrapUV2 != value)
                {
                    unwrapUV2 = value;
                    Dirty = true;
                }
            }
        }

        /// <summary>
        /// When Combine is true, combine only meshes sharing the same index.
        /// </summary>
        /// <remarks>Is used only if <see cref="InSpots"/> is not empty</remarks>
        /// <remarks>Please keep in mind that meshes provided by the <see cref="DeformMesh"/> module do not share the same index.</remarks>
        public bool GroupMeshes
        {
            get { return m_GroupMeshes; }
            set
            {
                if (m_GroupMeshes != value)
                    m_GroupMeshes = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// If true, the generated mesh will have normals
        /// </summary>
        public bool IncludeNormals
        {
            get { return includeNormals; }
            set
            {
                if (includeNormals != value)
                    includeNormals = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// If true, the generated mesh will have tangents
        /// </summary>
        public bool IncludeTangents
        {
            get { return includeTangents; }
            set
            {
                if (includeTangents != value)
                    includeTangents = value;
                Dirty = true;
            }
        }

        [Obsolete("Use IncludeNormals instead")]
        public CGYesNoAuto AddNormals
        {
            get { return m_AddNormals; }
            set
            {
                if (m_AddNormals != value)
                    m_AddNormals = value;
                Dirty = true;
            }
        }

        [Obsolete("Use IncludeTangents instead")]
        public CGYesNoAuto AddTangents
        {
            get { return m_AddTangents; }
            set
            {
                if (m_AddTangents != value)
                    m_AddTangents = value;
                Dirty = true;
            }
        }

        [Obsolete("UV2 is now always added")]
        public bool AddUV2
        {
            get { return m_AddUV2; }
            set
            {
                if (m_AddUV2 != value)
                    m_AddUV2 = value;
                Dirty = true;
            }
        }


        public int Layer
        {
            get { return m_Layer; }
            set
            {
                int v = Mathf.Clamp(value, 0, 32);
                if (m_Layer != v)
                    m_Layer = v;
                Dirty = true;
            }
        }

        public string Tag
        {
            get { return m_Tag; }
            set
            {
                if (m_Tag != value)//TODO get rid of value comparison in all properties, or at least add the Dirty = true line inside the if
                    m_Tag = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// If enabled, meshes will have the Static flag set, and will not be generated/updated in Play Mode. This is to maintain Unity optimizations done in Edit Mode to static GameObjects.
        /// </summary>
        /// <remarks>Do not set to true if you rely on Play Mode generated meshes</remarks>
        public bool MakeStatic
        {
            get { return m_MakeStatic; }
            set
            {
                if (m_MakeStatic != value)
                    m_MakeStatic = value;
                Dirty = true;
            }
        }
        #endregion

        #region --- Renderer ---
        public bool RendererEnabled
        {
            get { return m_RendererEnabled; }
            set
            {
                if (m_RendererEnabled != value)
                    m_RendererEnabled = value;
                Dirty = true;
            }
        }

        public ShadowCastingMode CastShadows
        {
            get { return m_CastShadows; }
            set
            {
                if (m_CastShadows != value)
                    m_CastShadows = value;
                Dirty = true;
            }
        }

        public bool ReceiveShadows
        {
            get { return m_ReceiveShadows; }
            set
            {
                if (m_ReceiveShadows != value)
                    m_ReceiveShadows = value;
                Dirty = true;
            }
        }

        public bool UseLightProbes
        {
            get { return m_UseLightProbes; }
            set
            {
                if (m_UseLightProbes != value)
                    m_UseLightProbes = value;
                Dirty = true;
            }
        }

        public LightProbeUsage LightProbeUsage
        {
            get { return m_LightProbeUsage; }
            set
            {
                if (m_LightProbeUsage != value)
                    m_LightProbeUsage = value;
                Dirty = true;
            }
        }


        public ReflectionProbeUsage ReflectionProbes
        {
            get { return m_ReflectionProbes; }
            set
            {
                if (m_ReflectionProbes != value)
                    m_ReflectionProbes = value;
                Dirty = true;
            }
        }

        public Transform AnchorOverride
        {
            get { return m_AnchorOverride; }
            set
            {
                if (m_AnchorOverride != value)
                    m_AnchorOverride = value;
                Dirty = true;
            }
        }

        #endregion

        #region --- Collider ---

        public CGColliderEnum Collider
        {
            get { return m_Collider; }
            set
            {
                if (m_Collider != value)
                    m_Collider = value;
                Dirty = true;
            }
        }

        public bool AutoUpdateColliders
        {
            get { return m_AutoUpdateColliders; }
            set
            {
                if (m_AutoUpdateColliders != value)
                    m_AutoUpdateColliders = value;
                Dirty = true;
            }
        }

        public bool Convex
        {
            get { return m_Convex; }
            set
            {
                if (m_Convex != value)
                    m_Convex = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// Is the created collider a trigger
        /// </summary>
        public bool IsTrigger
        {
            get { return m_IsTrigger; }
            set
            {
                if (m_IsTrigger != value)
                    m_IsTrigger = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// Options used to enable or disable certain features in Collider mesh cooking. See Unity's MeshCollider.cookingOptions for more details
        /// </summary>
        public MeshColliderCookingOptions CookingOptions
        {
            get { return m_CookingOptions; }
            set
            {
                if (m_CookingOptions != value)
                    m_CookingOptions = value;
                Dirty = true;
            }
        }

        public PhysicsMaterial Material
        {
            get { return m_Material; }
            set
            {
                if (m_Material != value)
                    m_Material = value;
                Dirty = true;
            }
        }

        #endregion

        /// <summary>
        /// The created meshes at the last update (call to Refresh). This list is not maintained outside of module updates, so if a user manually deletes one of the created meshes, its entry in this list will still be there, but with a null value (since deleted objects are equal to null in Unity's world) 
        /// </summary>
        public CGMeshResourceCollection Meshes
        {
            get { return m_MeshResources; }
        }

        /// <summary>
        /// Count of <see cref="Meshes"/>
        /// </summary>
        public int MeshCount
        {
            get { return Meshes.Count; }
        }

        public int VertexCount { get; private set; }

        #endregion

        #region ### Private Fields & Properties ###

        private readonly CGSpotComparer cgSpotComparer = new CGSpotComparer();


        private bool CanGroupMeshes
        {
            get
            {
                return (InSpots.IsLinked);
            }
        }

        private bool CanModifyStaticFlag
        {
            get
            {
#if UNITY_EDITOR
                return Application.isPlaying == false;
#else
                return false;
#endif
            }
        }

        private bool CanUpdate
        {
            get
            {
                return !Application.isPlaying || !MakeStatic;
            }
        }

        //Do not remove, used in FieldCondition in this file
        private bool EnableIsTrigger
        {
            get
            {
                return CanUpdate && (m_Collider != CGColliderEnum.Mesh || m_Convex);
            }
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            IncludeNormals = includeNormals;
            IncludeTangents = includeTangents;
#pragma warning disable 618
            AddNormals = m_AddNormals;
            AddTangents = m_AddTangents;
#pragma warning restore 618
            Collider = m_Collider;
            Dirty = true;
        }
#endif

        public override void Reset()
        {
            base.Reset();
            Combine = false;
            UnwrapUV2 = false;
            GroupMeshes = false;
            IncludeNormals = true;
            IncludeTangents = false;
#pragma warning disable 618
            AddNormals = CGYesNoAuto.Auto;
            AddTangents = CGYesNoAuto.No;
#pragma warning restore 618
            MakeStatic = false;
            Material = null;
            Layer = 0;
            Tag = DefaultTag;
            CastShadows = ShadowCastingMode.On;
            RendererEnabled = true;
            ReceiveShadows = true;
            UseLightProbes = true;
            LightProbeUsage = LightProbeUsage.BlendProbes;
            ReflectionProbes = ReflectionProbeUsage.BlendProbes;
            AnchorOverride = null;
            Collider = CGColliderEnum.Mesh;
            AutoUpdateColliders = true;
            Convex = false;
            IsTrigger = false;
#pragma warning disable 618
            AddUV2 = true;
#pragma warning restore 618
            CookingOptions = CGMeshResource.EverMeshColliderCookingOptions;
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public CreateMesh()
        {
            Version = "1";
        }

        public override bool DeleteAllOutputManagedResources()
        {
            bool result = base.DeleteAllOutputManagedResources();

            //delete all children
            int childCount = transform.childCount;
            //the following line is not prefect, since a module can have children that are not mesh resources, but I believe it is ok to assume so, worst case scenario in rare occasions there will be extra work done from the code that uses the "result" value. Best case scenario you are keeping the behaviour consistent with CreateGameObject module
            result |= childCount > 0;

            List<CGMeshResource> meshResources = new List<CGMeshResource>(childCount);
            List<Transform> nonMeshResourceChildren = new List<Transform>();

            for (int i = 0; i < childCount; i++)
            {
                Transform child = transform.GetChild(i);
                if (child.TryGetComponent(out CGMeshResource resource))
                    meshResources.Add(resource);
                else
                    nonMeshResourceChildren.Add(child);
            }

            //it might seem a good idea to not use meshResources, and just iterate through all children and delete them, but the deletion code can, depending on different on edit/play mode and prefab status, either delete instantly the object, delete it at the end of the frame, or not delete it at all, leading to the iteration logic having to handle all of those cases in deciding what should be the iteration index. I prefer to play it safe, and use the destructionTargets list
            foreach (CGMeshResource resource in meshResources)
                DeleteManagedResource("Mesh", resource);

            //we delete children that are not mesh resources to stay consistent with CreteGameObject module, that deletes all chidlren, and consistent with TryDeleteChildrenFromAssociatedPrefab. Such inconsistency with TryDeleteChildrenFromAssociatedPrefab might lead to that method loading the prefab asset at every update, since it will always detect the non mesh resource child, which will never be deleted by the this method.
            foreach (Transform child in nonMeshResourceChildren)
                child.gameObject.Destroy(false, true);

            VertexCount = 0;
            Meshes.Items.Clear();

            return result;
        }

        [Obsolete("Use DeleteAllOutputManagedResources instead")]
        public void Clear()
        {
            DeleteAllOutputManagedResources();
        }

        public override void Refresh()
        {
            base.Refresh();
            if (CanUpdate)
            {
                TryDeleteChildrenFromAssociatedPrefab();
                DeleteAllOutputManagedResources();

                List<CGVMesh> VMeshes = InVMeshArray.GetAllData<CGVMesh>(out bool isVMeshesDisposable);
                List<CGSpots> Spots = InSpots.GetAllData<CGSpots>(out bool isSpotsDisposable);

                SubArray<CGSpot>? flattenedSpotsArray = ToOneDimensionalArray(Spots, out bool isCopy);
                int vMeshesCount = VMeshes.Count;

                VertexCount = 0;
                Meshes.Items.Clear();

                if (vMeshesCount > 0 && (!InSpots.IsLinked || (flattenedSpotsArray != null && flattenedSpotsArray.Value.Count > 0)))
                {
                    if (flattenedSpotsArray != null && flattenedSpotsArray.Value.Count > 0)
                    {
                        SubArray<CGSpot> subArray = flattenedSpotsArray.Value;
                        for (int i = 0; i < subArray.Count; i++)
                        {
                            CGSpot spot = subArray.Array[i];
                            if (spot.Index >= vMeshesCount)
                            {
                                int correctedIndex = vMeshesCount - 1;
                                UIMessages.Add($"Spot index {spot.Index} references an non existing VMesh. There is/are only {vMeshesCount} valid input VMesh(es). An index of {correctedIndex} was used instead");
                                subArray.Array[i] = new CGSpot(correctedIndex, spot.Position, spot.Rotation, spot.Scale);
                            }
                        }
                        CreateSpotMeshes(VMeshes, flattenedSpotsArray.Value, Combine, isCopy, Meshes.Items);
                    }
                    else
                        CreateMeshes(VMeshes, Combine, Meshes.Items);
                }
                // Cleanup
                if (isCopy)
                    ArrayPools.CGSpot.Free(flattenedSpotsArray.Value);

                if (isVMeshesDisposable)
                {
                    VMeshes.ForEach(d => d.Dispose());
                }

                if (isSpotsDisposable)
                {
                    Spots.ForEach(d => d.Dispose());
                }

                // Update Colliders?
                if (AutoUpdateColliders)
                    UpdateColliders();
            }
            else
                UIMessages.Add("Make Static is enabled. This stops mesh generation in Play Mode, to maintain Unity optimizations done in Edit Mode to static GameObjects.");

            if (MakeStatic && CurvyGlobalManager.SaveGeneratorOutputs == false)
                UIMessages.Add("Make Static is incompatible with Preferences -> Curvy -> Save Generator Outputs being false.");
        }

        public void UpdateColliders()
        {
            List<CGMeshResource> meshResources = Meshes.Items;
            bool success = true;

            //Parallel mesh baking if needed
            if (Collider == CGColliderEnum.Mesh && meshResources.Count > 1)//do not bake if no mesh collider asked
            {
                SubArray<int> meshIds = ArrayPools.Int32.Allocate(meshResources.Count, false);
                for (var i = 0; i < meshResources.Count; i++)
                {
                    if (meshResources[i] == null)
                    {
#if CURVY_SANITY_CHECKS_PRIVATE
                        DTLog.LogError("[Curvy] A resource was null.", this);
#endif
                        meshIds.Array[i] = 0; //meshIds is allocated without being cleared, so set to 0 to avoid using the meshId from a previous call
                    }
                    else
                        meshIds.Array[i] = meshResources[i].Filter.sharedMesh.GetInstanceID();
                }

                Parallel.For(0, meshResources.Count, (i) =>
                {
                    Physics.BakeMesh(meshIds.Array[i], Convex);
                }
                );

                ArrayPools.Int32.Free(meshIds);
            }

            for (int r = 0; r < meshResources.Count; r++)
            {
                if (meshResources[r] == null)
                    continue;
                if (!meshResources[r].UpdateCollider(Collider, Convex, IsTrigger, Material, CookingOptions))
                    success = false;
            }
            if (!success)
                UIMessages.Add("Error setting collider!");
        }

        #region ISerializationCallbackReceiver implementation

        public void OnBeforeSerialize()
        {

        }

        public void OnAfterDeserialize()
        {
            if (String.IsNullOrEmpty(Version))
            {
                Version = "1";
#pragma warning disable 618
                IncludeNormals = AddNormals != CGYesNoAuto.No;
                IncludeTangents = AddTangents != CGYesNoAuto.No;
#pragma warning restore 618
            }
        }

        #endregion

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */

        private void CreateMeshes(List<CGVMesh> vMeshes, bool combine, [NotNull] List<CGMeshResource> createdMeshes)
        {
            if (combine && vMeshes.Count > 1)
            {
                CGVMesh curVMesh = new CGVMesh();
                curVMesh.MergeVMeshes(vMeshes, 0, vMeshes.Count - 1);
                WriteVMeshToMesh(curVMesh, createdMeshes);
            }
            else
                for (int index = 0; index < vMeshes.Count; index++)
                    WriteVMeshToMesh(vMeshes[index], createdMeshes);
        }

        private void CreateSpotMeshes(List<CGVMesh> vMeshes, SubArray<CGSpot> spots, bool combine, bool spotsIsACopy, [NotNull] List<CGMeshResource> createdMeshes)
        {
            int vmCount = vMeshes.Count;
            CGSpot spot;

            bool allocateNewSpotsArray = combine && GroupMeshes && spotsIsACopy == false;

            if (allocateNewSpotsArray)
                spots = ArrayPools.CGSpot.Clone(spots);

            if (combine)
            {
                if (GroupMeshes)
                    System.Array.Sort(spots.Array, 0, spots.Count, cgSpotComparer);

                spot = spots.Array[0];
                CGVMesh curVMesh = new CGVMesh(vMeshes[spot.Index]);
                if (spot.Position != Vector3.zero || spot.Rotation != Quaternion.identity || spot.Scale != Vector3.one)
                    curVMesh.TRS(spot.Matrix);
                for (int s = 1; s < spots.Count; s++)
                {
                    spot = spots.Array[s];
                    // Filter spot.index not in vMeshes[]
                    if (spot.Index > -1 && spot.Index < vmCount)
                    {
                        if (GroupMeshes && spot.Index != spots.Array[s - 1].Index)
                        { // write curVMesh 
                            WriteVMeshToMesh(curVMesh, createdMeshes);
                            curVMesh.Dispose();
                            curVMesh = new CGVMesh(vMeshes[spot.Index]);
                            if (!spot.Matrix.isIdentity)
                                curVMesh.TRS(spot.Matrix);
                        }
                        else
                        {
                            // Add new vMesh to curVMesh
                            //OPTIM use MergeVMeshes to merge everything at once
                            curVMesh.MergeVMesh(vMeshes[spot.Index], spot.Matrix);
                        }
                    }
                }
                WriteVMeshToMesh(curVMesh, createdMeshes);
                curVMesh.Dispose();
            }
            else
            {
                for (int s = 0; s < spots.Count; s++)
                {
                    spot = spots.Array[s];
                    // Filter spot.index not in vMeshes[]
                    if (spot.Index > -1 && spot.Index < vmCount)
                    {
                        CGMeshResource res = WriteVMeshToMesh(vMeshes[spot.Index], createdMeshes);
                        // Don't touch vertices, TRS Resource instead
                        if (spot.Position != Vector3.zero || spot.Rotation != Quaternion.identity || spot.Scale != Vector3.one)
                            spot.ToTransform(res.Filter.transform);
                    }
                }
            }

            if (allocateNewSpotsArray)
                ArrayPools.CGSpot.Free(spots);
        }

        /// <summary>
        /// create a mesh resource and copy vmesh data to the mesh!
        /// </summary>
        /// <param name="vmesh"></param>
        /// <param name="cgMeshResources"></param>
        private CGMeshResource WriteVMeshToMesh(CGVMesh vmesh, List<CGMeshResource> cgMeshResources)
        {
            CGMeshResource res = GetNewMesh(cgMeshResources.Count);
            cgMeshResources.Add(res);

            if (CanModifyStaticFlag)
                res.Filter.gameObject.isStatic = false;
            Mesh mesh = res.Prepare();
            res.gameObject.layer = Layer;
            res.gameObject.tag = Tag;
            vmesh.ToMesh(ref mesh, IncludeNormals, IncludeTangents);
            VertexCount += vmesh.Count;

            if (IncludeNormals && (vmesh.HasNormals == false || vmesh.HasPartialNormals))
                mesh.RecalculateNormals();
            if (IncludeTangents && (vmesh.HasTangents == false || vmesh.HasPartialTangents))
                mesh.RecalculateTangents();

            if (Combine && UnwrapUV2 && (vmesh.HasUV2))
#if UNITY_EDITOR
                UnityEditor.Unwrapping.GenerateSecondaryUVSet(mesh);
#else
            DTLog.Log("[Curvy] UV2 Unwrapping is not available outside of the editor", this);
#endif

#if CURVY_SANITY_CHECKS_PRIVATE
            if (IncludeNormals)
            {
                Vector3[] meshNormals = mesh.normals;
                for (var i = 0; i < meshNormals.Length; i++)
                {
                    if (meshNormals[i] == Vector3.zero)
                    {
                        Assert.IsTrue(false);
                    }
                }
            }

            if (includeTangents)
            {
                Vector4[] meshTangents = mesh.tangents;
                for (var i = 0; i < meshTangents.Length; i++)
                {
                    if (meshTangents[i] == Vector4.zero)
                    {
                        Assert.IsTrue(false);
                    }
                }
            }
#endif

            // Reset Transform
            res.Filter.transform.localPosition = Vector3.zero;
            res.Filter.transform.localRotation = Quaternion.identity;
            res.Filter.transform.localScale = Vector3.one;
            if (CanModifyStaticFlag)
                res.Filter.gameObject.isStatic = MakeStatic;
            res.Renderer.sharedMaterials = vmesh.GetMaterials();


            return res;
        }

        /// <summary>
        /// gets a new mesh resource and increase mCurrentMeshCount
        /// </summary>
        private CGMeshResource GetNewMesh(int currentMeshCount)
        {
            // Reuse existing resources
            CGMeshResource r = ((CGMeshResource)AddManagedResource("Mesh", "", currentMeshCount));

            // Renderer settings
            r.Renderer.shadowCastingMode = CastShadows;
            r.Renderer.enabled = RendererEnabled;
            r.Renderer.receiveShadows = ReceiveShadows;
            r.Renderer.lightProbeUsage = LightProbeUsage;
            r.Renderer.reflectionProbeUsage = ReflectionProbes;

            r.Renderer.probeAnchor = AnchorOverride;

            if (!r.ColliderMatches(Collider))
                r.RemoveCollider();

            return r;
        }


        private static SubArray<CGSpot>? ToOneDimensionalArray(List<CGSpots> spotsList, out bool arrayIsCopy)
        {
            SubArray<CGSpot>? output;
            switch (spotsList.Count)
            {
                case 1:
                    if (spotsList[0] != null)
                    {
                        output = new SubArray<CGSpot>(spotsList[0].Spots.Array, spotsList[0].Spots.Count);
                        arrayIsCopy = false;
                    }
                    else
                    {
                        output = null;
                        arrayIsCopy = false;
                    }
                    break;
                case 0:
                    output = null;
                    arrayIsCopy = false;
                    break;
                default:
                    {
                        output = ArrayPools.CGSpot.Allocate(spotsList.Where(s => s != null).Sum(s => s.Count));
                        arrayIsCopy = true;

                        CGSpot[] array = output.Value.Array;
                        int destinationIndex = 0;
                        foreach (CGSpots cgSpots in spotsList)
                        {
                            if (cgSpots == null)
                                continue;
                            Array.Copy(cgSpots.Spots.Array, 0, array, destinationIndex, cgSpots.Spots.Count);
                            destinationIndex += cgSpots.Spots.Count;
                        }
                    }

                    break;
            }

            return output;
        }

        /*! \endcond */

        #endregion

        #region Resources saving

        /// <summary>
        /// Saves the created meshes to asset files
        /// </summary>
        /// <remarks>Will open a file selector to select where to save the files</remarks>
        public void SaveToAsset()
        {
#if UNITY_EDITOR
            string assetPathBase = InquireAssetPath();
            if (string.IsNullOrEmpty(assetPathBase))
                return;

            List<Component> managedResources;
            GetManagedResources(out managedResources, out _);
            for (int i = 0; i < managedResources.Count; i++)
            {
                Mesh instantiatedMesh = Instantiate(managedResources[i].GetComponent<MeshFilter>().sharedMesh);
                string assetPath = ResourceFilesSavingState.GetAssetFullName(assetPathBase, i, managedResources.Count);
                SaveMeshToAsset(instantiatedMesh, assetPath);
            }

            UnityEditor.AssetDatabase.Refresh();
#else
            throw new InvalidOperationException("Operation available only in editor");
#endif
        }

        /// <summary>
        /// Saves a copy of the generated mesh(es) as Asset(s), then creates a GameObject, outside of the generator, referencing those mesh assets. This way the created GameObject can be made part of a prefab without issues
        /// </summary>
        /// <remarks>Will open a file selector to select where to save the files</remarks>
        public void SaveToSceneAndAsset()
        {
#if UNITY_EDITOR
            string assetPathBase = InquireAssetPath();
            if (string.IsNullOrEmpty(assetPathBase))
                return;

            try
            {
                GetManagedResources(out List<Component> managedResources, out _);
                resourceFilesSavingState = new ResourceFilesSavingState(assetPathBase, 0, managedResources.Count);

                SaveToScene();
                UnityEditor.AssetDatabase.Refresh();
            }
            finally
            {
                resourceFilesSavingState = null;
            }
#else
            throw new InvalidOperationException("Operation available only in editor");
#endif
        }

        protected override GameObject SaveResourceToScene(Component managedResource, Transform newParent)
        {
            MeshFilter meshFilter = managedResource.GetComponent<MeshFilter>();
            Mesh instantiatedMesh = Instantiate(meshFilter.sharedMesh);

            GameObject duplicateGameObject = managedResource.gameObject.DuplicateGameObject(newParent);
            duplicateGameObject.name = managedResource.name;
            duplicateGameObject.GetComponent<CGMeshResource>().Destroy(false, true);
            duplicateGameObject.GetComponent<MeshFilter>().sharedMesh = instantiatedMesh;
#if UNITY_EDITOR
            if (resourceFilesSavingState != null)
            {
                string assetName = resourceFilesSavingState.GetAssetFullName();
                SaveMeshToAsset(instantiatedMesh, assetName);
                resourceFilesSavingState.IncrementResourceIndex();
            }
#endif
            return duplicateGameObject;
        }

#if UNITY_EDITOR

        /// <summary>
        /// This state is used when saving both to the scene and the assets. The way this operation was implemented makes it a scene saving that saves to te assets folder too based on the state of this class's instance
        /// </summary>
        private class ResourceFilesSavingState
        {
            private string AssetsBasePath { get; }
            private int ResourceIndex { get; set; }
            private int ResourcesCount { get; }

            public ResourceFilesSavingState(string assetsBasePath, int resourceIndex, int resourcesCount)
            {
                this.AssetsBasePath = assetsBasePath;
                this.ResourceIndex = resourceIndex;
                this.ResourcesCount = resourcesCount;
            }
            public ResourceFilesSavingState()
            {
            }

            public void IncrementResourceIndex()
            {
                ResourceIndex++;
            }

            public string GetAssetFullName()
            {
                return GetAssetFullName(AssetsBasePath, ResourceIndex, ResourcesCount);
            }

            public static string GetAssetFullName(string assetsBasePath, int resourceIndex, int resourcesCount)
            {
                return resourcesCount > 1
                    ? $"{assetsBasePath}-{resourceIndex:D3}.asset"
                    : $"{assetsBasePath}.asset";
            }

        }

        private ResourceFilesSavingState resourceFilesSavingState;

        private static void SaveMeshToAsset(Mesh meshInstance, string assetPath)
        {
            UnityEditor.AssetDatabase.DeleteAsset(assetPath);
            UnityEditor.AssetDatabase.CreateAsset(meshInstance, assetPath);
        }

        private string InquireAssetPath()
        {
            return UnityEditor.EditorUtility.SaveFilePanelInProject("Save Assets", ModuleName, "mesh", "Save Mesh(es) as").Replace(".mesh", "");
        }
#endif
    }

    #endregion

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/CreateMesh.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/CreatePathLineRenderer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 359139391bbb6514fb37f1b3fb94879c
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Linq;
using FluffyUnderware.Curvy.Pools;
using FluffyUnderware.DevTools;
using FluffyUnderware.Curvy.Utils;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Create/Path Line Renderer", ModuleName = "Create Path Line Renderer", Description = "Feeds a Line Renderer with a Path")]
    [HelpURL(CurvySpline.DOCLINK + "cgcreatepathlinerenderer")]
    public class CreatePathLineRenderer : CGModule
    {

        [HideInInspector]
        [InputSlotInfo(typeof(CGPath), DisplayName = "Rasterized Path")]
        public CGModuleInputSlot InPath = new CGModuleInputSlot();

        #region ### Serialized Fields ###

        public LineRenderer LineRenderer
        {
            get
            {
                if (mLineRenderer == null)
                    mLineRenderer = GetComponent<LineRenderer>();
                return mLineRenderer;
            }
        }

        #endregion

        private LineRenderer mLineRenderer;

        #region ### Unity Callbacks ###
        /*! \cond UNITY */
        protected override void Awake()
        {
            base.Awake();
            createLR();
        }
        /*! \endcond */
        #endregion

        #region ### Module Overrides ###

        public override void Refresh()
        {
            base.Refresh();
            CGPath path = InPath.GetData<CGPath>(out bool isDisposable);
#if UNITY_5_6_OR_NEWER
            if (path != null)
            {
                LineRenderer.positionCount = path.Positions.Count;
                LineRenderer.SetPositions(path.Positions.Array);
            }
            else
                LineRenderer.positionCount = 0;
#else
            if (path != null)
            {
                LineRenderer.numPositions = path.Position.Length;
                for (int v = 0; v < path.Position.Length; v++)
                    LineRenderer.SetPosition(v, path.Position[v]);
            }
            else
                LineRenderer.numPositions = 0;
#endif
            if(isDisposable)
                path.Dispose();

        }

        // Called when a module's state changes (Link added/removed, Active toggles etc..)
        //public override void OnStateChange()
        //{
        //    base.OnStateChange();
        //}

        // Called after a module was copied to a template
        //public override void OnTemplateCreated() 
        //{
        //	base.OnTemplateCreated();
        //}


        #endregion

        private void createLR()
        {
            if (LineRenderer == null)
            {
                mLineRenderer = gameObject.AddComponent<LineRenderer>();
                mLineRenderer.useWorldSpace = false;
#if UNITY_5_6_OR_NEWER
                mLineRenderer.textureMode = LineTextureMode.Tile;
#endif
                mLineRenderer.sharedMaterial = CurvyUtility.GetDefaultMaterial();
            }
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/CreatePathLineRenderer.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/DebugRasterizedPath.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f2099f374214cd943a9b522e8887c453
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    /// <summary>
    /// Shows the tangents and orientation of a path
    /// </summary>
    [ModuleInfo("Debug/Rasterized Path", ModuleName = "Debug Rasterized Path", Description = "Shows the tangents and orientation of a rasterized path")]
    [HelpURL(CurvySpline.DOCLINK + "cgdebugrasterizedpath")]
    public class DebugRasterizedPath : CGModule
    {

        [HideInInspector]
        [InputSlotInfo(typeof(CGPath), DisplayName = "Rasterized Path")]
        public CGModuleInputSlot InPath = new CGModuleInputSlot();

        /// <summary>
        /// Display the normal at each one of the path's points
        /// </summary>
        [Tooltip("Display the normal at each one of the path's points")]
        public bool ShowNormals = true;
        /// <summary>
        /// Display the orientation at each one of the path's points
        /// </summary>
        [Tooltip("Display the orientation at each one of the path's points")]
        public bool ShowOrientation = true;

        #region ### Module Overrides ###


        public override void Reset()
        {
            base.Reset();
            ShowNormals = ShowOrientation = true;
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/DebugRasterizedPath.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/DebugVMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 057c96da40c092343886bcef75fde4c4
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Debug/VMesh", ModuleName = "Debug VMesh")]
    [HelpURL(CurvySpline.DOCLINK + "cgdebugvmesh")]
    public class DebugVMesh : CGModule
    {
        [HideInInspector]
        [InputSlotInfo(typeof(CGVMesh), Name = "VMesh")]
        public CGModuleInputSlot InData = new CGModuleInputSlot();

        #region ### Serialized Fields ###

        [Tab("General")]
        public bool ShowVertices;
        public bool ShowVertexID;
        public bool ShowUV;

        #endregion

        #region ### Public Properties ###
        #endregion

        #region ### Private Fields & Properties ###
        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */
        public override void Reset()
        {
            base.Reset();
            ShowVertices = false;
            ShowVertexID = false;
            ShowUV = false;
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###
        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */


        /*! \endcond */
        #endregion






    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/DebugVMesh.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/DebugVolume.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b3ffa9a202f99b745a2a3d9a2619ffb3
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;


namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Debug/Volume", ModuleName = "Debug Volume")]
    [HelpURL(CurvySpline.DOCLINK + "cgdebugvolume")]
    public class DebugVolume : CGModule
    {
        [HideInInspector]
        [InputSlotInfo(typeof(CGVolume), Name = "Volume")]
        public CGModuleInputSlot InData = new CGModuleInputSlot();

        #region ### Serialized Fields ###

        [Tab("General")]
        public bool ShowPathSamples = true;
        public bool ShowCrossSamples = true;
        [FieldCondition(nameof(ShowCrossSamples), true)]
        [IntRegion(RegionIsOptional = true)]
        public IntRegion LimitCross = new IntRegion(0, 0);
        public bool ShowNormals = false;
        public bool ShowIndex = false;
        public bool ShowMap = false;
        public Color PathColor = Color.white;
        public Color VolumeColor = Color.gray;
        public Color NormalColor = Color.yellow;
        [Tab("Interpolate")]
        public bool Interpolate;
        [RangeEx(-1, 1, "Path")]
        public float InterpolatePathF;
        [RangeEx(-1, 1, "Cross")]
        public float InterpolateCrossF;
        #endregion

        #region ### Public Properties ###
        #endregion

        #region ### Private Fields & Properties ###
        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Dirty = true;
        }

        public override void Reset()
        {
            base.Reset();
            ShowPathSamples = true;
            ShowCrossSamples = true;
            LimitCross = new IntRegion(0, 0);
            ShowNormals = false;
            ShowIndex = false;
            ShowMap = false;
            PathColor = Color.white;
            VolumeColor = Color.gray;
            NormalColor = Color.yellow;
            Interpolate = false;
            InterpolatePathF = 0;
            InterpolateCrossF = 0;
        }
#endif

        /*! \endcond */
        #endregion

        #region ### Public Methods ###
        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */


        /*! \endcond */
        #endregion


    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/DebugVolume.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/DeformMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 484a3e33b7b7161448fd889c96322e73
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.Curvy.Pools;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    /// <summary>
    /// Deforms a mesh following a path
    /// </summary>
    [ModuleInfo("Modifier/Deform Mesh", ModuleName = "Deform Mesh", Description = "Deform a mesh following a path")]
    [HelpURL(CurvySpline.DOCLINK + "cgdeformmesh")]
    public class DeformMesh : ScalingModule
    {
        [HideInInspector]
        [InputSlotInfo(typeof(CGVMesh), Array = true, Name = "VMesh")]
        public CGModuleInputSlot InVMeshes = new CGModuleInputSlot();

        [HideInInspector]
        [InputSlotInfo(typeof(CGPath), Name = "Path", DisplayName = "Volume/Rasterized Path")]
        public CGModuleInputSlot InPath = new CGModuleInputSlot();

        [HideInInspector]
        [InputSlotInfo(typeof(CGSpots), Array = true, Name = "Spots", Optional = true)]
        public CGModuleInputSlot InSpots = new CGModuleInputSlot();

        [HideInInspector]
        [OutputSlotInfo(typeof(CGVMesh), Name = "VMesh", Array = true)]
        public CGModuleOutputSlot OutVMeshes = new CGModuleOutputSlot();

        [HideInInspector]
        [OutputSlotInfo(typeof(CGSpots), Array = true, Name = "Spots")]
        public CGModuleOutputSlot OutSpots = new CGModuleOutputSlot();

        [Tab("General")]
        [SerializeField]
        [Tooltip("Stretch the meshes to make them fit the end of the path")]
        private bool stretchToEnd;

        private readonly ThreadPoolWorker<CGSpot> threadWorker = new ThreadPoolWorker<CGSpot>();

        /// <summary>
        /// Stretch the meshes to make them fit the end of the path
        /// </summary>
        public bool StretchToEnd
        {
            get => stretchToEnd;
            set
            {
                if (stretchToEnd != value)
                {
                    stretchToEnd = value;
                    Dirty = true;
                }
            }
        }

        #region ### Module Overrides ###

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Dirty = true;
        }
#endif

        public override void Reset()
        {
            base.Reset();
            StretchToEnd = false;
        }

        public override void Refresh()
        {
            base.Refresh();

            CGPath path = InPath.GetData<CGPath>(out bool isPathDisposable);
            List<CGVMesh> inputMeshes = InVMeshes.GetAllData<CGVMesh>(out bool isMeshesDisposable);

            CGData[] outVMeshesData;
            CGSpots outSpotsData;
            if (inputMeshes.Count != 0)
            {
                List<CGSpots> inputSpots = InSpots.GetAllData<CGSpots>(out bool isSpotsDisposable);
                SubArray<CGSpot>? inputSpotsArray = ToOneDimensionalArray(inputSpots, out bool isCopy);
                bool thereAreSpots = inputSpotsArray.HasValue && inputSpotsArray.Value.Count != 0;

                if (thereAreSpots)
                {
                    int spotsCount = inputSpotsArray.Value.Count;
                    CGSpot[] spotsArray = inputSpotsArray.Value.Array;

                    //inputs verification
                    bool areSpotsValid = true;
                    for (int i = 0; i < spotsCount; i++)
                    {
                        int meshIndex = spotsArray[i].Index;
                        if (meshIndex < 0 || meshIndex >= inputMeshes.Count)
                        {
                            UIMessages.Add($"Spot #{i} has an invalid Index value of '{meshIndex}'. An index can't be greater or equal to the number of input Meshes, which is '{inputMeshes.Count}'");
                            areSpotsValid = false;
                            break;
                        }
                    }

                    //the actual processing
                    if (areSpotsValid)
                    {
                        CGVMesh[] outputMeshes = new CGVMesh[spotsCount];
                        SubArray<CGSpot> outputSpots = ArrayPools.CGSpot.Allocate(spotsCount);

                        ScaleParameters scaleParameters = new ScaleParameters(ScaleMode, ScaleReference, ScaleUniform, ScaleOffset, ScaleX, ScaleY, ScaleMultiplierX, ScaleMultiplierY);

                        DeformMeshes(inputMeshes, inputSpotsArray.Value, outputSpots, outputMeshes, path, StretchToEnd, threadWorker, scaleParameters);

                        outVMeshesData = outputMeshes;
                        outSpotsData = new CGSpots(outputSpots);
                    }
                    else
                    {
                        outVMeshesData = Array.Empty<CGVMesh>();
                        outSpotsData = new CGSpots();
                    }
                }
                else
                {
                    outVMeshesData = Array.Empty<CGVMesh>();
                    outSpotsData = new CGSpots();
                }

                if (isCopy)
                    ArrayPools.CGSpot.Free(inputSpotsArray.Value);

                if (isSpotsDisposable)
                    inputSpots.ForEach(s => s.Dispose());
            }
            else
            {
                outVMeshesData = Array.Empty<CGVMesh>();
                outSpotsData = new CGSpots();
            }

            OutVMeshes.SetData(outVMeshesData);
            OutSpots.SetData(outSpotsData);

            if (isPathDisposable)
                path.Dispose();

            if (isMeshesDisposable)
                inputMeshes.ForEach(m => m.Dispose());
        }
        #endregion

        #region public methods



        /// <summary>
        /// Deforms multiple <see cref="CGVMesh"/>s following a path 
        /// </summary>
        /// <param name="inputMeshes">The list of meshes the <see cref="CGSpot.Index"/> of <paramref name="inputSpots"/> refer to</param>
        /// <param name="inputSpots">The <see cref="CGSpot"/>s defining the transform and mesh to use as inputs</param>
        /// <param name="outputSpots">Should have the same <see cref="ArraySegment{T}.Count"/> as <paramref name="inputMeshes"/></param>
        /// <param name="outputMeshes">Should have the same <see cref="ArraySegment{T}.Count"/> as <paramref name="inputMeshes"/></param>
        /// <param name="path">A path defining how the meshes should be deformed</param>
        /// <param name="stretchToEnd">see <see cref="StretchToEnd"/></param>
        /// <param name="threadPoolWorker">An instance of <see cref="ThreadPoolWorker{CGSpot}"/> to run the mesh deformation on</param>
        public static void DeformMeshes([NotNull] List<CGVMesh> inputMeshes, SubArray<CGSpot> inputSpots, SubArray<CGSpot> outputSpots, [NotNull] CGVMesh[] outputMeshes, [NotNull] CGPath path, bool stretchToEnd, ThreadPoolWorker<CGSpot> threadPoolWorker)
        {
            ScaleParameters scaleParameters = new ScaleParameters(ScaleMode.Simple,
                CGReferenceMode.Self,
                true,
                0,
                1,
                1,
                AnimationCurve.Linear(0, 1, 1, 1),
                AnimationCurve.Linear(0, 1, 1, 1));

            DeformMeshes(inputMeshes,
                inputSpots,
                outputSpots,
                outputMeshes,
                path,
                stretchToEnd,
                threadPoolWorker,
                scaleParameters);
        }

        /// <summary>
        /// Deforms multiple <see cref="CGVMesh"/>s following a path 
        /// </summary>
        /// <param name="inputMeshes">The list of meshes the <see cref="CGSpot.Index"/> of <paramref name="inputSpots"/> refer to</param>
        /// <param name="inputSpots">The <see cref="CGSpot"/>s defining the transform and mesh to use as inputs</param>
        /// <param name="outputSpots">Should have the same <see cref="ArraySegment{T}.Count"/> as <paramref name="inputMeshes"/></param>
        /// <param name="outputMeshes">Should have the same <see cref="ArraySegment{T}.Count"/> as <paramref name="inputMeshes"/></param>
        /// <param name="path">A path defining how the meshes should be deformed</param>
        /// <param name="stretchToEnd">see <see cref="StretchToEnd"/></param>
        /// <param name="threadPoolWorker">An instance of <see cref="ThreadPoolWorker{CGSpot}"/> to run the mesh deformation on</param>
        /// <param name="scaleParameters"> Defines what scaling to apply to the deformed mesh</param>
        public static void DeformMeshes([NotNull] List<CGVMesh> inputMeshes, SubArray<CGSpot> inputSpots, SubArray<CGSpot> outputSpots, [NotNull] CGVMesh[] outputMeshes, [NotNull] CGPath path, bool stretchToEnd, ThreadPoolWorker<CGSpot> threadPoolWorker, ScaleParameters scaleParameters)
        {
            if (inputMeshes == null) throw new ArgumentNullException(nameof(inputMeshes));
            if (outputMeshes == null) throw new ArgumentNullException(nameof(outputMeshes));
            if (path == null) throw new ArgumentNullException(nameof(path));
            if (inputSpots.Count == 0) throw new ArgumentException("input spots should have at least one element", nameof(inputSpots));
            if (inputMeshes.Count == 0) throw new ArgumentException("input meshes should have at least one element", nameof(inputMeshes));

            bool isCurveEvaluationNeeded = IsCurveEvaluationNeeded(scaleParameters);

            CGSpot[] spotsArray = inputSpots.Array;
            int spotsCount = inputSpots.Count;

#if CURVY_SANITY_CHECKS
            for (int i = 0; i < spotsCount; i++)
            {
                int meshIndex = spotsArray[i].Index;

                Assert.IsTrue(meshIndex >= 0);
                Assert.IsTrue(meshIndex < inputMeshes.Count);
            }
#endif

            //prepare output meshes
            for (int i = 0; i < spotsCount; i++)
            {
                CGVMesh inputMesh = inputMeshes[spotsArray[i].Index];

                CGVMesh outputMesh = new CGVMesh(inputMesh.Count, inputMesh.HasUV, inputMesh.HasUV2, inputMesh.HasNormals, inputMesh.HasTangents);

                if (inputMesh.HasUV)
                    Array.Copy(inputMesh.UVs.Array, 0,
                        outputMesh.UVs.Array, 0, inputMesh.UVs.Count);

                if (inputMesh.HasUV2)
                    Array.Copy(inputMesh.UV2s.Array, 0,
                    outputMesh.UV2s.Array, 0, inputMesh.UV2s.Count);

                outputMesh.SubMeshes = new CGVSubMesh[inputMesh.SubMeshes.Length];
                for (int j = 0; j < inputMesh.SubMeshes.Length; j++)
                    outputMesh.SubMeshes[j] = new CGVSubMesh(inputMesh.SubMeshes[j]);

                outputMeshes[i] = outputMesh;
            }

            //if StretchToEnd, prepare stretching data
            float smallestVertexDistance;
            float stretchingAdditionalDistanceRatio; //How much additional distance should be applied per unit of distance
            if (stretchToEnd)
            {
                //smallestVertexDistance
                {
                    CGSpot firstSpot = spotsArray[0];
                    float firstSpotDistance = GetSpotDistance(path, firstSpot.Position, path.Positions.Array, path.Count - 1, path.RelativeDistances.Array, path.Length);

                    CGVMesh firstMesh = inputMeshes[firstSpot.Index];
                    if (firstMesh.Count == 0)
                    {
                        smallestVertexDistance = 0;
                    }
                    else
                    {
                        SubArray<int> firstMeshSortedVertexIndices = firstMesh.GetCachedSortedVertexIndices();
                        smallestVertexDistance = firstSpotDistance +
                                                 firstMesh.Vertices.Array[firstMeshSortedVertexIndices.Array[0]].z;
                    }

                }

                float largestVertexDistance;
                {
                    CGSpot lastSpot = spotsArray[spotsCount - 1];
                    float lastSpotDistance = GetSpotDistance(path, lastSpot.Position, path.Positions.Array, path.Count - 1, path.RelativeDistances.Array, path.Length);

                    CGVMesh lastMesh = inputMeshes[lastSpot.Index];
                    if (lastMesh.Count == 0)
                    {
                        largestVertexDistance = 0;
                    }
                    else
                    {
                        SubArray<int> lastMeshSortedVertexIndices = lastMesh.GetCachedSortedVertexIndices();
                        largestVertexDistance = lastSpotDistance +
                                                lastMesh.Vertices.Array[lastMeshSortedVertexIndices.Array[lastMesh.Vertices.Count - 1]].z;
                    }
                }

                float deltaDistances = (largestVertexDistance - smallestVertexDistance);
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(deltaDistances >= 0);
#endif
                stretchingAdditionalDistanceRatio = deltaDistances > 0 ? (path.Length - largestVertexDistance) / deltaDistances : 0;
            }
            else
            {
                smallestVertexDistance = stretchingAdditionalDistanceRatio = Single.NaN;
            }

            //OPTIM Replace this action with one that is created at instance creation. This action had to take all the parameters needed, this way you avoid the compiler automatically creating a class for the captured parameters, which will be automatically instantiated at each call

            //the action that does the mesh deformation for a specific spot
            Action<CGSpot, int, int> action = (spot, spotIndex, elementsCount) =>
             {
                 //path
                 int pathPointsCount = path.Count;
                 Vector3[] pathDirections = path.Directions.Array;
                 Vector3[] pathNormals = path.Normals.Array;
                 float[] pathRelativeDistances = path.RelativeDistances.Array;
                 Vector3[] pathPoints = path.Positions.Array;

                 //input mesh
                 CGVMesh inputMesh = inputMeshes[spot.Index];
                 Vector3[] inputMeshVertices = inputMesh.Vertices.Array;
                 Vector3[] inputMeshNormals = inputMesh.NormalsList.Array;
                 Vector4[] inputMeshTangents = inputMesh.TangentsList.Array;
                 int verticesCount = inputMesh.Vertices.Count;
                 int normalsCount = inputMesh.NormalsList.Count;
                 int tangentsCount = inputMesh.TangentsList.Count;
                 int[] sortedInputVertexIndices = inputMesh.GetCachedSortedVertexIndices().Array;


                 //output mesh
                 CGVMesh outputMesh = outputMeshes[spotIndex];
                 Vector3[] outputMeshVertices = outputMesh.Vertices.Array;
                 Vector3[] outputMeshNormals = outputMesh.NormalsList.Array;
                 Vector4[] outputMeshTangents = outputMesh.TangentsList.Array;

                 outputMesh.Name = inputMesh.Name;

                 int maxIndex = pathPointsCount - 1;
                 float pathLength = path.Length;
                 float inversePathLength = 1 / pathLength;

                 Vector3 spotPosition = spot.Position;
                 Vector3 spotScale = spot.Scale;
                 float spotZScale = spot.Scale.z;
                 float inverseSpotXScale = 1 / spot.Scale.x;
                 float inverseSpotYScale = 1 / spot.Scale.y;
                 float inverseSpotZScale = 1 / spot.Scale.z;
                 float spotPositionX = spotPosition.x;
                 float spotPositionY = spotPosition.y;
                 float spotPositionZ = spotPosition.z;

                 float spotDistance = GetSpotDistance(path, spotPosition, pathPoints, maxIndex, pathRelativeDistances, pathLength);

                 //update index to make the create mesh module use the right mesh from the meshes array
                 outputSpots.Array[spotIndex] = new CGSpot(spotIndex, spotPosition, Quaternion.identity, spotScale);

                 float previousZ = float.NaN;
                 Vector2 previousScale = Vector3.zero;
                 Vector3 previousPositionOnPathMeshSpace = Vector3.zero;
                 //The following numbers are computed at each rotation multiplication. I compute them only once and store them
                 float previousDeltaRotationMultiplication_precomputedNumber_4 = float.NaN;
                 float previousDeltaRotationMultiplication_precomputedNumber_5 = float.NaN;
                 float previousDeltaRotationMultiplication_precomputedNumber_6 = float.NaN;
                 float previousDeltaRotationMultiplication_precomputedNumber_7 = float.NaN;
                 float previousDeltaRotationMultiplication_precomputedNumber_8 = float.NaN;
                 float previousDeltaRotationMultiplication_precomputedNumber_9 = float.NaN;
                 float previousDeltaRotationMultiplication_precomputedNumber_10 = float.NaN;
                 float previousDeltaRotationMultiplication_precomputedNumber_11 = float.NaN;
                 float previousDeltaRotationMultiplication_precomputedNumber_12 = float.NaN;

                 for (int coupleIndex = 0; coupleIndex < verticesCount; coupleIndex++)
                 {
                     int sortedVertexIndex = sortedInputVertexIndices[coupleIndex];
                     Vector3 vertexPosition = inputMeshVertices[sortedVertexIndex];

                     Vector2 vertexPositionDelta;
                     {
                         vertexPositionDelta.x = vertexPosition.x;
                         vertexPositionDelta.y = vertexPosition.y;
                     }

                     Vector2 scale;
                     Vector3 positionOnPathMeshSpace;
                     //The following numbers are computed at each rotation multiplication. I compute them only once and store them
                     float formulaNumber_4;
                     float formulaNumber_5;
                     float formulaNumber_6;
                     float formulaNumber_7;
                     float formulaNumber_8;
                     float formulaNumber_9;
                     float formulaNumber_10;
                     float formulaNumber_11;
                     float formulaNumber_12;

                     float currentZ = vertexPosition.z;
                     if (coupleIndex > 0 && previousZ == currentZ)
                     {
                         positionOnPathMeshSpace = previousPositionOnPathMeshSpace;
                         scale = previousScale;
                         formulaNumber_4 = previousDeltaRotationMultiplication_precomputedNumber_4;
                         formulaNumber_5 = previousDeltaRotationMultiplication_precomputedNumber_5;
                         formulaNumber_6 = previousDeltaRotationMultiplication_precomputedNumber_6;
                         formulaNumber_7 = previousDeltaRotationMultiplication_precomputedNumber_7;
                         formulaNumber_8 = previousDeltaRotationMultiplication_precomputedNumber_8;
                         formulaNumber_9 = previousDeltaRotationMultiplication_precomputedNumber_9;
                         formulaNumber_10 = previousDeltaRotationMultiplication_precomputedNumber_10;
                         formulaNumber_11 = previousDeltaRotationMultiplication_precomputedNumber_11;
                         formulaNumber_12 = previousDeltaRotationMultiplication_precomputedNumber_12;
                     }
                     else
                     {
                         int vertexFIndex;
                         float vertexFFragment;
                         {
                             float vertexF;
                             {
                                 float vertexDistance = spotDistance + vertexPosition.z * spotZScale;
                                 if (stretchToEnd)
                                 {
                                     vertexDistance += (vertexDistance - smallestVertexDistance) * stretchingAdditionalDistanceRatio;
                                 }

                                 //inlined version of path.DistanceToF()
                                 vertexF = vertexDistance * inversePathLength;

                                 if (path.Seamless)
                                 {
                                     while (vertexF < 0)
                                         vertexF++;
                                     while (vertexF > 1)
                                         vertexF--;
                                 }
                                 else
                                 {
                                     if (vertexF < 0)
                                         vertexF = 0;
                                     else if (vertexF > 1)
                                         vertexF = 1;
                                 }
                             }

                             //Inlined version of path.GetFIndex
                             {
                                 vertexFIndex = CurvyUtility.InterpolationSearch(pathRelativeDistances, pathPointsCount, vertexF);

                                 if (vertexFIndex == maxIndex)
                                 {
                                     vertexFIndex -= 1;
                                     vertexFFragment = 1;
                                 }
                                 else
                                     vertexFFragment = (vertexF - pathRelativeDistances[vertexFIndex]) / (pathRelativeDistances[vertexFIndex + 1] - pathRelativeDistances[vertexFIndex]);
                             }
                         }

                         {
                             int nextIndex = Math.Min(vertexFIndex + 1, maxIndex);

                             Vector3 positionOnPath = Vector3.LerpUnclamped(pathPoints[vertexFIndex], pathPoints[nextIndex], vertexFFragment);

                             switch (scaleParameters.ScaleMode)
                             {
                                 case ScaleMode.Advanced:
                                     if (isCurveEvaluationNeeded)
                                     {
                                         float relativeDistance = GetRelativeDistance(vertexFIndex,
                                             scaleParameters.ScaleReference,
                                             path.RelativeDistances,
                                             path.SourceRelativeDistances);

                                         lock (scaleParameters)
                                         {
                                             scale = GetAdvancedScale(relativeDistance,
                                                 scaleParameters.ScaleOffset,
                                                 scaleParameters.ScaleUniform,
                                                 scaleParameters.ScaleX,
                                                 scaleParameters.ScaleMultiplierX,
                                                 scaleParameters.ScaleY,
                                                 scaleParameters.ScaleMultiplierY);
                                         }
                                     }
                                     else
                                     {
                                         scale = GetSimpleScale(scaleParameters.ScaleUniform,
                                             scaleParameters.ScaleX,
                                             scaleParameters.ScaleY);
                                     }

                                     break;
                                 case ScaleMode.Simple:
                                     scale = GetSimpleScale(scaleParameters.ScaleUniform,
                                         scaleParameters.ScaleX,
                                         scaleParameters.ScaleY);
                                     break;
                                 default:
                                     throw new ArgumentOutOfRangeException();
                             }

                             positionOnPathMeshSpace.x = (positionOnPath.x - spotPositionX) * inverseSpotXScale;
                             positionOnPathMeshSpace.y = (positionOnPath.y - spotPositionY) * inverseSpotYScale;
                             positionOnPathMeshSpace.z = (positionOnPath.z - spotPositionZ) * inverseSpotZScale;

                             Quaternion indexRotation = Quaternion.LookRotation(pathDirections[vertexFIndex], pathNormals[vertexFIndex]);
                             Quaternion nextIndexRotation = Quaternion.LookRotation(pathDirections[nextIndex], pathNormals[nextIndex]);
                             Quaternion deltaRotation = (Quaternion.LerpUnclamped(indexRotation, nextIndexRotation, vertexFFragment));

                             float formulaNumber_1 = deltaRotation.x * 2f;
                             float formulaNumber_2 = deltaRotation.y * 2f;
                             float formulaNumber_3 = deltaRotation.z * 2f;
                             formulaNumber_4 = deltaRotation.x * formulaNumber_1;
                             formulaNumber_5 = deltaRotation.y * formulaNumber_2;
                             formulaNumber_6 = deltaRotation.z * formulaNumber_3;
                             formulaNumber_7 = deltaRotation.x * formulaNumber_2;
                             formulaNumber_8 = deltaRotation.x * formulaNumber_3;
                             formulaNumber_9 = deltaRotation.y * formulaNumber_3;
                             formulaNumber_10 = deltaRotation.w * formulaNumber_1;
                             formulaNumber_11 = deltaRotation.w * formulaNumber_2;
                             formulaNumber_12 = deltaRotation.w * formulaNumber_3;

                         }

                         previousZ = currentZ;
                         previousScale = scale;
                         previousPositionOnPathMeshSpace = positionOnPathMeshSpace;
                         previousDeltaRotationMultiplication_precomputedNumber_4 = formulaNumber_4;
                         previousDeltaRotationMultiplication_precomputedNumber_5 = formulaNumber_5;
                         previousDeltaRotationMultiplication_precomputedNumber_6 = formulaNumber_6;
                         previousDeltaRotationMultiplication_precomputedNumber_7 = formulaNumber_7;
                         previousDeltaRotationMultiplication_precomputedNumber_8 = formulaNumber_8;
                         previousDeltaRotationMultiplication_precomputedNumber_9 = formulaNumber_9;
                         previousDeltaRotationMultiplication_precomputedNumber_10 = formulaNumber_10;
                         previousDeltaRotationMultiplication_precomputedNumber_11 = formulaNumber_11;
                         previousDeltaRotationMultiplication_precomputedNumber_12 = formulaNumber_12;

                     }

                     //Optimized version of outputMeshVertex[vertexShitIndex] = positionOnPathMeshSpace + (deltaRotation * scale * vertexPositionDelta);
                     {
                         Vector3 outputVertex;
                         {
                             outputVertex.x = positionOnPathMeshSpace.x +
                                 (1.0f - (formulaNumber_5 + formulaNumber_6)) * scale.x * vertexPositionDelta.x
                                  + (formulaNumber_7 - formulaNumber_12) * scale.y * vertexPositionDelta.y;
                             //deleted the following because vertexPositionDelta.z is zero: + (formulaNumber_8 + formulaNumber_11) * vertexPositionDelta.z;
                             outputVertex.y = positionOnPathMeshSpace.y +
                                 (formulaNumber_7 + formulaNumber_12) * scale.x * vertexPositionDelta.x
                                   + (1.0f - (formulaNumber_4 + formulaNumber_6)) * scale.y * vertexPositionDelta.y;
                             //deleted the following because vertexPositionDelta.z is zero: + (formulaNumber_9 - formulaNumber_10) * vertexPositionDelta.z;
                             outputVertex.z = positionOnPathMeshSpace.z +
                                 (formulaNumber_8 - formulaNumber_11) * scale.x * vertexPositionDelta.x
                                  + (formulaNumber_9 + formulaNumber_10) * scale.y * vertexPositionDelta.y;
                             //deleted the following because vertexPositionDelta.z is zero: + (1.0f - (formulaNumber_4 + formulaNumber_5)) * vertexPositionDelta.z;
                         }

                         outputMeshVertices[sortedVertexIndex] = outputVertex;
                     }

                     if (normalsCount > sortedVertexIndex)
                     {
                         //Optimized version of outputMeshNormal[vertexShitIndex] = deltaRotation * inputMeshNormal[vertexShitIndex];
                         Vector3 outputNormal;
                         {
                             Vector3 inputNormal = inputMeshNormals[sortedVertexIndex];

                             outputNormal.x = (1.0f - (formulaNumber_5 + formulaNumber_6)) * inputNormal.x + (formulaNumber_7 - formulaNumber_12) * inputNormal.y + (formulaNumber_8 + formulaNumber_11) * inputNormal.z;
                             outputNormal.y = (formulaNumber_7 + formulaNumber_12) * inputNormal.x + (1.0f - (formulaNumber_4 + formulaNumber_6)) * inputNormal.y + (formulaNumber_9 - formulaNumber_10) * inputNormal.z;
                             outputNormal.z = (formulaNumber_8 - formulaNumber_11) * inputNormal.x + (formulaNumber_9 + formulaNumber_10) * inputNormal.y + (1.0f - (formulaNumber_4 + formulaNumber_5)) * inputNormal.z;
                         }

                         outputMeshNormals[sortedVertexIndex] = outputNormal;
                     }


                     if (tangentsCount > sortedVertexIndex)
                     {
                         //Optimized version of outputMeshTangents[vertexShitIndex] = deltaRotation * inputMeshTangents[vertexShitIndex];
                         Vector4 outputMeshTangent;
                         {
                             Vector4 inputTangent = inputMeshTangents[sortedVertexIndex];

                             outputMeshTangent.x = (1.0f - (formulaNumber_5 + formulaNumber_6)) * inputTangent.x + (formulaNumber_7 - formulaNumber_12) * inputTangent.y + (formulaNumber_8 + formulaNumber_11) * inputTangent.z;
                             outputMeshTangent.y = (formulaNumber_7 + formulaNumber_12) * inputTangent.x + (1.0f - (formulaNumber_4 + formulaNumber_6)) * inputTangent.y + (formulaNumber_9 - formulaNumber_10) * inputTangent.z;
                             outputMeshTangent.z = (formulaNumber_8 - formulaNumber_11) * inputTangent.x + (formulaNumber_9 + formulaNumber_10) * inputTangent.y + (1.0f - (formulaNumber_4 + formulaNumber_5)) * inputTangent.z;
                             outputMeshTangent.w = inputTangent.w;
                         }
                         outputMeshTangents[sortedVertexIndex] = outputMeshTangent;
                     }
                 }
             };

            threadPoolWorker.ParallelFor(action, spotsArray, spotsCount);
        }

        private static bool IsCurveEvaluationNeeded(ScaleParameters scaleParameters)
        {
            bool evaluateTranslationMultiplier;
            {
                switch (scaleParameters.ScaleMode)
                {
                    case ScaleMode.Simple:
                        evaluateTranslationMultiplier = false;
                        break;
                    case ScaleMode.Advanced:
                        evaluateTranslationMultiplier = scaleParameters.ScaleUniform ? scaleParameters.ScaleMultiplierX.ValueIsOne() == false : scaleParameters.ScaleMultiplierX.ValueIsOne() == false || scaleParameters.ScaleMultiplierY.ValueIsOne() == false;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
            return evaluateTranslationMultiplier;
        }

        #endregion

        private static float GetSpotDistance(CGPath path, Vector3 spotPosition, Vector3[] pathPoints, int maxIndex, float[] pathRelativeDistances, float pathLength)
        {
            float spotDistance;
            {
                int spotRelativeDistanceIndex;
                CurvyUtility.GetNearestPointIndex(spotPosition, pathPoints, path.Positions.Count, out spotRelativeDistanceIndex, out float fragment);
                int nextIndex = Math.Min(spotRelativeDistanceIndex + 1, maxIndex);
                spotDistance = Mathf.LerpUnclamped(pathRelativeDistances[spotRelativeDistanceIndex], pathRelativeDistances[nextIndex], fragment) * pathLength;
            }
            return spotDistance;
        }

        private static SubArray<CGSpot>? ToOneDimensionalArray(List<CGSpots> spotsList, out bool arrayIsCopy)
        {
            SubArray<CGSpot>? output;
            switch (spotsList.Count)
            {
                case 1:
                    if (spotsList[0] != null)
                    {
                        output = new SubArray<CGSpot>(spotsList[0].Spots.Array, spotsList[0].Spots.Count);
                        arrayIsCopy = false;
                    }
                    else
                    {
                        output = null;
                        arrayIsCopy = false;
                    }
                    break;
                case 0:
                    output = null;
                    arrayIsCopy = false;
                    break;
                default:
                    {
                        output = ArrayPools.CGSpot.Allocate(spotsList.Where(s => s != null).Sum(s => s.Count));
                        arrayIsCopy = true;

                        CGSpot[] array = output.Value.Array;
                        int destinationIndex = 0;
                        foreach (CGSpots cgSpots in spotsList)
                        {
                            if (cgSpots == null)
                                continue;
                            Array.Copy(cgSpots.Spots.Array, 0, array, destinationIndex, cgSpots.Spots.Count);
                            destinationIndex += cgSpots.Spots.Count;
                        }
                    }

                    break;
            }

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(arrayIsCopy == false || output.HasValue);
#endif

            return output;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/DeformMesh.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/GameObjectToMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7773b5e28f4f8ca48a528baec6332880
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using JetBrains.Annotations;
using UnityEngine;
using UnityEngine.Rendering;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    /// <summary>
    /// Creates <see cref="CGVMesh"/>s from the meshes of GameObjects
    /// </summary>
    [ModuleInfo("Convert/GameObject To Mesh", ModuleName = "GameObject To Mesh", Description = "Converts GameObjects to Volume Meshes")]
    [HelpURL(CurvySpline.DOCLINK + "cggameobject2mesh")]
    public class GameObjectToMesh : CGModule
    {
        /// <summary>
        /// Input Game Objects
        /// </summary>
        [HideInInspector]
        [InputSlotInfo(typeof(CGGameObject), Array = true)]
        public CGModuleInputSlot InGameObjects = new CGModuleInputSlot();

        /// <summary>
        /// Output Volume Meshes
        /// </summary>
        [HideInInspector]
        [OutputSlotInfo(typeof(CGVMesh), Array = true)]
        public CGModuleOutputSlot OutVMesh = new CGModuleOutputSlot();


        #region ### Serialized Fields ###
        [SerializeField]
        [Tooltip("Whether to include or not the meshes from the input Game Objects' children")]
        private bool useChildrenMeshes;

        [SerializeField]
        [Tooltip("Forces the output mesh to be centered")]
        private bool centerMesh;

        #endregion


        /// <summary>
        /// Whether to include or not the meshes from the input Game Objects' children
        /// </summary>
        public bool UseChildrenMeshes
        {
            get => useChildrenMeshes;
            set
            {
                if (value != useChildrenMeshes)
                {
                    useChildrenMeshes = value;
                    Dirty = true;
                }
            }
        }

        /// <summary>
        /// Forces the output mesh to be centered
        /// </summary>
        public bool CenterMesh
        {
            get => centerMesh;
            set
            {
                if (value != centerMesh)
                {
                    centerMesh = value;
                    Dirty = true;
                }
            }
        }

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Dirty = true;
        }
#endif

        public override void Reset()
        {
            base.Reset();
            UseChildrenMeshes = false;
            CenterMesh = false;
        }

        /*! \endcond */
        #endregion

        public override void Refresh()
        {
            base.Refresh();

            if (!OutVMesh.IsLinked)
                return;

            List<CGGameObject> gameObjects = InGameObjects.GetAllData<CGGameObject>(out bool isDataDisposable);
            CGVMesh[] data = new CGVMesh[gameObjects.Count];
            int total = 0;

            foreach (CGGameObject cgGameObject in gameObjects)
            {
                GameObject inputGameObject = cgGameObject.Object;

                if (inputGameObject == null)
                    continue;

                Mesh mesh;
                Material[] materials;
                if (UseChildrenMeshes)
                {
                    mesh = CombineMeshFilters(inputGameObject.GetComponentsInChildren<MeshFilter>(false),
                        out List<Material> materialsList,
                        inputGameObject.transform.worldToLocalMatrix,
                        UIMessages);

                    materials = materialsList.ToArray();
                }
                else
                {
                    MeshFilter meshFilter = inputGameObject.GetComponent<MeshFilter>();

                    if (meshFilter == null)
                    {
                        UIMessages.Add($"GameObject '{inputGameObject.name}' has no Mesh Filter associated to it. If you want to use Mesh Filters in its children, set the 'Use Children Mesh' parameter to true");
                        continue;
                    }

                    mesh = meshFilter.sharedMesh;

                    //materials;
                    {
                        MeshRenderer meshRenderer = meshFilter.gameObject.GetComponent<MeshRenderer>();
                        if (meshRenderer == null)
                        {
                            UIMessages.Add($"GameObject '{inputGameObject.name}' has a Mesh Filter but no Mesh Renderer associated to it. No material will be assigned to this mesh");
                            materials = new Material[0];
                        }
                        else
                            materials = meshRenderer.sharedMaterials;
                    }
                }
                Matrix4x4 trsMatrix = cgGameObject.Matrix;
                if (centerMesh)
                    trsMatrix *= Matrix4x4.Translate(-mesh.bounds.center);

                if (mesh.isReadable == false)
                {
                    UIMessages.Add($"GameObject '{inputGameObject.name}' has a mesh '{mesh.name}' that is not readable. Please set the 'Read/Write Enabled' parameter to true in the mesh model import settings");
                }

                data[total++] = new CGVMesh(mesh, materials, trsMatrix);
            }

            System.Array.Resize(ref data, total);
            OutVMesh.SetData(data);

            if (isDataDisposable)
            {
                foreach (CGGameObject cgGameObject in gameObjects)
                    cgGameObject.Dispose();
            }
        }

        /// <summary>
        /// Takes multiple <see cref="MeshFilter"/>s and return a mesh containing all their meshes, each one of them being assigned to a subMesh id.
        /// </summary>
        /// <param name="meshFilters">mesh filters from which the meshes to combine will be taken</param>
        /// <param name="materials">The materials for all the subMeshes.Those materials are taken from <see cref="MeshRenderer"/>s associated with the input <see cref="MeshFilter"/>s. If none, the material wiL be set to null</param>
        /// <param name="originTrs">The TRS matrix of the origin point</param>
        /// <param name="errorMessages">An array in which error messages will be added. Can be null</param>
        /// <returns></returns>
        public static Mesh CombineMeshFilters(MeshFilter[] meshFilters, out List<Material> materials, Matrix4x4 originTrs
            , [CanBeNull] List<string> errorMessages)
        {
            List<CombineInstance> combiners = new List<CombineInstance>(meshFilters.Length);
            materials = new List<Material>(meshFilters.Length);
            List<Material> tempMaterialsList = new List<Material>(1);

            int vertexTotalCount = 0;
            int vertexTotalCount_submeshDuplicate = 0;

            Mesh combinedMesh = new Mesh();

            foreach (MeshFilter meshFilter in meshFilters)
            {
                Mesh mesh = meshFilter.sharedMesh;

                if (mesh.isReadable == false)
                {
                    errorMessages?.Add($"Mesh '{mesh.name}' is not readable. Please set the 'Read/Write Enabled' parameter to true in the mesh model import settings.");
                }

                for (int i = 0; i < mesh.subMeshCount; i++)
                {
                    combiners.Add(new CombineInstance
                    {
                        transform = originTrs * meshFilter.transform.localToWorldMatrix,
                        mesh = mesh,
                        subMeshIndex = i
                    });
                    vertexTotalCount_submeshDuplicate += mesh.vertexCount;
                }
                vertexTotalCount += mesh.vertexCount;


                MeshRenderer meshRenderer = meshFilter.gameObject.GetComponent<MeshRenderer>();
                if (meshRenderer == null)
                {
                    errorMessages?.Add($"GameObject '{meshFilter.gameObject.name}' has a Mesh Filter but no Mesh Renderer associated to it. No material will be assigned to this mesh");
                    for (int k = 0; k < mesh.subMeshCount; k++)
                        materials.Add(null);
                }
                else
                {
                    meshRenderer.GetSharedMaterials(tempMaterialsList);
                    materials.AddRange(tempMaterialsList);
                }
            }

            //it seems there is a bug in CombineMeshes where it counts the vertex count for each submesh as equal to the whole mesh (in some circumstances, happened to me only at scene opening, go figure). So before the call to CombineMeshes, I set indexFormat accordingly, then after the call I set it to according to the real value of vertexTotalCount
            combinedMesh.indexFormat = vertexTotalCount_submeshDuplicate >= UInt16.MaxValue ? IndexFormat.UInt32 : IndexFormat.UInt16;
            combinedMesh.CombineMeshes(combiners.ToArray(), false);
            IndexFormat realIndexFormat = vertexTotalCount >= UInt16.MaxValue ? IndexFormat.UInt32 : IndexFormat.UInt16;
            if (combinedMesh.indexFormat != realIndexFormat)
                combinedMesh.indexFormat = realIndexFormat;

            return combinedMesh;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/GameObjectToMesh.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputGameObject.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a8c91f1c72cdd8f4b99ab43636b1db6b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;
using System.Collections.Generic;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Input/GameObjects", ModuleName = "Input GameObjects", Description = "")]
    [HelpURL(CurvySpline.DOCLINK + "cginputgameobject")]
    public class InputGameObject : CGModule
    {

        [HideInInspector]
        [OutputSlotInfo(typeof(CGGameObject), Array = true)]
        public CGModuleOutputSlot OutGameObject = new CGModuleOutputSlot();

        #region ### Serialized Fields ###

        [ArrayEx]
        [SerializeField]
        private List<CGGameObjectProperties> m_GameObjects = new List<CGGameObjectProperties>();

        #endregion

        #region ### Public Properties ###

        public List<CGGameObjectProperties> GameObjects
        {
            get { return m_GameObjects; }
        }

        public bool SupportsIPE
        {
            get { return false; }
        }

        #endregion

        #region ### Private Fields & Properties ###
        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */


#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Dirty = true;
        }
#endif

        public override void Reset()
        {
            base.Reset();
            GameObjects.Clear();
            Dirty = true;
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public override void Refresh()
        {
            base.Refresh();
            //OutVMesh
            if (OutGameObject.IsLinked)
            {
                CGGameObject[] data = new CGGameObject[GameObjects.Count];
                int total = 0;
                for (int i = 0; i < GameObjects.Count; i++)
                {
                    if (GameObjects[i].Object != null)
                        data[total++] = new CGGameObject(GameObjects[i]);
                }
                System.Array.Resize(ref data, total);
                OutGameObject.SetData(data);
            }

#if UNITY_EDITOR
            if (GameObjects.Exists(g => g.Object == null))
                UIMessages.Add("Missing Game Object input");
#endif
        }

        public override void OnTemplateCreated()
        {
            base.OnTemplateCreated();
            GameObjects.Clear();
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */


        /*! \endcond */
        #endregion



    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputGameObject.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4dcd8018d6d8ecf4f876101d6e13a763
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;
using System.Collections.Generic;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Input/Meshes", ModuleName = "Input Meshes", Description = "Create VMeshes")]
    [HelpURL(CurvySpline.DOCLINK + "cginputmesh")]
    public class InputMesh : CGModule, IExternalInput
    {

        [HideInInspector]
        [OutputSlotInfo(typeof(CGVMesh), Array = true)]
        public CGModuleOutputSlot OutVMesh = new CGModuleOutputSlot();

        #region ### Serialized Fields ###

        [SerializeField]
        [ArrayEx]
        private List<CGMeshProperties> m_Meshes = new List<CGMeshProperties>(new CGMeshProperties[] { new CGMeshProperties() });

        #endregion

        #region ### Public Properties ###

        public List<CGMeshProperties> Meshes
        {
            get { return m_Meshes; }
        }

        public bool SupportsIPE
        {
            get { return false; }
        }

        #endregion

        #region ### Private Fields & Properties ###
        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            foreach (CGMeshProperties m in Meshes)
                m.OnValidate();
            Dirty = true;
        }
#endif
        public override void Reset()
        {
            base.Reset();
            Meshes.Clear();
            Dirty = true;
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public override void Refresh()
        {
            base.Refresh();
            //OutVMesh
            if (OutVMesh.IsLinked)
            {
                CGVMesh[] data = new CGVMesh[Meshes.Count];
                int total = 0;
                for (int i = 0; i < Meshes.Count; i++)
                {
                    Mesh mesh = Meshes[i].Mesh;
                    if (mesh)
                    {
                        if (mesh.isReadable == false)
                        {
                            UIMessages.Add($"Input mesh '{mesh.name}' is not readable. Please set the 'Read/Write Enabled' parameter to true in the mesh model import settings");
                        }
                        data[total++] = new CGVMesh(Meshes[i]);
                    }
                }
                System.Array.Resize(ref data, total);
                OutVMesh.SetData(data);
            }

#if UNITY_EDITOR
            if (Meshes.Exists(m => m.Mesh == null))
                UIMessages.Add("Missing Mesh input");
#endif
        }



        public override void OnTemplateCreated()
        {
            base.OnTemplateCreated();
            Meshes.Clear();
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */


        /*! \endcond */
        #endregion


    }

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputMesh.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputSplinePath.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f1c5cbffa9299884494795e0d5c9e852
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.DevTools;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Input/Spline Path", ModuleName = "Input Spline Path", Description = "Spline Path")]
    [HelpURL(CurvySpline.DOCLINK + "cginputsplinepath")]
#pragma warning disable 618
    public class InputSplinePath : SplineInputModuleBase, IExternalInput, IOnRequestProcessing, IPathProvider
#pragma warning restore 618
    {
        [HideInInspector]
        [OutputSlotInfo(typeof(CGPath))]
        public CGModuleOutputSlot Path = new CGModuleOutputSlot();

        #region ### Serialized Fields ###

        [Tab("General", Sort = 0)]
        [SerializeField]
        [CGResourceManager("Spline")]
        [FieldCondition(nameof(m_Spline), null, false, ActionAttribute.ActionEnum.ShowWarning, "Missing Spline input")]
        private CurvySpline m_Spline;

        #endregion

        #region ### Public Properties ###

        public CurvySpline Spline
        {
            get { return m_Spline; }
            set
            {
                if (m_Spline != value)
                {
                    m_Spline = value;
                    OnSplineAssigned();
                    ValidateStartAndEndCps();
                }
                Dirty = true;
            }
        }

        public bool SupportsIPE { get { return false; } }

        #endregion

        #region ### IOnRequestModule ###

        public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
        {
            CGDataRequestRasterization raster = GetRequestParameter<CGDataRequestRasterization>(ref requests);
            CGDataRequestMetaCGOptions options = GetRequestParameter<CGDataRequestMetaCGOptions>(ref requests);
            if (options)
                UIMessages.Add("Meta CG Options are not supported for Path rasterization. They are supported only for Shape rasterization.");

            /*TODO the logic related to the whole OnSlotDataRequest and the CGModuleInputSlot.GetData<T>(params CGDataRequestParameter[] requests) is flawed, and here are the issues I see:
            Some modules need a CGDataRequestParameter[] as a parameter to properly work. This module is one of them. As you can see bellow, if such requeset array is null or empty, the method returns null. This raises some issues:
            - the code doesn't guide a person that wants to create a new module to help him know if he needs to send a CGDataRequestParameter[] to it's input slots or not.
            - the code silently returns null if the necessary data if the required CGDataRequestParameter[] is not there
            - slots who need CGDataRequestParameter[] and those who don't, even if they output the same CGData, can't connect to the same modules. For example, BuildVolumeSpots needs a rasterized CGPath (one that doesn't need CGDataRequestParameter[]) as an input, while BuildVolumeMesh nees a non rasterized CGPath as an input. So two different behaviors, but the same needed data. The user experience is confusing when he needs to connect such splines. For now there are different colors for slots names in those modules, but this isn't very clear to the user, and the code deciding which color to use use different conditions that the one deciding which modules can connect. So a change in one fo them needs always to be mirrored with a change in the othe one. This is very error prone.
            So the logic for connecting mdules should be hardly tied with the logic of sending the CGDataRequestParameter[] params, and the logic of UI display. This needs some work that I hope will be done sometime soon.
            */
            if (!raster || raster.RasterizedRelativeLength == 0)
                return null;

            CGData data = GetSplineData(Spline, true, raster, options);

            return new CGData[1] { data };
        }

        #endregion

        #region ### Public Methods ###

        //BUG? why is this absent from InputSplineShape?
        public override void OnTemplateCreated()
        {
            base.OnTemplateCreated();
            if (Spline && !IsManagedResource(Spline))
            {
                Spline = null;
            }
        }

        #endregion

        #region ### Protected members ###

        protected override CurvySpline InputSpline
        {
            get { return Spline; }
            set { Spline = value; }

        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputSplinePath.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputSplineShape.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e981787696c73b041a1adb21ea65264a
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Shapes;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Generator.Modules
{

    [ModuleInfo("Input/Spline Shape", ModuleName = "Input Spline Shape", Description = "Spline Shape")]
    [HelpURL(CurvySpline.DOCLINK + "cginputsplineshape")]
#pragma warning disable 618
    public class InputSplineShape : SplineInputModuleBase, IExternalInput, IOnRequestProcessing, IPathProvider
#pragma warning restore 618
    {
        [HideInInspector]
        [OutputSlotInfo(typeof(CGShape))]
        public CGModuleOutputSlot OutShape = new CGModuleOutputSlot();

        #region ### Serialized Fields ###

        [Tab("General", Sort = 0)]
        [SerializeField, CGResourceManager("Shape")]
        [FieldCondition(nameof(m_Shape), null, false, ActionAttribute.ActionEnum.ShowWarning, "Missing Shape input")]
        private CurvySpline m_Shape;

        #endregion

        #region ### Public Properties ###

        public CurvySpline Shape
        {
            get { return m_Shape; }
            set
            {
                if (m_Shape != value)
                {
                    m_Shape = value;
                    OnSplineAssigned();
                    ValidateStartAndEndCps();
                }
                Dirty = true;
            }
        }

        public bool SupportsIPE { get { return FreeForm; } }
        public bool FreeForm
        {
            get
            {
                return (Shape != null && Shape.GetComponent<CurvyShape>() == null);
            }
            set
            {
                if (Shape != null)
                {
                    CurvyShape sh = Shape.GetComponent<CurvyShape>();
                    if (value && sh != null)
                        sh.Delete();
                    else if (!value && sh == null)
                        Shape.gameObject.AddComponent<CSCircle>();
                }

            }
        }

        #endregion


        #region ### IOnRequestPath ###
        public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
        {
            CGDataRequestRasterization raster = GetRequestParameter<CGDataRequestRasterization>(ref requests);
            CGDataRequestMetaCGOptions options = GetRequestParameter<CGDataRequestMetaCGOptions>(ref requests);

            if (!raster || raster.RasterizedRelativeLength == 0)
                return null;
            CGData data = GetSplineData(Shape, false, raster, options);

            return new CGData[1] { data };

        }

        #endregion

        #region ### Public Methods ###

        public T SetManagedShape<T>() where T : CurvyShape2D
        {
            if (!Shape)
                Shape = (CurvySpline)AddManagedResource("Shape");

            CurvyShape sh = Shape.GetComponent<CurvyShape>();

            if (sh != null)
                sh.Delete();
            return Shape.gameObject.AddComponent<T>();
        }

        public void RemoveManagedShape()
        {
            if (Shape)
                DeleteManagedResource("Shape", Shape);
        }

        #endregion

        #region ### Protected members ###

        protected override CurvySpline InputSpline
        {
            get { return Shape; }
            set { Shape = value; }
        }

        protected override void OnSplineAssigned()
        {
            base.OnSplineAssigned();
            if (Shape)
                Shape.RestrictTo2D = true;
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputSplineShape.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputSpots.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c2fc8ee21afb5ef4e9ce554d0df97530
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Input/Spots", ModuleName = "Input Spots", Description = "Defines an array of placement spots")]
    [HelpURL(CurvySpline.DOCLINK + "cginputspots")]
    public class InputSpots : CGModule
    {

        [HideInInspector]
        [OutputSlotInfo(typeof(CGSpots))]
        public CGModuleOutputSlot OutSpots = new CGModuleOutputSlot();

        #region ### Serialized Fields ###

        [ArrayEx]
        [SerializeField]
        private List<CGSpot> m_Spots = new List<CGSpot>();

        #endregion

        #region ### Public Properties ###

        public List<CGSpot> Spots
        {
            get { return m_Spots; }
            set
            {
                if (m_Spots != value)
                    m_Spots = value;
                Dirty = true;
            }
        }

        #endregion

        #region ### Private Fields & Properties ###
        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected override void OnEnable()
        {
            base.OnEnable();
            Properties.MinWidth = 250;
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
        }
#endif

        public override void Reset()
        {
            base.Reset();
            Spots.Clear();
            Dirty = true;
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public override void Refresh()
        {
            base.Refresh();

            if (OutSpots.IsLinked)
            {
                OutSpots.SetData(new CGSpots(Spots));
            }
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */


        /*! \endcond */
        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputSpots.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputTransformSpots.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f1765478dede28e4c87d689860b74212
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.DevTools;
#if UNITY_EDITOR
using UnityEditor;
#endif


namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Input/Transform Spots", ModuleName = "Input Transform Spots", Description = "Defines an array of placement spots taken from existing Transforms")]
    [HelpURL(CurvySpline.DOCLINK + "cginputtransformspots")]
    public class InputTransformSpots : CGModule
    {
        [HideInInspector]
        [OutputSlotInfo(typeof(CGSpots))]
        public CGModuleOutputSlot OutSpots = new CGModuleOutputSlot();

        #region ### Serialized Fields ###

        [ArrayEx]
        [SerializeField]
        private List<TransformSpot> transformSpots = new List<TransformSpot>();

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// The input <see cref="TransformSpots"/>
        /// </summary>
        public List<TransformSpot> TransformSpots
        {
            get { return transformSpots; }
            set
            {
                if (transformSpots != value)
                    transformSpots = value;
                Dirty = true;
            }
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected override void OnEnable()
        {
            base.OnEnable();
            Properties.MinWidth = 250;
#if UNITY_EDITOR
            EditorApplication.update += EditorUpdate;
#endif
        }

        protected override void OnDisable()
        {
            base.OnDisable();
#if UNITY_EDITOR
            EditorApplication.update -= EditorUpdate;
#endif
        }

        public override void Reset()
        {
            base.Reset();
            TransformSpots.Clear();
            Dirty = true;
        }

        private void Update()
        {
            if (Dirty == false && OutSpots.Data != null && OutSpots.Data.Length != 0)
            {
                foreach (var keyValuePair in outputToInputDictionary)
                {
                    CGSpot cgSpot = keyValuePair.Key;
                    TransformSpot transformSpot = keyValuePair.Value;
                    if (cgSpot.Position != transformSpot.Transform.position)
                    {
                        Dirty = true;
                        return;
                    }
                }
            }
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public override void Refresh()
        {
            base.Refresh();

            if (OutSpots.IsLinked)
            {
                outputToInputDictionary.Clear();

                List<CGSpot> spots = TransformSpots.Where(s => s.Transform != null).Select(s =>
                {
                    CGSpot cgSpot = new CGSpot(s.Index, s.Transform.position, s.Transform.rotation, s.Transform.lossyScale);
                    outputToInputDictionary[cgSpot] = s;
                    return cgSpot;
                }).ToList();

                OutSpots.SetData(new CGSpots(spots));
            }

#if UNITY_EDITOR
            if (TransformSpots.Exists(s => s.Transform == null))
                UIMessages.Add("Missing Transform input");
#endif
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */

        private readonly Dictionary<CGSpot, TransformSpot> outputToInputDictionary = new Dictionary<CGSpot, TransformSpot>();

#if UNITY_EDITOR
        private void EditorUpdate()
        {
            if (Application.isPlaying == false)
                Update();
        }

#endif
        /*! \endcond */
        #endregion

        /// <summary>
        /// Similar to <see cref="CGSpot"/>, but instead of having a constant position/rotation/scale, it is taken from a Transform
        /// </summary>
        [System.Serializable]
        public struct TransformSpot : IEquatable<TransformSpot>
        {
            [SerializeField]
#pragma warning disable 649 //field is modified through InputTransformSpotsEditor, through Unity's serialization API
            private int index;
#pragma warning restore 649

            [SerializeField]
#pragma warning disable 649 //field is modified through InputTransformSpotsEditor, through Unity's serialization API
            private Transform transform;
#pragma warning restore 649

            /// <summary>
            /// The index of the object to place
            /// </summary>
            public int Index => index;

            /// <summary>
            /// The Transform from which the spot's position/rotation/scale should be taken
            /// </summary>
            public Transform Transform => transform;

            public bool Equals(TransformSpot other)
            {
                return index == other.index && Equals(transform, other.transform);
            }

            public override bool Equals(object obj)
            {
                return obj is TransformSpot other && Equals(other);
            }

            public override int GetHashCode()
            {
                unchecked
                {
                    return (index * 397) ^ (transform != null ? transform.GetHashCode() : 0);
                }
            }

            public static bool operator ==(TransformSpot left, TransformSpot right)
            {
                return left.Equals(right);
            }

            public static bool operator !=(TransformSpot left, TransformSpot right)
            {
                return !left.Equals(right);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/InputTransformSpots.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierMixPaths.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5b25376c289be4147bed2f4e7a7ec677
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Pools;
using ToolBuddy.Pooling.Pools;
using FluffyUnderware.DevTools;
using JetBrains.Annotations;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Modifier/Mix Paths", ModuleName = "Mix Paths", Description = "Interpolates between two paths")]
    [HelpURL(CurvySpline.DOCLINK + "cgmixpaths")]
#pragma warning disable 618
    public class ModifierMixPaths : CGModule, IOnRequestProcessing, IPathProvider
#pragma warning restore 618
    {
        [HideInInspector]
        [InputSlotInfo(typeof(CGPath), Name = "Path A")]
        public CGModuleInputSlot InPathA = new CGModuleInputSlot();

        [HideInInspector]
        [InputSlotInfo(typeof(CGPath), Name = "Path B")]
        public CGModuleInputSlot InPathB = new CGModuleInputSlot();

        [HideInInspector]
        [OutputSlotInfo(typeof(CGPath))]
        public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();

        #region ### Serialized Fields ###

        [SerializeField, RangeEx(-1, 1, Tooltip = "Mix between the paths. Values between -1 for Path A and 1 for Path B")]
        private float m_Mix;

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Defines how the result is interpolated. Values between -1 for Path A and 1 for Path B
        /// </summary>
        public float Mix
        {
            get { return m_Mix; }
            set
            {
                if (m_Mix != value)
                    m_Mix = value;
                Dirty = true;
            }
        }

        public bool PathIsClosed
        {
            get
            {
                return (IsConfigured) && InPathA.SourceSlot().PathProvider.PathIsClosed &&
                                        InPathB.SourceSlot().PathProvider.PathIsClosed;
            }
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected override void OnEnable()
        {
            base.OnEnable();
            Properties.MinWidth = 250;
            Properties.LabelWidth = 50;
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Mix = m_Mix;
        }
#endif
        public override void Reset()
        {
            base.Reset();
            Mix = 0;
        }

        /*! \endcond */
        #endregion

        #region ### IOnRequestProcessing ###
        public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
        {

            CGDataRequestRasterization raster = GetRequestParameter<CGDataRequestRasterization>(ref requests);
            if (!raster)
                return null;

            CGPath DataA = InPathA.GetData<CGPath>(out bool isADisposable, requests);
            CGPath DataB = InPathB.GetData<CGPath>(out bool isBDisposable, requests);

            CGPath data = MixPath(DataA, DataB, Mix, UIMessages);

            if (isADisposable)
                DataA.Dispose();
            if (isBDisposable)
                DataB.Dispose();

            return new CGData[1] { data };
        }
        #endregion

        #region ### Public Static Methods ###

        /// <summary>
        /// Returns the mixed path
        /// </summary>
        /// <param name="pathA"></param>
        /// <param name="pathB"></param>
        /// <param name="mix"> A value between -1 and 1. -1 will select the path with the most points. 1 will select the other </param>
        /// <param name="warningsContainer">Is filled with warnings raised by the mixing logic</param>
        /// <returns>The mixed path</returns>
        public static CGPath MixPath(CGPath pathA, CGPath pathB, float mix, [NotNull] List<string> warningsContainer)
        {
            if (pathA == null)
                return pathB;

            if (pathB == null)
                return pathA;

            int pathVertexCount = Mathf.Max(pathA.Count, pathB.Count);

            CGPath data = new CGPath();
            ModifierMixShapes.InterpolateShape(data, pathA, pathB, mix, warningsContainer);

            float interpolationTime = (mix + 1) * 0.5f;
            Assert.IsTrue(interpolationTime >= 0);
            Assert.IsTrue(interpolationTime <= 1);

            //BUG: Directions should be recomputed based on positions, and not interpolated. This is already done in the Recalculate() method called inside InterpolateShape() (line above), but Recalculate has a bug that makes it not compute Direction[0], so I kept the code bellow to recompute directions.
            //OPTIM avoid double computation of directions
            SubArray<Vector3> directions = ArrayPools.Vector3.Allocate(pathVertexCount);
            if (pathA.Count == pathVertexCount)
                for (int i = 0; i < pathVertexCount; i++)
                {
                    Vector3 bDirection;
                    {
                        float frag;
                        int idx = pathB.GetFIndex(pathA.RelativeDistances.Array[i], out frag);
                        bDirection = Vector3.SlerpUnclamped(pathB.Directions.Array[idx], pathB.Directions.Array[idx + 1], frag);
                    }

                    directions.Array[i] = Vector3.SlerpUnclamped(pathA.Directions.Array[i], bDirection, interpolationTime);

                }
            else
                for (int i = 0; i < pathVertexCount; i++)
                {
                    Vector3 aDirection;
                    {
                        float frag;
                        int idx = pathA.GetFIndex(pathB.RelativeDistances.Array[i], out frag);
                        aDirection = Vector3.SlerpUnclamped(pathA.Directions.Array[idx], pathA.Directions.Array[idx + 1], frag);
                    }

                    directions.Array[i] = Vector3.SlerpUnclamped(aDirection, pathB.Directions.Array[i], interpolationTime);
                }

            data.Directions = directions;
            return data;
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierMixPaths.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierMixShapes.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e9aaee9b270c0704a913452b9479f14b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.Curvy.Pools;
using ToolBuddy.Pooling.Pools;
using FluffyUnderware.DevTools;
using JetBrains.Annotations;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Modifier/Mix Shapes", ModuleName = "Mix Shapes", Description = "Interpolates between two shapes")]
    [HelpURL(CurvySpline.DOCLINK + "cgmixshapes")]
#pragma warning disable 618
    public class ModifierMixShapes : CGModule, IOnRequestProcessing, IPathProvider
#pragma warning restore 618
    {
        [HideInInspector]
        [InputSlotInfo(typeof(CGShape), Name = "Shape A")]
        public CGModuleInputSlot InShapeA = new CGModuleInputSlot();

        [HideInInspector]
        [InputSlotInfo(typeof(CGShape), Name = "Shape B")]
        public CGModuleInputSlot InShapeB = new CGModuleInputSlot();

        [HideInInspector]
        [OutputSlotInfo(typeof(CGShape))]
        public CGModuleOutputSlot OutShape = new CGModuleOutputSlot();

        #region ### Serialized Fields ###

        [SerializeField, RangeEx(-1, 1, Tooltip = "Mix between the shapes. Values between -1 for Shape A and 1 for Shape B")]
        private float m_Mix;

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Defines how the result is interpolated. Values between -1 for Shape A and 1 for Shape B
        /// </summary>
        public float Mix
        {
            get { return m_Mix; }
            set
            {
                if (m_Mix != value)
                    m_Mix = value;
                Dirty = true;
            }
        }

        public bool PathIsClosed
        {
            get
            {
                return (IsConfigured) && InShapeA.SourceSlot().PathProvider.PathIsClosed &&
                                        InShapeB.SourceSlot().PathProvider.PathIsClosed;
            }
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected override void OnEnable()
        {
            base.OnEnable();
            Properties.MinWidth = 250;
            Properties.LabelWidth = 50;
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Mix = m_Mix;
        }
#endif

        public override void Reset()
        {
            base.Reset();
            Mix = 0;
        }

        /*! \endcond */
        #endregion

        #region ### IOnRequestProcessing ###
        public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
        {
            CGDataRequestRasterization raster = GetRequestParameter<CGDataRequestRasterization>(ref requests);
            if (!raster)
                return null;

            CGShape DataA = InShapeA.GetData<CGShape>(out bool isADisposable, requests);
            CGShape DataB = InShapeB.GetData<CGShape>(out bool isBDisposable, requests);
            CGShape data = MixShapes(DataA, DataB, Mix, UIMessages);
            
            if(isADisposable)
                DataA.Dispose();
            if(isBDisposable)
                DataB.Dispose();
            
            return new CGData[1] { data };
        }

        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Returns the mixed shape
        /// </summary>
        /// <param name="shapeA"></param>
        /// <param name="shapeB"></param>
        /// <param name="mix"> A value between -1 and 1. -1 will select the shape with the most points. 1 will select the other </param>
        /// <param name="warningsContainer">Is filled with warnings raised by the mixing logic</param>
        /// <param name="ignoreWarnings"> If true, warningsContainer will not be filled with warnings</param>
        /// <returns> The mixed shape</returns>
        public static CGShape MixShapes(CGShape shapeA, CGShape shapeB, float mix, [NotNull] List<string> warningsContainer, bool ignoreWarnings = false)
        {
            if (shapeA == null)
                return shapeB;

            if (shapeB == null)
                return shapeA;

            CGShape data = new CGShape();
            InterpolateShape(data, shapeA, shapeB, mix, warningsContainer, ignoreWarnings);
            return data;
        }

        /// <summary>
        /// Returns the mixed shape
        /// </summary>
        /// <param name="resultShape">A shape which will be filled with the data of the mixed shape</param>
        /// <param name="mix"> A value between -1 and 1. -1 will select shape A. 1 will select shape B </param>
        /// <param name="shapeA"> One of the two interpolated shapes</param>
        /// <param name="shapeB"> One of the two interpolated shapes</param>
        /// <param name="warningsContainer">Is filled with warnings raised by the mixing logic</param>
        /// <param name="ignoreWarnings"> If true, warningsContainer will not be filled with warnings</param>
        /// <returns> The mixed shape</returns>
        public static void InterpolateShape([NotNull] CGShape resultShape, CGShape shapeA, CGShape shapeB, float mix, [NotNull] List<string> warningsContainer, bool ignoreWarnings = false)
        {
            float interpolationTime = (mix + 1) * 0.5f;
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(interpolationTime >= 0);
            Assert.IsTrue(interpolationTime <= 1);
#endif
            int shapeVertexCount = Mathf.Max(shapeA.Count, shapeB.Count);
            CGShape shapeWithMostVertices = shapeA.Count == shapeVertexCount
                ? shapeA
                : shapeB;

            SubArray<Vector3> positions = ArrayPools.Vector3.Allocate(shapeVertexCount);
            SubArray<Vector3> normals = ArrayPools.Vector3.Allocate(shapeVertexCount);

            var shapeBPositionsList = shapeB.Positions.Array;
            var shapeAPositionsList = shapeA.Positions.Array;
            Vector3[] positionsArray = positions.Array;
            var shapeANormalsList = shapeA.Normals.Array;
            var shapeBNormalsList = shapeB.Normals.Array;

            if (shapeWithMostVertices == shapeA)
                for (int i = 0; i < shapeVertexCount; i++)
                {
                    float frag;
                    int idx = shapeB.GetFIndex(shapeA.RelativeDistances.Array[i], out frag);

                    Vector3 bPosition;
                    {
                        bPosition.x = shapeBPositionsList[idx].x + (shapeBPositionsList[idx + 1].x - shapeBPositionsList[idx].x) * frag;
                        bPosition.y = shapeBPositionsList[idx].y + (shapeBPositionsList[idx + 1].y - shapeBPositionsList[idx].y) * frag;
                        bPosition.z = shapeBPositionsList[idx].z + (shapeBPositionsList[idx + 1].z - shapeBPositionsList[idx].z) * frag;
                    }

                    positionsArray[i].x = shapeAPositionsList[i].x + (bPosition.x - shapeAPositionsList[i].x) * interpolationTime;
                    positionsArray[i].y = shapeAPositionsList[i].y + (bPosition.y - shapeAPositionsList[i].y) * interpolationTime;
                    positionsArray[i].z = shapeAPositionsList[i].z + (bPosition.z - shapeAPositionsList[i].z) * interpolationTime;


                    Vector3 bNormal = Vector3.SlerpUnclamped(shapeBNormalsList[idx], shapeBNormalsList[idx + 1], frag);
                    normals.Array[i] = Vector3.SlerpUnclamped(shapeANormalsList[i], bNormal, interpolationTime);
                }
            else
                for (int i = 0; i < shapeVertexCount; i++)
                {
                    float frag;
                    int idx = shapeA.GetFIndex(shapeB.RelativeDistances.Array[i], out frag);

                    Vector3 aPosition;
                    {
                        aPosition.x = shapeAPositionsList[idx].x + (shapeAPositionsList[idx + 1].x - shapeAPositionsList[idx].x) * frag;
                        aPosition.y = shapeAPositionsList[idx].y + (shapeAPositionsList[idx + 1].y - shapeAPositionsList[idx].y) * frag;
                        aPosition.z = shapeAPositionsList[idx].z + (shapeAPositionsList[idx + 1].z - shapeAPositionsList[idx].z) * frag;
                    }

                    positionsArray[i].x = aPosition.x + (shapeBPositionsList[i].x - aPosition.x) * interpolationTime;
                    positionsArray[i].y = aPosition.y + (shapeBPositionsList[i].y - aPosition.y) * interpolationTime;
                    positionsArray[i].z = aPosition.z + (shapeBPositionsList[i].z - aPosition.z) * interpolationTime;

                    Vector3 aNormal = Vector3.SlerpUnclamped(shapeANormalsList[idx], shapeANormalsList[idx + 1], frag);
                    normals.Array[i] = Vector3.SlerpUnclamped(aNormal, shapeBNormalsList[i], interpolationTime);
                }

            resultShape.Positions = positions;

            resultShape.RelativeDistances = ArrayPools.Single.Allocate(shapeVertexCount);
            // sets Length and F
            resultShape.Recalculate();

            /*TODO BUG the following 4 properties are tied to the shape geometry, and should be recomputed based on the mixed mesh's geometry instead of using an approximate result.
             This will be specially visible when shape A and shape B have very different values of those properties, such as one of them having different material groups while the other having only one.
             3 of the 4 properties use shapeWithMostVertices. The issue with this is that shapeWithMostVertices can switch between the shape A and shape B depending on the shape's rasterization properties. To test/reproduce, set a square and circle as shapes, and set their rasterization to Optimize = true and Angle Threshold = 120. In those conditions, the square has more vertices. Then set the threshold to 10. In those conditions the circle has more vertices
              */

            resultShape.Normals = normals;
            resultShape.CustomValues = ArrayPools.Single.Clone(shapeWithMostVertices.CustomValues);
            resultShape.SourceRelativeDistances = ArrayPools.Single.Clone(shapeWithMostVertices.SourceRelativeDistances);
            resultShape.MaterialGroups = shapeWithMostVertices.MaterialGroups.Select(g => g.Clone()).ToList();

            if (ignoreWarnings == false)
            {
                if (shapeA.Closed != shapeB.Closed)
                    warningsContainer.Add("Mixing inputs with different Closed values is not supported");
                if (shapeA.Seamless != shapeB.Seamless)
                    warningsContainer.Add("Mixing inputs with different Seamless values is not supported");
                if (shapeA.SourceIsManaged != shapeB.SourceIsManaged)
                    warningsContainer.Add("Mixing inputs with different SourceIsManaged values is not supported");
            }
            resultShape.Closed = shapeA.Closed;
            resultShape.Seamless = shapeA.Seamless;
            resultShape.SourceIsManaged = shapeA.SourceIsManaged;
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierMixShapes.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierPathRelativeTranslation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 52d51ba992d55654699202ddc813ee25
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.DevTools;
using System;
using System.Threading.Tasks;
using FluffyUnderware.DevTools.Extensions;
using UnityEngine;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    /// <summary>
    /// Translates a path relatively to it's direction, instead of relatively to the world as does the TRS Path module.
    /// </summary>
    [ModuleInfo("Modifier/Path Relative Translation", ModuleName = "Path Relative Translation", Description = "Translates a path relatively to it's direction, instead of relatively to the world as does the TRS Path module.")]
    [HelpURL(CurvySpline.DOCLINK + "cgpathrelativetranslation")]
#pragma warning disable 618
    public class ModifierPathRelativeTranslation : CGModule, IOnRequestProcessing, IPathProvider
#pragma warning restore 618
    {
        [HideInInspector]
        [InputSlotInfo(typeof(CGPath), Name = "Path A", ModifiesData = true)]
        public CGModuleInputSlot InPath = new CGModuleInputSlot();

        [HideInInspector]
        [OutputSlotInfo(typeof(CGPath))]
        public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();


        #region ### Serialized Fields ###

        /// <summary>
        /// The translation distance
        /// </summary>
        [SerializeField]
        [Label("Translation")]
        [Tooltip("The (base) translation distance")]
        private float lateralTranslation;

        [SerializeField]
        [Tooltip("Defines translation multiplier, depending on the Relative Distance (between 0 and 1) of a point on the path")]
        [AnimationCurveEx("    Multiplier")]
        private AnimationCurve multiplier = AnimationCurve.Linear(0, 1, 1, 1);

        /// <summary>
        /// The translation angle, in degrees
        /// </summary>
        [SerializeField]
        [Tooltip("The translation angle, in degrees")]
        private float angle;

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// The translation distance
        /// </summary>
        public float LateralTranslation
        {
            get { return lateralTranslation; }
            set
            {
                if (lateralTranslation != value)
                {
                    lateralTranslation = value;
                    Dirty = true;
                }
            }
        }

        /// <summary>
        /// The translation angle, in degrees
        /// </summary>
        public float Angle
        {
            get { return angle; }
            set
            {

                if (Single.IsNaN(value))
                {
#if CURVY_SANITY_CHECKS
                    DTLog.LogWarning($"[Curvy] Invalid Angle value: {value}. 0 will be assigned instead", this);
#endif
                    value = 0;
                }

                if (angle != value)
                {
                    angle = value;
                    Dirty = true;
                }
            }
        }

        /// <summary>
        /// Defines a translation multiplier relatively to the Relative Distance of a point on the path.
        /// </summary>
        /// <remarks>You will need to set this module's Dirty to true yourself if you modify the AnimationCurve without setting a new one</remarks>
        public AnimationCurve Multiplier
        {
            get { return multiplier; }
            set
            {
                if (multiplier != value)
                    multiplier = value;
                Dirty = true;
            }
        }

        public bool PathIsClosed
        {
            get
            {
                return (IsConfigured) && InPath.SourceSlot().PathProvider.PathIsClosed;
            }
        }

        #endregion

        #region ### IOnRequestProcessing ###

        public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
        {
            CGData[] result;
            if (requestedSlot == OutPath)
            {
                CGPath data = InPath.GetData<CGPath>(out bool isDisposable, requests);
#if CURVY_SANITY_CHECKS
                // I forgot why I added this assertion, but I trust my past self
                Assert.IsTrue(data == null || isDisposable);
#endif
                if (data)
                {
                    bool evaluateTranslationMultiplier = Multiplier.ValueIsOne() == false;

                    if (evaluateTranslationMultiplier)
                        //no parallelization if we are going to evaluate TranslationMultiplier, since evaluating Animation Curves is not thread safe 
                        for (int i = 0; i < data.Count; i++)
                            TranslatePoint(i, data, evaluateTranslationMultiplier, 
                                lateralTranslation, multiplier, angle);
                    else
                        Parallel.For(0,
                            data.Count,
                            i => TranslatePoint(i, data, evaluateTranslationMultiplier, 
                                lateralTranslation, multiplier, angle)
                            );

                    data.Recalculate();
                }

                //TODO after fixing Directions computation in ConformPath, do the same here

                result = new CGData[1] { data };
            }
            else
                result = null;

            return result;
        }

        private static void TranslatePoint(int index, CGPath data, bool evaluateTranslationMultiplier, float translation, AnimationCurve translationMultiplier, float angle)
        {

            float translationMagnitude;
            {
                if (evaluateTranslationMultiplier)
                    translationMagnitude = translation * translationMultiplier.Evaluate(data.RelativeDistances.Array[index]);
                else
                    translationMagnitude = translation;
            }

            Vector3 translationVector;
            {
                Vector3 direction = data.Directions.Array[index];
                Vector3 normal = data.Normals.Array[index];

                if (angle != 0f)
                    translationVector = Quaternion.AngleAxis(angle, direction) * Vector3.Cross(normal, direction) * translationMagnitude;
                else
                    translationVector = Vector3.Cross(normal, direction) * translationMagnitude;
            }

            Vector3[] positions = data.Positions.Array;
            positions[index].x = positions[index].x + translationVector.x;
            positions[index].y = positions[index].y + translationVector.y;
            positions[index].z = positions[index].z + translationVector.z;
        }

        #endregion


        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected override void OnEnable()
        {
            base.OnEnable();
            Properties.MinWidth = 250;
            Properties.LabelWidth = 165;
        }

        public override void Reset()
        {
            base.Reset();
            LateralTranslation = 0;
            Angle = 0;
            Multiplier = AnimationCurve.Linear(0, 1, 1, 1);
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            LateralTranslation = lateralTranslation;
            Angle = angle;
            Multiplier = multiplier;
            Dirty = true;
        }
#endif

        /*! \endcond */
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierPathRelativeTranslation.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierTRSMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 88fffc7e9dfb6294185e9c3289854b61
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections.Generic;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Modifier/TRS Mesh", ModuleName = "TRS Mesh", Description = "Transform,Rotate,Scale a VMesh")]
    [HelpURL(CurvySpline.DOCLINK + "cgtrsmesh")]
    public class ModifierTRSMesh : TRSModuleBase
    {
        [HideInInspector]
        [InputSlotInfo(typeof(CGVMesh), Array = true, ModifiesData = true)]
        public CGModuleInputSlot InVMesh = new CGModuleInputSlot();

        [HideInInspector]
        [OutputSlotInfo(typeof(CGVMesh), Array = true)]
        public CGModuleOutputSlot OutVMesh = new CGModuleOutputSlot();



        #region ### Public Methods ###

        public override void Refresh()
        {
            base.Refresh();
            if (OutVMesh.IsLinked)
            {
                List<CGVMesh> vMesh = InVMesh.GetAllData<CGVMesh>(out bool isDisposable);
                Matrix4x4 mat = Matrix;
                for (int i = 0; i < vMesh.Count; i++)
                    vMesh[i].TRS(mat);
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(isDisposable);
#endif
                OutVMesh.SetData(vMesh);
            }

        }

        #endregion







    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierTRSMesh.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierTRSPath.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 34604050e8b02cd4ab1b388c022ab2d2
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Modifier/TRS Path", ModuleName = "TRS Path", Description = "Transform,Rotate,Scale a Path")]
    [HelpURL(CurvySpline.DOCLINK + "cgtrspath")]
#pragma warning disable 618
    public class ModifierTRSPath : TRSModuleBase, IOnRequestProcessing, IPathProvider
#pragma warning restore 618
    {
        [HideInInspector]
        [InputSlotInfo(typeof(CGPath), Name = "Path A", ModifiesData = true)]
        public CGModuleInputSlot InPath = new CGModuleInputSlot();

        [HideInInspector]
        [OutputSlotInfo(typeof(CGPath))]
        public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();



        #region ### Public Properties ###

        public bool PathIsClosed
        {
            get
            {
                return (IsConfigured) && InPath.SourceSlot().PathProvider.PathIsClosed;
            }
        }

        #endregion


        #region ### IOnRequestProcessing ###

        public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
        {
            CGData[] result;
            if (requestedSlot == OutPath)
            {
                CGPath data = InPath.GetData<CGPath>(out bool isDisposable, requests);
#if CURVY_SANITY_CHECKS
                // I forgot why I added this assertion, but I trust my past self
                Assert.IsTrue(data == null || isDisposable);
#endif

                if (data)
                {
                    var scaleLessMatrix = ApplyTrsOnShape(data);
                    for (int i = 0; i < data.Count; i++)
                        data.Directions.Array[i] = scaleLessMatrix.MultiplyVector(data.Directions.Array[i]);
                }
                result = new CGData[1] { data };
            }
            else
                result = null;

            return result;
        }
    }

    #endregion




}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierTRSPath.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierTRSShape.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9aa16a61208287d44abaa805bc050e9c
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Modifier/TRS Shape", ModuleName = "TRS Shape", Description = "Transform,Rotate,Scale a Shape")]
    [HelpURL(CurvySpline.DOCLINK + "cgtrsshape")]
#pragma warning disable 618
    public class ModifierTRSShape : TRSModuleBase, IOnRequestProcessing, IPathProvider
#pragma warning restore 618
    {
        [HideInInspector]
        [InputSlotInfo(typeof(CGShape), Name = "Shape A", ModifiesData = true)]
        public CGModuleInputSlot InShape = new CGModuleInputSlot();

        [HideInInspector]
        [OutputSlotInfo(typeof(CGShape))]
        public CGModuleOutputSlot OutShape = new CGModuleOutputSlot();

        #region ### Public Properties ###

        public bool PathIsClosed
        {
            get
            {
                return (IsConfigured) && InShape.SourceSlot().PathProvider.PathIsClosed;
            }
        }

        #endregion

        #region ### IOnRequestProcessing ###

        public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
        {
            CGData[] result;
            if (requestedSlot == OutShape)
            {
                CGShape data = InShape.GetData<CGShape>(out bool isDisposable, requests);
#if CURVY_SANITY_CHECKS
                // I forgot why I added this assertion, but I trust my past self
                Assert.IsTrue(data == null || isDisposable);
#endif
                if (data)
                    ApplyTrsOnShape(data);
                result = new CGData[1] { data };
            }
            else
                result = null;

            return result;
        }

        #endregion





    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierTRSShape.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierVariableMixShapes.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e9f9ee6c17ecbcf429b7eaa26063afd1
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Modifier/Variable Mix Shapes", ModuleName = "Variable Mix Shapes", Description = "Interpolates between two shapes in a way that varies along the shape extrusion")]
    [HelpURL(CurvySpline.DOCLINK + "cgvariablemixshapes")]
#pragma warning disable 618
    public class ModifierVariableMixShapes : CGModule, IOnRequestProcessing, IPathProvider
#pragma warning restore 618
    {
        [HideInInspector]
        [InputSlotInfo(typeof(CGShape), Name = "Shape A")]
        public CGModuleInputSlot InShapeA = new CGModuleInputSlot();

        [HideInInspector]
        [InputSlotInfo(typeof(CGShape), Name = "Shape B")]
        public CGModuleInputSlot InShapeB = new CGModuleInputSlot();

        [HideInInspector]
        [ShapeOutputSlotInfo(OutputsVariableShape = true, Array = true, ArrayType = SlotInfo.SlotArrayType.Hidden)]
        public CGModuleOutputSlot OutShape = new CGModuleOutputSlot();

        #region ### Serialized Fields ###
        [Label("Mix Curve", "Mix between the shapes. Values (Y axis) between -1 for Shape A and 1 for Shape B. Times (X axis) between 0 for extrusion start and 1 for extrusion end")]
        [SerializeField]
        private AnimationCurve m_MixCurve = AnimationCurve.Linear(0, -1, 1, 1);
        #endregion
        #region ### Public Properties ###

        public bool PathIsClosed
        {
            get
            {
                return (IsConfigured) && InShapeA.SourceSlot().PathProvider.PathIsClosed &&
                                        InShapeB.SourceSlot().PathProvider.PathIsClosed;
            }
        }

        /// <summary>
        /// Defines how the result is interpolated. Values (Y axis) between -1 for Shape A and 1 for Shape B. Times (X axis) between 0 for extrusion start and 1 for extrusion end
        /// </summary>
        public AnimationCurve MixCurve
        {
            get { return m_MixCurve; }
            set
            {
                m_MixCurve = value;
                Dirty = true;
            }
        }
        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Dirty = true;
        }
#endif

        public override void Reset()
        {
            base.Reset();
            m_MixCurve = AnimationCurve.Linear(0, -1, 1, 1);
        }

        /*! \endcond */
        #endregion

        #region ### IOnRequestProcessing ###
        public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
        {
            CGDataRequestShapeRasterization raster = GetRequestParameter<CGDataRequestShapeRasterization>(ref requests);
            if (!raster)
                return null;

            int pathFLength = raster.RelativeDistances.Count;

            CGData[] result = new CGData[pathFLength];

            if (pathFLength > 0)
            {
#if UNITY_EDITOR
                bool warnedAboutInterpolation = false;
#endif
                CGShape shapeA = InShapeA.GetData<CGShape>(out bool isADisposable, requests);
                CGShape shapeB = InShapeB.GetData<CGShape>(out bool isBDisposable, requests);

                for (int crossIndex = 0; crossIndex < pathFLength; crossIndex++)
                {
                    float mix = MixCurve.Evaluate(raster.RelativeDistances.Array[crossIndex]);
#if UNITY_EDITOR
                    if ((mix < -1 || mix > 1) && warnedAboutInterpolation == false)
                    {
                        warnedAboutInterpolation = true;
                        UIMessages.Add(String.Format("Mix Curve should have values between -1 and 1. Found a value of {0} at time {1}. The value was corrected", mix, raster.RelativeDistances.Array[crossIndex]));
                        mix = Mathf.Clamp(mix, -1, 1);
                    }
#endif
                    result[crossIndex] = ModifierMixShapes.MixShapes(
                        shapeA, shapeB, mix,
                        UIMessages, crossIndex != 0);
                }

                if (isADisposable)
                    shapeA.Dispose();

                if (isBDisposable)
                    shapeB.Dispose();
            }
            return result;
        }

        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ModifierVariableMixShapes.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/Note.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c8b0cfe04ef5e5d4aaf9ff8c26cabecb
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    [ModuleInfo("Note", ModuleName="Note", Description = "Creates a note")]
    [HelpURL(CurvySpline.DOCLINK + "cgnote")]
    public class Note : CGModule, INoProcessing
    {

        [SerializeField, TextArea(3, 10)] private string m_Note;

        public string NoteText
        {
            get { return m_Note; }
            set
            {
                if (m_Note != value)
                    m_Note = value;
            }
        }

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected override void OnEnable()
        {
            base.OnEnable();
            Properties.MinWidth = 250;
            Properties.LabelWidth = 50;
        }

        public override void Reset()
        {
            base.Reset();
            m_Note = null;
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            NoteText = m_Note;
        }
#endif

        /*! \endcond */
        #endregion
      
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/Note.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ResourceExportingModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 97658263086c0474cbff9ecccdf3ec25
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections.Generic;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;

namespace FluffyUnderware.Curvy.Generator.Modules
{
    /// <summary>
    /// A CGModule that creates managed resources that can be exported
    /// </summary>
    public abstract class ResourceExportingModule : CGModule
    {
        /// <summary>
        /// Save the created resource(s) to the scene
        /// </summary>
        /// <param name="parent">the parent transform to which the saved resource(s) GameObject(s) will be attached. If null, saved resource(s) GameObject(s) will be at the hierarchy's root</param>
        /// <returns>The created GameObject</returns>
        public GameObject SaveToScene(Transform parent = null)
        {
            List<Component> managedResources;
            GetManagedResources(out managedResources, out _);
            if (managedResources.Count == 0)
                return null;

            GameObject result = new GameObject($"{ModuleName} Exported Resources");
            result.transform.parent = parent;
            for (int i = 0; i < managedResources.Count; i++)
                SaveResourceToScene(managedResources[i], result.transform);

            result.transform.position = this.transform.position;
            result.transform.rotation = this.transform.rotation;
            result.transform.localScale = this.transform.localScale;
            return result;
        }

        /// <summary>
        /// Save a specific resource to the scene as a GameObject
        /// </summary>
        /// <returns>The saved GameObject</returns>
        protected abstract GameObject SaveResourceToScene(Component managedResource, Transform newParent);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG Modules/ResourceExportingModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGBoundsGroup.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 75d63101243298e4e90c40319e35d557
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.DevTools;
using UnityEngine;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Helper class used by VolumeSpots and others
    /// </summary>
    [System.Serializable]
    public class CGBoundsGroup : CGWeightedItem
    {
        /// <summary>
        /// How the rotation axes are defined related to the Volume's data
        /// </summary>
        public enum RotationModeEnum
        {
            /// <summary>
            /// Use Volume's direction and orientation
            /// </summary>
            Full,
            /// <summary>
            /// Use Volume's direction only
            /// </summary>
            Direction,
            /// <summary>
            /// Use Volume's direction only after projecting it on XZ plane
            /// </summary>
            Horizontal,
            /// <summary>
            /// Do not use Volume's data
            /// </summary>
            Independent
        }

        #region ### Serialized Fields ###
        [SerializeField] private string m_Name;
        [SerializeField]
        [Tooltip("When checked, the group will only be placed when all the group's items can be placed in the space left")]
        private bool m_KeepTogether;
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_SpaceBefore = new FloatRegion() { SimpleValue = true };
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_SpaceAfter = new FloatRegion() { SimpleValue = true };
        [SerializeField]
        //BUG Tooltip and FloatRegion are not compatible [Tooltip("Shifts the Cross origin for this group by a value in the defined range")]
        [FloatRegion(RegionIsOptional = true, RegionOptionsPropertyName = nameof(PositionRangeOptions), UseSlider = true, Precision = 3)]
        private FloatRegion m_CrossBase = new FloatRegion(0);
        [SerializeField]
        [Tooltip("If ticked, the Cross origin for this group will not take into consideration the Cross parameters in the General tab")]
        private bool m_IgnoreModuleCrossBase = false;

        [SerializeField]
        [Tooltip("When enabled, items will be selected randomly")]
        private bool m_RandomizeItems;

        [IntRegion(UseSlider = false, RegionOptionsPropertyName = nameof(RepeatingGroupsOptions), Options = AttributeOptionsFlags.Compact)]
        [SerializeField]
        [Tooltip("The randomized items are the the ones that have their indices inside this range")]
        private IntRegion m_RepeatingItems;

        //Translation
        [SerializeField]
        [Tooltip("If unchecked, translation will be done in the global/world space")]
        private bool m_RelativeTranslation = true;
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_TranslationX = new FloatRegion(0);
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_TranslationY = new FloatRegion(0);
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_TranslationZ = new FloatRegion(0);

        //Rotation
        [SerializeField]
        [Tooltip("How the rotation axes are defined related to the Volume's data\r\n  - Full : Use Volume's direction and orientation\r\n  - Direction : Use Volume's direction only\r\n  - Horizontal : Use Volume's direction only after projecting it on XZ plane\r\n  - Independent : Do not use Volume's data")]
        private RotationModeEnum m_RotationMode = RotationModeEnum.Full;

        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_RotationX = new FloatRegion(0);
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_RotationY = new FloatRegion(0);
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_RotationZ = new FloatRegion(0);

        //Scale
        [SerializeField]
        [Tooltip("Whether the scaling is applied equally on all dimensions")]
        private bool m_UniformScaling = true;
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_ScaleX = new FloatRegion(1);
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_ScaleY = new FloatRegion(1);
        [SerializeField]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_ScaleZ = new FloatRegion(1);

        [SerializeField] private List<CGBoundsGroupItem> m_Items = new List<CGBoundsGroupItem>();

        #endregion

        #region ### Public Members ###

        public string Name
        {
            get { return m_Name; }
            set
            {
                if (m_Name != value)
                    m_Name = value;
            }
        }

        /// <summary>
        /// When true, the group will only be placed when all items can be placed in the space left. 
        /// </summary>
        public bool KeepTogether
        {
            get { return m_KeepTogether; }
            set
            {
                if (m_KeepTogether != value)
                    m_KeepTogether = value;
            }
        }

        public FloatRegion SpaceBefore
        {
            get { return m_SpaceBefore; }
            set
            {
                if (m_SpaceBefore != value)
                    m_SpaceBefore = value;
            }
        }

        public FloatRegion SpaceAfter
        {
            get { return m_SpaceAfter; }
            set
            {
                if (m_SpaceAfter != value)
                    m_SpaceAfter = value;
            }
        }

        /// <summary>
        /// When enabled, items in groups will be selected randomly.
        /// <seealso cref="RepeatingItems"/>
        /// </summary>
        public bool RandomizeItems
        {
            get { return m_RandomizeItems; }
            set
            {
                if (m_RandomizeItems != value)
                    m_RandomizeItems = value;
            }
        }

        /// <summary>
        /// When <seealso cref="RandomizeItems"/> is set to true, the randomized items are the the ones that have their indices inside the RepeatingItems range
        /// </summary>
        public IntRegion RepeatingItems
        {
            get { return m_RepeatingItems; }
            set
            {
                if (m_RepeatingItems != value)
                    m_RepeatingItems = value;
            }
        }

        /// <summary>
        /// Shifts the Cross origin for this group by a value in the defined range
        /// </summary>
        public FloatRegion CrossBase
        {
            get { return m_CrossBase; }
            set
            {
                if (m_CrossBase != value)
                    m_CrossBase = value;
            }
        }

        /// <summary>
        /// If true, the Cross origin for this group will not take into consideration the Cross parameters of the BuildVolumeSpots class/>
        /// </summary>
        public bool IgnoreModuleCrossBase
        {
            get { return m_IgnoreModuleCrossBase; }
            set
            {
                if (m_IgnoreModuleCrossBase != value)
                    m_IgnoreModuleCrossBase = value;
            }
        }

        /// <summary>
        /// How the rotation axes are defined related to the Volume's data
        /// </summary>
        public RotationModeEnum RotationMode
        {
            get { return m_RotationMode; }
            set
            {
                if (m_RotationMode != value)
                    m_RotationMode = value;
            }
        }

        public FloatRegion RotationX
        {
            get { return m_RotationX; }
            set
            {
                if (m_RotationX != value)
                    m_RotationX = value;
            }
        }
        public FloatRegion RotationY
        {
            get { return m_RotationY; }
            set
            {
                if (m_RotationY != value)
                    m_RotationY = value;
            }
        }
        public FloatRegion RotationZ
        {
            get { return m_RotationZ; }
            set
            {
                if (m_RotationZ != value)
                    m_RotationZ = value;
            }
        }

        /// <summary>
        /// When true, the scaling vector is (ScaleX, ScaleX, ScaleX) instead of (ScaleX, ScaleY, ScaleZ)
        /// </summary>
        public bool UniformScaling
        {
            get { return m_UniformScaling; }
            set
            {
                if (m_UniformScaling != value)
                    m_UniformScaling = value;
            }
        }
        public FloatRegion ScaleX
        {
            get { return m_ScaleX; }
            set
            {
                if (m_ScaleX != value)
                    m_ScaleX = value;
            }
        }
        public FloatRegion ScaleY
        {
            get { return m_ScaleY; }
            set
            {
                if (m_ScaleY != value)
                    m_ScaleY = value;
            }
        }
        public FloatRegion ScaleZ
        {
            get { return m_ScaleZ; }
            set
            {
                if (m_ScaleZ != value)
                    m_ScaleZ = value;
            }
        }
        /// <summary>
        /// When true, the translation of an item is done in the relative frame defined by the tangent and orientation (up vector) of the volume at the item's position
        /// </summary>
        public bool RelativeTranslation
        {
            get { return m_RelativeTranslation; }
            set
            {
                if (m_RelativeTranslation != value)
                    m_RelativeTranslation = value;
            }
        }
        public FloatRegion TranslationX
        {
            get { return m_TranslationX; }
            set
            {
                if (m_TranslationX != value)
                    m_TranslationX = value;
            }
        }
        public FloatRegion TranslationY
        {
            get { return m_TranslationY; }
            set
            {
                if (m_TranslationY != value)
                    m_TranslationY = value;
            }
        }
        public FloatRegion TranslationZ
        {
            get { return m_TranslationZ; }
            set
            {
                if (m_TranslationZ != value)
                    m_TranslationZ = value;
            }
        }

        public List<CGBoundsGroupItem> Items
        {
            get { return m_Items; }
        }

        /// <summary>
        /// First index of the <see cref="RepeatingItems"/> range
        /// </summary>
        public int FirstRepeating
        {
            get { return m_RepeatingItems.From; }
            set
            {
                int v = Mathf.Clamp(value, 0, Mathf.Max(0, ItemCount - 1));
                if (m_RepeatingItems.From != v)
                    m_RepeatingItems.From = v;
            }
        }

        /// <summary>
        /// Last index of the <see cref="RepeatingItems"/> range
        /// </summary>
        public int LastRepeating
        {
            get { return m_RepeatingItems.To; }
            set
            {
                int v = Mathf.Clamp(value, FirstRepeating, Mathf.Max(0, ItemCount - 1));
                if (m_RepeatingItems.To != v)
                    m_RepeatingItems.To = v;
            }
        }

        public int ItemCount
        {
            get { return Items.Count; }
        }

        public CGBoundsGroup(string name)
        {
            Name = name;
        }

        /// <summary>
        /// Fill an item bag with items based on their weights
        /// </summary>
        public static void FillItemBag(WeightedRandom<int> bag, IEnumerable<CGWeightedItem> itemsWeights, int firstItem, int lastItem)
        {
            for (int g = firstItem; g <= lastItem; g++)
                bag.Add(g, (int)(itemsWeights.ElementAt(g).Weight * 10));

            if (bag.Size == 0)
                bag.Add(firstItem, 1);
        }

        #endregion

        #region Non Public Members

        private RegionOptions<int> RepeatingGroupsOptions
        {
            get
            {
                return RegionOptions<int>.MinMax(0, Mathf.Max(0, ItemCount - 1));
            }
        }

        private RegionOptions<float> PositionRangeOptions
        {
            get
            {
                return RegionOptions<float>.MinMax(-1f, 1f);
            }
        }
        #endregion

        #region Obsolete code kept for retrocompatibility
        [Obsolete("Enum no more used by Curvy. This enum is kept for retro compatibility reasons")]
        private enum DistributionModeEnum
        {
            Parent,
            Self
        }

#pragma warning disable 649
        [SerializeField, HideInInspector]
        [Obsolete("Use IgnoreModuleCrossBase instead. This field is kept for retro compatibility reasons")]
        private DistributionModeEnum m_DistributionMode;

        [SerializeField, HideInInspector]
        [Obsolete("Use CrossBase instead. This field is kept for retro compatibility reasons")]
        [FloatRegion(RegionIsOptional = true, RegionOptionsPropertyName = nameof(PositionRangeOptions), UseSlider = true, Precision = 3)]
        private FloatRegion m_PositionOffset = new FloatRegion(0);

        [SerializeField, HideInInspector]
        [Obsolete("Use TranslationY instead, while setting RelativeTranslation to true. This field is kept for retro compatibility reasons")]
        [FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
        private FloatRegion m_Height = new FloatRegion(0);

        [SerializeField, HideInInspector]
        [Obsolete("Use RandomizeItems instead. This field is kept for retro compatibility reasons")]
        private CurvyRepeatingOrderEnum m_RepeatingOrder = CurvyRepeatingOrderEnum.Row;

        [SerializeField, HideInInspector]
        [Obsolete("Use RotationX, RotationY and RotationZ instead. This field is kept for retro compatibility reasons")]
        [VectorEx]
        private Vector3 m_RotationOffset;

        [SerializeField, HideInInspector]
        [Obsolete("Use RotationX, RotationY and RotationZ instead. This field is kept for retro compatibility reasons")]
        [VectorEx]
        private Vector3 m_RotationScatter;
#pragma warning restore 649

        /// <summary>
        /// Converts the obsolete data to the new format
        /// </summary>
        [Obsolete("Method will get removed once the obsolete data will get removed")]
        public void ConvertObsoleteData()
        {
            RandomizeItems = m_RepeatingOrder == CurvyRepeatingOrderEnum.Random;
            IgnoreModuleCrossBase = m_DistributionMode == DistributionModeEnum.Self;
            CrossBase = m_PositionOffset;
            if (m_Height.From != 0f || (m_Height.SimpleValue == false && m_Height.To != 0f))
            {
                TranslationY = m_Height;
                RelativeTranslation = true;
            }

            {
                float from = m_RotationOffset.x - m_RotationScatter.x;
                float to = m_RotationOffset.x + m_RotationScatter.x;
                RotationX = from == to ? new FloatRegion(from) : new FloatRegion(from, to);
            }

            {
                float from = m_RotationOffset.y - m_RotationScatter.y;
                float to = m_RotationOffset.y + m_RotationScatter.y;
                RotationY = from == to ? new FloatRegion(from) : new FloatRegion(from, to);
            }

            {
                float from = m_RotationOffset.z - m_RotationScatter.z;
                float to = m_RotationOffset.z + m_RotationScatter.z;
                RotationZ = from == to ? new FloatRegion(from) : new FloatRegion(from, to);
            }
        }
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGBoundsGroup.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGClasses.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a2040f930733ca34783e346013036c51
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Generator
{
    #region ### CGModule related ###

    /// <summary>
    /// Yes,No,Auto Enum
    /// </summary>
    public enum CGYesNoAuto
    {
        Yes,
        No,
        Auto
    }

    /// <summary>
    /// Which entity an operation refers to: either an object itself or its source
    /// </summary>
    public enum CGReferenceMode
    {
        Source,
        Self
    }

    /// <summary>
    /// Aspect Mode correction modes enum
    /// </summary>
    public enum CGKeepAspectMode
    {
        /// <summary>
        ///  No Aspect correction is applied
        /// </summary>
        Off,
        /// <summary>
        /// U is scaled to keep texel size proportional
        /// </summary>
        ScaleU,
        /// <summary>
        /// V is scaled to keep texel size proportional
        /// </summary>
        ScaleV
    }

    public enum CGColliderEnum
    {
        None,
        Mesh,
        Box,
        Sphere,
        Capsule
    }

    /// <summary>
    /// Spots are used to place objects (like meshes or Game Objects) A spot is defined by spacial coordinates (similar to Transform) and the index of the object to place
    /// </summary>
    [System.Serializable]
    public struct CGSpot : IEquatable<CGSpot>
    {
        [SerializeField]
        [Label("Index")]
        private int m_Index;
        [SerializeField]
        [VectorEx("Position", Options = AttributeOptionsFlags.Compact, Precision = 4)]
        private Vector3 m_Position;
        [SerializeField]
        [VectorEx("Rotation", Options = AttributeOptionsFlags.Compact, Precision = 4)]
        private Quaternion m_Rotation;
        [SerializeField]
        [VectorEx("Scale", Options = AttributeOptionsFlags.Compact, Precision = 4)]
        private Vector3 m_Scale;

        /// <summary>
        /// The index of the object to place
        /// </summary>
        public int Index
        {
            get { return m_Index; }
        }

        /// <summary>
        /// Gets or sets the position
        /// </summary>
        public Vector3 Position
        {
            get { return m_Position; }
            set
            {
                if (m_Position != value)
                    m_Position = value;
            }
        }

        /// <summary>
        /// Gets or sets the rotation
        /// </summary>
        public Quaternion Rotation
        {
            get { return m_Rotation; }
            set
            {
                if (m_Rotation != value)
                    m_Rotation = value;
            }
        }

        /// <summary>
        /// Gets or sets the scale
        /// </summary>
        public Vector3 Scale
        {
            get { return m_Scale; }
            set
            {
                if (m_Scale != value)
                    m_Scale = value;
            }
        }

        /// <summary>
        /// Gets a TRS matrix using Position, Rotation, Scale
        /// </summary>
        public Matrix4x4 Matrix
        {
            get { return Matrix4x4.TRS(m_Position, m_Rotation, m_Scale); }
        }

        public CGSpot(int index) : this(index, Vector3.zero, Quaternion.identity, Vector3.one) { }

        public CGSpot(int index, Vector3 position, Quaternion rotation, Vector3 scale)
        {
            m_Index = index;
            m_Position = position;
            m_Rotation = rotation;
            m_Scale = scale;
        }

        /// <summary>
        /// Sets a transform to match Position, Rotation, Scale in local space
        /// </summary>
        /// <param name="transform"></param>
        public void ToTransform(Transform transform)
        {
            transform.localPosition = Position;
            transform.localRotation = Rotation;
            transform.localScale = Scale;
        }

        public bool Equals(CGSpot other)
        {
            return m_Index == other.m_Index && m_Position.Equals(other.m_Position) && m_Rotation.Equals(other.m_Rotation) && m_Scale.Equals(other.m_Scale);
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
                return false;
            return obj is CGSpot && Equals((CGSpot)obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hashCode = m_Index;
                hashCode = (hashCode * 397) ^ m_Position.GetHashCode();
                hashCode = (hashCode * 397) ^ m_Rotation.GetHashCode();
                hashCode = (hashCode * 397) ^ m_Scale.GetHashCode();
                return hashCode;
            }
        }

        public static bool operator ==(CGSpot left, CGSpot right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(CGSpot left, CGSpot right)
        {
            return !left.Equals(right);
        }
    }

    /// <summary>
    /// An <see cref="IComparer"/> that compares instances of <see cref="CGSpot"/> based on their <see cref="CGSpot.Index"/>
    /// </summary>
    public class CGSpotComparer : IComparer
    {
        public int Compare(object x, object y)
        {
            return ((CGSpot)x).Index.CompareTo(((CGSpot)y).Index);
        }
    }

    /// <summary>
    /// Helper class used by various Curvy Generator modules
    /// </summary>
    [System.Serializable]
    public class CGMaterialSettings
    {
        public bool SwapUV = false;
        [Tooltip("Options to keep texel size proportional")]
        public CGKeepAspectMode KeepAspect = CGKeepAspectMode.Off;
        public float UVRotation = 0;
        public Vector2 UVOffset = Vector2.zero;
        public Vector2 UVScale = Vector2.one;
    }

    /// <summary>
    /// Helper class used by various Curvy Generator modules
    /// </summary>
    [System.Serializable]
    //Design: get rid of CGMaterialSettingsEx, use CGMaterialSettings instead
    public class CGMaterialSettingsEx : CGMaterialSettings
    {
        [Obsolete("This field is not used anymore, will get remove in a future update")]
        public int MaterialID = 0;
    }

    /// <summary>
    /// Helper class used by InputMesh module
    /// </summary>
    [System.Serializable]
    public class CGMeshProperties
    {
        [SerializeField] private Mesh m_Mesh;
        [SerializeField] private Material[] m_Material = new Material[0];
        [SerializeField]
        [VectorEx]
        private Vector3 m_Translation;
        [SerializeField]
        [VectorEx]
        private Vector3 m_Rotation;
        [SerializeField]
        [VectorEx]
        private Vector3 m_Scale = Vector3.one;


        public Mesh Mesh
        {
            get { return m_Mesh; }
            set
            {
                if (m_Mesh != value)
                    m_Mesh = value;
                if (m_Mesh && m_Mesh.subMeshCount != m_Material.Length)
                    System.Array.Resize(ref m_Material, m_Mesh.subMeshCount);
            }
        }
        public Material[] Material
        {
            get { return m_Material; }
            set
            {
                if (m_Material != value)
                    m_Material = value;
            }
        }

        public Vector3 Translation
        {
            get { return m_Translation; }
            set
            {
                if (m_Translation != value)
                    m_Translation = value;
            }
        }

        public Vector3 Rotation
        {
            get { return m_Rotation; }
            set
            {
                if (m_Rotation != value)
                    m_Rotation = value;
            }
        }

        public Vector3 Scale
        {
            get { return m_Scale; }
            set
            {
                if (m_Scale != value)
                    m_Scale = value;
            }
        }

        public Matrix4x4 Matrix
        {
            get { return Matrix4x4.TRS(Translation, Quaternion.Euler(Rotation), Scale); }
        }

        public CGMeshProperties() { }

        public CGMeshProperties(Mesh mesh)
        {
            Mesh = mesh;
            Material = (mesh != null) ? new Material[mesh.subMeshCount] : new Material[0];
        }
#if UNITY_EDITOR
        public void OnValidate()
        {
            Mesh = m_Mesh;
            Material = m_Material;
        }
#endif
    }

    /// <summary>
    /// Helper class used by InputGameObject module
    /// </summary>
    [System.Serializable]
    public class CGGameObjectProperties
    {
        [SerializeField] private GameObject m_Object;
        [SerializeField]
        [VectorEx]
        private Vector3 m_Translation;
        [SerializeField]
        [VectorEx]
        private Vector3 m_Rotation;
        [SerializeField]
        [VectorEx]
        private Vector3 m_Scale = Vector3.one;

        public GameObject Object
        {
            get { return m_Object; }
            set
            {
                if (m_Object != value)
                    m_Object = value;
            }
        }

        public Vector3 Translation
        {
            get { return m_Translation; }
            set
            {
                if (m_Translation != value)
                    m_Translation = value;
            }
        }

        public Vector3 Rotation
        {
            get { return m_Rotation; }
            set
            {
                if (m_Rotation != value)
                    m_Rotation = value;
            }
        }

        public Vector3 Scale
        {
            get { return m_Scale; }
            set
            {
                if (m_Scale != value)
                    m_Scale = value;
            }
        }

        public Matrix4x4 Matrix
        {
            get { return Matrix4x4.TRS(Translation, Quaternion.Euler(Rotation), Scale); }
        }

        public CGGameObjectProperties() { }

        public CGGameObjectProperties(GameObject gameObject)
        {
            Object = gameObject;
        }
    }

    /// <summary>
    /// An item that has a weight associated to it
    /// </summary>
    [Serializable]
    public class CGWeightedItem
    {
        [RangeEx(0, 1, Slider = true, Precision = 1)]
        [SerializeField]
        private float m_Weight = 0.5f;

        public float Weight
        {
            get { return m_Weight; }
            set
            {
                float v = Mathf.Clamp01(value);
                if (m_Weight != v)
                    m_Weight = v;
            }
        }
    }

    /// <summary>
    /// Helper class used by VolumeSpots and others
    /// </summary>
    [System.Serializable]
    public class CGBoundsGroupItem : CGWeightedItem
    {
        public int Index;
    }

    #endregion

    #region ### Spline rasterization related ###

    /// <summary>
    /// Rasterization helper
    /// </summary>
    public struct ControlPointOption : IEquatable<ControlPointOption>
    {
        public float TF;
        public float Distance;
        public bool Include;
        public int MaterialID;
        public bool HardEdge;
        public float MaxStepDistance;
        public bool UVEdge;
        /// <summary>
        /// Also known as ExplicitU
        /// </summary>
        public bool UVShift;
        public float FirstU;
        public float SecondU;


        public ControlPointOption(float tf, float dist, bool includeAnyways, int materialID, bool hardEdge, float maxStepDistance, bool uvEdge, bool uvShift, float firstU, float secondU)
        {
            TF = tf;
            Distance = dist;
            Include = includeAnyways;
            MaterialID = materialID;
            HardEdge = hardEdge;
            if (maxStepDistance == 0)
                MaxStepDistance = float.MaxValue;
            else
                MaxStepDistance = maxStepDistance;
            UVEdge = uvEdge;
            UVShift = uvShift;
            FirstU = firstU;
            SecondU = secondU;
        }

        public bool Equals(ControlPointOption other)
        {
            return TF.Equals(other.TF) && Distance.Equals(other.Distance) && Include == other.Include && MaterialID == other.MaterialID && HardEdge == other.HardEdge && MaxStepDistance.Equals(other.MaxStepDistance) && UVEdge == other.UVEdge && UVShift == other.UVShift && FirstU.Equals(other.FirstU) && SecondU.Equals(other.SecondU);
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
                return false;
            return obj is ControlPointOption && Equals((ControlPointOption)obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hashCode = TF.GetHashCode();
                hashCode = (hashCode * 397) ^ Distance.GetHashCode();
                hashCode = (hashCode * 397) ^ Include.GetHashCode();
                hashCode = (hashCode * 397) ^ MaterialID;
                hashCode = (hashCode * 397) ^ HardEdge.GetHashCode();
                hashCode = (hashCode * 397) ^ MaxStepDistance.GetHashCode();
                hashCode = (hashCode * 397) ^ UVEdge.GetHashCode();
                hashCode = (hashCode * 397) ^ UVShift.GetHashCode();
                hashCode = (hashCode * 397) ^ FirstU.GetHashCode();
                hashCode = (hashCode * 397) ^ SecondU.GetHashCode();
                return hashCode;
            }
        }

        public static bool operator ==(ControlPointOption left, ControlPointOption right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(ControlPointOption left, ControlPointOption right)
        {
            return !left.Equals(right);
        }
    }

    /// <summary>
    /// A patch of vertices to be connected by triangles (i.e. same Material and no hard edges within a patch)
    /// </summary>
    /// <remarks>The index values refer to rasterized points of CGShape</remarks>
    public struct SamplePointsPatch : IEquatable<SamplePointsPatch>
    {
        /// <summary>
        /// First Sample Point Index of the patch
        /// </summary>
        public int Start;
        /// <summary>
        /// Number of Sample Points of the patch
        /// </summary>
        public int Count;

        /// <summary>
        /// Last Sample Point Index of the patch
        /// </summary>
        public int End
        {
            get { return Start + Count; }
            set
            {
                Count = Mathf.Max(0, value - Start);
            }
        }

        public int TriangleCount
        {
            get
            {
                return Count * 2;
            }
        }


        public SamplePointsPatch(int start)
        {
            Start = start;
            Count = 0;
        }

        public override string ToString()
        {
            return string.Format(System.Globalization.CultureInfo.InvariantCulture, "Size={0} ({1}-{2}, {3} Tris)", Count, Start, End, TriangleCount);
        }

        public bool Equals(SamplePointsPatch other)
        {
            return Start == other.Start && Count == other.Count;
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
                return false;
            return obj is SamplePointsPatch && Equals((SamplePointsPatch)obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return (Start * 397) ^ Count;
            }
        }

        public static bool operator ==(SamplePointsPatch left, SamplePointsPatch right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(SamplePointsPatch left, SamplePointsPatch right)
        {
            return !left.Equals(right);
        }
    }

    /// <summary>
    /// A section of one or more patches, all sharing the same MaterialID
    /// </summary>
    public class SamplePointsMaterialGroup
    {
        public int MaterialID;

        public List<SamplePointsPatch> Patches;

        public int TriangleCount
        {
            get
            {
                int cnt = 0;
                for (int p = 0; p < Patches.Count; p++)
                    cnt += Patches[p].TriangleCount;
                return cnt;
            }
        }

        public int StartVertex
        {
            get
            {
                return Patches[0].Start;
            }
        }

        public int EndVertex
        {
            get
            {
                return Patches[Patches.Count - 1].End;
            }
        }

        public int VertexCount
        {
            get
            {
                return EndVertex - StartVertex + 1;
            }
        }

        public SamplePointsMaterialGroup(int materialID) : this(materialID, new List<SamplePointsPatch>())
        {
        }

        public SamplePointsMaterialGroup(int materialID, List<SamplePointsPatch> patches)
        {
            MaterialID = materialID;
            Patches = patches;
        }

        public void GetLengths(CGVolume volume, out float worldLength, out float uLength)
        {
            worldLength = 0;
            for (int v = StartVertex; v < EndVertex; v++)
                worldLength += (volume.Vertices.Array[v + 1] - volume.Vertices.Array[v]).magnitude;
            uLength = volume.CrossCustomValues.Array[EndVertex] - volume.CrossCustomValues.Array[StartVertex];
        }

        /// <summary>
        /// Returns a clone of the current instance.
        /// </summary>
        public SamplePointsMaterialGroup Clone()
        {
            return new SamplePointsMaterialGroup(MaterialID, new List<SamplePointsPatch>(Patches));
        }
    }

    /// <summary>
    /// Data about duplicated points, meaning a couple of points sharing the same position. Such duplicated points are used to store different normals or different U coordinates at the same position
    /// </summary>
    public readonly struct DuplicateSamplePoint : IEquatable<DuplicateSamplePoint>
    {
        /// <summary>
        /// The index of the first point
        /// </summary>
        public int StartIndex { get; }
        /// <summary>
        /// The index of the second point
        /// </summary>
        public int EndIndex { get; }
        /// <summary>
        /// When true, both points don't share the same normal
        /// </summary>
        public bool IsHardEdge { get; }

        public DuplicateSamplePoint(int startIndex, int endIndex, bool isHardEdge)
        {
            StartIndex = startIndex;
            EndIndex = endIndex;
            IsHardEdge = isHardEdge;
        }

        public bool Equals(DuplicateSamplePoint other)
        {
            return StartIndex == other.StartIndex && EndIndex == other.EndIndex && IsHardEdge == other.IsHardEdge;
        }

        public override bool Equals(object obj)
        {
            return obj is DuplicateSamplePoint other && Equals(other);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hashCode = StartIndex;
                hashCode = (hashCode * 397) ^ EndIndex;
                hashCode = (hashCode * 397) ^ IsHardEdge.GetHashCode();
                return hashCode;
            }
        }

        public static bool operator ==(DuplicateSamplePoint left, DuplicateSamplePoint right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(DuplicateSamplePoint left, DuplicateSamplePoint right)
        {
            return !left.Equals(right);
        }

        public override string ToString()
        {
            return $"{nameof(StartIndex)}: {StartIndex}, {nameof(EndIndex)}: {EndIndex}, {nameof(IsHardEdge)}: {IsHardEdge}";
        }
    }


    public struct SamplePointUData : IEquatable<SamplePointUData>
    {
        public int Vertex;
        public bool UVEdge;
        public bool HardEdge;
        public float FirstU;
        public float SecondU;

        [Obsolete("Use other constructors")]
        public SamplePointUData(int vertexIndex, bool uvEdge, float firstU, float secondU) : this(vertexIndex, uvEdge, false, firstU, secondU)
        {
        }

        public SamplePointUData(int vertexIndex, bool uvEdge, bool hardEdge, float firstU, float secondU)
        {
            Vertex = vertexIndex;
            UVEdge = uvEdge;
            HardEdge = hardEdge;
            FirstU = firstU;
            SecondU = secondU;
        }

        public SamplePointUData(int vertexIndex, ControlPointOption controlPointsOption) : this(
            vertexIndex,
            controlPointsOption.UVEdge,
            controlPointsOption.HardEdge,
            controlPointsOption.FirstU,
            controlPointsOption.SecondU
        )
        {
        }


        public override string ToString()
        {
            return string.Format(System.Globalization.CultureInfo.InvariantCulture, "SamplePointUData (Vertex={0}, UVEdge={1}, HardEdge={4}, FirstU={2}, SecondU={3}", Vertex, UVEdge, FirstU, SecondU, HardEdge);
        }

        public bool Equals(SamplePointUData other)
        {
            return Vertex == other.Vertex && UVEdge == other.UVEdge && HardEdge == other.HardEdge && FirstU.Equals(other.FirstU) && SecondU.Equals(other.SecondU);
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
                return false;
            return obj is SamplePointUData && Equals((SamplePointUData)obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hashCode = Vertex;
                hashCode = (hashCode * 397) ^ UVEdge.GetHashCode();
                hashCode = (hashCode * 397) ^ HardEdge.GetHashCode();
                hashCode = (hashCode * 397) ^ FirstU.GetHashCode();
                hashCode = (hashCode * 397) ^ SecondU.GetHashCode();
                return hashCode;
            }
        }

        public static bool operator ==(SamplePointUData left, SamplePointUData right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(SamplePointUData left, SamplePointUData right)
        {
            return !left.Equals(right);
        }
    }

    #endregion


    /// <summary>
    /// List of Material Groups
    /// </summary>
    public class SamplePointsMaterialGroupCollection : List<SamplePointsMaterialGroup>
    {
        public int TriangleCount
        {
            get
            {
                int cnt = 0;
                for (int g = 0; g < this.Count; g++)
                    cnt += this[g].TriangleCount;
                return cnt;
            }
        }

        public int MaterialID;

        [Obsolete("Use AspectCorrectionV instead")]
        public float AspectCorrection
        {
            get => AspectCorrectionV;
            set => AspectCorrectionV = value;
        }

        /// <summary>
        /// A multiplication applied on the U coordinate as part of the aspect correction
        /// </summary>
        public float AspectCorrectionU = 1;

        /// <summary>
        /// A multiplication applied on the V coordinate as part of the aspect correction
        /// </summary>
        public float AspectCorrectionV = 1;

        public SamplePointsMaterialGroupCollection() : base() { }
        public SamplePointsMaterialGroupCollection(int capacity) : base(capacity) { }
        public SamplePointsMaterialGroupCollection(IEnumerable<SamplePointsMaterialGroup> collection) : base(collection) { }

        public void CalculateAspectCorrection(CGVolume volume, CGMaterialSettingsEx matSettings)
        {
            switch (matSettings.KeepAspect)
            {
                case CGKeepAspectMode.Off:
                    AspectCorrectionV = 1;
                    AspectCorrectionU = 1;
                    break;
                case CGKeepAspectMode.ScaleU:
                case CGKeepAspectMode.ScaleV:
                    {
                        float crossLength = 0;
                        float uLength = 0;
                        for (int g = 0; g < Count; g++)
                        {
                            float length, u;
                            this[g].GetLengths(volume, out length, out u);
                            crossLength += length;
                            uLength += u;
                        }

                        if (matSettings.KeepAspect == CGKeepAspectMode.ScaleU)
                        {
                            AspectCorrectionV = 1;
                            AspectCorrectionU = crossLength / volume.Length;
                        }
                        else
                        {
                            AspectCorrectionV = volume.Length * uLength / crossLength;
                            AspectCorrectionU = 1;
                        }
                    }
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }

    /// <summary>
    /// Class referencing a particular module's output slot
    /// </summary>
    /// <remarks>When using, be sure to add the <see cref="CGDataReferenceSelectorAttribute"/> to the field</remarks>
    [System.Serializable]
    public class CGDataReference
    {
        [SerializeField] private CGModule m_Module;
        [SerializeField] private string m_SlotName;

        private CGModuleOutputSlot mSlot;

        public CGData[] Data
        {
            get
            {
                return (Slot != null) ? Slot.Data : new CGData[0];
            }
        }

        public CGModuleOutputSlot Slot
        {
            get
            {
                if ((mSlot == null || mSlot.Module != m_Module || mSlot.Info == null || mSlot.Info.Name != m_SlotName) && m_Module != null && m_Module.Generator != null && m_Module.Generator.IsInitialized && !string.IsNullOrEmpty(m_SlotName))
                {
                    mSlot = m_Module.GetOutputSlot(m_SlotName);
                }
                return mSlot;
            }
        }

        public bool HasValue
        {
            get
            {
                CGModuleOutputSlot cgModuleOutputSlot = Slot;
                return (cgModuleOutputSlot != null) && cgModuleOutputSlot.Data.Length > 0;
            }
        }

        public bool IsEmpty
        {
            get { return string.IsNullOrEmpty(SlotName); }
        }

        public CGModule Module
        {
            get { return m_Module; }
        }
        public string SlotName
        {
            get { return m_SlotName; }
        }

        public CGDataReference()
        {
        }

        public CGDataReference(CGModule module, string slotName)
        {
            setINTERNAL(module, slotName);
        }

        public CGDataReference(CurvyGenerator generator, string moduleName, string slotName)
        {
            setINTERNAL(generator, moduleName, slotName);
        }

        public void Clear()
        {
            setINTERNAL(null, string.Empty);
        }

        public T GetData<T>() where T : CGData
        {
            return (Data.Length == 0) ? null : Data[0] as T;
        }

        public T[] GetAllData<T>() where T : CGData
        {
            return Data as T[];
        }

        #region ### Privates & Internals ###
        /*! \cond PRIVATE */

        public void setINTERNAL(CGModule module, string slotName)
        {
            m_Module = module;
            m_SlotName = slotName;
            mSlot = null;
        }

        public void setINTERNAL(CurvyGenerator generator, string moduleName, string slotName)
        {
            m_Module = generator.GetModule(moduleName, false);
            m_SlotName = slotName;
            mSlot = null;
        }

        /*! \endcond */
        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGClasses.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1e4fde665d7cfa546a1c391d055728ec
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools.Extensions;
using System;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Runtime.CompilerServices;
using FluffyUnderware.Curvy.Pools;
using ToolBuddy.Pooling.Pools;
using FluffyUnderware.DevTools;
using JetBrains.Annotations;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;
using UnityEngine.Rendering;

#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif




namespace FluffyUnderware.Curvy.Generator
{
    //TODO replace all the misuse of the F concept here, where it should really be RelativeDistance 

    /// <summary>
    /// Additional properties for CGData based classes
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class CGDataInfoAttribute : Attribute
    {
        public readonly Color Color;

        public CGDataInfoAttribute(Color color)
        {
            Color = color;
        }

        public CGDataInfoAttribute(float r, float g, float b, float a = 1)
        {
            Color = new Color(r, g, b, a);
        }

        public CGDataInfoAttribute(string htmlColor)
        {
            Color = htmlColor.ColorFromHtml();
        }
    }

    /// <summary>
    /// Data Base class
    /// </summary>
    public class CGData : IDisposable
    {
        #region Dispose pattern

        private bool disposed = false;

        protected virtual bool Dispose(bool disposing)
        {
            if (disposed)
            {
                DTLog.LogWarning("[Curvy] Attempt to dispose a CGData twice. Please raise a bug report.");
                return false;
            }

            disposed = true;
            return true;
        }

        /// <summary>
        /// Disposes an instance that is no more used, allowing it to free its resources immediately.
        /// Dispose is called automatically when an instance is <see cref="Finalize"/>d
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~CGData()
        {
            Dispose(false);
        }

        #endregion

        public string Name;

        public virtual int Count
        {
            get { return 0; }
        }

        public static implicit operator bool(CGData a)
        {
            return !ReferenceEquals(a, null);
        }

        public virtual T Clone<T>() where T : CGData
        {
            return new CGData() as T;
        }

        /// <summary>
        /// Searches FMapArray and returns the index that covers the fValue as well as the percentage between index and index+1
        /// </summary>
        /// <param name="FMapArray">array of sorted values ranging from 0..1</param>
        /// <param name="fValue">a value 0..1</param>
        /// <param name="frag">fragment between the resulting and the next index (0..1)</param>
        /// <returns>the index where fValue lies in</returns>
        protected int getGenericFIndex(SubArray<float> FMapArray, float fValue, out float frag)
        {
            //WARNING this method is inlined in DeformMesh, if you modify something here modify it there too
            int index = CurvyUtility.InterpolationSearch(FMapArray.Array, FMapArray.Count, fValue);

            if (index == FMapArray.Count - 1)
            {
                index -= 1;
                frag = 1;
            }
            else
                frag = (fValue - FMapArray.Array[index]) / (FMapArray.Array[index + 1] - FMapArray.Array[index]);

            return index;
        }
    }

    /// <summary>
    /// Rasterized Shape Data (Polyline)
    /// </summary>
    [CGDataInfo(0.73f, 0.87f, 0.98f)]
    public class CGShape : CGData
    {
        /// <summary>
        /// The relative distance of each point.
        /// A relative distance is a value between 0 and 1 representing how far the point is in a shape.
        /// A value of 0 means the start of the shape, and a value of 1 means the end of it.
        /// It is defined as (the point's distance from the shape's start) / (the total length of the shape)
        /// This is unrelated to the notion of <seealso cref="CurvySplineSegment.TF"/> or F of a spline.
        /// Unfortunately, it is abusively called F in big parts of the the Curvy Generator related code, sorry for the confusion.
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<float> RelativeDistances
        {
            get => relativeDistances;
            set
            {
                ArrayPools.Single.Free(relativeDistances);
                relativeDistances = value;
            }
        }

        /// <summary>
        /// The relative distance of each point relative to the source shape.
        /// A relative distance is a value between 0 and 1 representing how far the point is in a shape.
        /// A value of 0 means the start of the shape, and a value of 1 means the end of it.
        /// It is defined as (the point's distance from the shape's start) / (the total length of the shape)
        /// Contrary to <seealso cref="RelativeDistances"/> which is computed based on the actual shape, SourceRelativeDistances is computed based on the source shape.
        /// For example, if a Shape A is defined as the second quarter of a Shape B, A's first point will have a relative distance of 0, but a source relative distance of 0.25. A's last point will have a relative distance of 1, but a source relative distance of 0.5
        /// This is unrelated to the notion of <seealso cref="CurvySplineSegment.TF"/> or F of a spline.
        /// Unfortunately, it is abusively called F in big parts of the the Curvy Generator related code, sorry for the confusion.
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<float> SourceRelativeDistances
        {
            get => sourceRelativeDistances;
            set
            {
                ArrayPools.Single.Free(sourceRelativeDistances);
                sourceRelativeDistances = value;
            }
        }

        /// <summary>
        /// Positions of the path's points, in the path's local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector3> Positions
        {
            get => positions;
            set
            {
                ArrayPools.Vector3.Free(positions);
                positions = value;
            }
        }

        /// <summary>
        /// Normals of the path's points, in the path's local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector3> Normals
        {
            get => normals;
            set
            {
                ArrayPools.Vector3.Free(normals);
                normals = value;
            }
        }

        /// <summary>
        /// Arbitrary mapped value to each point, usually U coordinate
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<float> CustomValues
        {
            get => customValues;
            set
            {
                ArrayPools.Single.Free(customValues);
                customValues = value;
            }
        }

        /// <summary>
        /// The list of the shape's <see cref="DuplicatePoints"/>
        /// </summary>
        public List<DuplicateSamplePoint> DuplicatePoints { get; set; }

        #region Obsolete

        /// <summary>
        /// The relative distance of each point.
        /// A relative distance is a value between 0 and 1 representing how far the point is in a shape.
        /// A value of 0 means the start of the shape, and a value of 1 means the end of it.
        /// It is defined as (the point's distance from the shape's start) / (the total length of the shape)
        /// This is unrelated to the notion of <seealso cref="CurvySplineSegment.TF"/> or F of a spline.
        /// Unfortunately, it is abusively called F in big parts of the the Curvy Generator related code, sorry for the confusion.
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use RelativeDistances instead")]
        public float[] F
        {
            get => RelativeDistances.CopyToArray(ArrayPools.Single);
            set => RelativeDistances = new SubArray<float>(value);
        }

        /// <summary>
        /// The relative distance of each point relative to the source shape.
        /// A relative distance is a value between 0 and 1 representing how far the point is in a shape.
        /// A value of 0 means the start of the shape, and a value of 1 means the end of it.
        /// It is defined as (the point's distance from the shape's start) / (the total length of the shape)
        /// Contrary to <seealso cref="RelativeDistances"/> which is computed based on the actual shape, SourceRelativeDistances is computed based on the source shape.
        /// For example, if a Shape A is defined as the second quarter of a Shape B, A's first point will have a relative distance of 0, but a source relative distance of 0.25. A's last point will have a relative distance of 1, but a source relative distance of 0.5
        /// This is unrelated to the notion of <seealso cref="CurvySplineSegment.TF"/> or F of a spline.
        /// Unfortunately, it is abusively called F in big parts of the the Curvy Generator related code, sorry for the confusion.
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use SourceRelativeDistances instead")]
        public float[] SourceF
        {
            get => SourceRelativeDistances.CopyToArray(ArrayPools.Single);
            set => SourceRelativeDistances = new SubArray<float>(value);
        }

        /// <summary>
        /// Positions of the path's points, in the path's local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use Positions instead")]
        public Vector3[] Position
        {
            get => Positions.CopyToArray(ArrayPools.Vector3);
            set => Positions = new SubArray<Vector3>(value);
        }

        /// <summary>
        /// Normals of the path's points, in the path's local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use Normals instead")]
        public Vector3[] Normal
        {
            get => Normals.CopyToArray(ArrayPools.Vector3);
            set => Normals = new SubArray<Vector3>(value);
        }

        /// <summary>
        /// Arbitrary mapped value to each point, usually U coordinate
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use CustomValues instead")]
        public float[] Map
        {
            get => CustomValues.CopyToArray(ArrayPools.Single);
            set => CustomValues = new SubArray<float>(value);
        }

        #endregion

        /// <summary>
        /// Groups/Patches
        /// </summary>
        public List<SamplePointsMaterialGroup> MaterialGroups;
        /// <summary>
        /// Whether the source is managed or not
        /// </summary>
        /// <remarks>This could be used to determine if values needs to be transformed into generator space or not</remarks>
        public bool SourceIsManaged;
        /// <summary>
        /// Whether the base spline is closed or not
        /// </summary>
        public bool Closed;
        /// <summary>
        /// Whether the Shape/Path is seamless, i.e. Closed==true and the whole length is covered
        /// </summary>
        public bool Seamless;
        /// <summary>
        /// Length in world units
        /// </summary>
        public float Length;

        /// <summary>
        /// Gets the number of sample points
        /// </summary>
        public override int Count
        {
            get { return relativeDistances.Count; }
        }

        #region ### Private fields ###

        //TODO Debug time checks that F arrays contain values between 0 and 1
        private SubArray<float> relativeDistances;
        //OPTIM can the storage of this array be avoided by storing only SourceF and the start and end Distance, and infer F values only when needed?
        //OPTIM can we just assign SourceF to F when start and end distances are equal to respectively 0 and 1? (which is the case most of the time)
        private SubArray<float> sourceRelativeDistances;
        private SubArray<Vector3> positions;
        private SubArray<Vector3> normals;
        /*TODO Map is defined in CGShape but:
        1- filling it inside an instance of CGPath (which inherits from CGShape) is useless, since Map is used only by CGVolume when it takes it from a CGShape, and not a CGPath. So an optimization would be to not fill Map for instances not consumed by CGVolume
        2- I hope that storing it might be not needed, and calculating it only when needed might be possible
       */
        private SubArray<float> customValues;

        // Caching
        //TODO DESIGN OPTIM are these still needed, now that GetFIndex was greatly optimized?
        private float mCacheLastF = float.MaxValue;
        private int mCacheLastIndex;
        private float mCacheLastFrag;

        #endregion

        public CGShape() : base()
        {
            sourceRelativeDistances = ArrayPools.Single.Allocate(0);
            relativeDistances = ArrayPools.Single.Allocate(0);
            positions = ArrayPools.Vector3.Allocate(0);
            normals = ArrayPools.Vector3.Allocate(0);
            customValues = ArrayPools.Single.Allocate(0);
            DuplicatePoints = new List<DuplicateSamplePoint>();
            MaterialGroups = new List<SamplePointsMaterialGroup>();
        }

        public CGShape(CGShape source) : base()
        {
            positions = ArrayPools.Vector3.Clone(source.positions);
            normals = ArrayPools.Vector3.Clone(source.normals);
            customValues = ArrayPools.Single.Clone(source.customValues);
            DuplicatePoints = new List<DuplicateSamplePoint>(source.DuplicatePoints);
            relativeDistances = ArrayPools.Single.Clone(source.relativeDistances);
            sourceRelativeDistances = ArrayPools.Single.Clone(source.sourceRelativeDistances);
            MaterialGroups = new List<SamplePointsMaterialGroup>(source.MaterialGroups.Count);
            foreach (SamplePointsMaterialGroup materialGroup in source.MaterialGroups)
                MaterialGroups.Add(materialGroup.Clone());
            Closed = source.Closed;
            Seamless = source.Seamless;
            Length = source.Length;
            SourceIsManaged = source.SourceIsManaged;
        }

        protected override bool Dispose(bool disposing)
        {
            bool result = base.Dispose(disposing);
            if (result)
            {
                ArrayPools.Single.Free(sourceRelativeDistances);
                ArrayPools.Single.Free(relativeDistances);
                ArrayPools.Vector3.Free(positions);
                ArrayPools.Vector3.Free(normals);
                ArrayPools.Single.Free(customValues);
            }

            return result;
        }

        public override T Clone<T>()
        {
            return new CGShape(this) as T;
        }

        public static void Copy(CGShape dest, CGShape source)
        {
            ArrayPools.Vector3.Resize(ref dest.positions, source.positions.Count);
            Array.Copy(source.positions.Array, 0, dest.positions.Array, 0, source.positions.Count);
            ArrayPools.Vector3.Resize(ref dest.normals, source.normals.Count);
            Array.Copy(source.normals.Array, 0, dest.normals.Array, 0, source.normals.Count);
            ArrayPools.Single.Resize(ref dest.customValues, source.customValues.Count);
            Array.Copy(source.customValues.Array, 0, dest.customValues.Array, 0, source.customValues.Count);
            ArrayPools.Single.Resize(ref dest.relativeDistances, source.relativeDistances.Count);
            Array.Copy(source.relativeDistances.Array, 0, dest.relativeDistances.Array, 0, source.relativeDistances.Count);
            ArrayPools.Single.Resize(ref dest.sourceRelativeDistances, source.sourceRelativeDistances.Count);
            Array.Copy(source.sourceRelativeDistances.Array, 0, dest.sourceRelativeDistances.Array, 0, source.sourceRelativeDistances.Count);
            dest.DuplicatePoints.Clear();
            dest.DuplicatePoints.AddRange(source.DuplicatePoints);
            dest.MaterialGroups = source.MaterialGroups.Select(g => g.Clone()).ToList();
            dest.Closed = source.Closed;
            dest.Seamless = source.Seamless;
            dest.Length = source.Length;
        }

        //TODO documentation and whatnot
        public void Copy(CGShape source) { Copy(this, source); }

        /// <summary>
        /// Converts absolute (World Units) to relative (F) distance
        /// </summary>
        /// <param name="distance">distance in world units</param>
        /// <returns>Relative distance (0..1)</returns>
        public float DistanceToF(float distance)
        {
            return Mathf.Clamp(distance, 0, Length) / Length;
        }

        /// <summary>
        /// Converts relative (F) to absolute distance (World Units)
        /// </summary>
        /// <param name="f">relative distance (0..1)</param>
        /// <returns>Distance in World Units</returns>
        public float FToDistance(float f)
        {
            return Mathf.Clamp01(f) * Length;
        }

        /// <summary>
        /// Gets the index of a certain F
        /// </summary>
        /// <param name="f">F (0..1)</param>
        /// <param name="frag">fragment between the resulting and the next index (0..1)</param>
        /// <returns>the resulting index</returns>
        public int GetFIndex(float f, out float frag)
        {
#if CURVY_SANITY_CHECKS_PRIVATE
            Assert.IsTrue(f >= 0);
            if (f > 1)
                Debug.LogWarning(f);
#endif
            if (mCacheLastF != f)
            {
                mCacheLastF = f;
                //OPTIM make sure f is a ratio, then remove the following line
                float fValue = f == 1 ? f : f % 1;
                mCacheLastIndex = getGenericFIndex(relativeDistances, fValue, out mCacheLastFrag);
            }
            frag = mCacheLastFrag;

            return mCacheLastIndex;
        }

        /*
        /// <summary>
        /// Gets the index of a certain SourceF
        /// </summary>
        /// <param name="sourceF">F (0..1)</param>
        /// <param name="frag">fragment between the resulting and the next index (0..1)</param>
        /// <returns>the resulting index</returns>
        public int GetSourceFIndex(float sourceF, out float frag)
        {
            if (mCacheLastSourceF != sourceF)
            {
                mCacheLastSourceF = sourceF;

                mCacheLastSourceIndex = getGenericFIndex(ref F, sourceF, out mCacheLastSourceFrag);
            }
            frag = mCacheLastSourceFrag;
            return mCacheLastSourceIndex;
        }
        */
        /// <summary>
        /// Interpolates Position by F
        /// </summary>
        /// <param name="f">0..1</param>
        /// <returns>the interpolated position</returns>
        public Vector3 InterpolatePosition(float f)
        {
            float frag;
            int idx = GetFIndex(f, out frag);
            return OptimizedOperators.LerpUnclamped(positions.Array[idx], positions.Array[idx + 1], frag);
        }

        /// <summary>
        /// Interpolates Normal by F
        /// </summary>
        /// <param name="f">0..1</param>
        /// <returns>the interpolated normal</returns>
        public Vector3 InterpolateUp(float f)
        {
            float frag;
            int idx = GetFIndex(f, out frag);
            return Vector3.SlerpUnclamped(normals.Array[idx], normals.Array[idx + 1], frag);
        }

        /// <summary>
        /// Interpolates Position and Normal by F
        /// </summary>
        /// <param name="f">0..1</param>
        /// <param name="position"></param>
        /// <param name="up">a.k.a normal</param>
        public void Interpolate(float f, out Vector3 position, out Vector3 up)
        {
            float frag;
            int idx = GetFIndex(f, out frag);
            position = OptimizedOperators.LerpUnclamped(positions.Array[idx], positions.Array[idx + 1], frag);
            up = Vector3.SlerpUnclamped(normals.Array[idx], normals.Array[idx + 1], frag);
        }

        public void Move(ref float f, ref int direction, float speed, CurvyClamping clamping)
        {
            f = CurvyUtility.ClampTF(f + speed * direction, ref direction, clamping);
        }

        public void MoveBy(ref float f, ref int direction, float speedDist, CurvyClamping clamping)
        {
            float dist = CurvyUtility.ClampDistance(FToDistance(f) + speedDist * direction, ref direction, clamping, Length);
            f = DistanceToF(dist);
        }

        /// <summary>
        /// Recalculate Length and RelativeDistances (by measuring a polyline built from all Position points)
        /// </summary>
        /// <remarks>Call this after TRS'ing a shape</remarks>
        public virtual void Recalculate()
        {
            Length = 0;
            SubArray<float> dist = ArrayPools.Single.Allocate(Count);

            for (int i = 1; i < Count; i++)
            {
                dist.Array[i] = dist.Array[i - 1] + (positions.Array[i].Subtraction(positions.Array[i - 1])).magnitude;

            }

            if (Count > 0)
            {
                Length = dist.Array[Count - 1];
                if (Length > 0)
                {

                    relativeDistances.Array[0] = 0;
                    float oneOnLength = 1 / Length;
                    for (int i = 1; i < Count - 1; i++)
                        relativeDistances.Array[i] = dist.Array[i] * oneOnLength;
                    relativeDistances.Array[Count - 1] = 1;
                }
                else
                {
                    ArrayPools.Single.ResizeAndClear(ref relativeDistances, Count);
                }
            }

            ArrayPools.Single.Free(dist);

            //for (int i = 1; i < Count; i++)
            //    Direction[i] = (Position[i] - Position[i - 1]).normalized;
        }

        [Obsolete("Use another overload of RecalculateNormals instead")]
        public void RecalculateNormals(List<int> softEdges)
        {
            //TODO this implementation works properly with 2D shapes, but creates invalid results with 3D paths. This is ok for now because the code calls it only on shapes, but it is a ticking bomb
            //TODO document the method after fixing it
            if (normals.Count != positions.Count)
            {
                ArrayPools.Vector3.Resize(ref normals, positions.Count);
            }

            for (int mg = 0; mg < MaterialGroups.Count; mg++)
            {
                for (int p = 0; p < MaterialGroups[mg].Patches.Count; p++)
                {
                    SamplePointsPatch patch = MaterialGroups[mg].Patches[p];
                    Vector3 t;
                    for (int vt = 0; vt < patch.Count; vt++)
                    {
                        int x = patch.Start + vt;
                        t = (positions.Array[x + 1] - positions.Array[x]).normalized;
                        normals.Array[x] = new Vector3(-t.y, t.x, 0);
#if CURVY_SANITY_CHECKS_PRIVATE
                        if (normals.Array[x].magnitude.Approximately(1f) == false)
                            Debug.LogError($"Normal is not normalized, length was {normals.Array[x].magnitude}");//happens if shape is not in the XY plane
#endif
                    }
                    t = (positions.Array[patch.End] - positions.Array[patch.End - 1]).normalized;
                    normals.Array[patch.End] = new Vector3(-t.y, t.x, 0);
#if CURVY_SANITY_CHECKS_PRIVATE
                    if (normals.Array[patch.End].magnitude.Approximately(1f) == false)
                        Debug.LogError("Normal is not normalized");//happens if shape is not in the XY plane
#endif
                }
            }

            // Handle soft edges
            for (int i = 0; i < softEdges.Count; i++)
            {
                int previous = softEdges.ToArray()[i] - 1;
                if (previous < 0)
                    previous = positions.Count - 1;

                int beforePrevious = previous - 1;
                if (beforePrevious < 0)
                    beforePrevious = positions.Count - 1;

                int next = softEdges.ToArray()[i] + 1;
                if (next == positions.Count)
                    next = 0;

                normals.Array[softEdges.ToArray()[i]] = Vector3.Slerp(normals.Array[beforePrevious], normals.Array[next], 0.5f);
                normals.Array[previous] = normals.Array[softEdges.ToArray()[i]];
            }
        }

        /// <summary>
        /// Recalculate the shape's <see cref="Normals"/> based on the spline the shape was rasterized from
        /// </summary>
        public void RecalculateNormals([NotNull] CurvySpline spline)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsFalse(spline.Orientation == CurvyOrientation.None);
#endif
            if (normals.Count != positions.Count)
            {
                ArrayPools.Vector3.Resize(ref normals, positions.Count);
            }

            Vector3[] normalsArray = normals.Array;
            float[] floats = SourceRelativeDistances.Array;

            for (int mg = 0; mg < MaterialGroups.Count; mg++)
            {
                for (int p = 0; p < MaterialGroups[mg].Patches.Count; p++)
                {
                    SamplePointsPatch patch = MaterialGroups[mg].Patches[p];
                    for (int vt = 0; vt < patch.Count; vt++)
                    {
                        int x = patch.Start + vt;
                        normalsArray[x] = spline.GetOrientationUpFast(spline.DistanceToTF(spline.Length * floats[x]), Space.Self);
#if CURVY_SANITY_CHECKS_PRIVATE
                        if (normalsArray[x].magnitude.Approximately(1f) == false)
                            Debug.LogError($"Normal is not normalized, length was {normalsArray[x].magnitude}");//happens if shape is not in the XY plane
#endif
                    }

                    normalsArray[patch.End] = spline.GetOrientationUpFast(spline.DistanceToTF(spline.Length * floats[patch.End]), Space.Self);
#if CURVY_SANITY_CHECKS_PRIVATE
                    if (normalsArray[patch.End].magnitude.Approximately(1f) == false)
                        Debug.LogError("Normal is not normalized");//happens if shape is not in the XY plane
#endif
                }
            }

            // Handle soft edges
            foreach (DuplicateSamplePoint duplicateSamplePoint in DuplicatePoints)
            {
                if (duplicateSamplePoint.IsHardEdge)
                {
                    int index = duplicateSamplePoint.StartIndex;
                    normalsArray[index] = normalsArray[Math.Max(0, index - 1)];
                }
            }
        }

        /// <summary>
        /// Recalculate the shape's <see cref="Normals"/> based on shape's rasterized <see cref="Positions"/>
        /// </summary>
        public void RecalculateNormals()
        {
            //TODO this implementation works properly with 2D shapes, but creates invalid results with 3D paths. This is ok for now because the code calls it only on shapes, but it is a ticking bomb
            //TODO document the method after fixing it
            if (normals.Count != positions.Count)
            {
                ArrayPools.Vector3.Resize(ref normals, positions.Count);
            }

            Vector3[] positionsArray = positions.Array;
            Vector3[] normalsArray = normals.Array;

            for (int mg = 0; mg < MaterialGroups.Count; mg++)
            {
                for (int p = 0; p < MaterialGroups[mg].Patches.Count; p++)
                {
                    SamplePointsPatch patch = MaterialGroups[mg].Patches[p];
                    Vector3 t;
                    int x;
                    for (int vt = 0; vt < patch.Count; vt++)
                    {
                        x = patch.Start + vt;
                        t = (positionsArray[x + 1] - positionsArray[x]).normalized;
                        //todo handle case where t = 0
                        normalsArray[x] = new Vector3(-t.y, t.x, 0);
#if CURVY_SANITY_CHECKS_PRIVATE
                        if (normalsArray[x].magnitude.Approximately(1f) == false)
                            Debug.LogError($"Normal is not normalized, length was {normalsArray[x].magnitude}");//happens if shape is not in the XY plane or if length is 0
#endif
                    }
                    t = (positionsArray[patch.End] - positionsArray[patch.End - 1]).normalized;
                    normalsArray[patch.End] = new Vector3(-t.y, t.x, 0);
#if CURVY_SANITY_CHECKS_PRIVATE
                    if (normalsArray[patch.End].magnitude.Approximately(1f) == false)
                        Debug.LogError("Normal is not normalized");//happens if shape is not in the XY plane
#endif
                }
            }

            // Handle soft edges
            foreach (DuplicateSamplePoint duplicateSamplePoint in DuplicatePoints)
            {
                if (duplicateSamplePoint.IsHardEdge == false)
                {
                    int previous = duplicateSamplePoint.EndIndex - 1;
                    if (previous < 0)
                        previous = positions.Count - 1;

                    int beforePrevious = previous - 1;
                    if (beforePrevious < 0)
                        beforePrevious = positions.Count - 1;

                    int next = duplicateSamplePoint.EndIndex + 1;
                    if (next == positions.Count)
                        next = 0;

                    normalsArray[duplicateSamplePoint.EndIndex] = Vector3.Slerp(normalsArray[beforePrevious], normalsArray[next], 0.5f);
                    normalsArray[previous] = normalsArray[duplicateSamplePoint.EndIndex];

                }
            }
        }
    }

    /// <summary>
    /// Path Data (Shape + Direction (Spline Tangents) + Orientation/Up)
    /// </summary>
    [CGDataInfo(0.13f, 0.59f, 0.95f)]
    public class CGPath : CGShape
    {
        /// <summary>
        /// Tangents of the path's points, in the path's local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector3> Directions
        {
            get => directions;
            set
            {
                ArrayPools.Vector3.Free(directions);
                directions = value;
            }
        }

        /// <summary>
        /// Tangents of the path's points, in the path's local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use Directions instead")]
        public Vector3[] Direction
        {
            get => Directions.CopyToArray(ArrayPools.Vector3);
            set => Directions = new SubArray<Vector3>(value);
        }

        private SubArray<Vector3> directions;

        public CGPath() : base()
        {
            directions = ArrayPools.Vector3.Allocate(0);
        }
        public CGPath(CGPath source) : base(source)
        {
            directions = ArrayPools.Vector3.Clone(source.directions);
        }

        protected override bool Dispose(bool disposing)
        {
            bool result = base.Dispose(disposing);
            if (result)
                ArrayPools.Vector3.Free(directions);
            return result;
        }

        public override T Clone<T>()
        {
            return new CGPath(this) as T;
        }

        public static void Copy(CGPath dest, CGPath source)
        {
            CGShape.Copy(dest, source);
            ArrayPools.Vector3.Resize(ref dest.directions, source.directions.Count);
            Array.Copy(source.directions.Array, 0, dest.directions.Array, 0, source.directions.Count);
        }

        /// <summary>
        /// Interpolates Position, Direction and Normal by F
        /// </summary>
        /// <param name="f">0..1</param>
        /// <param name="position"></param>
        /// <param name="direction">a.k.a tangent</param>
        /// <param name="up">a.k.a normal</param>
        public void Interpolate(float f, out Vector3 position, out Vector3 direction, out Vector3 up)
        {
            float frag;
            int idx = GetFIndex(f, out frag);
            position = OptimizedOperators.LerpUnclamped(Positions.Array[idx], Positions.Array[idx + 1], frag);
            direction = Vector3.SlerpUnclamped(directions.Array[idx], directions.Array[idx + 1], frag);
            up = Vector3.SlerpUnclamped(Normals.Array[idx], Normals.Array[idx + 1], frag);
        }

        [Obsolete("Method is no more used by Curvy and will get removed. Copy its content if you still need it")]
        public void Interpolate(float f, float angleF, out Vector3 pos, out Vector3 dir, out Vector3 up)
        {
            Interpolate(f, out pos, out dir, out up);
            if (angleF != 0)
            {
                Quaternion R = Quaternion.AngleAxis(angleF * -360, dir);
                up = R * up;
            }
        }

        /// <summary>
        /// Interpolates Direction by F
        /// </summary>
        /// <param name="f">0..1</param>
        public Vector3 InterpolateDirection(float f)
        {
            float frag;
            int idx = GetFIndex(f, out frag);
            return Vector3.SlerpUnclamped(directions.Array[idx], directions.Array[idx + 1], frag);
        }
    }

    /// <summary>
    /// Volume Data (Path + Vertex, VertexNormal, Cross)
    /// </summary>
    [CGDataInfo(0.08f, 0.4f, 0.75f)]
    public class CGVolume : CGPath
    {
        /// <summary>
        /// Positions of the points, in the local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector3> Vertices
        {
            get => vertices;
            set
            {
                ArrayPools.Vector3.Free(vertices);
                vertices = value;
            }
        }

        /// <summary>
        /// Notmals of the points, in the local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector3> VertexNormals
        {
            get => vertexNormals;
            set
            {
                ArrayPools.Vector3.Free(vertexNormals);
                vertexNormals = value;
            }
        }

        /// <summary>
        /// The <see cref="CGShape.F"/> of the <see cref="CGShape"/> used in the extrusion of this volume
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<float> CrossRelativeDistances
        {
            get => crossRelativeDistances;
            set
            {
                ArrayPools.Single.Free(crossRelativeDistances);
                crossRelativeDistances = value;
            }
        }

        /// <summary>
        /// The <see cref="CGShape.CustomValues"/> of the <see cref="CGShape"/> used in the extrusion of this volume
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<float> CrossCustomValues
        {
            get => crossCustomValues;
            set
            {
                ArrayPools.Single.Free(crossCustomValues);
                crossCustomValues = value;
            }
        }

        /// <summary>
        /// The 2D scale of the mesh at each sample point of the volume's path
        /// </summary>
        public SubArray<Vector2> Scales
        {
            get => scales;
            set
            {
                ArrayPools.Vector2.Free(scales);
                scales = value;
            }
        }

        #region Obsolete

        /// <summary>
        /// Positions of the points, in the local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use Vertices instead")]
        public Vector3[] Vertex
        {
            get => Vertices.CopyToArray(ArrayPools.Vector3);
            set => Vertices = new SubArray<Vector3>(value);
        }

        /// <summary>
        /// Normals of the points, in the local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use VertexNormals instead")]
        public Vector3[] VertexNormal
        {
            get => VertexNormals.CopyToArray(ArrayPools.Vector3);
            set => VertexNormals = new SubArray<Vector3>(value);
        }

        /// <summary>
        /// The <see cref="CGShape.F"/> of the <see cref="CGShape"/> used in the extrusion of this volume
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use CrossRelativeDistances instead")]
        public float[] CrossF
        {
            get => CrossRelativeDistances.CopyToArray(ArrayPools.Single);
            set => CrossRelativeDistances = new SubArray<float>(value);
        }

        /// <summary>
        /// The <see cref="CGShape.CustomValues"/> of the <see cref="CGShape"/> used in the extrusion of this volume
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use CrossCustomValues instead")]
        public float[] CrossMap
        {
            get => CrossCustomValues.CopyToArray(ArrayPools.Single);
            set => CrossCustomValues = new SubArray<float>(value);
        }

        #endregion

        /// <summary>
        /// Length of a given cross segment. Will be calculated on demand only!
        /// </summary>
        [Obsolete("Do not use this. Use the GetCrossLength method instead")]
        public float[] SegmentLength
        {
            get
            {
                if (_segmentLength == null)
                    _segmentLength = new float[Count];
                return _segmentLength;
            }
            set => _segmentLength = value;
        }

        /// <summary>
        /// Gets the number of cross shape's sample points
        /// </summary>
        public int CrossSize { get { return crossRelativeDistances.Count; } }
        /// <summary>
        /// Whether the Cross base spline is closed or not
        /// </summary>
        public bool CrossClosed;//TODO make obsolete then remove this, it is not needed by Curvy
        /// <summary>
        /// Whether the Cross shape covers the whole length of the base spline
        /// </summary>
        public bool CrossSeamless;
        /// <summary>
        /// A shift of the <see cref="CrossRelativeDistances"/> value that is applied when using the interpolation methods on the volume, like <see cref="InterpolateVolume"/>
        /// </summary>
        public float CrossFShift;

        public SamplePointsMaterialGroupCollection CrossMaterialGroups;

        public int VertexCount { get { return vertices.Count; } }

        #region private fields

        private SubArray<Vector3> vertices;
        private SubArray<Vector3> vertexNormals;
        private SubArray<float> crossRelativeDistances;
        private SubArray<float> crossCustomValues;
        private SubArray<Vector2> scales;
        [Obsolete("Do not use this. Use the GetCrossLength method instead")]
        private float[] _segmentLength;

        #endregion

        #region ### Constructors ###

        [Obsolete("Use one of the other constructors")]
        public CGVolume() : base() { }

        public CGVolume(int samplePoints, CGShape crossShape) : base()
        {
            crossRelativeDistances = ArrayPools.Single.Clone(crossShape.RelativeDistances);
            crossCustomValues = ArrayPools.Single.Clone(crossShape.CustomValues);
            scales = ArrayPools.Vector2.Allocate(samplePoints);
            CrossClosed = crossShape.Closed;
            CrossSeamless = crossShape.Seamless;
            CrossMaterialGroups = new SamplePointsMaterialGroupCollection(crossShape.MaterialGroups);
            vertices = ArrayPools.Vector3.Allocate(CrossSize * samplePoints);
            vertexNormals = ArrayPools.Vector3.Allocate(vertices.Count);
        }

        public CGVolume(CGPath path, CGShape crossShape)
            : base(path)
        {
            crossRelativeDistances = ArrayPools.Single.Clone(crossShape.RelativeDistances);
            crossCustomValues = ArrayPools.Single.Clone(crossShape.CustomValues);
            scales = ArrayPools.Vector2.Allocate(Count);
            CrossClosed = crossShape.Closed;
            CrossSeamless = crossShape.Seamless;
            CrossMaterialGroups = new SamplePointsMaterialGroupCollection(crossShape.MaterialGroups);
            vertices = ArrayPools.Vector3.Allocate(CrossSize * Count);
            vertexNormals = ArrayPools.Vector3.Allocate(vertices.Count);
        }

        public CGVolume(CGVolume source)
            : base(source)
        {
            vertices = ArrayPools.Vector3.Clone(source.vertices);
            vertexNormals = ArrayPools.Vector3.Clone(source.vertexNormals);
            crossRelativeDistances = ArrayPools.Single.Clone(source.crossRelativeDistances);
            crossCustomValues = ArrayPools.Single.Clone(source.crossCustomValues);
            scales = ArrayPools.Vector2.Clone(source.scales);
            CrossClosed = source.Closed;
            CrossSeamless = source.CrossSeamless;
            CrossFShift = source.CrossFShift;
            CrossMaterialGroups = new SamplePointsMaterialGroupCollection(source.CrossMaterialGroups);
        }

        #endregion

        protected override bool Dispose(bool disposing)
        {
            bool result = base.Dispose(disposing);
            if (result)
            {
                ArrayPools.Vector3.Free(vertices);
                ArrayPools.Vector3.Free(vertexNormals);
                ArrayPools.Single.Free(crossRelativeDistances);
                ArrayPools.Single.Free(crossCustomValues);
                ArrayPools.Vector2.Free(scales);
#pragma warning disable 618
                if (SegmentLength != null)
                    ArrayPools.Single.Free(SegmentLength);
#pragma warning restore 618
            }

            return result;
        }

        /// <summary>
        /// Returns a CGVolume made from the given CGPath and CGShape
        /// </summary>
        /// <param name="data">If not null, the returned instance will be the one but with its fields updated. If null, a new instance will be created</param>
        /// <param name="path">The path used in the creation of the volume</param>
        /// <param name="crossShape">The shape used in the creation of the volume</param>
        /// <returns></returns>
        public static CGVolume Get(CGVolume data, CGPath path, CGShape crossShape)
        {
            if (data == null)
                return new CGVolume(path, crossShape);

            Copy(data, path);

#pragma warning disable 618
            if (data._segmentLength != null)
                data.SegmentLength = new float[data.Count];
#pragma warning restore 618

            // Volume
            ArrayPools.Single.Resize(ref data.crossRelativeDistances, crossShape.RelativeDistances.Count, false);
            Array.Copy(crossShape.RelativeDistances.Array, 0, data.crossRelativeDistances.Array, 0, crossShape.RelativeDistances.Count);

            ArrayPools.Single.Resize(ref data.crossCustomValues, crossShape.CustomValues.Count, false);
            Array.Copy(crossShape.CustomValues.Array, 0, data.crossCustomValues.Array, 0, crossShape.CustomValues.Count);

            ArrayPools.Vector2.Resize(ref data.scales, path.Count, false);

            data.CrossClosed = crossShape.Closed;
            data.CrossSeamless = crossShape.Seamless;
            data.CrossMaterialGroups = new SamplePointsMaterialGroupCollection(crossShape.MaterialGroups);
            ArrayPools.Vector3.Resize(ref data.vertices, data.CrossSize * data.Positions.Count, false);
            ArrayPools.Vector3.Resize(ref data.vertexNormals, data.vertices.Count, false);
            return data;
        }


        public override T Clone<T>()
        {
            return new CGVolume(this) as T;
        }



        public void InterpolateVolume(float f, float crossF, out Vector3 pos, out Vector3 dir, out Vector3 up)
        {
            float frag;
            float cfrag;
            int v0Idx = GetVertexIndex(f, crossF, out frag, out cfrag);

            // (2)-(3)
            //  | \ |
            // (0)-(1)
            Vector3 xd, zd;
            Vector3 v0 = vertices.Array[v0Idx];
            Vector3 v1 = vertices.Array[v0Idx + 1];
            Vector3 v2 = vertices.Array[v0Idx + CrossSize];

            if (frag + cfrag > 1)
            {
                Vector3 v3 = vertices.Array[v0Idx + CrossSize + 1];
                xd = v3 - v2;
                zd = v3 - v1;
                pos = v2 - zd * (1 - frag) + xd * (cfrag);
            }
            else
            {
                xd = v1 - v0;
                zd = v2 - v0;
                pos = v0 + zd * frag + xd * cfrag;
            }

            dir = zd.normalized;
            up = Vector3.Cross(zd, xd);
        }

        public Vector3 InterpolateVolumePosition(float f, float crossF)
        {
            float frag;
            float cfrag;
            int v0Idx = GetVertexIndex(f, crossF, out frag, out cfrag);
            // (2)-(3)
            //  | \ |
            // (0)-(1)
            Vector3 xd, zd;
            Vector3 v0 = vertices.Array[v0Idx];
            Vector3 v1 = vertices.Array[v0Idx + 1];
            Vector3 v2 = vertices.Array[v0Idx + CrossSize];

            if (frag + cfrag > 1)
            {
                Vector3 v3 = vertices.Array[v0Idx + CrossSize + 1];
                xd = v3 - v2;
                zd = v3 - v1;
                return v2 - zd * (1 - frag) + xd * (cfrag);
            }
            else
            {
                xd = v1 - v0;
                zd = v2 - v0;
                return v0 + zd * frag + xd * cfrag;
            }
        }

        public Vector3 InterpolateVolumeDirection(float f, float crossF)
        {
            float frag;
            float cfrag;
            int v0Idx = GetVertexIndex(f, crossF, out frag, out cfrag);

            // (2)-(3)
            //  | \ |
            // (0)-(1)
            if (frag + cfrag > 1)
            {
                Vector3 v1 = vertices.Array[v0Idx + 1];
                Vector3 v3 = vertices.Array[v0Idx + CrossSize + 1];
                return (v3 - v1).normalized;
            }
            else
            {
                Vector3 v0 = vertices.Array[v0Idx];
                Vector3 v2 = vertices.Array[v0Idx + CrossSize];
                return (v2 - v0).normalized;
            }

        }

        public Vector3 InterpolateVolumeUp(float f, float crossF)
        {
            float frag;
            float cfrag;
            int v0Idx = GetVertexIndex(f, crossF, out frag, out cfrag);

            // (2)-(3)
            //  | \ |
            // (0)-(1)
            Vector3 xd, zd;

            Vector3 v1 = vertices.Array[v0Idx + 1];
            Vector3 v2 = vertices.Array[v0Idx + CrossSize];

            if (frag + cfrag > 1)
            {
                Vector3 v3 = vertices.Array[v0Idx + CrossSize + 1];
                xd = v3 - v2;
                zd = v3 - v1;
            }
            else
            {
                Vector3 v0 = vertices.Array[v0Idx];
                xd = v1 - v0;
                zd = v2 - v0;
            }
            return Vector3.Cross(zd, xd);
        }

        public float GetCrossLength(float pathF)
        {
            int s0;
            int s1;
            float frag;
#pragma warning disable 618
            GetSegmentIndices(pathF, out s0, out s1, out frag);
#pragma warning restore 618

#pragma warning disable 618
            if (SegmentLength[s0] == 0)
                SegmentLength[s0] = calcSegmentLength(s0);
            if (SegmentLength[s1] == 0)
                SegmentLength[s1] = calcSegmentLength(s1);

            return Mathf.LerpUnclamped(SegmentLength[s0], SegmentLength[s1], frag);
#pragma warning restore 618
        }


        public float CrossFToDistance(float f, float crossF, CurvyClamping crossClamping = CurvyClamping.Clamp)
        {
            return GetCrossLength(f) * CurvyUtility.ClampTF(crossF, crossClamping);
        }

        public float CrossDistanceToF(float f, float distance, CurvyClamping crossClamping = CurvyClamping.Clamp)
        {
            float cl = GetCrossLength(f);
            return CurvyUtility.ClampDistance(distance, crossClamping, cl) / cl;
        }

        /// <summary>
        /// Get the indices of the two points on the path that are surrounding the point at pathF
        /// </summary>
        /// <param name="pathF">The relative distance of the input point on the path</param>
        /// <param name="segment0Index">Index of the path point just before the input point </param>
        /// <param name="segment1Index">Index of the path point just after the input point</param>
        /// <param name="frag">The interpolation value between segment0Index and segment1Index, defining the exact position of the input point between those two points</param>
        [Obsolete("Method will get removed. Copy its content if you still need it")]
        public void GetSegmentIndices(float pathF, out int segment0Index, out int segment1Index, out float frag)
        {
            segment0Index = GetFIndex(Mathf.Repeat(pathF, 1), out frag);
            segment1Index = segment0Index + 1;
        }

        public int GetSegmentIndex(int segment)
        {
            return segment * CrossSize;
        }

        public int GetCrossFIndex(float crossF, out float frag)
        {
            float f = crossF + CrossFShift;
            //OPTIM if f is always positive, replace repeat with %. Right now crossF can be negative
            f = f == 1 ? f : Mathf.Repeat(f, 1);
            int index = getGenericFIndex(crossRelativeDistances, f, out frag);

            return index;
        }

        /// <summary>
        /// Get the index of the first vertex belonging to the segment a certain F is part of
        /// </summary>
        /// <param name="pathF">position on the path (0..1)</param>
        /// <param name="pathFrag">remainder between the returned segment and the next segment</param>
        /// <returns>a vertex index</returns>
        public int GetVertexIndex(float pathF, out float pathFrag)
        {
            int pIdx = GetFIndex(pathF, out pathFrag);
            return pIdx * CrossSize;
        }

        /// <summary>
        /// Get the index of the first vertex of the edge a certain F and CrossF is part of
        /// </summary>
        /// <param name="pathF">position on the path (0..1)</param>
        /// <param name="crossF">position on the cross (0..1)</param>
        /// <param name="pathFrag">remainder between the segment and the next segment</param>
        /// <param name="crossFrag">remainder between the returned vertex and the next vertex</param>
        /// <returns>a vertex index</returns>
        public int GetVertexIndex(float pathF, float crossF, out float pathFrag, out float crossFrag)
        {
            int pIdx = GetVertexIndex(pathF, out pathFrag);
            int cIdx = GetCrossFIndex(crossF, out crossFrag);
            return pIdx + cIdx;
        }

        /// <summary>
        /// Gets all vertices belonging to one or more extruded shape segments
        /// </summary>
        /// <param name="segmentIndices">indices of segments in question</param>
        public Vector3[] GetSegmentVertices(params int[] segmentIndices)
        {
            SubArray<Vector3> verts = ArrayPools.Vector3.Allocate(CrossSize * segmentIndices.Length);
            for (int i = 0; i < segmentIndices.Length; i++)
            {
                int sourceIndex = segmentIndices[i] * CrossSize;
                int destinationIndex = i * CrossSize;
                Array.Copy(vertices.Array, sourceIndex, verts.Array, destinationIndex, CrossSize);
            }

            return verts.CopyToArray(ArrayPools.Vector3);
        }


        private float calcSegmentLength(int segmentIndex)
        {
            int vstart = segmentIndex * CrossSize;
            int vend = vstart + CrossSize - 1;
            float l = 0;
            for (int i = vstart; i < vend; i++)
                l += (vertices.Array[i + 1] - vertices.Array[i]).magnitude;

            return l;
        }

    }

    /// <summary>
    /// Bounds data class
    /// </summary>
    [CGDataInfo(1, 0.8f, 0.5f)]
    public class CGBounds : CGData
    {
        protected Bounds? mBounds;
        public Bounds Bounds
        {
            get
            {
                if (!mBounds.HasValue)
                    RecalculateBounds();
                return mBounds.Value;
            }
            set
            {
                if (mBounds != value)
                    mBounds = value;
            }
        }

        public float Depth
        {
            get
            {
                //OPTIM just do the delta between max z and min z, and get rid of bounds
                return Bounds.size.z;
            }
        }

        public CGBounds() : base() { }

        public CGBounds(Bounds bounds) : base()
        {
            Bounds = bounds;
        }

        public CGBounds(CGBounds source)
        {
            Name = source.Name;
            if (source.mBounds.HasValue) //Do not copy bounds if they are not computed yet
                Bounds = source.Bounds;
        }


        public virtual void RecalculateBounds()
        {
            Bounds = new Bounds();
        }

        public override T Clone<T>()
        {
            return new CGBounds(this) as T;
        }

        public static void Copy(CGBounds dest, CGBounds source)
        {
            if (source.mBounds.HasValue) //Do not copy bounds if they are not computed yet
                dest.Bounds = source.Bounds;
        }
    }

    /// <summary>
    /// SubMesh data (triangles, material)
    /// </summary>
    public class CGVSubMesh : CGData
    {
        /// <summary>
        /// Vertex indices constituting the mesh's triangles
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<int> TrianglesList
        {
            get => triangles;
            set
            {
                ArrayPools.Int32.Free(triangles);
                triangles = value;
            }
        }

        /// <summary>
        /// Vertex indices constituting the mesh's triangles
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use TrianglesList instead")]
        public int[] Triangles
        {
            get => TrianglesList.CopyToArray(ArrayPools.Int32);
            set => TrianglesList = new SubArray<int>(value);
        }

        public Material Material;
        private SubArray<int> triangles;

        public override int Count
        {
            get
            {
                return triangles.Count;
            }
        }

        public CGVSubMesh(Material material = null) : base()
        {
            Material = material;
            triangles = ArrayPools.Int32.Allocate(0);
        }

        public CGVSubMesh(int[] triangles, Material material = null) : base()
        {
            Material = material;
            this.triangles = new SubArray<int>(triangles);
        }

        public CGVSubMesh(SubArray<int> triangles, Material material = null) : base()
        {
            Material = material;
            this.triangles = triangles;
        }

        public CGVSubMesh(int triangleCount, Material material = null) : base()
        {
            Material = material;
            triangles = ArrayPools.Int32.Allocate(triangleCount);
        }

        public CGVSubMesh(CGVSubMesh source) : base()
        {
            Material = source.Material;
            triangles = ArrayPools.Int32.Clone(source.triangles);
        }

        protected override bool Dispose(bool disposing)
        {
            bool result = base.Dispose(disposing);
            if (result)
                ArrayPools.Int32.Free(triangles);
            return result;
        }

        public override T Clone<T>()
        {
            return new CGVSubMesh(this) as T;
        }

        public static CGVSubMesh Get(CGVSubMesh data, int triangleCount, Material material = null)
        {

            if (data == null)
                return new CGVSubMesh(triangleCount, material);

            ArrayPools.Int32.Resize(ref data.triangles, triangleCount);
            data.Material = material;
            return data;
        }

        public void ShiftIndices(int offset, int startIndex = 0)
        {
            for (int i = startIndex; i < triangles.Count; i++)
                triangles.Array[i] += offset;
        }

        public void Add(CGVSubMesh other, int shiftIndexOffset = 0)
        {
            int trianglesLength = triangles.Count;
            int otherTriangleLength = other.triangles.Count;

            if (otherTriangleLength == 0)
                return;

            ArrayPools.Int32.Resize(ref triangles, trianglesLength + otherTriangleLength);

            Array.Copy(other.triangles.Array, 0, triangles.Array, trianglesLength, otherTriangleLength);

            if (shiftIndexOffset != 0)
                ShiftIndices(shiftIndexOffset, trianglesLength);
        }
    }

    /// <summary>
    /// Mesh Data (Bounds + Vertex,UV,UV2,Normal,Tangents,SubMehes)
    /// </summary>
    [CGDataInfo(0.98f, 0.5f, 0)]
    public class CGVMesh : CGBounds
    {

#if CONTRACTS_FULL
        [ContractInvariantMethod]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "Required for code contracts.")]
        private void ObjectInvariant()
        {
            Contract.Invariant(Vertex != null);
            Contract.Invariant(UV != null);
            Contract.Invariant(UV2 != null);
            Contract.Invariant(Normal != null);
            Contract.Invariant(Tangents != null);
            Contract.Invariant(SubMeshes != null);

            Contract.Invariant(UV.Length == 0 || UV.Length == Vertex.Length);
            Contract.Invariant(UV2.Length == 0 || UV2.Length == Vertex.Length);
            Contract.Invariant(Normal.Length == 0 || Normal.Length == Vertex.Length);
            Contract.Invariant(Tangents.Length == 0 || Tangents.Length == Vertex.Length);
        }
#endif

        /// <summary>
        /// Positions of the points, in the local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        /// <remarks>If you modify the content of the returned array, make sure to call <see cref="ClearCachedSortedVertexIndices"/> before calling <see cref="GetCachedSortedVertexIndices"/></remarks>
        public SubArray<Vector3> Vertices
        {
            get => vertices;
            set
            {
                ArrayPools.Vector3.Free(vertices);
                vertices = value;
                OnVerticesChanged();
            }
        }

        /// <summary>
        /// UVs of the points
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector2> UVs
        {
            get => uvs;
            set
            {
                ArrayPools.Vector2.Free(uvs);
                uvs = value;
            }
        }

        /// <summary>
        /// UV2s of the points
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector2> UV2s
        {
            get => uv2s;
            set
            {
                ArrayPools.Vector2.Free(uv2s);
                uv2s = value;
            }
        }

        /// <summary>
        /// Normals of the points, in the local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector3> NormalsList
        {
            get => normals;
            set
            {
                ArrayPools.Vector3.Free(normals);
                normals = value;
            }
        }

        /// <summary>
        /// Tangents of the points, in the local space
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<Vector4> TangentsList
        {
            get => tangents;
            set
            {
                ArrayPools.Vector4.Free(tangents);
                tangents = value;
            }
        }

        #region Obsolete

        /// <summary>
        /// Positions of the points, in the local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use Vertices instead")]
        public Vector3[] Vertex
        {
            get => Vertices.CopyToArray(ArrayPools.Vector3);
            set => Vertices = new SubArray<Vector3>(value);
        }

        /// <summary>
        /// UVs of the points
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use UVs instead")]
        public Vector2[] UV
        {
            get => UVs.CopyToArray(ArrayPools.Vector2);
            set => UVs = new SubArray<Vector2>(value);
        }

        /// <summary>
        /// UV2s of the points
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use UV2s instead")]
        public Vector2[] UV2
        {
            get => UV2s.CopyToArray(ArrayPools.Vector2);
            set => UV2s = new SubArray<Vector2>(value);
        }


        /// <summary>
        /// Normals of the points, in the local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use NormalList instead")]
        public Vector3[] Normals
        {
            get => NormalsList.CopyToArray(ArrayPools.Vector3);
            set => NormalsList = new SubArray<Vector3>(value);
        }

        /// <summary>
        /// Tangents of the points, in the local space
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use TangentsList instead")]
        public Vector4[] Tangents
        {
            get => TangentsList.CopyToArray(ArrayPools.Vector4);
            set => TangentsList = new SubArray<Vector4>(value);
        }


        #endregion
        public CGVSubMesh[] SubMeshes;
        /// <summary>
        /// Gets the number of vertices
        /// </summary>
        public override int Count
        {
            get
            {
                return vertices.Count;
            }
        }

        public bool HasUV { get { return uvs.Count > 0; } }
        public bool HasUV2 { get { return uv2s.Count > 0; } }
        /// <summary>
        /// True if at least one vertex has a normal
        /// </summary>
        public bool HasNormals { get { return normals.Count > 0; } }

        /// <summary>
        /// True if <see cref="HasNormals"/> but not all vertices have normals
        /// </summary>
        public bool HasPartialNormals
        {
            get
            {
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(hasPartialNormals == false || HasNormals);
#endif
                return hasPartialNormals;
            }
            private set => hasPartialNormals = value;
        }

        /// <summary>
        /// True if at least one vertex has a tangent
        /// </summary>
        public bool HasTangents { get { return tangents.Count > 0; } }

        /// <summary>
        /// True if <see cref="HasTangents"/> but not all vertices have tangents
        /// </summary>
        public bool HasPartialTangents
        {
            get
            {
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(hasPartialTangents == false || HasTangents);
#endif
                return hasPartialTangents;
            }
            private set => hasPartialTangents = value;
        }

        public int TriangleCount
        {
            get
            {
                int cnt = 0;
                for (int i = 0; i < SubMeshes.Length; i++)
                    cnt += SubMeshes[i].TrianglesList.Count;
                return cnt / 3;
            }
        }

        #region Private fields

        /// <summary>
        /// An array of the index of vertices when sorted by Z coordinate, from smaller to bigger
        /// </summary>
        private SubArray<int>? sortedVertexIndices;
        /// <summary>
        /// Lock used when generating <see cref="sortedVertexIndices"/>
        /// </summary>
        private readonly object vertexIndicesLock = new object();

        private SubArray<Vector3> vertices;

        private SubArray<Vector2> uvs;

        private SubArray<Vector2> uv2s;

        private SubArray<Vector3> normals;

        private SubArray<Vector4> tangents;

        private bool hasPartialNormals;

        private bool hasPartialTangents;

        #endregion
        public CGVMesh() : this(0) { }
        public CGVMesh(int vertexCount, bool addUV = false, bool addUV2 = false, bool addNormals = false, bool addTangents = false) : base()
        {
            vertices = ArrayPools.Vector3.Allocate(vertexCount);
            uvs = addUV
                ? ArrayPools.Vector2.Allocate(vertexCount)
                : ArrayPools.Vector2.Allocate(0);
            uv2s = addUV2
                ? ArrayPools.Vector2.Allocate(vertexCount)
                : ArrayPools.Vector2.Allocate(0);
            normals = addNormals
                ? ArrayPools.Vector3.Allocate(vertexCount)
                : ArrayPools.Vector3.Allocate(0);
            tangents = addTangents
                ? ArrayPools.Vector4.Allocate(vertexCount)
                : ArrayPools.Vector4.Allocate(0);
            hasPartialNormals = false;
            hasPartialTangents = false;
            SubMeshes = new CGVSubMesh[0];
        }
        public CGVMesh(CGVolume volume) : this(volume.Vertices.Count)
        {
            Array.Copy(volume.Vertices.Array, 0, vertices.Array, 0, volume.Vertices.Count);
        }

        public CGVMesh(CGVolume volume, IntRegion subset)
            : this((subset.LengthPositive + 1) * volume.CrossSize, false, false, true)
        {
            int start = subset.Low * volume.CrossSize;
            Array.Copy(volume.Vertices.Array, start, vertices.Array, 0, vertices.Count);
            Array.Copy(volume.VertexNormals.Array, start, normals.Array, 0, normals.Count);
        }

        public CGVMesh(CGVMesh source) : base(source)
        {
            vertices = ArrayPools.Vector3.Clone(source.vertices);
            uvs = ArrayPools.Vector2.Clone(source.uvs);
            uv2s = ArrayPools.Vector2.Clone(source.uv2s);
            normals = ArrayPools.Vector3.Clone(source.normals);
            tangents = ArrayPools.Vector4.Clone(source.tangents);
            hasPartialNormals = source.HasPartialNormals;
            hasPartialTangents = source.HasPartialTangents;
            SubMeshes = new CGVSubMesh[source.SubMeshes.Length];
            for (int i = 0; i < source.SubMeshes.Length; i++)
                SubMeshes[i] = new CGVSubMesh(source.SubMeshes[i]);
        }

        public CGVMesh(CGMeshProperties meshProperties) : this(meshProperties.Mesh, meshProperties.Material, meshProperties.Matrix) { }

        public CGVMesh(Mesh source, Material[] materials, Matrix4x4 trsMatrix) : base()
        {
            Name = source.name;
            vertices = new SubArray<Vector3>(source.vertices);
            normals = new SubArray<Vector3>(source.normals);
            tangents = new SubArray<Vector4>(source.tangents);
            hasPartialNormals = false;
            hasPartialTangents = false;
            uvs = new SubArray<Vector2>(source.uv);
            uv2s = new SubArray<Vector2>(source.uv2);
            SubMeshes = new CGVSubMesh[source.subMeshCount];
            for (int s = 0; s < source.subMeshCount; s++)
                SubMeshes[s] = new CGVSubMesh(source.GetTriangles(s), (materials.Length > s) ? materials[s] : null);

            Bounds = source.bounds;

            if (!trsMatrix.isIdentity)
                TRS(trsMatrix);

        }

        protected override bool Dispose(bool disposing)
        {
            bool result = base.Dispose(disposing);
            if (result)
            {
                if (sortedVertexIndices != null)
                    ArrayPools.Int32.Free(sortedVertexIndices.Value);
                ArrayPools.Vector3.Free(vertices);
                ArrayPools.Vector2.Free(uvs);
                ArrayPools.Vector2.Free(uv2s);
                ArrayPools.Vector3.Free(normals);
                ArrayPools.Vector4.Free(tangents);

                //Do not dispose SubMeshes if the call is due to finalization, since submeshes are disposable by themselves.
                if (disposing)
                    for (var i = 0; i < SubMeshes.Length; i++)
                        SubMeshes[i].Dispose();
            }
            return result;
        }

        public override T Clone<T>()
        {
            return new CGVMesh(this) as T;
        }

        [Obsolete("Member not used by Curvy, will get removed next major version. Use another overload of this method")]
        public static CGVMesh Get(CGVMesh data, CGVolume source, bool addUV, bool reverseNormals)
        {
            return Get(data, source, new IntRegion(0, source.Count - 1), addUV, reverseNormals);
        }

        [Obsolete("Member not used by Curvy, will get removed next major version. Use another overload of this method")]
        public static CGVMesh Get(CGVMesh data, CGVolume source, IntRegion subset, bool addUV, bool reverseNormals)
        {
            return Get(data, source, subset, addUV, false, reverseNormals);
        }

        public static CGVMesh Get(CGVMesh data, CGVolume source, IntRegion subset, bool addUV, bool addUV2, bool reverseNormals)
        {
            int start = subset.Low * source.CrossSize;
            int size = (subset.LengthPositive + 1) * source.CrossSize;

            if (data == null)
                data = new CGVMesh(size, addUV, addUV2, true);
            else
            {
                if (data.vertices.Count != size)
                    ArrayPools.Vector3.Resize(ref data.vertices, size, false);

                if (data.normals.Count != size)
                    ArrayPools.Vector3.Resize(ref data.normals, size, false);

                int uvSize = (addUV) ? size : 0;
                if (data.uvs.Count != uvSize)
                    ArrayPools.Vector2.ResizeAndClear(ref data.uvs, uvSize);

                int uv2Size = (addUV2) ? size : 0;
                if (data.uv2s.Count != uv2Size)
                    ArrayPools.Vector2.ResizeAndClear(ref data.uv2s, uv2Size);

                //data.SubMeshes = new CGVSubMesh[0];//BUG? why is this commented?

                if (data.tangents.Count != 0)
                    ArrayPools.Vector4.Resize(ref data.tangents, 0);
                data.HasPartialTangents = false;
            }

            Array.Copy(source.Vertices.Array, start, data.vertices.Array, 0, size);
            Array.Copy(source.VertexNormals.Array, start, data.normals.Array, 0, size);
            data.hasPartialNormals = false;

            if (reverseNormals)
            {
                Vector3[] normalsArray = data.normals.Array;

                //OPTIM merge loop with normals copy
                for (int n = 0; n < data.normals.Count; n++)
                {
                    normalsArray[n].x = -normalsArray[n].x;
                    normalsArray[n].y = -normalsArray[n].y;
                    normalsArray[n].z = -normalsArray[n].z;
                }
            }

            data.OnVerticesChanged();

            return data;
        }


        public void SetSubMeshCount(int count)
        {
            Array.Resize(ref SubMeshes, count);
        }

        public void AddSubMesh(CGVSubMesh submesh = null)
        {
            SubMeshes = SubMeshes.Add(submesh);
        }

        /// <summary>
        /// Combine/Merge another VMesh into this
        /// </summary>
        /// <param name="source"></param>
        public void MergeVMesh(CGVMesh source) => MergeVMesh(source, Matrix4x4.identity);

        /// <summary>
        /// Combine/Merge another VMesh into this, applying a matrix
        /// </summary>
        /// <param name="source"></param>
        /// <param name="matrix"></param>
        public void MergeVMesh(CGVMesh source, Matrix4x4 matrix)
        {
            //TODO Design: unify implementation with MergeVMeshes
            int preMergeVertexCount = Count;
            // Add base data
            if (source.Count != 0)
            {
                int postMergeVertexCount = preMergeVertexCount + source.Count;
                ArrayPools.Vector3.Resize(ref vertices, postMergeVertexCount);
                if (matrix == Matrix4x4.identity)
                    Array.Copy(source.vertices.Array, 0, vertices.Array, preMergeVertexCount, source.Count);
                else
                    for (int v = preMergeVertexCount; v < postMergeVertexCount; v++)
                        vertices.Array[v] = matrix.MultiplyPoint3x4(source.vertices.Array[v - preMergeVertexCount]);

                MergeUVsNormalsAndTangents(source, preMergeVertexCount);

                // Add Submeshes
                for (int sm = 0; sm < source.SubMeshes.Length; sm++)
                    GetMaterialSubMesh(source.SubMeshes[sm].Material).Add(source.SubMeshes[sm], preMergeVertexCount);

                OnVerticesChanged();
            }
        }

        /// <summary>
        /// Combine/Merge multiple CGVMeshes into this
        /// </summary>
        /// <param name="vMeshes">list of CGVMeshes</param>
        /// <param name="startIndex">Index of the first element of the list to merge</param>
        /// <param name="endIndex">Index of the last element of the list to merge</param>
        public void MergeVMeshes(List<CGVMesh> vMeshes, int startIndex, int endIndex)
        {
            Assert.IsTrue(endIndex < vMeshes.Count);
            int totalVertexCount = 0;
            bool hasNormals = false;
            bool partialNormals = false;
            bool hasTangents = false;
            bool partialTangents = false;
            bool hasUV = false;
            bool hasUV2 = false;
            Dictionary<Material, List<SubArray<int>>> submeshesByMaterial = new Dictionary<Material, List<SubArray<int>>>();
            Dictionary<Material, int> trianglesIndexPerMaterial = new Dictionary<Material, int>();
            //dictionaries can't have null as a key, so to handle null materials, here are the fields equivalent to these dictionaries for null
            List<SubArray<int>> noMaterialSubmeshes = null;
            int noMaterialTrianglesIndex = 0;

            for (int i = startIndex; i <= endIndex; i++)
            {
                CGVMesh cgvMesh = vMeshes[i];
                totalVertexCount += cgvMesh.Count;
                hasNormals |= cgvMesh.HasNormals;
                partialNormals |= cgvMesh.HasNormals == false || cgvMesh.HasPartialNormals;
                hasTangents |= cgvMesh.HasTangents;
                partialTangents |= cgvMesh.HasTangents == false || cgvMesh.hasPartialTangents;
                hasUV |= cgvMesh.HasUV;
                hasUV2 |= cgvMesh.HasUV2;

                //initialize per material data
                for (int sm = 0; sm < cgvMesh.SubMeshes.Length; sm++)
                {
                    CGVSubMesh subMesh = cgvMesh.SubMeshes[sm];
                    if (subMesh.Material != null)
                    {
                        Material subMeshMaterial = subMesh.Material;
                        if (submeshesByMaterial.ContainsKey(subMeshMaterial) == false)
                        {
                            submeshesByMaterial[subMeshMaterial] = new List<SubArray<int>>(1);
                            trianglesIndexPerMaterial[subMeshMaterial] = 0;
                        }
                        submeshesByMaterial[subMeshMaterial].Add(subMesh.TrianglesList);
                    }
                    else
                    {
                        if(noMaterialSubmeshes == null)
                        {
                            noMaterialSubmeshes = new List<SubArray<int>>(1);
                            noMaterialTrianglesIndex = 0;
                        }
                        noMaterialSubmeshes.Add(subMesh.TrianglesList);
                    }

                }
            }

            ArrayPools.Vector3.Resize(ref vertices, totalVertexCount);
            if (hasNormals)
                ArrayPools.Vector3.Resize(ref normals, totalVertexCount);
            hasPartialNormals = partialNormals;

            if (hasTangents)
                ArrayPools.Vector4.Resize(ref tangents, totalVertexCount);
            hasPartialTangents = partialTangents;

            if (hasUV)
                ArrayPools.Vector2.Resize(ref uvs, totalVertexCount);

            if (hasUV2)
                ArrayPools.Vector2.Resize(ref uv2s, totalVertexCount);

            foreach (KeyValuePair<Material, List<SubArray<int>>> pair in submeshesByMaterial)
                ProcessTriangleArrays(pair.Value, pair.Key);
            if(noMaterialSubmeshes != null)
                ProcessTriangleArrays(noMaterialSubmeshes, null);

            int currentVertexCount = 0;
            for (int i = startIndex; i <= endIndex; i++)
            {
                CGVMesh source = vMeshes[i];

                Array.Copy(source.vertices.Array, 0, vertices.Array, currentVertexCount, source.vertices.Count);
                if (hasNormals)
                {
                    if (source.HasNormals)
                        Array.Copy(source.normals.Array, 0, normals.Array, currentVertexCount, source.normals.Count);
                    else
                        Array.Clear(normals.Array, currentVertexCount, source.vertices.Count);
                }

                if (hasTangents)
                {
                    if (source.HasTangents)
                        Array.Copy(source.tangents.Array, 0, tangents.Array, currentVertexCount, source.tangents.Count);
                    else
                        Array.Clear(tangents.Array, currentVertexCount, source.vertices.Count);
                }

                if (hasUV)
                {
                    if (source.HasUV)
                        Array.Copy(source.uvs.Array, 0, uvs.Array, currentVertexCount, source.uvs.Count);
                    else
                        Array.Clear(uvs.Array, currentVertexCount, source.vertices.Count);
                }

                if (hasUV2)
                {
                    if (source.HasUV2)
                        Array.Copy(source.uv2s.Array, 0, uv2s.Array, currentVertexCount, source.uv2s.Count);
                    else
                        Array.Clear(uv2s.Array, currentVertexCount, source.vertices.Count);
                }

                // Add Submeshes
                for (int subMeshIndex = 0; subMeshIndex < source.SubMeshes.Length; subMeshIndex++)
                {
                    CGVSubMesh sourceSubMesh = source.SubMeshes[subMeshIndex];
                    Material sourceMaterial = sourceSubMesh.Material;
                    SubArray<int> sourceTriangles = sourceSubMesh.TrianglesList;
                    int sourceTrianglesLength = sourceTriangles.Count;

                    SubArray<int> destinationTriangles = GetMaterialSubMesh(sourceMaterial).TrianglesList;

                    int trianglesIndex = sourceMaterial == null ? noMaterialTrianglesIndex: trianglesIndexPerMaterial[sourceMaterial];

                    if (sourceTrianglesLength != 0)
                    {
                        if (currentVertexCount == 0)
                            Array.Copy(sourceTriangles.Array, 0, destinationTriangles.Array, trianglesIndex, sourceTrianglesLength);
                        else
                            for (int j = 0; j < sourceTrianglesLength; j++)
                                destinationTriangles.Array[trianglesIndex + j] = sourceTriangles.Array[j] + currentVertexCount;

                        int materialTrianglesIndex = trianglesIndex + sourceTrianglesLength;

                        if (sourceMaterial == null)
                            noMaterialTrianglesIndex = materialTrianglesIndex;
                        else
                            trianglesIndexPerMaterial[sourceMaterial] = materialTrianglesIndex;
                    }
                }
                currentVertexCount += source.vertices.Count;
            }

            OnVerticesChanged();

            void ProcessTriangleArrays(List<SubArray<int>> subArrays, Material material1)
            {
                int totalTrianglesCount = 0;
                for (int arraysIndex = 0; arraysIndex < subArrays.Count; arraysIndex++)
                    totalTrianglesCount += subArrays[arraysIndex].Count;

                AddSubMesh(new CGVSubMesh(totalTrianglesCount, material1));
            }
        }

        private void MergeUVsNormalsAndTangents(CGVMesh source, int preMergeVertexCount)
        {
            int sourceLength = source.Count;
            if (sourceLength == 0)
                return;

            int postMergeVetexCount = preMergeVertexCount + sourceLength;
            if (HasUV || source.HasUV)
            {
                SubArray<Vector2> newUVs = ArrayPools.Vector2.Allocate(postMergeVetexCount, false);

                if (HasUV)
                    Array.Copy(uvs.Array, 0, newUVs.Array, 0, preMergeVertexCount);
                else
                    Array.Clear(newUVs.Array, 0, preMergeVertexCount);

                if (source.HasUV)
                    Array.Copy(source.uvs.Array, 0, newUVs.Array, preMergeVertexCount, sourceLength);
                else
                    Array.Clear(newUVs.Array, preMergeVertexCount, sourceLength);

                UVs = newUVs;

            }

            if (HasUV2 || source.HasUV2)
            {
                SubArray<Vector2> newUV2s = ArrayPools.Vector2.Allocate(postMergeVetexCount, false);

                if (HasUV2)
                    Array.Copy(uv2s.Array, 0, newUV2s.Array, 0, preMergeVertexCount);
                else
                    Array.Clear(newUV2s.Array, 0, preMergeVertexCount);

                if (source.HasUV2)
                    Array.Copy(source.uv2s.Array, 0, newUV2s.Array, preMergeVertexCount, sourceLength);
                else
                    Array.Clear(newUV2s.Array, preMergeVertexCount, sourceLength);

                UV2s = newUV2s;

            }

            if (HasNormals || source.HasNormals)
            {
                HasPartialNormals = HasNormals ^ source.HasNormals;

                SubArray<Vector3> newNormals = ArrayPools.Vector3.Allocate(postMergeVetexCount, false);

                if (HasNormals)
                    Array.Copy(normals.Array, 0, newNormals.Array, 0, preMergeVertexCount);
                else
                    Array.Clear(newNormals.Array, 0, preMergeVertexCount);

                if (source.HasNormals)
                    Array.Copy(source.normals.Array, 0, newNormals.Array, preMergeVertexCount, sourceLength);
                else
                    Array.Clear(newNormals.Array, preMergeVertexCount, sourceLength);

                NormalsList = newNormals;
            }

            if (HasTangents || source.HasTangents)
            {
                HasPartialTangents = HasTangents ^ source.HasTangents;

                SubArray<Vector4> newTangents = ArrayPools.Vector4.Allocate(postMergeVetexCount, false);

                if (HasTangents)
                    Array.Copy(tangents.Array, 0, newTangents.Array, 0, preMergeVertexCount);
                else
                    Array.Clear(newTangents.Array, 0, preMergeVertexCount);

                if (source.HasTangents)
                    Array.Copy(source.tangents.Array, 0, newTangents.Array, preMergeVertexCount, sourceLength);
                else
                    Array.Clear(newTangents.Array, preMergeVertexCount, sourceLength);

                TangentsList = newTangents;
            }
        }

        /// <summary>
        /// Gets the submesh using a certain material
        /// </summary>
        /// <param name="mat">the material the submesh should use</param>
        /// <param name="createIfMissing">whether to create the submesh if no existing one matches</param>
        /// <returns>a submesh using the given material</returns>
        public CGVSubMesh GetMaterialSubMesh(Material mat, bool createIfMissing = true)
        {
            // already having submesh with matching material?
            for (int sm = 0; sm < SubMeshes.Length; sm++)
                if (SubMeshes[sm].Material == mat)
                    return SubMeshes[sm];

            // else create new
            if (createIfMissing)
            {
                CGVSubMesh sm = new CGVSubMesh(mat);
                AddSubMesh(sm);
                return sm;
            }
            else
                return null;
        }

        /// <summary>
        /// Creates a Mesh from the data
        /// </summary>
        public Mesh AsMesh()
        {
            Mesh msh = new Mesh();
            ToMesh(ref msh);
            return msh;
        }

        /// <summary>
        /// Copies the data into an existing Mesh
        /// </summary>
        /// <param name="mesh">The mesh to copy the data from this CGVMesh into</param>
        /// <param name="includeNormals">should normals be copied or set to empty?</param>
        /// <param name="includeTangents">should tangents be copied or set to empty?</param>
        public void ToMesh(ref Mesh mesh, bool includeNormals = true, bool includeTangents = true)
        {
            mesh.indexFormat = Count >= UInt16.MaxValue ? IndexFormat.UInt32 : IndexFormat.UInt16;

            mesh.SetVertices(vertices.Array, 0, vertices.Count);
            mesh.SetUVs(0, uvs.Array, 0, HasUV ? uvs.Count : 0);
            mesh.SetUVs(1, uv2s.Array, 0, HasUV2 ? uv2s.Count : 0);
            mesh.SetNormals(normals.Array, 0, (includeNormals && HasNormals) ? normals.Count : 0);
            mesh.SetTangents(tangents.Array, 0, (includeTangents && HasTangents) ? tangents.Count : 0);

            mesh.subMeshCount = SubMeshes.Length;
            for (int s = 0; s < SubMeshes.Length; s++)
            {
                SubArray<int> subArray = SubMeshes[s].TrianglesList;
                mesh.SetTriangles(subArray.Array, 0, subArray.Count, s);
            }
        }

        /// <summary>
        /// Gets a list of all Materials used
        /// </summary>
        public Material[] GetMaterials()
        {
            List<Material> mats = new List<Material>();
            for (int s = 0; s < SubMeshes.Length; s++)
                mats.Add(SubMeshes[s].Material);
            return mats.ToArray();
        }

        public override void RecalculateBounds()
        {
            if (Count == 0)
            {
                mBounds = new Bounds(Vector3.zero, Vector3.zero);
            }
            else
            {
                int vertexCount = vertices.Count;
                Vector3 min = vertices.Array[0], max = vertices.Array[0];
                for (int i = 1; i < vertexCount; i++)
                {
                    Vector3 vertex = vertices.Array[i];

                    if (vertex.x < min.x)
                        min.x = vertex.x;
                    else if (vertex.x > max.x)
                        max.x = vertex.x;

                    if (vertex.y < min.y)
                        min.y = vertex.y;
                    else if (vertex.y > max.y)
                        max.y = vertex.y;

                    if (vertex.z < min.z)
                        min.z = vertex.z;
                    else if (vertex.z > max.z)
                        max.z = vertex.z;
                }

                Bounds bounds = new Bounds();
                bounds.SetMinMax(min, max);
                mBounds = bounds;
            }
        }

        [Obsolete("Method will get remove in next major update. Copy its content if you need it")]
        public void RecalculateUV2()
        {
            ArrayPools.Vector2.Resize(ref uv2s, UVs.Count);
            CGUtility.CalculateUV2(uvs.Array, uv2s.Array, uvs.Count);
        }

        /// <summary>
        /// Applies the translation, rotation and scale defined by the given matrix
        /// </summary>
        public void TRS(Matrix4x4 matrix)
        {
            int count = Count;
            for (int vertexIndex = 0; vertexIndex < count; vertexIndex++)
                vertices.Array[vertexIndex] = matrix.MultiplyPoint3x4(vertices.Array[vertexIndex]);

            count = normals.Count;
            for (int vertexIndex = 0; vertexIndex < count; vertexIndex++)
                normals.Array[vertexIndex] = matrix.MultiplyVector(normals.Array[vertexIndex]);

            count = tangents.Count;
            for (int vertexIndex = 0; vertexIndex < count; vertexIndex++)
            {
                //Keep in mind that Tangents is a Vector4 array
                Vector4 tangent4 = tangents.Array[vertexIndex];
                Vector3 tangent3;
                tangent3.x = tangent4.x;
                tangent3.y = tangent4.y;
                tangent3.z = tangent4.z;
                tangents.Array[vertexIndex] = matrix.MultiplyVector(tangent3);
            }

            OnVerticesChanged();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void OnVerticesChanged()
        {
            mBounds = null;
            ClearCachedSortedVertexIndices();
        }

        /// <summary>
        /// Gets an array of the index of vertices when sorted by Z coordinate, from smaller to bigger.
        /// This array is cached. Curvy Splines does clear this cache if it modifies <see cref="Vertices"/>, but if you modify <see cref="Vertices"/> through its getter, you will have to clear the cached value by calling <see cref="ClearCachedSortedVertexIndices"/>
        /// </summary>
        /// <remarks>Is thread safe</remarks>
        public SubArray<int> GetCachedSortedVertexIndices()
        {
            if (sortedVertexIndices == null)
            {
                lock (vertexIndicesLock)
                {
                    if (sortedVertexIndices == null)
                    {
                        int verticesCount = vertices.Count;

                        SubArray<int> result = ArrayPools.Int32.Allocate(verticesCount);
                        SubArray<float> verticesZ = ArrayPools.Single.Allocate(verticesCount);
                        for (int k = 0; k < verticesCount; k++)
                        {
                            result.Array[k] = k;
                            verticesZ.Array[k] = vertices.Array[k].z;
                        }

                        Array.Sort(verticesZ.Array, result.Array, 0, verticesCount);
                        ArrayPools.Single.Free(verticesZ);

                        sortedVertexIndices = result;
                    }
                }
            }

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(sortedVertexIndices.Value.Count == Vertices.Count);
#endif
            return sortedVertexIndices.Value;
        }

        /// <summary>
        /// Clears the cached value computed by <see cref="GetCachedSortedVertexIndices"/>
        /// </summary>
        /// <remarks>Is thread safe</remarks>
        private void ClearCachedSortedVertexIndices()
        {
            if (sortedVertexIndices != null)
                lock (vertexIndicesLock)
                {
                    if (sortedVertexIndices != null)
                    {
                        ArrayPools.Int32.Free(sortedVertexIndices.Value);
                        sortedVertexIndices = null;
                    }
                }
        }
    }

    /// <summary>
    /// GameObject data (Bounds + Object)
    /// </summary>
    [CGDataInfo("#FFF59D")]
    public class CGGameObject : CGBounds
    {
        public GameObject Object;
        public Vector3 Translate;
        public Vector3 Rotate;
        public Vector3 Scale = Vector3.one;

        public Matrix4x4 Matrix
        {
            get { return Matrix4x4.TRS(Translate, Quaternion.Euler(Rotate), Scale); }
        }

        public CGGameObject() : base() { }

        public CGGameObject(CGGameObjectProperties properties) : this(properties.Object, properties.Translation, properties.Rotation, properties.Scale) { }

        public CGGameObject(GameObject obj) : this(obj, Vector3.zero, Vector3.zero, Vector3.one) { }

        public CGGameObject(GameObject obj, Vector3 translate, Vector3 rotate, Vector3 scale)
            : base()
        {
            Object = obj;
            Translate = translate;
            Rotate = rotate;
            Scale = scale;
            if (Object)
                Name = Object.name;
        }

        public CGGameObject(CGGameObject source) : base(source)
        {
            Object = source.Object;
            Translate = source.Translate;
            Rotate = source.Rotate;
            Scale = source.Scale;
        }

        public override T Clone<T>()
        {
            return new CGGameObject(this) as T;
        }

        public override void RecalculateBounds()
        {
            if (Object == null)
            {
                mBounds = new Bounds();
            }
            else
            {
                Renderer[] renderer = Object.GetComponentsInChildren<Renderer>(true);
                Collider[] collider = Object.GetComponentsInChildren<Collider>(true);
                Bounds bounds;
                if (renderer.Length > 0)
                {
                    bounds = renderer[0].bounds;
                    for (int i = 1; i < renderer.Length; i++)
                        bounds.Encapsulate(renderer[i].bounds);
                    for (int i = 0; i < collider.Length; i++)
                        bounds.Encapsulate(collider[i].bounds);
                }
                else if (collider.Length > 0)
                {
                    bounds = collider[0].bounds;
                    for (int i = 1; i < collider.Length; i++)
                        bounds.Encapsulate(collider[i].bounds);
                }
                else
                    bounds = new Bounds();

                Vector3 rotationlessBoundsSize = (Quaternion.Inverse(Object.transform.localRotation) * bounds.size);
                bounds.size = new Vector3(
                    rotationlessBoundsSize.x * Scale.x,
                    rotationlessBoundsSize.y * Scale.y,
                    rotationlessBoundsSize.z * Scale.z);

                mBounds = bounds;
            }
        }
    }

    /// <summary>
    /// A collection of <see cref="CGSpot"/>
    /// </summary>
    [CGDataInfo(0.96f, 0.96f, 0.96f)]
    public class CGSpots : CGData
    {
        //DESIGN what is the use of this class? Seems to me like a complicated way to represent an array

        /// <summary>
        /// List of spots
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>

        public SubArray<CGSpot> Spots
        {
            get => spots;
            set
            {
                ArrayPools.CGSpot.Free(spots);
                spots = value;
            }
        }

        /// <summary>
        /// List of spots
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use Spots instead")]
        public CGSpot[] Points
        {
            get => Spots.CopyToArray(ArrayPools.CGSpot);
            set => Spots = new SubArray<CGSpot>(value);
        }

        private SubArray<CGSpot> spots;

        public override int Count
        {
            get
            {
                return spots.Count;
            }
        }

        public CGSpots() : base()
        {
            spots = ArrayPools.CGSpot.Allocate(0);
        }

        public CGSpots(params CGSpot[] points) : base()
        {
            spots = new SubArray<CGSpot>(points);
        }

        public CGSpots(SubArray<CGSpot> spots) : base()
        {
            this.spots = spots;
        }

        public CGSpots(List<CGSpot> spots) : base()
        {
            this.spots = ArrayPools.CGSpot.Allocate(spots.Count);
            spots.CopyTo(0, this.spots.Array, 0, spots.Count);
        }

        public CGSpots(params List<CGSpot>[] spots) : base()
        {
            int c = 0;
            for (int i = 0; i < spots.Length; i++)
                c += spots[i].Count;
            this.spots = ArrayPools.CGSpot.Allocate(c);
            c = 0;
            for (int i = 0; i < spots.Length; i++)
            {
                List<CGSpot> cgSpots = spots[i];
                cgSpots.CopyTo(0, this.spots.Array, c, cgSpots.Count);
                c += cgSpots.Count;
            }
        }

        public CGSpots(CGSpots source) : base()
        {
            spots = ArrayPools.CGSpot.Clone(source.spots);
        }
        protected override bool Dispose(bool disposing)
        {
            bool result = base.Dispose(disposing);
            if (result)
                ArrayPools.CGSpot.Free(spots);
            return result;
        }

        public override T Clone<T>()
        {
            return new CGSpots(this) as T;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGData.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGDataRequests.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 171ae25dd0efed1458b5b7581e352db0
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using FluffyUnderware.Curvy.Pools;
using ToolBuddy.Pooling.Collections;
using ToolBuddy.Pooling.Pools;

#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif


namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Request Parameter base class
    /// </summary>
    public abstract class CGDataRequestParameter
    {
        public static implicit operator bool(CGDataRequestParameter a)
        {
            return !ReferenceEquals(a, null);
        }
    }

    /// <summary>
    /// Additional Spline Request parameters
    /// </summary>
    public class CGDataRequestMetaCGOptions : CGDataRequestParameter
    {
        /// <summary>
        /// Whether Hard Edges should produce extra samples
        /// </summary>
        /// <remarks>This may result in extra samples at affected Control Points</remarks>
        [Obsolete("This option is now always assumed to be true")]
        public bool CheckHardEdges;
        /// <summary>
        /// Whether MaterialID's should be stored
        /// </summary>
        /// <remarks>This may result in extra samples at affected Control Points</remarks>
        [Obsolete("This option is now always assumed to be true")]
        public bool CheckMaterialID;
        /// <summary>
        /// Whether all Control Points should be included
        /// </summary>
        public bool IncludeControlPoints;
        /// <summary>
        /// Whether UVEdge, ExplicitU and custom U settings should be included
        /// </summary>
        [Obsolete("This option is now always assumed to be true")]
        public bool CheckExtendedUV;


        public CGDataRequestMetaCGOptions(bool checkEdges, bool checkMaterials, bool includeCP, bool extendedUV)
        {
#pragma warning disable 618
            CheckHardEdges = checkEdges;
#pragma warning restore 618
#pragma warning disable 618
            CheckMaterialID = checkMaterials;
#pragma warning restore 618
            IncludeControlPoints = includeCP;
#pragma warning disable 618
            CheckExtendedUV = extendedUV;
#pragma warning restore 618
        }

        public override bool Equals(object obj)
        {
            CGDataRequestMetaCGOptions O = obj as CGDataRequestMetaCGOptions;
            if (O == null)
                return false;
#pragma warning disable 618
            return (CheckHardEdges == O.CheckHardEdges && CheckMaterialID == O.CheckMaterialID && IncludeControlPoints == O.IncludeControlPoints && CheckExtendedUV == O.CheckExtendedUV);
#pragma warning restore 618
        }

        public override int GetHashCode()
        {
#pragma warning disable 618
            return new { A = CheckHardEdges, B = CheckMaterialID, C = IncludeControlPoints, D = CheckExtendedUV }.GetHashCode(); //OPTIM avoid array creation
#pragma warning restore 618
        }

        public override string ToString()
        {
#pragma warning disable 618
            return $"{nameof(CheckHardEdges)}: {CheckHardEdges}, {nameof(CheckMaterialID)}: {CheckMaterialID}, {nameof(IncludeControlPoints)}: {IncludeControlPoints}, {nameof(CheckExtendedUV)}: {CheckExtendedUV}";
#pragma warning restore 618
        }
    }

    /// <summary>
    /// Shape Rasterization Request parameters
    /// </summary>
    public class CGDataRequestShapeRasterization : CGDataRequestRasterization
    {
        /// <summary>
        /// The <see cref="CGShape.RelativeDistances"/> array of the <see cref="CGPath"/> instance used for the shape extrusion that requests the current Shape rasterization
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<float> RelativeDistances
        {
            get => relativeDistances;
            set => relativeDistances = value;
        }

        /// <summary>
        /// The <see cref="CGShape.RelativeDistances"/> array of the <see cref="CGPath"/> instance used for the shape extrusion that requests the current Shape rasterization
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use RelativeDistances instead")]
        public float[] PathF
        {
            get => RelativeDistances.CopyToArray(ArrayPools.Single);
            set => RelativeDistances = new SubArray<float>(value);
        }

        private SubArray<float> relativeDistances;

        public CGDataRequestShapeRasterization(SubArray<float> relativeDistance, float start, float rasterizedRelativeLength, int resolution, float angle, ModeEnum mode = ModeEnum.Even) : base(start, rasterizedRelativeLength, resolution, angle, mode)
        {
            relativeDistances = ArrayPools.Single.Clone(relativeDistance);
        }

        [Obsolete("Use another constructor instead")]
        public CGDataRequestShapeRasterization(float[] pathF, float start, float rasterizedRelativeLength, int resolution, float angle, ModeEnum mode = ModeEnum.Even) : base(start, rasterizedRelativeLength, resolution, angle, mode)
        {
            relativeDistances = ArrayPools.Single.Clone(pathF);
        }

        public override bool Equals(object obj)
        {
            CGDataRequestShapeRasterization other = obj as CGDataRequestShapeRasterization;
            if (other == null)
                return false;

            if (!base.Equals(obj) || other.relativeDistances.Count != relativeDistances.Count)
                return false;

            for (var i = 0; i < relativeDistances.Count; i++)
            {
                if (other.relativeDistances.Array[i].Equals(relativeDistances.Array[i]) == false)
                    return false;
            }

            return true;
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return (base.GetHashCode() * 397) ^ (relativeDistances != null
                           ? relativeDistances.GetHashCode()
                           : 0);
            }
        }

        public override string ToString()
        {
            return $"{base.ToString()}, {nameof(RelativeDistances)}: {relativeDistances}";
        }
    }

    /// <summary>
    /// Rasterization Request parameters
    /// </summary>
    public class CGDataRequestRasterization : CGDataRequestParameter
    {
#if CONTRACTS_FULL
        [ContractInvariantMethod]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "Required for code contracts.")]
        private void ObjectInvariant()
        {
            Contract.Invariant(Start.IsRatio());
            Contract.Invariant(RasterizedRelativeLength.IsRatio());
            Contract.Invariant(Resolution > 0);
            Contract.Invariant(Resolution <= 100);
            Contract.Invariant(SplineAbsoluteLength.IsPositiveNumber());
            Contract.Invariant(AngleThreshold.IsIn0To180Range());
        }
#endif


        public enum ModeEnum
        {
            /// <summary>
            /// Distribute sample points evenly spread
            /// </summary>
            Even,
            /// <summary>
            /// Use Source' curvation to optimize the result
            /// </summary>
            Optimized
        }

        /// <summary>
        /// Relative Start Position (0..1)
        /// </summary>
        public float Start;

        /// <summary>
        /// Relative Length. A value of 1 means the full spline length
        /// </summary>
        public float RasterizedRelativeLength;

        /// <summary>
        /// Maximum number of samplepoints
        /// </summary>
        public int Resolution;

        /// <summary>
        /// Angle resolution (0..100) for optimized mode
        /// </summary>
        public float AngleThreshold;

        /// <summary>
        /// Rasterization mode
        /// </summary>
        public ModeEnum Mode;

        public CGDataRequestRasterization(float start, float rasterizedRelativeLength, int resolution, float angle, ModeEnum mode = ModeEnum.Even)
        {
#if CONTRACTS_FULL
            Contract.Requires(rasterizedRelativeLength.IsRatio());
#endif
            Start = Mathf.Repeat(start, 1);
            RasterizedRelativeLength = Mathf.Clamp01(rasterizedRelativeLength);
            Resolution = resolution;
            AngleThreshold = angle;
            Mode = mode;
        }

        public CGDataRequestRasterization(CGDataRequestRasterization source) : this(source.Start, source.RasterizedRelativeLength, source.Resolution, source.AngleThreshold, source.Mode)
        {
        }

        public override bool Equals(object obj)
        {
            CGDataRequestRasterization O = obj as CGDataRequestRasterization;
            if (O == null)
                return false;
            return (Start == O.Start && RasterizedRelativeLength == O.RasterizedRelativeLength && Resolution == O.Resolution && AngleThreshold == O.AngleThreshold && Mode == O.Mode);
        }

        public override int GetHashCode()
        {
            return new { A = Start, B = RasterizedRelativeLength, C = Resolution, D = AngleThreshold, E = Mode }.GetHashCode(); //OPTIM avoid array creation
        }

        public override string ToString()
        {
            return $"{nameof(Start)}: {Start}, {nameof(RasterizedRelativeLength)}: {RasterizedRelativeLength}, {nameof(Resolution)}: {Resolution}, {nameof(AngleThreshold)}: {AngleThreshold}, {nameof(Mode)}: {Mode}";
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGDataRequests.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 795eae83fdd52ee4697860cab17950d3
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;

#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Curvy Generator related event
    /// </summary>
    [System.Serializable]
    public class CurvyCGEvent : UnityEventEx<CurvyCGEventArgs> { }

    /// <summary>
    /// EventArgs for CurvyCGEvent events
    /// </summary>
    public class CurvyCGEventArgs : System.EventArgs
    {
        /// <summary>
        /// the component raising the event
        /// </summary>
        public readonly MonoBehaviour Sender;
        /// <summary>
        /// The related CurvyGenerator
        /// </summary>
        public readonly CurvyGenerator Generator;
        /// <summary>
        /// The related CGModule
        /// </summary>
        public readonly CGModule Module;

        public CurvyCGEventArgs(CGModule module)
        {
            Sender = module;
            Generator = module.Generator;
            Module = module;

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(Sender != null);
#endif
        }

        public CurvyCGEventArgs(CurvyGenerator generator, CGModule module)
        {
            Sender = generator;
            Generator = generator;
            Module = module;

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(Sender != null);
#endif
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGEvents.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGInterfaces.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0db4b847e74dae148ad1ba0205adbd50
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using FluffyUnderware.DevTools;
using JetBrains.Annotations;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// For modules that don't process anything
    /// </summary>
    public interface INoProcessing
    {
    }

    /// <summary>
    /// For modules that rely on external input (Splines, Meshes etc..)
    /// </summary>
    public interface IExternalInput
    {
        /// <summary>
        /// Whether the module currently supports an IPE session
        /// </summary>
        bool SupportsIPE { get; }
    }

    /// <summary>
    /// For modules that process data on demand
    /// </summary>
    public interface IOnRequestProcessing
    {
        CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests);
    }

    /// <summary>
    /// For modules that output instances of <see cref="CGPath"/>
    /// </summary>
    public interface IPathProvider
    {
        bool PathIsClosed { get; }
    }

    /// <summary>
    /// Resource Loader Interface
    /// </summary>
    public interface ICGResourceLoader
    {
        Component Create(CGModule cgModule, [NotNull] string context);
        void Destroy(CGModule cgModule, Component obj, [NotNull] string context, bool kill);
    }

    /// <summary>
    /// Resource Collection interface
    /// </summary>
    public interface ICGResourceCollection
    {
        int Count { get; }
        Component[] ItemsArray { get; }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGInterfaces.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGMeshResource.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bfd1baeec4f08064eb868f23f209ebc6
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using System.Collections.Generic;
using Object = UnityEngine.Object;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Mesh Resource Component used by Curvy Generator
    /// </summary>
    [RequireComponent(typeof(MeshRenderer))]
    [HelpURL(CurvySpline.DOCLINK + "cgmeshresource")]
    public class CGMeshResource : DuplicateEditorMesh, IPoolable
    {
        /// <summary>
        /// The value of the "Everything" entry in a <see cref="MeshCollider.cookingOptions"/>'s inspector
        /// </summary>
        public const MeshColliderCookingOptions EverMeshColliderCookingOptions = 
            MeshColliderCookingOptions.EnableMeshCleaning|
            MeshColliderCookingOptions.CookForFasterSimulation|
            MeshColliderCookingOptions.UseFastMidphase|
            MeshColliderCookingOptions.WeldColocatedVertices;

        private MeshRenderer mRenderer;
        private Collider mCollider;

        public MeshRenderer Renderer
        {
            get
            {
                if (mRenderer == null)
                    mRenderer = GetComponent<MeshRenderer>();
                return mRenderer;
            }
        }

        public Collider Collider
        {
            get
            {
                if (mCollider == null)
                    mCollider = GetComponent<Collider>();
                return mCollider;
            }

        }

        public Mesh Prepare()
        {
            return Filter.PrepareNewShared();
        }

        public bool ColliderMatches(CGColliderEnum type)
        {
            if (Collider == null && type == CGColliderEnum.None)
                return true;
            if (Collider is MeshCollider && type == CGColliderEnum.Mesh)
                return true;
            if (Collider is BoxCollider && type == CGColliderEnum.Box)
                return true;
            if (Collider is SphereCollider && type == CGColliderEnum.Sphere)
                return true;
            if (Collider is CapsuleCollider && type == CGColliderEnum.Capsule)
                return true;

            return false;
        }

        public void RemoveCollider()
        {
            if (Collider)
            {
                mCollider.Destroy(false, false);
                mCollider = null;
            }
        }

        /// <summary>
        /// Updates the collider if existing, and create a new one if not.
        /// </summary>
        /// <param name="mode">The collider's type</param>
        /// <param name="convex">Used only when mode is CGColliderEnum.Mesh</param>
        /// <param name="isTrigger">Is the collider a Trigger</param>
        /// <param name="material">The collider's material</param>
        /// <param name="meshCookingOptions">Used only when mode is CGColliderEnum.Mesh</param>
        /// <returns></returns>
        public bool UpdateCollider(CGColliderEnum mode, bool convex, bool isTrigger, PhysicsMaterial material
            , MeshColliderCookingOptions meshCookingOptions = EverMeshColliderCookingOptions
            )
        {
            if (Collider == null)
                switch (mode)
                {
                    case CGColliderEnum.Mesh:
                        mCollider = gameObject.AddComponent<MeshCollider>();
                        break;
                    case CGColliderEnum.Box:
                        mCollider = gameObject.AddComponent<BoxCollider>();
                        break;
                    case CGColliderEnum.Sphere:
                        mCollider = gameObject.AddComponent<SphereCollider>();
                        break;
                    case CGColliderEnum.Capsule:
                        mCollider = gameObject.AddComponent<CapsuleCollider>();
                        break;
                    case CGColliderEnum.None:
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }

            if (mode != CGColliderEnum.None)
            {
                switch (mode)
                {
                    case CGColliderEnum.Mesh:
                        MeshCollider meshCollider = Collider as MeshCollider;
                        if (meshCollider != null)
                        {
                            meshCollider.sharedMesh = null;
                            meshCollider.convex = convex;
                            meshCollider.isTrigger = isTrigger;
                            meshCollider.cookingOptions = meshCookingOptions;
                            try
                            {
                                meshCollider.sharedMesh = Filter.sharedMesh;
                            }
#if CURVY_SANITY_CHECKS
                            catch (Exception e)
                            {
                                DTLog.LogException(e, this);
#else
                            catch
                            {
#endif
                                return false;
                            }
                        }
                        else
                            DTLog.LogError("[Curvy] Collider of wrong type", this);
                        break;
                    case CGColliderEnum.Box:
                        BoxCollider boxCollider = Collider as BoxCollider;
                        if (boxCollider != null)
                        {
                            boxCollider.isTrigger = isTrigger;
                            boxCollider.center = Filter.sharedMesh.bounds.center;
                            boxCollider.size = Filter.sharedMesh.bounds.size;
                        }
                        else
                            DTLog.LogError("[Curvy] Collider of wrong type", this);
                        break;
                    case CGColliderEnum.Sphere:
                        SphereCollider sphereCollider = Collider as SphereCollider;
                        if (sphereCollider != null)
                        {
                            sphereCollider.isTrigger = isTrigger;
                            sphereCollider.center = Filter.sharedMesh.bounds.center;
                            sphereCollider.radius = Filter.sharedMesh.bounds.extents.magnitude;
                        }
                        else
                            DTLog.LogError("[Curvy] Collider of wrong type", this);
                        break;
                    case CGColliderEnum.Capsule:
                        CapsuleCollider capsuleCollider = Collider as CapsuleCollider;
                        if (capsuleCollider != null)
                        {
                            Bounds sharedMeshBounds = Filter.sharedMesh.bounds;
                            capsuleCollider.isTrigger = isTrigger;
                            capsuleCollider.center = sharedMeshBounds.center;
                            capsuleCollider.radius = new Vector2(sharedMeshBounds.extents.x, sharedMeshBounds.extents.y).magnitude;
                            capsuleCollider.height = sharedMeshBounds.size.z;
                            capsuleCollider.direction = 2;//Z
                        }
                        else
                            DTLog.LogError("[Curvy] Collider of wrong type", this);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }

                Collider.material = material;
            }

            return true;
        }

        public void OnBeforePush()
        {
        }

        public void OnAfterPop()
        {
        }
    }

    /// <summary>
    /// Collection of Mesh Resources
    /// </summary>
    [System.Serializable]
    public class CGMeshResourceCollection : ICGResourceCollection
    {
        public List<CGMeshResource> Items = new List<CGMeshResource>();

        public int Count
        {
            get
            {
                return Items.Count;
            }
        }

        public Component[] ItemsArray
        {
            get { return Items.ToArray(); }
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGMeshResource.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModule.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3febf7cd67efdd24cabe9faf9224067e
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections.Generic;
using System.Reflection;
using FluffyUnderware.DevTools.Extensions;

using System.Collections;
using System.Globalization;
using FluffyUnderware.DevTools;
using JetBrains.Annotations;
using Random = UnityEngine.Random;
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.AnimatedValues;
#endif




namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Curvy Generator module base class
    /// </summary>
    [ExecuteAlways]
    public abstract class CGModule : DTVersionedMonoBehaviour
    {
        #region ### Events ###

        /*! \cond PRIVATE */

        [Group("Events", Expanded = false, Sort = 1000)]
        [SerializeField]
        protected CurvyCGEvent m_OnBeforeRefresh = new CurvyCGEvent();
        [Group("Events")]
        [SerializeField]
        protected CurvyCGEvent m_OnRefresh = new CurvyCGEvent();

        /*! \endcond */

        public CurvyCGEvent OnBeforeRefresh
        {
            get { return m_OnBeforeRefresh; }
            set
            {
                if (m_OnBeforeRefresh != value)
                    m_OnBeforeRefresh = value;

            }

        }

        public CurvyCGEvent OnRefresh
        {
            get { return m_OnRefresh; }
            set
            {
                if (m_OnRefresh != value)
                    m_OnRefresh = value;

            }

        }

        protected CurvyCGEventArgs OnBeforeRefreshEvent(CurvyCGEventArgs e)
        {
            if (OnBeforeRefresh != null)
                OnBeforeRefresh.Invoke(e);
            return e;
        }

        protected CurvyCGEventArgs OnRefreshEvent(CurvyCGEventArgs e)
        {
            if (OnRefresh != null)
                OnRefresh.Invoke(e);
            return e;
        }

        #endregion

        #region ### Public Fields & Properties ###

        #region --- Fields ---

        [SerializeField, HideInInspector] private string m_ModuleName;
        [SerializeField, HideInInspector] private bool m_Active = true;

        [Group("Seed Options", Expanded = false, Sort = 1001)]
        [GroupCondition(nameof(usesRandom))]
        [FieldAction("CBSeedOptions", ShowBelowProperty = true)]
        [SerializeField]
        private bool m_RandomizeSeed = false;

        [SerializeField, HideInInspector] private int m_Seed = unchecked((int)System.DateTime.Now.Ticks);

        #endregion


        #region --- API Accessors ---

        public string ModuleName
        {
            get { return name; }
            set
            {
                if (name != value)
                {
                    name = value;
                    renameManagedResourcesINTERNAL();
                }
            }
        }

        public bool Active
        {
            get { return m_Active; }
            set
            {
                if (m_Active != value)
                {
                    m_Active = value;
                    Dirty = true;
                    Generator.sortModulesINTERNAL();
                }
            }
        }

        /// <summary>
        /// If <see cref="RandomizeSeed"/> is set to false, Seed is used to initialize Unity's random numbers generator before refreshing the
        /// If <see cref="RandomizeSeed"/> is set to true, a random seed will be used
        /// current module
        /// </summary>
        public int Seed
        {
            get { return m_Seed; }
            set
            {
                if (m_Seed != value)
                    m_Seed = value;
                Dirty = true;
            }
        }

        /// <summary>
        /// If is set to false, <see cref="Seed"/> is used to initialize Unity's random numbers generator before refreshing the current module.
        /// If set to true, a random seed will be used
        /// </summary>
        public bool RandomizeSeed
        {
            get { return m_RandomizeSeed; }
            set
            {
                if (m_RandomizeSeed != value)
                    m_RandomizeSeed = value;
            }
        }

        #endregion



        [System.NonSerialized]
        public List<string> UIMessages = new List<string>();

        public CurvyGenerator Generator
        {
            get { return mGenerator; }
        }

        private CurvyGenerator mGenerator;



        #endregion

        #region ### Graph Related ###


        #region UniqueID

        [SerializeField, HideInInspector] private int m_UniqueID;

        public int UniqueID
        {
            get { return m_UniqueID; }
        }

        // In order to reduce per frame allocations, we cache the string version
        private string m_UniqueIDString = null;
        private string UniqueIDString
        {
            get
            {
                if (m_UniqueIDString == null)
                    m_UniqueIDString = m_UniqueID.ToString(System.Globalization.CultureInfo.InvariantCulture);
                return m_UniqueIDString;
            }
        }

        #endregion


        /// <summary>
        /// Whether this module has circular reference errors
        /// </summary>
        public bool CircularReferenceError { get; set; }

        /// <summary>
        /// Helper for topology sorting
        /// </summary>
        //DESIGN inline this in doSortModules()
        internal int SortAncestors;


        [HideInInspector]
        public CGModuleProperties Properties = new CGModuleProperties();
        [HideInInspector]
        public List<CGModuleLink> InputLinks = new List<CGModuleLink>();
        [HideInInspector]
        public List<CGModuleLink> OutputLinks = new List<CGModuleLink>();

        // These will be filled by reflection in OnEnable()
        public Dictionary<string, CGModuleInputSlot> InputByName { get; private set; }
        public Dictionary<string, CGModuleOutputSlot> OutputByName { get; private set; }
        public List<CGModuleInputSlot> Input { get; private set; }
        public List<CGModuleOutputSlot> Output { get; private set; }

        public ModuleInfoAttribute Info
        {
            get
            {
                if (mInfo == null)
                    mInfo = getInfo();
                return mInfo;
            }
        }

        private ModuleInfoAttribute mInfo;

        //-----

        public bool Dirty
        {
            get { return mDirty; }
            set
            {
                if (mDirty != value)
                    mDirty = value;


                if (mDirty)
                {
                    bool isConfigured = IsConfigured;
                    if (mLastIsConfiguredState != isConfigured)
                        mStateChangeDirty = true;
                    mLastIsConfiguredState = isConfigured;
                    if (Output != null)
                    {
                        for (int i = 0; i < Output.Count; i++)
                        {
                            if (Output[i].IsLinked)
                            {
                                List<CGModule> modules = Output[i].GetLinkedModules();
                                for (int m = 0; m < modules.Count; m++)
                                    //BUG? does the || modules[m].CircularReferenceError create infinite dirtying logique?
                                    if (modules[m] != this || modules[m].CircularReferenceError) // prevent circular reference
                                        modules[m].Dirty = true;
                            }
                        }
                    }
                }

                if (this is IOnRequestProcessing || this is INoProcessing)
                {
                    mDirty = false;
                    if (Output != null)
                        for (int i = 0; i < Output.Count; i++)
                            Output[i].LastRequestParameters = null;
                }

            }
        }

        private bool mDirty = true;
        private bool mInitialized = false;

        private bool mStateChangeDirty;
        private bool mLastIsConfiguredState;


        #endregion

        #region ### Debugging ###
#if UNITY_EDITOR || CURVY_DEBUG
        public System.DateTime DEBUG_LastUpdateTime;
        public TimeMeasure DEBUG_ExecutionTime = new TimeMeasure(5);
#endif

        #endregion

        #region ### Unity Callbacks (Virtual) ###

        protected virtual void Awake()
        {
            mGenerator = RetrieveGenerator();
        }

        protected virtual void OnEnable()
        {
            if (mGenerator)
            {
                Initialize();
                Generator.sortModulesINTERNAL();
            }
        }

        public void Initialize()
        {
            if (!mGenerator)
                mGenerator = RetrieveGenerator();
            if (!mGenerator)
                Invoke(nameof(Delete), 0);
            else
            {
                mInfo = getInfo();

                if (string.IsNullOrEmpty(ModuleName))
                    if (string.IsNullOrEmpty(Info.ModuleName))
                        ModuleName = Generator.getUniqueModuleNameINTERNAL(Info.MenuName.Substring(Info.MenuName.LastIndexOf("/", StringComparison.Ordinal) + 1));
                    else
                        ModuleName = Generator.getUniqueModuleNameINTERNAL(Info.ModuleName);

                loadSlots();
                mInitialized = true;
            }
        }

        protected virtual void OnDisable()
        {
        }

        protected virtual void OnDestroy()
        {
            bool realDestroy = true;
#if UNITY_EDITOR
            if (EditorApplication.isPlayingOrWillChangePlaymode && !EditorApplication.isPlaying)
                realDestroy = false;
#endif
            setTreeDirtyStateChange();
            List<Component> res;
            List<string> resNames;
            // Resources
            if (realDestroy)
            {
                if (GetManagedResources(out res, out resNames))
                {
                    for (int i = res.Count - 1; i >= 0; i--)
                        DeleteManagedResource(resNames[i], res[i], string.Empty, true);
                }
            }

            // Links

            List<CGModuleInputSlot> inSlots = GetInputSlots();
            foreach (CGModuleInputSlot slot in inSlots)
            {
                List<CGModule> linkedModules = slot.GetLinkedModules();
                foreach (CGModule module in linkedModules)
                    if (module != null)
                        module.ReInitializeLinkedSlots();
            }

            List<CGModuleOutputSlot> outSlots = GetOutputSlots();
            foreach (CGModuleOutputSlot slot in outSlots)
            {
                List<CGModule> linkedModules = slot.GetLinkedModules();
                foreach (CGModule module in linkedModules)
                    if (module != null)
                        module.ReInitializeLinkedSlots();
            }

            if (Generator)
            {
                // Delete module
                Generator.ModulesByID.Remove(UniqueID);
                Generator.Modules.Remove(this);
                Generator.sortModulesINTERNAL();
            }
            mInitialized = false;
        }

#if UNITY_EDITOR
        /*DESIGN:simplify the CGModules' OnValidate and properties by:
        - Make properties set dirty only if the value has changed
        - Set dirty to true in CGModule.OnValidate
        - avoid calling SomeProperty = m_SomeProperty in the OnValidate of all CGModules. You have of course to handle any work done by SomeProperty, that is not dirtying, in the OnValidate of these modules.*/
        protected virtual void OnValidate()
        {
        }

        private void Update()
        {
            if (!Application.isPlaying)
                renameManagedResourcesINTERNAL();
        }
#endif
        private void OnDidApplyAnimationProperties()
        {
            Dirty = true;
        }

        #endregion

        #region ### Virtual Methods & Properties ###

        /// <summary>
        /// Gets whether the module is properly configured i.e. has everything to work like intended
        /// </summary>
        public virtual bool IsConfigured
        {
            get
            {
                if (!IsInitialized || CircularReferenceError || !Active)
                    return false;

                int validTotalLinks = 0;
                for (int i = 0; i < Input.Count; i++)
                {
                    InputSlotInfo myInfo = Input[i].InputInfo;
                    if (Input[i].IsLinked)
                    {
                        for (int link = 0; link < Input[i].Count; link++)
                            if (Input[i].SourceSlot(link) != null)
                            {
                                if (Input[i].SourceSlot(link).Module.IsConfigured)
                                    validTotalLinks++;
                                else if (!myInfo.Optional)
                                    return false;
                            }
                    }
                    else
                        if (myInfo == null || !myInfo.Optional)
                        return false;
                }

                return validTotalLinks > 0 || Input.Count == 0;
            }
        }

        /// <summary>
        /// Gets whether the module and all its dependencies are fully initialized
        /// </summary>
        public virtual bool IsInitialized { get { return mInitialized; } }

        /// <summary>
        /// Add Module processing code in here
        /// </summary>
        public virtual void Refresh()
        {
            //            Debug.Log(name + ".Refresh()");
            UIMessages.Clear();
        }

        public virtual void Reset()
        {
            ModuleName = string.IsNullOrEmpty(Info.ModuleName) ? GetType().Name : Info.ModuleName;

            //Remove all non-persisent (ie created from script) listeners from the events. Might help with garbage collection
            if (OnBeforeRefresh != null)
                OnBeforeRefresh.RemoveAllListeners();
            if (OnRefresh != null)
                OnRefresh.RemoveAllListeners();

            OnBeforeRefresh = new CurvyCGEvent();
            OnRefresh = new CurvyCGEvent();

            DeleteAllOutputManagedResources();
        }

        public void ReInitializeLinkedSlots()
        {
            List<CGModuleInputSlot> ins = GetInputSlots();
            List<CGModuleOutputSlot> ous = GetOutputSlots();
            for (int i = 0; i < ins.Count; i++)
                ins[i].ReInitializeLinkedSlots();
            for (int i = 0; i < ous.Count; i++)
                ous[i].ReInitializeLinkedSlots();
        }

        /// <summary>
        /// Delete all the managed resources acting as an output. One example of this are the generated meshes by the <see cref="FluffyUnderware.Curvy.Generator.Modules.CreateMesh"/> module
        /// </summary>
        /// <returns>True if there were deleted resources</returns>
        virtual public bool DeleteAllOutputManagedResources()
        {
            return false;
        }

        /// <summary>
        /// Called when a module's state changes (Link added/removed, Active toggles etc..)
        /// </summary>
        public virtual void OnStateChange()
        {
            //            Debug.Log(name + ".OSC, configured="+IsConfigured);
            Dirty = true;

            if (Output != null)
            {
                for (int i = 0; i < Output.Count; i++)
                {
                    Output[i].ClearData();
                    /*
                    if (Output[i].IsLinked)
                    {
                        var modules = Output[i].GetLinkedModules();
                        for (int m = 0; m < modules.Count; m++)
                            if (modules[m] != this || modules[m].CircularReferenceError) // prevent circular reference
                                modules[m].CheckAndRaiseOnStateChangedINTERNAL();
                    }
                     */
                }
            }
#if UNITY_EDITOR
            if (Input != null)
                for (int i = 0; i < Input.Count; i++)
                    Input[i].LastDataCountINTERNAL = 0;
#endif
            if (!IsConfigured)
                DeleteAllOutputManagedResources();
        }

        /// <summary>
        /// Called after a module was copied to a template
        /// </summary>
        /// <remarks>Use this handle references that can't be templated etc...</remarks>
        public virtual void OnTemplateCreated()
        {
            DeleteAllOutputManagedResources();
        }

        #endregion

        #region ### Helpers ###

        /// <summary>
        /// Gets a request parameter of a certain type
        /// </summary>
        /// <typeparam name="T">Type derived from PCGDataRequestParameter</typeparam>
        /// <param name="requests">reference to the list of request parameters</param>
        /// <returns>the wanted request parameter or null</returns>
        static protected T GetRequestParameter<T>(ref CGDataRequestParameter[] requests) where T : CGDataRequestParameter
        {
            for (int i = 0; i < requests.Length; i++)
                if (requests[i] is T)
                    return (T)requests[i];

            return null;
        }

        /// <summary>
        /// Removes a certain request parameter from the requests array
        /// </summary>
        /// <param name="requests">reference to the requests array</param>
        /// <param name="request">the request to remove</param>
        static protected void RemoveRequestParameter(ref CGDataRequestParameter[] requests, CGDataRequestParameter request)
        {
            for (int i = 0; i < requests.Length; i++)
                if (requests[i] == request)
                {
                    requests = requests.RemoveAt(i);
                    return;
                }

        }

        #endregion

        #region ### Public Methods ###


        public CGModuleLink GetOutputLink(CGModuleOutputSlot outSlot, CGModuleInputSlot inSlot)
        {
            return GetLink(OutputLinks, outSlot, inSlot);
        }

        public List<CGModuleLink> GetOutputLinks(CGModuleOutputSlot outSlot)
        {
            return GetLinks(OutputLinks, outSlot);
        }

        public CGModuleLink GetInputLink(CGModuleInputSlot inSlot, CGModuleOutputSlot outSlot)
        {
            return GetLink(InputLinks, inSlot, outSlot);
        }

        public List<CGModuleLink> GetInputLinks(CGModuleInputSlot inSlot)
        {
            return GetLinks(InputLinks, inSlot);
        }


        public CGModule CopyTo(CurvyGenerator targetGenerator)
        {
            if (this == null)
                throw new InvalidOperationException($"[Curvy] Trying to copy the already deleted module {this.name}");

            CGModule newModule = this.DuplicateGameObject<CGModule>(targetGenerator.transform, false);
            newModule.mGenerator = targetGenerator;
            newModule.Initialize();
            newModule.ModuleName = ModuleName;
            newModule.ModuleName = targetGenerator.getUniqueModuleNameINTERNAL(newModule.ModuleName);
            newModule.SetUniqueIdINTERNAL();
            newModule.renameManagedResourcesINTERNAL();
            return newModule;
        }

        public Component AddManagedResource(string resourceName, string context = "", int index = -1)
        {
            Component res = CGResourceHandler.CreateResource(this, resourceName, context);
            if (res == null)
                throw new InvalidOperationException(String.Format("[Curvy] Could not create managed resource of type '{0}'. In some cases this is due to not enough elements in a resources Pool", resourceName));
            res.name = GetResourceName(
                context == "" ? resourceName : (resourceName + context),
                index);
            res.transform.SetParent(transform);
            return res;
        }


        public void DeleteManagedResource(string resourceName, Component res, [NotNull] string context = "", bool dontUsePool = false)
        {
            if (res)
                CGResourceHandler.DestroyResource(this, resourceName, res, context, dontUsePool);
        }

        public bool IsManagedResource(Component res)
        {
            return (res && res.transform.parent == transform);//res.gameObject.GetComponentInParent<CurvyGenerator>() == Generator);RetrieveGenerator
        }


        public List<IPool> GetAllPrefabPools()
        {
            return Generator.PoolManager.FindPools(UniqueIDString + "_");
        }

        public void DeleteAllPrefabPools()
        {
            Generator.PoolManager.DeletePools(UniqueIDString + "_");
        }

        public void Delete()
        {
            OnStateChange();
            gameObject.Destroy(true, true);
        }

        public CGModuleInputSlot GetInputSlot(string name)
        {
            return (InputByName != null && InputByName.ContainsKey(name)) ? InputByName[name] : null;
        }

        public List<CGModuleInputSlot> GetInputSlots(System.Type filterType = null)
        {
            if (filterType == null)
                return new List<CGModuleInputSlot>(Input);
            else
            {
                List<CGModuleInputSlot> res = new List<CGModuleInputSlot>();
                for (int i = 0; i < Output.Count; i++)
                    if (Output[i].Info.DataTypes[0] == filterType || Output[i].Info.DataTypes[0].IsSubclassOf(filterType))
                        res.Add(Input[i]);

                return res;
            }
        }

        public CGModuleOutputSlot GetOutputSlot(string name)
        {
            return (OutputByName != null && OutputByName.ContainsKey(name)) ? OutputByName[name] : null;
        }

        public List<CGModuleOutputSlot> GetOutputSlots(System.Type filterType = null)
        {
            if (filterType == null)
                return new List<CGModuleOutputSlot>(Output);
            else
            {
                List<CGModuleOutputSlot> res = new List<CGModuleOutputSlot>();
                for (int i = 0; i < Output.Count; i++)
                    if (Output[i].Info.DataTypes[0] == filterType || Output[i].Info.DataTypes[0].IsSubclassOf(filterType))
                        res.Add(Output[i]);

                return res;
            }
        }

        public bool GetManagedResources(out List<Component> components, out List<string> resourceNames)
        {
            components = new List<Component>();
            resourceNames = new List<string>();
            FieldInfo[] fields = GetType().GetAllFields(false, true);
            foreach (FieldInfo f in fields)
            {
                CGResourceManagerAttribute at = f.GetCustomAttribute<CGResourceManagerAttribute>();
                if (at != null)
                {
                    if (typeof(ICGResourceCollection).IsAssignableFrom(f.FieldType))
                    {
                        ICGResourceCollection col = f.GetValue(this) as ICGResourceCollection;
                        if (col != null)
                        {
                            Component[] items = col.ItemsArray;
                            foreach (Component component in items)
                            {
                                //component can be null if for example the user delete from the hierarchy a CGMeshResource game object
                                if (component && component.transform.parent == transform)
                                {
                                    components.Add(component);
                                    resourceNames.Add(at.ResourceName);
                                }
                            }
                        }
                    }
                    else
                    {
                        Component component = f.GetValue(this) as Component;
                        if (component && component.transform.parent == transform)
                        {
                            components.Add(component);
                            resourceNames.Add(at.ResourceName);
                        }
                    }
                }
            }

            return (components.Count > 0);
        }



        #endregion

        #region ### Privates, Protected and Internals ###
        /*! \cond PRIVATE */
        /*! @name Internal Public
         *  Don't use them unless you know what you're doing!
         */
        //@{

        /*
        public void CheckAndRaiseOnStateChangedINTERNAL()
        {
            
            bool b = mLastIsConfiguredState;
            Debug.Log(name + " check ="+b+":"+IsConfigured);
            if (IsConfigured != b)
                OnStateChange();
            
        }
         */

        private readonly Dictionary<string, Dictionary<int, string>> resourcesNameCache = new Dictionary<string, Dictionary<int, string>>();

        private string GetResourceName(string resourceName, int index)
        {
            string newName = null;
            bool found;
            if (found = resourcesNameCache.TryGetValue(resourceName, out var dictionary))
                found = dictionary.TryGetValue(index, out newName);
            else
                resourcesNameCache[resourceName] = new Dictionary<int, string>();

            if (found == false)
            {
                newName = index > -1
                    ? string.Format(CultureInfo.InvariantCulture, "{0}_{1}_{2}{3:000}", ModuleName, UniqueIDString, resourceName, index)
                    : string.Format(CultureInfo.InvariantCulture, "{0}_{1}_{2}", ModuleName, UniqueIDString, resourceName);
                resourcesNameCache[resourceName][index] = newName;
            }

            return newName;
        }

        protected void RenameResource(string resourceName, Component resource, int index = -1)
        {
            string newName = GetResourceName(resourceName, index);
            //This check is necessary because when CurvyGenerator.ForceFrequentUpdates is true, this bug happens
            //[FIXED] When a scene has input spline path or input spline shape module, renaming objects from the hierarchy or though the F2 shortcut does not work
            if (resource.name != newName)
                resource.name = newName;
        }

        private static CGModuleLink GetLink(List<CGModuleLink> lst, CGModuleSlot source, CGModuleSlot target)
        {
            for (int i = 0; i < lst.Count; i++)
                if (lst[i].IsSame(source, target))
                    return lst[i];
            return null;
        }

        private static List<CGModuleLink> GetLinks(List<CGModuleLink> lst, CGModuleSlot source)
        {
            List<CGModuleLink> res = new List<CGModuleLink>();
            for (int i = 0; i < lst.Count; i++)
                if (lst[i].IsFrom(source))
                    res.Add(lst[i]);
            return res;
        }

        protected PrefabPool GetPrefabPool(GameObject prefab)
        {
            return Generator.PoolManager.GetPrefabPool(UniqueIDString + "_" + prefab.name, prefab);
        }

        protected bool TryDeleteChildrenFromAssociatedPrefab()
        {
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                int childCount = transform.childCount;
                for (int i = 0; i < childCount; i++)
                {
                    Transform item = transform.GetChild(i);
                    if (DTUtility.DoesPrefabStatusAllowDeletion(item.gameObject, out _) == false)
                    {
                        Generator.DeleteAllOutputManagedResourcesFromAssociatedPrefab();
                        return true;
                    }
                }
            }
#endif
            return false;
        }


        public int SetUniqueIdINTERNAL()
        {
            m_UniqueID = ++Generator.m_LastModuleID;
            m_UniqueIDString = null; //invalidate cache
            return m_UniqueID;
        }

        /// <summary>
        /// Initializes SortAncestor with number of connected Input links
        /// </summary>
        //DESIGN inline this in doSortModules()
        internal void initializeSort()
        {
            SortAncestors = 0;
            CircularReferenceError = false;
            //if (Active)
            //{
            for (int i = 0; i < Input.Count; i++)
                if (Input[i].IsLinked)
                    SortAncestors += Input[i].LinkedSlots.Count;
            //}
        }
        /// <summary>
        /// Decrement SortAncestor of linked modules and return a list of childs where SortAncestor==0
        /// </summary>
        /// <returns></returns>
        //DESIGN inline this in doSortModules()
        internal List<CGModule> decrementChilds()
        {
            List<CGModule> noAncestors = new List<CGModule>();
            for (int s = 0; s < Output.Count; s++)
                for (int l = 0; l < Output[s].LinkedSlots.Count; l++)
                {
                    if (--Output[s].LinkedSlots[l].Module.SortAncestors == 0)
                        noAncestors.Add(Output[s].LinkedSlots[l].Module);
                }

            return noAncestors;
        }

        internal void doRefresh()
        {
#if UNITY_EDITOR || CURVY_DEBUG
            DEBUG_LastUpdateTime = System.DateTime.Now;
            DEBUG_ExecutionTime.Start();
#endif

            if (RandomizeSeed)
                Random.InitState(unchecked((int)System.DateTime.Now.Ticks));
            else
                Random.InitState(Seed);
            OnBeforeRefreshEvent(new CurvyCGEventArgs(this));
            Refresh();
            Random.InitState(unchecked((int)System.DateTime.Now.Ticks));

#if UNITY_EDITOR || CURVY_DEBUG
            DEBUG_ExecutionTime.Stop();
#endif
            OnRefreshEvent(new CurvyCGEventArgs(this));

            mDirty = false;
        }

        internal ModuleInfoAttribute getInfo()
        {
            object[] inf = GetType().GetCustomAttributes(typeof(ModuleInfoAttribute), true);
            return (inf.Length > 0) ? (ModuleInfoAttribute)inf[0] : null;
        }

        private bool usesRandom()
        {
            return (Info != null && Info.UsesRandom);
        }

        private void loadSlots()
        {
            // Get list of Slots
            InputByName = new Dictionary<string, CGModuleInputSlot>();
            OutputByName = new Dictionary<string, CGModuleOutputSlot>();
            Input = new List<CGModuleInputSlot>();
            Output = new List<CGModuleOutputSlot>();
            FieldInfo[] fields = GetType().GetAllFields();
            //Debug.Log(name + ".loadSlots()");
            foreach (FieldInfo f in fields)
            {
                if (f.FieldType == typeof(CGModuleInputSlot))
                {
                    CGModuleInputSlot s = (CGModuleInputSlot)f.GetValue(this);
                    s.Module = this;
                    s.Info = getSlotInfo(f);
                    s.ReInitializeLinkedSlots();
                    InputByName.Add(s.Info.Name, s);
                    Input.Add(s);
                }
                else if (f.FieldType == typeof(CGModuleOutputSlot))
                {
                    CGModuleOutputSlot s = (CGModuleOutputSlot)f.GetValue(this);
                    s.Module = this;
                    s.Info = getSlotInfo(f);
                    s.ReInitializeLinkedSlots();
                    OutputByName.Add(s.Info.Name, s);
                    Output.Add(s);
                }
            }
        }

        private SlotInfo getSlotInfo(FieldInfo f)
        {
            SlotInfo si = f.GetCustomAttribute<SlotInfo>();
            if (si != null)
            {
                if (string.IsNullOrEmpty(si.Name))
                    si.Name = f.Name.TrimStart("In").TrimStart("Out");
                for (int x = 0; x < si.DataTypes.Length; x++)
                    if (!si.DataTypes[x].IsSubclassOf(typeof(CGData)))
                        Debug.LogError(string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}, Slot '{1}': Data type needs to be subclass of CGData!", GetType().Name, si.DisplayName));
                return si;
            }
            Debug.LogError("The Slot '" + f.Name + "' of type '" + f.DeclaringType.Name + "' needs a SlotInfo attribute!");
            return null;
        }

        private void setTreeDirtyStateChange()
        {
            mStateChangeDirty = true;
            if (Output != null)
            {
                for (int i = 0; i < Output.Count; i++)
                {
                    if (Output[i].IsLinked)
                    {
                        List<CGModule> modules = Output[i].GetLinkedModules();
                        for (int m = 0; m < modules.Count; m++)
                            //BUG? does the || modules[m].CircularReferenceError create infinite dirtying logique?
                            if (modules[m] != this || modules[m].CircularReferenceError) // prevent circular reference
                                modules[m].setTreeDirtyStateChange();
                    }
                }
            }
        }

        private CurvyGenerator RetrieveGenerator()
        {
            //return GetComponentInParent<CurvyGenerator>();
            return transform.parent != null
                ? transform.parent.GetComponent<CurvyGenerator>()
                : null;
        }

        public void checkOnStateChangedINTERNAL()
        {
            //            Debug.Log(ModuleName+".Check: " + mStateChangeDirty);
            if (mStateChangeDirty)
                OnStateChange();
            mStateChangeDirty = false;
        }


        public void renameManagedResourcesINTERNAL()
        {
            FieldInfo[] fields = GetType().GetAllFields(false, true);
            foreach (FieldInfo f in fields)
            {
                CGResourceManagerAttribute at = f.GetCustomAttribute<CGResourceManagerAttribute>();
                if (at != null)
                {
                    Component cmp = f.GetValue(this) as Component;
                    if (cmp && cmp.transform.parent == this.transform)
                        RenameResource(at.ResourceName, cmp);
                }
            }
        }


        //@}
        /*! \endcond */
        #endregion


    }

    /// <summary>
    /// Attribute defining basic module properties
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public sealed class ModuleInfoAttribute : System.Attribute, System.IComparable
    {
        /// <summary>
        /// Menu-Name of the module (without '/')
        /// </summary>
        public readonly string MenuName;
        /// <summary>
        /// Default Module name
        /// </summary>
        public string ModuleName;
        /// <summary>
        /// Tooltip Info
        /// </summary>
        public string Description;

        /// <summary>
        /// Whether the module uses Random, i.e. should show Seed options
        /// </summary>
        public bool UsesRandom;

        public ModuleInfoAttribute(string name)
        {
            MenuName = name;
        }

        public int CompareTo(object obj)
        {
            return String.Compare(MenuName, ((ModuleInfoAttribute)obj).MenuName, StringComparison.Ordinal);
        }



        //TODO code analysis (CA1036) says that Equal, !=, <, == and > should be defined since IComparable is implemented
    }


    /// <summary>
    /// CGModule helper class
    /// </summary>
    [System.Serializable]
    public class CGModuleProperties
    {
        public Rect Dimensions;
#if UNITY_EDITOR
        public AnimBool Expanded;
#endif
        public float MinWidth = 250;
        public float LabelWidth;
        public Color BackgroundColor = Color.black;

        public CGModuleProperties()
        {
#if UNITY_EDITOR
            Expanded = new AnimBool(true);
            Expanded.speed = 3;
#endif
        }
    }


}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModule.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModuleLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a742dce02c15b8544a4337da3c04c78a
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Class defining a linkage between two modules' slots
    /// </summary>
    [System.Serializable]
    public class CGModuleLink
    {
        // Self
        [SerializeField] private int m_ModuleID;
        [SerializeField] private string m_SlotName;
        // Other
        [SerializeField] private int m_TargetModuleID;
        [SerializeField] private string m_TargetSlotName;

        public int ModuleID { get { return m_ModuleID; } }
        public string SlotName { get { return m_SlotName;} }
        public int TargetModuleID { get { return m_TargetModuleID; } }
        public string TargetSlotName { get { return m_TargetSlotName; } }
        
        

        public CGModuleLink(int sourceID, string sourceSlotName, int targetID, string targetSlotName)
        {
            m_ModuleID = sourceID;
            m_SlotName = sourceSlotName;
            m_TargetModuleID = targetID;
            m_TargetSlotName = targetSlotName;
        }

        public CGModuleLink(CGModuleSlot source, CGModuleSlot target) : this(source.Module.UniqueID,source.Name,target.Module.UniqueID,target.Name) {}

        public bool IsSame(CGModuleLink o)
        {
            return (ModuleID == o.ModuleID &&
                    SlotName == o.SlotName &&
                    TargetModuleID == o.TargetModuleID &&
                    TargetSlotName == o.m_TargetSlotName);
        }

        public bool IsSame(CGModuleSlot source, CGModuleSlot target)
        {
            return (ModuleID == source.Module.UniqueID &&
                    SlotName == source.Name &&
                    TargetModuleID == target.Module.UniqueID &&
                    TargetSlotName == target.Name);
        }

        public bool IsTo(CGModuleSlot s)
        {
            return (s.Module.UniqueID == TargetModuleID && s.Name == TargetSlotName);
        }

        public bool IsFrom(CGModuleSlot s)
        {
            return (s.Module.UniqueID == ModuleID && s.Name == SlotName);
        }

        public bool IsUsing(CGModule module)
        {
            return (ModuleID == module.UniqueID || TargetModuleID == module.UniqueID);
        }

        public bool IsBetween(CGModuleSlot one, CGModuleSlot another)
        {
            return ((IsTo(one) && IsFrom(another)) ||
                   (IsTo(another) && IsFrom(one)));
        }

        public void SetModuleIDIINTERNAL(int moduleID, int targetModuleID)
        {
            m_ModuleID = moduleID;
            m_TargetModuleID = targetModuleID;
        }
        

        public static implicit operator bool(CGModuleLink a)
        {
            return !object.ReferenceEquals(a, null);
        }

        public override string ToString()
        {
            return string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}({1})->{2}({3})", SlotName, ModuleID, TargetSlotName, TargetModuleID);
        }
        
    }

   
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModuleLink.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModuleSlot.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 82ee39978f511ae4c9a157723ae1e1c1
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;
using System.Linq;
using System.Reflection;
using FluffyUnderware.DevTools;
using ToolBuddy.Pooling.Pools;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Class defining a module slot
    /// </summary>
    public class CGModuleSlot
    {
        /// <summary>
        /// The Module this Slot belongs to
        /// </summary>
        public CGModule Module { get; internal set; }
        /// <summary>
        /// Gets the SlotInfo Attribute
        /// </summary>
        public SlotInfo Info { get; internal set; }

        /// <summary>
        /// Origin of Link-Wire
        /// </summary>
        public Vector2 Origin { get; set; }
        /// <summary>
        /// Mouse-Hotzone
        /// </summary>
        public Rect DropZone { get; set; }

        /// <summary>
        /// Whether the link is wired or not
        /// </summary>
        public bool IsLinked { get { return LinkedSlots != null && LinkedSlots.Count > 0; } }
        /// <summary>
        /// Whether the link is wired and all connected modules are configured
        /// </summary>
        public bool IsLinkedAndConfigured
        {
            get
            {
                if (!IsLinked)
                    return false;
                for (int i = 0; i < LinkedSlots.Count; i++)
                    if (!LinkedSlots[i].Module.IsConfigured)
                        return false;
                return true;
            }
        }
        /// <summary>
        /// Gets the module as an <see cref="IOnRequestProcessing"/>
        /// </summary>
        public IOnRequestProcessing OnRequestModule { get { return Module as IOnRequestProcessing; } }
        /// <summary>
        /// Gets the module as an <see cref="IPathProvider"/>
        /// </summary>
        public IPathProvider PathProvider { get { return Module as IPathProvider; } }
        /// <summary>
        /// Gets the module as an <see cref="IExternalInput"/>
        /// </summary>
        public IExternalInput ExternalInput { get { return Module as IExternalInput; } }
        /// <summary>
        /// All slots of linked modules
        /// </summary>
        public List<CGModuleSlot> LinkedSlots
        {
            get
            {
                if (mLinkedSlots == null)
                    LoadLinkedSlots();
                return mLinkedSlots ?? new List<CGModuleSlot>();
            }
        }
        /// <summary>
        /// Gets the number of connected links, i.e. shortcut to this.Links.Count
        /// </summary>
        public int Count
        {
            get { return LinkedSlots.Count; }
        }

        public string Name
        {
            get { return (Info != null) ? Info.Name : ""; }
        }

        protected List<CGModuleSlot> mLinkedSlots = null;

        public CGModuleSlot()
        {

        }

        public bool HasLinkTo(CGModuleSlot other)
        {
            for (int i = 0; i < LinkedSlots.Count; i++)
                if (LinkedSlots[i] == other)
                    return true;

            return false;
        }

        /// <summary>
        /// Gets a list of all Links' modules
        /// </summary>
        public List<CGModule> GetLinkedModules()
        {
            List<CGModule> res = new List<CGModule>();
            for (int i = 0; i < LinkedSlots.Count; i++)
                res.Add(LinkedSlots[i].Module);
            return res;
        }

        public virtual void LinkTo(CGModuleSlot other)
        {
            if (Module)
            {
                Module.Generator.sortModulesINTERNAL();
                Module.Dirty = true;
            }
            if (other.Module)
                other.Module.Dirty = true;
        }

        protected static void LinkInputAndOutput(CGModuleSlot inputSlot, CGModuleSlot outputSlot)
        {
            if ((!inputSlot.Info.Array || inputSlot.Info.ArrayType == SlotInfo.SlotArrayType.Hidden) && inputSlot.IsLinked)
                inputSlot.UnlinkAll();

            outputSlot.Module.OutputLinks.Add(new CGModuleLink(outputSlot, inputSlot));
            inputSlot.Module.InputLinks.Add(new CGModuleLink(inputSlot, outputSlot));
            if (!outputSlot.LinkedSlots.Contains(inputSlot))
                outputSlot.LinkedSlots.Add(inputSlot);
            if (!inputSlot.LinkedSlots.Contains(outputSlot))
                inputSlot.LinkedSlots.Add(outputSlot);
        }

        public virtual void UnlinkFrom(CGModuleSlot other)
        {
            if (Module)
            {
                Module.Generator.sortModulesINTERNAL();
                Module.Dirty = true;
            }
            if (other.Module)
                other.Module.Dirty = true;
        }

        public virtual void UnlinkAll()
        {
        }

        public void ReInitializeLinkedSlots()
        {
            mLinkedSlots = null;
        }

        protected virtual void LoadLinkedSlots()
        {
        }

        public static implicit operator bool(CGModuleSlot a)
        {
            return !object.ReferenceEquals(a, null);
        }

        public override string ToString()
        {
            return string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}: {1}.{2}", GetType().Name, Module.name, Name);
        }

    }

    /// <summary>
    /// Class defining a module's input slot
    /// </summary>
    [System.Serializable]
    public class CGModuleInputSlot : CGModuleSlot
    {
        public InputSlotInfo InputInfo { get { return Info as InputSlotInfo; } }
#if UNITY_EDITOR
        public int LastDataCountINTERNAL { get; set; }
#endif
        public CGModuleInputSlot() : base() { }


        protected override void LoadLinkedSlots()
        {
            if (!Module.Generator.IsInitialized)
                return;
            base.LoadLinkedSlots();
            mLinkedSlots = new List<CGModuleSlot>();
            List<CGModuleLink> lnks = Module.GetInputLinks(this);
            foreach (CGModuleLink l in lnks)
            {
                CGModule mod = Module.Generator.GetModule(l.TargetModuleID, true);
                if (mod)
                {
                    CGModuleOutputSlot slot = mod.OutputByName[l.TargetSlotName];
                    // Sanitize missing links
                    if (!slot.Module.GetOutputLink(slot, this))
                    {
                        slot.Module.OutputLinks.Add(new CGModuleLink(slot, this));
                        slot.ReInitializeLinkedSlots();
                    }

                    if (!mLinkedSlots.Contains(slot))
                        mLinkedSlots.Add(slot);
                }
                else
                {
                    Module.InputLinks.Remove(l);
                }
            }
        }

        public override void UnlinkAll()
        {
            List<CGModuleSlot> ls = new List<CGModuleSlot>(LinkedSlots);
            foreach (CGModuleSlot l in ls)
            {
                UnlinkFrom(l);
            }
        }

        public override void LinkTo(CGModuleSlot outputSlot)
        {
            if (!HasLinkTo(outputSlot))
            {
                LinkInputAndOutput(this, outputSlot);
                base.LinkTo(outputSlot);
            }
        }

        public override void UnlinkFrom(CGModuleSlot outputSlot)
        {
            if (HasLinkTo(outputSlot))
            {
                CGModuleOutputSlot cgModuleOutputSlot = (CGModuleOutputSlot)outputSlot;
                CGModuleLink l1 = Module.GetInputLink(this, cgModuleOutputSlot);
                Module.InputLinks.Remove(l1);
                CGModuleLink l2 = outputSlot.Module.GetOutputLink(cgModuleOutputSlot, this);
                outputSlot.Module.OutputLinks.Remove(l2);

                LinkedSlots.Remove(outputSlot);
                outputSlot.LinkedSlots.Remove(this);

                base.UnlinkFrom(outputSlot);
            }
        }



        /// <summary>
        /// Gets a linked Output slot
        /// </summary>
        public CGModuleOutputSlot SourceSlot(int index = 0)
        {
            return (index < Count && index >= 0) ? (CGModuleOutputSlot)LinkedSlots[index] : null;
        }

        /// <summary>
        /// Determines if a particular output slot of another module can link to this slot
        /// </summary>
        /// <param name="source">the slot of the other module that'd like to link to this input slot</param>
        /// <returns>whether linking is allowed or not</returns>
        public bool CanLinkTo(CGModuleOutputSlot source)
        {
            return source.Module != Module && AreInputAndOutputSlotsCompatible(InputInfo, OnRequestModule != null, source.OutputInfo, source.OnRequestModule != null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="inputSlotInfo"></param>
        /// <param name="inputSlotModuleIsOnRequest">Does the module owning the input slot implement the IOnRequestProcessing interface</param>
        /// <param name="outputSlotInfo"></param>
        /// <param name="outputSlotModuleIsOnRequest">Does the module owning the output slot implement the IOnRequestProcessing interface</param>
        /// <returns></returns>
        public static bool AreInputAndOutputSlotsCompatible(InputSlotInfo inputSlotInfo, bool inputSlotModuleIsOnRequest, OutputSlotInfo outputSlotInfo, bool outputSlotModuleIsOnRequest)
        {
            return inputSlotInfo.IsValidFrom(outputSlotInfo.DataType) &&
                    ((outputSlotModuleIsOnRequest && (inputSlotInfo.RequestDataOnly || inputSlotModuleIsOnRequest)) || (outputSlotModuleIsOnRequest == false && !inputSlotInfo.RequestDataOnly));
        }

        /// <summary>
        /// Gets the module connected to the link
        /// </summary>
        /// <param name="index">the link index</param>
        /// <returns>a module</returns>
        private CGModule SourceModule(int index)
        {
            return (index < Count && index >= 0) ? LinkedSlots[index].Module : null;
        }

        /// <summary>
        /// Gets the data from the module connected to a certain input slot. If more than one module is connected, the first module's data is returned
        /// </summary>
        /// <typeparam name="T">type of requested data</typeparam>
        /// <param name="requests">request parameters</param>
        /// <returns>the data</returns>
        public T GetData<T>(params CGDataRequestParameter[] requests) where T : CGData
        {
            return GetData<T>(out _, requests);
        }

        /// <summary>
        /// Gets the data from the module connected to a certain input slot. If more than one module is connected, the first module's data is returned
        /// </summary>
        /// <typeparam name="T">type of requested data</typeparam>
        /// <param name="isDataDisposable">Whether the returned data can be disposed safely after using it, in order to make its resources available for future use, and thus reducing garbage collection.
        /// It is set to false when returned data is a direct reference to data stored by the module, and not a copy of it
        /// <seealso cref="CGData.Dispose(bool)"/>
        /// <seealso cref="ArrayPool{U}"/>
        /// </param>
        /// <param name="requests">request parameters</param>
        /// <returns>the data</returns>
        public T GetData<T>(out bool isDataDisposable, params CGDataRequestParameter[] requests) where T : CGData
        {
            CGData[] data = GetData<T>(0, out isDataDisposable, requests);
#if UNITY_EDITOR
            LastDataCountINTERNAL = (data == null || data.Length == 0) ? 0 : data.Length;
#endif
            if (data == null || data.Length == 0 || data[0] == null)
            {
                isDataDisposable = false;
                return null;
            }

            return data[0] as T;
        }

        /// <summary>
        /// Gets the data from all modules connected to a certain input slot.
        /// </summary>
        /// <typeparam name="T">type of requested data</typeparam>
        /// <param name="requests">request parameters</param>
        /// <returns>the data</returns>
        public List<T> GetAllData<T>(params CGDataRequestParameter[] requests) where T : CGData
        {
            return GetAllData<T>(out _, requests);
        }

        /// <summary>
        /// Gets the data from all modules connected to a certain input slot.
        /// </summary>
        /// <typeparam name="T">type of requested data</typeparam>
        /// <param name="isDataDisposable">Whether the returned data can be disposed safely after using it, in order to make its resources available for future use, and thus reducing garbage collection.
        /// It is set to false when returned data is a direct reference to data stored by the module, and not a copy of it
        /// <seealso cref="CGData.Dispose(bool)"/>
        /// <seealso cref="ArrayPool{U}"/>
        /// </param>
        /// <param name="requests">request parameters</param>
        /// <returns>the data</returns>
        public List<T> GetAllData<T>(out bool isDataDisposable, params CGDataRequestParameter[] requests) where T : CGData
        {
            isDataDisposable = true;
            List<T> res = new List<T>();
            for (int i = 0; i < Count; i++)
            {
                CGData[] data = GetData<T>(i, out bool isDisposable, requests);
                if (data != null)
                {
                    //If in the returned there are multiple CGData, some needing to be disposed, others not, then we consider that none should be disposed
                    //This means that some data might not be flagged as disposable, which means it will be dispose once Finalize is called. Missed opportunity to instantly reuse its data. Not good for reducing garbage collection
                    isDataDisposable &= isDisposable;
#if CURVY_SANITY_CHECKS
                    //TODO right now there are no graph that I am aware of that can trigger the situation explained above, but in the future, if there are modules that take multiple paths as inputs, one of them can be from Input Path module (isDisposable true) and one from Shape Extrusion (output Volume, which is also a path, isDisposable false)
                    if (isDisposable && isDataDisposable == false)
                        DTLog.LogWarning("[Curvy] A disposable data was treated as not disposable");
#endif
                    if (!Info.Array)
                    {
                        res.Add(data[0] as T);
                        break;
                    }

                    for (int a = 0; a < data.Length; a++)
                        res.Add(data[a] as T);
                }
            }

#if UNITY_EDITOR
            LastDataCountINTERNAL = res.Count;
#endif
            return res;
        }

        /// <summary>
        /// Gets the data from the module connected to a certain input slot
        /// </summary>
        /// <typeparam name="T">type of requested data</typeparam>
        /// <param name="slotIndex">slot index (if the slot supports multiple inputs)</param>
        /// <param name="isDataDisposable">Whether the returned data can be disposed safely after using it, in order to make its resources available for future use, and thus reducing garbage collection.
        /// It is set to false when returned data is a direct reference to data stored by the module, and not a copy of it
        /// <seealso cref="CGData.Dispose(bool)"/>
        /// <seealso cref="ArrayPool{U}"/>
        /// </param>
        /// <param name="requests">request parameters</param>
        /// <returns>the data</returns>
        private CGData[] GetData<T>(int slotIndex, out bool isDataDisposable, params CGDataRequestParameter[] requests
            ) where T : CGData
        {
            CGModuleOutputSlot source = SourceSlot(slotIndex);
            if (source == null || !source.Module.Active)
            {
                isDataDisposable = true;
                return new CGData[0];
            }

            // Handles IOnRequestProcessing modules (i.e. modules that provides data on the fly)
            if (source.Module is IOnRequestProcessing)
            {
                bool needNewData = (source.Data == null || source.Data.Length == 0);
                // Return last data?
                if (!needNewData && source.LastRequestParameters != null && source.LastRequestParameters.Length == requests.Length)
                {
                    for (int i = 0; i < requests.Length; i++)
                        if (!requests[i].Equals(source.LastRequestParameters[i]))
                        {
                            needNewData = true;
                            break;
                        }
                }
                else
                    needNewData = true;

                if (needNewData)
                {
                    source.LastRequestParameters = requests;
#if UNITY_EDITOR || CURVY_DEBUG
                    source.Module.DEBUG_LastUpdateTime = System.DateTime.Now;
                    Module.DEBUG_ExecutionTime.Pause();
                    source.Module.DEBUG_ExecutionTime.Start();
#endif
                    source.Module.UIMessages.Clear();//TODO Find a way to move this line of code inside OnSlotDataRequest
                    source.SetData(((IOnRequestProcessing)source.Module).OnSlotDataRequest(this, source, requests));
#if UNITY_EDITOR || CURVY_DEBUG
                    source.Module.DEBUG_ExecutionTime.Stop();
                    Module.DEBUG_ExecutionTime.Start();
#endif
                }

            }

            bool copyData = InputInfo.ModifiesData || source.Module is IOnRequestProcessing;

            CGData[] result = copyData
                ? cloneData<T>(source.Data)
                : source.Data;

            isDataDisposable = copyData && result != null;

            return result; ;
        }

        private static CGData[] cloneData<T>(CGData[] source) where T : CGData
        {
            T[] d = new T[source.Length];
            for (int i = 0; i < source.Length; i++)
                d[i] = source[i] == null ? null : source[i].Clone<T>();
            return d;
        }

    }

    /// <summary>
    /// Class defining a module's output slot
    /// </summary>
    [System.Serializable]
    public class CGModuleOutputSlot : CGModuleSlot
    {
        public OutputSlotInfo OutputInfo { get { return Info as OutputSlotInfo; } }
        public CGData[] Data = new CGData[0];
        public CGDataRequestParameter[] LastRequestParameters; // used for caching of Virtual Modules

        public CGModuleOutputSlot() : base() { }

        protected override void LoadLinkedSlots()
        {
            if (!Module.Generator.IsInitialized)
                return;
            base.LoadLinkedSlots();
            mLinkedSlots = new List<CGModuleSlot>();
            List<CGModuleLink> lnks = Module.GetOutputLinks(this);
            foreach (CGModuleLink l in lnks)
            {
                CGModule mod = Module.Generator.GetModule(l.TargetModuleID, true);
                if (mod)
                {
                    CGModuleInputSlot slot = mod.InputByName[l.TargetSlotName];

                    // Sanitize missing links
                    if (!slot.Module.GetInputLink(slot, this))
                    {
                        slot.Module.InputLinks.Add(new CGModuleLink(slot, this));
                        slot.ReInitializeLinkedSlots();
                    }

                    if (!mLinkedSlots.Contains(slot))
                        mLinkedSlots.Add(slot);
                }
                else
                {
                    Module.OutputLinks.Remove(l);
                }
            }
        }

        public override void LinkTo(CGModuleSlot inputSlot)
        {
            if (!HasLinkTo(inputSlot))
            {
                LinkInputAndOutput(inputSlot, this);
                base.LinkTo(inputSlot);
            }
        }

        public override void UnlinkFrom(CGModuleSlot inputSlot)
        {
            if (HasLinkTo(inputSlot))
            {
                CGModuleInputSlot cgModuleInputSlot = (CGModuleInputSlot)inputSlot;
                CGModuleLink l1 = Module.GetOutputLink(this, cgModuleInputSlot);
                Module.OutputLinks.Remove(l1);

                CGModuleLink l2 = inputSlot.Module.GetInputLink(cgModuleInputSlot, this);
                inputSlot.Module.InputLinks.Remove(l2);

                LinkedSlots.Remove(inputSlot);
                inputSlot.LinkedSlots.Remove(this);

                base.UnlinkFrom(inputSlot);
            }
        }



        public bool HasData
        {
            get { return Data != null && Data.Length > 0 && Data[0] != null; }
        }

        public void ClearData()
        {
            AssignNewData(new CGData[0]);
        }

        private void AssignNewData(CGData[] newData)
        {
            if (Data == newData)
                return;

            foreach (CGData cgData in Data)
                if (cgData && newData.Contains(cgData) == false)
                    cgData.Dispose();

            Data = newData;
        }

        public void SetData<T>(List<T> newData) where T : CGData
        {
            CGData[] newDataArray;
            if (newData == null)
                newDataArray = new CGData[0];
            else
            {
                if (!Info.Array && newData.Count > 1)
                    Debug.LogWarning("[Curvy] " + Module.GetType().Name + " (" + Info.DisplayName + ") only supports a single data item! Either avoid calculating unnecessary data or define the slot as an array!");
                newDataArray = newData.ToArray();
            }
            AssignNewData(newDataArray);
        }

        public void SetData(params CGData[] newData)
        {
            //TODO why does this not do the same test then the other SetData method, i.e. if (!Info.Array && data.Count > 1)
            AssignNewData((newData == null) ? new CGData[0] : newData);
        }

        public T GetData<T>() where T : CGData
        {
            return (Data.Length == 0) ? null : Data[0] as T;
        }

        public T[] GetAllData<T>() where T : CGData
        {
            return Data as T[];
        }
    }

    /// <summary>
    /// Attribute to define slot properties
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1813:AvoidUnsealedAttributes")]
    [AttributeUsage(AttributeTargets.Field)]
    public class SlotInfo : Attribute, IComparable
    {
        /// <summary>
        /// Defines what type of Array is used
        /// </summary>
        public enum SlotArrayType
        {
            Unknown,
            /// <summary>
            /// An array that behaves like an array code wise and UI wise
            /// </summary>
            Normal,
            /// <summary>
            /// An array that behave like an array code wise, but is displayed as a single instance of CGData UI wise.
            /// This allows for CG modules to send/receive arrays, without giving the user the possibility to link multiple modules to the slot
            /// </summary>
            Hidden
        }

        public readonly Type[] DataTypes;

        /// <summary>
        /// If empty Field's name will be used, with slight modifications
        /// </summary>
        public string Name;

        private string displayName = null;
        /// <summary>
        /// If not null, this string will be used in the UI, while <see cref="Name"/> will be used in the data serialization and slots linking logic
        /// </summary>
        public string DisplayName
        {
            get { return displayName ?? Name; }
            set { displayName = value; }
        }

        public string Tooltip;

        /// <summary>
        /// Whether or not the slot accepts an array of CGData instances or a single instance of it
        /// </summary>
        public bool Array;//DESIGN should be renamed to IsArray

        /// <summary>
        /// When <see cref="Array"/> is true, this value defines what type of Array is used
        /// </summary>
        public SlotArrayType ArrayType = SlotArrayType.Normal;

        protected SlotInfo(string name, params Type[] type)
        {
            DataTypes = type;
            Name = name;
        }
        protected SlotInfo(params Type[] type) : this(null, type) { }

        public int CompareTo(object obj)
        {
            return String.Compare(((SlotInfo)obj).Name, Name, StringComparison.Ordinal);
        }

        //TODO code analysis (CA1036) says that Equal, !=, <, == and > should be defined since IComparable is implemented

    }
    /// <summary>
    /// Attribute to define input sot properties
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public sealed class InputSlotInfo : SlotInfo
    {
        public bool RequestDataOnly = false;
        public bool Optional = false;
        /// <summary>
        /// Whether this data is altered by the module.
        /// If true, the module providing data to this slot will return a copy of its data, and not the original copy, so you can safely modify it.
        /// </summary>
        // DESIGN should this be removed, and ask users to just clone the data when they need to modify it?
        public bool ModifiesData = false;

        public InputSlotInfo(string name, params Type[] type) : base(name, type) { }
        public InputSlotInfo(params Type[] type) : this(null, type) { }

        /// <summary>
        /// Gets whether outType is of same type or a subtype of one of our input types
        /// </summary>
        public bool IsValidFrom(Type outType)
        {
            for (int x = 0; x < DataTypes.Length; x++)
                if (outType == DataTypes[x] || outType.IsSubclassOf(DataTypes[x]))
                    return true;
            return false;
        }
    }

    /// <summary>
    /// Attribute to define output slot properties
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public class OutputSlotInfo : SlotInfo
    {
        public Type DataType
        {
            get
            {
                return DataTypes[0];
            }
        }

        public OutputSlotInfo(Type type) : this(null, type) { }

        public OutputSlotInfo(string name, Type type) : base(name, type) { }
    }

    /// <summary>
    /// An <see cref="OutputSlotInfo"/> preset for modules that output CGShape data. Allows modules to output a <see cref="CGShape"/> that varies along a shape extrusion. See also <see cref="CGDataRequestShapeRasterization"/>
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public class ShapeOutputSlotInfo : OutputSlotInfo
    {
        /// <summary>
        /// Whether this module outputs a <see cref="CGShape"/> that varies along a shape extrusion
        /// </summary>
        public bool OutputsVariableShape = false;

        public ShapeOutputSlotInfo() : this(null) { }
        public ShapeOutputSlotInfo(string name) : base(name, typeof(CGShape)) { }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGModuleSlot.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGResource.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e08f4ad1d0c546b4cab3c0faddd74868
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System.Collections.Generic;
using System.Reflection;
using FluffyUnderware.Curvy.Shapes;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Resource attribute
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public sealed class ResourceLoaderAttribute : System.Attribute
    {
        public readonly string ResourceName;

        public ResourceLoaderAttribute([NotNull] string resName)
        {
            ResourceName = resName;
        }
    }

    /// <summary>
    /// Resource Helper class used by Curvy Generator
    /// </summary>
    public static class CGResourceHandler
    {
        private static readonly Dictionary<string, ICGResourceLoader> Loader = new Dictionary<string, ICGResourceLoader>();

        public static Component CreateResource(CGModule module, [NotNull] string resName, [NotNull] string context)
        {
            if (Loader.Count == 0)
                getLoaders();
            if (Loader.ContainsKey(resName))
            {
                ICGResourceLoader loader = Loader[resName];
                return loader.Create(module, context);
            }
            else
            {
                Debug.LogError("CGResourceHandler: Missing Loader for resource '" + resName + "'");
                return null;
            }

        }

        public static void DestroyResource(CGModule module, [NotNull] string resName, Component obj, [NotNull] string context, bool kill)
        {
            if (Loader.Count == 0)
                getLoaders();
            if (Loader.ContainsKey(resName))
            {
                ICGResourceLoader loader = Loader[resName];
                loader.Destroy(module, obj, context, kill);
            }
            else
                Debug.LogError("CGResourceHandler: Missing Loader for resource '" + resName + "'");
        }

        private static void getLoaders()
        {
#if UNITY_EDITOR
            TypeCache.TypeCollection types = TypeCache.GetTypesDerivedFrom<ICGResourceLoader>();
#else
            Type[] types = TypeExt.GetLoadedTypes();
            Type ICGResourceLoaderType = typeof(ICGResourceLoader);
#endif

            foreach (Type T in types)
            {
#if UNITY_EDITOR == false
                if (ICGResourceLoaderType.IsAssignableFrom(T) && ICGResourceLoaderType != T)
#endif
                {
                    object[] attributes = (object[])T.GetCustomAttributes(typeof(ResourceLoaderAttribute), true);
                    if (attributes.Length > 0)
                    {
                        ICGResourceLoader o = (ICGResourceLoader)System.Activator.CreateInstance(T);
                        if (o != null)
                            Loader.Add(((ResourceLoaderAttribute)attributes[0]).ResourceName, o);
                    }
                    else
                    {
                        DTLog.LogError(String.Format("[Curvy] Could not register resource loader of type {0} because it does not have a ResourceLoader attribute", T.FullName));
                    }
                }
            }
        }
    }

    /// <summary>
    /// Spline resource loader class
    /// </summary>
    [ResourceLoader("Spline")]
    public class CGSplineResourceLoader : ICGResourceLoader
    {
        public Component Create(CGModule cgModule, string context)
        {
            CurvySpline spl = CurvySpline.Create();
            spl.transform.position = Vector3.zero;
            spl.Closed = true;
            spl.Add(new Vector3(0, 0, 0), new Vector3(5, 0, 10), new Vector3(-5, 0, 10));
            return spl;
        }

        public void Destroy(CGModule cgModule, Component obj, string context, bool kill)
        {
            if (obj != null)
                obj.gameObject.Destroy(false, false);//isUndoable is set to false because that's how it was working before. Try make this operation undoable if needed
        }
    }

    /// <summary>
    /// Shape (2D spline) resource loader class
    /// </summary>
    [ResourceLoader("Shape")]
    public class CGShapeResourceLoader : ICGResourceLoader
    {

        public Component Create(CGModule cgModule, string context)
        {
            CurvySpline spl = CurvySpline.Create();
            spl.transform.position = Vector3.zero;
            spl.RestrictTo2D = true;
            spl.Closed = true;
            spl.Orientation = CurvyOrientation.None;
            spl.gameObject.AddComponent<CSCircle>().Refresh();
            return spl;
        }

        public void Destroy(CGModule cgModule, Component obj, string context, bool kill)
        {
            if (obj != null)
                obj.gameObject.Destroy(false, false);//isUndoable is set to false because that's how it was working before. Try make this operation undoable if needed
        }
    }

    /// <summary>
    /// Mesh resource loader class
    /// </summary>
    [ResourceLoader("Mesh")]
    public class CGMeshResourceLoader : ICGResourceLoader
    {
        public Component Create(CGModule cgModule, string context)
        {
            Component cmp = cgModule.Generator.PoolManager.GetComponentPool<CGMeshResource>().Pop();
            return cmp;
        }

        public void Destroy(CGModule cgModule, Component obj, string context, bool kill)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(obj.GetComponent<CGMeshResource>() != null);
#endif
            if (obj != null)
            {
                if (kill)
                {
                    obj.gameObject.Destroy(false, false);
                }
                else
                {
                    obj.StripComponents(typeof(CGMeshResource), typeof(MeshFilter), typeof(MeshRenderer));
                    //OPTIM should we assign null to sharedMesh, so it can be garbage collected? It seems (need deeper investiguation) safe since every time we pop a CGMeshResource from the pool, the following code clears the shared mesh if it exists. And if you put this optim in prod, make sure the retrieval of a CGMeshResource from the pool and its initialization are done in the same atomic operation, and not like now in two separate methods
                    //obj.GetComponent<MeshFilter>().sharedMesh = null;
                    cgModule.Generator.PoolManager.GetComponentPool<CGMeshResource>().Push(obj);
                }
            }
        }
    }

    /// <summary>
    /// GameObject resource loader class
    /// </summary>
    [ResourceLoader("GameObject")]
    public class CGGameObjectResourceLoader : ICGResourceLoader
    {
        public Component Create(CGModule cgModule, string context)
        {
            GameObject go = cgModule.Generator.PoolManager.GetPrefabPool(context).Pop();
            return go ? go.transform : null;
        }

        public void Destroy(CGModule cgModule, Component obj, string context, bool kill)
        {
            if (obj != null)
            {
                if (kill)
                {
                    obj.gameObject.Destroy(false, false);
                }
                else
                {
                    cgModule.Generator.PoolManager.GetPrefabPool(context).Push(obj.gameObject);
                }
            }
        }
    }

    /// <summary>
    /// Collection of GameObject resources
    /// </summary>
    [System.Serializable]
    public class CGGameObjectResourceCollection : ICGResourceCollection
    {
        public List<Transform> Items = new List<Transform>();
        public List<string> PoolNames = new List<string>();

        public int Count
        {
            get
            {
                return Items.Count;
            }
        }

        public Component[] ItemsArray
        {
            get { return Items.ToArray(); }
        }
    }

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGResource.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0ddf8aabfb85e2a40bf54a226d9a16fc
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Curvy Generator Utility class
    /// </summary>
    public static class CGUtility
    {
        /// <summary>
        /// Calculates lightmap UV's
        /// </summary>
        /// <param name="uv">the UV to create UV2 for</param>
        /// <returns>UV2</returns>
        [Obsolete("Method will get remove in next major update. Copy its content if you need it")]
        public static Vector2[] CalculateUV2(Vector2[] uv)
        {
            Vector2[] UV2 = new Vector2[uv.Length];
            CalculateUV2(uv, UV2, uv.Length);
            return UV2;
        }

        /// <summary>
        /// Calculates lightmap UV's. Same as <see cref="CalculateUV2(Vector2[])"/>but without array allocation
        /// </summary>
        /// <param name="uv">the UV to create UV2 for</param>
        /// <param name="uv2">the UV2 array to fill data into</param>
        /// <param name="elementsNumber"> number of array elements to process</param>
        [Obsolete("Method will get remove in next major update. Copy its content if you need it")]
        public static void CalculateUV2(Vector2[] uv, Vector2[] uv2, int elementsNumber)
        {
            float maxU = 0;
            float maxV = 0;
            for (int i = 0; i < elementsNumber; i++)
            {
                maxU = maxU < uv[i].x ? uv[i].x : maxU;
                maxV = maxV < uv[i].y ? uv[i].y : maxV;
            }

            float oneOnMaxU = 1f / maxU;
            float oneOnMaxV = 1f / maxV;
            for (int i1 = 0; i1 < elementsNumber; i1++)
            {
                uv2[i1].x = uv[i1].x * oneOnMaxU;
                uv2[i1].y = uv[i1].y * oneOnMaxV;
            }
        }

        #region ### Rasterization Helpers ###

        /// <summary>
        /// Rasterization Helper class
        /// </summary>
        public static List<ControlPointOption> GetControlPointsWithOptions(CGDataRequestMetaCGOptions options, CurvySpline shape, float startDist, float endDist, bool optimize, out int initialMaterialID, out float initialMaxStep)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(shape.Count > 0);
#endif

            List<ControlPointOption> res = new List<ControlPointOption>();
            initialMaterialID = 0;
            initialMaxStep = float.MaxValue;
            CurvySplineSegment startSeg = shape.DistanceToSegment(startDist);

            CurvySplineSegment finishSeg;
            {
                float clampedEndDist;
                {
                    clampedEndDist = shape.ClampDistance(endDist, shape.Closed ? CurvyClamping.Loop : CurvyClamping.Clamp);
                    if (clampedEndDist == 0)
                        clampedEndDist = endDist;
                }
                finishSeg = (clampedEndDist == shape.Length) ? shape.LastVisibleControlPoint : shape.DistanceToSegment(clampedEndDist);
                if (endDist != shape.Length && endDist > finishSeg.Distance)
                {
                    finishSeg = shape.GetNextControlPoint(finishSeg);
                }
            }

            MetaCGOptions cgOptions;
            float loopOffset = 0;
            if (startSeg)
            {
                cgOptions = startSeg.GetMetadata<MetaCGOptions>(true);
                initialMaxStep = (cgOptions.MaxStepDistance == 0) ? float.MaxValue : cgOptions.MaxStepDistance;
                initialMaterialID = cgOptions.MaterialID;
                int currentMaterialID = initialMaterialID;

                float maxDist = cgOptions.MaxStepDistance;
                /*
                if ((options.CheckMaterialID && cgOptions.MaterialID != 0) ||
                       (optimize && cgOptions.MaxStepDistance != 0))
                    res.Add(new ControlPointOption(startSeg.LocalFToTF(0),
                                                   startSeg.Distance,
                                                   true,
                                                   cgOptions.MaterialID,
                                                   options.CheckHardEdges && cgOptions.HardEdge,
                                                   initialMaxStep,
                                                   (options.CheckExtendedUV && cgOptions.UVEdge),
                                                   options.CheckExtendedUV && cgOptions.ExplicitU,
                                                   cgOptions.FirstU,
                                                   cgOptions.SecondU));
                */


                CurvySplineSegment seg = shape.GetNextSegment(startSeg) ?? shape.GetNextControlPoint(startSeg);
                do
                {
                    cgOptions = seg.GetMetadata<MetaCGOptions>(true);
                    if (shape.GetControlPointIndex(seg) < shape.GetControlPointIndex(startSeg))
                        loopOffset = shape.Length;
                    if (options.IncludeControlPoints ||
                       cgOptions.CorrectedHardEdge ||
                       cgOptions.MaterialID != currentMaterialID ||
                       optimize && cgOptions.MaxStepDistance != maxDist ||
                       (cgOptions.CorrectedUVEdge || cgOptions.ExplicitU)
                        )
                    {
                        maxDist = (cgOptions.MaxStepDistance == 0) ? float.MaxValue : cgOptions.MaxStepDistance;
                        currentMaterialID = cgOptions.MaterialID;
                        res.Add(new ControlPointOption(seg.TF + Mathf.FloorToInt(loopOffset / shape.Length),
                                                       seg.Distance + loopOffset,
                                                       options.IncludeControlPoints,
                                                       currentMaterialID,
                                                        cgOptions.CorrectedHardEdge,
                                                       cgOptions.MaxStepDistance,
                                                       cgOptions.CorrectedUVEdge,
                                                       cgOptions.ExplicitU,
                                                       cgOptions.FirstU,
                                                       cgOptions.SecondU));

                    }
                    seg = shape.GetNextSegment(seg);
                } while (seg && seg != finishSeg);
                // Check UV settings of last cp (not a segment if open spline!)
                if (!seg && shape.LastVisibleControlPoint == finishSeg)
                {
                    cgOptions = finishSeg.GetMetadata<MetaCGOptions>(true);
                    if (cgOptions.ExplicitU)
                        res.Add(new ControlPointOption(1,
                            finishSeg.Distance + loopOffset,
                            options.IncludeControlPoints,
                            currentMaterialID,
                            cgOptions.CorrectedHardEdge,
                            cgOptions.MaxStepDistance,
                            cgOptions.CorrectedUVEdge,
                            cgOptions.ExplicitU,
                            cgOptions.FirstU,
                            cgOptions.SecondU));
                }
            }

            return res;
        }

        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CGUtility.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CurvyGenerator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 92f936dd5124460479f65d72577c8d9e
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using UnityEngine.SceneManagement;
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.Experimental.SceneManagement;
using UnityEditor.SceneManagement;
#endif


namespace FluffyUnderware.Curvy.Generator
{
    /// <summary>
    /// Curvy Generator component
    /// </summary>
    [ExecuteAlways]
    [HelpURL(CurvySpline.DOCLINK + "generator")]
    [AddComponentMenu("Curvy/Generator")]
    [RequireComponent(typeof(PoolManager))]
    public class CurvyGenerator : DTVersionedMonoBehaviour
    {

        #region ### Serialized Fields ###

        [Tooltip("Show Debug Output?")]
        [SerializeField]
        private bool m_ShowDebug;

        [Tooltip("Whether to automatically refresh the generator's output when necessary")]
        [SerializeField]
        private bool m_AutoRefresh = true;

        [FieldCondition(nameof(m_AutoRefresh), true)]
        [Positive(Tooltip = "The minimum delay between two automatic generator's refreshing while in Play mode, in milliseconds")]
        [SerializeField]
        private int m_RefreshDelay = 0;

        [FieldCondition(nameof(m_AutoRefresh), true)]
        [Positive(Tooltip = "The minimum delay between two automatic generator's refreshing while in Edit mode, in milliseconds")]
        [SerializeField]
        private int m_RefreshDelayEditor = 10;

        /*! \cond PRIVATE */

        [Section("Events", false, false, 1000, HelpURL = CurvySpline.DOCLINK + "generator_events")]
        [SerializeField]
        protected CurvyCGEvent m_OnRefresh = new CurvyCGEvent();

        /*! \endcond */

#if UNITY_EDITOR
        [Section("Advanced Settings", Sort = 2000, HelpURL = CurvySpline.DOCLINK + "generator_events", Expanded = false)]
        [Label(Tooltip = "Force this script to update in Edit mode as often as in Play mode. Most users don't need that.")]
        [SerializeField]
        private bool m_ForceFrequentUpdates;
#endif

        /// <summary>
        /// List of modules this Generator contains
        /// </summary>
        [HideInInspector]
        public List<CGModule> Modules = new List<CGModule>();

        [SerializeField, HideInInspector]
        internal int m_LastModuleID;

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Gets or sets whether to show debug outputs
        /// </summary>
        public bool ShowDebug
        {
            get { return m_ShowDebug; }
            set
            {
                if (m_ShowDebug != value)
                    m_ShowDebug = value;
            }
        }
        /// <summary>
        /// Gets or sets whether to automatically call <see cref="Refresh"/> if necessary
        /// </summary>
        public bool AutoRefresh
        {
            get { return m_AutoRefresh; }
            set
            {
                if (m_AutoRefresh != value)
                    m_AutoRefresh = value;
            }
        }
        /// <summary>
        /// Gets or sets the minimum delay between two consecutive calls to <see cref="Refresh"></see> while playing, expressed in milliseconds
        /// </summary>
        public int RefreshDelay
        {
            get { return m_RefreshDelay; }
            set
            {
                int v = Mathf.Max(0, value);
                if (m_RefreshDelay != v)
                    m_RefreshDelay = v;
            }
        }
        /// <summary>
        /// Gets or sets the minimum delay between two consecutive calls to <see cref="Refresh"></see> in the editor
        /// </summary>
        public int RefreshDelayEditor
        {
            get { return m_RefreshDelayEditor; }
            set
            {
                int v = Mathf.Max(0, value);
                if (m_RefreshDelayEditor != v)
                    m_RefreshDelayEditor = v;
            }
        }

#if UNITY_EDITOR
        /// <summary>
        /// By default Unity calls scripts' update less frequently in Edit mode. ForceFrequentUpdates forces this script to update in Edit mode as often as in Play mode. Most users don't need that.
        /// </summary>
        public bool ForceFrequentUpdates
        {
            get { return m_ForceFrequentUpdates; }
            set { m_ForceFrequentUpdates = value; }
        }
#endif

        /// <summary>
        /// Gets the PoolManager
        /// </summary>
        public PoolManager PoolManager
        {
            get
            {
                if (mPoolManager == null)
                    mPoolManager = GetComponent<PoolManager>();
                return mPoolManager;
            }
        }

        /// <summary>
        /// Event raised after refreshing the Generator
        /// </summary>
        public CurvyCGEvent OnRefresh
        {
            get { return m_OnRefresh; }
            set
            {
                if (m_OnRefresh != value)
                    m_OnRefresh = value;

            }
        }

        /// <summary>
        /// Gets whether the generator and all its dependencies are fully initialized
        /// </summary>
        public bool IsInitialized { get { return mInitialized; } }
        /// <summary>
        /// Gets whether the Generator is about to get destroyed
        /// </summary>
        public bool Destroying { get; private set; }

        /// <summary>
        /// Dictionary to get a module by it's ID
        /// </summary>
        public Dictionary<int, CGModule> ModulesByID = new Dictionary<int, CGModule>();

        #endregion

        #region ### Private Fields ###

        private bool mInitialized;
        private bool mInitializedPhaseOne;
        private bool mNeedSort = true;
        private double mLastUpdateTime;
        private PoolManager mPoolManager;

#if UNITY_EDITOR || CURVY_DEBUG
        // Debugging:
        public TimeMeasure DEBUG_ExecutionTime = new TimeMeasure(5);
#endif
#if UNITY_EDITOR
        // Refresh-Handling
        private double mLastEditorUpdateTime;

#endif

        /// <summary>
        /// Used in the modules reordering logic. Value's unit is pixels.
        /// </summary>
        private const int ModulesReorderingDeltaX = 50;
        /// <summary>
        /// Used in the modules reordering logic. Value's unit is pixels.
        /// </summary>
        private const int ModulesReorderingDeltaY = 20;

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        private void OnEnable()
        {
            PoolManager.AutoCreatePools = true;
#if UNITY_EDITOR
            EditorApplication.update += editorUpdate;
            if (!Application.isPlaying)
            {
                UnityEditorInternal.ComponentUtility.MoveComponentUp(this);
            }
#endif
        }

        private void OnDisable()
        {
            mInitialized = false;
            mInitializedPhaseOne = false;
            mNeedSort = true;
#if UNITY_EDITOR
            EditorApplication.update -= editorUpdate;
#endif
        }


        private void OnDestroy()
        {
            Destroying = true;
        }

#if UNITY_EDITOR
        private void editorUpdate()
        {
            if (AutoRefresh && Application.isPlaying == false)
            {
                if (ForceFrequentUpdates)
                    EditorApplication.QueuePlayerLoopUpdate();
                else
                    Update();
            }
        }
#endif

        private void Update()
        {
            if (!IsInitialized)
                Initialize();
            else
                TryAutoRefresh();
        }


        /*! \endcond */
        #endregion

        #region ### Public Static Methods ###

        /// <summary>
        /// Creates a new GameObject with a CurvyGenerator attached
        /// </summary>
        /// <returns>the Generator component</returns>
        public static CurvyGenerator Create()
        {
            GameObject go = new GameObject("Curvy Generator", typeof(CurvyGenerator));
            return go.GetComponent<CurvyGenerator>();
        }

        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Adds a Module
        /// </summary>
        /// <typeparam name="T">type of the Module</typeparam>
        /// <returns>the new Module</returns>
        public T AddModule<T>() where T : CGModule
        {
            return (T)AddModule(typeof(T));
        }
        /// <summary>
        /// Adds a Module
        /// </summary>
        /// <param name="type">type of the Module</param>
        /// <returns>the new Module</returns>
        public CGModule AddModule(System.Type type)
        {
            GameObject go = new GameObject("");
            go.transform.SetParent(transform, false);
            CGModule mod = (CGModule)go.AddComponent(type);
            mod.SetUniqueIdINTERNAL();
            Modules.Add(mod);
            ModulesByID.Add(mod.UniqueID, mod);
            return mod;
        }

        /// <summary>
        /// Auto-Arrange modules' graph canvas position
        /// In other words, this alligns the graph with the top left corner of the canvas. This does not modify the modules position relatively to each other
        /// </summary>
        public void ArrangeModules()
        {
            Vector2 min = new Vector2(float.MaxValue, float.MaxValue);
            foreach (CGModule mod in Modules)
            {
                min.x = Mathf.Min(mod.Properties.Dimensions.x, min.x);
                min.y = Mathf.Min(mod.Properties.Dimensions.y, min.y);
            }
            min -= new Vector2(10, 10);
            foreach (CGModule mod in Modules)
            {
                mod.Properties.Dimensions.x -= min.x;
                mod.Properties.Dimensions.y -= min.y;
            }
        }

        /// <summary>
        /// Changes the modules' positions to make the graph easier to read.
        /// </summary>
        public void ReorderModules()
        {
            Dictionary<CGModule, Rect> initialModulesPositions;
            {
                initialModulesPositions = new Dictionary<CGModule, Rect>(Modules.Count);
                foreach (CGModule cgModule in Modules)
                    initialModulesPositions[cgModule] = cgModule.Properties.Dimensions;
            }


            List<CGModule> endpointModules = Modules.Where(m => m.OutputLinks.Any() == false).ToList();


            //A dictionary that gives for each module the set of all the modules that are connected to its inputs, whether directly or indirectly
            Dictionary<CGModule, HashSet<CGModule>> modulesRecursiveInputs = new Dictionary<CGModule, HashSet<CGModule>>(Modules.Count);
            foreach (CGModule module in endpointModules)
                UpdateModulesRecursiveInputs(modulesRecursiveInputs, module);

            HashSet<int> reordredModuleIds = new HashSet<int>();
            for (int index = 0; index < endpointModules.Count; index++)
            {
                float endPointY = index == 0
                    ? 0
                    //Draw under the previous endpoint recursive inputs
                    : modulesRecursiveInputs[endpointModules[index - 1]].Max(m => m.Properties.Dimensions.yMax) + ModulesReorderingDeltaY;

                CGModule endpointModule = endpointModules[index];
                //Set the endpoint's position
                endpointModule.Properties.Dimensions.position = new Vector2(0, endPointY);
                reordredModuleIds.Add(endpointModule.UniqueID);
                //And then its children's positions, recursively
                ReorderEndpointRecursiveInputs(endpointModule, reordredModuleIds, modulesRecursiveInputs);
            }

            ArrangeModules();
#if UNITY_EDITOR
            if (Application.isPlaying == false)
                //Dirty scene if something changed
                if (Modules.Exists(m => m.Properties.Dimensions != initialModulesPositions[m]))
                    EditorSceneManager.MarkSceneDirty(SceneManager.GetActiveScene());
#endif
        }



        /// <summary>
        /// Clears the whole generator
        /// </summary>
        public void Clear()
        {
            //BUG when a module is a child of another one, destroying the first destroys the second, which lead to unwanted behavior in this loop

            bool isInEditMode = DTUtility.IsInEditMode;
            if (isInEditMode)
            {
#if UNITY_EDITOR
                bool skipAllMessages = false;

                for (int i = Modules.Count - 1; i >= 0; i--)
                {
                    CGModule module = Modules[i];
                    GameObject moduleGO = module.gameObject;

                    if (DTUtility.DoesPrefabStatusAllowDeletion(moduleGO, out string errorMessage))
                    {
                        if (moduleGO.Destroy(true, false) == false)
                            Debug.LogError("Could not destroy a CG module. This is not expected. Please send a bug report.");
                    }
                    else
                    {
                        if (skipAllMessages == false)
                            skipAllMessages = false == EditorUtility.DisplayDialog($"Cannot delete Game Object '{moduleGO.name}'", errorMessage, "Ok", "Skip All");
                    }
                }

                //Destroyed modules are not removed manually from Modules and ModulesByID because in edit mode, game objects are destroyed immediatly after the Destroy call, which leads to the OnDestroy being called, which removes the destroyed module from Modules and ModulesByID. In play mode, the game objects are destroyed at the frame's end, thus the need to clear Modules and ModulesByID in this method
                if (Modules.Count == 0)
                    m_LastModuleID = 0;
#endif
            }
            else
            {
                for (int i = Modules.Count - 1; i >= 0; i--)
                    if (Modules[i].gameObject.Destroy(true, false) == false)
                        Debug.LogError("Could not destroy a CG module. This is not expected. Please send a bug report.");

                Modules.Clear();
                ModulesByID.Clear();
                m_LastModuleID = 0;
            }
        }

        /// <summary>
        /// Deletes a module (same as PCGModule.Delete())
        /// </summary>
        /// <param name="module">a module</param>
        public void DeleteModule(CGModule module)
        {
            if (module)
                module.Delete();
        }

        /// <summary>
        /// Find modules of a given type
        /// </summary>
        /// <typeparam name="T">the module type</typeparam>
        /// <returns>a list of zero or more modules</returns>
        [Obsolete("Use the overload that has a mandatory includeOnRequestProcessing parameter")]
        public List<T> FindModules<T>() where T : CGModule => FindModules<T>(false);

        /// <summary>
        /// Find modules of a given type
        /// </summary>
        /// <typeparam name="T">the module type</typeparam>
        /// <param name="includeOnRequestProcessing">whether to include IOnRequestProcessing modules</param>
        /// <returns>a list of zero or more modules</returns>
        public List<T> FindModules<T>(bool includeOnRequestProcessing) where T : CGModule
        {
            List<T> res = new List<T>();
            for (int i = 0; i < Modules.Count; i++)
                if (Modules[i] is T && (includeOnRequestProcessing || !(Modules[i] is IOnRequestProcessing)))
                    res.Add((T)Modules[i]);
            return res;
        }

        /// <summary>
        /// Gets a list of modules, either including or excluding IOnRequestProcessing modules
        /// </summary>
        /// <returns>a list of zero or more modules</returns>
        [Obsolete("Use the overload that has a mandatory includeOnRequestProcessing parameter")]
        public List<CGModule> GetModules() => GetModules(false);

        /// <summary>
        /// Gets a list of modules, either including or excluding IOnRequestProcessing modules
        /// </summary>
        /// <param name="includeOnRequestProcessing">whether to include IOnRequestProcessing modules</param>
        public List<CGModule> GetModules(bool includeOnRequestProcessing)
        {

            if (includeOnRequestProcessing)
                return new List<CGModule>(Modules);
            else
            {
                List<CGModule> res = new List<CGModule>();
                for (int i = 0; i < Modules.Count; i++)
                    if (!(Modules[i] is IOnRequestProcessing))
                        res.Add(Modules[i]);
                return res;
            }
        }

        /// <summary>
        /// Gets a module by ID, either including or excluding IOnRequestProcessing modules
        /// </summary>
        /// <param name="moduleID">the ID of the module in question</param>
        [Obsolete("Use the overload that has a mandatory includeOnRequestProcessing parameter")]
        public CGModule GetModule(int moduleID) => GetModule(moduleID, false);

        /// <summary>
        /// Gets a module by ID, either including or excluding IOnRequestProcessing modules
        /// </summary>
        /// <param name="moduleID">the ID of the module in question</param>
        /// <param name="includeOnRequestProcessing">whether to include IOnRequestProcessing modules</param>
        public CGModule GetModule(int moduleID, bool includeOnRequestProcessing)
        {
            CGModule res;
            if (ModulesByID.TryGetValue(moduleID, out res) && (includeOnRequestProcessing || !(res is IOnRequestProcessing)))
                return res;
            else
                return null;
        }

        /// <summary>
        /// Gets a module by ID, either including or excluding IOnRequestProcessing modules (Generic version)
        /// </summary>
        /// <typeparam name="T">type of the module</typeparam>
        /// <param name="moduleID">the ID of the module in question</param>
        [Obsolete("Use the overload that has a mandatory includeOnRequestProcessing parameter")]
        public T GetModule<T>(int moduleID) where T : CGModule => GetModule<T>(moduleID, false);

        /// <summary>
        /// Gets a module by ID, either including or excluding IOnRequestProcessing modules (Generic version)
        /// </summary>
        /// <typeparam name="T">type of the module</typeparam>
        /// <param name="moduleID">the ID of the module in question</param>
        /// <param name="includeOnRequestProcessing">whether to include IOnRequestProcessing modules</param>
        public T GetModule<T>(int moduleID, bool includeOnRequestProcessing) where T : CGModule
        {
            return GetModule(moduleID, includeOnRequestProcessing) as T;
        }

        /// <summary>
        /// Gets a module by name, either including or excluding IOnRequestProcessing modules 
        /// </summary>
        /// <param name="moduleName"></param>
        [Obsolete("Use the overload that has a mandatory includeOnRequestProcessing parameter")]
        public CGModule GetModule(string moduleName) => GetModule(moduleName, false);

        /// <summary>
        /// Gets a module by name, either including or excluding IOnRequestProcessing modules 
        /// </summary>
        /// <param name="moduleName"></param>
        /// <param name="includeOnRequestProcessing"></param>
        public CGModule GetModule(string moduleName, bool includeOnRequestProcessing)
        {
            for (int i = 0; i < Modules.Count; i++)
                if (Modules[i].ModuleName.Equals(moduleName, System.StringComparison.CurrentCultureIgnoreCase) && (includeOnRequestProcessing || !(Modules[i] is IOnRequestProcessing)))
                    return Modules[i];

            return null;
        }

        /// <summary>
        /// Gets a module by name, either including or excluding IOnRequestProcessing modules (Generic version)
        /// </summary>
        /// <typeparam name="T">type of the module</typeparam>
        /// <param name="moduleName">the ID of the module in question</param>
        [Obsolete("Use the overload that has a mandatory includeOnRequestProcessing parameter")]
        public T GetModule<T>(string moduleName) where T : CGModule => GetModule<
            T>(moduleName, false);

        /// <summary>
        /// Gets a module by name, either including or excluding IOnRequestProcessing modules (Generic version)
        /// </summary>
        /// <typeparam name="T">type of the module</typeparam>
        /// <param name="moduleName">the ID of the module in question</param>
        /// <param name="includeOnRequestProcessing">whether to include IOnRequestProcessing modules</param>
        public T GetModule<T>(string moduleName, bool includeOnRequestProcessing) where T : CGModule
        {
            return GetModule(moduleName, includeOnRequestProcessing) as T;
        }

        /// <summary>
        /// Gets a module's output slot by module ID and slotName
        /// </summary>
        /// <param name="moduleId">Id of the module</param>
        /// <param name="slotName">Name of the slot</param>
        public CGModuleOutputSlot GetModuleOutputSlot(int moduleId, string slotName)
        {
            CGModule mod = GetModule(moduleId, true);
            if (mod)
                return mod.GetOutputSlot(slotName);
            else
                return null;
        }

        /// <summary>
        /// Gets a module's output slot by module name and slotName
        /// </summary>
        /// <param name="moduleName">Name of the module</param>
        /// <param name="slotName">Name of the slot</param>
        public CGModuleOutputSlot GetModuleOutputSlot(string moduleName, string slotName)
        {
            CGModule mod = GetModule(moduleName, true);
            if (mod)
                return mod.GetOutputSlot(slotName);
            else
                return null;
        }

        //TODO initialize earlier
        /// <summary>
        /// Initializes the Generator
        /// </summary>
        /// <param name="force">true to force reinitialization</param>
        public void Initialize(bool force = false)
        {
            if (this == null)//Modifying a prefab of a shape extrusion generator (removing its input spline then adding it back again) the updated of the generator gets called with a null generator. Probably due to the refreshing of the prefab file (to remove generated mesh)
                return;

            if (!mInitializedPhaseOne || force)
            {
                // Read modules
                ModulesByID.Clear();

                Modules.Clear();
                GetComponentsInChildren(Modules);
                //Not all modules are part of this generator. This happens for example if a generator creates GameObjects that are generators themselves
                Modules.RemoveAll(m => m.transform.parent != this.transform);

                for (int i = 0; i < Modules.Count; i++)
                {
                    if (!Modules[i].IsInitialized || force)
                        Modules[i].Initialize();

                    if (ModulesByID.ContainsKey(Modules[i].UniqueID))
                    {
                        Debug.LogError("ID of '" + Modules[i].ModuleName + "' isn't unique!");
                        return;
                    }
                    ModulesByID.Add(Modules[i].UniqueID, Modules[i]);
                }

                if (Modules.Count > 0)
                {
                    // Sort them
                    sortModulesINTERNAL();
                }
                mInitializedPhaseOne = true;
            }
            for (int m = 0; m < Modules.Count; m++)
                if (Modules[m] is IExternalInput && !Modules[m].IsInitialized)
                    return;

            mInitialized = true;
            mInitializedPhaseOne = false;
            mNeedSort = mNeedSort || force;
            Refresh(true);
        }

        /// <summary>
        /// Refreshes the Generator
        /// </summary>
        /// <param name="forceUpdate">true to force a refresh of all modules</param>
        public void Refresh(bool forceUpdate = false)
        {
            if (!IsInitialized)
                return;

            if (mNeedSort)
                //BUG this does not sort modules correctly
                doSortModules();//This is supposed to sort a module in a way that for each module, all its input modules are set in the modules list (which defines the updating order) before the said module

            CGModule firstChanged = null;

            for (int i = 0; i < Modules.Count; i++)
            {
                if (forceUpdate && Modules[i] is IOnRequestProcessing)
                    Modules[i].Dirty = true; // Dirty state will be resetted to false, but last data will be deleted - forcing a recalculation
                if (!(Modules[i] is INoProcessing) // ignore INoProcessing modules
                    && (Modules[i].Dirty // update dirty modules
                        || (forceUpdate && !(Modules[i] is IOnRequestProcessing)))) //update non dirty modules when forceUpdate is true, except IOnRequestProcessing modules, which by the way are never dirty, because the Dirty setter handles them differently, which I think is bad design, but this is not a major issue
                {
                    Modules[i].checkOnStateChangedINTERNAL();//BUG? this can set dirty to true, so shouldn't it be called before checking the value of Dirty earlier in this method?
                    if (Modules[i].IsInitialized && Modules[i].IsConfigured)
                    {

                        if (firstChanged == null)
                        {
#if UNITY_EDITOR || CURVY_DEBUG
                            DEBUG_ExecutionTime.Start();
#endif
                            firstChanged = Modules[i];
                        }

                        //OPTIM? remove this check, or make its compilation conditional
                        foreach (CGModuleInputSlot inputSlot in Modules[i].Input)
                        {
                            foreach (CGModuleSlot linkedSlot in inputSlot.LinkedSlots)
                                if (linkedSlot.Module.IsConfigured && linkedSlot.Module.Dirty)
                                    DTLog.LogError("[Curvy] Getting data from a dirty module. This shouldn't happen at all. Please raise a bug report. Source module is " + linkedSlot.Module, this);
                        }

                        Modules[i].doRefresh();
                    }
                }
            }
            if (firstChanged != null)
            {
#if UNITY_EDITOR
                DEBUG_ExecutionTime.Stop();
#endif
                OnRefreshEvent(new CurvyCGEventArgs(this, firstChanged));
            }
        }

        /// <summary>
        /// Will try to auto refresh the generator. Basically this calls <see cref="Refresh"/> if <see cref="AutoRefresh"/> is set and the refresh delays are respected
        /// </summary>
        public void TryAutoRefresh()
        {
            if (AutoRefresh)
            {
                double realtimeSinceStartup =
#if UNITY_2020_2_OR_NEWER
                    Time.realtimeSinceStartupAsDouble;
#else
                    Time.realtimeSinceStartup;
#endif

                float refreshDelayInSeconds = RefreshDelay * 0.001f;
                float refreshDelayEditorInSeconds = RefreshDelayEditor * 0.001f;

#if UNITY_EDITOR
                if (mLastEditorUpdateTime > realtimeSinceStartup)
                {
#if CURVY_SANITY_CHECKS
                    DTLog.LogWarning($"[Curvy] Curvy Generator: Auto Refresh timestamp is too big: mLastEditorUpdateTime {mLastEditorUpdateTime} realtimeSinceStartup {realtimeSinceStartup}", this);
#endif
                    mLastEditorUpdateTime = realtimeSinceStartup - refreshDelayEditorInSeconds;
                }
#endif

                if (mLastUpdateTime > realtimeSinceStartup)
                {
#if CURVY_SANITY_CHECKS
                    DTLog.LogWarning($"[Curvy] Curvy Generator: Auto Refresh timestamp is too big: mLastUpdateTime {mLastUpdateTime} realtimeSinceStartup {realtimeSinceStartup}", this);
#endif

                    mLastUpdateTime = realtimeSinceStartup - refreshDelayInSeconds;
                }

                if (Application.isPlaying)
                {
                    if (realtimeSinceStartup - mLastUpdateTime > refreshDelayInSeconds)
                    {
                        mLastUpdateTime = realtimeSinceStartup;
                        Refresh();
                    }
                }
#if UNITY_EDITOR
                else
                {
                    if (realtimeSinceStartup - mLastEditorUpdateTime > refreshDelayEditorInSeconds)
                    {
                        mLastEditorUpdateTime = realtimeSinceStartup;
                        Refresh();
                    }
                }
#endif
            }
        }

        /// <summary>
        /// Delete all the managed resources acting as an output. One example of this are the generated meshes by the <see cref="FluffyUnderware.Curvy.Generator.Modules.CreateMesh"/> module
        /// </summary>
        /// <param name="associatedPrefabWasModified">Is true if an associated prefab was modified to deleted the output resources from it too</param>
        /// <remarks>Due to how the prefab system works, this method has to delete output from associated prefab assets too</remarks>
        /// <returns>True if there were deleted resources</returns>
        public bool DeleteAllOutputManagedResources(out bool associatedPrefabWasModified)
        {
#if UNITY_EDITOR
            if (DTUtility.DoesPrefabStatusAllowDeletion(gameObject, out _) == false)
                associatedPrefabWasModified = DeleteAllOutputManagedResourcesFromAssociatedPrefab();
            else
                associatedPrefabWasModified = false;
#else
            associatedPrefabWasModified = false;
#endif

            bool result = false;
            foreach (CGModule module in Modules)
                result |= module.DeleteAllOutputManagedResources();
            return result;
        }

        #endregion

        #region ### Protected Members ###

        protected CurvyCGEventArgs OnRefreshEvent(CurvyCGEventArgs e)
        {
            if (OnRefresh != null)
                OnRefresh.Invoke(e);
            return e;
        }

        #endregion

        #region ### Privates and Internals ###
        /*! \cond PRIVATE */

#if UNITY_EDITOR
        static CurvyGenerator()
        {
            EditorSceneManager.sceneSaving += OnSceneSaving;
        }

        private static void OnSceneSaving(Scene scene, string path)
        {
            if (CurvyGlobalManager.SaveGeneratorOutputs)
                return;

            //clear all output GOs to avoid saving them.
            foreach (CurvyGenerator generator in FindObjectsOfType<CurvyGenerator>())
                //only if the generator is supposed to refresh automatically, otherwise the users might not expect their generator to update
                if (generator.isActiveAndEnabled && generator.AutoRefresh)
                    foreach (CGModule module in generator.Modules)
                        if (module.DeleteAllOutputManagedResources())
                            module.Dirty = true;//to force update once saving is done
        }
#endif

        /// <summary>
        /// Ensures a module name is unique
        /// </summary>
        /// <param name="name">desired name</param>
        /// <returns>unique name</returns>
        public string getUniqueModuleNameINTERNAL(string name)
        {
            string newName = name;
            bool isUnique;
            int c = 1;
            do
            {
                isUnique = true;
                foreach (CGModule mod in Modules)
                {
                    if (mod.ModuleName.Equals(newName, System.StringComparison.CurrentCultureIgnoreCase))
                    {
                        newName = name + (c++).ToString(System.Globalization.CultureInfo.InvariantCulture);
                        isUnique = false;
                        break;
                    }
                }

            } while (!isUnique);
            return newName;
        }


        /// <summary>
        /// INTERNAL! Don't call this by yourself! 
        /// </summary>
        internal void sortModulesINTERNAL()
        {
            mNeedSort = true;
        }

        private bool doSortModules()
        {
            //DESIGN OPTIM: CGModule has members that are needed only in this method, and are confusing outside of this contexte, so inline everyting here and get rid of these members
            List<CGModule> unsorted = new List<CGModule>(Modules);

            List<CGModule> noAncestor = new List<CGModule>();
            List<CGModule> needNoSort = new List<CGModule>();


            // initialize
            for (int m = unsorted.Count - 1; m >= 0; m--)
            {
                unsorted[m].initializeSort();
                if (unsorted[m] is INoProcessing)
                {
                    needNoSort.Add(unsorted[m]);
                    unsorted.RemoveAt(m);
                }
                else if (unsorted[m].SortAncestors == 0)
                {
                    noAncestor.Add(unsorted[m]);
                    unsorted.RemoveAt(m);
                }
            }

            noAncestor.Sort((a, b) => a.UniqueID.CompareTo(b.UniqueID));

            Modules.Clear();

            // Sort
            int index = 0;
            while (noAncestor.Count > 0)
            {
                // get a module without ancestors
                CGModule mod = noAncestor[0];
                noAncestor.RemoveAt(0);
                // decrement child ancestors and fetch childs without ancestors
                List<CGModule> newModsWithoutAncestors = mod.decrementChilds();
                // Add them to noAncestor list
                noAncestor.AddRange(newModsWithoutAncestors);
                // and remove from unsorted
                for (int i = 0; i < newModsWithoutAncestors.Count; i++)
                    unsorted.Remove(newModsWithoutAncestors[i]);
                // add current module to sorted
                Modules.Add(mod);
                mod.transform.SetSiblingIndex(index++);
            }

            // These modules got errors!
            for (int circ = 0; circ < unsorted.Count; circ++)
                unsorted[circ].CircularReferenceError = true;

            //Debug.Log("====: NeedNoSort=" + needNoSort.Count + ", Unsorted=" + unsorted.Count);
            //foreach (var m in Modules)
            //    Debug.Log("Sort: " + m.ModuleName);

            Modules.AddRange(unsorted);
            Modules.AddRange(needNoSort);



            mNeedSort = false;
            return (unsorted.Count > 0);
        }

        /// <summary>
        /// Sets the position of an endpoint module's recursive inputs in a way that makes the graph easy to read
        /// </summary>
        /// <param name="endPoint">The module which recursive inputs are to be reordred</param>
        /// <param name="reordredModuleIds">Set of modules already reordred</param>
        /// <param name="modulesRecursiveInputs"> A dictionary that gives for each module the set of all the modules that are connected to its inputs, whether directly or indirectly</param>
        static private void ReorderEndpointRecursiveInputs(CGModule endPoint, HashSet<int> reordredModuleIds, Dictionary<CGModule, HashSet<CGModule>> modulesRecursiveInputs)
        {
            float nextInputEndingX = endPoint.Properties.Dimensions.xMin - ModulesReorderingDeltaX;
            float nextInputStartingY = endPoint.Properties.Dimensions.yMin;

            List<CGModule> inputModules = endPoint.Input.SelectMany(i => i.GetLinkedModules()).ToList();
            foreach (CGModule inputModule in inputModules)
            {
                float inputModuleXPosition = nextInputEndingX - inputModule.Properties.Dimensions.width;
                //If module is processed for the first time, process it normally ...
                if (reordredModuleIds.Contains(inputModule.UniqueID) == false)
                {
                    inputModule.Properties.Dimensions.position = new Vector2(inputModuleXPosition, nextInputStartingY);
                    reordredModuleIds.Add(inputModule.UniqueID);
                    ReorderEndpointRecursiveInputs(inputModule, reordredModuleIds, modulesRecursiveInputs);
                }
                //... otherwise allow it to be repositioned only when pushed to the left
                else if (inputModuleXPosition < inputModule.Properties.Dimensions.xMin)
                {
                    inputModule.Properties.Dimensions.position = new Vector2(inputModuleXPosition, inputModule.Properties.Dimensions.yMin);
                    ReorderEndpointRecursiveInputs(inputModule, reordredModuleIds, modulesRecursiveInputs);
                }
                nextInputStartingY = Math.Max(nextInputStartingY, modulesRecursiveInputs[inputModule].Max(m => m.Properties.Dimensions.yMax) + ModulesReorderingDeltaY);
            }
        }

        /// <summary>
        /// Adds to the modules recursive inputs dictionary the entries corresponding to the given module 
        /// </summary>
        /// <returns>The recursive inputs of the given module</returns>
        static private HashSet<CGModule> UpdateModulesRecursiveInputs(Dictionary<CGModule, HashSet<CGModule>> modulesRecursiveInputs, CGModule moduleToAdd)
        {
            if (modulesRecursiveInputs.ContainsKey(moduleToAdd))
                return modulesRecursiveInputs[moduleToAdd];

            List<CGModule> inputModules = moduleToAdd.Input.SelectMany(i => i.GetLinkedModules()).ToList();
            HashSet<CGModule> result = new HashSet<CGModule>
            {
                moduleToAdd
            };
            result.UnionWith(inputModules.SelectMany(i => UpdateModulesRecursiveInputs(modulesRecursiveInputs, i)));
            modulesRecursiveInputs[moduleToAdd] = result;
            return result;
        }

        /// <summary>
        ///  Delete, from the associated prefab if any, all the managed resources acting as an output. One example of such resources is the generated meshes by the <see cref="FluffyUnderware.Curvy.Generator.Modules.CreateMesh"/> module
        /// <remarks>Prefabs instances are not allowed to do some operations, such as deleting a game object. Such operations are done by the Curvy Generator. So run this method before doing any of those operations</remarks>
        /// </summary>
        /// <returns>Whether an associated prefab was modified</returns>
        public bool DeleteAllOutputManagedResourcesFromAssociatedPrefab()
        {
#if UNITY_EDITOR
            string prefabPath = PrefabUtility.GetPrefabAssetPathOfNearestInstanceRoot(this);
            if (String.IsNullOrEmpty(prefabPath))
                return false;

            GameObject prefabContentsRoot = PrefabUtility.LoadPrefabContents(prefabPath);
            CurvyGenerator[] prefabGenerators = prefabContentsRoot.GetComponentsInChildren<CurvyGenerator>();

            bool modified = false;
            foreach (CurvyGenerator prefabGenerator in prefabGenerators)
                foreach (CGModule module in prefabGenerator.Modules)
                    modified |= module.DeleteAllOutputManagedResources();

            if (modified)
            {
                var savedPrefab = PrefabUtility.SaveAsPrefabAsset(prefabContentsRoot, prefabPath);
                if (savedPrefab == null)
                {
                    DTLog.LogError($"[Curvy] The prefab asset '{prefabPath}' containing the generator '{name}' needs to be modified to delete generator output objects. Attempt to modify it failed. See other console messages to know what caused this failure.", this);
                    modified = false;
                }
                else
                {
                    object message = $"[Curvy] The prefab asset '{prefabPath}' containing the generator '{name}' was modified to delete generator output objects.";

                    PrefabStage currentPrefabStage = PrefabStageUtility.GetCurrentPrefabStage();

#if UNITY_2020_1_OR_NEWER
                    if (currentPrefabStage != null && currentPrefabStage.assetPath == prefabPath)
#else
                    if (currentPrefabStage != null && currentPrefabStage.prefabAssetPath == prefabPath)
#endif
                    {
                        message += " This might happen when you save modifications to the prefab asset. You might want to disable Auto Save in Prefab Mode to make this happen less frequently.";
                        DTLog.LogWarning(message, this);
                    }
                    else
                    {
                        message += " This might lead to the refreshing of the associated generator in the prefab instance.";
                        DTLog.Log(message, this);
                    }

                }
            }
            PrefabUtility.UnloadPrefabContents(prefabContentsRoot);
            return modified;
#else
            return false;
#endif
        }

        /// <summary>
        /// Save to scene all the managed resources acting as an output. One example of such resources is the generated meshes by the <see cref="FluffyUnderware.Curvy.Generator.Modules.CreateMesh"/> module
        /// </summary>
        public void SaveAllOutputManagedResources()
        {
            GameObject result = new GameObject($"{name} Exported Resources");
            result.transform.position = this.transform.position;
            result.transform.rotation = this.transform.rotation;
            result.transform.localScale = this.transform.localScale;
            Modules.Where(m => m is ResourceExportingModule).ForEach(m => ((ResourceExportingModule)m).SaveToScene(result.transform));

        }


        /*! \endcond */
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CurvyGenerator.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CurvyPropertyAttributes.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ff18089ea6039164dbd5086635c53ac8
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using System;
using System.Reflection;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy
{

    #region ### CG related ###

    /// <summary>
    /// CG Resource Attribute
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1813:AvoidUnsealedAttributes")]
    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
    public class CGResourceManagerAttribute : DTPropertyAttribute
    {
        public readonly string ResourceName;
        public bool ReadOnly;

        public CGResourceManagerAttribute(string resourceName)
        {
            ResourceName = resourceName;
        }
    }

    /// <summary>
    /// CG Resource Collection Attribute
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
    public sealed class CGResourceCollectionManagerAttribute : CGResourceManagerAttribute
    {
        public bool ShowCount;

        public CGResourceCollectionManagerAttribute(string resourceName)
            : base(resourceName)
        {
            ReadOnly = true;
        }
    }

    /// <summary>
    /// CG Data Reference Selector Attribute
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
    public sealed class CGDataReferenceSelectorAttribute : DTPropertyAttribute
    {
        public readonly System.Type DataType;

        public CGDataReferenceSelectorAttribute(System.Type dataType)
        {
            DataType = dataType;
        }
    }

    #endregion



}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/CurvyPropertyAttributes.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/MetaCGOptions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d8e6515f233d3da4fbaeff6c986c19df
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy
{

    /// <summary>
    /// Curvy Generator options Metadata class
    /// </summary>
    [HelpURL(CurvySpline.DOCLINK + "metacgoptions")]
    public class MetaCGOptions : CurvyMetadataBase
    {

        #region ### Serialized Fields ###

        [Positive]
        [SerializeField]
        private int m_MaterialID = DefaultMaterialId;


        [SerializeField]
        [FieldCondition(nameof(ShowUvEdgeOrHardEdge), true)]
        private bool m_HardEdge;
        [Positive(Tooltip = "Max step distance when using optimization")]
        [SerializeField]
        private float m_MaxStepDistance;
        [Section("Extended UV", HelpURL = CurvySpline.DOCLINK + "metacgoptions_extendeduv")]
        [FieldCondition(nameof(ShowUvEdgeOrHardEdge), true)]
        [SerializeField]
        private bool m_UVEdge;

        [Positive]
        [FieldCondition(nameof(showExplicitU), true)]
        [SerializeField]
        private bool m_ExplicitU;
        [FieldCondition(nameof(showFirstU), true)]
        [FieldAction("CBSetFirstU")]
        [Positive]
        [SerializeField]
        private float m_FirstU;
        [FieldCondition(nameof(showSecondU), true)]
        [Positive]
        [SerializeField]
        private float m_SecondU;

        /// <summary>
        /// Whether  or not the conversion of the UVEdge value to the new "system" (starting from Curvy 8) was done. See the commentary on the private method EnsureUVEdgeUpdate to know more.
        /// </summary>
        [SerializeField, HideInInspector] private bool uVEdgeUpdated = false;

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Gets or sets Material ID
        /// </summary>
        public int MaterialID
        {
            get
            {
                return m_MaterialID;
            }
            set
            {
                int v = Mathf.Max(0, value);
                if (m_MaterialID != v)
                {
                    m_MaterialID = v;
                    NotifyModification();
                }
            }
        }

        /// <summary>
        /// Gets or sets whether to create a hard edge or not
        /// This is the raw serialized value. In opposition, <see cref="CorrectedHardEdge"/> takes other considerations into account
        /// </summary>
        public bool HardEdge
        {
            get { return m_HardEdge; }
            set
            {
                if (m_HardEdge != value)
                {
                    m_HardEdge = value;
                    NotifyModification();
                }
            }
        }

        /// <summary>
        /// <see cref="HardEdge"/> is ignored for first and last CPs of an open spline. This method takes that into consideration. In opposition, <see cref="HardEdge"/> is the raw serialized value.
        /// </summary>
        /// <value></value>
        public bool CorrectedHardEdge
        {
            get
            {
                //this one is to handle the case of a cp (of an open spline) that was in the middle of the spline, and has HardEdge, then we delete all its following cps, so it becomes the last cp. This means it has HardEdge to true, but the value is ignored
                return CanHaveUvEdgeOrHadrdEdge() && HardEdge;
            }
        }

        /// <summary>
        /// Gets or sets whether to create an UV edge or not
        /// This is the raw serialized value. In opposition, <see cref="CorrectedUVEdge"/> takes other considerations into account
        /// </summary>
        public bool UVEdge
        {
            get { return m_UVEdge; }
            set
            {
                if (m_UVEdge != value)
                {
                    m_UVEdge = value;
                    NotifyModification();
                }
            }
        }

        /// <summary>
        /// <see cref="UVEdge"/> is ignored for first and last CPs of an open spline. This method takes that into consideration. In opposition, <see cref="UVEdge"/> is the raw serialized value.
        /// </summary>
        /// <value></value>
        public bool CorrectedUVEdge
        {
            get
            {
                //this one is to handle the case of a cp (of an open spline) that was in the middle of the spline, and has UVEdge, then we delete all its following cps, so it becomes the last cp. This means it has UVEdge to true, but the value is ignored
                return CanHaveUvEdgeOrHadrdEdge() && UVEdge;
            }
        }

        /// <summary>
        /// Gets or sets whether to define explicit U values
        /// </summary>
        public bool ExplicitU
        {
            get { return m_ExplicitU; }
            set
            {
                if (m_ExplicitU != value)
                {
                    m_ExplicitU = value;
                    NotifyModification();
                }
            }
        }

        /// <summary>
        /// Gets or sets UV0
        /// </summary>
        public float FirstU
        {
            get { return m_FirstU; }
            set
            {
                if (m_FirstU != value)
                {
                    m_FirstU = value;
                    NotifyModification();
                }
            }
        }

        /// <summary>
        /// Gets or sets UV0
        /// </summary>
        public float SecondU
        {
            get { return m_SecondU; }
            set
            {
                if (m_SecondU != value)
                {
                    m_SecondU = value;
                    NotifyModification();
                }
            }
        }

        /// <summary>
        /// Gets or sets maximum vertex distance when using optimization (0=infinite)
        /// </summary>
        public float MaxStepDistance
        {
            get
            {
                return m_MaxStepDistance;
            }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_MaxStepDistance != v)
                {
                    m_MaxStepDistance = v;
                    NotifyModification();
                }
            }
        }

        public bool HasDifferentMaterial
        {
            get
            {
                MetaCGOptions previousMetaCGOptions = GetPreviousData<MetaCGOptions>(false);
                int previousMaterialId = previousMetaCGOptions == null ? DefaultMaterialId : previousMetaCGOptions.MaterialID;
                return previousMaterialId != MaterialID;
            }
        }

        #endregion

        #region ### Private Fields & Properties ###

        private const int DefaultMaterialId = 0;

        private bool ShowUvEdgeOrHardEdge
        {
            get
            {
                return ControlPoint && CanHaveUvEdgeOrHadrdEdge();
            }
        }

        private bool showExplicitU
        {
            get
            {
                return (ControlPoint && !showSecondU);
            }
        }

        private bool showFirstU
        {
            get
            {
                return ExplicitU || CorrectedUVEdge;
            }
        }

        private bool showSecondU
        {
            get
            {
                return CorrectedUVEdge;
            }
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */


#if UNITY_EDITOR
        private void OnValidate()
        {
            NotifyModification();
        }

        protected override void Awake()
        {
            base.Awake();
            EnsureUVEdgeUpdate();
        }

#endif

        public void Reset()
        {
            MaterialID = DefaultMaterialId;
            HardEdge = false;
            MaxStepDistance = 0;
            UVEdge = false;
            ExplicitU = false;
            FirstU = 0;
            SecondU = 0;
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public float GetDefinedFirstU(float defaultValue)
        {
            return (CorrectedUVEdge || ExplicitU) ? FirstU : defaultValue;
        }

        public float GetDefinedSecondU(float defaultValue)
        {
            return (CorrectedUVEdge) ? SecondU : GetDefinedFirstU(defaultValue);
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATES */

        /// <summary>
        ///Until Curvy 7 included, a change in material id (compared to the one of the previous CP) was automatically considered to be an UVEdge, so in the case users wanted to just change a material id, they had to figure out the right value of first and second U, which is annoying at best. True, they had the option to deactivate Extended UV in the Shape Extrusion module, but that's not an option if you want to use extended UV on CPs other than the one with a material change.
        ///Starting from Curvy 8, the Extended UV option in the Shape Extrusion module is not visible anymore (which solves another problem: people confused about why the UV options they enter are not taken into consideration). The module will act as if Extended UV is always true. With Extended UV not available, a solution had to be implemented to allow for material id change that does not modify the UV. The solution found is to dissociate a material id change from UVEdge. Now you can have both true, false, or having different values.
        ///To keep things backward compatible, I am setting UVEdge to true when I detect a material id change while both U values are different from their default value of 0. This is done when an instance is processed for the first time under Curvy 8. This is not perfect, since you can still have someone who purposefully set both U values to 0.
        /// </summary>
        private void EnsureUVEdgeUpdate()
        {
            if (uVEdgeUpdated == false)
            {
                m_UVEdge = m_UVEdge || (HasDifferentMaterial && false == (FirstU == 0 && SecondU == 0));
                uVEdgeUpdated = true;
            }
        }

        private bool CanHaveUvEdgeOrHadrdEdge()
        {
            return Spline.Closed || (Spline.FirstVisibleControlPoint != ControlPoint && Spline.LastVisibleControlPoint != ControlPoint);
        }

        /*! \endcond */
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/CG/MetaCGOptions.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/ConnectedControlPointsSelector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fa3e4d284c1d61b45b2357dc26add96d
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.DevTools;
using UnityEngine;

namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// A class used by <see cref="SplineController"/> to define custom selection logic to select between the possible connected splines when the controller reaches a <see cref="CurvyConnection"/>
    /// </summary>
    abstract public class ConnectedControlPointsSelector : DTVersionedMonoBehaviour
    {
        /// <summary>
        /// Select, from the current connection, a Control Point to continue moving through.
        /// </summary>
        /// <param name="caller">The spline controller that is calling this selector</param>
        /// <param name="connection">The connection the caller reached and from which it needs to select a Control Point to continue the movement on</param>
        /// <param name="currentControlPoint">the Control Point, part of the connection, the controller is at.</param>
        /// <returns>The control point that the <param name="caller"></param> should continue its movement on</returns>
        abstract public CurvySplineSegment SelectConnectedControlPoint(SplineController caller, CurvyConnection connection, CurvySplineSegment currentControlPoint);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/ConnectedControlPointsSelector.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/ControllersEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a46071b8cead970438b2ce2c36461aef
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using FluffyUnderware.DevTools;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Events;

namespace FluffyUnderware.Curvy.Controllers
{
    #region ### Controller Events ###

    [System.Serializable]
    public class ControllerEvent : UnityEventEx<CurvyController> { }

    /// <summary>
    /// EventArgs used by spline controller movements
    /// </summary>
    [System.Serializable]
    public class CurvySplineMoveEvent : UnityEventEx<CurvySplineMoveEventArgs> { }

    /// <summary>
    /// EventArgs used by spline controller movements
    /// </summary>
    public class CurvySplineMoveEventArgs : System.ComponentModel.CancelEventArgs
    {
        /// <summary>
        /// The Spline Controller raising the event
        /// </summary>
        public SplineController Sender { get; private set; }
        /// <summary>
        /// The related spline
        /// </summary>
        public CurvySpline Spline { get; private set; }
        /// <summary>
        /// The control point which reaching triggered this event
        /// </summary>
        public CurvySplineSegment ControlPoint { get; private set; }
        /// <summary>
        /// Are <see cref="Delta"/> and <see cref="Position"/> in world units (in opposition to relative units)?
        /// </summary>
        public bool WorldUnits { get; private set; }

        /// <summary>
        /// The movement direction the controller had when sending the event
        /// </summary>
        public MovementDirection MovementDirection { get; private set; }
        /// <summary>
        /// The left distance yet to move.
        /// </summary>
        public float Delta { get; private set; }
        /// <summary>
        /// Controller Position on Spline
        /// </summary>
        public float Position { get; private set; }


        public CurvySplineMoveEventArgs(SplineController sender, CurvySpline spline, CurvySplineSegment controlPoint, float position, bool usingWorldUnits, float delta, MovementDirection direction)
        {
            Set_INTERNAL(sender, spline, controlPoint, position, delta, direction, usingWorldUnits);
        }

        /// <summary>
        /// Set all the properties values. Is not meant to be used by code outside of Curvy's code.
        /// </summary>
        internal void Set_INTERNAL(SplineController sender, CurvySpline spline, CurvySplineSegment controlPoint, float position, float delta, MovementDirection direction, bool usingWorldUnits)
        {

            Sender = sender;
            Spline = spline;
            ControlPoint = controlPoint;

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(Sender != null);
            Assert.IsTrue(controlPoint == null || controlPoint.Spline == spline);
#endif
            MovementDirection = direction;
            Delta = delta;
            Position = position;
            WorldUnits = usingWorldUnits;
            Cancel = false;
        }
    }


    //TODO Use CurvyControllerSwitchEvent
    //public class CurvyControllerSwitchEvent : UnityEventEx<CurvyControllerSwitchEventArgs> { }

    //public class CurvyControllerSwitchEventArgs : EventArgs
    //{
    //    /// <summary>
    //    /// The controller raising the event
    //    /// </summary>
    //    public CurvyController Controller { get; private set; }
    //    public CurvySpline SourceSpline { get; private set; }
    //    public CurvySpline DestinationSpline { get; private set; }
    //    public float TFOnSource { get; private set; }
    //    public float TFOnDestination { get; private set; }
    //    public CurvyControllerDirection DirectionOnSource { get; private set; }
    //    public CurvyControllerDirection DirectionOnDestination { get; private set; }
    //    public float SwitchTimeStart { get; private set; }
    //    public float SwitchDuration { get; private set; }
    //    public float SwitchProgression { get; private set; }


    //    public CurvyControllerSwitchEventArgs()
    //    {
    //    }

    //    public void Set(CurvyController controller, float switchTimeStart, float switchDuration, float switchProgression, CurvySpline sourceSpline, CurvySpline destinationSpline, float tfOnSource, float tfOnDestination, CurvyControllerDirection directionOnSource, CurvyControllerDirection directionOnDestination)
    //    {
    //        SwitchDuration = switchDuration;
    //        SwitchProgression = switchProgression;
    //        Controller = controller;
    //        SourceSpline = sourceSpline;
    //        DestinationSpline = destinationSpline;
    //        TFOnSource = tfOnSource;
    //        TFOnDestination = tfOnDestination;
    //        SwitchTimeStart = switchTimeStart;
    //        DirectionOnSource = directionOnSource;
    //        DirectionOnDestination = directionOnDestination;
    //    }
    //}

    #endregion
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/ControllersEvents.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/CurvyController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bb9a1c67a6f383a478b8a20a17b05cc4
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using System.Reflection;
using JetBrains.Annotations;
#if UNITY_EDITOR
using UnityEditor;
#endif

using UnityEngine.Assertions;
using UnityEngine.Events;
using UnityEngine.Serialization;

namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// Controller base class
    /// </summary>
    [ExecuteAlways]
    public abstract class CurvyController : DTVersionedMonoBehaviour, ISerializationCallbackReceiver
    {
        #region ### Enums ###
        /// <summary>
        /// Movement method options
        /// </summary>
        public enum MoveModeEnum
        {
            /// <summary>
            /// Move by Percentage or TF (SplineController only)
            /// </summary>
            Relative = 0,
            /// <summary>
            /// Move by calculated distance
            /// </summary>
            AbsolutePrecise = 1,
        }

        /// <summary>
        /// The play state of the controller
        /// </summary>
        public enum CurvyControllerState
        {
            Stopped,
            Playing,
            Paused
        }

        #endregion

        #region ### Events ###

        /// <summary>
        /// Invoked each time the controller finishes initialization
        /// </summary>
        public ControllerEvent OnInitialized
        {
            get { return onInitialized; }
        }

        #endregion

        #region ### Serialized Fields ###
        //TODO tooltips
        [Section("General", Sort = 0, HelpURL = CurvySpline.DOCLINK + "curvycontroller_general")]
        [Label(Tooltip = "Determines when to update")]
        public CurvyUpdateMethod UpdateIn = CurvyUpdateMethod.Update; // when to update?

        [SerializeField]
        [FieldCondition(nameof(IsNeededRigidbodyMissing), true, false, ActionAttribute.ActionEnum.ShowError,
            "Missing Rigidbody component. Its 'Is Kinematic' setting should be set to true")]
        [FieldCondition(nameof(IsNeeded2DRigidbodyMissing), true, false, ActionAttribute.ActionEnum.ShowError,
            "Missing Rigidbody 2D component. Its 'Body Type' setting should be set to 'Kinematic'")]
        [FieldCondition(nameof(IsNeededRigidbodyNotKinematic), true, false, ActionAttribute.ActionEnum.ShowError,
            "Rigidbody's 'Is Kinematic' setting should be set to true")]
        [FieldCondition(nameof(IsNeeded2DRigidbodyNotKinematic), true, false, ActionAttribute.ActionEnum.ShowError,
            "Rigidbody 2Ds 'Body Type' setting should be set to 'Kinematic'")]
        [FieldCondition(nameof(targetComponent), TargetComponent.Transform, false, ActionAttribute.ActionEnum.ShowInfo,
            "The transform's position and rotation are updated at the selected 'Update In' method.")]
        [FieldCondition(nameof(targetComponent), TargetComponent.Transform, true, ActionAttribute.ActionEnum.ShowInfo,
            "The rigidbody's position and rotation are updated at the physics simulation, and not at the selected 'Update In' method. Please consider this if getting the position or rotation via script.")]
        [Tooltip("The component controlled by the controller")]
        private TargetComponent targetComponent = TargetComponent.Transform;

        [Section("Position", Sort = 100, HelpURL = CurvySpline.DOCLINK + "curvycontroller_position")]
        [SerializeField]
        private CurvyPositionMode m_PositionMode = CurvyPositionMode.WorldUnits;

        /*! \cond PRIVATE */

        [RangeEx(0, nameof(maxPosition))]
        [SerializeField]
        [FormerlySerializedAs("m_InitialPosition")]
        [FieldCondition(nameof(ShouldDisablePositionSlider), true, false, ActionAttribute.ActionEnum.Disable)]
        protected float m_Position;

        /*! \endcond */

        [Section("Motion", Sort = 200, HelpURL = CurvySpline.DOCLINK + "curvycontroller_move")]
        [SerializeField]
        private MoveModeEnum m_MoveMode = MoveModeEnum.AbsolutePrecise;

        [Positive]
        [SerializeField]
        private float m_Speed = 0;

        [SerializeField] private MovementDirection m_Direction = MovementDirection.Forward;

        [SerializeField] private CurvyClamping m_Clamping = CurvyClamping.Loop;

        [Label("Constraints")]
        [Tooltip("Defines what motions are to be frozen")]
        [FieldCondition(nameof(AreConstraintsConflicting), true, false, ActionAttribute.ActionEnum.ShowWarning,
            "The controller targets a Rididbody that has constraints on it. This can creates conflicts with the controller's constraints")]
        [SerializeField] private MotionConstraints motionConstraints = MotionConstraints.None;

        [SerializeField, Tooltip("Start playing automatically when entering play mode")]
        private bool m_PlayAutomatically = true;

        [Section("Orientation", Sort = 300, HelpURL = CurvySpline.DOCLINK + "curvycontroller_orientation")]

        [Label("Source", "Source Vector")]
        [FieldCondition(nameof(ShowOrientationSection), false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [SerializeField]
        private OrientationModeEnum m_OrientationMode = OrientationModeEnum.Orientation;

        [Label("Lock Rotation", "When set, the controller will enforce the rotation to not change")]
#if UNITY_EDITOR //Conditional to avoid WebGL build failure when using Unity 5.5.3
        [FieldCondition(nameof(m_OrientationMode), OrientationModeEnum.None, true, ConditionalAttribute.OperatorEnum.OR, "ShowOrientationSection", false, false, Action = ActionAttribute.ActionEnum.Hide)]
#endif
        [SerializeField]
        private bool m_LockRotation = true;

        [Label("Target", "Target Vector3")]
        [FieldCondition(nameof(m_OrientationMode), OrientationModeEnum.None, false, ConditionalAttribute.OperatorEnum.OR, "ShowOrientationSection", false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [SerializeField]
        private OrientationAxisEnum m_OrientationAxis = OrientationAxisEnum.Up;

        [Tooltip("Should the orientation ignore the movement direction?")]
        [FieldCondition(nameof(m_OrientationMode), OrientationModeEnum.None, false, ConditionalAttribute.OperatorEnum.OR, "ShowOrientationSection", false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [SerializeField]
        private bool m_IgnoreDirection;

        [DevTools.Min(0, "Direction Damping Time", "If non zero, the direction vector will not be updated instantly, but using a damping effect that will last the specified amount of time.")]
        [FieldCondition(nameof(ShowOrientationSection), false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [SerializeField]
        private float m_DampingDirection;

        [DevTools.Min(0, "Up Damping Time", "If non zero, the up vector will not be updated instantly, but using a damping effect that will last the specified amount of time.")]
        [FieldCondition(nameof(ShowOrientationSection), false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [SerializeField]
        private float m_DampingUp;

        [Section("Offset", Sort = 400, HelpURL = CurvySpline.DOCLINK + "curvycontroller_orientation")]
        [FieldCondition(nameof(ShowOffsetSection), false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [RangeEx(-180f, 180f)]
        [SerializeField]
        private float m_OffsetAngle;

        [FieldCondition(nameof(ShowOffsetSection), false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [SerializeField]
        private float m_OffsetRadius;

        [FieldCondition(nameof(ShowOffsetSection), false, false, Action = ActionAttribute.ActionEnum.Hide)]
        [Label("Compensate Offset")]
        [SerializeField]
        private bool m_OffsetCompensation = true;

        [Section("Events", Sort = 500)]
        [SerializeField]
#pragma warning disable 649
        protected ControllerEvent onInitialized = new ControllerEvent();
#pragma warning restore 649

#if UNITY_EDITOR
        [Section("Advanced Settings", Sort = 2000, HelpURL = CurvySpline.DOCLINK + "curvycontroller_general", Expanded = false)]
        [Label(Tooltip = "Force this script to update in Edit mode as often as in Play mode. Most users don't need that.")]
        [SerializeField]
        private bool m_ForceFrequentUpdates;
#endif
        #endregion

        #region ### Public Properties ###


        /// <summary>
        /// The component controlled by the controller
        /// </summary>
        public TargetComponent TargetComponent
        {
            get { return targetComponent; }
            set
            {
                if (targetComponent != value)
                    targetComponent = value;
            }
        }

        /// <summary>
        /// Gets or sets the position mode to use
        /// </summary>
        public CurvyPositionMode PositionMode
        {
            get { return m_PositionMode; }
            set
            {
                m_PositionMode = value;
            }
        }

        /// <summary>
        /// Gets or sets the movement mode to use
        /// </summary>
        public MoveModeEnum MoveMode
        {
            get { return m_MoveMode; }
            set
            {
                if (m_MoveMode != value)
                    m_MoveMode = value;
            }
        }

        /// <summary>
        /// Gets or sets whether to start playing automatically
        /// </summary>
        public bool PlayAutomatically
        {
            get { return m_PlayAutomatically; }
            set
            {
                if (m_PlayAutomatically != value)
                    m_PlayAutomatically = value;
            }
        }

        /// <summary>
        /// Gets or sets what to do when the source's end is reached
        /// </summary>
        public CurvyClamping Clamping
        {
            get { return m_Clamping; }
            set
            {
                if (m_Clamping != value)
                    m_Clamping = value;
            }
        }

        /// <summary>
        /// Defines what motions are to be frozen
        /// </summary>
        public MotionConstraints MotionConstraints
        {
            get { return motionConstraints; }
            set
            {
                if (motionConstraints != value)
                    motionConstraints = value;
            }
        }

        /// <summary>
        /// Gets or sets how to apply rotation
        /// </summary>
        public OrientationModeEnum OrientationMode
        {
            get { return m_OrientationMode; }
            set
            {
                if (m_OrientationMode != value)
                    m_OrientationMode = value;
            }
        }

        /// <summary>
        /// Used only when OrientationMode is equal to None
        /// When true, the controller will enforce the rotation to not change
        /// </summary>
        public bool LockRotation
        {
            get { return m_LockRotation; }
            set
            {
                if (m_LockRotation != value)
                    m_LockRotation = value;

                if (m_LockRotation)
                {
                    GetPositionAndRotation(out _, out Quaternion rotation);
                    LockedRotation = rotation;
                }
            }
        }

        /// <summary>
        /// Gets or sets the axis to apply the rotation to
        /// </summary>
        public OrientationAxisEnum OrientationAxis
        {
            get { return m_OrientationAxis; }
            set
            {
                if (m_OrientationAxis != value)
                    m_OrientationAxis = value;

            }
        }

        /// <summary>
        /// If non zero, the direction vector will not be updated instantly, but using a damping effect that will last the specified amount of time.
        /// </summary>
        public float DirectionDampingTime
        {
            get { return m_DampingDirection; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_DampingDirection != v)
                    m_DampingDirection = v;
            }
        }

        /// <summary>
        /// If non zero, the up vector will not be updated instantly, but using a damping effect that will last the specified amount of time.
        /// </summary>
        public float UpDampingTime
        {
            get { return m_DampingUp; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_DampingUp != v)
                    m_DampingUp = v;
            }
        }



        /// <summary>
        /// Should the controller's orientation ignore the movement direction?
        /// </summary>
        public bool IgnoreDirection
        {
            get { return m_IgnoreDirection; }
            set
            {
                if (m_IgnoreDirection != value)
                    m_IgnoreDirection = value;
            }
        }

        /// <summary>
        /// Gets or sets the angle to offset (-180 to 180 off Orientation)
        /// </summary>
        public float OffsetAngle
        {
            get { return m_OffsetAngle; }
            set
            {
                if (m_OffsetAngle != value)
                    m_OffsetAngle = value;
            }
        }
        /// <summary>
        /// Gets or sets the offset radius
        /// </summary>
        public float OffsetRadius
        {
            get { return m_OffsetRadius; }
            set
            {
                if (m_OffsetRadius != value)
                    m_OffsetRadius = value;
            }
        }

        /// <summary>
        /// Gets or sets whether to compensate offset distances in curvy paths
        /// </summary>
        public bool OffsetCompensation
        {
            get { return m_OffsetCompensation; }
            set { m_OffsetCompensation = value; }
        }

        /// <summary>
        /// Gets or sets the speed either in world units or relative, depending on MoveMode
        /// </summary>
        public float Speed
        {
            get { return m_Speed; }
            set
            {
                if (value < 0)
                {
#if CURVY_SANITY_CHECKS

                    DTLog.LogWarning("[Curvy] Trying to assign a negative value of " + value.ToString() + " to Speed. Speed should always be positive. To set direction, use the Direction property", this);
#endif
                    value = -value;
                }
                m_Speed = value;
            }
        }

        /// <summary>
        /// Gets or sets the relative position on the source, respecting Clamping
        /// </summary>
        public float RelativePosition
        {
            get
            {
                float relativePosition;
                switch (PositionMode)
                {
                    case CurvyPositionMode.Relative:
                        relativePosition = GetClampedPosition(m_Position, CurvyPositionMode.Relative, Clamping, Length);
                        break;
                    case CurvyPositionMode.WorldUnits:
                        relativePosition = AbsoluteToRelative(GetClampedPosition(m_Position, CurvyPositionMode.WorldUnits, Clamping, Length));
                        break;
                    default:
                        throw new NotSupportedException();
                }

                return relativePosition;
            }
            set
            {
                float clampedRelativePosition = GetClampedPosition(value, CurvyPositionMode.Relative, Clamping, Length);
                switch (PositionMode)
                {
                    case CurvyPositionMode.Relative:
                        m_Position = clampedRelativePosition;
                        break;
                    case CurvyPositionMode.WorldUnits:
                        m_Position = RelativeToAbsolute(clampedRelativePosition);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
        }

        /// <summary>
        /// Gets or sets the absolute position on the source, respecting Clamping
        /// </summary>
        public float AbsolutePosition
        {
            get
            {
                float absolutePosition;
                switch (PositionMode)
                {
                    case CurvyPositionMode.Relative:
                        absolutePosition = RelativeToAbsolute(GetClampedPosition(m_Position, CurvyPositionMode.Relative, Clamping, Length));
                        break;
                    case CurvyPositionMode.WorldUnits:
                        absolutePosition = GetClampedPosition(m_Position, CurvyPositionMode.WorldUnits, Clamping, Length);
                        break;
                    default:
                        throw new NotSupportedException();
                }

                return absolutePosition;
            }
            set
            {
                float clampedAbsolutePosition = GetClampedPosition(value, CurvyPositionMode.WorldUnits, Clamping, Length);
                switch (PositionMode)
                {
                    case CurvyPositionMode.Relative:
                        m_Position = AbsoluteToRelative(clampedAbsolutePosition);
                        break;
                    case CurvyPositionMode.WorldUnits:
                        m_Position = clampedAbsolutePosition;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
        }

        /// <summary>
        /// Gets or sets the position on the source (relative or absolute, depending on MoveMode), respecting Clamping
        /// </summary>
        public float Position
        {
            get
            {
                float result;
                switch (PositionMode)
                {
                    case CurvyPositionMode.Relative:
                        result = RelativePosition;
                        break;
                    case CurvyPositionMode.WorldUnits:
                        result = AbsolutePosition;
                        break;
                    default:
                        throw new NotSupportedException();
                }
                return result;
            }
            set
            {
                switch (PositionMode)
                {
                    case CurvyPositionMode.Relative:
                        RelativePosition = value;
                        break;
                    case CurvyPositionMode.WorldUnits:
                        AbsolutePosition = value;
                        break;
                    default:
                        throw new NotSupportedException();
                }
            }
        }

        /// <summary>
        /// Gets or sets the movement direction
        /// </summary>
        public MovementDirection MovementDirection
        {
            get { return m_Direction; }
            set { m_Direction = value; }
        }


        /// <summary>
        /// The state (Playing, paused or stopped) of the controller
        /// </summary>
        public CurvyControllerState PlayState { get { return State; } }

        /// <summary>
        /// Returns true if the controller has all it dependencies ready.
        /// </summary>
        /// <remarks>A controller that is not initialized and has IsReady true, will be initialized at the next update call (automatically each frame or manually through <see cref="Refresh"/>.</remarks>
        abstract public bool IsReady { get; }

#if UNITY_EDITOR
        /// <summary>
        /// By default Unity calls scripts' update less frequently in Edit mode. ForceFrequentUpdates forces this script to update in Edit mode as often as in Play mode. Most users don't need that, but that was helpful for a user working with cameras controlled by Unity in Edit mode
        /// </summary>
        public bool ForceFrequentUpdates
        {
            get { return m_ForceFrequentUpdates; }
            set { m_ForceFrequentUpdates = value; }
        }
#endif

        #endregion

        #region ### Private & Protected Fields ###

        /// <summary>
        /// The position slider is disabled in the inspector when this property returns true
        /// </summary>
        protected virtual bool ShouldDisablePositionSlider => PositionMode == CurvyPositionMode.WorldUnits && IsReady == false;

        /// <summary>
        /// An error message used in various assertions
        /// </summary>
        protected const string ControllerNotReadyMessage = "The controller is not yet ready";

        /// <summary>
        /// The state (Playing, paused or stopped) of the controller
        /// <seealso cref="CurvyControllerState"/>
        /// </summary>
        protected CurvyControllerState State = CurvyControllerState.Stopped;

        /// <summary>
        /// The damping velocity used in the Direction damping
        /// <seealso cref="DirectionDampingTime"/>
        /// <seealso cref="Vector3.SmoothDamp(Vector3, Vector3, ref Vector3, float, float, float)"/>
        /// </summary>
        protected Vector3 DirectionDampingVelocity;//TODO should this value be reinitialized when DirectionDampingTime is set to non strictly positive value or any other moment?

        /// <summary>
        /// The damping velocity used in the Up damping
        /// <seealso cref="UpDampingTime"/>
        /// <seealso cref="Vector3.SmoothDamp(Vector3, Vector3, ref Vector3, float, float, float)"/>
        /// </summary>
        protected Vector3 UpDampingVelocity;//TODO should this value be reinitialized when UpDampingTime is set to non strictly positive value or any other moment?

        /// <summary>
        /// The position of the controller when started playing
        /// </summary>
        protected float PrePlayPosition;

        /// <summary>
        /// The <see cref="MovementDirection"/> of the controller when started playing
        /// </summary>
        protected MovementDirection PrePlayDirection;

        /// <summary>
        /// When <see cref="OrientationMode"/> is None, and <see cref="LockRotation"/> is true, this field is the value of the locked rotation, the one that will be assigned all the time to the controller
        /// </summary>
        protected Quaternion LockedRotation;


#if UNITY_EDITOR
        /// <summary>
        /// The last time the controller was updated while in Edit Mode
        /// </summary>
        protected float EditModeLastUpdate;
#endif

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */
        protected virtual void OnEnable()
        {
            if (isInitialized == false && IsReady)
            {
                Initialize();
                InitializedApplyDeltaTime(0);
            }

#if UNITY_EDITOR
            EditorApplication.update += editorUpdate;
#endif
        }

        protected virtual void Start()
        {
            if (isInitialized == false && IsReady)
            {
                Initialize();
                InitializedApplyDeltaTime(0);
            }

            if (PlayAutomatically && Application.isPlaying)
                Play();
        }

        protected virtual void OnDisable()
        {
#if UNITY_EDITOR
            EditorApplication.update -= editorUpdate;
#endif
            if (isInitialized)
                Deinitialize();
        }

        protected virtual void Update()
        {
            if (UpdateIn == CurvyUpdateMethod.Update)
                ApplyDeltaTime(TimeSinceLastUpdate);
        }

        protected virtual void LateUpdate()
        {
            if (UpdateIn == CurvyUpdateMethod.LateUpdate ||
                (Application.isPlaying == false && UpdateIn == CurvyUpdateMethod.FixedUpdate)) // In edit mode, fixed updates are not called, so we update the controller here instead
                ApplyDeltaTime(TimeSinceLastUpdate);
        }

        protected virtual void FixedUpdate()
        {
            if (UpdateIn == CurvyUpdateMethod.FixedUpdate)
                ApplyDeltaTime(TimeSinceLastUpdate);
        }

#if UNITY_EDITOR
        protected virtual void OnValidate()
        {
            Speed = m_Speed;
            LockRotation = m_LockRotation;
        }
#endif

        protected virtual void Reset()
        {
            UpdateIn = CurvyUpdateMethod.Update;
            TargetComponent = TargetComponent.Transform;
            PositionMode = CurvyPositionMode.WorldUnits;
            m_Position = 0;
            PlayAutomatically = true;
            MoveMode = MoveModeEnum.AbsolutePrecise;
            Speed = 0;
            LockRotation = true;
            MotionConstraints = MotionConstraints.None;
            Clamping = CurvyClamping.Loop;
            OrientationMode = OrientationModeEnum.Orientation;
            OrientationAxis = OrientationAxisEnum.Up;
            IgnoreDirection = false;
        }
        /*! \endcond */
        #endregion

        #region ### Virtual Properties & Methods  ###

        /// <summary>
        /// Gets the transform being controlled by this controller.
        /// </summary>
        /// <seealso cref="TargetComponent"/>
        public virtual Transform Transform
        {
            get
            {
                return transform;
            }
        }

        /// <summary>
        /// Gets the rigidbody being controlled by this controller.
        /// </summary>
        /// <seealso cref="TargetComponent"/>
        public virtual Rigidbody Rigidbody
        {
            [CanBeNull]
            get
            {
                return transform.GetComponent<Rigidbody>();
            }
        }

        /// <summary>
        /// Gets the 2d rigidbody being controlled by this controller.
        /// </summary>
        /// <seealso cref="TargetComponent"/>
        public virtual Rigidbody2D Rigidbody2D
        {
            [CanBeNull]
            get
            {
                return transform.GetComponent<Rigidbody2D>();
            }
        }

        /// <summary>
        /// Advances the controller state by deltaTime seconds. Is called only for initialized controllers
        /// </summary>
        protected virtual void InitializedApplyDeltaTime(float deltaTime)
        {
#if UNITY_EDITOR
            EditModeLastUpdate = Time.realtimeSinceStartup;
#endif
            if (State == CurvyControllerState.Playing && Speed * deltaTime != 0)
            {
                float speed = UseOffset && OffsetCompensation && OffsetRadius != 0f
                    ? ComputeOffsetCompensatedSpeed(deltaTime)
                    : Speed;

                if (speed * deltaTime != 0)
                    Advance(speed, deltaTime);
            }

            Vector3 preRefreshPosition;
            Quaternion preRefreshOrientation;
            GetPositionAndRotation(out preRefreshPosition, out preRefreshOrientation);

            Vector3 newPosition;
            Vector3 newForward;
            Vector3 newUp;
            ComputeTargetPositionAndRotation(out newPosition, out newUp, out newForward);

            Vector3 postDampingForward;
            if (DirectionDampingTime > 0 && State == CurvyControllerState.Playing)
            {
                postDampingForward = deltaTime > 0
                    ? Vector3.SmoothDamp(preRefreshOrientation * Vector3.forward, newForward, ref DirectionDampingVelocity, DirectionDampingTime, float.PositiveInfinity, deltaTime)
                    : preRefreshOrientation * Vector3.forward;
            }
            else
                postDampingForward = newForward;

            Vector3 postDampingUp;
            if (UpDampingTime > 0 && State == CurvyControllerState.Playing)
            {
                postDampingUp = deltaTime > 0
                    ? Vector3.SmoothDamp(preRefreshOrientation * Vector3.up, newUp, ref UpDampingVelocity, UpDampingTime, float.PositiveInfinity, deltaTime)
                    : preRefreshOrientation * Vector3.up;
            }
            else
                postDampingUp = newUp;

            Quaternion newRotation = Quaternion.LookRotation(postDampingForward, postDampingUp);

            SetPositionAndRotation(newPosition, newRotation);

            if (preRefreshPosition.NotApproximately(newPosition) || preRefreshOrientation.DifferentOrientation(newRotation))
                UserAfterUpdate();
        }

        /// <summary>
        /// Gets the position and rotation of the controller, ignoring any damping or other interpolations
        /// </summary>
        /// <param name="targetPosition"></param>
        /// <param name="targetUp"></param>
        /// <param name="targetForward"></param>
        protected virtual void ComputeTargetPositionAndRotation(out Vector3 targetPosition, out Vector3 targetUp, out Vector3 targetForward)
        {
            Vector3 pos;
            Vector3 tangent;
            Vector3 orientation;
            GetInterpolatedSourcePosition(RelativePosition, out pos, out tangent, out orientation);

            if (tangent == Vector3.zero || orientation == Vector3.zero)
                GetOrientationNoneUpAndForward(out targetUp, out targetForward);
            else
            {
                switch (OrientationMode)
                {
                    case OrientationModeEnum.None:
                        GetOrientationNoneUpAndForward(out targetUp, out targetForward);
                        break;
                    case OrientationModeEnum.Orientation:
                        {
                            Vector3 signedTangent = (m_Direction == MovementDirection.Backward && IgnoreDirection == false) ? -tangent : tangent;
                            switch (OrientationAxis)
                            {
                                case OrientationAxisEnum.Up:
                                    targetUp = orientation;
                                    targetForward = signedTangent;
                                    break;
                                case OrientationAxisEnum.Down:
                                    targetUp = -orientation;
                                    targetForward = signedTangent;
                                    break;
                                case OrientationAxisEnum.Forward:
                                    targetUp = -signedTangent;
                                    targetForward = orientation;
                                    break;
                                case OrientationAxisEnum.Backward:
                                    targetUp = signedTangent;
                                    targetForward = -orientation;
                                    break;
                                case OrientationAxisEnum.Left:
                                    targetUp = Vector3.Cross(orientation, signedTangent);
                                    targetForward = signedTangent;
                                    break;
                                case OrientationAxisEnum.Right:
                                    targetUp = Vector3.Cross(signedTangent, orientation);
                                    targetForward = signedTangent;
                                    break;
                                default:
                                    throw new NotSupportedException();
                            }
                        }
                        break;
                    case OrientationModeEnum.Tangent:
                        {

                            Vector3 signedTangent = (m_Direction == MovementDirection.Backward && IgnoreDirection == false) ? -tangent : tangent;
                            switch (OrientationAxis)
                            {
                                case OrientationAxisEnum.Up:
                                    targetUp = signedTangent;
                                    targetForward = -orientation;
                                    break;
                                case OrientationAxisEnum.Down:
                                    targetUp = -signedTangent;
                                    targetForward = orientation;
                                    break;
                                case OrientationAxisEnum.Forward:
                                    targetUp = orientation;
                                    targetForward = signedTangent;
                                    break;
                                case OrientationAxisEnum.Backward:
                                    targetUp = orientation;
                                    targetForward = -signedTangent;
                                    break;
                                case OrientationAxisEnum.Left:
                                    targetUp = orientation;
                                    targetForward = Vector3.Cross(orientation, signedTangent);
                                    break;
                                case OrientationAxisEnum.Right:
                                    targetUp = orientation;
                                    targetForward = Vector3.Cross(signedTangent, orientation);
                                    break;
                                default:
                                    throw new NotSupportedException();
                            }
                        }
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

            targetPosition = (UseOffset && OffsetRadius != 0f)
                ? ApplyOffset(pos, tangent, orientation, OffsetAngle, OffsetRadius)
                : pos;
        }


        virtual protected void Initialize()
        {
            isInitialized = true;
            GetPositionAndRotation(out _, out Quaternion rotation);
            LockedRotation = rotation;
            DirectionDampingVelocity = UpDampingVelocity = Vector3.zero;

            BindEvents();
            UserAfterInit();
            onInitialized.Invoke(this);
        }

        virtual protected void Deinitialize()
        {
            UnbindEvents();
            isInitialized = false;
        }

        /// <summary>
        /// Binds any external events
        /// </summary>
        protected virtual void BindEvents()
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(isInitialized);
#endif
        }
        /// <summary>
        /// Unbinds any external events
        /// </summary>
        protected virtual void UnbindEvents()
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(isInitialized);
#endif
        }

        protected virtual void SavePrePlayState()
        {
            PrePlayPosition = m_Position;
            PrePlayDirection = m_Direction;
        }

        protected virtual void RestorePrePlayState()
        {
            m_Position = PrePlayPosition;
            m_Direction = PrePlayDirection;
        }

        /// <summary>
        /// Gets the current position and rotation of the target component
        /// </summary>
        /// <seealso cref="TargetComponent"/>
        protected virtual void GetPositionAndRotation(out Vector3 position, out Quaternion rotation)
        {
            switch (TargetComponent)
            {
                case TargetComponent.Transform:
                    {
                        Transform cachedTransform = Transform;
                        position = cachedTransform.position;
                        rotation = cachedTransform.rotation;
                    }
                    break;
                case TargetComponent.KinematicRigidbody:
                    {
                        Rigidbody cachedRigidBody = Rigidbody;
                        if (cachedRigidBody == null || Application.isPlaying == false)
                        {
                            Transform cachedTransform = Transform;
                            position = cachedTransform.position;
                            rotation = cachedTransform.rotation;
                        }
                        else
                        {
                            position = cachedRigidBody.position;
                            rotation = cachedRigidBody.rotation;
                        }
                    }
                    break;
                case TargetComponent.KinematicRigidbody2D:
                    {
                        Rigidbody2D cachedRigidBody = Rigidbody2D;
                        if (cachedRigidBody == null || Application.isPlaying == false)
                        {
                            Transform cachedTransform = Transform;
                            position = cachedTransform.position;
                            rotation = cachedTransform.rotation;
                        }
                        else
                        {
                            position = cachedRigidBody.position;
                            rotation = Quaternion.AngleAxis(Rigidbody2D.rotation, cachedRigidBody.transform.rotation * new Vector3(0, 0, 1));
                        }
                    }
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        /// <summary>
        /// Sets a new position and rotation to the target component
        /// </summary>
        /// <seealso cref="TargetComponent"/>
        protected virtual void SetPositionAndRotation(Vector3 position, Quaternion rotation)
        {
            Vector3 constrainedPosition;
            Quaternion constrainedRotation;
            if (MotionConstraints == MotionConstraints.None)
            {
                constrainedPosition = position;
                constrainedRotation = rotation;
            }
            else
            {
                GetPositionAndRotation(out var oldPosition, out var oldRotation);

                //position
                {
                    constrainedPosition.x =
                        (MotionConstraints & MotionConstraints.FreezePositionX) == 0
                            ? position.x
                            : oldPosition.x;

                    constrainedPosition.y =
                        (MotionConstraints & MotionConstraints.FreezePositionY) == 0
                            ? position.y
                            : oldPosition.y;

                    constrainedPosition.z =
                        (MotionConstraints & MotionConstraints.FreezePositionZ) == 0
                            ? position.z
                            : oldPosition.z;
                }

                //rotation
                {

                    Vector3 constrainedRotationEuler;
                    {
                        Vector3 rotationEuler = rotation.eulerAngles;
                        Vector3 oldRotationEuler = oldRotation.eulerAngles;

                        constrainedRotationEuler.x =
                            (MotionConstraints & MotionConstraints.FreezeRotationX) == 0
                                ? rotationEuler.x
                                : oldRotationEuler.x;

                        constrainedRotationEuler.y =
                            (MotionConstraints & MotionConstraints.FreezeRotationY) == 0
                                ? rotationEuler.y
                                : oldRotationEuler.y;

                        constrainedRotationEuler.z =
                            (MotionConstraints & MotionConstraints.FreezeRotationZ) == 0
                                ? rotationEuler.z
                                : oldRotationEuler.z;
                    }

                    constrainedRotation = Quaternion.Euler(constrainedRotationEuler);
                }
            }

            switch (TargetComponent)
            {
                case TargetComponent.Transform:
                    {
                        Transform.SetPositionAndRotation(constrainedPosition, constrainedRotation);
                    }
                    break;
                case TargetComponent.KinematicRigidbody:
                    {
                        Rigidbody cachedRigidBody = Rigidbody;
                        if (cachedRigidBody == null || Application.isPlaying == false)
                        {
                            Transform.SetPositionAndRotation(constrainedPosition, constrainedRotation);
                        }
                        else
                        {
                            cachedRigidBody.MovePosition(constrainedPosition); //cachedRigidbody.position is not yet updated. Will be done after physics simulation.
                            cachedRigidBody.MoveRotation(constrainedRotation); //cachedRigidbody.roation is not yet updated. Will be done after physics simulation.
                        }
                    }
                    break;
                case TargetComponent.KinematicRigidbody2D:
                    {
                        Rigidbody2D cachedRigidBody = Rigidbody2D;
                        if (cachedRigidBody == null || Application.isPlaying == false)
                        {
                            Transform.SetPositionAndRotation(constrainedPosition, constrainedRotation);
                        }
                        else
                        {
                            cachedRigidBody.MovePosition(constrainedPosition); //cachedRigidbody.position is not yet updated. Will be done after physics simulation.
                            cachedRigidBody.MoveRotation(constrainedRotation); //cachedRigidbody.roation is not yet updated. Will be done after physics simulation.
                        }
                    }
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        #region ### Virtual Methods for inherited custom controllers (Easy mode) ###

        /// <summary>
        /// Called after the controller is initialized
        /// </summary>
        protected virtual void UserAfterInit() { }
        /// <summary>
        /// Called after the controller has updated it's position or rotation
        /// </summary>
        protected virtual void UserAfterUpdate() { }

        #endregion

        #region Conditional display in the inspector of CurvyController properties

        /// <summary>
        /// Whether the controller should display the CurvyController properties under the Orientation section or not.
        /// </summary>
        protected virtual bool ShowOrientationSection
        {
            get { return true; }
        }
        /// <summary>
        /// Whether the controller should display the CurvyController properties under the Offset section or not.
        /// </summary>
        protected virtual bool ShowOffsetSection
        {
            get { return OrientationMode != OrientationModeEnum.None; }
        }

        #endregion

        #endregion

        #region ### Abstract Properties and Methods ###

        /// <summary>
        /// Gets the source's length
        /// </summary>
        public abstract float Length { get; }

        /// <summary>
        /// Advance the controller and return the new position. This method will do side effect operations if needed, like updating some internal state, or trigerring events.
        /// </summary>
        /// <param name="speed">controller's speed. Should be strictely positive</param>
        /// <param name="deltaTime">the time that the controller should advance with. Should be strictely positive</param>
        abstract protected void Advance(float speed, float deltaTime);

        /// <summary>
        /// Advance the controller and return the new position. Contrary to <see cref="Advance"/>, this method will not do any side effect operations, like updating some internal state, or trigerring events
        /// 
        /// </summary>
        /// <param name="tf">the current virtual position (either TF or World Units) </param>
        /// <param name="curyDirection">the current direction</param>
        /// <param name="speed">controller's speed. Should be strictely positive</param>
        /// <param name="deltaTime">the time that the controller should advance with. Should be strictely positive</param>
        abstract protected void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime);

        /// <summary>
        /// Converts distance on source from absolute to relative position.
        /// </summary>
        /// <param name="worldUnitDistance">distance in world units from the source start. Should be already clamped</param>
        /// <returns>relative distance in the range 0..1</returns>
        abstract protected float AbsoluteToRelative(float worldUnitDistance);

        /// <summary>
        /// Converts distance on source from relative to absolute position.
        /// </summary>
        /// <param name="relativeDistance">relative distance from the source start. Should be already clamped</param>
        /// <returns>distance in world units from the source start</returns>
        abstract protected float RelativeToAbsolute(float relativeDistance);

        /// <summary>
        /// Retrieve the source global position for a given relative position (TF)
        /// </summary>
        abstract protected Vector3 GetInterpolatedSourcePosition(float tf);

        /// <summary>
        /// Retrieve the source global position, tangent and orientation for a given relative position (TF)
        /// </summary>
        abstract protected void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up);

        /// <summary>
        /// Retrieve the source global Orientation/Up-Vector for a given relative position
        /// </summary>
        abstract protected Vector3 GetOrientation(float tf);

        /// <summary>
        /// Gets global tangent for a given relative position
        /// </summary>
        abstract protected Vector3 GetTangent(float tf);


        #endregion


        #region Non virtual public methods 

        /// <summary>
        /// Plays the controller. Calling this method while the controller is playing will have no effect.
        /// </summary>
        public void Play()
        {
            if (PlayState == CurvyControllerState.Stopped)
                SavePrePlayState();
            State = CurvyControllerState.Playing;
        }

        /// <summary>
        /// Stops the controller, and restore its position (and other relevant states) to its state when starting playing
        /// </summary>
        public void Stop()
        {
            if (PlayState != CurvyControllerState.Stopped)
                RestorePrePlayState();
            State = CurvyControllerState.Stopped;
        }

        /// <summary>
        /// Pauses the controller. To unpause it call Play()
        /// </summary>
        public void Pause()
        {
            if (PlayState == CurvyControllerState.Playing)
                State = CurvyControllerState.Paused;
        }

        /// <summary>
        /// Forces the controller to update its state, without waiting for the automatic per frame update.
        /// Can initialize or deinitialize the controller if the right conditions are met.
        /// </summary>
        public void Refresh()
        {
            ApplyDeltaTime(0);
        }

        /// <summary>
        /// Advances the controller state by deltaTime seconds, without waiting for the automatic per frame update.
        /// Can initialize or deinitialize the controller if the right conditions are met.
        /// </summary>
        public void ApplyDeltaTime(float deltaTime)
        {
            if (isInitialized == false && IsReady)
                Initialize();
            else if (isInitialized && IsReady == false)
                Deinitialize();

            if (isInitialized)
                InitializedApplyDeltaTime(deltaTime);
        }

        /// <summary>
        /// Teleports the controller to a specific position, while handling events triggering and connections.
        /// </summary>
        /// <remarks> Internally, the teleport is handled as a movement of high speed on small time (0.001s). This will call <see cref="ApplyDeltaTime"/> with that small amount of time.</remarks>
        public void TeleportTo(float newPosition)
        {
            float distance = Mathf.Abs(Position - newPosition);
            MovementDirection direction = Position < newPosition
                ? MovementDirection.Forward
                : MovementDirection.Backward;
            TeleportBy(distance, direction);
        }

        /// <summary>
        /// Teleports the controller to by a specific distance, while handling events triggering and connections.
        /// </summary>
        /// <param name="distance"> A positive distance</param>
        /// <param name="direction"> Direction of teleportation</param>
        /// <remarks> Internally, the teleport is handled as a movement of high speed on small time (0.001s). This will call <see cref="ApplyDeltaTime"/> with that small amount of time.</remarks>
        public void TeleportBy(float distance, MovementDirection direction)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(distance >= 0);
#endif
            if (PlayState != CurvyControllerState.Playing)
                DTLog.LogError("[Curvy] Calling TeleportBy on a controller that is stopped. Please make the controller play first", this);

            float preWrapSpeed = Speed;
            MovementDirection preWrapDirection = MovementDirection;

            const float timeFraction = 1000;
            Speed = Mathf.Abs(distance) * timeFraction;
            MovementDirection = direction;

            ApplyDeltaTime(1 / timeFraction);

            Speed = preWrapSpeed;
            MovementDirection = preWrapDirection;
        }



        /// <summary>
        /// Event-friedly helper that sets a field or property value
        /// </summary>
        /// <param name="fieldAndValue">e.g. "MyValue=42"</param>
        public void SetFromString(string fieldAndValue)
        {
            string[] f = fieldAndValue.Split('=');
            if (f.Length != 2)
                return;

            FieldInfo fi = this.GetType().FieldByName(f[0], true, false);
            if (fi != null)
            {
                try
                {
                    if (fi.FieldType.IsEnum)
                        fi.SetValue(this, System.Enum.Parse(fi.FieldType, f[1]));
                    else
                        fi.SetValue(this, System.Convert.ChangeType(f[1], fi.FieldType, System.Globalization.CultureInfo.InvariantCulture));
                }
                catch (System.Exception e)
                {
                    Debug.LogWarning(this.name + ".SetFromString(): " + e.ToString());
                }
            }
            else
            {
                PropertyInfo pi = this.GetType().PropertyByName(f[0], true, false);
                if (pi != null)
                {
                    try
                    {
                        if (pi.PropertyType.IsEnum)
                            pi.SetValue(this, System.Enum.Parse(pi.PropertyType, f[1]), null);
                        else
                            pi.SetValue(this, System.Convert.ChangeType(f[1], pi.PropertyType, System.Globalization.CultureInfo.InvariantCulture), null);
                    }
                    catch (System.Exception e)
                    {
                        Debug.LogWarning(this.name + ".SetFromString(): " + e.ToString());
                    }
                }
            }
        }
        #endregion



        #region ### Privates & Protected Methods & Properties ###

        /// <summary>
        /// Whether or not the controller is initialized. Initialization happens before first usage
        /// </summary>
        protected bool isInitialized { get; private set; }

        /// <summary>
        /// When in Play mode, the controller update happens only in Update or Late Update of Fixed Update, so the time since last update is always equal to Time.deltaTime
        /// When in Edit mode, the controller update happens at various points, including the editor's update, so we compute the time since last update using a time stamp
        /// </summary>
        protected float TimeSinceLastUpdate
        {
            get
            {
#if UNITY_EDITOR
                return (Application.isPlaying) ?
                    Time.deltaTime :
                    Time.realtimeSinceStartup - EditModeLastUpdate;
#else
                    return  Time.deltaTime;
#endif
            }
        }

        /// <summary>
        /// Whether this controller uses Offsetting or not
        /// </summary>
        protected bool UseOffset
        {
            get { return ShowOffsetSection; }
        }

#if UNITY_EDITOR
        private void editorUpdate()
        {
            if (Application.isPlaying == false)
            {
                if (ForceFrequentUpdates)
                    EditorApplication.QueuePlayerLoopUpdate();
                else
                    ApplyDeltaTime(TimeSinceLastUpdate);
            }
        }
#endif

        /// <summary>
        /// Returns the position of the controller after applying an offset
        /// </summary>
        /// <param name="position">The controller's position</param>
        /// <param name="tangent">The tangent at the controller's position</param>
        /// <param name="up">The Up direction at the controller's position</param>
        /// <param name="offsetAngle"><see cref="OffsetAngle"/></param>
        /// <param name="offsetRadius"><see cref="OffsetRadius"/></param>
        protected static Vector3 ApplyOffset(Vector3 position, Vector3 tangent, Vector3 up, float offsetAngle, float offsetRadius)
        {
            Quaternion offsetRotation = Quaternion.AngleAxis(offsetAngle, tangent);
            return position.Addition((offsetRotation * up).Multiply(offsetRadius));
        }

        /// <summary>
        /// Return the clamped position
        /// </summary>
        protected static float GetClampedPosition(float position, CurvyPositionMode positionMode, CurvyClamping clampingMode, float length)
        {
            float clampedPosition;
            {
                switch (positionMode)
                {
                    case CurvyPositionMode.Relative:
                        if (position == 1)
                            clampedPosition = 1;
                        else
                            clampedPosition = CurvyUtility.ClampTF(position, clampingMode);
                        break;
                    case CurvyPositionMode.WorldUnits:
                        if (position == length)
                            clampedPosition = length;
                        else
                            clampedPosition = CurvyUtility.ClampDistance(position, clampingMode, length);
                        break;
                    default:
                        throw new NotSupportedException();
                }
            }
            return clampedPosition;
        }

        private float maxPosition
        {
            get
            {
                return GetMaxPosition(PositionMode);
            }
        }

        /// <summary>
        /// Returns the maximal valid position value using the given <see cref="CurvyPositionMode"/>
        /// </summary>
        /// <param name="positionMode"></param>
        protected float GetMaxPosition(CurvyPositionMode positionMode)
        {
            float result;
            switch (positionMode)
            {
                case CurvyPositionMode.Relative:
                    result = 1;
                    break;
                case CurvyPositionMode.WorldUnits:
                    result = IsReady
                        ? Length
                        : 0;
                    break;
                default:
                    throw new NotSupportedException();
            }

            return result;
        }

        /// <summary>
        /// Returns the Speed after applying Offset Compensation <see cref="OffsetCompensation"/>
        /// </summary>
        /// <param name="deltaTime">Time since last update</param>
        /// <returns></returns>
        protected float ComputeOffsetCompensatedSpeed(float deltaTime)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(deltaTime > 0);
            Assert.IsTrue(UseOffset);
#endif

            if (OffsetRadius == 0)
                return Speed;

            Vector3 previousOffsetlesPosition;
            Vector3 previousOffsetPosition;
            {
                Vector3 previousTangent;
                Vector3 previousUp;
                GetInterpolatedSourcePosition(RelativePosition, out previousOffsetlesPosition, out previousTangent, out previousUp);

                previousOffsetPosition = ApplyOffset(previousOffsetlesPosition, previousTangent, previousUp, OffsetAngle, OffsetRadius);
            }

            Vector3 offsetlesPosition;
            Vector3 offsetPosition;
            {
                float offsetlesRelativePosition;
                {
                    offsetlesRelativePosition = RelativePosition;
                    MovementDirection curvyDirection = m_Direction;
                    SimulateAdvance(ref offsetlesRelativePosition, ref curvyDirection, Speed, deltaTime);
                }

                Vector3 offsetlesTangent;
                Vector3 offsetlesUp;
                GetInterpolatedSourcePosition(offsetlesRelativePosition, out offsetlesPosition, out offsetlesTangent, out offsetlesUp);

                offsetPosition = ApplyOffset(offsetlesPosition, offsetlesTangent, offsetlesUp, OffsetAngle, OffsetRadius);
            }

            float deltaPosition = (offsetlesPosition - previousOffsetlesPosition).magnitude;
            float deltaOffsetPosition = (previousOffsetPosition - offsetPosition).magnitude;
            float ratio = (deltaPosition / deltaOffsetPosition);
            return Speed * (float.IsNaN(ratio) ? 1 : ratio);
        }

        //TODO This should be a local method when all supported unity versions will handle C#7
        /// <summary>
        /// Gets the Up and Forward of the orientation when the <see cref="OrientationMode"/> is set to <see cref="OrientationModeEnum.None"/>
        /// </summary>
        private void GetOrientationNoneUpAndForward(out Vector3 targetUp, out Vector3 targetForward)
        {
            if (LockRotation)
            {
                targetUp = LockedRotation * Vector3.up;
                targetForward = LockedRotation * Vector3.forward;
            }
            else
            {
                GetPositionAndRotation(out _, out Quaternion rotation);

                targetUp = rotation * Vector3.up;
                targetForward = rotation * Vector3.forward;
            }
        }
        #region Rigibody target handling
        private bool IsNeededRigidbodyMissing
        {
            get
            {
                return targetComponent == TargetComponent.KinematicRigidbody && Rigidbody == null;
            }
        }

        private bool IsNeeded2DRigidbodyMissing
        {
            get
            {
                return targetComponent == TargetComponent.KinematicRigidbody2D && Rigidbody2D == null;
            }
        }

        private bool IsNeededRigidbodyNotKinematic
        {
            get
            {
                Rigidbody localRigidBody = Rigidbody;
                return targetComponent == TargetComponent.KinematicRigidbody && localRigidBody != null && localRigidBody.isKinematic == false;
            }
        }

        private bool IsNeeded2DRigidbodyNotKinematic
        {
            get
            {
                Rigidbody2D localRigidBody = Rigidbody2D;
                return targetComponent == TargetComponent.KinematicRigidbody2D && localRigidBody != null && localRigidBody.isKinematic == false;
            }
        }

        private bool AreConstraintsConflicting
        {
            get
            {
                Rigidbody localRigidBody;
                Rigidbody2D localRigidBody2D;
                bool isConflicting;
                switch (TargetComponent)
                {
                    case TargetComponent.KinematicRigidbody when (localRigidBody = Rigidbody) != null:
                        isConflicting = localRigidBody.constraints != RigidbodyConstraints.None;
                        break;
                    case TargetComponent.KinematicRigidbody2D when (localRigidBody2D = Rigidbody2D) != null:
                        isConflicting = localRigidBody2D.constraints != RigidbodyConstraints2D.None;
                        break;
                    default:
                        isConflicting = false;
                        break;
                }

                return isConflicting;
            }
        }

        #endregion

        #endregion

        #region ISerializationCallbackReceiver
        /*! \cond PRIVATE */
        /// <summary>
        /// Implementation of UnityEngine.ISerializationCallbackReceiver
        /// Called automatically by Unity, is not meant to be called by Curvy's users
        /// </summary>
        public void OnBeforeSerialize()
        {
        }

        /// <summary>
        /// Implementation of UnityEngine.ISerializationCallbackReceiver
        /// Called automatically by Unity, is not meant to be called by Curvy's users
        /// </summary>
        public virtual void OnAfterDeserialize()
        {
            if (m_Speed < 0)
            {
                m_Speed = Mathf.Abs(m_Speed);
                m_Direction = MovementDirection.Backward;
            }

            //Merged AbsolutePrecise and AbsoluteExtrapolate into one value
            if ((short)MoveMode == 2)
                MoveMode = MoveModeEnum.AbsolutePrecise;
        }
        /*! \endcond */
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/CurvyController.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/MotionConstraints.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5e008b0661a3c064083d0fff5655a116
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// Defines what motions are to be frozen
    /// </summary>
    [System.Flags]
    public enum MotionConstraints
    {
        /// <summary>
        /// No constraints.
        /// </summary>
        None = 0,
        /// <summary>
        /// Freeze motion along the X-axis.
        /// </summary>
        FreezePositionX = 1 << 0,
        /// <summary>
        /// Freeze motion along the Y-axis.
        /// </summary>
        FreezePositionY = 1 << 1,
        /// <summary>
        /// Freeze motion along the Z-axis.
        /// </summary>
        FreezePositionZ = 1 << 2,
        /// <summary>
        /// Freeze rotation along the X-axis.
        /// </summary>
        FreezeRotationX = 1 << 3,
        /// <summary>
        /// Freeze rotation along the Y-axis.
        /// </summary>
        FreezeRotationY = 1 << 4,
        /// <summary>
        /// Freeze rotation along the Z-axis.
        /// </summary>
        FreezeRotationZ = 1 << 5,

        #region Hidden because of inspector not handling it properly
        /*
        /// <summary>
        /// Freeze motion along all axes.
        /// </summary>
        FreezePosition = FreezePositionX | FreezePositionY | FreezePositionZ,
        /// <summary>
        /// Freeze rotation along all axes.
        /// </summary>
        FreezeRotation = FreezeRotationX | FreezeRotationY | FreezeRotationZ,
        /// <summary>
        /// Freeze motion along all axes.
        /// </summary>
        FreezeAll = FreezePosition | FreezeRotation
        */
        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/MotionConstraints.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/MovementDirection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d7eb8ecd5bf585346a7ad6f0646e4939
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// Defines if the controller will move the object the same direction that the spline or the opposite one
    /// </summary>
    /// <seealso cref="MovementDirectionMethods"/>
    public enum MovementDirection
    {
        /// <summary>
        /// Same direction than spline's tangent
        /// </summary>
        Forward,
        /// <summary>
        /// Opposite direction than spline's tangent
        /// </summary>
        Backward
    }
    /// <summary>
    /// Extension methods for <see cref="MovementDirection"/>
    /// </summary>
    public static class MovementDirectionMethods
    {
        /// <summary>
        /// Converts the int to a direction. Positive int means Forward, negative means backward.
        /// </summary>
        public static MovementDirection FromInt(int value)
        {
           return value >= 0
                ? MovementDirection.Forward
                : MovementDirection.Backward;
        }

        /// <summary>
        /// Returns the opposite value of the given direction value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static MovementDirection GetOpposite(this MovementDirection value)
        {
            MovementDirection result;
            switch (value)
            {
                case MovementDirection.Forward:
                    result = MovementDirection.Backward;
                    break;
                case MovementDirection.Backward:
                    result = MovementDirection.Forward;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            return result;
        }

        /// <summary>
        /// Converts the direction to an int. Positive int means Forward, negative means backward.
        /// </summary>
        public static int ToInt(this MovementDirection direction)
        {
            int result;
            switch (direction)
            {
                case MovementDirection.Forward:
                    result = 1;
                    break;
                case MovementDirection.Backward:
                    result = -1;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            return result;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/MovementDirection.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/OnPositionReachedSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 254770b4f3df24245ba3f57e7b51b875
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;

namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// Settings for events to be triggered when the controller reaches a specific position
    /// </summary>
    [System.Serializable]
    public class OnPositionReachedSettings : ISerializationCallbackReceiver
    {
        public string Name;
        public CurvySplineMoveEvent Event = new CurvySplineMoveEvent();
        public float Position;
        public CurvyPositionMode PositionMode;
        public TriggeringDirections TriggeringDirections;
        public Color GizmoColor;

        #region handling default values

        public OnPositionReachedSettings()
        {
            InitializeFieldsWithDefaultValue();
        }

        [SerializeField, HideInInspector]
        private bool initialized;

        /// <summary>
        /// Default values assigned at field initialization or at construction are overriden with default type values when instances of this class are added to a list. This method is used to fix that issue
        /// </summary>
        private void InitializeFieldsWithDefaultValue()
        {
            Name = "My Event";
            PositionMode = CurvyPositionMode.WorldUnits;
            TriggeringDirections = TriggeringDirections.All;
            GizmoColor = new Color(0.652f, 0.652f, 0.652f);
            initialized = true;
        }

        public void OnBeforeSerialize() { }

        public void OnAfterDeserialize()
        {
            //when an instance of this class is added to a list via the inspector, its fields are set to their types default values (0, false, ...). I try to detect that via this test, then assign the default values I want
            if (initialized == false)
                InitializeFieldsWithDefaultValue();
        }
        #endregion

        public OnPositionReachedSettings Clone()
        {
            return (OnPositionReachedSettings)MemberwiseClone();
        }
    }

    /// <summary>
    /// Defines what travel directions should trigger an event
    /// </summary>
    public enum TriggeringDirections
    {
        /// <summary>
        /// All directions
        /// </summary>
        All,
        /// <summary>
        /// Same direction as spline's tangent
        /// </summary>
        Forward,
        /// <summary>
        /// Opposite direction as spline's tangent
        /// </summary>
        Backward
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/OnPositionReachedSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/PathController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ec8c51951f66b4a4099916a8055d980a
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;


namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// Controller working on Curvy Generator Paths
    /// </summary>
    [AddComponentMenu("Curvy/Controllers/CG Path Controller")]
    [HelpURL(CurvySpline.DOCLINK + "pathcontroller")]
    public class PathController : CurvyController
    {

        #region ### Serialized Fields ###

        [Section("General", Sort = 0)]
        [SerializeField]
        [CGDataReferenceSelector(typeof(CGPath), Label = "Path/Slot")]
        private CGDataReference m_Path = new CGDataReference();

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Gets or sets the path to use
        /// </summary>
        public CGDataReference Path
        {
            get { return m_Path; }
            set { m_Path = value; }
        }

        /// <summary>
        /// Gets the actual CGPath data
        /// </summary>
        public CGPath PathData
        {
            get
            {
                return (Path.HasValue) ? Path.GetData<CGPath>() : null;
            }
        }

        /// <summary>
        /// Gets the source's length
        /// </summary>
        public override float Length
        {
            get
            {
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
                return (PathData != null) ? PathData.Length : 0;
            }
        }

        #endregion

        #region ### Private fields ###


        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        #endregion

        #region ### Protected Methods ###


        override public bool IsReady
        {
            get
            {
                return Path != null && !Path.IsEmpty && Path.HasValue;
            }
        }


        /// <summary>
        /// Converts distance on source from relative to absolute position.
        /// </summary>
        /// <param name="relativeDistance">relative distance from the source start. Should be already clamped</param>
        /// <returns>distance in world units from the source start</returns>
        protected override float RelativeToAbsolute(float relativeDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
            Assert.IsTrue(CurvyUtility.Approximately(relativeDistance, GetClampedPosition(relativeDistance, CurvyPositionMode.Relative, Clamping, Length)));
#endif

            return (PathData != null) ? PathData.FToDistance(relativeDistance) : 0;
        }

        /// <summary>
        /// Converts distance on source from absolute to relative position.
        /// </summary>
        /// <param name="worldUnitDistance">distance in world units from the source start. Should be already clamped</param>
        /// <returns>relative distance in the range 0..1</returns>
        protected override float AbsoluteToRelative(float worldUnitDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
            Assert.IsTrue(CurvyUtility.Approximately(worldUnitDistance, GetClampedPosition(worldUnitDistance, CurvyPositionMode.WorldUnits, Clamping, Length)));
#endif
            return (PathData != null) ? PathData.DistanceToF(worldUnitDistance) : 0;
        }

        protected override Vector3 GetInterpolatedSourcePosition(float tf)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return Path.Module.Generator.transform.TransformPoint(PathData.InterpolatePosition(tf));
        }

        protected override void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            PathData.Interpolate(tf, out interpolatedPosition, out tangent, out up);
            Transform generatorTransform = Path.Module.Generator.transform;
            interpolatedPosition = generatorTransform.TransformPoint(interpolatedPosition);
            tangent = generatorTransform.TransformDirection(tangent);
            up = generatorTransform.TransformDirection(up);
        }

        protected override Vector3 GetTangent(float tf)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return Path.Module.Generator.transform.TransformDirection(PathData.InterpolateDirection(tf));
        }

        protected override Vector3 GetOrientation(float tf)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return Path.Module.Generator.transform.TransformDirection(PathData.InterpolateUp(tf));
        }

        protected override void Advance(float speed, float deltaTime)
        {
            float tf = RelativePosition;
            MovementDirection direction = MovementDirection;

            SimulateAdvance(ref tf, ref direction, speed, deltaTime);

            MovementDirection = direction;
            RelativePosition = tf;
        }

        override protected void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            int directionInt = curyDirection.ToInt();
            switch (MoveMode)
            {
                case MoveModeEnum.Relative:
                    PathData.Move(ref tf, ref directionInt, speed * deltaTime, Clamping);
                    break;
                case MoveModeEnum.AbsolutePrecise:
                    PathData.MoveBy(ref tf, ref directionInt, speed * deltaTime, Clamping);
                    break;
                default:
                    throw new NotSupportedException();
            }
            curyDirection = MovementDirectionMethods.FromInt(directionInt);
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/PathController.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/SplineController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dacc8a2ff207fca49bdaf5d45a943d80
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using UnityEngine.Assertions;
using Random = UnityEngine.Random;

namespace FluffyUnderware.Curvy.Controllers
{

    /// <summary>
    /// Defines what spline a <see cref="SplineController"/> will use when reaching a <see cref="CurvyConnection"/>.
    /// </summary>
    public enum SplineControllerConnectionBehavior
    {
        /// <summary>
        /// Continue moving on the current spline, ignoring the connection.
        /// </summary>
        CurrentSpline,
        /// <summary>
        /// Move to the spline containing the Follow-Up if any. If none, continue moving on the current spline, ignoring the connection.
        /// </summary>
        FollowUpSpline,
        /// <summary>
        /// Move to the spline of a randomly selected control point from all the connected control points.
        /// </summary>
        RandomSpline,
        /// <summary>
        /// Move to the spline containing the Follow-Up if any. If none, move to the spline of a randomly selected control point from all the connected control points.
        /// </summary>
        FollowUpOtherwiseRandom,
        /// <summary>
        /// Use a custom defined selection logic
        /// </summary>
        Custom
    }

    /// <summary>
    /// Controller working with Splines
    /// </summary>
    [AddComponentMenu("Curvy/Controllers/Spline Controller")]
    [HelpURL(CurvySpline.DOCLINK + "splinecontroller")]
    public class SplineController : CurvyController
    {
        public SplineController()
        {
            preAllocatedEventArgs = new CurvySplineMoveEventArgs(this, Spline, null, Single.NaN, false, Single.NaN, MovementDirection.Forward);
        }

        #region ### Serialized Fields ###

        /*! \cond PRIVATE */

        /// <summary>
        /// The spline to use. It is best to set/get the spline through the <see cref="Spline"/> property instead
        /// </summary>
        [Section("General", Sort = 0)]

        [FieldCondition(nameof(m_Spline), null, false, ActionAttribute.ActionEnum.ShowError, "Missing source Spline")]
        [SerializeField]
        protected CurvySpline m_Spline;

        /*! \endcond */

        [SerializeField]
        [Tooltip("Whether spline's cache data should be used. Set this to true to gain performance if precision is not required.")]
        private bool m_UseCache;

        #region Connections handling

        [Section("Connections handling", Sort = 250, HelpURL = CurvySpline.DOCLINK + "curvycontroller_connectionshandling")]

        [SerializeField, Label("At connection, use", "What spline should the controller use when reaching a Connection")]
        private SplineControllerConnectionBehavior connectionBehavior = SplineControllerConnectionBehavior.CurrentSpline;

        #region Random Connection and Follow-Up options

        [SerializeField, Label("Allow direction change", "When true, the controller will modify its direction to best fit the connected spline")]
#if UNITY_EDITOR
        [FieldCondition(nameof(connectionBehavior), SplineControllerConnectionBehavior.FollowUpSpline, false, ConditionalAttribute.OperatorEnum.OR, "ShowRandomConnectionOptions", true, false)]
#endif

        private bool allowDirectionChange = true;

        #endregion

        #region Random Connection options

        [SerializeField, Label("Reject current spline", "Whether the current spline should be excluded from the randomly selected splines")]
        [FieldCondition(nameof(ShowRandomConnectionOptions), true)]
        private bool rejectCurrentSpline = true;

        [SerializeField, Label("Reject divergent splines", "Whether splines that diverge from the current spline with more than a specific angle should be excluded from the randomly selected splines")]
        [FieldCondition(nameof(ShowRandomConnectionOptions), true)]
        private bool rejectTooDivergentSplines = false;

        [SerializeField, Label("Max allowed angle", "Maximum allowed divergence angle in degrees")]
#if UNITY_EDITOR
        [FieldCondition(nameof(ShowRandomConnectionOptions), true, false, ConditionalAttribute.OperatorEnum.AND, "rejectTooDivergentSplines", true, false)]
#endif
        [Range(0, 180)]
        private float maxAllowedDivergenceAngle = 90;

        #endregion

        #region Custom options

        [SerializeField, Label("Custom Selector", "A custom logic to select which connected spline to follow. Select a Script inheriting from SplineControllerConnectionBehavior")]
        [FieldCondition(nameof(connectionBehavior), SplineControllerConnectionBehavior.Custom, false, ActionAttribute.ActionEnum.Show)]
        [FieldCondition(nameof(connectionCustomSelector), null, false, ActionAttribute.ActionEnum.ShowWarning, "Missing custom selector")]
        private ConnectedControlPointsSelector connectionCustomSelector;

        #endregion

        #endregion

        /*! \cond PRIVATE */

        [Section("Events", false, false, 1000, HelpURL = CurvySpline.DOCLINK + "splinecontroller_events")]
        [SerializeField]
        [ArrayEx]
        protected List<OnPositionReachedSettings> onPositionReachedList = new List<OnPositionReachedSettings>();
        [SerializeField]
        protected CurvySplineMoveEvent m_OnControlPointReached = new CurvySplineMoveEvent();
        [SerializeField]
        protected CurvySplineMoveEvent m_OnEndReached = new CurvySplineMoveEvent();
        [SerializeField]
        protected CurvySplineMoveEvent m_OnSwitch = new CurvySplineMoveEvent();

        /*! \endcond */

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Gets or sets the spline to use
        /// </summary>
        public virtual CurvySpline Spline
        {
            get { return m_Spline; }
            set
            { m_Spline = value; }
        }

        /// <summary>
        /// Gets or sets whether spline's cache data should be used
        /// </summary>
        public bool UseCache
        {
            get
            {
                return m_UseCache;
            }
            set
            {
                if (m_UseCache != value)
                    m_UseCache = value;
            }
        }


        #region Connections handling

        /// <summary>
        /// Connections handling: What spline should the controller use when reaching a Connection
        /// </summary>
        public SplineControllerConnectionBehavior ConnectionBehavior
        {
            get { return connectionBehavior; }
            set { connectionBehavior = value; }
        }

        /// <summary>
        /// Connections handling: A custom logic to select which connected spline to follow. Select a Script inheriting from SplineControllerConnectionBehavior. Is used when <see cref="ConnectionBehavior"/> is equal to <see cref="SplineControllerConnectionBehavior.Custom"/>
        /// </summary>
        public ConnectedControlPointsSelector ConnectionCustomSelector
        {
            get { return connectionCustomSelector; }
            set { connectionCustomSelector = value; }
        }

        /// <summary>
        /// Connections handling: When true, the controller will modify its direction to best fit the connected spline. Is used when <see cref="ConnectionBehavior"/> is equal to <see cref="SplineControllerConnectionBehavior.FollowUpSpline"/>,  <see cref="SplineControllerConnectionBehavior.RandomSpline"/>, or <see cref="SplineControllerConnectionBehavior.FollowUpOtherwiseRandom"/>
        /// </summary>
        public bool AllowDirectionChange
        {
            get { return allowDirectionChange; }
            set { allowDirectionChange = value; }
        }

        /// <summary>
        /// Connections handling: Whether the current spline should be excluded from the randomly selected splines. Is used when <see cref="ConnectionBehavior"/> is equal to <see cref="SplineControllerConnectionBehavior.RandomSpline"/>, or <see cref="SplineControllerConnectionBehavior.FollowUpOtherwiseRandom"/>
        /// </summary>
        public bool RejectCurrentSpline
        {
            get { return rejectCurrentSpline; }
            set { rejectCurrentSpline = value; }
        }

        /// <summary>
        /// Connections handling: Whether splines that diverge from the current spline with more than <see cref="MaxAllowedDivergenceAngle"/> should be excluded from the randomly selected splines. Is used when <see cref="ConnectionBehavior"/> is equal to <see cref="SplineControllerConnectionBehavior.RandomSpline"/>, or <see cref="SplineControllerConnectionBehavior.FollowUpOtherwiseRandom"/>
        /// </summary>
        public bool RejectTooDivergentSplines
        {
            get { return rejectTooDivergentSplines; }
            set { rejectTooDivergentSplines = value; }
        }

        /// <summary>
        /// Connections handling: Maximum allowed divergence angle in degrees. Considered when <see cref="MaxAllowedDivergenceAngle"/> is true. Is used when <see cref="ConnectionBehavior"/> is equal to <see cref="SplineControllerConnectionBehavior.RandomSpline"/>, or <see cref="SplineControllerConnectionBehavior.FollowUpOtherwiseRandom"/>
        /// </summary>
        public float MaxAllowedDivergenceAngle
        {
            get { return maxAllowedDivergenceAngle; }
            set { maxAllowedDivergenceAngle = value; }
        }

        #endregion


        /// <summary>
        /// Settings of events raised when moving over specific positions on the spline
        /// </summary>
        public List<OnPositionReachedSettings> OnPositionReachedList
        {
            get { return onPositionReachedList; }
            set { onPositionReachedList = value; }
        }

        /// <summary>
        /// Event raised when moving over a Control Point
        /// </summary>
        public CurvySplineMoveEvent OnControlPointReached
        {
            get { return m_OnControlPointReached; }
            set { m_OnControlPointReached = value; }
        }

        /// <summary>
        /// Event raised when reaching the extends (i.e. the start or end) of the source spline
        /// </summary>
        public CurvySplineMoveEvent OnEndReached
        {
            get { return m_OnEndReached; }
            set { m_OnEndReached = value; }
        }

        /// <summary>
        /// Event raised while switching splines. Splines switching is done via the <see cref="SwitchTo"/> method.
        /// </summary>
        public CurvySplineMoveEvent OnSwitch
        {
            get { return m_OnSwitch; }
            set { m_OnSwitch = value; }
        }


        /// <summary>
        /// Gets whether the Controller is switching splines
        /// </summary>
        public bool IsSwitching { get; private set; }

        /// <summary>
        /// The ratio (value between 0 and 1) expressing the progress of the current spline switch. 0 means the switch just started, 1 means the switch ended.
        /// Its value is 0 if no spline switching is in progress. Spline switching is done by calling <see cref="SwitchTo"/>
        /// </summary>
        public float SwitchProgress { get { return IsSwitching ? Mathf.Clamp01((Time.time - SwitchStartTime) / SwitchDuration) : 0; } }

        /// <summary>
        /// Gets the source's length
        /// </summary>
        public override float Length
        {
            get
            {
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
                return ReferenceEquals(Spline, null) == false ? Spline.Length : 0;
            }
        }

        #endregion

        #region ### Private & Protected Fields & Properties ###

        private CurvySpline prePlaySpline;
        private readonly CurvySplineMoveEventArgs preAllocatedEventArgs;

        #region Switch

        /// <summary>
        /// The time at which the current spline switching started.
        /// Its value is invalid if no spline switching is in progress. Spline switching is done by calling <see cref="SwitchTo"/>
        /// </summary>
        protected float SwitchStartTime;
        /// <summary>
        /// The duration of the the current spline switching.
        /// Its value is invalid if no spline switching is in progress. Spline switching is done by calling <see cref="SwitchTo"/>
        /// </summary>
        protected float SwitchDuration;
        /// <summary>
        /// The spline to which the controller is switching.
        /// Its value is invalid if no spline switching is in progress. Spline switching is done by calling <see cref="SwitchTo"/>
        /// </summary>
        protected CurvySpline SwitchTarget;
        /// <summary>
        /// The controller's current TF on the <see cref="SwitchTarget"/>.
        /// Its value is invalid if no spline switching is in progress. Spline switching is done by calling <see cref="SwitchTo"/>
        /// </summary>
        protected float TfOnSwitchTarget;
        /// <summary>
        /// The controller's current Direction on the <see cref="SwitchTarget"/>.
        /// Its value is invalid if no spline switching is in progress. Spline switching is done by calling <see cref="SwitchTo"/>
        /// </summary>
        protected MovementDirection DirectionOnSwitchTarget;

        #endregion

        #endregion

        #region ## Unity Callbacks ###

        /*! \cond UNITY */
#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            if (IsReady)
                foreach (OnPositionReachedSettings settings in OnPositionReachedList)
                    settings.Position = Mathf.Min(Mathf.Max(settings.Position, 0), GetMaxPosition(settings.PositionMode));
        }
#endif

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Start a spline switch. Should be called only on non stopped controllers.
        /// </summary>
        /// <remarks>While switching is not finished, movement on destination spline will not fire events nor consider connections</remarks>
        /// <param name="destinationSpline">the target spline to switch to</param>
        /// <param name="destinationTf">the target TF</param>
        /// <param name="duration">duration of the switch phase</param>
        public virtual void SwitchTo(CurvySpline destinationSpline, float destinationTf, float duration)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(isInitialized, ControllerNotReadyMessage);
#endif

            if (PlayState == CurvyControllerState.Stopped)
            {
                DTLog.LogError("[Curvy] Controller can not switch when stopped. The switch call will be ignored", this);
            }
            else if (duration <= 0)
            {
                DTLog.LogWarning($"[Curvy] Controller switch has a duration set to {duration}. Duration should be a strictly positive value", this);
                Spline = destinationSpline;
                RelativePosition = destinationTf;
            }
            else
            {
                SwitchStartTime = Time.time;
                SwitchDuration = duration;
                SwitchTarget = destinationSpline;
                TfOnSwitchTarget = destinationTf;
                DirectionOnSwitchTarget = MovementDirection;
                IsSwitching = true;
            }
        }

        /// <summary>
        /// If is switching splines, instantly finishes the current switch.
        /// </summary>
        public void FinishCurrentSwitch()
        {
            if (IsSwitching)
            {
                IsSwitching = false;
                Spline = SwitchTarget;
                RelativePosition = TfOnSwitchTarget;
            }
        }

        /// <summary>
        /// If is switching splines, cancels the current switch.
        /// </summary>
        public void CancelCurrentSwitch()
        {
            if (IsSwitching)
                IsSwitching = false;
        }

        /// <summary>
        /// Get the direction change, in degrees, of controller caused by the crossing of a connection.
        /// </summary>
        /// <param name="before">The control point the controller is on before crossing the connection</param>
        /// <param name="movementMode">The movement mode the controller has before crossing the connection</param>
        /// <param name="after">The control point the controller is on after crossing the connection</param>
        /// <param name="allowMovementModeChange">If true, the controller will change movemen mode to best fit the after control point. <see cref="AllowDirectionChange"/></param>
        /// <returns>A positif angle in degrees</returns>
        public static float GetAngleBetweenConnectedSplines(CurvySplineSegment before, MovementDirection movementMode, CurvySplineSegment after, bool allowMovementModeChange)
        {
            Vector3 currentTangent = before.GetTangentFast(0) * movementMode.ToInt();
            Vector3 newTangent = after.GetTangentFast(0) * GetPostConnectionDirection(after, movementMode, allowMovementModeChange).ToInt();
            return Vector3.Angle(currentTangent, newTangent);
        }

        #endregion

        #region ### Protected Methods ###

        override public bool IsReady
        {
            get
            {
                return ReferenceEquals(Spline, null) == false && Spline.IsInitialized;
            }
        }

        override protected void SavePrePlayState()
        {
            prePlaySpline = Spline;
            base.SavePrePlayState();
        }

        override protected void RestorePrePlayState()
        {
            Spline = prePlaySpline;
            base.RestorePrePlayState();
        }

        protected override float RelativeToAbsolute(float relativeDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
            Assert.IsTrue(CurvyUtility.Approximately(relativeDistance, GetClampedPosition(relativeDistance, CurvyPositionMode.Relative, Clamping, Length)));
#endif
            return Spline.TFToDistance(relativeDistance, Clamping);
        }


        protected override float AbsoluteToRelative(float worldUnitDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
            Assert.IsTrue(CurvyUtility.Approximately(worldUnitDistance, GetClampedPosition(worldUnitDistance, CurvyPositionMode.WorldUnits, Clamping, Length)));
#endif
            return Spline.DistanceToTF(worldUnitDistance, Clamping);
        }

        protected override Vector3 GetInterpolatedSourcePosition(float tf)
        {
            Vector3 p = (UseCache) ? Spline.InterpolateFast(tf) : Spline.Interpolate(tf);

            return Spline.transform.TransformPoint(p);
        }


        protected override void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up)
        {
            CurvySpline spline = Spline;
            Transform splineTransform = spline.transform;

            float localF;
            CurvySplineSegment currentSegment = spline.TFToSegment(tf, out localF);
            if (ReferenceEquals(currentSegment, null) == false)
            {
                if (UseCache)
                    currentSegment.InterpolateAndGetTangentFast(localF, out interpolatedPosition, out tangent);
                else
                    currentSegment.InterpolateAndGetTangent(localF, out interpolatedPosition, out tangent);
                up = currentSegment.GetOrientationUpFast(localF);
            }

            else
            {
                interpolatedPosition = Vector3.zero;
                tangent = Vector3.zero;
                up = Vector3.zero;
            }

            interpolatedPosition = splineTransform.TransformPoint(interpolatedPosition);
            tangent = splineTransform.TransformDirection(tangent);
            up = splineTransform.TransformDirection(up);
        }

        protected override Vector3 GetTangent(float tf)
        {
            Vector3 t = (UseCache) ? Spline.GetTangentFast(tf) : Spline.GetTangent(tf);
            return Spline.transform.TransformDirection(t);
        }

        protected override Vector3 GetOrientation(float tf)
        {
            return Spline.transform.TransformDirection(Spline.GetOrientationUpFast(tf));
        }

        protected override void Advance(float speed, float deltaTime)
        {
            float distance = speed * deltaTime;

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(distance > 0);
#endif

            if (Spline.Count != 0)
                EventAwareMove(distance);


            if (IsSwitching && SwitchTarget.Count > 0)
            {
                SimulateAdvanceOnSpline(ref TfOnSwitchTarget, ref DirectionOnSwitchTarget, SwitchTarget, speed * deltaTime);

                preAllocatedEventArgs.Set_INTERNAL(this, SwitchTarget, null, TfOnSwitchTarget, SwitchProgress, DirectionOnSwitchTarget, false);
                OnSwitch.Invoke(preAllocatedEventArgs);
                if (preAllocatedEventArgs.Cancel)
                    CancelCurrentSwitch();
            }
        }

        override protected void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime)
        {
            SimulateAdvanceOnSpline(ref tf, ref curyDirection, Spline, speed * deltaTime);
        }

        private void SimulateAdvanceOnSpline(ref float tf, ref MovementDirection curyDirection, CurvySpline spline, float distance)
        {
            if (spline.Count > 0)
            {
                int directionInt = curyDirection.ToInt();
                switch (MoveMode)
                {
                    case MoveModeEnum.AbsolutePrecise:
                        tf = spline.DistanceToTF(spline.ClampDistance(spline.TFToDistance(tf) + distance * directionInt, ref directionInt, Clamping));
                        break;
                    case MoveModeEnum.Relative:
                        tf = CurvyUtility.ClampTF(tf + distance * directionInt, ref directionInt, Clamping);
                        break;
                    default:
                        throw new NotSupportedException();
                }
                curyDirection = MovementDirectionMethods.FromInt(directionInt);
            }
        }

        override protected void InitializedApplyDeltaTime(float deltaTime)
        {
            if (Spline.Dirty)
                Spline.Refresh();

            base.InitializedApplyDeltaTime(deltaTime);

            if (IsSwitching && SwitchProgress >= 1)
                FinishCurrentSwitch();
        }

        override protected void ComputeTargetPositionAndRotation(out Vector3 targetPosition, out Vector3 targetUp, out Vector3 targetForward)
        {
            Vector3 switchlessPosition;
            Vector3 switchlessUp;
            Vector3 switchlessForward;
            base.ComputeTargetPositionAndRotation(out switchlessPosition, out switchlessUp, out switchlessForward);
            Quaternion switchlessRotation = Quaternion.LookRotation(switchlessForward, switchlessUp);

            if (IsSwitching)
            {
                CurvySpline preSwitchSpline = Spline;
                float preSwitchSplineTf = RelativePosition;

                m_Spline = SwitchTarget;
                RelativePosition = TfOnSwitchTarget;

                Vector3 positionOnSwitchToSpline;
                Vector3 upOnSwitchToSpline;
                Vector3 forwardOnSwitchToSpline;
                base.ComputeTargetPositionAndRotation(out positionOnSwitchToSpline, out upOnSwitchToSpline, out forwardOnSwitchToSpline);
                Quaternion rotationOnSwitchToSpline = Quaternion.LookRotation(forwardOnSwitchToSpline, upOnSwitchToSpline);

                m_Spline = preSwitchSpline;
                RelativePosition = preSwitchSplineTf;

                targetPosition = OptimizedOperators.LerpUnclamped(switchlessPosition, positionOnSwitchToSpline, SwitchProgress);
                Quaternion interpolatedRotation = Quaternion.LerpUnclamped(switchlessRotation, rotationOnSwitchToSpline, SwitchProgress);
                targetUp = interpolatedRotation * Vector3.up;
                targetForward = interpolatedRotation * Vector3.forward;
            }
            else
            {
                targetPosition = switchlessPosition;
                targetUp = switchlessUp;
                targetForward = switchlessForward;
            }
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */

        /// <summary>
        /// This method gets the controller position, but handles the looping differently than usual (it does not change a relative position of 1 to 0), which avoids hardly solvable ambiguities in the movement logic.
        /// </summary>
        /// <remarks>This is to make controller logic simpler, since it does not need anymore to guess if a position of 0 meant controller on the end of the spline and needed looping, or meant that the controller is on the start of the spline.</remarks>
        /// <param name="positionMode"> The one of the returned position</param>
        /// <param name="clampedPosition"> Uses the controller's <see cref="CurvyController.PositionMode"/></param>
        private static float MovementCompatibleGetPosition(SplineController controller, float clampedPosition, CurvyPositionMode positionMode, out CurvySplineSegment controlPoint, out bool isOnControlPoint)
        {

            float resultPosition;
            CurvySpline spline = controller.Spline;

            bool isOnSegmentLastCp;
            bool isOnSegmentFirstCp;
            float unconvertedLocalPosition;
            switch (controller.PositionMode)
            {
                case CurvyPositionMode.Relative:
                    controlPoint = spline.TFToSegment(clampedPosition, out unconvertedLocalPosition, out isOnSegmentFirstCp, out isOnSegmentLastCp, CurvyClamping.Clamp); //CurvyClamping.Clamp to cancel looping handling
                    break;
                case CurvyPositionMode.WorldUnits:
                    controlPoint = spline.DistanceToSegment(clampedPosition, out unconvertedLocalPosition, out isOnSegmentFirstCp, out isOnSegmentLastCp, CurvyClamping.Clamp); //CurvyClamping.Clamp to cancel looping handling
                    break;
                default:
                    throw new NotSupportedException();
            }

            if (positionMode == controller.PositionMode)
                resultPosition = clampedPosition;
            else
            {
                switch (positionMode)
                {
                    case CurvyPositionMode.Relative:
                        resultPosition = spline.SegmentToTF(controlPoint, controlPoint.DistanceToLocalF(unconvertedLocalPosition));
                        break;
                    case CurvyPositionMode.WorldUnits:
                        resultPosition = controlPoint.Distance + controlPoint.LocalFToDistance(unconvertedLocalPosition);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

            if (isOnSegmentLastCp) //Case of last cp of an open spline
                controlPoint = spline.GetNextControlPoint(controlPoint);

            isOnControlPoint = isOnSegmentFirstCp || isOnSegmentLastCp;

            return resultPosition;
        }

        /// <summary>
        /// This method sets the controller position, but handles the looping differently than usual (it does not change a realtive position of 1 to 0), which avoids hardly solvable ambiguities in the movement logic.
        /// </summary>
        /// <remarks>This is to make controller logic simpler, since it does not need anymore to guess if a position of 0 meant controller on the end of the spline and needed looping, or meant that the controller is on the start of the spline.</remarks>
        private static void MovementCompatibleSetPosition(SplineController controller, CurvyPositionMode positionMode, float specialClampedPosition)
        {
            float clampedPosition = specialClampedPosition;

            if (positionMode == controller.PositionMode)
                controller.m_Position = clampedPosition;
            else
                switch (positionMode)
                {
                    case CurvyPositionMode.Relative:
                        controller.m_Position = controller.Spline.TFToDistance(clampedPosition, controller.Clamping);
                        break;
                    case CurvyPositionMode.WorldUnits:
                        controller.m_Position = controller.Spline.DistanceToTF(clampedPosition, controller.Clamping);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
        }

        private const string InvalidSegmentErrorMessage = "[Curvy] Controller {0} reached segment {1} which is invalid segment because it has a length of 0. Please fix the invalid segment to avoid issues with the controller";

        /// <summary>
        /// Updates position and direction while triggering events when reaching a control point
        /// </summary>
        /// <param name="distance"></param>
        /// <param name="positionMode">The position mode used in the computations. Could be different than SplineController.PositionMode</param>
        private void EventAwareMove(float distance)
        {
#if CURVY_SANITY_CHECKS
            MoveModeEnum moveModeAtMethodStart = MoveMode;
            Assert.IsTrue(distance > 0);
#endif
            CurvyPositionMode movementRelatedPositionMode;
            switch (MoveMode)
            {
                case MoveModeEnum.AbsolutePrecise:
                    movementRelatedPositionMode = CurvyPositionMode.WorldUnits;
                    break;
                case MoveModeEnum.Relative:
                    movementRelatedPositionMode = CurvyPositionMode.Relative;
                    break;
                default:
                    throw new NotSupportedException();
            }

            float currentDelta = distance;

            bool cancelMovement = false;

            //Handle when controller starts at special position
            switch (MovementDirection)
            {
                case MovementDirection.Backward:
                    if (m_Position == 0)
                        if (Clamping == CurvyClamping.PingPong)
                            MovementDirection = MovementDirection.GetOpposite();
                        else if (Clamping == CurvyClamping.Clamp)
                            return;
                    break;
                case MovementDirection.Forward:
                    float upperLimit;
                    {
                        switch (PositionMode)
                        {
                            case CurvyPositionMode.Relative:
                                upperLimit = 1f;
                                break;
                            case CurvyPositionMode.WorldUnits:
                                upperLimit = m_Spline.Length;
                                break;
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                    if (m_Position == upperLimit)
                        if (Clamping == CurvyClamping.PingPong)
                            MovementDirection = MovementDirection.GetOpposite();
                        else if (Clamping == CurvyClamping.Clamp)
                            return;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            CurvySplineSegment currentCp;
            bool isOnCp;
            float movementCompatibleCurrentPosition;
            movementCompatibleCurrentPosition = MovementCompatibleGetPosition(this, m_Position, movementRelatedPositionMode, out currentCp, out isOnCp);

            if (currentCp.Length == 0 && Spline.IsControlPointASegment(currentCp))
                DTLog.LogWarning(String.Format(InvalidSegmentErrorMessage, this.name, currentCp), this);

            int infiniteLoopSafety = 10000;
            while (!cancelMovement && currentDelta > 0 && infiniteLoopSafety-- > 0)
            {

#if CURVY_SANITY_CHECKS
                Assert.IsTrue(Spline.Count > 0);
                Assert.IsTrue(moveModeAtMethodStart == MoveMode);// MoveMode is not allowed to be modified while moving a Spline Controller;
#endif
                CurvySplineSegment candidateControlPoint;
                {
                    if (MovementDirection == MovementDirection.Forward)
                        candidateControlPoint = Spline.GetNextControlPoint(currentCp);
                    else
                        candidateControlPoint = isOnCp
                            ? Spline.GetPreviousControlPoint(currentCp)
                            : currentCp;
                }

                if (ReferenceEquals(candidateControlPoint, null) == false && Spline.IsControlPointVisible(candidateControlPoint))
                {
                    float candidateControlPointPosition;
                    {
                        candidateControlPointPosition = GetControlPointPosition(candidateControlPoint, movementRelatedPositionMode);
                        //handles first cp of closed spline having two values: 0 and max value
                        if (MovementDirection == MovementDirection.Forward && m_Spline.Closed && candidateControlPointPosition == 0)
                            candidateControlPointPosition = GetMaxPosition(movementRelatedPositionMode);
                    }

                    float distanceToCandidate = Mathf.Abs(candidateControlPointPosition - movementCompatibleCurrentPosition);

                    float postEventsEndPosition;

                    if (distanceToCandidate > currentDelta)//If no more control point to reach, move the controller and exit
                    {
                        float movementCompatibleNewPosition_Unclamped = movementCompatibleCurrentPosition + currentDelta * MovementDirection.ToInt();

                        float movementCompatibleNewPosition_Clamped = GetClampedPosition(movementCompatibleNewPosition_Unclamped, movementRelatedPositionMode, Clamping, m_Spline.Length);

                        HandleOnPositionReachedEvents(movementRelatedPositionMode,
                            movementCompatibleCurrentPosition,
                            movementCompatibleNewPosition_Clamped,
                            movementCompatibleNewPosition_Unclamped,
                            out postEventsEndPosition,
                            currentDelta,
                            currentCp,
                            ref cancelMovement);

                        MovementCompatibleSetPosition(this, movementRelatedPositionMode, postEventsEndPosition);

                        break;
                    }

                    HandleOnPositionReachedEvents(movementRelatedPositionMode,
                        movementCompatibleCurrentPosition,
                        candidateControlPointPosition,
                        candidateControlPointPosition,
                        out postEventsEndPosition,
                        currentDelta,
                        currentCp,
                        ref cancelMovement);

                    if (postEventsEndPosition.Approximately(candidateControlPointPosition) == false)
                    {
                        DTLog.LogWarning($"[Curvy] Spline Controller {name}: Position was modified in an {nameof(OnPositionReachedList)} event handler. That modification will be ignored to prioritize the controller reaching a new control point. You can use the {nameof(OnControlPointReached)} event or {(nameof(OnEndReached))} instead. If this behavior is problematic, please contact the developers.", this);
                    }

                    currentDelta -= distanceToCandidate;

                    //Move to next control point
                    HandleReachingNewControlPoint(candidateControlPoint, candidateControlPointPosition, movementRelatedPositionMode, currentDelta, ref cancelMovement, out currentCp, out isOnCp, out movementCompatibleCurrentPosition);
                }

                //handle connection
                {
                    if (isOnCp && currentCp.Connection && currentCp.Connection.ControlPointsList.Count > 1)
                    {
                        MovementDirection newDirection;
                        CurvySplineSegment postConnectionHandlingControlPoint;
                        switch (ConnectionBehavior)
                        {
                            case SplineControllerConnectionBehavior.CurrentSpline:
                                postConnectionHandlingControlPoint = currentCp;
                                newDirection = MovementDirection;
                                break;
                            case SplineControllerConnectionBehavior.FollowUpSpline:
                                postConnectionHandlingControlPoint = HandleFollowUpConnectionBehavior(currentCp, MovementDirection, out newDirection);
                                break;
                            case SplineControllerConnectionBehavior.FollowUpOtherwiseRandom:
                                postConnectionHandlingControlPoint = currentCp.FollowUp
                                    ? HandleFollowUpConnectionBehavior(currentCp, MovementDirection, out newDirection)
                                    : HandleRandomConnectionBehavior(currentCp, MovementDirection, out newDirection, currentCp.Connection.ControlPointsList);
                                break;
                            case SplineControllerConnectionBehavior.RandomSpline:
                                postConnectionHandlingControlPoint = HandleRandomConnectionBehavior(currentCp, MovementDirection, out newDirection, currentCp.Connection.ControlPointsList);
                                break;
                            case SplineControllerConnectionBehavior.Custom:
                                if (ConnectionCustomSelector == null)
                                {
                                    DTLog.LogError("[Curvy] You need to set a non null ConnectionCustomSelector when using SplineControllerConnectionBehavior.Custom", this);
                                    postConnectionHandlingControlPoint = currentCp;
                                }
                                else
                                    postConnectionHandlingControlPoint = ConnectionCustomSelector.SelectConnectedControlPoint(this, currentCp.Connection, currentCp);
                                newDirection = MovementDirection;
                                break;
                            default:
                                throw new ArgumentOutOfRangeException();
                        }

                        if (ReferenceEquals(postConnectionHandlingControlPoint, currentCp) == false)
                        {
                            MovementDirection = newDirection;
                            float postConnectionHandlingControlPointPosition = GetControlPointPosition(postConnectionHandlingControlPoint, movementRelatedPositionMode);
                            HandleReachingNewControlPoint(postConnectionHandlingControlPoint, postConnectionHandlingControlPointPosition, movementRelatedPositionMode, currentDelta, ref cancelMovement, out currentCp, out isOnCp, out movementCompatibleCurrentPosition);
                        }
                    }
                }

                //handle clamping
                {
                    if (isOnCp)
                    {
                        switch (Clamping)
                        {
                            case CurvyClamping.Loop:
                                if (Spline.Closed == false)
                                {
                                    CurvySplineSegment newControlPoint;
                                    if (MovementDirection == MovementDirection.Backward && ReferenceEquals(currentCp, Spline.FirstVisibleControlPoint))
                                        newControlPoint = Spline.LastVisibleControlPoint;
                                    else if (MovementDirection == MovementDirection.Forward && ReferenceEquals(currentCp, Spline.LastVisibleControlPoint))
                                        newControlPoint = Spline.FirstVisibleControlPoint;
                                    else
                                        newControlPoint = null;

                                    if (ReferenceEquals(newControlPoint, null) == false)
                                    {
                                        float newControlPointPosition = GetControlPointPosition(newControlPoint, movementRelatedPositionMode);
                                        HandleReachingNewControlPoint(newControlPoint, newControlPointPosition, movementRelatedPositionMode, currentDelta, ref cancelMovement, out currentCp, out isOnCp, out movementCompatibleCurrentPosition);
                                    }
                                }
                                break;
                            case CurvyClamping.Clamp:
                                if ((MovementDirection == MovementDirection.Backward && ReferenceEquals(currentCp, Spline.FirstVisibleControlPoint)) ||
                                    (MovementDirection == MovementDirection.Forward && ReferenceEquals(currentCp, Spline.LastVisibleControlPoint)))
                                    currentDelta = 0;
                                break;
                            case CurvyClamping.PingPong:
                                if ((MovementDirection == MovementDirection.Backward && ReferenceEquals(currentCp, Spline.FirstVisibleControlPoint)) ||
                                    (MovementDirection == MovementDirection.Forward && ReferenceEquals(currentCp, Spline.LastVisibleControlPoint)))
                                    MovementDirection = MovementDirection.GetOpposite();
                                break;
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                }
            }

            if (infiniteLoopSafety <= 0)
                DTLog.LogError(String.Format("[Curvy] Unexpected behavior in Spline Controller '{0}'. Please raise a Bug Report.", name), this);

        }

        /// <summary>
        /// Triggers relevant OnPositionReached events if any.
        /// </summary>
        private void HandleOnPositionReachedEvents(
            CurvyPositionMode positionMode,
            float startPosition,
            float endPosition,
            float endPositionUnclamped,
            out float postEventsEndPosition,
            float currentDelta,
            CurvySplineSegment currentCp,
            ref bool cancelMovement)
        {

#if CURVY_SANITY_CHECKS
            switch (MovementDirection)
            {
                case MovementDirection.Forward:
                    Assert.IsTrue(startPosition <= endPositionUnclamped);
                    break;
                case MovementDirection.Backward:
                    Assert.IsTrue(startPosition > endPositionUnclamped);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
#endif

            float? nullablePostEventsEndPosition = null;
            foreach (OnPositionReachedSettings eventSettings in OnPositionReachedList)
            {
                nullablePostEventsEndPosition = HandleOnPositionReachedEvent(positionMode, startPosition, endPositionUnclamped, currentDelta, currentCp, ref cancelMovement, eventSettings, nullablePostEventsEndPosition);

                if (Spline.Closed)
                {
                    //handles first cp of closed spline having two values: 0 and max value. In the controller logic, that point has a value of max value when going forward, and 0 when going backwards. To handle this, we create two events, one for each value of the ambiguous point 

                    OnPositionReachedSettings extraEventSettings;
                    if (MovementDirection == MovementDirection.Forward 
                        && eventSettings.Position == 0)
                    {
                        extraEventSettings = eventSettings.Clone();
                        extraEventSettings.Position = GetMaxPosition(eventSettings.PositionMode);
                    }
                    else if (MovementDirection == MovementDirection.Backward 
                             && Mathf.Approximately(eventSettings.Position ,GetMaxPosition(eventSettings.PositionMode)))
                    {
                        extraEventSettings = eventSettings.Clone();
                        extraEventSettings.Position = 0;
                    }
                    else
                    {
                        extraEventSettings = null;
                    }

                    if (extraEventSettings != null)
                        nullablePostEventsEndPosition = HandleOnPositionReachedEvent(positionMode, startPosition, endPositionUnclamped, currentDelta, currentCp, ref cancelMovement, extraEventSettings, nullablePostEventsEndPosition);
                }
            }

           
            postEventsEndPosition = nullablePostEventsEndPosition ?? endPosition;
        }

        private float? HandleOnPositionReachedEvent(
            CurvyPositionMode positionMode,
            float startPosition,
            float endPositionUnclamped,
            float currentDelta,
            CurvySplineSegment currentCp,
            ref bool cancelMovement,
            OnPositionReachedSettings settings,
            float? postEventEndPosition)
        {
            //Debug.Log($"{customEvent.PositionMode} : {startPosition} {endPosition}");

            float eventPosition;
            {
                if (positionMode == settings.PositionMode)
                    eventPosition = settings.Position;
                else
                    switch (positionMode)
                    {
                        case CurvyPositionMode.Relative:
                            eventPosition = Spline.DistanceToTF(settings.Position);
                            break;
                        case CurvyPositionMode.WorldUnits:
                            eventPosition = Spline.TFToDistance(settings.Position);
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(nameof(positionMode), positionMode, null);
                    }
            }

            TriggeringDirections triggeringDirections = settings.TriggeringDirections;

            bool isForwardEventTriggered =
                (triggeringDirections == TriggeringDirections.All ||
                 triggeringDirections == TriggeringDirections.Forward) &&
                startPosition < eventPosition &&
                eventPosition <= endPositionUnclamped;
            bool isBackwardEventTriggered =
                (triggeringDirections == TriggeringDirections.All ||
                 triggeringDirections == TriggeringDirections.Backward) &&
                endPositionUnclamped <= eventPosition &&
                eventPosition < startPosition;

            if (isForwardEventTriggered || isBackwardEventTriggered)
            {
                float delta = Math.Abs(eventPosition - startPosition);

                //every custom event triggering will modify the controller's position to the event's position. This will override any possible position modification by a prior event handler
                MovementCompatibleSetPosition(this, settings.PositionMode, eventPosition);

                preAllocatedEventArgs.Set_INTERNAL(this,
                    Spline,
                    currentCp,
                    eventPosition,
                    currentDelta - delta,
                    MovementDirection,
                    settings.PositionMode == CurvyPositionMode.WorldUnits);

                InvokeEventHandler(settings.Event, preAllocatedEventArgs, positionMode, out _, out _, out postEventEndPosition);

                cancelMovement |= preAllocatedEventArgs.Cancel;
            }

            return postEventEndPosition;
        }

        /// <summary>
        /// Do operations necessary when controller reaches a new control point: setting the controller position, update its spline if necessary, and send events if necessary
        /// </summary>
        private void HandleReachingNewControlPoint(CurvySplineSegment controlPoint,
            float controlPointPosition,
            CurvyPositionMode positionMode,
            float currentDelta,
            ref bool cancelMovement,
            out CurvySplineSegment postEventsControlPoint,
            out bool postEventsIsControllerOnControlPoint,
            out float postEventsControlPointPosition)
        {
            //update state
            MovementCompatibleSetPosition(this, positionMode, controlPointPosition);
            Spline = controlPoint.Spline;
            postEventsControlPoint = controlPoint;
            postEventsIsControllerOnControlPoint = true;
            postEventsControlPointPosition = controlPointPosition;

            //handle invalid situation
            if (controlPoint.Length == 0 && Spline.IsControlPointASegment(controlPoint))
                DTLog.LogWarning(String.Format(InvalidSegmentErrorMessage, this.name, controlPoint), this);


            //setup event param
            preAllocatedEventArgs.Set_INTERNAL(this, Spline, controlPoint, controlPointPosition, currentDelta, MovementDirection, positionMode == CurvyPositionMode.WorldUnits);

            //handle OnControlPointReached
            InvokeEventHandler(OnControlPointReached, preAllocatedEventArgs, positionMode, ref postEventsControlPoint, ref postEventsIsControllerOnControlPoint, ref postEventsControlPointPosition);

            //handle OnEndReached
            if (ReferenceEquals(preAllocatedEventArgs.Spline.FirstVisibleControlPoint, preAllocatedEventArgs.ControlPoint)
                || ReferenceEquals(preAllocatedEventArgs.Spline.LastVisibleControlPoint, preAllocatedEventArgs.ControlPoint))
                InvokeEventHandler(OnEndReached, preAllocatedEventArgs, positionMode, ref postEventsControlPoint, ref postEventsIsControllerOnControlPoint, ref postEventsControlPointPosition);

            cancelMovement |= preAllocatedEventArgs.Cancel;
        }

        private void InvokeEventHandler(CurvySplineMoveEvent @event,
            CurvySplineMoveEventArgs eventArgument,
            CurvyPositionMode positionMode,
            ref CurvySplineSegment postEventsControlPoint,
            ref bool postEventsIsControllerOnControlPoint,
            ref float postEventPosition)
        {
            InvokeEventHandler(@event,
                eventArgument,
                positionMode,
                out CurvySplineSegment outControlPoint,
                out bool? outIsControllerOnControlPoint,
                out float? outPosition);

            if (outPosition != null)
                postEventPosition = outPosition.Value;
            if (outIsControllerOnControlPoint != null)
                postEventsIsControllerOnControlPoint = outIsControllerOnControlPoint.Value;
            if (outControlPoint != null)
                postEventsControlPoint = outControlPoint;

        }

        private void InvokeEventHandler(CurvySplineMoveEvent @event,
            CurvySplineMoveEventArgs eventArgument,
            CurvyPositionMode positionMode,
            out CurvySplineSegment postEventsControlPoint,
            out bool? postEventsIsControllerOnControlPoint,
            out float? postEventPosition)
        {
            //save some data before calling events to know if event handlers changed important state
            float preEventPosition = m_Position;
            CurvyPositionMode preEventPositionMode = PositionMode;
            CurvySpline preEventPositionSpline = m_Spline;
            //call event handler
            @event.Invoke(eventArgument);
            //update state if event handler changed important things
            if (m_Position != preEventPosition || PositionMode != preEventPositionMode || ReferenceEquals(m_Spline, preEventPositionSpline) == false)
            {
                postEventPosition = MovementCompatibleGetPosition(this, m_Position, positionMode, out postEventsControlPoint, out bool outIsOnCP);
                postEventsIsControllerOnControlPoint = outIsOnCP;
            }
            else
            {
                postEventsControlPoint = null;
                postEventsIsControllerOnControlPoint = null;
                postEventPosition = null;
            }
        }

        /// <summary>
        /// Get the correct control point and direction from applying the Random connection handling logic
        /// </summary>
        private CurvySplineSegment HandleRandomConnectionBehavior(CurvySplineSegment currentControlPoint, MovementDirection currentDirection, out MovementDirection newDirection, ReadOnlyCollection<CurvySplineSegment> connectedControlPoints)
        {
            //OPTIM avoid allocation
            List<CurvySplineSegment> validConnectedControlPoints = new List<CurvySplineSegment>(connectedControlPoints.Count);

            for (int index = 0; index < connectedControlPoints.Count; index++)
            {
                CurvySplineSegment controlPoint = connectedControlPoints[index];
                if (RejectCurrentSpline && controlPoint == currentControlPoint)
                    continue;

                if (RejectTooDivergentSplines)
                {
                    if (GetAngleBetweenConnectedSplines(currentControlPoint, currentDirection, controlPoint, AllowDirectionChange) > MaxAllowedDivergenceAngle)
                        continue;
                }

                validConnectedControlPoints.Add(controlPoint);
            }

            CurvySplineSegment newControlPoint = validConnectedControlPoints.Count == 0 ?
                currentControlPoint :
                validConnectedControlPoints[Random.Range(0, validConnectedControlPoints.Count)];

            newDirection = GetPostConnectionDirection(newControlPoint, currentDirection, AllowDirectionChange);

            return newControlPoint;
        }

        /// <summary>
        /// Get the direction the controller should have if moving through a specific connected Control Point
        /// </summary>
        private static MovementDirection GetPostConnectionDirection(CurvySplineSegment connectedControlPoint, MovementDirection currentDirection, bool directionChangeAllowed)
        {
            return directionChangeAllowed && connectedControlPoint.Spline.Closed == false
                ? HeadingToDirection(ConnectionHeadingEnum.Auto, connectedControlPoint, currentDirection)
                : currentDirection;
        }

        /// <summary>
        /// Get the correct control point and direction from applying the FollowUp connection handling logic
        /// </summary>
        private CurvySplineSegment HandleFollowUpConnectionBehavior(CurvySplineSegment currentControlPoint, MovementDirection currentDirection, out MovementDirection newDirection)
        {
            CurvySplineSegment newControlPoint = currentControlPoint.FollowUp
                ? currentControlPoint.FollowUp
                : currentControlPoint;

            newDirection = AllowDirectionChange && currentControlPoint.FollowUp
                ? HeadingToDirection(currentControlPoint.FollowUpHeading, currentControlPoint.FollowUp, currentDirection)
                : currentDirection;

            return newControlPoint;
        }

        /// <summary>
        /// Translates a heading value to a controller direction, based on the current control point situation
        /// </summary>
        static private MovementDirection HeadingToDirection(ConnectionHeadingEnum heading, CurvySplineSegment controlPoint, MovementDirection currentDirection)
        {
            MovementDirection newDirection;
            ConnectionHeadingEnum resolveHeading = heading.ResolveAuto(controlPoint);

            switch (resolveHeading)
            {
                case ConnectionHeadingEnum.Minus:
                    newDirection = MovementDirection.Backward;
                    break;
                case ConnectionHeadingEnum.Sharp:
                    newDirection = currentDirection;
                    break;
                case ConnectionHeadingEnum.Plus:
                    newDirection = MovementDirection.Forward;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            return newDirection;
        }


        /// <summary>
        /// Get the controller position corresponding to a specific control point
        /// </summary>
        private static float GetControlPointPosition(CurvySplineSegment controlPoint, CurvyPositionMode positionMode)
        {
            float position;
            switch (positionMode)
            {
                case CurvyPositionMode.Relative:
                    position = controlPoint.TF;
                    break;
                case CurvyPositionMode.WorldUnits:
                    position = controlPoint.Distance;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            return position;
        }

        /// <summary>
        /// Used as a field condition
        /// </summary>
        private bool ShowRandomConnectionOptions { get { return ConnectionBehavior == SplineControllerConnectionBehavior.FollowUpOtherwiseRandom || ConnectionBehavior == SplineControllerConnectionBehavior.RandomSpline; } }

        /*! \endcond */

        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/SplineController.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/TargetComponent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 39383bb6a7d43ce4591337c8a3c75e7b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// Defines what is the component controlled by the controller
    /// </summary>
    public enum TargetComponent
    {
        /// <summary>
        /// A transform
        /// </summary>
        Transform,
        /// <summary>
        /// A Rigidbody that is set to be kinematic
        /// </summary>
        KinematicRigidbody,
        /// <summary>
        /// A Rigidbody2D that is set to be kinematic
        /// </summary>
        KinematicRigidbody2D
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/TargetComponent.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/UITextSplineController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f3ff25939a248e146b6f134422bd0a55
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using UnityEngine.UI;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Pools;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// SplineController modifying uGUI text
    /// </summary>
    [RequireComponent(typeof(Text))]
    [AddComponentMenu("Curvy/Controllers/UI Text Spline Controller")]
    [HelpURL(CurvySpline.DOCLINK + "uitextsplinecontroller")]
    public class UITextSplineController : SplineController, IMeshModifier
    {
        protected interface IGlyph
        {
            Vector3 Center { get; }
            void Transpose(Vector3 v);
            void Rotate(Quaternion rotation);
        }

        protected class GlyphQuad : IGlyph
        {
            public UIVertex[] V = new UIVertex[4];
            public Rect Rect;
            public Vector3 Center { get { return Rect.center; } }

            public void Load(List<UIVertex> verts, int index)
            {
                V[0] = verts[index];
                V[1] = verts[index + 1];
                V[2] = verts[index + 2];
                V[3] = verts[index + 3];

                calcRect();
            }

            public void LoadTris(List<UIVertex> verts, int index)
            {
                V[0] = verts[index];
                V[1] = verts[index + 1];
                V[2] = verts[index + 2];
                V[3] = verts[index + 4];
                calcRect();
            }

            public void calcRect()
            {
                Rect = new Rect(V[0].position.x,
                              V[2].position.y,
                              V[2].position.x - V[0].position.x,
                              V[0].position.y - V[2].position.y);
            }

            public void Save(List<UIVertex> verts, int index)
            {
                verts[index] = V[0];
                verts[index + 1] = V[1];
                verts[index + 2] = V[2];
                verts[index + 3] = V[3];
            }

            public void Save(VertexHelper vh)
            {
                vh.AddUIVertexQuad(V);
            }

            public void Transpose(Vector3 v)
            {
                for (int i = 0; i < 4; i++)
                    V[i].position += v;

            }

            public void Rotate(Quaternion rotation)
            {
                for (int i = 0; i < 4; i++)
                    V[i].position = V[i].position.RotateAround(Center, rotation);
            }

        }

        protected class GlyphPlain : IGlyph
        {
            public Vector3[] V = new Vector3[4];
            public Rect Rect;
            public Vector3 Center { get { return Rect.center; } }

            public void Load(ref Vector3[] verts, int index)
            {
                V[0] = verts[index];
                V[1] = verts[index + 1];
                V[2] = verts[index + 2];
                V[3] = verts[index + 3];

                calcRect();
            }

            public void calcRect()
            {
                Rect = new Rect(V[0].x,
                              V[2].y,
                              V[2].x - V[0].x,
                              V[0].y - V[2].y);
            }

            public void Save(ref Vector3[] verts, int index)
            {
                verts[index] = V[0];
                verts[index + 1] = V[1];
                verts[index + 2] = V[2];
                verts[index + 3] = V[3];
            }

            public void Transpose(Vector3 v)
            {
                for (int i = 0; i < 4; i++)
                    V[i] += v;

            }

            public void Rotate(Quaternion rotation)
            {
                for (int i = 0; i < 4; i++)
                    V[i] = V[i].RotateAround(Center, rotation);
            }

        }

        #region ### Serialized Fields ###

        [Section("Orientation")]
        [Tooltip("If true, the text characters will keep the same orientation regardless of the spline they follow")]
        [SerializeField]
        private bool staticOrientation;

        #endregion

        #region Public properties

        /// <summary>
        /// If true, the text characters will keep the same orientation regardless of the spline they follow
        /// </summary>
        public bool StaticOrientation
        {
            get { return staticOrientation; }
            set
            {
                staticOrientation = value;
            }
        }

        #endregion


        #region Conditional display in the inspector of CurvyController properties

        protected override bool ShowOrientationSection
        {
            get { return false; }
        }
        protected override bool ShowOffsetSection
        {
            get { return false; }
        }

        #endregion

        private Graphic m_Graphic;
        private RectTransform mRect;
        private Text mText;



        protected Text Text
        {
            get
            {
                if (mText == null)
                    mText = GetComponent<Text>();
                return mText;
            }
        }

        protected RectTransform Rect
        {
            get
            {
                if (mRect == null)
                    mRect = GetComponent<RectTransform>();
                return mRect;
            }
        }

        protected Graphic graphic
        {
            get
            {
                if (m_Graphic == null)
                    m_Graphic = GetComponent<Graphic>();

                return m_Graphic;
            }
        }

        protected override void InitializedApplyDeltaTime(float deltaTime)
        {
            base.InitializedApplyDeltaTime(deltaTime);
            graphic.SetVerticesDirty();
        }

        public void ModifyMesh(Mesh verts)
        {
            if (enabled && gameObject.activeInHierarchy && isInitialized)
            {
                Vector3[] vtArray = verts.vertices;
                GlyphPlain glyph = new GlyphPlain();
                for (int c = 0; c < Text.text.Length; c++)
                {
                    glyph.Load(ref vtArray, c * 4);
                    UpdateGlyph(glyph);
                    glyph.Save(ref vtArray, c * 4);
                }
                verts.vertices = vtArray;
                ArrayPools.Vector3.Free(vtArray);
            }
        }


        public void ModifyMesh(VertexHelper vertexHelper)
        {
            if (enabled && gameObject.activeInHierarchy && isInitialized)
            {
                List<UIVertex> verts = new List<UIVertex>();
                GlyphQuad glyph = new GlyphQuad();

                vertexHelper.GetUIVertexStream(verts);
                vertexHelper.Clear();

                int readingIndex = 0;
                for (int letterIndex = 0; letterIndex < Text.text.Length; letterIndex++)
                {
                    if (Text.text[letterIndex] == ' ')
                        continue;

                    glyph.LoadTris(verts, readingIndex * 6);
                    readingIndex++;
                    UpdateGlyph(glyph);
                    glyph.Save(vertexHelper);
                }
            }
        }

        private void UpdateGlyph(IGlyph glyph)
        {
            //OPTIM use InterpolateAndGetTangent
            float glyphTf = AbsoluteToRelative(GetClampedPosition(AbsolutePosition + glyph.Center.x, CurvyPositionMode.WorldUnits, Clamping, Length));

            // shift to match baseline
            glyph.Transpose(new Vector3(0, glyph.Center.y, 0));

            // Rotate
            if (StaticOrientation == false)
            {
                Vector3 glyphTangent = GetTangent(glyphTf);
                glyph.Rotate(Quaternion.AngleAxis(Mathf.Atan2(glyphTangent.x, -glyphTangent.y) * Mathf.Rad2Deg - 90, Vector3.forward));
            }

            // Center on controller's position
            glyph.Transpose(-glyph.Center);

            // Move on the corresponding position on the spline
            float controllerTf = AbsoluteToRelative(GetClampedPosition(AbsolutePosition, CurvyPositionMode.WorldUnits, Clamping, Length));
            Vector3 controllerPosition = (UseCache)
                ? Spline.InterpolateFast(controllerTf)
                : Spline.Interpolate(controllerTf);
            Vector3 glyphPosition = (UseCache)
                ? Spline.InterpolateFast(glyphTf)
                : Spline.Interpolate(glyphTf);
            glyph.Transpose(Spline.transform.TransformDirection(glyphPosition - controllerPosition));
        }

        #region ### Unity Callbacks ###

        protected override void OnEnable()
        {
            base.OnEnable();
            if (this.graphic != null)
            {
                this.graphic.SetVerticesDirty();
            }
        }

        protected override void OnDisable()
        {
            base.OnDisable();
            if (this.graphic != null)
            {
                this.graphic.SetVerticesDirty();
            }
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            if (isInitialized)
            {
                UnbindSplineRelatedEvents();
                BindSplineRelatedEvents();
            }
            base.OnValidate();
            if (this.graphic != null)
            {
                this.graphic.SetVerticesDirty();
            }
        }
#endif

        #endregion

        #region Spline refreshing


        public override CurvySpline Spline
        {
            get { return m_Spline; }
            set
            {
                if (m_Spline != value)
                {
                    if (isInitialized)
                        UnbindSplineRelatedEvents();

                    m_Spline = value;
                    if (isInitialized)
                        BindSplineRelatedEvents();
                }
            }
        }

        protected override void BindEvents()
        {
            base.BindEvents();
            BindSplineRelatedEvents();
        }

        protected override void UnbindEvents()
        {
            base.UnbindEvents();
            UnbindSplineRelatedEvents();
        }

        private void BindSplineRelatedEvents()
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(isInitialized);
#endif
            if (Spline)
            {
                UnbindSplineRelatedEvents();
                Spline.OnRefresh.AddListener(OnSplineRefreshed);
            }
        }

        private void UnbindSplineRelatedEvents()
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(isInitialized);
#endif
            if (Spline)
            {
                Spline.OnRefresh.RemoveListener(OnSplineRefreshed);
            }
        }

        private void OnSplineRefreshed(CurvySplineEventArgs e)
        {
            CurvySpline senderSpline = e.Sender as CurvySpline;
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(senderSpline != null);
#endif
            if (senderSpline != Spline)
                senderSpline.OnRefresh.RemoveListener(OnSplineRefreshed);
            else
            {
                graphic.SetVerticesDirty();
            }
        }

        #endregion


    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/UITextSplineController.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/VolumeController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 978716ea84cf827468383a8fad80663e
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.DevTools;
using FluffyUnderware.Curvy.Utils;
using UnityEngine.Assertions;
using UnityEngine.Serialization;


namespace FluffyUnderware.Curvy.Controllers
{
    /// <summary>
    /// Controller using a Curvy Generator Volume
    /// </summary>
    [AddComponentMenu("Curvy/Controllers/CG Volume Controller")]
    [HelpURL(CurvySpline.DOCLINK + "volumecontroller")]
    public class VolumeController : CurvyController
    {
        private const float CrossPositionRangeMin = -0.5f;
        private const float CrossPositionRangeMax = 0.5f;

        #region ### Serialized Fields ###

        [Section("General")]
        [CGDataReferenceSelector(typeof(CGVolume), Label = "Volume/Slot")]
        [SerializeField]
        private CGDataReference m_Volume = new CGDataReference();

        [Section("Cross Position", Sort = 1, HelpURL = CurvySpline.DOCLINK + "volumecontroller_crossposition")]
        [SerializeField]
        [FloatRegion(UseSlider = true, Precision = 4, RegionOptionsPropertyName = nameof(CrossRangeOptions), Options = AttributeOptionsFlags.Full)]
        private FloatRegion m_CrossRange = new FloatRegion(CrossPositionRangeMin, CrossPositionRangeMax);

        [RangeEx(nameof(MinCrossRelativePosition), nameof(MaxCrossRelativePosition))]
        [SerializeField]
        private float crossRelativePosition;

        [SerializeField] private CurvyClamping m_CrossClamping;

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Gets or sets the volume to use
        /// </summary>
        public CGDataReference Volume
        {
            get { return m_Volume; }
            set { m_Volume = value; }
        }

        /// <summary>
        /// Gets the actual volume data
        /// </summary>
        public CGVolume VolumeData
        {
            get
            {
                return (Volume.HasValue) ? Volume.GetData<CGVolume>() : null;
            }
        }

        public float CrossFrom
        {
            get { return m_CrossRange.From; }
            set { m_CrossRange.From = Mathf.Clamp(value, CrossPositionRangeMin, CrossPositionRangeMax); }
        }

        public float CrossTo
        {
            get { return m_CrossRange.To; }
            set { m_CrossRange.To = Mathf.Clamp(value, CrossFrom, CrossPositionRangeMax); }
        }

        public float CrossLength
        {
            get { return m_CrossRange.Length; }
        }


        /// <summary>
        /// Gets or sets the clamping mode for lateral movement
        /// </summary>
        public CurvyClamping CrossClamping
        {
            get { return m_CrossClamping; }
            set
            {
                m_CrossClamping = value;
            }
        }

        /// <summary>
        /// Gets or sets the current relative lateral position, respecting clamping. Ranges from <see cref="CrossFrom"/> to <see cref="CrossTo"/>
        /// </summary>
        public float CrossRelativePosition
        {
            get { return GetClampedCrossPosition(crossRelativePosition); }
            set { crossRelativePosition = GetClampedCrossPosition(value); }
        }

        /// <summary>
        /// Gets the source's length
        /// </summary>
        public override float Length
        {
            get
            {
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
                return (VolumeData != null) ? VolumeData.Length : 0;
            }
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Converts relative lateral to absolute position, respecting clamping, ignoring CrossRange
        /// </summary>
        /// <param name="relativeDistance">the relative position</param>
        /// <returns>the absolute position</returns>
        public float CrossRelativeToAbsolute(float relativeDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return (VolumeData != null) ? VolumeData.CrossFToDistance(RelativePosition, relativeDistance, CrossClamping) : 0;
        }

        /// <summary>
        /// Converts absolute lateral to relative position, respecting clamping, ignoring CrossRange
        /// </summary>
        /// <param name="worldUnitDistance">the absolute position</param>
        /// <returns>the relative position</returns>
        public float CrossAbsoluteToRelative(float worldUnitDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return (VolumeData != null) ? VolumeData.CrossDistanceToF(RelativePosition, worldUnitDistance, CrossClamping) : 0;
        }

        #endregion

        #region ### Protected Methods ###

        override public bool IsReady
        {
            get
            {
                return Volume != null && !Volume.IsEmpty && Volume.HasValue;
            }
        }

        /// <summary>
        /// Converts distance on source from relative to absolute position.
        /// </summary>
        /// <param name="relativeDistance">relative distance from the source start. Should be already clamped</param>
        /// <returns>distance in world units from the source start</returns>
        protected override float RelativeToAbsolute(float relativeDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
            Assert.IsTrue(CurvyUtility.Approximately(relativeDistance, GetClampedPosition(relativeDistance, CurvyPositionMode.Relative, Clamping, Length)));
#endif
            return (VolumeData != null) ? VolumeData.FToDistance(relativeDistance) : 0;
        }

        /// <summary>
        /// Converts distance on source from absolute to relative position.
        /// </summary>
        /// <param name="worldUnitDistance">distance in world units from the source start. Should be already clamped</param>
        /// <returns>relative distance in the range 0..1</returns>
        protected override float AbsoluteToRelative(float worldUnitDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
            Assert.IsTrue(CurvyUtility.Approximately(worldUnitDistance, GetClampedPosition(worldUnitDistance, CurvyPositionMode.WorldUnits, Clamping, Length)));
#endif
            return (VolumeData != null) ? VolumeData.DistanceToF(worldUnitDistance) : 0;
        }

        protected override Vector3 GetInterpolatedSourcePosition(float tf)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return Volume.Module.Generator.transform.TransformPoint(VolumeData.InterpolateVolumePosition(tf, CrossRelativePosition));
        }

        protected override void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            VolumeData.InterpolateVolume(tf, CrossRelativePosition, out interpolatedPosition, out tangent, out up);
            Transform generatorTransform = Volume.Module.Generator.transform;
            interpolatedPosition = generatorTransform.TransformPoint(interpolatedPosition);
            tangent = generatorTransform.TransformDirection(tangent);
            up = generatorTransform.TransformDirection(up);
        }


        protected override Vector3 GetTangent(float tf)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return Volume.Module.Generator.transform.TransformDirection(VolumeData.InterpolateVolumeDirection(tf, CrossRelativePosition));
        }


        protected override Vector3 GetOrientation(float tf)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            return Volume.Module.Generator.transform.TransformDirection(VolumeData.InterpolateVolumeUp(tf, CrossRelativePosition));
        }

        protected override void Advance(float speed, float deltaTime)
        {
            float tf = RelativePosition;
            MovementDirection direction = MovementDirection;

            SimulateAdvance(ref tf, ref direction, speed, deltaTime);

            MovementDirection = direction;
            RelativePosition = tf;
        }

        override protected void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(IsReady, ControllerNotReadyMessage);
#endif
            int directionInt = curyDirection.ToInt();

            switch (MoveMode)
            {
                case MoveModeEnum.Relative:
                    VolumeData.Move(ref tf, ref directionInt, speed * deltaTime, Clamping);
                    break;
                case MoveModeEnum.AbsolutePrecise:
                    VolumeData.MoveBy(ref tf, ref directionInt, speed * deltaTime, Clamping);
                    break;
                default:
                    throw new NotSupportedException();
            }
            curyDirection = MovementDirectionMethods.FromInt(directionInt);
        }

        #endregion

        #region ### Privates & Internals ###
        /*! \cond PRIVATE */

        private RegionOptions<float> CrossRangeOptions
        {
            get
            {
                return RegionOptions<float>.MinMax(CrossPositionRangeMin, CrossPositionRangeMax);
            }
        }

        private float MinCrossRelativePosition
        {
            get
            {
                return m_CrossRange.From;
            }
        }

        private float MaxCrossRelativePosition
        {
            get
            {
                return m_CrossRange.To;
            }
        }

        private float GetClampedCrossPosition(float position)
        {
            return CurvyUtility.ClampValue(position, CrossClamping, CrossFrom, CrossTo);
        }

        /*! \endcond */
        #endregion

        #region RetroCompatibility code

        [SerializeField, HideInInspector]
        [Obsolete("Use crossRelativePosition instead. This field is kept for retro compatibility reasons")]
        private float m_CrossInitialPosition;

        /*! \cond PRIVATE */
        public override void OnAfterDeserialize()
        {
            base.OnAfterDeserialize();
#pragma warning disable 618
            if (float.IsNaN(m_CrossInitialPosition) == false)
            {
#pragma warning disable 612
                //Converts from the obsolete way of representing cross relative position to the usual one.
                crossRelativePosition = DTMath.MapValue(CrossFrom, CrossTo, m_CrossInitialPosition, CrossPositionRangeMin, CrossPositionRangeMax);
#pragma warning restore 612
                m_CrossInitialPosition = Single.NaN;
            }
#pragma warning restore 618
        }
        /*! \endcond */
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Controllers/VolumeController.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/CurvySerializationSpace.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3a81a593ae4669e47b9b277cce50cded
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

namespace FluffyUnderware.Curvy.ImportExport
{
    /// <summary>
    /// Used in the import/export process to define if which coordinates should be read/written, the local ones or the global ones
    /// </summary>
    public enum CurvySerializationSpace
    {
        Global = 0,
        Local = 1
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/CurvySerializationSpace.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/FileFormat.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4a54cc3b2dcf63147bc0b7ba203bdc17
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

namespace FluffyUnderware.Curvy.ImportExport
{
    /// <summary>
    /// Used in the import/export process to define what format to import and/or export to
    /// </summary>
    public enum FileFormat
    {
        JSON = 0,
        SVG = 1
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/FileFormat.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/SplineJsonConverter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f83deb70d027ab1468a94644e80ac33c
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.Curvy.Utils;
using JetBrains.Annotations;
using UnityEngine;


namespace FluffyUnderware.Curvy.ImportExport
{
    /// <summary>
    /// Converts splines to JSON strings, and vice versa
    /// </summary>
    public static class SplineJsonConverter
    {
        /// <summary>
        /// Converts splines to a JSON string
        /// </summary>
        /// <param name="splines">The splines to serialize</param>
        /// <param name="coordinatesSpace">What coordinates of the spline should be serialized: local ones or global ones?</param>
        /// <param name="prettify">Set to true to make the JSON string easy to read. If false, the spline will be compacted to make it small</param>
        public static string SplinesToJson(IEnumerable<CurvySpline> splines, CurvySerializationSpace coordinatesSpace = CurvySerializationSpace.Global, bool prettify = true)
        {
            SerializedCurvySpline[] serializedSplines = splines.Select(s => new SerializedCurvySpline(s, coordinatesSpace)).ToArray();
            return JsonUtility.ToJson(new SerializableArray<SerializedCurvySpline> { Array = serializedSplines }, prettify);
        }

        /// <summary>
        /// Converts a spline to a JSON string
        /// </summary>
        /// <param name="spline">The spline to serialize</param>
        /// <param name="coordinatesSpace">What coordinates of the spline should be serialized: local ones or global ones?</param>
        /// <param name="prettify">Set to true to make the JSON string easy to read. If false, the spline will be compacted to make it small</param>
        public static string SplineToJson(CurvySpline spline, CurvySerializationSpace coordinatesSpace = CurvySerializationSpace.Global, bool prettify = true)
        {
            return SplinesToJson(new[] { spline }, coordinatesSpace, prettify);
        }

        /// <summary>
        /// Converts a JSON string to an array of splines
        /// </summary>
        /// <param name="json">The JSON to deserialize</param>
        /// <param name="coordinatesSpace">How to interpret the coordinates in the JSON: local ones or global ones?</param>
        public static CurvySpline[] JsonToSplines(string json, CurvySerializationSpace coordinatesSpace = CurvySerializationSpace.Global)
        {
            SerializedCurvySpline[] serializedSplines = JsonToSerializedSplines(json);

            CurvySpline[] result = new CurvySpline[serializedSplines.Length];

            for (int index = 0; index < serializedSplines.Length; index++)
            {
                SerializedCurvySpline spline = serializedSplines[index];
                CurvySpline deserializedSpline = result[index] = CurvySpline.Create();
                spline.WriteIntoSpline(deserializedSpline, coordinatesSpace);
            }

            return result;
        }

        /// <summary>
        /// Converts a JSON string to a spline
        /// </summary>
        /// <param name="json">The JSON to deserialize</param>
        /// <param name="coordinatesSpace">How to interpret the coordinates in the JSON: local ones or global ones?</param>
        public static CurvySpline JsonToSpline(string json, CurvySerializationSpace coordinatesSpace = CurvySerializationSpace.Global)
        {
            return JsonToSplines(json, coordinatesSpace).Single();
        }

        /// <summary>
        /// Converts a JSON string to an array of instances of <see cref="SerializedCurvySpline"/>
        /// </summary>
        /// <param name="json">The JSON to deserialize</param>
        public static SerializedCurvySpline[] JsonToSerializedSplines([NotNull] string json)
        {
            if (json == null)
                throw new ArgumentNullException(nameof(json));
            if (string.IsNullOrWhiteSpace(json))
                throw new ArgumentException("Value cannot be null or whitespace.", nameof(json));
            if (string.IsNullOrEmpty(json))
                throw new ArgumentException("Value cannot be null or empty.", nameof(json));
            
            SerializedCurvySpline[] serializedSplines;
            //The following deserializes the JSON text, but instead of doing with a simple and nice one line of code, it is done in a complex way. The reason to that is that JsonUtility doesn't handle default values for JSON fields.
            {
                //First we deserialize the JSON in the sole goal to know how much elements there are in the arrays
                SerializableArray<SerializedCurvySpline> serializableArray = JsonUtility.FromJson<SerializableArray<SerializedCurvySpline>>(json);

                //Knowing the number of array elements, we assign a new instance for each element. By creating the new instances ourselves, through the constructor, we have control on the default value of fields
                for (int index = 0; index < serializableArray.Array.Length; index++)
                {
                    int controlPointsCount = serializableArray.Array[index].ControlPoints.Length;

                    SerializedCurvySpline splineWithCorrectDefaultValue = new SerializedCurvySpline();
                    splineWithCorrectDefaultValue.ControlPoints = new SerializedCurvySplineSegment[controlPointsCount];
                    for (int controlPointIndex = 0; controlPointIndex < controlPointsCount; controlPointIndex++) splineWithCorrectDefaultValue.ControlPoints[controlPointIndex] = new SerializedCurvySplineSegment();

                    serializableArray.Array[index] = splineWithCorrectDefaultValue;
                }

                //Then, through FromJsonOverwrite, we overwrite the fields that are existing in the JSON text
                JsonUtility.FromJsonOverwrite(json, serializableArray);

                serializedSplines = serializableArray.Array;
            }
            
            return serializedSplines;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/SplineJsonConverter.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/SplineSvgConverter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 09e1211c9bcae294fb0787f8ba317d21
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using UnityEngine;
using ToolBuddy.ThirdParty.VectorGraphics;


namespace FluffyUnderware.Curvy.ImportExport
{
    /// <summary>
    /// Converts SVG strings to splines
    /// </summary>
    public static class SplineSvgConverter
    {
        /// <summary>
        /// Converts an SVG string to an array of splines
        /// </summary>
        /// <param name="svg">The SVG to deserialize</param>
        /// <param name="coordinatesSpace">How to interpret the coordinates in the SVG: local ones or global ones?</param>
        public static CurvySpline[] SvgToSplines(string svg, CurvySerializationSpace coordinatesSpace = CurvySerializationSpace.Global)
        {
            List<SerializedCurvySpline> serializedSplines = SvgToSerializedSplines(svg);

            CurvySpline[] result = new CurvySpline[serializedSplines.Count];

            for (int index = 0; index < serializedSplines.Count; index++)
            {
                SerializedCurvySpline spline = serializedSplines[index];
                CurvySpline deserializedSpline = result[index] = CurvySpline.Create();
                spline.WriteIntoSpline(deserializedSpline, coordinatesSpace);
            }

            return result;
        }

        /// <summary>
        /// Converts an SVG string to a spline
        /// </summary>
        /// <param name="svg">The SVG to deserialize</param>
        /// <param name="coordinatesSpace">How to interpret the coordinates in the SVG: local ones or global ones?</param>
        public static CurvySpline SvgToSpline(string svg, CurvySerializationSpace coordinatesSpace = CurvySerializationSpace.Global)
        {
            return SvgToSplines(svg, coordinatesSpace).Single();
        }

        /// <summary>
        /// Converts an SVG string to an array of instances of <see cref="SerializedCurvySpline"/>
        /// </summary>
        /// <param name="svg">The SVG to deserialize</param>
        /// <param name="invertY">Inverts the Y coordinates to match unity's Y axis</param>
        public static List<SerializedCurvySpline> SvgToSerializedSplines([NotNull] string svg, bool invertY = true)
        {
            if (svg == null)
                throw new ArgumentNullException(nameof(svg));
            if (string.IsNullOrWhiteSpace(svg))
                throw new ArgumentException("Value cannot be null or whitespace.", nameof(svg));
            if (string.IsNullOrEmpty(svg))
                throw new ArgumentException("Value cannot be null or empty.", nameof(svg));

            List<SerializedCurvySpline> serializedSplines = new List<SerializedCurvySpline>();

            using (StringReader stringReader = new StringReader(svg))
            {
                SVGParser.SceneInfo sceneInfo = SVGParser.ImportSVG(stringReader);
                DrawNode(sceneInfo.Scene.Root, sceneInfo.Scene.Root.Transform, serializedSplines);
            }

            if (invertY)
                foreach (SerializedCurvySpline spline in serializedSplines)
                {
                    foreach (SerializedCurvySplineSegment controlPoint in spline.ControlPoints)
                    {
                        controlPoint.Position.y *= -1;
                        controlPoint.HandleIn.y *= -1;
                        controlPoint.HandleOut.y *= -1;
                    }
                }

            return serializedSplines;
        }

        private static void DrawNode(SceneNode node, Matrix2D rootTransform, List<SerializedCurvySpline> splines)
        {
            if (node.Clipper != null)
            {
                DTLog.LogWarning("[Curvy] SVG Import: A clipper was encountered. Clippers are not supported.");
            }

            if (node.Shapes != null)
            {
                Matrix2D transform = rootTransform * node.Transform;

                foreach (Shape shape in node.Shapes)
                {
                    foreach (BezierContour bezierContour in shape.Contours)
                    {
                        BezierPathSegment[] segments = bezierContour.Segments;
                        List<SerializedCurvySplineSegment> controlPoints = new List<SerializedCurvySplineSegment>(segments.Length);

                        if (segments.Length == 0)
                            continue;

                        if (segments.Length == 1)
                        {
                            DTLog.LogError("[Curvy] SVG Import: A segments array had only one element. This is unexpected. That contour was ignored. Please raise a bug report.");
                            continue;
                        }

                        SerializedCurvySpline spline = new SerializedCurvySpline();
                        spline.Interpolation = CurvyInterpolation.Bezier;
                        spline.Closed = bezierContour.Closed;
                        spline.Name = $"SVG Spline {splines.Count}";
                        splines.Add(spline);

                        BezierPathSegment firstSegment = segments.First();
                        BezierPathSegment lastSegment = segments.Last();

                        SerializedCurvySplineSegment firstCurvySegment = new SerializedCurvySplineSegment();
                        firstCurvySegment.Position = transform.MultiplyPoint(firstSegment.P0);
                        firstCurvySegment.AutoHandles = false;
                        firstCurvySegment.HandleIn = transform.MultiplyVector(lastSegment.P2 - firstSegment.P0);
                        firstCurvySegment.HandleOut = transform.MultiplyVector(firstSegment.P1 - firstSegment.P0);
                        controlPoints.Add(firstCurvySegment);


                        for (int index = 1; index < segments.Length; index++)
                        {
                            BezierPathSegment previousSegment = segments[index - 1];
                            BezierPathSegment segment = segments[index];

                            SerializedCurvySplineSegment curvySegment = new SerializedCurvySplineSegment();
                            curvySegment.Position = transform.MultiplyPoint(segment.P0);
                            curvySegment.AutoHandles = false;
                            curvySegment.HandleIn = transform.MultiplyVector(previousSegment.P2 - segment.P0);
                            curvySegment.HandleOut = transform.MultiplyVector(segment.P1 - segment.P0);
                            controlPoints.Add(curvySegment);
                        }

                        spline.ControlPoints = controlPoints.ToArray();
                    }
                }
            }

            if (node.Children != null)
                foreach (SceneNode childNode in node.Children)
                    DrawNode(childNode, rootTransform * childNode.Transform, splines);
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/SplineSvgConverter.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/Wrappers.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6cf9b447a28326d47a6e12d03bce0f7c
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using JetBrains.Annotations;
using UnityEngine;

namespace FluffyUnderware.Curvy.ImportExport
{
    /// <summary>
    /// A wrapper to the CurvySpline class
    /// </summary>
    [Serializable]
    public class SerializedCurvySpline
    {
        public string Name;
        public Vector3 Position;
        public Vector3 Rotation;
        public CurvyInterpolation Interpolation;
        public bool RestrictTo2D;
        public bool Closed;
        public bool AutoEndTangents;
        public CurvyOrientation Orientation;
        public float AutoHandleDistance;
        public int CacheDensity;
        public float MaxPointsPerUnit;
        public bool UsePooling;
        public bool UseThreading;
        public bool CheckTransform;
        public CurvyUpdateMethod UpdateIn;
        public bool IsBSplineClamped;
        public int BSplineDegree;
        public SerializedCurvySplineSegment[] ControlPoints;

        public SerializedCurvySpline()
        {
            Interpolation = CurvyGlobalManager.DefaultInterpolation;
            AutoEndTangents = CurvySplineDefaultValues.AutoEndTangents;
            Orientation = CurvySplineDefaultValues.Orientation;
            AutoHandleDistance = CurvySplineDefaultValues.AutoHandleDistance;
            CacheDensity = CurvySplineDefaultValues.CacheDensity;
            MaxPointsPerUnit = CurvySplineDefaultValues.MaxPointsPerUnit;
            UsePooling = CurvySplineDefaultValues.UsePooling;
            CheckTransform = CurvySplineDefaultValues.CheckTransform;
            UpdateIn = CurvySplineDefaultValues.UpdateIn;
            BSplineDegree = CurvySplineDefaultValues.BSplineDegree;
            IsBSplineClamped = CurvySplineDefaultValues.IsBSplineClamped;
            ControlPoints = new SerializedCurvySplineSegment[0];

        }

        public SerializedCurvySpline([NotNull] CurvySpline spline, CurvySerializationSpace space)
        {
            Name = spline.name;
            Position = (space == CurvySerializationSpace.Local)
                ? spline.transform.localPosition
                : spline.transform.position;
            Rotation = (space == CurvySerializationSpace.Local)
                ? spline.transform.localRotation.eulerAngles
                : spline.transform.rotation.eulerAngles;
            Interpolation = spline.Interpolation;
            RestrictTo2D = spline.RestrictTo2D;
            Closed = spline.Closed;
            AutoEndTangents = spline.AutoEndTangents;
            Orientation = spline.Orientation;
            AutoHandleDistance = spline.AutoHandleDistance;
            CacheDensity = spline.CacheDensity;
            MaxPointsPerUnit = spline.MaxPointsPerUnit;
            UsePooling = spline.UsePooling;
            UseThreading = spline.UseThreading;
            CheckTransform = spline.CheckTransform;
            UpdateIn = spline.UpdateIn;
            BSplineDegree = spline.BSplineDegree;
            IsBSplineClamped = spline.IsBSplineClamped;
            ControlPoints = new SerializedCurvySplineSegment[spline.ControlPointCount];
            for (int i = 0; i < spline.ControlPointCount; i++)
                ControlPoints[i] = new SerializedCurvySplineSegment(spline.ControlPointsList[i], space);
        }

        /// <summary>
        /// Fills an existing spline with data from this instance
        /// </summary>
        /// <remarks>This method will dirty the spline</remarks>
        public void WriteIntoSpline([NotNull] CurvySpline deserializedSpline, CurvySerializationSpace space)
        {
            deserializedSpline.name = Name;
            if (space == CurvySerializationSpace.Local)
            {
                deserializedSpline.transform.localPosition = Position;
                deserializedSpline.transform.localRotation = Quaternion.Euler(Rotation);
            }
            else
            {
                deserializedSpline.transform.position = Position;
                deserializedSpline.transform.rotation = Quaternion.Euler(Rotation);
            }
            deserializedSpline.Interpolation = Interpolation;
            deserializedSpline.RestrictTo2D = RestrictTo2D;
            deserializedSpline.Closed = Closed;
            deserializedSpline.AutoEndTangents = AutoEndTangents;
            deserializedSpline.Orientation = Orientation;
            deserializedSpline.AutoHandleDistance = AutoHandleDistance;
            deserializedSpline.CacheDensity = CacheDensity;
            deserializedSpline.MaxPointsPerUnit = MaxPointsPerUnit;
            deserializedSpline.UsePooling = UsePooling;
            deserializedSpline.UseThreading = UseThreading;
            deserializedSpline.CheckTransform = CheckTransform;
            deserializedSpline.UpdateIn = UpdateIn;

            foreach (SerializedCurvySplineSegment serializedControlPoint in ControlPoints)
                serializedControlPoint.WriteIntoControlPoint(deserializedSpline.InsertAfter(null, true), space);

            //degree is assigned after the control points insertion, because the actual value of the degree depends on the number of control points
            deserializedSpline.BSplineDegree = BSplineDegree;
            deserializedSpline.IsBSplineClamped = IsBSplineClamped;

            deserializedSpline.SetDirtyAll();
        }
    }

    /// <summary>
    /// Serialized Control Point
    /// </summary>
    [Serializable]
    public class SerializedCurvySplineSegment
    {
        public Vector3 Position;
        public Vector3 Rotation;
        public bool AutoBakeOrientation;
        public bool OrientationAnchor;
        public CurvyOrientationSwirl Swirl;
        public float SwirlTurns;
        public bool AutoHandles;
        public bool SynchronizeTCB;
        public float AutoHandleDistance;
        public Vector3 HandleOut;
        public Vector3 HandleIn;

        public SerializedCurvySplineSegment()
        {

            Swirl = CurvySplineSegmentDefaultValues.Swirl;
            SynchronizeTCB = CurvySplineSegmentDefaultValues.SynchronizeTCB;
            AutoHandles = CurvySplineSegmentDefaultValues.AutoHandles;
            AutoHandleDistance = CurvySplineSegmentDefaultValues.AutoHandleDistance;
            HandleOut = CurvySplineSegmentDefaultValues.HandleOut;
            HandleIn = CurvySplineSegmentDefaultValues.HandleIn;
        }

        public SerializedCurvySplineSegment([NotNull] CurvySplineSegment segment, CurvySerializationSpace space)
        {
            Position = (space == CurvySerializationSpace.Global)
                ? segment.transform.position
                : segment.transform.localPosition;
            Rotation = (space == CurvySerializationSpace.Global)
                ? segment.transform.rotation.eulerAngles
                : segment.transform.localRotation.eulerAngles;
            AutoBakeOrientation = segment.AutoBakeOrientation;
            OrientationAnchor = segment.SerializedOrientationAnchor;
            Swirl = segment.Swirl;
            SwirlTurns = segment.SwirlTurns;
            AutoHandles = segment.AutoHandles;
            SynchronizeTCB = segment.SynchronizeTCB;
            AutoHandleDistance = segment.AutoHandleDistance;
            HandleOut = segment.HandleOut;
            HandleIn = segment.HandleIn;
        }

        /// <summary>
        /// Fills an existing control point with data from this instance.
        /// </summary>
        public void WriteIntoControlPoint([NotNull] CurvySplineSegment controlPoint, CurvySerializationSpace space)
        {
            if (space == CurvySerializationSpace.Global)
            {
                controlPoint.transform.position = Position;
                controlPoint.transform.rotation = Quaternion.Euler(Rotation);
            }
            else
            {
                controlPoint.transform.localPosition = Position;
                controlPoint.transform.localRotation = Quaternion.Euler(Rotation);
            }
            controlPoint.AutoBakeOrientation = AutoBakeOrientation;
            controlPoint.SerializedOrientationAnchor = OrientationAnchor;
            controlPoint.Swirl = Swirl;
            controlPoint.SynchronizeTCB = SynchronizeTCB;
            controlPoint.SwirlTurns = SwirlTurns;
            controlPoint.AutoHandles = AutoHandles;
            controlPoint.AutoHandleDistance = AutoHandleDistance;
            controlPoint.SetBezierHandleIn(HandleIn);
            controlPoint.SetBezierHandleOut(HandleOut);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/ImportExport/Wrappers.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/BSplineHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1a16162565f8a9c4abf2a7cd62b6f064
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System.Runtime.CompilerServices;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using UnityEngine;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Static methods used in the implementation of B-Splines
    /// </summary>
    public static class BSplineHelper
    {
        /// <summary>
        /// De Boor algorithm for clamped B-Splines. parameter names taken from https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/de-Boor.html.
        /// This is a variant of that implementation, explained in the english De Boor's page in Wikipedia 
        /// </summary>
        public static Vector3 DeBoorClamped(int p, int k, float u, int nPlus1, [NotNull] Vector3[] pArray)
        {
            //OPTIM make a per degree non recursive implementation for degree 2 and maybe other lower degrees
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(pArray.Length >= p + 1);
#endif
            int kMinusP = k - p;
            int maxClampedKnotValue = nPlus1 - p;// n + 1 - p  is the max knot value

            for (int r = 1; r <= p; r++)
            {
                int kPlusOneMinusR = k + 1 - r;

                for (int j = p; j >= r; j--)
                {
                    int i1 = j + kMinusP;
                    int i2 = j + kPlusOneMinusR;

                    int u1;
                    int u2;
                    /*The following code is equivalent to the commented code underneath, but using the fact that i1 is smaller than i2
                    u1 = i1 <= p
                        ? 0
                        : i1 >= nPlus1 // n+1 is m-p 
                            ? maxClampedKnotValue // n - p + 1 is the max knot value
                            : i1 - p;
                    u2 = i2 <= p
                        ? 0
                        : i2 >= nPlus1 // n+1 is m-p 
                            ? maxClampedKnotValue // n - p + 1 is the max knot value
                            : i2 - p;
                    */
                    if (i1 <= p)
                    {
                        u1 = 0;

                        if (i2 <= p)
                            u2 = 0;
                        else
                            u2 = i2 >= nPlus1 // n+1 is m-p 
                                ? maxClampedKnotValue
                                : i2 - p;
                    }
                    else if (i1 >= nPlus1)
                    {
                        u1 = u2 = maxClampedKnotValue;
                    }
                    else
                    {
                        u1 = i1 - p;
                        u2 = i2 >= nPlus1 // n+1 is m-p 
                            ? maxClampedKnotValue
                            : i2 - p;
                    }

                    float a = (u - u1) / (u2 - u1);
                    //equivalent to psArray[j] = (1 - a) * psArray[j - 1] + a * psArray[j];
                    pArray[j] = pArray[j - 1].Multiply(1 - a)
                        .Addition(pArray[j].Multiply(a));
                }
            }

            return pArray[p];
        }

        /// <summary>
        /// De Boor algorithm for clamped B-Splines. parameter names taken from https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/de-Boor.html.
        /// This is a variant of that implementation, explained in the english De Boor's page in Wikipedia 
        /// </summary>
        public static Vector3 DeBoorUnclamped(int p, int k, float u, [NotNull] Vector3[] pArray)
        {
            //OPTIM make a per degree non recursive implementation for degree 2 and maybe other lower degrees

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(pArray.Length >= p + 1);
#endif
            int kMinusP = k - p;

            for (int r = 1; r <= p; r++)
            {
                int kPlusOneMinusR = k + 1 - r;

                for (int j = p; j >= r; j--)
                {
                    float a = (u - (j + kMinusP)) / ((j + kPlusOneMinusR) - (j + kMinusP));
                    //equivalent to psArray[j] = (1 - a) * psArray[j - 1] + a * psArray[j];
                    pArray[j] = pArray[j - 1].Multiply(1 - a)
                        .Addition(pArray[j].Multiply(a));
                }
            }

            return pArray[p];
        }

        /// <summary>
        /// Get the N number as defined in the B-Spline section here: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int GetBSplineN(int controlPointsCount, int degree, bool closed)
        {
            return controlPointsCount - 1 + (closed ? degree : 0);
        }

        /// <summary>
        /// Get the the U and K numbers as defined in the B-Spline section, De Boor's algorithm, here: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void GetBSplineUAndK(float tf, bool isClamped, int p, int n, out float u, out int k)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(tf.IsBetween0And1());
#endif
            if (isClamped)
            {
                u = (n - p + 1) * tf; // n - p + 1 is the max knot value
                int intU = (int)u;
                //case of u equal to 1
                if (intU == n - p + 1) // n - p + 1 is the max knot value
                    intU--;
                k = intU + p;
            }
            else
            {
                u = p + (n + 1 - p) * tf;//inlined version of DTMath.MapValue(p, m - p, tf, 0, 1), knowing that n+1 is m-p
                int intU = (int)u;
                //case of u equal to 1
                if (intU == n + 1) // n+1 is m-p
                    intU--;
                k = intU;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/BSplineHelper.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CodeContractsUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e1897b667b05641448d9cb45004d9bbf
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

#if CONTRACTS_FULL

using System;
using System.Diagnostics.Contracts;
using UnityEngine;

namespace FluffyUnderware.Curvy
{
    public static class CodeContractsUtility
    {
        [Pure]
        public static void AssumeInvariant<T>(T assumptionTarget)
        {
        }

        [Pure]
        public static bool IsPercentage(this float number)
        {
            return number >= 0 && number <= 100;
        }

        [Pure]
        public static bool IsPercentage(this int number)
        {
            return number >= 0 && number <= 100;
        }

        [Pure]
        public static bool IsValidCollectionIndex(this int number, int collectionSize)
        {
            return number >= 0 && number < collectionSize;
        }

        [Pure]
        public static bool IsRatio(this float number)
        {
            return number >= 0 && number <= 1;
        }

        [Pure]
        public static bool IsRatioOrNegativeRatio(this float number)
        {
            return number >= -1 && number <= 1;
        }

        /// <summary>
        /// Returns true if float is neither an infinity nor a NaN
        /// </summary>
        /// <param name="number"></param>
        /// <returns></returns>
        [Pure]
        public static bool IsANumber(this float number)
        {
            return Single.IsNaN(number) == false && number.IsFinite();
        }

        [Pure]
        public static bool IsPositiveNumber(this float number)
        {
            return number >= 0 && number.IsANumber();
        }

        [Pure]
        public static bool IsStrictelyPositiveNumber(this float number)
        {
            return number > 0 && number.IsANumber();
        }

        [Pure]
        public static bool IsNegativeNumber(this float number)
        {
            return number <= 0 && number.IsANumber();
        }

        [Pure]
        public static bool IsOdd(this int number)
        {
            return number % 2 != 0;
        }

        [Pure]
        public static bool IsEven(this int number)
        {
            return number % 2 == 0;
        }


        /// <summary>
        /// Is the given value between 0 and 180 inclusive
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        [Pure]
        public static bool IsIn0To180Range(this float value)
        {
            return value >= 0 && value <= 180;
        }

        /// <summary>
        /// Is the given value between -180 and 180 inclusive
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        [Pure]
        public static bool IsInMinus180To180Range(this float value)
        {
            return value >= -180 && value <= 180;
        }

        /// <summary>
        /// Is the given value between 0 and 90 inclusive
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        [Pure]
        public static bool IsIn0To90Range(this float value)
        {
            return value >= 0 && value <= 90;
        }

        /// <summary>
        /// Is the given value between -90 and 90 inclusive
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        [Pure]
        public static bool IsInMinus90To90Range(this float value)
        {
            return value >= -90 && value <= 90;
        }

        [Pure]
        public static bool IsInRangeExclusive(this float value, float rangeLowerBound, float rangeUpperBound)
        {
            Contract.Requires(rangeLowerBound < rangeUpperBound);

            return value > rangeLowerBound && value < rangeUpperBound;
        }

        [Pure]
        public static bool IsInRangeInclusive(this float value, float rangeLowerBound, float rangeUpperBound)
        {
            Contract.Requires(rangeLowerBound < rangeUpperBound);

            return value >= rangeLowerBound && value <= rangeUpperBound;
        }

        [Pure]
        public static bool IsNan(this float number)
        {
            return Single.IsNaN(number);
        }

        [Pure]
        public static bool IsNormalized(this Vector3 vector)
        {
            return Approximately(vector.magnitude, 1f);
        }

        [Pure]
        public static bool IsNormalized(this Quaternion q)
        {
            return Approximately(
                (float)Math.Sqrt(q.w * q.w + q.x * q.x + q.y * q.y + q.z * q.z)
                , 1f);
        }

        [Pure]
        public static bool ContainsNan(this Vector3 vector)
        {
            return float.IsNaN(vector.x) || float.IsNaN(vector.y) || float.IsNaN(vector.z);
        }

        [Pure]
        public static bool ContainsInfinity(this Vector3 vector)
        {
            return float.IsInfinity(vector.x) || float.IsInfinity(vector.y) || float.IsInfinity(vector.z);

        }
        [Pure]
        public static float PureDot(this Vector3 vector1, Vector3 vector2)
        {
            return Vector3.Dot(vector1, vector2);
        }

        [Pure]
        public static Vector3 PureCross(this Vector3 vector1, Vector3 vector2)
        {
            return Vector3.Cross(vector1, vector2);
        }

        [Pure]
        public static bool PureIsChildOf(this Transform child, Transform parent)
        {
            return child.IsChildOf(parent);
        }

        [Pure]
        public static bool Approximately(this float a, float b)
        {
            return Mathf.Approximately(a, b);
        }

        [Pure]
        public static bool WithinMargin(this float a, float b, float margin)
        {
            return Mathf.Abs(b - a) <= margin;
        }

        [Pure]
        public static bool Approximately(this Vector3 a, Vector3 b)
        {
            return a.x.Approximately(b.x)
                && a.y.Approximately(b.y)
                && a.z.Approximately(b.z);
        }

        [Pure]
        public static bool IsWithinDistance(this Vector3 a, Vector3 b, float maxAllowedDistance)
        {
            Contract.Requires(maxAllowedDistance.IsPositiveNumber());
            return (a - b).magnitude <= maxAllowedDistance;
        }

        //[Pure]
        //public static bool IsWithinAngle(this Quaternion a, Quaternion b, float maxAllowedAngle)
        //{
        //    Contract.Requires(maxAllowedAngle.IsPositiveNumber());

        //    return a.Angle(b) <= maxAllowedAngle;
        //}


        [Pure]
        public static bool IsFinite(this float number)
        {
            Contract.Requires(IsNan(number) == false);

            return float.IsInfinity(number) == false;
        }

        [Pure]
        public static bool IsInfinite(this float number)
        {
            return !IsFinite(number);
        }

        [Pure]
        public static bool IsNotZero(this float number)
        {
            return number.Approximately(0f) == false;
        }

        [Pure]
        public static int MaskNameToLayer(string layerName)
        {
            return LayerMask.NameToLayer(layerName);
        }

        [Pure]
        public static bool AreBarycentricCoordinatesOfPointInTriangle(this Vector3 barycentricCoordinates)
        {
            return
                barycentricCoordinates.x >= 0 &&
                barycentricCoordinates.y >= 0 &&
                barycentricCoordinates.z >= 0 &&
                1f.Approximately(barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z);
        }

        [Pure]
        static public float PureMin(float a, float b)
        {
            Contract.Ensures(Contract.Result<float>() <= a);
            Contract.Ensures(Contract.Result<float>() <= b);
            return Mathf.Min(a, b);
        }

        [Pure]
        static public float PureMax(float a, float b)
        {
            Contract.Ensures(Contract.Result<float>() >= a);
            Contract.Ensures(Contract.Result<float>() >= b);
            return Mathf.Max(a, b);
        }

        [Pure]
        static public T PureGetComponent<T>(this GameObject gameObject)
        {
            return gameObject.GetComponent<T>();
        }

        [Pure]
        static public Component PureGetComponent(this GameObject gameObject, string componentName)
        {
            return gameObject.GetComponent(componentName);
        }
    }
}

#endif
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CodeContractsUtility.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyClasses.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 67f3b369fc26aae43aa3d1cbb9b64d3f
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Orientation options
    /// </summary>
    public enum OrientationModeEnum
    {
        /// <summary>
        /// No Orientation. The initial orientation of the controller is kept.
        /// </summary>
        None,
        /// <summary>
        /// Use Orientation/Up-Vector
        /// </summary>
        Orientation,
        /// <summary>
        /// Use Direction/Tangent
        /// </summary>
        Tangent
    }

    /// <summary>
    /// Orientation axis to use
    /// </summary>
    public enum OrientationAxisEnum
    {
        Up,
        Down,
        Forward,
        Backward,
        Left,
        Right
    }

    /// <summary>
    /// Used by components to determine when updates should occur
    /// </summary>
    public enum CurvyUpdateMethod
    {
        Update,
        LateUpdate,
        FixedUpdate
    }

    public enum CurvyRepeatingOrderEnum
    {
        Random = 0,
        Row = 1
    }

    /// <summary>
    /// Plane definition
    /// </summary>
    public enum CurvyPlane
    {
        /// <summary>
        /// X/Y Plane (Z==0)
        /// </summary>
        XY,
        /// <summary>
        /// X/U Plane (Y==0)
        /// </summary>
        XZ,
        /// <summary>
        /// Y/Z Plane (X==)
        /// </summary>
        YZ
    }

    /// <summary>
    /// Position Mode 
    /// </summary>
    public enum CurvyPositionMode
    {
        /// <summary>
        /// Valid positions are from 0 (Start) to 1 (End)
        /// </summary>
        Relative = 0,
        /// <summary>
        /// Valid positions are from 0 (Start) to Length (End). Also know as Absolute.
        /// </summary>
        WorldUnits = 1,
    }

    /// <summary>
    /// Bezier Handles editing modes
    /// </summary>
    [Flags]
    public enum CurvyBezierModeEnum
    {
        /// <summary>
        /// Don't sync
        /// </summary>
        None = 0,
        /// <summary>
        /// Sync Direction
        /// </summary>
        Direction = 1,
        /// <summary>
        /// Sync Length
        /// </summary>
        Length = 2,
        /// <summary>
        /// Sync connected Control Points
        /// </summary>
        Connections = 4,
        /// <summary>
        /// Combine both Handles of a segment
        /// </summary>
        Combine = 8
    }

    /// <summary>
    /// Bezier Handles editing modes for AdvSplines
    /// </summary>
    public enum CurvyAdvBezierModeEnum
    {
        /// <summary>
        /// Don't sync
        /// </summary>
        None = 0,
        /// <summary>
        /// Sync Direction
        /// </summary>
        Direction = 1,
        /// <summary>
        /// Sync Length
        /// </summary>
        Length = 2,
        /// <summary>
        /// Combine both Handles of a segment
        /// </summary>
        Combine = 8
    }

    /// <summary>
    /// Determines the interpolation method
    /// </summary>
    public enum CurvyInterpolation
    {
        /// <summary>
        ///  Linear interpolation
        /// </summary>
        Linear = 0,
        /// <summary>
        /// Catmul-Rom splines
        /// </summary>
        CatmullRom = 1,
        /// <summary>
        /// Kochanek-Bartels (TCB)-Splines
        /// </summary>
        TCB = 2,
        /// <summary>
        /// Cubic Bezier-Splines
        /// </summary>
        Bezier = 3,
        /// <summary>
        /// B-Splines
        /// </summary>
        BSpline = 4
    }

    /// <summary>
    /// Determines the clamping method used by Move-methods
    /// </summary>
    public enum CurvyClamping
    {
        /// <summary>
        /// Stop at splines ends
        /// </summary>
        Clamp = 0,
        /// <summary>
        /// Start over
        /// </summary>
        Loop = 1,
        /// <summary>
        /// Switch direction
        /// </summary>
        PingPong = 2
    }

    /// <summary>
    /// Determines Orientation mode
    /// </summary>
    public enum CurvyOrientation
    {
        /// <summary>
        /// Ignore rotation
        /// </summary>
        None = 0,
        /// <summary>
        /// Use the splines' tangent and up vectors to create a look rotation 
        /// </summary>
        Dynamic = 1,
        /// <summary>
        /// Interpolate between the Control Point's rotation
        /// </summary>
        Static = 2,
    }

    /// <summary>
    /// Swirl mode
    /// </summary>
    public enum CurvyOrientationSwirl
    {
        /// <summary>
        /// No Swirl
        /// </summary>
        None = 0,
        /// <summary>
        /// Swirl over each segment of anchor group
        /// </summary>
        Segment = 1,
        /// <summary>
        /// Swirl equal over current anchor group's segments
        /// </summary>
        AnchorGroup = 2,
        /// <summary>
        /// Swirl equal over anchor group's length
        /// </summary>
        AnchorGroupAbs = 3
    }



    /// <summary>
    /// Sceneview viewing modes
    /// </summary>
    [Flags]
    public enum CurvySplineGizmos : int
    {
        None = 0,
        Connections = 1,
        Curve = 1 << 1,
        Approximation = 1 << 2,
        Tangents = 1 << 3,
        Orientation = 1 << 4,
        Labels = 1 << 5,
        Metadata = 1 << 6,
        Bounds = 1 << 7,
        TFs = 1 << 8,
        RelativeDistances = 1 << 9,
        OrientationAnchors = 1 << 10,
        All = 65535
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyClasses.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: fd4480447eb35824e9fe7f9dd8256ddf
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using UnityEngine.Assertions;

#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
namespace FluffyUnderware.Curvy
{
    public class CurvyEventArgs : EventArgs
    {
        /// <summary>
        /// The component raising the event
        /// </summary>
        public readonly MonoBehaviour Sender;
        /// <summary>
        /// Custom data
        /// </summary>
        public readonly object Data;

        public CurvyEventArgs(MonoBehaviour sender, object data)
        {
            Sender = sender;
            Data = data;

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(System.Object.ReferenceEquals(null, Sender) == false);
#endif
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyEvents.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2d6ea997949c6e245aa4edc8a8e04b66
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Pools;
using ToolBuddy.Pooling.Pools;
using FluffyUnderware.Curvy.ThirdParty.LibTessDotNet;
#if UNITY_EDITOR
using UnityEditor;
#endif
using FluffyUnderware.DevTools;
using ToolBuddy.Pooling;
using ToolBuddy.Pooling.Collections;


namespace FluffyUnderware.Curvy.Utils
{

    /// <summary>
    /// A workaround to the Unity Json's class not being able to serialize top level arrays.
    /// Including such arrays in another object avoids the issue.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class SerializableArray<T>
    {
        public T[] Array;
    }

    /// <summary>
    /// Taken from my asset Frame Rate Booster
    /// https://assetstore.unity.com/packages/tools/utilities/frame-rate-booster-120660
    /// </summary>
    public static class OptimizedOperators
    {
        public static Vector3 Addition(this Vector3 a, Vector3 b)
        {
            a.x += b.x;
            a.y += b.y;
            a.z += b.z;
            return a;
        }

        public static Vector3 UnaryNegation(this Vector3 a)
        {
            Vector3 result;
            result.x = -a.x;
            result.y = -a.y;
            result.z = -a.z;
            return result;
        }

        public static Vector3 Subtraction(this Vector3 a, Vector3 b)
        {
            a.x -= b.x;
            a.y -= b.y;
            a.z -= b.z;
            return a;

        }

        public static Vector3 Multiply(this Vector3 a, float d)
        {
            a.x *= d;
            a.y *= d;
            a.z *= d;
            return a;
        }

        public static Vector3 Multiply(this float d, Vector3 a)
        {
            a.x *= d;
            a.y *= d;
            a.z *= d;
            return a;
        }

        public static Vector3 Division(this Vector3 a, float d)
        {
            float inversed = 1 / d;
            a.x *= inversed;
            a.y *= inversed;
            a.z *= inversed;
            return a;
        }

        public static Vector3 Normalize(this Vector3 value)
        {
            Vector3 result;
            float num = (float)Math.Sqrt(value.x * (double)value.x + value.y * (double)value.y + value.z * (double)value.z);
            if (num > 9.99999974737875E-06)
            {
                float inversed = 1 / num;
                result.x = value.x * inversed;
                result.y = value.y * inversed;
                result.z = value.z * inversed;
            }
            else
            {
                result.x = 0;
                result.y = 0;
                result.z = 0;
            }
            return result;
        }

        public static Vector3 LerpUnclamped(this Vector3 a, Vector3 b, float t)
        {
            a.x += (b.x - a.x) * t;
            a.y += (b.y - a.y) * t;
            a.z += (b.z - a.z) * t;
            return a;
        }

        static public Color Multiply(this Color a, float b)
        {
            a.r *= b;
            a.g *= b;
            a.b *= b;
            a.a *= b;
            return a;
        }

        static public Color Multiply(this float b, Color a)
        {
            a.r *= b;
            a.g *= b;
            a.b *= b;
            a.a *= b;
            return a;
        }

        public static Quaternion Multiply(this Quaternion lhs, Quaternion rhs)
        {
            Quaternion result;
            result.x = (lhs.w * rhs.x + lhs.x * rhs.w + lhs.y * rhs.z - lhs.z * rhs.y);
            result.y = (lhs.w * rhs.y + lhs.y * rhs.w + lhs.z * rhs.x - lhs.x * rhs.z);
            result.z = (lhs.w * rhs.z + lhs.z * rhs.w + lhs.x * rhs.y - lhs.y * rhs.x);
            result.w = (lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z);
            return result;
        }
    }


    /// <summary>
    /// Curvy Utility class
    /// </summary>
    public static class CurvyUtility
    {
        #region ### Clamping Methods ###

        /// <summary>
        /// Clamps relative position
        /// </summary>
        public static float ClampTF(float tf, CurvyClamping clamping)
        {
            switch (clamping)
            {
                case CurvyClamping.Loop:
                    return Mathf.Repeat(tf, 1);
                case CurvyClamping.PingPong:
                    return Mathf.PingPong(tf, 1);
                case CurvyClamping.Clamp:
                    return Mathf.Clamp01(tf);
                default:
                    throw new InvalidEnumArgumentException();
            }
        }


        /// <summary>
        /// Clamps relative position and sets new direction
        /// </summary>
        public static float ClampTF(float tf, ref int dir, CurvyClamping clamping)
        {
            switch (clamping)
            {
                case CurvyClamping.Loop:
                    return Mathf.Repeat(tf, 1);
                case CurvyClamping.PingPong:
                    if (Mathf.FloorToInt(tf) % 2 != 0)
                        dir *= -1;
                    return Mathf.PingPong(tf, 1);
                case CurvyClamping.Clamp:
                    return Mathf.Clamp01(tf);
                default:
                    throw new InvalidEnumArgumentException();
            }
        }

        /// <summary>
        /// Clamps a float to a range
        /// </summary>
        public static float ClampValue(float tf, CurvyClamping clamping, float minTF, float maxTF)
        {

            switch (clamping)
            {
                case CurvyClamping.Loop:
                    float v1 = DTMath.MapValue(0, 1, tf, minTF, maxTF);
                    return DTMath.MapValue(minTF, maxTF, Mathf.Repeat(v1, 1), 0, 1);
                case CurvyClamping.PingPong:
                    float v2 = DTMath.MapValue(0, 1, tf, minTF, maxTF);
                    return DTMath.MapValue(minTF, maxTF, Mathf.PingPong(v2, 1), 0, 1);
                case CurvyClamping.Clamp:
                    return Mathf.Clamp(tf, minTF, maxTF);
                default:
                    throw new InvalidEnumArgumentException();
            }
        }

        /// <summary>
        /// Clamps absolute position
        /// </summary>
        public static float ClampDistance(float distance, CurvyClamping clamping, float length)
        {
            if (length == 0)
                return 0;
            switch (clamping)
            {
                case CurvyClamping.Loop:
                    return Mathf.Repeat(distance, length);
                case CurvyClamping.PingPong:
                    return Mathf.PingPong(distance, length);
                case CurvyClamping.Clamp:
                    return Mathf.Clamp(distance, 0, length);
                default:
                    throw new InvalidEnumArgumentException();
            }
        }

        /// <summary>
        /// Clamps absolute position
        /// </summary>
        public static float ClampDistance(float distance, CurvyClamping clamping, float length, float min, float max)
        {
            if (length == 0)
                return 0;
            min = Mathf.Clamp(min, 0, length);
            max = Mathf.Clamp(max, min, length);
            switch (clamping)
            {
                case CurvyClamping.Loop:
                    return min + Mathf.Repeat(distance, max - min);
                case CurvyClamping.PingPong:
                    return min + Mathf.PingPong(distance, max - min);
                case CurvyClamping.Clamp:
                    return Mathf.Clamp(distance, min, max);
                default:
                    throw new InvalidEnumArgumentException();
            }
        }

        /// <summary>
        /// Clamps absolute position and sets new direction
        /// </summary>
        public static float ClampDistance(float distance, ref int dir, CurvyClamping clamping, float length)
        {
            if (length == 0)
                return 0;
            switch (clamping)
            {
                case CurvyClamping.Loop:
                    return Mathf.Repeat(distance, length);
                case CurvyClamping.PingPong:
                    if (Mathf.FloorToInt(distance / length) % 2 != 0)
                        dir *= -1;
                    return Mathf.PingPong(distance, length);
                case CurvyClamping.Clamp:
                    return Mathf.Clamp(distance, 0, length);
                default:
                    throw new InvalidEnumArgumentException();
            }
        }

        /// <summary>
        /// Clamps absolute position and sets new direction
        /// </summary>
        public static float ClampDistance(float distance, ref int dir, CurvyClamping clamping, float length, float min, float max)
        {
            if (length == 0)
                return 0;
            min = Mathf.Clamp(min, 0, length);
            max = Mathf.Clamp(max, min, length);
            switch (clamping)
            {
                case CurvyClamping.Loop:
                    return min + Mathf.Repeat(distance, max - min);
                case CurvyClamping.PingPong:
                    if (Mathf.FloorToInt(distance / (max - min)) % 2 != 0)
                        dir *= -1;
                    return min + Mathf.PingPong(distance, max - min);
                case CurvyClamping.Clamp:
                    return Mathf.Clamp(distance, min, max);
                default:
                    throw new InvalidEnumArgumentException();
            }
        }

        #endregion

        /// <summary>
        /// Gets the default material, i.e. Curvy/Resources/CurvyDefaultMaterial
        /// </summary>
        public static Material GetDefaultMaterial()
        {
            Material mat = Resources.Load("CurvyDefaultMaterial") as Material;
            if (mat == null)
            {
                Shader shader = Shader.Find("Standard");
                if (shader != null) //this can happen, for example in an HDRP build
                    mat = new Material(shader);
            }

            if (mat == null)
                DTLog.LogWarning("[Curvy] Couldn't find Curvy's default material. Please raise a bug report.");

            return mat;
        }


        /// <summary>
        /// Does the same things as Mathf.Approximately, but with different handling of case where one of the two values is 0
        /// Considering inputs of 0 and 1E-7, Mathf.Approximately will return false, while this method will return true.
        /// </summary>
        public static bool Approximately(this float x, float y)
        {
            bool result;
            const float zeroComparisionMargin = 0.000009f;

            float nearlyZero = Mathf.Epsilon * 8f;

            float absX = Math.Abs(x);
            float absY = Math.Abs(y);

            if (absY < nearlyZero)
                result = absX < zeroComparisionMargin;
            else if (absX < nearlyZero)
                result = absY < zeroComparisionMargin;
            else
                result = Mathf.Approximately(x, y);
            return result;
        }

        /// <summary>
        /// Finds the index of x in an array of sorted values (ascendant order). If x not found, the closest smaller value's index is returned if any, -1 otherwise
        /// </summary>
        ///  <param name="array">The array to search into</param>
        ///  <param name="x">The element to search for</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int InterpolationSearch(float[] array, float x)
        {
            return InterpolationSearch(array, array.Length, x);
        }

        ///  <summary>
        ///  Finds the index of x in an array of sorted values (ascendant order). If x not found, the closest smaller value's index is returned if any, -1 otherwise
        ///  </summary>
        ///  <param name="array">The array to search into</param>
        ///  <param name="elementsCount">The number of elements of the array to search into</param>
        ///  <param name="x">The element to search for</param>
        public static int InterpolationSearch(float[] array, int elementsCount, float x)
        {
            int low = 0, high = (elementsCount - 1);

            while (low <= high && array[low] <= x && x <= array[high])
            {
                if (low == high)
                {
                    if (array[low] == x)
                        return low;
                    break;
                }
                int index = low + (int)((((high - low) / (array[high] - array[low])) * (x - array[low])));
                if (array[index] == x)
                    return index;
                if (array[index] < x)
                    low = index + 1;
                else
                    high = index - 1;
            }

            if (low > high)
            {
                (low, high) = (high, low);
            }

            if (x <= array[low])
            {
                while (low >= 0)
                {
                    if (array[low] <= x)
                        return low;
                    low--;
                }

                return 0;
            }

            if (array[high] < x)
            {
                while (high < elementsCount)
                {
                    if (x < array[high])
                        return high - 1;
                    high++;
                }

                return elementsCount - 1;
            }

            return -1;
        }

        /// <summary>
        /// Returns a mesh which boundaries are the input spline, similarly to what the Spline To Mesh window does, but simpler and less configurable.
        /// </summary>
        public static Mesh SplineToMesh(this CurvySpline spline)
        {
            Mesh result;

            Spline2Mesh splineToMesh = new Spline2Mesh();
            splineToMesh.Lines.Add(new SplinePolyLine(spline));
            splineToMesh.Apply(out result);

            if (String.IsNullOrEmpty(splineToMesh.Error) == false)
                Debug.Log(splineToMesh.Error);

            return result;
        }


        /// <summary>
        /// Given an input point, gets the index of the point in the array that is closest to the input point.
        /// </summary>
        /// <param name="point">the input point</param>
        /// <param name="points">A list of points to test against</param>
        /// <param name="pointsCount">The number of points to test against</param>
        /// <param name="index">the index of the closest point</param>
        /// <param name="fragement">a value between 0 and 1 indicating how close the input point is close to the point of index: index + 1</param>
        public static void GetNearestPointIndex(Vector3 point, Vector3[] points, int pointsCount, out int index, out float fragement)
        {
            float nearestSquaredDistance = float.MaxValue;
            int nearestIndex = 0;
            // get the nearest index
            for (int i = 0; i < pointsCount; i++)
            {
                Vector3 delta;
                delta.x = points[i].x - point.x;
                delta.y = points[i].y - point.y;
                delta.z = points[i].z - point.z;
                float squaredDistance = (delta.x * delta.x + delta.y * delta.y + delta.z * delta.z);
                if (squaredDistance <= nearestSquaredDistance)
                {
                    nearestSquaredDistance = squaredDistance;
                    nearestIndex = i;
                }
            }

            // collide p against the lines build by the index
            int leftIdx = (nearestIndex > 0) ? nearestIndex - 1 : -1;
            int rightIdx = (nearestIndex < pointsCount - 1) ? nearestIndex + 1 : -1;

            float leftFrag = 0;
            float rightFrag = 0;
            float leftSquaredDistance = float.MaxValue;
            float rightSquareDistance = float.MaxValue;
            {
                if (leftIdx > -1)
                    leftSquaredDistance = DTMath.LinePointDistanceSqr(points[leftIdx], points[nearestIndex], point, out leftFrag);
                if (rightIdx > -1)
                    rightSquareDistance = DTMath.LinePointDistanceSqr(points[nearestIndex], points[rightIdx], point, out rightFrag);
            }

            if (leftSquaredDistance < rightSquareDistance)
            {
                fragement = leftFrag;
                index = leftIdx;
            }
            else
            {
                fragement = rightFrag;
                index = nearestIndex;
            }
        }
    }

    #region ### Spline2Mesh ###

    /// <summary>
    /// Class to create a Mesh from a set of splines
    /// </summary>
    public class Spline2Mesh
    {
        #region ### Public Fields & Properties ###
        /// <summary>
        /// A list of splines (X/Y only) forming the resulting mesh
        /// </summary>
        public List<SplinePolyLine> Lines = new List<SplinePolyLine>();
        /// <summary>
        /// Winding rule used by triangulator
        /// </summary>
        public WindingRule Winding = WindingRule.EvenOdd;
        public Vector2 UVTiling = Vector2.one;
        public Vector2 UVOffset = Vector2.zero;
        public bool SuppressUVMapping;
        /// <summary>
        /// Whether UV2 should be set
        /// </summary>
        public bool UV2;
        /// <summary>
        /// Name of the returned mesh
        /// </summary>
        public string MeshName = string.Empty;
        /// <summary>
        /// Whether only vertices of the outline spline should be created
        /// </summary>
        public bool VertexLineOnly;

        public string Error { get; private set; }

        #endregion

        #region ### Private Fields ###

        private Tess mTess;
        private Mesh mMesh;

        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Create the Mesh using the current settings
        /// </summary>
        /// <param name="result">the resulting Mesh</param>
        /// <returns>true on success. If false, check the Error property!</returns>
        public bool Apply(out Mesh result)
        {
            ArrayPool<Vector3> pool = ArrayPoolsProvider.GetPool<Vector3>();

            mTess = null;
            mMesh = null;
            Error = string.Empty;
            bool triangulationSucceeded = triangulate();
            if (triangulationSucceeded)
            {
                mMesh = new Mesh();
                mMesh.name = MeshName;

                if (VertexLineOnly && Lines.Count > 0 && Lines[0] != null)
                {
                    SubArray<Vector3> vertices = Lines[0].GetVertexList();
                    mMesh.SetVertices(vertices.Array, 0, vertices.Count);
                    pool.Free(vertices);
                }
                else
                {
                    ContourVertex[] vertices = mTess.Vertices;
                    SubArray<Vector3> vector3s = pool.Allocate(vertices.Length);
                    UnityLibTessUtility.FromContourVertex(vertices, vector3s);
                    mMesh.SetVertices(vector3s.Array, 0, vector3s.Count);
                    mMesh.SetTriangles(mTess.ElementsArray.Value.Array, 0, mTess.ElementsArray.Value.Count, 0);
                    pool.Free(vector3s);
                }

                mMesh.RecalculateBounds();
                mMesh.RecalculateNormals();
                if (!SuppressUVMapping && !VertexLineOnly)
                {
                    Vector3 boundsSize = mMesh.bounds.size;
                    Vector3 boundsMin = mMesh.bounds.min;

                    float minSize = Mathf.Min(boundsSize.x, Mathf.Min(boundsSize.y, boundsSize.z));

                    bool minSizeIsX = minSize == boundsSize.x;
                    bool minSizeIsY = minSize == boundsSize.y;
                    bool minSizeIsZ = minSize == boundsSize.z;

                    Vector3[] vertices = mMesh.vertices;
                    int vertexCount = vertices.Length;

                    //set uv and uv2
                    SubArray<Vector2> uv;
                    SubArray<Vector2> uv2;
                    {
                        uv = ArrayPools.Vector2.Allocate(vertexCount);
                        Vector2[] uvArray = uv.Array;

                        uv2 = ArrayPools.Vector2.Allocate(UV2 ? vertexCount : 0);
                        Vector2[] uv2Array = uv2.Array;

                        for (int i = 0; i < vertexCount; i++)
                        {
                            float u;
                            float v;
                            Vector3 vertex = vertices[i];

                            if (minSizeIsX)
                            {
                                u = (vertex.y - boundsMin.y) / boundsSize.y;
                                v = (vertex.z - boundsMin.z) / boundsSize.z;
                            }
                            else if (minSizeIsY)
                            {
                                u = (vertex.z - boundsMin.z) / boundsSize.z;
                                v = (vertex.x - boundsMin.x) / boundsSize.x;
                            }
                            else if (minSizeIsZ)
                            {
                                u = (vertex.x - boundsMin.x) / boundsSize.x;
                                v = (vertex.y - boundsMin.y) / boundsSize.y;
                            }
                            else
                                throw new InvalidOperationException("Couldn't find the minimal bound dimension");

                            if (UV2)
                            {
                                uv2Array[i].x = u;
                                uv2Array[i].y = v;
                            }

                            u += UVOffset.x;
                            v += UVOffset.y;

                            u *= UVTiling.x;
                            v *= UVTiling.y;
                            uvArray[i].x = u;
                            uvArray[i].y = v;
                        }
                        mMesh.SetUVs(0, uv.Array, 0, uv.Count);
                        mMesh.SetUVs(1, uv2.Array, 0, uv2.Count);
                    }

                    ArrayPools.Vector2.Free(uv);
                    ArrayPools.Vector2.Free(uv2);
                    ArrayPools.Vector3.Free(vertices);
                }
            }
            result = mMesh;
            return triangulationSucceeded;
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATE */

        private bool triangulate()
        {
            if (Lines.Count == 0)
            {
                Error = "Missing splines to triangulate";
                return false;
            }

            if (VertexLineOnly)
                return true;

            mTess = new Tess();

            for (int i = 0; i < Lines.Count; i++)
            {
                if (Lines[i].Spline == null)
                {
                    Error = "Missing Spline";
                    return false;
                }
                if (!polyLineIsValid(Lines[i]))
                {
                    Error = Lines[i].Spline.name + ": Angle must be >0";
                    return false;
                }
                SubArray<Vector3> vertices = Lines[i].GetVertexList();
                if (vertices.Count < 3)
                {
                    Error = Lines[i].Spline.name + ": At least 3 Vertices needed!";
                    return false;
                }
                mTess.AddContour(UnityLibTessUtility.ToContourVertex(vertices, false), Lines[i].Orientation);
                ArrayPoolsProvider.GetPool<Vector3>().Free(vertices);
            }
            try
            {
                mTess.Tessellate(Winding, ElementType.Polygons, 3);
                return true;
            }
            catch (System.Exception e)
            {
                Error = e.Message;
            }

            return false;
        }

        private static bool polyLineIsValid(SplinePolyLine pl)
        {
            return (pl != null && pl.VertexMode == SplinePolyLine.VertexCalculation.ByApproximation ||
                    !Mathf.Approximately(0, pl.Angle));
        }

        /*! \endcond */
        #endregion
    }

    /// <summary>
    /// Spline Triangulation Helper Class
    /// </summary>
    [System.Serializable]
    public class SplinePolyLine
    {
        /// <summary>
        /// How to calculate vertices
        /// </summary>
        public enum VertexCalculation
        {
            /// <summary>
            /// Use Approximation points
            /// </summary>
            ByApproximation,
            /// <summary>
            /// By curvation angle
            /// </summary>
            ByAngle
        }

        /// <summary>
        /// Orientation order
        /// </summary>
        public ContourOrientation Orientation = ContourOrientation.Original;

        /// <summary>
        /// Base Spline
        /// </summary>
        public CurvySpline Spline;
        /// <summary>
        /// Vertex Calculation Mode
        /// </summary>
        public VertexCalculation VertexMode;
        /// <summary>
        /// Angle, used by VertexMode.ByAngle only
        /// </summary>
        public float Angle;
        /// <summary>
        /// Minimum distance, used by VertexMode.ByAngle only
        /// </summary>
        public float Distance;
        public Space Space;

        /// <summary>
        /// Creates a Spline2MeshCurve class using Spline2MeshCurve.VertexMode.ByApproximation
        /// </summary>
        public SplinePolyLine(CurvySpline spline) : this(spline, VertexCalculation.ByApproximation, 0, 0) { }
        /// <summary>
        /// Creates a Spline2MeshCurve class using Spline2MeshCurve.VertexMode.ByAngle
        /// </summary>
        public SplinePolyLine(CurvySpline spline, float angle, float distance) : this(spline, VertexCalculation.ByAngle, angle, distance) { }

        private SplinePolyLine(CurvySpline spline, VertexCalculation vertexMode, float angle, float distance, Space space = Space.World)
        {
            Spline = spline;
            VertexMode = vertexMode;
            Angle = angle;
            Distance = distance;
            Space = space;
        }
        /// <summary>
        /// Gets whether the spline is closed
        /// </summary>
        public bool IsClosed
        {
            get
            {
                return (Spline && Spline.Closed);
            }
        }

        /// <summary>
        /// Get vertices calculated using the current VertexMode
        /// </summary>
        /// <returns>an array of vertices</returns>
        [Obsolete("No more used in Curvy. Will get removed. Copy it if you still need it")]
        public Vector3[] GetVertices()
        {
            SubArray<Vector3> vertexList = GetVertexList();
            Vector3[] result = vertexList.CopyToArray(ArrayPools.Vector3);
            ArrayPools.Vector3.Free(vertexList);
            return result;
        }

        /// <summary>
        /// Get vertices calculated using the current VertexMode
        /// </summary>
        /// <returns>an array of vertices</returns>
        public SubArray<Vector3> GetVertexList()
        {
            SubArray<Vector3> points;
            switch (VertexMode)
            {
                case VertexCalculation.ByAngle:
                    points = GetPolygon(Spline, 0, 1, Angle, Distance, -1, false).ToSubArray();
                    break;
                default:
                    points = Spline.GetPositionsCache(Space.Self);
                    break;
            }

            if (Space == Space.World)
            {
                Vector3[] pointsArray = points.Array;
                int pointsCount = points.Count;
                for (int i = 0; i < pointsCount; i++)
                    pointsArray[i] = Spline.transform.TransformPoint(pointsArray[i]);
            }

            return points;
        }

        /// <summary>
        /// Gets an array of sampled points that follow some restrictions on the distance between two consecutive points, and the angle of tangents between those points
        /// </summary>
        /// <param name="fromTF">start TF</param>
        /// <param name="toTF">end TF</param>
        /// <param name="maxAngle">maximum angle in degrees between tangents</param>
        /// <param name="minDistance">minimum distance between two points</param>
        /// <param name="maxDistance">maximum distance between two points</param>
        /// <param name="vertexTF">Stores the TF of the resulting points</param>
        /// <param name="vertexTangents">Stores the Tangents of the resulting points</param>
        /// <param name="includeEndPoint">Whether the end position should be included</param>
        /// <param name="stepSize">the stepsize to use</param>
        /// <returns>an array of interpolated positions</returns>
        private static SubArrayList<Vector3> GetPolygon(CurvySpline spline, float fromTF, float toTF, float maxAngle, float minDistance, float maxDistance, bool includeEndPoint = true, float stepSize = 0.01f)
        {
            stepSize = Mathf.Clamp(stepSize, 0.002f, 1);
            maxDistance = (maxDistance == -1) ? spline.Length : Mathf.Clamp(maxDistance, 0, spline.Length);
            minDistance = Mathf.Clamp(minDistance, 0, maxDistance);
            if (!spline.Closed)
            {
                toTF = Mathf.Clamp01(toTF);
                fromTF = Mathf.Clamp(fromTF, 0, toTF);
            }
            SubArrayList<Vector3> vPos = new SubArrayList<Vector3>(50, ArrayPools.Vector3);

            int linearSteps = 0;
            float angleFromLast = 0;
            float distAccu = 0;
            Vector3 curPos = spline.Interpolate(fromTF);
            Vector3 curTangent = spline.GetTangent(fromTF);
            Vector3 lastPos = curPos;
            Vector3 lastTangent = curTangent;

            Action<Vector3> addPoint = ((position) =>
            {
                vPos.Add(position);
                angleFromLast = 0;
                distAccu = 0;

                linearSteps = 0;
            });

            addPoint(curPos);

            float tf = fromTF + stepSize;
            while (tf < toTF)
            {
                // Get Point Pos & Tangent
                spline.InterpolateAndGetTangent(tf % 1, out curPos, out curTangent);
                if (curTangent == Vector3.zero)
                {
                    Debug.Log("zero Tangent! Oh no!");
                }
                distAccu += (curPos - lastPos).magnitude;
                if (curTangent == lastTangent)
                    linearSteps++;
                if (distAccu >= minDistance)
                {
                    // Exceeding distance?
                    if (distAccu >= maxDistance)
                        addPoint(curPos);
                    else // Check angle
                    {
                        angleFromLast += Vector3.Angle(lastTangent, curTangent);
                        // Max angle reached or entering/leaving a linear zone
                        if (angleFromLast >= maxAngle || (linearSteps > 0 && angleFromLast > 0))
                            addPoint(curPos);
                    }
                }
                tf += stepSize;
                lastPos = curPos;
                lastTangent = curTangent;
            }
            if (includeEndPoint)
            {
                curPos = spline.Interpolate(toTF % 1);
                vPos.Add(curPos);
            }

            return vPos;
        }
    }
    #endregion
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Misc/CurvyUtility.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/Base/SplineProcessor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7ad2b5fc1f2381b4eb677973a985c772
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using FluffyUnderware.DevTools;
using JetBrains.Annotations;
using UnityEngine;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Base class for components that process a spline to produce something else, a line renderer or an edge collider for example
    /// </summary>
    [ExecuteAlways]
    public abstract class SplineProcessor : DTVersionedMonoBehaviour
    {
        /// <summary>
        /// The source spline
        /// </summary>
        public CurvySpline Spline
        {
            get { return m_Spline; }
            set
            {
                if (m_Spline != value)
                {
                    UnbindEvents();
                    m_Spline = value;
                    BindEvents();
                    Refresh();
                }
            }
        }

        /// <summary>
        /// Method that processes the associated <see cref="CurvySpline"/>
        /// </summary>
        abstract public void Refresh();

        #region private

        /*! \cond PRIVATE */

        [SerializeField] protected CurvySpline m_Spline;

        /*! \endcond */

        private void OnSplineRefresh(CurvySplineEventArgs e)
        {
            ProcessEvent(e.Spline);
        }

        private void OnSplineCoordinatesChanged(CurvySpline spline)
        {
            ProcessEvent(spline);
        }

        private void ProcessEvent([NotNull] CurvySpline spline)
        {
            if (Spline != spline)
                UnbindEvents(spline);
            else
                Refresh();
        }

        #endregion

        #region protected

        #region Unity callbacks

        protected virtual void Awake()
        {
            if (m_Spline == null)
            {
                m_Spline = GetComponent<CurvySpline>();
                if (ReferenceEquals(m_Spline, null) == false)
                    DTLog.Log(String.Format("[Curvy] Spline '{0}' was assigned to the {1} by default.", this.name, this.GetType().Name), this);
            }
        }

        protected virtual void OnEnable()
        {
            BindEvents();
        }

        protected virtual void OnDisable()
        {
            UnbindEvents();
        }

#if UNITY_EDITOR
        protected virtual void OnValidate()
        {
            UnbindEvents();
            BindEvents();

            Refresh();
        }
#endif
        protected virtual void Start()
        {
            Refresh();
        }

        #endregion

        protected void BindEvents()
        {
            if (Spline)
            {
                Spline.OnRefresh.AddListenerOnce(OnSplineRefresh);
                Spline.OnGlobalCoordinatesChanged += OnSplineCoordinatesChanged;
            }
        }

        protected void UnbindEvents()
        {
            if (Spline)
                UnbindEvents(Spline);
        }

        private void UnbindEvents([NotNull] CurvySpline spline)
        {
            spline.OnRefresh.RemoveListener(OnSplineRefresh);
            spline.OnGlobalCoordinatesChanged -= OnSplineCoordinatesChanged;
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/Base/SplineProcessor.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyGlobalManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f7da6ae8fd39ffa439ccf96f0d3da992
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Pools;
using Object = UnityEngine.Object;


namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Curvy Global Scene Manager component
    /// </summary>
    [ExecuteInEditMode]
    [RequireComponent(typeof(PoolManager))]
    [RequireComponent(typeof(ArrayPoolsSettings))]
    [HelpURL(CurvySpline.DOCLINK + "curvyglobalmanager")]
    public class CurvyGlobalManager : DTSingleton<CurvyGlobalManager>
    {
        #region Do not move these

        //Do not move these. If they are moved to another file or lower in this file (bellow their usage by say DefaultGizmoColor), this issue will happen:
        // https://stackoverflow.com/questions/22927167/strange-behavior-on-static-members-of-a-class-hows-this-possible
        // https://github.com/RalfKoban/MiKo-Analyzers/issues/295

        /// <summary>
        /// Default value of the <see cref="DefaultGizmoColor"/> 
        /// </summary>
        public static readonly Color DefaultDefaultGizmoColor = new Color(0.71f, 0.71f, 0.71f);
        /// <summary>
        /// Default value of the <see cref="DefaultGizmoSelectionColor"/>
        /// </summary>
        public static readonly Color DefaultDefaultGizmoSelectionColor = new Color(0.6f, 0.15f, 0.68f);
        /// <summary>
        /// Default value of the <see cref="GizmoOrientationColor"/>
        /// </summary>
        public static readonly Color DefaultGizmoOrientationColor = new Color(0.75f, 0.75f, 0.4f);
        #endregion

        #region ### Public Static Fields (Editor->Runtime Bridge) ###
        public static bool HideManager = false;
        /// <summary>
        /// Whether the output of Curvy Generators should be saved in the scene file.
        /// Disable this option to reduce the size of scene files. This might increase the saving time for complex scenes.
        /// This option applies only on generators that are enabled and have Auto Refresh set to true
        /// </summary>
        public static bool SaveGeneratorOutputs = true;
        /// <summary>
        /// Resolution of SceneView spline rendering
        /// </summary>
        public static float SceneViewResolution = 0.5f;
        /// <summary>
        /// Default spline color
        /// </summary>
        public static Color DefaultGizmoColor = DefaultDefaultGizmoColor;
        /// <summary>
        /// Default selected spline color
        /// </summary>
        public static Color DefaultGizmoSelectionColor = DefaultDefaultGizmoSelectionColor;
        /// <summary>
        /// Default interpolation used by new splines
        /// </summary>
        public static CurvyInterpolation DefaultInterpolation = CurvyInterpolation.CatmullRom;
        /// <summary>
        /// Size of control point gizmos
        /// </summary>
        public static float GizmoControlPointSize = 0.15f;
        /// <summary>
        /// Size of orientation gizmo
        /// </summary>
        public static float GizmoOrientationLength = 1f;
        /// <summary>
        /// Orientation gizmo color
        /// </summary>
        public static Color GizmoOrientationColor = DefaultGizmoOrientationColor;
        public static int SplineLayer = 0;
        /// <summary>
        /// Default view settings
        /// </summary>
        public static CurvySplineGizmos Gizmos = CurvySplineGizmos.Curve | CurvySplineGizmos.Connections;

        public static bool ShowCurveGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Curve) == CurvySplineGizmos.Curve; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Curve;
                else
                    Gizmos &= ~CurvySplineGizmos.Curve;
            }
        }

        public static bool ShowConnectionsGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Connections) == CurvySplineGizmos.Connections; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Connections;
                else
                    Gizmos &= ~CurvySplineGizmos.Connections;
            }
        }

        public static bool ShowApproximationGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Approximation) == CurvySplineGizmos.Approximation; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Approximation;
                else
                    Gizmos &= ~CurvySplineGizmos.Approximation;
            }
        }

        public static bool ShowTangentsGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Tangents) == CurvySplineGizmos.Tangents; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Tangents;
                else
                    Gizmos &= ~CurvySplineGizmos.Tangents;
            }
        }

        public static bool ShowOrientationGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Orientation) == CurvySplineGizmos.Orientation; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Orientation;
                else
                    Gizmos &= ~CurvySplineGizmos.Orientation;
            }
        }

        public static bool ShowTFsGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.TFs) == CurvySplineGizmos.TFs; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.TFs;
                else
                    Gizmos &= ~CurvySplineGizmos.TFs;
            }
        }

        public static bool ShowRelativeDistancesGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.RelativeDistances) == CurvySplineGizmos.RelativeDistances; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.RelativeDistances;
                else
                    Gizmos &= ~CurvySplineGizmos.RelativeDistances;
            }
        }

        public static bool ShowLabelsGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Labels) == CurvySplineGizmos.Labels; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Labels;
                else
                    Gizmos &= ~CurvySplineGizmos.Labels;
            }
        }

        public static bool ShowMetadataGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Metadata) == CurvySplineGizmos.Metadata; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Metadata;
                else
                    Gizmos &= ~CurvySplineGizmos.Metadata;
            }
        }

        public static bool ShowBoundsGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.Bounds) == CurvySplineGizmos.Bounds; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.Bounds;
                else
                    Gizmos &= ~CurvySplineGizmos.Bounds;
            }
        }

        public static bool ShowOrientationAnchorsGizmo
        {
            get { return (Gizmos & CurvySplineGizmos.OrientationAnchors) == CurvySplineGizmos.OrientationAnchors; }
            set
            {
                if (value)
                    Gizmos |= CurvySplineGizmos.OrientationAnchors;
                else
                    Gizmos &= ~CurvySplineGizmos.OrientationAnchors;
            }
        }

        #endregion

        #region ### Private Fields ###

        private PoolManager mPoolManager;
        private ComponentPool mControlPointPool;
        private ArrayPoolsSettings arrayPoolsSettings;
        #endregion

        #region ### Public Methods & Properties ###


        /// <summary>
        /// Gets the PoolManager
        /// </summary>
        public PoolManager PoolManager
        {
            get
            {
                if (mPoolManager == null)
                    mPoolManager = GetComponent<PoolManager>();
                return mPoolManager;
            }
        }

        public ComponentPool ControlPointPool
        {
            get
            {
                return mControlPointPool;
            }
        }

        public ArrayPoolsSettings ArrayPoolsSettings
        {
            get
            {
                if (arrayPoolsSettings == null)
                    arrayPoolsSettings = GetComponent<ArrayPoolsSettings>();
                return arrayPoolsSettings;
            }
        }

        /// <summary>
        /// Gets all connections in the scene
        /// </summary>
        public CurvyConnection[] Connections
        {
            get
            {
                return GetComponentsInChildren<CurvyConnection>();
            }
        }

        /// <summary>
        /// Returns all the connections that are exclusively connecting cps within the splines parameter
        /// </summary>
        /// <param name="splines"></param>
        /// <returns></returns>
        public CurvyConnection[] GetContainingConnections(params CurvySpline[] splines)
        {
            List<CurvyConnection> connectionsResult = new List<CurvyConnection>();
            List<CurvySpline> splinesList = new List<CurvySpline>(splines);
            foreach (CurvySpline spline in splinesList)
            {
                foreach (CurvySplineSegment controlPoint in spline.ControlPointsList)
                    if (controlPoint.Connection != null && !connectionsResult.Contains(controlPoint.Connection))
                    {
                        bool add = true;
                        // only process connections if all involved splines are part of the prefab
                        foreach (CurvySplineSegment connectedControlPoint in controlPoint.Connection.ControlPointsList)
                        {
                            if (connectedControlPoint.Spline != null && !splinesList.Contains(connectedControlPoint.Spline))
                            {
                                add = false;
                                break;
                            }
                        }
                        if (add)
                            connectionsResult.Add(controlPoint.Connection);
                    }
            }

            return connectionsResult.ToArray();
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */
        public override void Awake()
        {
            base.Awake();
            name = "_CurvyGlobal_";
            transform.SetAsLastSibling();
            // Unity 5.3 introduces buug that hides GameObject when calling this outside playmode!
            if (Application.isPlaying)
                Object.DontDestroyOnLoad(this);

            mPoolManager = GetComponent<PoolManager>();

            PoolSettings s = new PoolSettings()
            {
                MinItems = 0,
                Threshold = 50,
                Prewarm = true,
                AutoCreate = true,
                AutoEnableDisable = true
            };
            mControlPointPool = mPoolManager.CreateComponentPool<CurvySplineSegment>(s);

            arrayPoolsSettings = GetComponent<ArrayPoolsSettings>();
            //this is needed even though there is a [RequireComponent(typeof(ArrayPoolsSettings))] attribute, because that attribute works only at the moment the component is added, and does nothing for previously existing instances
            if (arrayPoolsSettings == null)
                arrayPoolsSettings = gameObject.AddComponent<ArrayPoolsSettings>();
        }

        private void Start()
        {
            if (HideManager)
                gameObject.hideFlags = HideFlags.HideInHierarchy;
            else
                gameObject.hideFlags = HideFlags.None;
        }

        /*! \endcond */
        #endregion

        #region ### Privates & Internals ###
        /*! \cond PRIVATE */

        [RuntimeInitializeOnLoadMethod]
        private static void LoadRuntimeSettings()
        {
            if (!PlayerPrefs.HasKey("Curvy_MaxCachePPU"))
                SaveRuntimeSettings();
            SceneViewResolution = DTUtility.GetPlayerPrefs("Curvy_SceneViewResolution", SceneViewResolution);
            HideManager = DTUtility.GetPlayerPrefs("Curvy_HideManager", HideManager);
            DefaultGizmoColor = DTUtility.GetPlayerPrefs("Curvy_DefaultGizmoColor", DefaultGizmoColor);
            DefaultGizmoSelectionColor = DTUtility.GetPlayerPrefs("Curvy_DefaultGizmoSelectionColor", DefaultGizmoColor);
            DefaultInterpolation = DTUtility.GetPlayerPrefs("Curvy_DefaultInterpolation", DefaultInterpolation);
            GizmoControlPointSize = DTUtility.GetPlayerPrefs("Curvy_ControlPointSize", GizmoControlPointSize);
            GizmoOrientationLength = DTUtility.GetPlayerPrefs("Curvy_OrientationLength", GizmoOrientationLength);
            GizmoOrientationColor = DTUtility.GetPlayerPrefs("Curvy_OrientationColor", GizmoOrientationColor);
            Gizmos = DTUtility.GetPlayerPrefs("Curvy_Gizmos", Gizmos);
            SplineLayer = DTUtility.GetPlayerPrefs("Curvy_SplineLayer", SplineLayer);
            SaveGeneratorOutputs = DTUtility.GetPlayerPrefs("Curvy_SaveGeneratorOutputs", SaveGeneratorOutputs);
        }

        public static void SaveRuntimeSettings()
        {
            //TODO some of these are not runtime settings at all, fix that
            DTUtility.SetPlayerPrefs("Curvy_SceneViewResolution", SceneViewResolution);
            DTUtility.SetPlayerPrefs("Curvy_HideManager", HideManager);
            DTUtility.SetPlayerPrefs("Curvy_DefaultGizmoColor", DefaultGizmoColor);
            DTUtility.SetPlayerPrefs("Curvy_DefaultGizmoSelectionColor", DefaultGizmoSelectionColor);
            DTUtility.SetPlayerPrefs("Curvy_DefaultInterpolation", DefaultInterpolation);
            DTUtility.SetPlayerPrefs("Curvy_ControlPointSize", GizmoControlPointSize);
            DTUtility.SetPlayerPrefs("Curvy_OrientationLength", GizmoOrientationLength);
            DTUtility.SetPlayerPrefs("Curvy_OrientationColor", GizmoOrientationColor);
            DTUtility.SetPlayerPrefs("Curvy_Gizmos", Gizmos);
            DTUtility.SetPlayerPrefs("Curvy_SplineLayer", SplineLayer);
            DTUtility.SetPlayerPrefs("Curvy_SaveGeneratorOutputs", SaveGeneratorOutputs);
            PlayerPrefs.Save();
        }



        public override void MergeDoubleLoaded(IDTSingleton newInstance)
        {
            base.MergeDoubleLoaded(newInstance);

            CurvyGlobalManager other = newInstance as CurvyGlobalManager;
            // Merge connection from a doubled CurvyGlobalManager before it get destroyed by DTSingleton
            CurvyConnection[] otherConnections = other.Connections;
            for (int i = 0; i < otherConnections.Length; i++)
                otherConnections[i].transform.SetParent(this.transform);
        }


        /*! \endcond */
        #endregion



    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyGlobalManager.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyGLRenderer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d025f1b57fec5ca4f8585046c3fd23c8
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.DevTools;
using System.Collections.Generic;
using FluffyUnderware.Curvy.Pools;
using ToolBuddy.Pooling.Collections;
using ToolBuddy.Pooling.Pools;
// =====================================================================
// Copyright 2013-2014 FluffyUnderware
// All rights reserved
// =====================================================================
using UnityEngine;
/* Renders curvy spline(s) approximation using GL.Draw
 * 
 * Add this script to a camera
 */

namespace FluffyUnderware.Curvy.Components
{

    /// <summary>
    /// Class to render a spline using GL.Draw
    /// </summary>
    /// <remarks>Useful for debugging</remarks>
    [HelpURL(CurvySpline.DOCLINK + "curvyglrenderer")]
    [AddComponentMenu("Curvy/Misc/Curvy GL Renderer")]
    public class CurvyGLRenderer : DTVersionedMonoBehaviour
    {
        [ArrayEx(ShowAdd = false, Draggable = false)]
        public List<GLSlotData> Splines = new List<GLSlotData>();

        private Material lineMaterial;

        private void CreateLineMaterial()
        {
            if (!lineMaterial)
            {
#if UNITY_5_0 || UNITY_4_6
                lineMaterial = new Material("Shader \"Lines/Colored Blended\" {" +
                    "SubShader { Pass { " +
                    "    Blend SrcAlpha OneMinusSrcAlpha " +
                    "    ZWrite Off Cull Off Fog { Mode Off } " +
                    "    BindChannels {" +
                    "      Bind \"vertex\", vertex Bind \"color\", color }" +
                    "} } }");
                    
#else
                lineMaterial = new Material(Shader.Find("Hidden/Internal-Colored"));
#endif
                lineMaterial.hideFlags = HideFlags.HideAndDontSave;
                lineMaterial.shader.hideFlags = HideFlags.HideAndDontSave;
            }
        }

#if UNITY_EDITOR
        private void OnValidate()
        {
            sanitize();
        }
#endif

        private void OnPostRender()
        {
            sanitize();
            CreateLineMaterial();
            for (int i = Splines.Count - 1; i >= 0; i--)
            {
                Splines[i].Spline.OnRefresh.AddListenerOnce(OnSplineRefresh);
                if (Splines[i].VertexData.Count == 0)
                    Splines[i].GetVertexData();

                Splines[i].Render(lineMaterial);
            }

        }

        private void sanitize()
        {
            for (int i = Splines.Count - 1; i >= 0; i--)
                if (Splines[i] == null || Splines[i].Spline == null)
                    Splines.RemoveAt(i);
        }

        private void OnSplineRefresh(CurvySplineEventArgs e)
        {
            GLSlotData slot = getSlot((CurvySpline)e.Sender);
            if (slot == null)
                ((CurvySpline)e.Sender).OnRefresh.RemoveListener(OnSplineRefresh);
            else
                slot.VertexData.Clear();
        }

        private GLSlotData getSlot(CurvySpline spline)
        {
            if (spline)
            {
                foreach (GLSlotData slot in Splines)
                    if (slot.Spline == spline)
                        return slot;
            }
            return null;
        }

        public void Add(CurvySpline spline)
        {
            if (spline != null)
                Splines.Add(new GLSlotData() { Spline = spline });
        }

        public void Remove(CurvySpline spline)
        {
            for (int i = Splines.Count - 1; i >= 0; i--)
                if (Splines[i].Spline == spline)
                    Splines.RemoveAt(i);
        }

    }

    /// <summary>
    /// Helper class used by CurvyGLRenderer
    /// </summary>
    [System.Serializable]
    public class GLSlotData
    {
        [SerializeField]
        public CurvySpline Spline;
        public Color LineColor = CurvyGlobalManager.DefaultGizmoColor;
        public List<Vector3[]> VertexData = new List<Vector3[]>();

        public void GetVertexData()
        {

            VertexData.Clear();
            List<CurvySpline> splines = new List<CurvySpline>
            {
                Spline
            };

            ArrayPool<Vector3> vector3ArrayPool = ArrayPools.Vector3;

            for (int i = 0; i < splines.Count; i++)
                if (splines[i].IsInitialized)
                {
                    SubArray<Vector3> positionsCache = splines[i].GetPositionsCache(Space.World);
                    //OPTIM avoid the CopyToArray call, make the class work with SubArrays
                    VertexData.Add(positionsCache.CopyToArray(vector3ArrayPool));
                    vector3ArrayPool.Free(positionsCache);
                }
        }

        public void Render(Material mat)
        {
            for (int i = 0; i < VertexData.Count; i++)
                if (VertexData[i].Length > 0)
                {
                    mat.SetPass(0);
                    GL.Begin(GL.LINES);
                    GL.Color(LineColor);
                    for (int v = 1; v < VertexData[i].Length; v++)
                    {
                        GL.Vertex(VertexData[i][v - 1]);
                        GL.Vertex(VertexData[i][v]);
                    }
                    GL.End();
                }
        }
    }


}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyGLRenderer.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyLineRenderer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f2d74ea90b9d85945b180cf66c7c0f6b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.Curvy.Pools;
using UnityEngine;
using FluffyUnderware.DevTools;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy.Components
{
    /// <summary>
    /// Class to drive a LineRenderer with a CurvySpline
    /// </summary>
    [AddComponentMenu(ComponentPath)]
    [RequireComponent(typeof(LineRenderer))]
    [HelpURL(CurvySpline.DOCLINK + "curvylinerenderer")]
    public class CurvyLineRenderer : SplineProcessor
    {
        public const string ComponentPath = "Curvy/Converters/Curvy Line Renderer";

        private LineRenderer mRenderer;

        protected override void Awake()
        {
            mRenderer = GetComponent<LineRenderer>();
            base.Awake();
        }

        protected override void OnEnable()
        {
            mRenderer = GetComponent<LineRenderer>();
            base.OnEnable();
        }

        private void Update()
        {
            EnforceWorldSpaceUsage();
        }

        private void EnforceWorldSpaceUsage()
        {
            if (mRenderer.useWorldSpace == false)
            {
                mRenderer.useWorldSpace = true;
                DTLog.Log("[Curvy] CurvyLineRenderer: Line Renderer's Use World Space was overriden to true", this);
            }
        }

        /// <summary>
        /// Update the <see cref="LineRenderer"/>'s points with the cache points of the <see cref="CurvySpline"/>
        /// </summary>
        public override void Refresh()
        {
            if (Spline)
            {
                if (Spline.IsInitialized && Spline.Dirty == false)
                {
#if CURVY_SANITY_CHECKS
                    Assert.IsTrue(mRenderer != null);
#endif
                    EnforceWorldSpaceUsage();
                    SubArray<Vector3> positions = Spline.GetPositionsCache(Space.World);
                    mRenderer.positionCount = positions.Count;
                    mRenderer.SetPositions(positions.Array);
                    ArrayPools.Vector3.Free(positions);
                }
                else if (mRenderer != null)
                {
                    EnforceWorldSpaceUsage();
                    mRenderer.positionCount = 0;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvyLineRenderer.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvySplineToEdgeCollider2D.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b69e477d494cd7d4197144300b3a3a51
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using FluffyUnderware.Curvy.Pools;
using UnityEngine;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Converts a <see cref="CurvySpline"/> to an <see cref="EdgeCollider2D"/> 
    /// </summary>
    [AddComponentMenu(ComponentPath)]
    [RequireComponent(typeof(EdgeCollider2D))]
    [HelpURL(CurvySpline.DOCLINK + "edgecollider2d")]
    public class CurvySplineToEdgeCollider2D : SplineProcessor
    {
        public const string ComponentPath = "Curvy/Converters/Curvy Spline To Edge Collider 2D";

        private EdgeCollider2D edgeCollider2D;

        protected override void Awake()
        {
            edgeCollider2D = GetComponent<EdgeCollider2D>();
            base.Awake();
        }

        protected override void OnEnable()
        {
            edgeCollider2D = GetComponent<EdgeCollider2D>();
            base.OnEnable();
        }

        /// <summary>
        /// Update the <see cref="EdgeCollider2D.points"/> with the cache points of the <see cref="CurvySpline"/>
        /// </summary>
        public override void Refresh()
        {
            if (Spline)
            {
                if (Spline.IsInitialized && Spline.Dirty == false)
                {
#if CURVY_SANITY_CHECKS
                    Assert.IsTrue(edgeCollider2D != null);
#endif
                    SubArray<Vector3> positions = Spline.GetPositionsCache(Space.Self);
                    SubArray<Vector2> positions2D = ArrayPools.Vector2.AllocateExactSize(positions.Count);
                    Vector3[] positionsArray = positions.Array;
                    Vector2[] positions2DArray = positions2D.Array;
                    for (var i = 0; i < positions.Count; i++)
                    {
                        positions2DArray[i].x = positionsArray[i].x;
                        positions2DArray[i].y = positionsArray[i].y;
                    }
                    edgeCollider2D.points = positions2DArray;
                    ArrayPools.Vector2.Free(positions2D);
                    ArrayPools.Vector3.Free(positions);
                }
                else if (edgeCollider2D != null)
                {
                    edgeCollider2D.points = Array.Empty<Vector2>();
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/CurvySplineToEdgeCollider2D.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/NearestSplinePoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a062b6bd68605bc4fb191834584d2d0d
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.DevTools;
using UnityEngine;
using UnityEditor;
using UnityEngine.Events;

namespace FluffyUnderware.Curvy
{

    /// <summary>
    /// Given a <see cref="CurvySpline"/> and an input position, this class will provide you with the nearest point to that position on the given spline.
    /// The nearest position is provided either in an <see cref="OnUpdated"/> event, or as an override of the position of the <see cref="TargetPosition"/>
    /// </summary>
    /// <remarks>This script simply calls the <see cref="CurvySpline.GetNearestPoint"/> method. If you are a programmer, you don't need to go through this script, just call <see cref="CurvySpline.GetNearestPoint"/></remarks>
    [HelpURL(CurvySpline.DOCLINK + "nearestsplinepoint")]
    [AddComponentMenu("Curvy/Misc/Nearest Spline Point")]
    [ExecuteAlways]
    public class NearestSplinePoint : MonoBehaviour
    {
        /// <summary>
        /// The <see cref="CurvySpline"/> on which the nearest position is searched for
        /// </summary>
        [Tooltip("The spline on which the nearest position is searched for")]
        public CurvySpline Spline;
        /// <summary>
        /// A transform which position will be used as the input position for the lookup
        /// </summary>
        [Tooltip("A transform which position will be used as the input position for the lookup")]
        public Transform SourcePosition;
        /// <summary>
        /// A transform which position will be updated with the nearest point on Spline to Source Position
        /// </summary>
        [Tooltip("A transform which position will be updated with the nearest point on Spline to Source Position")]
        public Transform TargetPosition;
        /// <summary>
        /// When to run the lookup
        /// </summary>
        [Tooltip("When to run the lookup")]
        public CurvyUpdateMethod UpdateIn;
        /// <summary>
        /// At each update, this event is called with the result of the lookup
        /// </summary>
        [Tooltip("At each update, this event is called with the result of the lookup")]
        public UnityEventEx<Vector3> OnUpdated = new UnityEventEx<Vector3>();

        private void Process()
        {
            if (SourcePosition && Spline && Spline.IsInitialized && Spline.Dirty == false)
            {
                Vector3 destinationPosition = Spline.GetNearestPoint(SourcePosition.position, Space.Self);
                if (TargetPosition)
                    TargetPosition.position = destinationPosition;
                OnUpdated?.Invoke(destinationPosition);
            }
        }

        #region Updating methods

#if UNITY_EDITOR
        private void Update()
        {
            if (UpdateIn == CurvyUpdateMethod.Update)
                Process();
        }

        private void LateUpdate()
        {
            if (UpdateIn == CurvyUpdateMethod.LateUpdate ||
                (Application.isPlaying == false && UpdateIn == CurvyUpdateMethod.FixedUpdate)) // In edit mode, fixed updates are not called, so we update here instead
                Process();
        }

        private void FixedUpdate()
        {
            if (UpdateIn == CurvyUpdateMethod.FixedUpdate)
                Process();
        }

        protected virtual void OnEnable()
        {
            EditorApplication.update += OnEditorUpdate;
        }

        protected virtual void OnDisable()
        {
            EditorApplication.update -= OnEditorUpdate;
        }

        private void OnEditorUpdate()
        {
            if (Application.isPlaying == false)
                Process();
        }
#endif

        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Other Components/NearestSplinePoint.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Pools/ArrayPools.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e950a29ae4d3e4f40b03ecd2271da862
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.Curvy.Generator;
using ToolBuddy.Pooling;
using ToolBuddy.Pooling.Pools;
using UnityEngine;

namespace FluffyUnderware.Curvy.Pools
{
    /// <summary>
    /// A class which sole purpose is to centralize references to the various <see cref="ArrayPool{T}"/>s instances
    /// </summary>
    public static class ArrayPools
    {
        static ArrayPools()
        {
            Int32 = ArrayPoolsProvider.GetPool<int>();
            Single = ArrayPoolsProvider.GetPool<float>();
            Vector2 = ArrayPoolsProvider.GetPool<Vector2>();
            Vector3 = ArrayPoolsProvider.GetPool<Vector3>();
            Vector4 = ArrayPoolsProvider.GetPool<Vector4>();
            CGSpot = ArrayPoolsProvider.GetPool<CGSpot>();
        }

        /// <summary>
        /// Gets the reference to the unique <see cref="ArrayPool{T}"/> of said type
        /// </summary>
        public static ArrayPool<Vector2> Vector2 { get; }
        /// <summary>
        /// Gets the reference to the unique <see cref="ArrayPool{T}"/> of said type
        /// </summary>
        public static ArrayPool<Vector3> Vector3 { get; }
        /// <summary>
        /// Gets the reference to the unique <see cref="ArrayPool{T}"/> of said type
        /// </summary>
        public static ArrayPool<Vector4> Vector4 { get; }
        /// <summary>
        /// Gets the reference to the unique <see cref="ArrayPool{T}"/> of said type
        /// </summary>
        public static ArrayPool<int> Int32 { get; }
        /// <summary>
        /// Gets the reference to the unique <see cref="ArrayPool{T}"/> of said type
        /// </summary>
        public static ArrayPool<float> Single { get; }
        /// <summary>
        /// Gets the reference to the unique <see cref="ArrayPool{T}"/> of said type
        /// </summary>
        public static ArrayPool<CGSpot> CGSpot { get; }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Pools/ArrayPools.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Pools/ArrayPoolsSettings.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6fd1ed065a5ad4241ade72657b4c6e4b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using FluffyUnderware.DevTools;
using ToolBuddy.Pooling.Pools;
using UnityEngine;

namespace FluffyUnderware.Curvy.Pools
{
    /// <summary>
    /// A component that allows setting, via the editor, the settings of the used <see cref="ToolBuddy.Pooling.Pools.ArrayPool{T}"/>s
    /// </summary>
    [HelpURL(DTUtility.HelpUrlBase + "arraypoolsettings")]
    [ExecuteAlways]
    [DisallowMultipleComponent]
    public class ArrayPoolsSettings : DTVersionedMonoBehaviour
    {
        [SerializeField]
        [Tooltip("The maximal number of elements of type Vector2 allowed to be stored in the arrays' pool waiting to be reused")]
        private long vector2Capacity = 100_000;

        [SerializeField]
        [Tooltip("The maximal number of elements of type Vector3 allowed to be stored in the arrays' pool waiting to be reused")]
        private long vector3Capacity = 100_000;

        [SerializeField]
        [Tooltip("The maximal number of elements of type Vector4 allowed to be stored in the arrays' pool waiting to be reused")]
        private long vector4Capacity = 100_000;

        [SerializeField]
        [Tooltip("The maximal number of elements of type Int32 allowed to be stored in the arrays' pool waiting to be reused")]
        private long intCapacity = 100_000;

        [SerializeField]
        [Tooltip("The maximal number of elements of type Single (a.k.a float) allowed to be stored in the arrays' pool waiting to be reused")]
        private long floatCapacity = 10_000;

        [SerializeField]
        [Tooltip("The maximal number of elements of type CGSpots allowed to be stored in the arrays' pool waiting to be reused")]
        private long cgSpotCapacity = 10_000;
        
        [Tooltip("Log in the console each time an array pool allocates a new array in memory")]
        [SerializeField]
        private bool logAllocations = false;

        /// <summary>
        /// The maximal number of elements of type Vector2 allowed to be stored in the arrays' pool waiting to be reused
        /// </summary>
        public long Vector2Capacity
        {
            get { return vector2Capacity; }
            set
            {
                vector2Capacity = Math.Max(0, value);
                ArrayPools.Vector2.ElementsCapacity = vector2Capacity;

            }
        }

        /// <summary>
        /// The maximal number of elements of type Vector3 allowed to be stored in the arrays' pool waiting to be reused
        /// </summary>
        public long Vector3Capacity
        {
            get { return vector3Capacity; }
            set
            {
                vector3Capacity = Math.Max(0, value);
                ArrayPools.Vector3.ElementsCapacity = vector3Capacity;
            }
        }

        /// <summary>
        /// The maximal number of elements of type Vector4 allowed to be stored in the arrays' pool waiting to be reused
        /// </summary>
        public long Vector4Capacity
        {
            get { return vector4Capacity; }
            set
            {
                vector4Capacity = Math.Max(0, value);
                ArrayPools.Vector4.ElementsCapacity = vector4Capacity;
            }
        }

        /// <summary>
        /// The maximal number of elements of type Int32 allowed to be stored in the arrays' pool waiting to be reused
        /// </summary>
        public long IntCapacity
        {
            get { return intCapacity; }
            set
            {
                intCapacity = Math.Max(0, value);
                ArrayPools.Int32.ElementsCapacity = IntCapacity;
            }
        }

        /// <summary>
        /// The maximal number of elements of type Single allowed to be stored in the arrays' pool waiting to be reused
        /// </summary>
        public long FloatCapacity
        {
            get { return floatCapacity; }
            set
            {
                floatCapacity = Math.Max(0, value);
                ArrayPools.Single.ElementsCapacity = floatCapacity;
            }
        }

        /// <summary>
        /// The maximal number of elements of type CGSpot allowed to be stored in the arrays' pool waiting to be reused
        /// </summary>
        public long CGSpotCapacity
        {
            get { return cgSpotCapacity; }
            set
            {
                cgSpotCapacity = Math.Max(0, value);
                ArrayPools.CGSpot.ElementsCapacity = cgSpotCapacity;
            }
        }
        /// <summary>
        /// Log in the console each time an array pool allocates a new array in memory
        /// </summary>
        public bool LogAllocations
        {
            get { return logAllocations; }
            set
            {
                logAllocations = value;
                ArrayPools.CGSpot.LogAllocations = logAllocations;
                ArrayPools.Int32.LogAllocations = logAllocations;
                ArrayPools.Single.LogAllocations = logAllocations;
                ArrayPools.Vector2.LogAllocations = logAllocations;
                ArrayPools.Vector3.LogAllocations = logAllocations;
                ArrayPools.Vector4.LogAllocations = logAllocations;
            }
        }

        private void Reset() => ValidateAndApply();

        private void OnValidate() => ValidateAndApply();

        private void Awake() => ValidateAndApply();

        private void OnEnable()
        {
#if UNITY_EDITOR
            if (FindObjectsOfType<ArrayPoolsSettings>().Length > 1)
                DTLog.LogWarning("[Curvy] More than one instance of 'Array Pools Settings' detected. You should keep only one instance of this script.", this);
#endif
            ValidateAndApply();
        }

        private void Start() => ValidateAndApply();

        private void ValidateAndApply()
        {
            Vector2Capacity = vector2Capacity;
            Vector3Capacity = vector3Capacity;
            Vector4Capacity = vector4Capacity;
            IntCapacity = intCapacity;
            FloatCapacity = floatCapacity;
            CGSpotCapacity = cgSpotCapacity;
            LogAllocations = logAllocations;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Pools/ArrayPoolsSettings.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSCircle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: db925cc84d8129f40818e17a75bc7ef3
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Shapes
{
    /// <summary>
    /// Circle Shape (2D)
    /// </summary>
    [CurvyShapeInfo("2D/Circle")]
    [RequireComponent(typeof(CurvySpline))]
    [AddComponentMenu("Curvy/Shapes/Circle")]
    public class CSCircle : CurvyShape2D
    {
        [Positive(Tooltip="Number of Control Points")]
        [SerializeField]
        private int m_Count=4;
        public int Count
        {
            get { return m_Count; }
            set
            {
                int v = Mathf.Max(2, value);
                if (m_Count != v)
                {
                    m_Count = v;
                    Dirty = true;
                }
            }
        }

        [SerializeField] private float m_Radius = 1;
        public float Radius
        {
            get { return m_Radius;}
            set 
            {
                float v = Mathf.Max(0, value);
                if (m_Radius != v)
                {
                    m_Radius = v;
                    Dirty = true;
                }
            }
        }


#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Count = m_Count;
            Radius = m_Radius;
        }
#endif

        protected override void Reset()
        {
            base.Reset();
            Count = 4;
            Radius = 1;
        }

        protected override void ApplyShape()
        {
            PrepareSpline(CurvyInterpolation.Bezier);
            PrepareControlPoints(Count);
            float d = 360f * Mathf.Deg2Rad / Count;
            for (int i = 0; i < Count; i++)
                Spline.ControlPointsList[i].transform.localPosition = new Vector3(Mathf.Sin(d * i) * Radius, Mathf.Cos(d * i) * Radius, 0);
        }

      


       

    }


}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSCircle.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSPie.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 11531ee0acb05f147a569dab22766734
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Shapes
{
    /// <summary>
    /// Pie Shape (2D)
    /// </summary>
    [CurvyShapeInfo("2D/Pie")]
    [RequireComponent(typeof(CurvySpline))]
    [AddComponentMenu("Curvy/Shapes/Pie")]
    public class CSPie : CSCircle
    {

        [Range(0, 1)]
        [SerializeField]
        private float m_Roundness = 1f;
        public float Roundness
        {
            get { return m_Roundness; }
            set
            {
                float v = Mathf.Clamp01(value);
                if (m_Roundness != v)
                {
                    m_Roundness = v;
                    Dirty = true;
                }

            }
        }

        public enum EatModeEnum
        {
            Left,
            Right,
            Center
        }

        [SerializeField]
        [RangeEx(0, nameof(maxEmpty), "Empty", "Number of empty slices")]
        private int m_Empty = 1;
        public int Empty
        {
            get { return m_Empty; }
            set
            {
                int v = Mathf.Clamp(value, 0, maxEmpty);
                if (m_Empty != v)
                {
                    m_Empty = v;
                    Dirty = true;
                }
            }
        }

        private int maxEmpty { get { return Count; } }

        [Label(Tooltip = "Eat Mode")]
        [SerializeField]
        private EatModeEnum m_Eat = EatModeEnum.Right;
        public EatModeEnum Eat
        {
            get { return m_Eat; }
            set
            {
                if (m_Eat != value)
                {
                    m_Eat = value;
                    Dirty = true;
                }
            }
        }



#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Empty = m_Empty;
            Eat = m_Eat;
            Roundness = m_Roundness;
        }
#endif

        protected override void Reset()
        {
            base.Reset();
            Roundness = 1f;
            Empty = 1;
            Eat = EatModeEnum.Right;
        }

        private Vector3 cpPosition(int i, int empty, float d)
        {
            switch (Eat)
            {
                case EatModeEnum.Left:
                    return new Vector3(Mathf.Sin(d * i) * Radius, Mathf.Cos(d * i) * Radius, 0);
                case EatModeEnum.Right:
                    return new Vector3(Mathf.Sin(d * (i + empty)) * Radius, Mathf.Cos(d * (i + empty)) * Radius, 0);
                default:
                    return new Vector3(Mathf.Sin(d * (i + empty * 0.5f)) * Radius, Mathf.Cos(d * (i + empty * 0.5f)) * Radius, 0);
            }
        }

        protected override void ApplyShape()
        {
            PrepareSpline(CurvyInterpolation.Bezier, CurvyOrientation.Dynamic);
            PrepareControlPoints(Count - Empty + 2);

            float d = 360f * Mathf.Deg2Rad / Count;
            float distPercent = Roundness * 0.39f;

            for (int i = 0; i < Spline.ControlPointCount - 1; i++)
            {
                Spline.ControlPointsList[i].AutoHandles = true;
                Spline.ControlPointsList[i].AutoHandleDistance = distPercent;
                SetPosition(i, cpPosition(i, Empty, d));
            }


            // Center
            SetPosition(Spline.ControlPointCount - 1, Vector3.zero);
            SetBezierHandles(Spline.ControlPointCount - 1, 0);

            // From Center
            Spline.ControlPointsList[0].AutoHandles = false;
            Spline.ControlPointsList[0].HandleIn = Vector3.zero;
            Spline.ControlPointsList[0].SetBezierHandles(distPercent,
                                                     cpPosition(Count - 1, Empty, d) - Spline.ControlPointsList[0].transform.localPosition,
                                                     cpPosition(1, Empty, d) - Spline.ControlPointsList[0].transform.localPosition, false, true);

            // To Center
            Spline.ControlPointsList[Spline.ControlPointCount - 2].AutoHandles = false;
            Spline.ControlPointsList[Spline.ControlPointCount - 2].HandleOut = Vector3.zero;
            Spline.ControlPointsList[Spline.ControlPointCount - 2].SetBezierHandles(distPercent,
                                                     cpPosition(Count - 1 - Empty, Empty, d) - Spline.ControlPointsList[Spline.ControlPointCount - 2].transform.localPosition,
                                                     cpPosition(Count + 1 - Empty, Empty, d) - Spline.ControlPointsList[Spline.ControlPointCount - 2].transform.localPosition, true, false);

        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSPie.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSRectangle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eb08e1dcb0ad99946b5fa3f2aab502ab
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Shapes
{
    /// <summary>
    /// Rectangle Shape (2D)
    /// </summary>
    [CurvyShapeInfo("2D/Rectangle")]
    [RequireComponent(typeof(CurvySpline))]
    [AddComponentMenu("Curvy/Shapes/Rectangle")]
    public class CSRectangle : CurvyShape2D
    {
        [Positive]
        [SerializeField]
        private float m_Width = 1;
        public float Width
        {
            get { return m_Width; }
            set 
            {
                float v = Mathf.Max(0, value);
                if (m_Width != v)
                {
                    m_Width = v;
                    Dirty = true;
                }
            }
        }
        [Positive]
        [SerializeField]
        private float m_Height = 1;
        public float Height
        {
            get { return m_Height; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_Height != v)
                {
                    m_Height = v;
                    Dirty = true;
                }
            }
        }

        protected override void Reset()
        {
            base.Reset();
            Width = 1;
            Height = 1;
        }

        protected override void ApplyShape()
        {
            base.ApplyShape();
            PrepareSpline(CurvyInterpolation.Linear, CurvyOrientation.Dynamic,1, true);
            PrepareControlPoints(4);
            float hw = Width / 2;
            float hh = Height / 2;
            SetCGHardEdges();
            
            SetPosition(0,new Vector3(-hw, -hh));
            SetPosition(1,new Vector3(-hw, hh));
            SetPosition(2,new Vector3(hw, hh));
            SetPosition(3,new Vector3(hw, -hh));
        }


#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Width = m_Width;
            Height = m_Height;
        }
#endif

      
      
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSRectangle.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSRoundedRectangle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 40c554b1636af874788a322143049112
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Shapes
{
    /// <summary>
    /// Rounded Rectangle (2D)
    /// </summary>
    [CurvyShapeInfo("2D/Rounded Rectangle")]
    [RequireComponent(typeof(CurvySpline))]
    [AddComponentMenu("Curvy/Shapes/Rounded Rectangle")]
    public class CSRoundedRectangle : CurvyShape2D
    {
        [Positive]
        [SerializeField]
        private float m_Width = 1;
        public float Width
        {
            get { return m_Width; }
            set
            {
                float v = Mathf.Max(0, value); ;
                if (m_Width != v)
                {
                    m_Width = v;
                    Dirty = true;
                }
            }
        }
        [Positive]
        [SerializeField]
        private float m_Height = 1;
        public float Height
        {
            get { return m_Height; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_Height != v)
                {
                    m_Height = v;
                    Dirty = true;
                }
            }
        }

        [Range(0, 1)]
        [SerializeField]
        private float m_Roundness = 0.5f;
        public float Roundness
        {
            get { return m_Roundness; }
            set
            {
                float v = Mathf.Clamp01(value);
                if (m_Roundness != v)
                {
                    m_Roundness = v;
                    Dirty = true;
                }
            }
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Width = m_Width;
            Height = m_Height;
            Roundness = m_Roundness;
        }
#endif

        protected override void Reset()
        {
            base.Reset();
            Width = 1;
            Height = 1;
            Roundness = 0.5f;
        }

        protected override void ApplyShape()
        {
            PrepareSpline(CurvyInterpolation.Bezier);
            bool isSquare = Roundness == 0;
            PrepareControlPoints(isSquare ? 4 : 8);

            float hw = Width / 2;
            float hh = Height / 2;

            if (isSquare)
            {
                SetPosition(0, new Vector3(-hw, -hh));
                SetPosition(1, new Vector3(-hw, hh));
                SetPosition(2, new Vector3(hw, hh));
                SetPosition(3, new Vector3(hw, -hh));

                SetBezierHandles(0, Vector3.zero, Vector3.zero, Space.Self);
                SetBezierHandles(1, Vector3.zero, Vector3.zero, Space.Self);
                SetBezierHandles(2, Vector3.zero, Vector3.zero, Space.Self);
                SetBezierHandles(3, Vector3.zero, Vector3.zero, Space.Self);
            }
            else
            {
                float off = Mathf.Min(hw, hh) * Roundness;
                SetPosition(0, new Vector3(-hw, -hh + off));
                SetPosition(1, new Vector3(-hw, hh - off));
                SetPosition(2, new Vector3(-hw + off, hh));
                SetPosition(3, new Vector3(hw - off, hh));
                SetPosition(4, new Vector3(hw, hh - off));
                SetPosition(5, new Vector3(hw, -hh + off));
                SetPosition(6, new Vector3(hw - off, -hh));
                SetPosition(7, new Vector3(-hw + off, -hh));

                SetBezierHandles(0, Vector3.down * off, Vector3.zero, Space.Self);
                SetBezierHandles(1, Vector3.zero, Vector3.up * off, Space.Self);
                SetBezierHandles(2, Vector3.left * off, Vector3.right * off, Space.Self);
                SetBezierHandles(3, Vector3.zero, Vector3.right * off, Space.Self);
                SetBezierHandles(4, Vector3.up * off, Vector3.zero, Space.Self);
                SetBezierHandles(5, Vector3.zero, Vector3.down * off, Space.Self);
                SetBezierHandles(6, Vector3.right * off, Vector3.zero, Space.Self);
                SetBezierHandles(7, Vector3.zero, Vector3.left * off, Space.Self);
            }

        }



    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSRoundedRectangle.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSSpiral.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 78fe27cadd58631478ff940cc42687c1
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Shapes
{
    /// <summary>
    /// Spiral Spline Shape
    /// </summary>
    [CurvyShapeInfo("3D/Spiral",false)]
    [RequireComponent(typeof(CurvySpline))]
    [AddComponentMenu("Curvy/Shapes/Spiral")]
    public class CSSpiral : CurvyShape2D
    {
        [Positive(Tooltip = "Number of Control Points per full Circle")]
        [SerializeField]
        private int m_Count = 8;
        public int Count
        {
            get { return m_Count; }
            set
            {
                int v = Mathf.Max(0, value);
                if (m_Count != v)
                {
                    m_Count = v;
                    Dirty = true;   
                }
            }
        }

        [Positive(Tooltip = "Number of Full Circles")]
        [SerializeField]
        private float m_Circles = 3;
        public float Circles
        {
            get { return m_Circles; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_Circles != v)
                {
                    m_Circles = v;
                    Dirty = true;
                }
            }
        }

        [Positive(Tooltip="Base Radius")]
        [SerializeField]
        private float m_Radius = 5;
        public float Radius
        {
            get { return m_Radius; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_Radius != v)
                {
                    m_Radius = v;
                    Dirty = true;
                }
            }
        }

        [Label(Tooltip="Radius Multiplicator")]
        [SerializeField]
        private AnimationCurve m_RadiusFactor = AnimationCurve.Linear(0, 1, 1, 1);
        public AnimationCurve RadiusFactor
        {
            get { return m_RadiusFactor; }
            set
            {
                if (m_RadiusFactor != value)
                {
                    m_RadiusFactor = value;
                    Dirty = true;
                }
            }
        }

        [SerializeField] private AnimationCurve m_Z = AnimationCurve.Linear(0, 0f, 1, 10f);
        public AnimationCurve Z
        {
            get { return m_Z; }
            set
            {
                if (m_Z != value)
                {
                    m_Z = value;
                    Dirty = true;
                }
            }
        }


        protected override void Reset()
        {
 	         base.Reset();
            Count=8;
            Circles=3;
            Radius=5;
            RadiusFactor=AnimationCurve.Linear(0,1,1,1);
            Z=AnimationCurve.Linear(0,0,1,10);
        }

        protected override void ApplyShape()
        {
            PrepareSpline(CurvyInterpolation.CatmullRom, CurvyOrientation.Dynamic, 50, false);
            Spline.RestrictTo2D = false;
            int cpCount = Mathf.FloorToInt(Count * Circles);
            PrepareControlPoints(cpCount);
            if (cpCount == 0)
                return;
            float d = 360f * Mathf.Deg2Rad / Count;
            
            for (int i = 0; i < cpCount; i++)
            {
                float frag = i / (float)cpCount;
                float rad = Radius * RadiusFactor.Evaluate(frag);
                SetPosition(i,new Vector3(Mathf.Sin(d * i) * rad, Mathf.Cos(d * i) * rad, m_Z.Evaluate(frag)));
            }
        }


        

    }
    

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSSpiral.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSStar.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c23adbe234d78794db53da7b155a4b75
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools;

namespace FluffyUnderware.Curvy.Shapes
{
    /// <summary>
    /// Star Shape (2D)
    /// </summary>
    [CurvyShapeInfo("2D/Star")]
    [RequireComponent(typeof(CurvySpline))]
    [AddComponentMenu("Curvy/Shapes/Star")]
    public class CSStar : CurvyShape2D
    {
        
        [SerializeField]
        [Positive(Tooltip = "Number of Sides", MinValue = 2)]
        private int m_Sides = 5;
        public int Sides
        {
            get { return m_Sides; }
            set
            {
                int v = Mathf.Max(0, value);
                if (m_Sides != v)
                {
                    m_Sides = v;
                    Dirty = true;
                }
            }
        }

        
        [SerializeField]
        [Positive]
        private float m_OuterRadius = 2;
        public float OuterRadius
        {
            get { return m_OuterRadius; }
            set
            {
                float v = Mathf.Max(InnerRadius, value);
                if (m_OuterRadius != v)
                {
                    m_OuterRadius = v;
                    Dirty = true;
                }
                
            }
        }

        
        [SerializeField]
        [RangeEx(0, 1)]
        private float m_OuterRoundness = 0;
        public float OuterRoundness
        {
            get { return m_OuterRoundness; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_OuterRoundness != v)
                {
                    m_OuterRoundness = v;
                    Dirty = true;
                }
            }
        }
        
        
        [SerializeField]
        [Positive]
        private float m_InnerRadius = 1;
        public float InnerRadius
        {
            get { return m_InnerRadius; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_InnerRadius != v)
                {
                    m_InnerRadius = v;
                    Dirty = true;
                }
            }
        }

        [SerializeField]
        [RangeEx(0, 1)]
        private float m_InnerRoundness = 0;
        public float InnerRoundness
        {
            get { return m_InnerRoundness; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_InnerRoundness != v)
                {
                    m_InnerRoundness = v;
                    Dirty = true;
                }
            }
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            base.OnValidate();
            Sides=m_Sides;
            OuterRadius = m_OuterRadius;
            InnerRadius=m_InnerRadius;
            OuterRoundness = m_OuterRoundness;
            InnerRoundness = m_InnerRoundness;
        }
#endif

        protected override void Reset()
        {
 	         base.Reset();
            Sides=5;
            OuterRadius=2;
            OuterRoundness=0;
            InnerRadius=1;
            InnerRoundness=0;
        }

        protected override void ApplyShape()
        {
            PrepareSpline(CurvyInterpolation.Bezier);
            PrepareControlPoints(Sides*2);
            float d = 360f * Mathf.Deg2Rad / Spline.ControlPointCount;
            for (int i = 0; i < Spline.ControlPointCount; i += 2)
            {
                Vector3 dir = new Vector3(Mathf.Sin(d * i), Mathf.Cos(d * i), 0);

                SetPosition(i, dir * OuterRadius);
                //SetBezierHandles(i,new Vector3(-dir.y, dir.x, 0),new Vector3(dir.y, -dir.x, 0),Space.Self);
                Spline.ControlPointsList[i].AutoHandleDistance = OuterRoundness;
                dir=new Vector3(Mathf.Sin(d*(i+1)),Mathf.Cos(d*(i+1)),0);
                SetPosition(i+1,dir * InnerRadius);
                //SetBezierHandles(i+1,new Vector3(-dir.y, dir.x, 0),new Vector3(dir.y, -dir.x, 0),Space.Self);
                Spline.ControlPointsList[i + 1].AutoHandleDistance = InnerRoundness;
            }
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CSStar.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CurvyShape.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3bf249c70f8faf74991ef60947480cb5
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System.Collections.Generic;
using FluffyUnderware.DevTools;
using System;
#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools.Extensions;


namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Base class for CurvyShape components
    /// </summary>
    [RequireComponent(typeof(CurvySpline))]
    //[DisallowMultipleComponent]
    [ExecuteAlways]
    [HelpURL(CurvySpline.DOCLINK + "curvyshape")]
    public class CurvyShape : DTVersionedMonoBehaviour
    {
        #region ### Serialized Fields ###

        [SerializeField, Label("Plane")] private CurvyPlane m_Plane = CurvyPlane.XY;

        #endregion

        #region ### Public Properties ###

        /// <summary>
        /// Gets or sets the plane to create the shape in
        /// </summary>
        public CurvyPlane Plane
        {
            get { return m_Plane; }
            set
            {
                Spline.Restricted2DPlane = value;
                if (m_Plane != value)
                {
                    m_Plane = value;
                    Dirty = true;
                }
            }
        }

        /// <summary>
        /// Gets the attached spline
        /// </summary>
        public CurvySpline Spline
        {
            get
            {
                if (!mSpline)
                    mSpline = GetComponent<CurvySpline>();
                return mSpline;
            }
        }

        #endregion

        #region ### Private fields ###

        private static Dictionary<CurvyShapeInfo, Type> mShapeDefs = new Dictionary<CurvyShapeInfo, System.Type>();

        private CurvySpline mSpline;
        [System.NonSerialized]
        public bool Dirty;
#if UNITY_EDITOR
        private bool isEnabled;
#endif
        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */
        private void Update()
        {
            // Prevent updating while dragging prefab
#if UNITY_EDITOR
            //if (Selection.activeGameObject==gameObject)
#endif
            Refresh();
        }

#if UNITY_EDITOR

        private void OnEnable()
        {
            isEnabled = true;
        }

        private void OnDisable()
        {
            isEnabled = false;
        }

        protected virtual void OnValidate()
        {
            if (isEnabled)
            {
                Plane = m_Plane;
                Dirty = true;
            }
        }
#endif

        protected virtual void Reset()
        {
            Plane = CurvyPlane.XY;
            Dirty = true;
        }
        /*! \endcond */

        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Remove the CurvyShape component from it's GameObject
        /// </summary>
        public void Delete()
        {
            this.Destroy(true, false);
        }

        /// <summary>
        /// Called to refresh the shape. Please call base.Refresh() or RefreshSpline() after your custom code!
        /// </summary>
        /// <remarks>Warning: Only work with ControlPoints, not with segments</remarks>
        public void Refresh()
        {
            if (Dirty)
            {
                //#if UNITY_EDITOR
                //                if (!Application.isPlaying)
                //                    Undo.RecordObject(Spline, "Apply Shape");
                //#endif
                ApplyShape();
                applyPlane();
                Spline.SetDirtyAll();
                Spline.Refresh();
            }
            Dirty = false;
        }


        /// <summary>
        /// Replace the current script with another shape's script
        /// </summary>
        /// <returns>the new shape script</returns>
        public CurvyShape Replace(string menuName)
        {
            Type shapeType = GetShapeType(menuName);
            if (shapeType != null)
            {
                GameObject go = this.gameObject;

                Delete();
                CurvyShape shape;

#if UNITY_EDITOR
                shape = (CurvyShape)Undo.AddComponent(go, shapeType);
#else
                shape = (CurvyShape)go.AddComponent(shapeType);
#endif

                shape.Dirty = true;
                return shape;
            }
            return null;
        }


        #endregion

        #region ### Protected Methods ###

        /// <summary>
        /// Sets basic spline parameters
        /// </summary>
        protected void PrepareSpline(CurvyInterpolation interpolation, CurvyOrientation orientation = CurvyOrientation.Dynamic, int cachedensity = 50, bool closed = true)
        {
            Spline.Interpolation = interpolation;
            Spline.Orientation = orientation;
            Spline.CacheDensity = cachedensity;
            Spline.Closed = closed;
            Spline.RestrictTo2D = this is CurvyShape2D;
        }

        /// <summary>
        /// Sets a Control Point's position by index
        /// </summary>
        /// <param name="no">Control point index</param>
        /// <param name="position">local position</param>
        protected void SetPosition(int no, Vector3 position)
        {
            Spline.ControlPointsList[no].SetLocalPosition(position);
        }

        /// <summary>
        /// Sets a Control Point's rotation by index
        /// </summary>
        /// <param name="no">Control point index</param>
        /// <param name="rotation">local rotation</param>
        protected void SetRotation(int no, Quaternion rotation)
        {
            Spline.ControlPointsList[no].SetLocalRotation(rotation);
        }

        /// <summary>
        /// Sets a Control Point's Bezier Handles by index
        /// </summary>
        /// <param name="no">Control point index</param>
        /// <param name="distanceFrag">distance in percent</param>
        protected void SetBezierHandles(int no, float distanceFrag)
        {
            SetBezierHandles(no, distanceFrag, distanceFrag);
        }

        /// <summary>
        /// Sets a Control Point's Bezier Handles by index
        /// </summary>
        /// <param name="no">Control point index</param>
        /// <param name="inDistanceFrag">distance in percent for HandleIn</param>
        /// /// <param name="outDistanceFrag">distance in percent for HandleOut</param>
        protected void SetBezierHandles(int no, float inDistanceFrag, float outDistanceFrag)
        {
            CurvySplineSegment curvySplineSegment = Spline.ControlPointsList[no];

            if (no >= 0 && no < Spline.ControlPointCount)
            {
                if (inDistanceFrag == outDistanceFrag)
                {
                    curvySplineSegment.AutoHandles = true;
                    curvySplineSegment.AutoHandleDistance = inDistanceFrag;
                }
                else
                {
                    curvySplineSegment.AutoHandles = false;
                    curvySplineSegment.AutoHandleDistance = (inDistanceFrag + outDistanceFrag) / 2f;
                    SetBezierHandles(inDistanceFrag, true, false, curvySplineSegment);
                    SetBezierHandles(outDistanceFrag, false, true, curvySplineSegment);
                }


            }
        }

        /// <summary>
        /// Sets a Control Point's Bezier Handles position
        /// </summary>
        /// <param name="no">the ControlPoint</param>
        /// <param name="i">HandlInPosition</param>
        /// <param name="o">HandleOutPosition</param>
        /// <param name="space">World or local space</param>
        protected void SetBezierHandles(int no, Vector3 i, Vector3 o, Space space = Space.World)
        {
            if (no >= 0 && no < Spline.ControlPointCount)
            {
                CurvySplineSegment curvySplineSegment = Spline.ControlPointsList[no];

                curvySplineSegment.AutoHandles = false;
                if (space == Space.World)
                {
                    curvySplineSegment.HandleInPosition = i;
                    curvySplineSegment.HandleOutPosition = o;
                }
                else
                {
                    curvySplineSegment.HandleIn = i;
                    curvySplineSegment.HandleOut = o;
                }
            }
        }

        /// <summary>
        /// Automatically place Bezier handles for a set of Control Points
        /// </summary>
        /// <param name="distanceFrag">how much % distance between neighbouring CPs are applied to the handle length?</param>
        /// <param name="setIn">Set HandleIn?</param>
        /// <param name="setOut">Set HandleOut?</param>
        /// <param name="controlPoints">one or more Control Points to set</param>
        public static void SetBezierHandles(float distanceFrag, bool setIn, bool setOut, params CurvySplineSegment[] controlPoints)
        {
            if (controlPoints.Length == 0)
                return;

            foreach (CurvySplineSegment cp in controlPoints)
                cp.SetBezierHandles(distanceFrag, setIn, setOut);
        }

        /// <summary>
        /// Enables CGHardEdge for a set of Control Points
        /// </summary>
        /// <param name="controlPoints">list of Control Point indices</param>
        protected void SetCGHardEdges(params int[] controlPoints)
        {
            if (controlPoints.Length == 0)
            {
                for (int i = 0; i < Spline.ControlPointCount; i++)
                    Spline.ControlPointsList[i].GetMetadata<MetaCGOptions>(true).HardEdge = true;
            }
            else
            {
                for (int i = 0; i < controlPoints.Length; i++)
                    if (i >= 0 && i < Spline.ControlPointCount)
                        Spline.ControlPointsList[i].GetMetadata<MetaCGOptions>(true).HardEdge = true;
            }
        }

        /// <summary>
        /// Override this to add custom code
        /// </summary>
        protected virtual void ApplyShape()
        {
        }

        /// <summary>
        /// Resizes the spline to have a certain number of Control Points
        /// </summary>
        /// <param name="count">number of Control Points</param>
        protected void PrepareControlPoints(int count)
        {
#if CONTRACTS_FULL
            Contract.Requires(Spline.LastVisibleControlPoint != null);
#endif

            /*
            Spline.Clear();
            while (count-- > 0)
                Spline.Add();
            Spline.Refresh();
            */
            int delta = count - Spline.ControlPointCount;
            bool upd = delta != 0;

            while (delta > 0)
            {
                Spline.InsertAfter(null, true);
                delta--;
            }

            while (delta < 0)
            {
                Spline.Delete(Spline.LastVisibleControlPoint, true, false);
                delta++;
            }
            // Revert to default settings
            for (int i = 0; i < Spline.ControlPointsList.Count; i++)
            {
                CurvySplineSegment controlPoint = Spline.ControlPointsList[i];
                controlPoint.transform.localPosition = Vector3.zero;
                controlPoint.transform.localRotation = Quaternion.identity;
                controlPoint.transform.localScale = Vector3.one;
                controlPoint.Reset();
                controlPoint.Disconnect();
                MetaCGOptions mcg = controlPoint.GetMetadata<MetaCGOptions>();
                if (mcg)
                    mcg.Reset();
            }

            if (upd)
                Spline.Refresh();
        }

        #endregion

        #region ### Public Static Methods & Properties ###

        /// <summary>
        /// Dictionary of Shape definitions and their types
        /// </summary>
        //TODO should be private
        public static Dictionary<CurvyShapeInfo, System.Type> ShapeDefinitions
        {
            get
            {
                if (mShapeDefs.Count == 0)
                    mShapeDefs = typeof(CurvyShape).GetAllTypesWithAttribute<CurvyShapeInfo>();

                return mShapeDefs;
            }
        }

        /// <summary>
        /// Gets a list of Menu Names of available shapes
        /// </summary>
        /// <param name="only2D">whether to skip 3D shapes or not</param>
        /// <returns>a list of Menu Names</returns>
        public static List<string> GetShapesMenuNames(bool only2D = false)
        {
            List<string> res = new List<string>();
            foreach (CurvyShapeInfo shapeInfo in ShapeDefinitions.Keys)
                if (!only2D || shapeInfo.Is2D)
                    res.Add(shapeInfo.Name);

            return res;
        }

        /// <summary>
        /// Gets a list of Menu Names of available shapes
        /// </summary>
        /// <param name="currentShapeType">the current shape type</param>
        /// <param name="currentIndex">returns the index of the current shape type</param>
        /// <param name="only2D">whether only to show 2D shapes</param>
        /// <returns>a list of Menu Names</returns>
        public static List<string> GetShapesMenuNames(System.Type currentShapeType, out int currentIndex, bool only2D = false)
        {
            currentIndex = 0;
            if (currentShapeType == null)
                return GetShapesMenuNames(only2D);
            List<string> lst = new List<string>();
            foreach (KeyValuePair<CurvyShapeInfo, Type> kv in ShapeDefinitions)
            {
                if (!only2D || kv.Key.Is2D)
                    lst.Add(kv.Key.Name);
                if (kv.Value == currentShapeType)
                    currentIndex = lst.Count - 1;

            }
            return lst;
        }

        /// <summary>
        /// Gets Shape Menu Name from a CurvyShape subclass type
        /// </summary>
        /// <param name="shapeType"></param>
        /// <returns></returns>
        public static string GetShapeName(System.Type shapeType)
        {
            foreach (KeyValuePair<CurvyShapeInfo, Type> kv in ShapeDefinitions)
                if (kv.Value == shapeType)
                    return kv.Key.Name;
            return null;
        }

        /// <summary>
        /// Gets a CurvyShape subclass type from a Shape's MenuName
        /// </summary>
        /// <param name="menuName"></param>
        /// <returns></returns>
        public static Type GetShapeType(string menuName)
        {
            foreach (CurvyShapeInfo shapeInfo in ShapeDefinitions.Keys)
                if (shapeInfo.Name == menuName)
                    return ShapeDefinitions[shapeInfo];

            return null;
        }

        #endregion

        #region ### Privates ###

        private void applyPlane()
        {
            switch (Plane)
            {
                case CurvyPlane.XZ:
                    applyRotation(Quaternion.Euler(90, 0, 0));
                    break;
                case CurvyPlane.YZ:
                    applyRotation(Quaternion.Euler(0, 90, 0));
                    break;
                default:
                    applyRotation(Quaternion.Euler(0, 0, 0));
                    break;
            }
        }

        private void applyRotation(Quaternion q)
        {
            Spline.transform.localRotation = Quaternion.identity;

            for (int i = 0; i < Spline.ControlPointCount; i++)
            {
                CurvySplineSegment curvySplineSegment = Spline.ControlPointsList[i];
                curvySplineSegment.SetLocalRotation(q * curvySplineSegment.transform.localRotation);
                curvySplineSegment.SetLocalPosition(q * curvySplineSegment.transform.localPosition);
                if (Spline.Interpolation == CurvyInterpolation.Bezier)
                {
                    curvySplineSegment.HandleIn = q * curvySplineSegment.HandleIn;
                    curvySplineSegment.HandleOut = q * curvySplineSegment.HandleOut;
                }
            }
        }

        #endregion


    }

    /// <summary>
    /// CurvyShape Info Attribute
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
    public sealed class CurvyShapeInfo : System.Attribute
    {
        public readonly string Name;
        public readonly bool Is2D;

        public CurvyShapeInfo(string name, bool is2D = true)
        {
            Name = name;
            Is2D = is2D;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CurvyShape.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CurvyShape2D.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dd2a6fa79083d8c468863ad668f919e3
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using System.Collections;
using FluffyUnderware.Curvy.Utils;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Base class for 2D Shapes
    /// </summary>
    public class CurvyShape2D : CurvyShape
    {
       
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Shapes/CurvyShape2D.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Connections/ConnectionHeadingEnum.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 053e00672ed69584292283c8a26f4a09
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Connection's Follow-Up heading direction
    /// </summary>
    public enum ConnectionHeadingEnum
    {
        /// <summary>
        /// Head towards the targets start (negative F)
        /// </summary>
        Minus = -1,
        /// <summary>
        /// Do not head anywhere, stay still
        /// </summary>
        Sharp = 0,
        /// <summary>
        /// Head towards the targets end (positive F)
        /// </summary>
        Plus = 1,
        /// <summary>
        /// Automatically choose the appropriate value
        /// </summary>
        Auto = 2
    }

    /// <summary>
    /// Extension methods of <see cref="ConnectionHeadingEnum"/>
    /// </summary>
    public static class ConnectionHeadingEnumMethods
    {
        /// <summary>
        /// If heading is Auto, this method will translate it to a Plus, Minus or Sharp value depending on the Follow-Up control point.
        /// </summary>
        /// <param name="heading">the value to resolve</param>
        /// <param name="followUp">the related followUp control point</param>
        /// <returns></returns>
        static public ConnectionHeadingEnum ResolveAuto(this ConnectionHeadingEnum heading, CurvySplineSegment followUp)
        {
            if (heading == ConnectionHeadingEnum.Auto)
            {
                if (CurvySplineSegment.CanFollowUpHeadToEnd(followUp))
                    heading = ConnectionHeadingEnum.Plus;
                else if (CurvySplineSegment.CanFollowUpHeadToStart(followUp))
                    heading = ConnectionHeadingEnum.Minus;
                else
                    heading = ConnectionHeadingEnum.Sharp;
            }
            return heading;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Connections/ConnectionHeadingEnum.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Connections/CurvyConnection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 320a2489ca748ce44a808c78b9a5c740
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using FluffyUnderware.Curvy;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.SceneManagement;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Connection component
    /// </summary>
    [ExecuteInEditMode]
    [HelpURL(CurvySpline.DOCLINK + "curvyconnection")]
    public class CurvyConnection : DTVersionedMonoBehaviour, ISerializationCallbackReceiver
    {
        #region ### Serialized Fields ###

        [SerializeField, Hide] private List<CurvySplineSegment> m_ControlPoints = new List<CurvySplineSegment>();

        #endregion

        #region ### Private Fields ###

        private ReadOnlyCollection<CurvySplineSegment> readOnlyControlPoints;
        /// <summary>
        /// The coordinates of the connection the last time synchronisation was processed
        /// </summary>
        private Couple<Vector3, Quaternion> processedConnectionCoordinates;
        /// <summary>
        /// The coordinates of the connection's control points the last time synchronisation was processed
        /// </summary>
        [SerializeField, Hide] private List<ControlPointCoordinates> processedControlPointsCoordinates = new List<ControlPointCoordinates>();

        #endregion

        #region ### Public Properties ###


        /// <summary>
        /// The list of connected control points
        /// </summary>
        public ReadOnlyCollection<CurvySplineSegment> ControlPointsList
        {
            //TODO apply the same TODOs than CurvySpline.ControlPointsList
            get
            {
                if (readOnlyControlPoints == null)
                    readOnlyControlPoints = m_ControlPoints.AsReadOnly();
                return readOnlyControlPoints;
            }
        }
        /// <summary>
        /// Gets the number of Control Points being part of this connection
        /// </summary>
        public int Count
        {
            get { return m_ControlPoints.Count; }
        }

        /// <summary>
        /// Gets a certain Control Point by index
        /// </summary>
        /// <param name="idx">index of the Control Point</param>
        /// <returns>a Control Point</returns>
        public CurvySplineSegment this[int idx]
        {
            get
            {
                return m_ControlPoints[idx];
            }
        }

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */


        private void OnEnable()
        {
            SceneManager.sceneLoaded += OnSceneLoaded;

            ResetProcessedCoordinates();
#if UNITY_EDITOR
            EditorApplication.update += EditorUpdate;
#endif
        }

        private void OnDisable()
        {
            SceneManager.sceneLoaded -= OnSceneLoaded;
#if UNITY_EDITOR
            EditorApplication.update -= EditorUpdate;
#endif
        }

#if UNITY_EDITOR
        private void EditorUpdate()
        {
            DoUpdate();
        }
#endif


        private void Update()
        {
            if (Application.isPlaying)
                DoUpdate();
        }

        private void LateUpdate()
        {
            if (Application.isPlaying)
                DoUpdate();
        }

        private void FixedUpdate()
        {
            if (Application.isPlaying)
                DoUpdate();
        }

        private void OnDestroy()
        {
            bool realDestroy = true;
#if UNITY_EDITOR
            if (EditorApplication.isPlayingOrWillChangePlaymode && !EditorApplication.isPlaying)
                realDestroy = false;
#endif
            if (realDestroy)
            {
                List<CurvySplineSegment> controlPointsToDisconnect = new List<CurvySplineSegment>(m_ControlPoints);
                foreach (CurvySplineSegment cp in controlPointsToDisconnect)
                    cp.Disconnect(false);

                //This is needed even if cp.Disconnect removes the cp from those lists via Connection.RemoveControlPoint, because when calling cp.Disconnect you can have cp.Connection == null, which will lead to Connection.RemoveControlPoint not being called. Saw that happening when undoing the creation of a connect CP (via the Smart Connect tool)
                m_ControlPoints.Clear();
                processedControlPointsCoordinates.Clear();
            }
        }


        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Creates a connection and adds Control Points
        /// </summary>
        /// <param name="controlPoints">Control Points to add</param>
        /// <returns>the new connection</returns>
        public static CurvyConnection Create(params CurvySplineSegment[] controlPoints)
        {
            CurvyGlobalManager curvyGlobalManager = CurvyGlobalManager.Instance;
            if (curvyGlobalManager == null)
            {
                DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.");
                return null;
            }

            CurvyConnection con = curvyGlobalManager.AddChildGameObject<CurvyConnection>("Connection");
#if UNITY_EDITOR
            if (!Application.isPlaying)
                Undo.RegisterCreatedObjectUndo(con.gameObject, "Add Connection");
#endif
            if (!con)
                return null;
            if (controlPoints.Length > 0)
            {
                con.transform.position = controlPoints[0].transform.position;
                con.AddControlPoints(controlPoints);
            }

            return con;
        }

        /// <summary>
        /// Adds Control Points to this connection
        /// </summary>
        /// <param name="controlPoints">the Control Points to add</param>
        public void AddControlPoints(params CurvySplineSegment[] controlPoints)
        {
            foreach (CurvySplineSegment cp in controlPoints)
            {
                if (cp.Connection)
                {
                    DTLog.LogErrorFormat(this, "[Curvy] CurvyConnection.AddControlPoints called on a control point '{0}' that has already a connection. Only control points with no connection can be added.", cp);
                    continue;
                }

#if UNITY_EDITOR
                if (!Application.isPlaying)
                    Undo.RecordObject(cp, "Add Connection");
#endif
#if CURVY_SANITY_CHECKS
                Assert.IsFalse(m_ControlPoints.Contains(cp));
#endif
                m_ControlPoints.Add(cp);
                processedControlPointsCoordinates.Add(new ControlPointCoordinates(cp));
                cp.Connection = this;
            }
            AutoSetFollowUp();
        }

        public void AutoSetFollowUp()
        {
            if (Count == 2)
            {
                CurvySplineSegment firstControlPoint = m_ControlPoints[0];
                CurvySplineSegment secondControlPoint = m_ControlPoints[1];
                if (firstControlPoint.transform.position == secondControlPoint.transform.position && firstControlPoint.ConnectionSyncPosition && secondControlPoint.ConnectionSyncPosition)
                {
                    if (firstControlPoint.FollowUp == null && firstControlPoint.Spline && firstControlPoint.Spline.CanControlPointHaveFollowUp(firstControlPoint))
                        firstControlPoint.SetFollowUp(secondControlPoint);
                    if (secondControlPoint.FollowUp == null && secondControlPoint.Spline && secondControlPoint.Spline.CanControlPointHaveFollowUp(secondControlPoint))
                        secondControlPoint.SetFollowUp(firstControlPoint);
                }
            }
        }

        /// <summary>
        /// Removes a Control Point from this connection
        /// </summary>
        /// <param name="controlPoint">the Control Point to remove</param>
        /// <param name="destroySelfIfEmpty">whether the connection should be destroyed when empty afterwards</param>
        public void RemoveControlPoint(CurvySplineSegment controlPoint, bool destroySelfIfEmpty = true)
        {
#if UNITY_EDITOR
            const string undoingStepLabel = "Disconnect from Connection";

            Undo.RegisterCompleteObjectUndo(new UnityEngine.Object[]{
                controlPoint, this
            }, undoingStepLabel);
#endif

            controlPoint.Connection = null;

            m_ControlPoints.Remove(controlPoint);
            processedControlPointsCoordinates.RemoveAll(element => ReferenceEquals(element.ControlPoint, controlPoint));

            foreach (CurvySplineSegment splineSegment in m_ControlPoints)
            {
                if (splineSegment.FollowUp == controlPoint)
                {
#if UNITY_EDITOR
                    Undo.RegisterCompleteObjectUndo(splineSegment, undoingStepLabel);
#endif
                    splineSegment.SetFollowUp(null);
                }
            }
            if (m_ControlPoints.Count == 0 && destroySelfIfEmpty)
                Delete();
        }

        /// <summary>
        /// Deletes the connection
        /// </summary>
        public void Delete()
        {
            gameObject.Destroy(true, true);
        }

        /// <summary>
        /// Gets all Control Points except the one provided
        /// </summary>
        /// <param name="source">the Control Point to filter out</param>
        /// <returns>list of Control Points</returns>
        public List<CurvySplineSegment> OtherControlPoints(CurvySplineSegment source)
        {
            List<CurvySplineSegment> res = new List<CurvySplineSegment>(m_ControlPoints);
            res.Remove(source);
            return res;
        }

        /// <summary>
        /// Synchronise all the connected control points to match the given position and rotation, based on their synchronisation options, namely <see cref="CurvySplineSegment.ConnectionSyncPosition"/> and <see cref="CurvySplineSegment.ConnectionSyncRotation"/>. Will update the CurvyConnection's game object's transform too.
        /// </summary>
        /// <remarks>Can dirty the splines of the updated control points</remarks>
        public void SetSynchronisationPositionAndRotation(Vector3 referencePosition, Quaternion referenceRotation)
        {
            Transform cachedTransform = transform;

            cachedTransform.position = referencePosition;
            cachedTransform.rotation = referenceRotation;
            cachedTransform.hasChanged = false;
            processedConnectionCoordinates.First = referencePosition;
            processedConnectionCoordinates.Second = referenceRotation;

            for (int i = 0; i < m_ControlPoints.Count; i++)
            {
                CurvySplineSegment controlPoint = m_ControlPoints[i];

                bool positionModified = controlPoint.ConnectionSyncPosition && controlPoint.transform.position.NotApproximately(referencePosition);
                bool rotationModified = controlPoint.ConnectionSyncRotation && controlPoint.transform.rotation.DifferentOrientation(referenceRotation);

                if (positionModified)
                    controlPoint.transform.position = referencePosition;
                if (rotationModified)
                    controlPoint.transform.rotation = referenceRotation;

                ControlPointCoordinates processedControlPointCoordinates =
                    processedControlPointsCoordinates.Single(element => ReferenceEquals(element.ControlPoint, controlPoint));

                processedControlPointCoordinates.Position = controlPoint.transform.position;
                processedControlPointCoordinates.Rotation = controlPoint.transform.rotation;

                if (positionModified || (rotationModified && controlPoint.OrientatinInfluencesSpline))
                    controlPoint.Spline.SetDirtyPartial(controlPoint
                        , positionModified == false ? SplineDirtyingType.OrientationOnly : SplineDirtyingType.Everything);
            }
        }


#if UNITY_EDITOR
        /// <summary>
        /// Gets the gizmo color based on the synchronization options of the connected control points
        /// </summary>
        public Color GetGizmoColor()
        {
            Color gizmoColor;

            if (ControlPointsList.Count == 0)
                gizmoColor = Color.black;
            else
            {
                bool allPositionsSynced = true;
                bool allRotationsSynced = true;
                foreach (CurvySplineSegment controlPoint in ControlPointsList)
                {
                    allPositionsSynced = allPositionsSynced && controlPoint.ConnectionSyncPosition;
                    allRotationsSynced = allRotationsSynced && controlPoint.ConnectionSyncRotation;

                    if (allPositionsSynced == false && allRotationsSynced == false)
                        break;
                }

                if (allPositionsSynced)
                    gizmoColor = allRotationsSynced
                        ? Color.white
                        : new Color(255 / 255f, 49 / 255f, 38 / 255f);
                else if (allRotationsSynced)
                    gizmoColor = new Color(1, 1, 0);
                else
                    gizmoColor = Color.black;
            }

            return gizmoColor;
        }
#endif


        #endregion

        #region ### Privates & Internals ###
        /*! \cond PRIVATE */

        private void DoUpdate()
        {
            Transform cachedTransform = transform;

            bool synchronised;
            if (cachedTransform.hasChanged)
            {
                cachedTransform.hasChanged = false;
                if (cachedTransform.position.NotApproximately(processedConnectionCoordinates.First) ||
                    cachedTransform.rotation.DifferentOrientation(processedConnectionCoordinates.Second))
                {
                    SetSynchronisationPositionAndRotation(cachedTransform.position, cachedTransform.rotation);
                    synchronised = true;
                }
                else
                    synchronised = false;
            }
            else
                synchronised = false;

            if (synchronised == false)
            {
                Vector3? synchronisationPosition = null;
                Quaternion? synchronisationRotation = null;

                foreach (CurvySplineSegment controlPoint in m_ControlPoints)
                {
                    if (controlPoint.gameObject == null)
                    {
                        //The only case I am aware of where this happens is when running test (see [TestFixture]), when the test is finished, a connection is duplicated and "restored", while having in its CPs list CPs that have been destroyed.
                        //This is somehow related to the following statement in the RemoveControlPoint method:
                        //Undo.RegisterCompleteObjectUndo(new UnityEngine.Object[]{
                        //    controlPoint, this
                        //}, undoingStepLabel);

                        //If you fix the problem above, remove unnecessary checks on controlPoint.gameObject. Look for the following comment to find such places:
                        // "see comment in CurvyConnection.DoUpdate to know more about when cp.gameObject can be null"

                        DTLog.LogError(String.Format("[Curvy] Connection named '{0}' had in its list a control point with no game object. Control point was ignored", this.name), this);
                        continue;
                    }
                    ControlPointCoordinates processedControlPointsCoordinate =
                        processedControlPointsCoordinates.Single(element => ReferenceEquals(element.ControlPoint, controlPoint));

                    Transform controlPointTransform = controlPoint.transform;

                    if (controlPoint.ConnectionSyncPosition && controlPointTransform.position.NotApproximately(processedControlPointsCoordinate.Position))
                        synchronisationPosition = controlPointTransform.position;

                    if (controlPoint.ConnectionSyncRotation && controlPointTransform.rotation.DifferentOrientation(processedControlPointsCoordinate.Rotation))
                        synchronisationRotation = controlPointTransform.rotation;

                    if (synchronisationPosition != null && synchronisationRotation != null)
                        break;
                }

                if (synchronisationPosition != null || synchronisationRotation != null)
                    SetSynchronisationPositionAndRotation(synchronisationPosition ?? transform.position, synchronisationRotation ?? transform.rotation);
            }
        }

        private void OnSceneLoaded(Scene arg0, LoadSceneMode arg1)
        {
            //m_ControlPoints can have null references in it because if the cp it has is disabled, and then the scene is switched, the cp will not execute its OnDestroy, ans thus will not remove himself from the connection. And since destroyed unity objects become equal to null, the CPs list will have a null value in it
            int removedElementsCount = m_ControlPoints.RemoveAll(cp => cp == null);
            if (removedElementsCount != 0)
            {
                if (m_ControlPoints.Count == 0)
                    Delete();
                else
                {
                    DTLog.LogWarning("[Curvy] Connection " + this.name + " was not destroyed after scene switch. That should not happen. Please raise a bug report.", this);
                    ResetProcessedCoordinates();
                }
            }
        }

        private void ResetProcessedCoordinates()
        {
            Transform cachedTransform = transform;
            processedConnectionCoordinates =
                new Couple<Vector3, Quaternion>(cachedTransform.position, cachedTransform.rotation);
            processedControlPointsCoordinates.Clear();
            for (int index = 0; index < m_ControlPoints.Count; index++)
                processedControlPointsCoordinates.Add(new ControlPointCoordinates(m_ControlPoints[index]));
        }

        /*! \endcond */
        #endregion

        #region ISerializationCallbackReceiver
        /*! \cond PRIVATE */
        /// <summary>
        /// Implementation of UnityEngine.ISerializationCallbackReceiver
        /// Called automatically by Unity, is not meant to be called by Curvy's users
        /// </summary>
        public void OnBeforeSerialize()
        {
            m_ControlPoints.RemoveAll(cp => ReferenceEquals(cp, null));
        }

        /// <summary>
        /// Implementation of UnityEngine.ISerializationCallbackReceiver
        /// Called automatically by Unity, is not meant to be called by Curvy's users
        /// </summary>
        public void OnAfterDeserialize()
        {
            m_ControlPoints.RemoveAll(cp => ReferenceEquals(cp, null));
        }
        /*! \endcond */
        #endregion

    }

    /// <summary>
    /// A class that exists only because Unity does not serialize Dictionary<CurvySplineSegment, Couple<Vector3, Quaternion>>
    /// </summary>
    [Serializable]
    internal class ControlPointCoordinates
    {
        internal ControlPointCoordinates(CurvySplineSegment controlPoint)
        {
            ControlPoint = controlPoint;
            if(controlPoint.gameObject)
            {
                // see comment in CurvyConnection.DoUpdate to know more about when cp.gameObject can be null
                Position = controlPoint.transform.position;
                Rotation = controlPoint.transform.rotation;
            }
        }
        [SerializeField]
        internal CurvySplineSegment ControlPoint;
        [SerializeField]
        internal Vector3 Position;
        [SerializeField]
        internal Quaternion Rotation;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Connections/CurvyConnection.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySpline.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 82f49053b9b703e4cbb1c6e76a563270
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using UnityEngine.Serialization;
using FluffyUnderware.DevTools.Extensions;
using System.Reflection;
using FluffyUnderware.Curvy.Pools;
using JetBrains.Annotations;
using ToolBuddy.Pooling.Collections;
using UnityEngine.Assertions;
#if UNITY_EDITOR
using UnityEditor;
#endif
#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif


namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Curvy Spline class
    /// </summary>
    [HelpURL(CurvySpline.DOCLINK + "curvyspline")]
    [AddComponentMenu("Curvy/Curvy Spline")]
    [ExecuteAlways]
    public partial class CurvySpline : DTVersionedMonoBehaviour
    {
        /*! \cond PRIVATE */
        //TODO move elsewhere
        public const string VERSION = "8.4.0";
        public const string APIVERSION = "840";
        public const string WEBROOT = "https://curvyeditor.com/";
        public const string DOCLINK = WEBROOT + "doclink/";
        /*! \endcond */

#if UNITY_EDITOR
        /// <summary>
        /// The number of precomputed spline names 
        /// </summary>
        //DESIGN Make this parametrable by users?
        private const short CachedControlPointsNameCount = 250;
        /// <summary>
        /// A list of precomputed control point names
        /// </summary>
        static readonly private string[] controlPointNames = GetControlPointNames();

#endif

        public CurvySpline()
        {
            refreshCurveAction = (controlPoint, controlPointIndex, controlPointsCount) => controlPoint.refreshCurveINTERNAL();
            defaultSplineEventArgs = new CurvySplineEventArgs(this, this, null);
            defaultAddAfterEventArgs = new CurvyControlPointEventArgs(this, this, null, CurvyControlPointEventArgs.ModeEnum.AddAfter);
            defaultDeleteEventArgs = new CurvyControlPointEventArgs(this, this, null, CurvyControlPointEventArgs.ModeEnum.Delete);
        }

        #region ### Serialized fields ###

        /// <summary>
        /// The list of control points
        /// </summary>
        /// <remarks>The returned list should not be modified</remarks>
        [SerializeField, HideInInspector]
        private List<CurvySplineSegment> ControlPoints = new List<CurvySplineSegment>();

        /// <summary>
        /// Whether to show the Gizmos enabled in the view settings or not at all 
        /// </summary>
        [HideInInspector]
        public bool ShowGizmos = true;

        #endregion

        #region ### Public Properties ###

        #region --- General ---

        /// <summary>
        /// The interpolation method used by this spline
        /// </summary>
        /// <remarks>AutoEndTangents's value can be updated depending on Interpolation value</remarks>
        public CurvyInterpolation Interpolation
        {
            get { return m_Interpolation; }
            set
            {
                if (m_Interpolation != value)
                {
                    m_Interpolation = value;
                    InvalidateControlPointsRelationshipCacheINTERNAL();
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }

                //Since canHaveManualEndCP uses Interpolation, and is used by AutoEndTangents, we force the later's update
                AutoEndTangents = m_AutoEndTangents;
            }
        }

        /// <summary>
        /// Whether to restrict Control Points to a local 2D plane
        /// </summary>
        /// <seealso cref="Restricted2DPlane"/>
        public bool RestrictTo2D
        {
            get { return m_RestrictTo2D; }
            set
            {
                if (m_RestrictTo2D != value)
                {
                    m_RestrictTo2D = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// The local 2D plane to restrict the spline's control point in
        /// </summary>
        /// <seealso cref="RestrictTo2D"/>
        public CurvyPlane Restricted2DPlane
        {
            get { return restricted2DPlane; }
            set
            {
                if (restricted2DPlane != value)
                {
                    restricted2DPlane = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// Gets or sets the default Handle distance for Bezier splines
        /// </summary>
        public float AutoHandleDistance
        {
            get { return m_AutoHandleDistance; }
            set
            {
                float clampedValue = Mathf.Clamp01(value);
                if (m_AutoHandleDistance != clampedValue)
                {
                    m_AutoHandleDistance = clampedValue;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// Whether this spline is closed or not
        /// </summary>
        /// <remarks>AutoEndTangents's value can be updated depending on Close value</remarks>
        public bool Closed
        {
            get { return m_Closed; }
            set
            {
                if (m_Closed != value)
                {
                    m_Closed = value;
                    InvalidateControlPointsRelationshipCacheINTERNAL();
                    SetDirtyAll(SplineDirtyingType.Everything, true);
                }
                //Since canHaveManualEndCP uses Closed, and is used by AutoEndTangents, we force the later's update
                AutoEndTangents = m_AutoEndTangents;
            }
        }

        /// <summary>
        /// Whether the first/last Control Point should act as the end tangent, too.
        /// </summary>
        /// <remarks>Ignored by linear splines and Bezier ones</remarks>
        public bool AutoEndTangents
        {
            get { return m_AutoEndTangents; }
            set
            {
                bool v = !CanHaveManualEndCp() || value;
                if (m_AutoEndTangents != v)
                {
                    m_AutoEndTangents = v;
                    InvalidateControlPointsRelationshipCacheINTERNAL();
                    SetDirtyAll(SplineDirtyingType.Everything, true);
                }
            }
        }

        /// <summary>
        /// Orientation mode
        /// </summary>
        public CurvyOrientation Orientation
        {
            get { return m_Orientation; }
            set
            {
                if (m_Orientation != value)
                {
                    m_Orientation = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        public CurvyUpdateMethod UpdateIn
        {
            get { return m_UpdateIn; }
            set
            {
                if (m_UpdateIn != value)
                    m_UpdateIn = value;
            }
        }

        #endregion

        #region --- Advanced Settings ---

        /// <summary>
        /// Gets or sets Spline color
        /// </summary>
        public Color GizmoColor
        {
            get { return m_GizmoColor; }
            set
            {
                if (m_GizmoColor != value)
                    m_GizmoColor = value;
            }
        }

        /// <summary>
        /// Gets or sets selected segment color
        /// </summary>
        public Color GizmoSelectionColor
        {
            get { return m_GizmoSelectionColor; }
            set
            {
                if (m_GizmoSelectionColor != value)
                    m_GizmoSelectionColor = value;
            }
        }

        /// <summary>
        /// Gets or sets the cache density
        /// Defines how densely the cached points are. When the value is 100, the number of cached points per world distance unit is equal to the spline's <see cref="MaxPointsPerUnit"/>
        /// </summary>
        public int CacheDensity
        {
            get { return m_CacheDensity; }
            set
            {
                int clampedDensity = Mathf.Clamp(value, 1, 100);

                if (m_CacheDensity != clampedDensity)
                {
                    m_CacheDensity = clampedDensity;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// The maximum number of sampling points per world distance unit. Sampling is used in caching or shape extrusion for example</summary>
        public float MaxPointsPerUnit
        {
            get
            {
                return m_MaxPointsPerUnit;
            }
            set
            {
                float clampedValue = Mathf.Clamp(value, MinimalMaxPointsPerUnit, 1000);
                if (m_MaxPointsPerUnit != clampedValue)
                {
                    m_MaxPointsPerUnit = clampedValue;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// Whether to use GameObject pooling for Control Points at runtime
        /// </summary>
        public bool UsePooling
        {
            get { return m_UsePooling; }
            set
            {
                if (m_UsePooling != value)
                    m_UsePooling = value;
            }
        }
        /// <summary>
        /// Whether to use threading where applicable or not.
        /// Threading is currently not supported when targeting WebGL and Universal Windows Platform
        /// </summary>
        public bool UseThreading
        {
            get
            {
#if !UNITY_WSA && !UNITY_WEBGL
                return m_UseThreading;
#else

                return false;
#endif
            }
            set
            {
                if (m_UseThreading != value)
                    m_UseThreading = value;
            }
        }

        /// <summary>
        /// Whether the spline should automatically refresh when a Control Point's position change
        /// </summary>
        /// <remarks>Enable this if you animate a Control Point's transform!</remarks>
        public bool CheckTransform
        {
            get { return m_CheckTransform; }
            set
            {
                if (m_CheckTransform != value)
                {
                    m_CheckTransform = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }


        #endregion

        #region --- TCB Options ---

        /// <summary>
        /// Global Tension
        /// </summary>
        /// <remarks>This only applies to TCB interpolation</remarks>
        public float Tension
        {
            get { return m_Tension; }
            set
            {
                if (m_Tension != value)
                {
                    m_Tension = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// Global Continuity
        /// </summary>
        /// <remarks>This only applies to TCB interpolation</remarks>
        public float Continuity
        {
            get { return m_Continuity; }
            set
            {
                if (m_Continuity != value)
                {
                    m_Continuity = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// Global Bias
        /// </summary>
        /// <remarks>This only applies to TCB interpolation</remarks>
        public float Bias
        {
            get { return m_Bias; }
            set
            {
                if (m_Bias != value)
                {
                    m_Bias = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }
        #endregion

        #region --- B-Spline Options ---

        /// <summary>
        /// Used only when <see cref="Interpolation"/> is <see cref="CurvyInterpolation.BSpline"/>
        /// The degree of the piecewise polynomial functions
        /// Is in the range [2; control points count - 1]
        /// </summary>
        public int BSplineDegree
        {
            get { return bSplineDegree; }
            set
            {
                value = Mathf.Min(Mathf.Max(minBSplineDegree, value), MaxBSplineDegree);
                if (bSplineDegree != value)
                {
                    bSplineDegree = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }

        /// <summary>
        /// Used only when <see cref="Interpolation"/> is <see cref="CurvyInterpolation.BSpline"/>
        /// Make the curve pass through the first and last control points by increasing the multiplicity of the first and last knots.
        /// In technical terms, when this parameter is true, the knot vector is [0, 0, ...,0, 1, 2, ..., N-1, N, N, ..., N]. When false, it is [0, 1, 2, ..., N-1, N]
        /// </summary>
        public bool IsBSplineClamped
        {
            get { return CanBeClamped() && isBSplineClamped; }
            set
            {
                if (isBSplineClamped != value)
                {
                    isBSplineClamped = value;
                    SetDirtyAll(SplineDirtyingType.Everything, false);
                }
            }
        }
        #endregion

        #region --- Others ---

        /// <summary>
        /// Whether the spline is fully initialized and all segments loaded
        /// </summary>
        public bool IsInitialized { get { return mIsInitialized; } }

        /// <summary>
        /// The bounding box of the spline, in world space
        /// </summary>
        public Bounds Bounds
        {
            get
            {
                if (!mBounds.HasValue)
                {
#if CURVY_SANITY_CHECKS
                    DoSanityChecks();
#endif
                    Bounds bounds;
                    if (Count > 0)
                    {
                        Bounds b = this[0].Bounds;

                        for (int i = 1; i < Count; i++)
                            b.Encapsulate(this[i].Bounds);
                        bounds = b;
                    }
                    else
                        bounds = new Bounds(transform.position, Vector3.zero);

                    if (Dirty == false)
                        mBounds = bounds;
                    return bounds;
                }
                return mBounds.Value;
            }
        }

        /// <summary>
        /// Gets the number of Segments
        /// </summary>
        public int Count { get { return Segments.Count; } }
        /// <summary>
        /// Gets the number of Control Points
        /// </summary>
        public int ControlPointCount { get { return ControlPoints.Count; } }

        /// <summary>
        /// Gets total Cache Size
        /// </summary>
        public int CacheSize
        {
            get
            {
                if (mCacheSize < 0)
                {
#if CURVY_SANITY_CHECKS
                    DoSanityChecks();
#endif
                    int cacheSize = 0;
                    List<CurvySplineSegment> segments = Segments;
                    for (int i = 0; i < segments.Count; i++)
                        cacheSize += segments[i].CacheSize;

                    if (Dirty == false)
                        mCacheSize = cacheSize;
                    return cacheSize;
                }
                return mCacheSize;
            }
        }

        /// <summary>
        /// Gets the total length of the Spline or SplineGroup
        /// </summary>
        /// <remarks>The accuracy depends on the current Granularity (higher Granularity means more exact values)</remarks>
        public float Length
        {
            get
            {
                if (length < 0)
                {
#if CURVY_SANITY_CHECKS
                    DoSanityChecks();
#endif

                    float tempLength;
                    if (Segments.Count == 0)
                        tempLength = 0;
                    else
                        tempLength = (Closed) ? this[Count - 1].Distance + this[Count - 1].Length : LastVisibleControlPoint.Distance;
                    if (Dirty == false)
                        length = tempLength;
                    return tempLength;
                }
                return length;
            }
        }

        /// <summary>
        /// When a spline is dirty, this means that it's cached data is no more up to date, and should be updated. The update is done automatically each frame when needed, or manually by calling <see cref="Refresh"/>
        /// </summary>
        public bool Dirty
        {
            get
            {
                return (allControlPointsAreDirty || dirtyControlPointsMinimalSet.Count > 0);
            }
        }

        /// <summary>
        /// Gets the Segment at a certain index
        /// </summary>
        /// <param name="idx">an index in the range 0..Count</param>
        /// <returns>the corresponding spline segment</returns>
        public CurvySplineSegment this[int idx]
        {
            get
            {
#if CONTRACTS_FULL
                Contract.Requires(idx > -1 && idx < Segments.Count);
#endif
                return Segments[idx];
            }
        }

        /// <summary>
        /// The list of control points
        /// </summary>
        public ReadOnlyCollection<CurvySplineSegment> ControlPointsList
        {
            //TODO use IReadOnlyList when .NET 4.6 will be default
            get
            {
                //OPTIM find the proper place to initialize readOnlyControlPoints, to avoid the if bellow to be tested at each call.
                //Note: even when initializing readOnlyControlPoints in Awake, OnEnable, OnAfterDeserialize  and OnValidate, scene 25 had a null reference exception on readOnlyControlPoints. Here is the stack trace:
                /*
                NullReferenceException: Object reference not set to an instance of an object
                FluffyUnderware.Curvy.CurvySpline.GetControlPointIndex (FluffyUnderware.Curvy.CurvySplineSegment controlPoint) (at Assets/Packages/Curvy/Base/CurvySpline.cs:254)
                FluffyUnderware.Curvy.CurvySplineSegment.GetPreviousControlPoint (System.Boolean segmentsOnly, System.Boolean useFollowUp) (at Assets/Packages/Curvy/Base/CurvySplineSegment.cs:1552)
                FluffyUnderware.Curvy.CurvySplineSegment.SetDirty (System.Boolean dirtyCurve, System.Boolean dirtyOrientation) (at Assets/Packages/Curvy/Base/CurvySplineSegment.cs:2148)
                FluffyUnderware.Curvy.CurvyMetadataBase.SetDirty () (at Assets/Packages/Curvy/Base/CurvyMetadataBase.cs:84)
                FluffyUnderware.Curvy.MetaCGOptions.OnValidate () (at Assets/Packages/Curvy/Base/CG/MetaCGOptions.cs:239)
                */
                if (readOnlyControlPoints == null)
                    readOnlyControlPoints = ControlPoints.AsReadOnly();
                return readOnlyControlPoints;
            }
        }



        /// <summary>
        /// Gets the first visible Control Point (equals the first segment or this[0])
        /// </summary>
        /// <remarks>Can be null, for example for a Catmull-Rom spline whith only two splines and AutoEndTangent set to false</remarks>
        [CanBeNull]
        public CurvySplineSegment FirstVisibleControlPoint
        {
            get
            {
                if (isCpsRelationshipCacheValid == false)
                    RebuildControlPointsRelationshipCache(true);
                return firstVisibleControlPoint;
            }
        }

        /// <summary>
        /// Gets the last visible Control Point (i.e. the end CP of the last segment)
        /// </summary>
        /// <remarks>Is null if spline has no segments</remarks>
        [CanBeNull]
        public CurvySplineSegment LastVisibleControlPoint
        {
            get
            {
                if (isCpsRelationshipCacheValid == false)
                    RebuildControlPointsRelationshipCache(true);
                return lastVisibleControlPoint;
            }
        }

        /// <summary>
        /// Gets the first segment of the spline
        /// </summary>
        public CurvySplineSegment FirstSegment
        {
            get
            {
                if (isCpsRelationshipCacheValid == false)
                    RebuildControlPointsRelationshipCache(true);
                return firstSegment;
            }
        }

        /// <summary>
        /// Gets the last segment of the spline
        /// </summary>
        public CurvySplineSegment LastSegment
        {
            get
            {
                if (isCpsRelationshipCacheValid == false)
                    RebuildControlPointsRelationshipCache(true);
                return lastSegment;
            }
        }

        /// <summary>
        /// Returns true if the global position, rotation or scale of the spline has changed this frame
        /// </summary>
        /// <seealso cref="OnGlobalCoordinatesChanged"/>
        public bool GlobalCoordinatesChangedThisFrame
        {
            get { return globalCoordinatesChangedThisFrame; }
        }

        /// <summary>
        /// Is triggered when the global position, rotation or scale of the spline changes.
        /// The triggering instance of CurvySpline is passed as a parameter of the delegate
        /// </summary>
        /// <remarks>This is triggered at the very end of the spline updating method. <see cref="UpdateIn"/></remarks>
        /// <seealso cref="GlobalCoordinatesChangedThisFrame"/>
        public Action<CurvySpline> OnGlobalCoordinatesChanged { get; set; }

        public CurvySplineEvent OnRefresh
        {
            get { return m_OnRefresh; }
            set
            {
                if (m_OnRefresh != value)
                    m_OnRefresh = value;

            }

        }
        /// <summary>
        /// Callback after one or more Control Points have been added or deleted
        /// </summary>
        /// <remarks>This executes last, after individual add/delete events and OnRefresh </remarks>
        public CurvySplineEvent OnAfterControlPointChanges
        {
            get { return m_OnAfterControlPointChanges; }
            set
            {
                if (m_OnAfterControlPointChanges != value)
                    m_OnAfterControlPointChanges = value;
            }
        }
        /// <summary>
        /// Callback before a Control Point is about to be added
        /// </summary>
        public CurvyControlPointEvent OnBeforeControlPointAdd
        {
            get { return m_OnBeforeControlPointAdd; }
            set
            {
                if (m_OnBeforeControlPointAdd != value)
                    m_OnBeforeControlPointAdd = value;
            }
        }
        /// <summary>
        /// Callback after a Control Point has been added and the spline was refreshed
        /// </summary>
        public CurvyControlPointEvent OnAfterControlPointAdd
        {
            get { return m_OnAfterControlPointAdd; }
            set
            {
                if (m_OnAfterControlPointAdd != value)
                    m_OnAfterControlPointAdd = value;
            }

        }
        /// <summary>
        /// Callback before a Control Point is about to be deleted. Return false to cancel the execution.
        /// </summary>
        public CurvyControlPointEvent OnBeforeControlPointDelete
        {
            get { return m_OnBeforeControlPointDelete; }
            set
            {
                if (m_OnBeforeControlPointDelete != value)
                    m_OnBeforeControlPointDelete = value;
            }
        }

        #endregion

        #endregion

        #region ### Public Static Methods ###

        /// <summary>
        /// Creates an empty spline
        /// </summary>
        public static CurvySpline Create()
        {
            CurvySpline spl = new GameObject("Curvy Spline", typeof(CurvySpline)).GetComponent<CurvySpline>();
            spl.gameObject.layer = CurvyGlobalManager.SplineLayer;
            spl.Start();
            return spl;
        }

        /// <summary>
        /// Creates an empty spline with the same settings as another spline
        /// </summary>
        /// <param name="takeOptionsFrom">another spline</param>
        public static CurvySpline Create(CurvySpline takeOptionsFrom)
        {
            CurvySpline spl = Create();
            if (takeOptionsFrom)
            {
                spl.RestrictTo2D = takeOptionsFrom.RestrictTo2D;
                spl.GizmoColor = takeOptionsFrom.GizmoColor;
                spl.GizmoSelectionColor = takeOptionsFrom.GizmoSelectionColor;
                spl.Interpolation = takeOptionsFrom.Interpolation;
                spl.Closed = takeOptionsFrom.Closed;
                spl.AutoEndTangents = takeOptionsFrom.AutoEndTangents;
                spl.CacheDensity = takeOptionsFrom.CacheDensity;
                spl.MaxPointsPerUnit = takeOptionsFrom.MaxPointsPerUnit;
                spl.Orientation = takeOptionsFrom.Orientation;
                spl.CheckTransform = takeOptionsFrom.CheckTransform;
            }
            return spl;
        }

        /// <summary>
        /// Gets the number of Cache Points needed for a certain part of a spline
        /// </summary>
        /// <param name="density">A value between 1 and 100 included. When equal to 100, the number of cache points per world distance unit is equal to maxPointsPerUnit</param>
        /// <param name="segmentLength">the length of the spline segment</param>
        /// <param name="maxPointsPerUnit">Maximum number of Cache Points per world distance unit</param>
        public static int CalculateCacheSize(int density, float segmentLength, float maxPointsPerUnit)
        {
#if CONTRACTS_FULL
            Contract.Requires(CodeContractsUtility.IsPositiveNumber(segmentLength));
#endif
            //This basically equals to Mathf.FloorToInt(length * (maxPointsPerUnit * (density - 1) / 99) + MinimalMaxPointsPerUnit) + 1
            //Here is a plot of (density - 1) / 99)
            //https://www.wolframalpha.com/input/?i=plot+((x+-+1)+%2F+99+)%5E2+for+x+from+1+to+100
            float samplePoints = CalculateSamplingPointsPerUnit(density, maxPointsPerUnit) * segmentLength;
            samplePoints = Math.Min(samplePoints, MaxSegmentCacheSize - 1);
            return Mathf.FloorToInt(samplePoints) + 1;
        }

        /// <summary>
        /// Returns the (floating) number of sampling points per world distance unit.
        /// </summary>
        /// <param name="density">A value between 1 and 100 included. When equal to 100, the number of sampling points per world distance unit is equal to maxPointsPerUnit</param>
        /// <param name="maxPointsPerUnit">Maximum number of sampling points per world distance unit</param>
        /// <returns></returns>
        static public float CalculateSamplingPointsPerUnit(int density, float maxPointsPerUnit)
        {
#if CONTRACTS_FULL
            Contract.Requires(density > 0);
            Contract.Requires(density <= 100);
            Contract.Requires(maxPointsPerUnit.IsPositiveNumber());
#endif
            int clampedDensity = Mathf.Clamp(density, 1, 100);
            if (clampedDensity != density)
            {
                DTLog.LogWarning("[Curvy] CalculateSamplingPointsPerUnit got an invalid density parameter. It should be between 1 and 100. The parameter value was " + density);
                density = clampedDensity;
            }

            //This basically equals to (maxPointsPerUnit * (density - 1) / 99) + MinimalMaxPointsPerUnit)
            //Here is a plot of (density - 1) / 99)
            //https://www.wolframalpha.com/input/?i=plot+((x+-+1)+%2F+99+)%5E2+for+x+from+1+to+100
            return DTTween.QuadIn(density - 1, MinimalMaxPointsPerUnit, maxPointsPerUnit, 99);
        }

        /// <summary>
        /// Cubic-Beziere Interpolation
        /// </summary>
        /// <param name="T0">HandleIn</param>
        /// <param name="P0">Pn</param>
        /// <param name="P1">Pn+1</param>
        /// <param name="T1">HandleOut</param>
        /// <param name="f">f in the range 0..1</param>
        /// <returns></returns>
        public static Vector3 Bezier(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f)
        {
            //If you modify this, modify also the inlined version of this method in refreshCurveINTERNAL()

            const double Ft2 = 3; const double Ft3 = -3;
            const double Fu1 = 3; const double Fu2 = -6; const double Fu3 = 3;
            const double Fv1 = -3; const double Fv2 = 3;

            double FAX = -P0.x + Ft2 * T0.x + Ft3 * T1.x + P1.x;
            double FBX = Fu1 * P0.x + Fu2 * T0.x + Fu3 * T1.x;
            double FCX = Fv1 * P0.x + Fv2 * T0.x;
            double FDX = P0.x;

            double FAY = -P0.y + Ft2 * T0.y + Ft3 * T1.y + P1.y;
            double FBY = Fu1 * P0.y + Fu2 * T0.y + Fu3 * T1.y;
            double FCY = Fv1 * P0.y + Fv2 * T0.y;
            double FDY = P0.y;

            double FAZ = -P0.z + Ft2 * T0.z + Ft3 * T1.z + P1.z;
            double FBZ = Fu1 * P0.z + Fu2 * T0.z + Fu3 * T1.z;
            double FCZ = Fv1 * P0.z + Fv2 * T0.z;
            double FDZ = P0.z;

            float FX = (float)(((FAX * f + FBX) * f + FCX) * f + FDX);
            float FY = (float)(((FAY * f + FBY) * f + FCY) * f + FDY);
            float FZ = (float)(((FAZ * f + FBZ) * f + FCZ) * f + FDZ);

            Vector3 result;
            result.x = FX;
            result.y = FY;
            result.z = FZ;
            return result;
        }

        //OPTIM Is using this better than using positions delta?
        public static Vector3 BezierTangent(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f)
        {
            Vector3 C1 = (P1 - (3.0f * T1) + (3.0f * T0) - P0);
            Vector3 C2 = ((3.0f * T1) - (6.0f * T0) + (3.0f * P0));
            Vector3 C3 = ((3.0f * T0) - (3.0f * P0));
            return ((3.0f * f * f * C1) + (2.0f * f * C2) + C3);
        }

        /// <summary>
        /// Catmull-Rom Interpolation
        /// </summary>
        /// <param name="T0">Pn-1 (In Tangent)</param>
        /// <param name="P0">Pn</param>
        /// <param name="P1">Pn+1</param>
        /// <param name="T1">Pn+2 (Out Tangent)</param>
        /// <param name="f">f in the range 0..1</param>
        /// <returns>the interpolated position</returns>
        public static Vector3 CatmullRom(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f)
        {
            //If you modify this, modify also the inlined version of this method in refreshCurveINTERNAL()

            const double Ft1 = -0.5; const double Ft2 = 1.5; const double Ft3 = -1.5; const double Ft4 = 0.5;
            const double Fu2 = -2.5; const double Fu3 = 2; const double Fu4 = -0.5;
            const double Fv1 = -0.5; const double Fv3 = 0.5;

            double FAX = Ft1 * T0.x + Ft2 * P0.x + Ft3 * P1.x + Ft4 * T1.x;
            double FBX = T0.x + Fu2 * P0.x + Fu3 * P1.x + Fu4 * T1.x;
            double FCX = Fv1 * T0.x + Fv3 * P1.x;
            double FDX = P0.x;

            double FAY = Ft1 * T0.y + Ft2 * P0.y + Ft3 * P1.y + Ft4 * T1.y;
            double FBY = T0.y + Fu2 * P0.y + Fu3 * P1.y + Fu4 * T1.y;
            double FCY = Fv1 * T0.y + Fv3 * P1.y;
            double FDY = P0.y;

            double FAZ = Ft1 * T0.z + Ft2 * P0.z + Ft3 * P1.z + Ft4 * T1.z;
            double FBZ = T0.z + Fu2 * P0.z + Fu3 * P1.z + Fu4 * T1.z;
            double FCZ = Fv1 * T0.z + Fv3 * P1.z;
            double FDZ = P0.z;

            float FX = (float)(((FAX * f + FBX) * f + FCX) * f + FDX);
            float FY = (float)(((FAY * f + FBY) * f + FCY) * f + FDY);
            float FZ = (float)(((FAZ * f + FBZ) * f + FCZ) * f + FDZ);

            Vector3 result;
            result.x = FX;
            result.y = FY;
            result.z = FZ;
            return result;
        }

        /// <summary>
        /// Kochanek-Bartels/TCB-Interpolation
        /// </summary>
        /// <param name="T0">Pn-1 (In Tangent)</param>
        /// <param name="P0">Pn</param>
        /// <param name="P1">Pn+1</param>
        /// <param name="T1">Pn+2 (Out Tangent)</param>
        /// <param name="f">f in the range 0..1</param>
        /// <param name="FT0">Start Tension</param>
        /// <param name="FC0">Start Continuity</param>
        /// <param name="FB0">Start Bias</param>
        /// <param name="FT1">End Tension</param>
        /// <param name="FC1">End Continuity</param>
        /// <param name="FB1">End Bias</param>
        /// <returns>the interpolated position</returns>
        public static Vector3 TCB(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f, float FT0, float FC0, float FB0, float FT1, float FC1, float FB1)
        {
            //If you modify this, modify also the inlined version of this method in refreshCurveINTERNAL()

            double FFA = (1 - FT0) * (1 + FC0) * (1 + FB0);
            double FFB = (1 - FT0) * (1 - FC0) * (1 - FB0);
            double FFC = (1 - FT1) * (1 - FC1) * (1 + FB1);
            double FFD = (1 - FT1) * (1 + FC1) * (1 - FB1);

            double DD = 2;
            double Ft1 = -FFA / DD; double Ft2 = (+4 + FFA - FFB - FFC) / DD; double Ft3 = (-4 + FFB + FFC - FFD) / DD; double Ft4 = FFD / DD;
            double Fu1 = +2 * FFA / DD; double Fu2 = (-6 - 2 * FFA + 2 * FFB + FFC) / DD; double Fu3 = (+6 - 2 * FFB - FFC + FFD) / DD; double Fu4 = -FFD / DD;
            double Fv1 = -FFA / DD; double Fv2 = (FFA - FFB) / DD; double Fv3 = FFB / DD;
            double Fw2 = +2 / DD;

            double FAX = Ft1 * T0.x + Ft2 * P0.x + Ft3 * P1.x + Ft4 * T1.x;
            double FBX = Fu1 * T0.x + Fu2 * P0.x + Fu3 * P1.x + Fu4 * T1.x;
            double FCX = Fv1 * T0.x + Fv2 * P0.x + Fv3 * P1.x;
            double FDX = Fw2 * P0.x;

            double FAY = Ft1 * T0.y + Ft2 * P0.y + Ft3 * P1.y + Ft4 * T1.y;
            double FBY = Fu1 * T0.y + Fu2 * P0.y + Fu3 * P1.y + Fu4 * T1.y;
            double FCY = Fv1 * T0.y + Fv2 * P0.y + Fv3 * P1.y;
            double FDY = Fw2 * P0.y;

            double FAZ = Ft1 * T0.z + Ft2 * P0.z + Ft3 * P1.z + Ft4 * T1.z;
            double FBZ = Fu1 * T0.z + Fu2 * P0.z + Fu3 * P1.z + Fu4 * T1.z;
            double FCZ = Fv1 * T0.z + Fv2 * P0.z + Fv3 * P1.z;
            double FDZ = Fw2 * P0.z;

            float FX = (float)(((FAX * f + FBX) * f + FCX) * f + FDX);
            float FY = (float)(((FAY * f + FBY) * f + FCY) * f + FDY);
            float FZ = (float)(((FAZ * f + FBZ) * f + FCZ) * f + FDZ);

            Vector3 result;
            result.x = FX;
            result.y = FY;
            result.z = FZ;
            return result;
        }


        /// <summary>
        /// This method returns the Control Point next to the Follow-Up, based on the ConnectionHeadingEnum's value
        /// </summary>
        /// <param name="followUp">The Control Point used as a Follow-Up</param>
        /// <param name="headingDirection">The head to direction</param>
        /// <returns>The Control Point the Follow-Up is heading to </returns>
        [NotNull]
        public static CurvySplineSegment GetFollowUpHeadingControlPoint(CurvySplineSegment followUp, ConnectionHeadingEnum headingDirection)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(followUp != null);
            Assert.IsTrue(followUp.Spline != null);
#endif
            ConnectionHeadingEnum resolveHeading = headingDirection.ResolveAuto(followUp);
            CurvySplineSegment result;
            switch (resolveHeading)
            {
                case ConnectionHeadingEnum.Minus:
                    result = followUp.Spline.GetPreviousControlPoint(followUp);
                    break;
                case ConnectionHeadingEnum.Plus:
                    result = followUp.Spline.GetNextControlPoint(followUp);
                    break;
                case ConnectionHeadingEnum.Sharp:
                    result = followUp;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            return result;
        }

        #endregion

        #region ### Public Methods ###

        #region --- Methods based on TF (total fragment) ---

        /// <summary>
        /// Gets the position of a point on the spline segment
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 Interpolate(float tf, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                return seg.Interpolate(localF, space);

            return space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets the position of a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 InterpolateFast(float tf, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                return seg.InterpolateFast(localF, space);

            return space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets the position of a point on the spline segment
        /// </summary>
        /// <param name="distance">The distance between the spline's start and the point you are interested in. Value should be in the range from 0 to <see cref="Length"/> inclusive</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 InterpolateByDistance(float distance, Space space = Space.Self)
        {
            return Interpolate(DistanceToTF(distance), space);
        }

        /// <summary>
        /// Gets the position of a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="distance">The distance between the spline's start and the point you are interested in. Value should be in the range from 0 to <see cref="Length"/> inclusive</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 InterpolateByDistanceFast(float distance, Space space = Space.Self)
        {
            return InterpolateFast(DistanceToTF(distance), space);
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 GetTangent(float tf, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                return seg.GetTangent(localF, space);

            return space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment.
        /// This method is faster than <see cref="GetTangent(float, Space)"/> if you have already the position of the point.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="position">the position of the point at localF. In other words, the result of <see cref="Interpolate(float, Space)"/></param>
        /// <param name="space">The space (local/object or global/world) in which the returned result and the <paramref name="position"/> parameter are expressed</param>
        public Vector3 GetTangent(float tf, Vector3 position, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                return seg.GetTangent(localF, position, space);

            return space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 GetTangentFast(float tf, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                return seg.GetTangentFast(localF, space);

            return space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment
        /// </summary>
        /// <param name="distance">The distance between the spline's start and the point you are interested in. Value should be in the range from 0 to <see cref="Length"/> inclusive</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 GetTangentByDistance(float distance, Space space = Space.Self)
        {
            return GetTangent(DistanceToTF(distance), space);
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="distance">The distance between the spline's start and the point you are interested in. Value should be in the range from 0 to <see cref="Length"/> inclusive</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 GetTangentByDistanceFast(float distance, Space space = Space.Self)
        {
            return GetTangentFast(DistanceToTF(distance), space);
        }

        /// <summary>
        /// Gets the position and normalized tangent at a point on the spline segment
        /// Is Faster than calling <see cref="Interpolate(float, Space)"/> and <see cref="Interpolate(float, Space)"/> separately
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="position">the output position</param>
        /// <param name="tangent">the output tangent</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public void InterpolateAndGetTangent(float tf, out Vector3 position, out Vector3 tangent, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                seg.InterpolateAndGetTangent(localF, out position, out tangent, space);
            else
                position = tangent = space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets the position and normalized tangent at a point on the spline segment
        /// Is Faster than calling <see cref="Interpolate(float, Space)"/> and <see cref="Interpolate(float, Space)"/> separately
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="position">the output position</param>
        /// <param name="tangent">the output tangent</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public void InterpolateAndGetTangentFast(float tf, out Vector3 position, out Vector3 tangent, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                seg.InterpolateAndGetTangentFast(localF, out position, out tangent, space);
            else
                position = tangent = space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets the Up vector of a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        public Vector3 GetOrientationUpFast(float tf, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                return seg.GetOrientationUpFast(localF, space);

            return space == Space.Self ? Vector3.zero : cachedTransform.position;
        }

        /// <summary>
        /// Gets a rotation looking to Tangent with the head upwards along the Up-Vector
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="inverse">whether the orientation should be inversed or not</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <returns>a rotation, relative to the spline's local space</returns>
        public Quaternion GetOrientationFast(float tf, bool inverse = false, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            if (ReferenceEquals(seg, null) == false)
                return seg.GetOrientationFast(localF, inverse, space);

            return space == Space.Self ? Quaternion.identity : cachedTransform.rotation;
        }

        /// <summary>
        /// Gets metadata for a certain TF
        /// </summary>
        /// <typeparam name="T">Metadata type interfacing ICurvyMetadata</typeparam>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <returns>the metadata</returns>
        public T GetMetadata<T>(float tf) where T : CurvyMetadataBase
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            return ReferenceEquals(seg, null) == false ? seg.GetMetadata<T>() : null;
        }


        /// <summary>
        /// Gets an interpolated Metadata value for a certain TF
        /// </summary>
        /// <typeparam name="T">Metadata type inheriting from CurvyInterpolatableMetadataBase</typeparam>
        /// <typeparam name="U">Metadata's Value type</typeparam>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <returns>The interpolated value. If no Metadata of specified type is present at the given tf, the default value of type U is returned</returns>
        public U GetInterpolatedMetadata<T, U>(float tf) where T : CurvyInterpolatableMetadataBase<U>
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float localF;
            CurvySplineSegment seg = TFToSegment(tf, out localF);
            return ReferenceEquals(seg, null) == false ? seg.GetInterpolatedMetadata<T, U>(localF) : default;
        }

        #endregion

        #region --- Conversion Methods ---

        /// <summary>
        /// Converts a TF value to a distance
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="clamping">Clamping to use</param>
        /// <returns>distance from spline's start</returns>
        public float TFToDistance(float tf, CurvyClamping clamping = CurvyClamping.Clamp)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif
            float splineLength = Length;

            float result;
            if (splineLength == 0)
                result = 0;
            else if (tf == 0)
                result = 0;
            else if (tf == 1)
                result = splineLength;
            else
            {
                float localF;
                CurvySplineSegment seg = TFToSegment(tf, out localF, clamping);
                result = (ReferenceEquals(seg, null) == false) ? seg.Distance + seg.LocalFToDistance(localF) : 0;
            }
            return result;
        }

        /// <summary>
        /// Gets the segment and the local F for a certain TF
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="localF">gets the remaining localF in the range 0..1</param>
        /// <param name="isOnSegmentStart">Is True if the given distance is positioned at the returned segment's start</param>
        /// <param name="isOnSegmentEnd">Is True if the given distance is positioned at the returned segment's end</param>
        /// <param name="clamping">Clamping to use</param>
        /// <returns>the segment the given TF is inside</returns>
        public CurvySplineSegment TFToSegment(float tf, out float localF, out bool isOnSegmentStart, out bool isOnSegmentEnd, CurvyClamping clamping)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            tf = CurvyUtility.ClampTF(tf, clamping);
            int segmentsCount = Count;
            if (segmentsCount == 0)
            {
                localF = 0;
                isOnSegmentStart = false;
                isOnSegmentEnd = false;
                return null;
            }

            float f = tf * segmentsCount;
            int idx = (int)f;
            localF = f - idx;

            if (idx == segmentsCount)
            {
                idx--;
                localF = 1;
            }

            isOnSegmentStart = f == (float)idx;
            isOnSegmentEnd = tf == 1f;

            return this[idx];
        }

        /// <summary>
        /// Gets the segment and the local F for a certain TF
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="localF">gets the remaining localF in the range 0..1</param>
        /// <param name="clamping">Clamping to use</param>
        /// <returns>the segment the given TF is inside</returns>
        public CurvySplineSegment TFToSegment(float tf, out float localF, CurvyClamping clamping)
        {
            return TFToSegment(tf, out localF, out _, out _, clamping);
        }

        /// <summary>
        /// Gets the segment for a certain TF
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="clamping">Clamping to use</param>
        /// <returns>the segment the given TF is inside</returns>
        public CurvySplineSegment TFToSegment(float tf, CurvyClamping clamping)
        {
            return TFToSegment(tf, out _, clamping);
        }

        /// <summary>
        /// Gets the segment for a certain TF clamped to 0..1
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <returns>the segment the given TF is inside</returns>
        public CurvySplineSegment TFToSegment(float tf)
        {
            return TFToSegment(tf, out _, CurvyClamping.Clamp);
        }
        /// <summary>
        /// Gets the segment and the local F for a certain TF clamped to 0..1
        /// </summary>
        /// <param name="tf">TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline</param>
        /// <param name="localF">gets the remaining localF in the range 0..1</param>
        /// <returns>the segment the given TF is inside</returns>
        public CurvySplineSegment TFToSegment(float tf, out float localF)
        {
            return TFToSegment(tf, out localF, CurvyClamping.Clamp);
        }

        /// <summary>
        /// Gets a TF value from a segment
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="segment">a segment</param>
        /// <returns>a TF value in the range 0..1</returns>
        public float SegmentToTF(CurvySplineSegment segment)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, segment.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, segment, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            return segment.GetExtrinsicPropertiesINTERNAL().TF;
        }

        /// <summary>
        /// Gets a TF value from a segment and a local F
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="segment">a segment</param>
        /// <param name="localF">F of this segment in the range 0..1</param>
        /// <returns>a TF value in the range 0..1</returns>
        public float SegmentToTF(CurvySplineSegment segment, float localF)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, segment.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, segment, name));
            Assert.IsTrue(localF.IsBetween0And1(), localF.ToString("R"));
#endif

            float result;
            if (IsControlPointASegment(segment))
            {
                //OPTIM a possible optimization would be to make this branch of the if the only executed code, so no call to IsControlPointASegment. the comparison with 1 bellow will take care of the last cp. The only remaining issue would be to handle the fake first cp create by AutoEndTangents for CatmullRom and TCB splines. I believe the only way to handle it would be to have separate treatment for autoendtangents. Might still be worth it.

                result = SegmentToTF(segment) + (localF / Count);
                //sometimes due to float imprecision, result can go beyond 1
                if (result > 1)
                    result = 1;
            }
            else
                result = SegmentToTF(segment);

#if CURVY_SANITY_CHECKS
            Assert.IsTrue(result.IsBetween0And1(), result.ToString("R"));
#endif

            return result;
        }

        /// <summary>
        /// Converts a distance to a TF value
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.This is the "time" parameter used in the splines' formulas. A point's F is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="distance">distance</param>
        /// <param name="clamping">Clamping to use</param>
        /// <returns>a TF value in the range 0..1</returns>
        public float DistanceToTF(float distance, CurvyClamping clamping = CurvyClamping.Clamp)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif
            float result;
            if (Length == 0)
                result = 0;
            else if (distance == 0)
                result = 0;
            else if (distance == Length)
                result = 1;
            else
            {
                float localDistance;
                // Get the segment the distance lies within
                CurvySplineSegment seg = DistanceToSegment(distance, out localDistance, clamping);
                result = ReferenceEquals(seg, null) == false ? SegmentToTF(seg, seg.DistanceToLocalF(localDistance)) : 0;
            }
            return result;
        }

        /// <summary>
        /// Gets the segment a certain distance lies within
        /// </summary>
        /// <param name="distance">a distance in the range 0..Length</param>
        /// <param name="clamping">clamping to use</param>
        /// <returns>a spline segment or null</returns>
        public CurvySplineSegment DistanceToSegment(float distance, CurvyClamping clamping = CurvyClamping.Clamp)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            float d;
            return DistanceToSegment(distance, out d, clamping);
        }

        /// <summary>
        /// Gets the segment a certain distance lies within
        /// </summary>
        /// <param name="distance">a distance in the range 0..Length</param>
        /// <param name="localDistance">gets the remaining distance inside the segment</param>
        /// <param name="clamping">clamping to use</param>
        /// <returns>a spline segment</returns>
        public CurvySplineSegment DistanceToSegment(float distance, out float localDistance, CurvyClamping clamping = CurvyClamping.Clamp)
        {
            return DistanceToSegment(distance, out localDistance, out _, out _, clamping);
        }

        /// <summary>
        /// Gets the segment a certain distance lies within
        /// </summary>
        /// <param name="distance">a distance in the range 0..Length</param>
        /// <param name="localDistance">gets the remaining distance inside the segment</param>
        /// <param name="isOnSegmentStart">Is True if the given distance is positioned at the returned segment's start</param>
        /// <param name="isOnSegmentEnd">Is True if the given distance is positioned at the returned segment's end</param>
        /// <param name="clamping">clamping to use</param>
        /// <returns>a spline segment</returns>
        public CurvySplineSegment DistanceToSegment(float distance, out float localDistance, out bool isOnSegmentStart, out bool isOnSegmentEnd, CurvyClamping clamping = CurvyClamping.Clamp)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif
            distance = CurvyUtility.ClampDistance(distance, clamping, Length);
            CurvySplineSegment resultSegment;
            if (Count > 0)
            {
                int resultCpIndex = CurvyUtility.InterpolationSearch(controlPointsDistances, controlPointsDistances.Length, distance);
                bool notAutoEndTangents = AutoEndTangents == false;
                int cpCount = ControlPointsList.Count;
                if (notAutoEndTangents)
                {
#if CURVY_SANITY_CHECKS_PRIVATE
                    UnityEngine.Assertions.Assert.IsFalse(Closed);
#endif
                    if (resultCpIndex == 0)
                        resultCpIndex = 1;
                    else if (resultCpIndex == cpCount - 1 || resultCpIndex == cpCount - 2)
                        resultCpIndex = cpCount - 3;
                }
                else if (Closed == false && resultCpIndex == cpCount - 1)
                    resultCpIndex = cpCount - 2;

                resultSegment = ControlPointsList[resultCpIndex];
                localDistance = distance - resultSegment.Distance;

                isOnSegmentStart = distance == resultSegment.Distance;
                isOnSegmentEnd = distance == Length;
            }
            else
            {
                resultSegment = null;
                localDistance = -1;
                isOnSegmentStart = false;
                isOnSegmentEnd = false;
            }

            return resultSegment;
        }


        #endregion


        #region Clamping

        /// <summary>
        /// Clamps absolute position
        /// </summary>
        public float ClampDistance(float distance, CurvyClamping clamping)
        {
            return CurvyUtility.ClampDistance(distance, clamping, Length);
        }

        /// <summary>
        /// Clamps absolute position
        /// </summary>
        public float ClampDistance(float distance, CurvyClamping clamping, float min, float max)
        {
            return CurvyUtility.ClampDistance(distance, clamping, Length, min, max);
        }

        /// <summary>
        /// Clamps absolute position and sets new direction
        /// </summary>
        public float ClampDistance(float distance, ref int dir, CurvyClamping clamping)
        {
            return CurvyUtility.ClampDistance(distance, ref dir, clamping, Length);
        }

        /// <summary>
        /// Clamps absolute position and sets new direction
        /// </summary>
        public float ClampDistance(float distance, ref int dir, CurvyClamping clamping, float min, float max)
        {
            return CurvyUtility.ClampDistance(distance, ref dir, clamping, Length, min, max);
        }

        #endregion

        #region --- General ---

        /// <summary>
        /// Adds a Control Point at the end of the spline
        /// This method will <see cref="Refresh"/> the spline and call the relevant events.
        /// If you want more control on the order of the added Control Point, its position, or whether <see cref="Refresh"/> and events should be called, use the <see cref="InsertBefore(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="InsertAfter(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="Add(Vector3,Space)"/> instead
        /// </summary>
        /// <returns>The added Control Point</returns>
        public CurvySplineSegment Add() { return InsertAfter(null, false); }

        /// <summary>
        /// Adds several Control Points at the end of the spline
        /// This method will <see cref="Refresh"/> the spline and call the relevant events.
        /// If you want more control on the order of the added Control Points, their position, or whether <see cref="Refresh"/> and events should be called, use the <see cref="InsertBefore(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="InsertAfter(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="Add(Vector3[],Space)"/> instead
        /// </summary>
        /// <param name="controlPointsCount">The number of  Control Points to add</param>
        public CurvySplineSegment[] Add(int controlPointsCount)
        {
            Vector3[] controlPointsLocalPositions = new Vector3[controlPointsCount];
            return Add(controlPointsLocalPositions);
        }

        /// <summary>
        /// Adds several Control Points at the end of the spline
        /// This method will <see cref="Refresh"/> the spline and call the relevant events.
        /// If you want more control on the order of the added Control Points, their position, or whether <see cref="Refresh"/> and events should be called, use the <see cref="InsertBefore(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="InsertAfter(CurvySplineSegment,Vector3,bool,Space)"/> instead
        /// </summary>
        /// <param name="controlPointPosition">The position of the Control Point to add</param>
        /// <param name="space">Whether the position is in the local or global space</param>
        /// <returns>The added Control Points</returns>
        public CurvySplineSegment Add(Vector3 controlPointPosition, Space space)
        {
            OnBeforeControlPointAddEvent(defaultAddAfterEventArgs);

            CurvySplineSegment result = InsertAfter(null, controlPointPosition, true, space);

            Refresh();
            OnAfterControlPointAddEvent(defaultAddAfterEventArgs);
            OnAfterControlPointChangesEvent(defaultSplineEventArgs);

            return result;
        }

        /// <summary>
        /// Adds several Control Points at the end of the spline
        /// This method will <see cref="Refresh"/> the spline and call the relevant events.
        /// If you want more control on the order of the added Control Points, their position, or whether <see cref="Refresh"/> and events should be called, use the <see cref="InsertBefore(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="InsertAfter(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="Add(Vector3[],Space)"/> instead
        /// </summary>
        /// <param name="controlPointsLocalPositions">The local position of the Control Points to add</param>
        /// <returns>The added Control Points</returns>
        public CurvySplineSegment[] Add(params Vector3[] controlPointsLocalPositions)
        {
            OnBeforeControlPointAddEvent(defaultAddAfterEventArgs);

            CurvySplineSegment[] cps = new CurvySplineSegment[controlPointsLocalPositions.Length];
            for (int i = 0; i < controlPointsLocalPositions.Length; i++)
                cps[i] = InsertAfter(null, controlPointsLocalPositions[i], true, Space.Self);

            Refresh();
            OnAfterControlPointAddEvent(defaultAddAfterEventArgs);
            OnAfterControlPointChangesEvent(defaultSplineEventArgs);

            return cps;
        }

        /// <summary>
        /// Adds several Control Points at the end of the spline
        /// This method will <see cref="Refresh"/> the spline and call the relevant events.
        /// If you want more control on the order of the added Control Points, their position, or whether <see cref="Refresh"/> and events should be called, use the <see cref="InsertBefore(CurvySplineSegment,Vector3,bool,Space)"/> and <see cref="InsertAfter(CurvySplineSegment,Vector3,bool,Space)"/> instead
        /// </summary>
        /// <param name="controlPointsPositions">The positions of the Control Points to add</param>
        /// <param name="space">Whether the positions are in the local or global space</param>
        /// <returns>The added Control Points</returns>
        public CurvySplineSegment[] Add(Vector3[] controlPointsPositions, Space space)
        {
            OnBeforeControlPointAddEvent(defaultAddAfterEventArgs);

            CurvySplineSegment[] cps = new CurvySplineSegment[controlPointsPositions.Length];
            for (int i = 0; i < controlPointsPositions.Length; i++)
                cps[i] = InsertAfter(null, controlPointsPositions[i], true, space);

            Refresh();
            OnAfterControlPointAddEvent(defaultAddAfterEventArgs);
            OnAfterControlPointChangesEvent(defaultSplineEventArgs);

            return cps;
        }

        /// <summary>
        /// Inserts a Control Point before a given Control Point
        /// </summary>
        /// <remarks>If you add several Control Points in a row, using <see cref="Add(Vector3[] controlPoints)"/> will be more efficient</remarks>
        /// <param name="controlPoint">A control point of the spline, before which the new control point will be added. If null, the CP will be added at the start of the spline</param>
        /// <returns>The created Control Point</returns>
        /// <param name="skipRefreshingAndEvents">If true, the spline's <see cref="Refresh"/> method will not be called, and the relevant events will not be triggered</param>
        public CurvySplineSegment InsertBefore(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents = false)
        {
            Vector3 position;
            CurvySplineSegment previousControlPoint;
            if (controlPoint && (previousControlPoint = GetPreviousControlPoint(controlPoint)))
                position = IsControlPointASegment(previousControlPoint) ?
                    previousControlPoint.Interpolate(0.5f, Space.World) :
                    OptimizedOperators.LerpUnclamped(previousControlPoint.transform.position, controlPoint.transform.position, 0.5f);
            else
                position = transform.position;

            return InsertBefore(controlPoint, position, skipRefreshingAndEvents, Space.World);
        }

        /// <summary>
        /// Inserts a Control Point before a given Control Point
        /// </summary>
        /// <remarks>If you add several Control Points in a row, using <see cref="Add(Vector3[] controlPoints)"/> will be more efficient</remarks>
        /// <param name="controlPoint">A control point of the spline, before which the new control point will be added. If null, the CP will be added at the start of the spline</param>
        /// <param name="position">The position of the control point at its creation</param>
        /// <param name="skipRefreshingAndEvents">If true, the spline's <see cref="Refresh"/> method will not be called, and the relevant events will not be triggered</param>
        /// <param name="space">Whether the position is in the local or global space</param>
        /// <returns>The created Control Point</returns>
        public CurvySplineSegment InsertBefore([CanBeNull] CurvySplineSegment controlPoint, Vector3 position, bool skipRefreshingAndEvents = false, Space space = Space.World)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(controlPoint, null) == false && ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            return InsertAt(
                controlPoint,
                position,
                ReferenceEquals(controlPoint, null) == false
                    ? Mathf.Max(0, GetControlPointIndex(controlPoint))
                    : 0,
                CurvyControlPointEventArgs.ModeEnum.AddBefore,
                skipRefreshingAndEvents,
                space);
        }

        /// <summary>
        /// Inserts a Control Point after a given Control Point
        /// </summary>
        /// <remarks>If you add several Control Points in a row, using <see cref="Add(Vector3[] controlPoints)"/> will be more efficient</remarks>
        /// <param name="controlPoint">A control point of the spline, behind which the new control point will be added. If null, the CP will be added at the end of the spline</param>
        /// <param name="skipRefreshingAndEvents">If true, the spline's <see cref="Refresh"/> method will not be called, and the relevant events will not be triggered</param>
        /// <returns>the new Control Point</returns>
        public CurvySplineSegment InsertAfter(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents = false)
        {
            Vector3 position;
            if (controlPoint)
            {
                if (IsControlPointASegment(controlPoint))
                    position = controlPoint.Interpolate(0.5f, Space.World);
                else
                {
                    CurvySplineSegment nextControlPoint = GetNextControlPoint(controlPoint);
                    position = nextControlPoint
                        ? OptimizedOperators.LerpUnclamped(nextControlPoint.transform.position, controlPoint.transform.position, 0.5f)
                        : controlPoint.transform.position;
                }
            }
            else
                position = transform.position;

            return InsertAfter(controlPoint, position, skipRefreshingAndEvents, Space.World);
        }

        /// <summary>
        /// Inserts a Control Point after a given Control Point
        /// </summary>
        /// <remarks>If you add several Control Points in a row, using <see cref="Add(Vector3[] controlPoints)"/> will be more efficient</remarks>
        /// <param name="controlPoint">A control point of the spline, behind which the new control point will be added. If null, the CP will be added at the end of the spline</param>
        /// <param name="position">The position of the control point at its creation</param>
        /// <param name="skipRefreshingAndEvents">If true, the spline's <see cref="Refresh"/> method will not be called, and the relevant events will not be triggered</param>
        /// <param name="space">Whether the position is in the local or global space</param>
        /// <returns>the new Control Point</returns>
        public CurvySplineSegment InsertAfter([CanBeNull] CurvySplineSegment controlPoint, Vector3 position, bool skipRefreshingAndEvents = false, Space space = Space.World)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(controlPoint, null) == false && ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif
            return InsertAt(
                controlPoint,
                position,
                ReferenceEquals(controlPoint, null) == false
                    ? GetControlPointIndex(controlPoint) + 1
                    : ControlPoints.Count,
                CurvyControlPointEventArgs.ModeEnum.AddAfter,
                skipRefreshingAndEvents,
                space);
        }

        /// <summary>
        /// Removes all control points
        /// <param name="isUndoable">If true, the clearing of the spline is made undoable (CTRL+Z) in the editor</param>
        /// </summary>
        public void Clear(bool isUndoable = true)
        {
            OnBeforeControlPointDeleteEvent(defaultDeleteEventArgs);

            for (int i = ControlPointCount - 1; i >= 0; i--)
                if (UsePooling && Application.isPlaying)
                {
                    CurvyGlobalManager curvyGlobalManager = CurvyGlobalManager.Instance;
                    if (curvyGlobalManager == null)
                        DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.", this);
                    else
                        curvyGlobalManager.ControlPointPool.Push(ControlPoints[i]);
                }
                else
                {
#if UNITY_EDITOR
                    if (!Application.isPlaying)
                        //BUG I am sure this is source of bug if the scene has an id 42. Check this potential issue
                        _newSelectionInstanceIDINTERNAL = 42; // Prevent selection of another CP/Spline
#endif
                    ControlPoints[i].gameObject.Destroy(isUndoable, true);
                }

            ClearControlPoints();

            Refresh();
            OnAfterControlPointChangesEvent(defaultSplineEventArgs);
#if UNITY_EDITOR
            _newSelectionInstanceIDINTERNAL = 0;
#endif
        }

        /// <summary>
        /// Deletes a Control Point
        /// </summary>
        /// <param name="controlPoint">a Control Point</param>
        /// <param name="skipRefreshingAndEvents">If true, the spline's <see cref="Refresh"/> method will not be called, and the relevant events will not be triggered</param>
        public void Delete(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents = false)
        {
            Delete(controlPoint, skipRefreshingAndEvents, true);
        }

        /// <summary>
        /// Deletes a Control Point
        /// </summary>
        /// <param name="controlPoint">a Control Point</param>
        /// <param name="skipRefreshingAndEvents">If true, the spline's <see cref="Refresh"/> method will not be called, and the relevant events will not be triggered</param>
        /// <param name="isUndoableDeletion">If true, the destruction of the control point's game object is made undoable (CTRL+Z) in the editor</param>
        public void Delete(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents, bool isUndoableDeletion)
        {
            if (!controlPoint)
                return;

#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (skipRefreshingAndEvents == false)
                OnBeforeControlPointDeleteEvent(new CurvyControlPointEventArgs(this, this, controlPoint, CurvyControlPointEventArgs.ModeEnum.Delete));

            RemoveControlPoint(controlPoint);

#if UNITY_EDITOR == false
            //TODO do we need this SetAsLastSibling?
            controlPoint.transform.SetAsLastSibling();// IMPORTANT! Runtime Delete is delayed, so we need to make sure it got sorted to the end 
#endif
            if (UsePooling && Application.isPlaying)
            {
                CurvyGlobalManager curvyGlobalManager = CurvyGlobalManager.Instance;
                if (curvyGlobalManager == null)
                    DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.", this);
                else
                    curvyGlobalManager.ControlPointPool.Push(controlPoint);
            }
            else
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    //BUG I am sure this is source of bug if the scene has an id 42. Check this potential issue
                    _newSelectionInstanceIDINTERNAL = 42; // Prevent selection of another CP/Spline
#endif
                controlPoint.gameObject.Destroy(isUndoableDeletion, true);
            }

            if (skipRefreshingAndEvents == false)
            {
                Refresh();
                OnAfterControlPointChangesEvent(defaultSplineEventArgs);
            }
        }

        #region Cache access

        /// <summary>
        /// Gets an array containing all approximation points
        /// </summary>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <remarks>Returns a copy of the internal cache</remarks>
        /// <returns>an array of world/local positions</returns>
        public SubArray<Vector3> GetPositionsCache(Space space)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif
            SubArray<Vector3> result = ArrayPools.Vector3.Allocate(CacheSize + 1);
            Vector3[] resultArray = result.Array;

            int idx = 0;
            for (int si = 0; si < Count; si++)
            {
                this[si].Approximation.CopyTo(resultArray, idx);
                idx += Mathf.Max(0, this[si].Approximation.Length - 1);
            }

            if (space == Space.World)
            {
                Matrix4x4 m = transform.localToWorldMatrix;
                for (int i = 0; i < result.Count; i++)
                    resultArray[i] = m.MultiplyPoint3x4(resultArray[i]);
            }

            return result;
        }

        /// <summary>
        /// Gets an array containing all approximation points
        /// </summary>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <remarks>This can be used to feed meshbuilders etc...</remarks>
        /// <returns>an array of world/local positions</returns>
        [Obsolete("Use GetPositionsCache instead")]
        public Vector3[] GetApproximation(Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif
            Vector3[] apps = new Vector3[CacheSize + 1];
            int idx = 0;
            for (int si = 0; si < Count; si++)
            {
                this[si].Approximation.CopyTo(apps, idx);
                idx += Mathf.Max(0, this[si].Approximation.Length - 1);
            }

            if (space == Space.World)
            {
                Matrix4x4 m = transform.localToWorldMatrix;
                for (int i = 0; i < apps.Length; i++)
                    apps[i] = m.MultiplyPoint3x4(apps[i]);
            }

            return apps;
        }

        /// <summary>
        /// Gets all Approximation points for a given spline part
        /// </summary>
        /// <param name="fromTF">start TF</param>
        /// <param name="toTF">end TF</param>
        /// <param name="includeEndPoint">Whether the end position should be included</param>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <returns>an array of Approximation points</returns>
        // DESIGN Make a GetPositionsCache equivalent, then make obsolete and remove/rename getApproximationIndexINTERNAL
        public Vector3[] GetApproximation(float fromTF, float toTF, bool includeEndPoint = true, Space space = Space.Self)
        {
            float startLF;
            float startFrag;
            float endLF;
            float endFrag;
            CurvySplineSegment startSeg = TFToSegment(fromTF, out startLF);
            int startIdx = startSeg.getApproximationIndexINTERNAL(startLF, out startFrag);
            CurvySplineSegment endSeg = TFToSegment(toTF, out endLF);
            int endIdx = endSeg.getApproximationIndexINTERNAL(endLF, out endFrag);

            CurvySplineSegment seg = startSeg;
            //bug usage of startIdx + 1 whithout checking if it is not out of bounds, which may happen if seg's length is 0
            Vector3[] res = new Vector3[1] { Vector3.Lerp(seg.Approximation[startIdx], seg.Approximation[startIdx + 1], startFrag) };
            //if (startFrag == 1)
            //    seg = seg.NextSegment;
            while (seg && ReferenceEquals(seg, endSeg) == false)
            {
                res = res.AddRange(seg.Approximation.SubArray(startIdx + 1, seg.Approximation.Length - 1));
                startIdx = 1;
                seg = seg.Spline.GetNextSegment(seg);
            }
            if (ReferenceEquals(seg, null) == false)
            {
                int i = (startSeg == seg) ? startIdx + 1 : 1;
                res = res.AddRange(seg.Approximation.SubArray(i, endIdx - i));
                if (includeEndPoint && (endFrag > 0 || endFrag < 1))
                {
                    res = res.Add(Vector3.Lerp(seg.Approximation[endIdx], seg.Approximation[endIdx + 1], endFrag));
                }
            }

            if (space == Space.World)
            {
                Matrix4x4 m = transform.localToWorldMatrix;
                for (int i = 0; i < res.Length; i++)
                    res[i] = m.MultiplyPoint3x4(res[i]);
            }

            return res;
        }

        /// <summary>
        /// Gets an array containing all approximation tangents
        /// </summary>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <remarks>Returns a copy of the internal cache</remarks>
        /// <returns>an array of tangents</returns>
        public SubArray<Vector3> GetTangentsCache(Space space)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            SubArray<Vector3> result = ArrayPools.Vector3.Allocate(CacheSize + 1);
            Vector3[] resultArray = result.Array;

            int idx = 0;
            for (int si = 0; si < Count; si++)
            {
                this[si].ApproximationT.CopyTo(resultArray, idx);
                idx += Mathf.Max(0, this[si].ApproximationT.Length - 1);
            }

            if (space == Space.World)
            {
                Matrix4x4 m = transform.localToWorldMatrix;
                for (int i = 0; i < result.Count; i++)
                    resultArray[i] = m.MultiplyVector(resultArray[i]);
            }

            return result;
        }

        /// <summary>
        /// Gets an array containing all approximation tangents
        /// </summary>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <remarks>This can be used to feed meshbuilders etc...</remarks>
        /// <returns>an array of tangents</returns>
        [Obsolete("Use GetTangentsCache instead")]
        public Vector3[] GetApproximationT(Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            Vector3[] apps = new Vector3[CacheSize + 1];
            int idx = 0;
            for (int si = 0; si < Count; si++)
            {
                this[si].ApproximationT.CopyTo(apps, idx);
                idx += Mathf.Max(0, this[si].ApproximationT.Length - 1);
            }

            if (space == Space.World)
            {
                Matrix4x4 m = transform.localToWorldMatrix;
                for (int i = 0; i < apps.Length; i++)
                    apps[i] = m.MultiplyVector(apps[i]);
            }

            return apps;
        }

        /// <summary>
        /// Gets an array containing all approximation Up-Vectors
        /// </summary>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <remarks>Returns a copy of the internal cache</remarks>
        /// <returns>an array of Up-Vectors</returns>
        public SubArray<Vector3> GetNormalsCache(Space space)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            SubArray<Vector3> result = ArrayPools.Vector3.Allocate(CacheSize + 1);
            Vector3[] resultArray = result.Array;

            int idx = 0;
            for (int si = 0; si < Count; si++)
            {
                this[si].ApproximationUp.CopyTo(resultArray, idx);
                idx += Mathf.Max(0, this[si].ApproximationUp.Length - 1);
            }

            if (space == Space.World)
            {
                Matrix4x4 m = transform.localToWorldMatrix;
                for (int i = 0; i < result.Count; i++)
                    resultArray[i] = m.MultiplyVector(resultArray[i]);
            }

            return result;
        }

        /// <summary>
        /// Gets an array containing all approximation Up-Vectors
        /// </summary>
        /// <param name="space">The space (local/object or global/world) in which the returned result is expressed</param>
        /// <remarks>This can be used to feed meshbuilders etc...</remarks>
        /// <returns>an array of Up-Vectors</returns>
        [Obsolete("Use GetNormalsCache instead")]
        public Vector3[] GetApproximationUpVectors(Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            Vector3[] apps = new Vector3[CacheSize + 1];
            int idx = 0;
            for (int si = 0; si < Count; si++)
            {
                this[si].ApproximationUp.CopyTo(apps, idx);
                idx += Mathf.Max(0, this[si].ApproximationUp.Length - 1);
            }

            if (space == Space.World)
            {
                Matrix4x4 m = transform.localToWorldMatrix;
                for (int i = 0; i < apps.Length; i++)
                    apps[i] = m.MultiplyVector(apps[i]);
            }

            return apps;
        }

        #endregion

        /// <summary>
        /// Gets the point on the spline that is the nearest to a given <paramref name="position"/>
        /// </summary>
        /// <param name="position">The input point's position</param>
        /// <param name="space">The space (local/object or global/world) in which the <paramref name="position"/> and the returned value are expressed</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>The nearest point on the spline to the given <paramref name="position"/>, expressed in the space defined by the <paramref name="space"/> parameter</returns>
        public Vector3 GetNearestPoint(Vector3 position, Space space)
        {
            Vector3 result;
            GetNearestPointTF(position, out result, out _, out _, 0, -1, space);
            return result;
        }

        /// <summary>
        /// Gets the TF value of the point on the spline that is the nearest to a given position
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="localPosition">The point's position expressed in the spline's local space</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>a TF value in the range 0..1. If spline has no segments the returned value will be -1</returns>
        public float GetNearestPointTF(Vector3 localPosition)
        {
            return GetNearestPointTF(localPosition, out _, out _, out _, 0, -1, Space.Self);
        }

        /// <summary>
        /// Gets the TF value of the point on the spline that is the nearest to a given position
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="position">The point's position</param>
        /// <param name="space">The space (local/object or global/world) in which the <paramref name="position"/> is expressed</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>a TF value in the range 0..1. If spline has no segments the returned value will be -1</returns>
        public float GetNearestPointTF(Vector3 position, Space space)
        {
            return GetNearestPointTF(position, out _, out _, out _, 0, -1, space);
        }

        /// <summary>
        /// Gets the TF value of the point on the spline that is the nearest to a given position
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="localPosition">The point's position expressed in the spline's local space</param>
        /// <param name="nearestPoint">the nearest point on the spline to the given <paramref name="localPosition"/>, expressed in the local space</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>a TF value in the range 0..1. If spline has no segments the returned value will be -1</returns>
        public float GetNearestPointTF(Vector3 localPosition, out Vector3 nearestPoint)
        {
            return GetNearestPointTF(localPosition, out nearestPoint, out _, out _, 0, -1, Space.Self);
        }

        /// <summary>
        /// Gets the TF value of the point on the spline that is the nearest to a given position
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="position">The point's position</param>
        /// <param name="nearestPoint">the nearest point on the spline to the given <paramref name="position"/>, expressed in the space defined by the <paramref name="space"/> parameter</param>
        /// <param name="space">The space (local/object or global/world) in which the <paramref name="position"/> is expressed</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>a TF value in the range 0..1. If spline has no segments the returned value will be -1</returns>
        public float GetNearestPointTF(Vector3 position, out Vector3 nearestPoint, Space space)
        {
            return GetNearestPointTF(position, out nearestPoint, out _, out _, 0, -1, space);
        }

        /// <summary>
        /// Gets the TF value of the point on the spline that is the nearest to a given position
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="position">The point's position</param>
        /// <param name="searchStartSegmentIndex">the index of the first segment to include in the search. Set it to 0 to start searching from the spline's start</param>
        /// <param name="searchEndSegmentIndex">the index of the last segment to include in the search. Set it to -1 to search until the spline's end</param>
        /// <param name="space">The space (local/object or global/world) in which the <paramref name="position"/> is expressed</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>a TF value in the range 0..1. If spline has no segments the returned value will be -1</returns>
        public float GetNearestPointTF(Vector3 position, int searchStartSegmentIndex = 0, int searchEndSegmentIndex = -1, Space space = Space.Self)
        {
            return GetNearestPointTF(position, out _, out _, out _, searchStartSegmentIndex, searchEndSegmentIndex, space);
        }

        /// <summary>
        /// Gets the TF value of the point on the spline that is the nearest to a given position
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="position">The point's position</param>
        /// <param name="nearestPoint">the nearest point on the spline to the given <paramref name="position"/>, expressed in the space defined by the <paramref name="space"/> parameter</param>
        /// <param name="searchStartSegmentIndex">the index of the first segment to include in the search. Set it to 0 to start searching from the spline's start</param>
        /// <param name="searchEndSegmentIndex">the index of the last segment to include in the search. Set it to -1 to search until the spline's end</param>
        /// <param name="space">The space (local/object or global/world) in which the <paramref name="position"/> is expressed</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>a TF value in the range 0..1. If spline has no segments the returned value will be -1</returns>
        public float GetNearestPointTF(Vector3 position, out Vector3 nearestPoint, int searchStartSegmentIndex = 0, int searchEndSegmentIndex = -1, Space space = Space.Self)
        {
            return GetNearestPointTF(position, out nearestPoint, out _, out _, searchStartSegmentIndex, searchEndSegmentIndex, space);
        }

        /// <summary>
        /// Gets the TF value of the point on the spline that is the nearest to a given position
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="position">The point's position</param>
        /// <param name="nearestPoint">the nearest point on the spline to the given <paramref name="position"/>, expressed in the space defined by the <paramref name="space"/> parameter</param>
        /// <param name="nearestSegment">the nearest segment of the spline to the given <paramref name="position"/></param>
        /// <param name="nearestPointLocalF">LocalF of the nearest point on the nearest segment</param>
        /// <param name="searchStartSegmentIndex">the index of the first segment to include in the search. Set it to 0 to start searching from the spline's start</param>
        /// <param name="searchEndSegmentIndex">the index of the last segment to include in the search. Set it to -1 to search until the spline's end</param>
        /// <param name="space">The space (local/object or global/world) in which the <paramref name="position"/> is expressed</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CacheDensity"/></remarks>
        /// <returns>a TF value in the range 0..1. If spline has no segments the returned value will be -1</returns>
        public float GetNearestPointTF(Vector3 position, out Vector3 nearestPoint, [CanBeNull] out CurvySplineSegment nearestSegment, out float nearestPointLocalF, int searchStartSegmentIndex = 0, int searchEndSegmentIndex = -1, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            DoSanityChecks();
#endif

            nearestPoint = Vector3.zero;
            if (Count == 0)
            {
                nearestSegment = null;
                nearestPointLocalF = -1;
                return -1;
            }
            // for each segment, get the distance to it's approximation points
            float distSqr = float.MaxValue;
            float resF = 0;

            CurvySplineSegment resSeg = null;
            if (searchEndSegmentIndex == -1)
                searchEndSegmentIndex = Count - 1;
            searchStartSegmentIndex = Mathf.Clamp(searchStartSegmentIndex, 0, Count - 1);
            searchEndSegmentIndex = Mathf.Clamp(searchEndSegmentIndex + 1, searchStartSegmentIndex + 1, Count);
            for (int i = searchStartSegmentIndex; i < searchEndSegmentIndex; i++)
            {
                float f = this[i].GetNearestPointF(position, space);
                Vector3 v = this[i].Interpolate(f, space);
                float magSqr = (v - position).sqrMagnitude;
                if (magSqr <= distSqr)
                {
                    resSeg = this[i];
                    resF = f;
                    nearestPoint = v;
                    distSqr = magSqr;
                }
            }

            nearestSegment = resSeg;
            nearestPointLocalF = resF;
            // return the nearest
            return resSeg.LocalFToTF(resF);
        }

        /// <summary>
        /// Refreshs the spline
        /// </summary>
        /// <remarks>This is called automatically on the next Update() if any changes are pending</remarks>
        public void Refresh()
        {
            if (ProcessDirtyControlPoints())
                OnRefreshEvent(defaultSplineEventArgs);
        }

        /// <summary>
        /// Ensures the whole spline (curve & orientation) will be recalculated on next call to Refresh()
        /// </summary>
        public void SetDirtyAll()
        {
            SetDirtyAll(SplineDirtyingType.Everything, true);
        }

        /// <summary>
        /// Ensure the whole spline will be recalculated on next call to Refresh()
        /// </summary>
        /// <param name="dirtyingType">Defines what aspect should be dirtied</param>
        /// <param name="dirtyConnectedControlPoints">whether to set dirty other splines's control points connected to one of this spline's control points</param>
        public void SetDirtyAll(SplineDirtyingType dirtyingType, bool dirtyConnectedControlPoints)
        {
#if CURVY_LOG_DIRTYING
            Debug.Log("Set Dirty all " + dirtyingType);
#endif
            allControlPointsAreDirty = true;
            SetDirtyingFlags(dirtyingType);

            if (dirtyConnectedControlPoints)
                //OPTIM: maintain a boolean saying if any control point has a connection. And then, avoid the following code if that boolean is false. Same suggestion for other dirtying codes related to connections
                for (int index = 0; index < ControlPoints.Count; index++)
                {
                    CurvySplineSegment controlPoint = ControlPoints[index];
                    if (controlPoint && controlPoint.Connection)//controlPoint can be null if you create a spline via the pen tool, and then undo it
                    {
                        ReadOnlyCollection<CurvySplineSegment> connectedControlPoints = controlPoint.Connection.ControlPointsList;
                        for (int connectedIndex = 0; connectedIndex < connectedControlPoints.Count; connectedIndex++)
                        {
                            CurvySplineSegment connectedControlPoint = connectedControlPoints[connectedIndex];
                            CurvySpline connectedSpline = connectedControlPoint != null
                                ? connectedControlPoint.Spline
                                : null;
                            if (connectedSpline && connectedSpline != this)
                            {
                                connectedSpline.dirtyControlPointsMinimalSet.Add(connectedControlPoint);
                                connectedSpline.SetDirtyingFlags(dirtyingType);
                            }
                        }
                    }
                }
        }

        /// <summary>
        /// Marks a Control Point to get recalculated on next call to Refresh(). Will also mark connected control points and control points that depend on the current one through the Follow-Up feature.
        /// </summary>
        /// <param name="dirtyControlPoint">the Control Point to dirty</param>
        /// <param name="dirtyingType">Defines what aspect should be dirtied</param>
        public void SetDirty(CurvySplineSegment dirtyControlPoint, SplineDirtyingType dirtyingType)
        {
            SetDirty(dirtyControlPoint, dirtyingType, GetPreviousControlPoint(dirtyControlPoint), GetNextControlPoint(dirtyControlPoint), false);
        }

        /// <summary>
        /// Marks a Control Point to get recalculated on next call to Refresh(). Will also mark connected control points and control points that depend on the current one through the Follow-Up feature. Be aware, this method, and unlike SetDirty, will not mark as dirty the control points connected to the "controlPoint" parameter
        /// </summary>
        /// <param name="dirtyControlPoint">the Control Point to dirty</param>
        /// <param name="dirtyingType">Defines what aspect should be dirtied</param>
        public void SetDirtyPartial(CurvySplineSegment dirtyControlPoint, SplineDirtyingType dirtyingType)
        {
            //OPTIM skip this if dirtyControlPoint is already dirty?
            SetDirty(dirtyControlPoint, dirtyingType, GetPreviousControlPoint(dirtyControlPoint), GetNextControlPoint(dirtyControlPoint), true);
        }

        /// <summary>
        /// Transforms position from local space to world space
        /// </summary>
        public Vector3 ToWorldPosition(Vector3 localPosition)
        {
            return cachedTransform.TransformPoint(localPosition);
        }

        /// <summary>
        /// Transforms direction from local space to world space
        /// </summary>
        public Vector3 ToWorldDirection(Vector3 localDirection)
        {
            return cachedTransform.TransformDirection(localDirection);
        }

        /// <summary>
        /// Transforms position from world space to local space
        /// </summary>
        public Vector3 ToLocalPosition(Vector3 worldPosition)
        {
            return cachedTransform.InverseTransformPoint(worldPosition);
        }

        /// <summary>
        /// Transforms direction from world space to local space
        /// </summary>
        public Vector3 ToLocalDirection(Vector3 localDirection)
        {
            return cachedTransform.InverseTransformDirection(localDirection);
        }

#if UNITY_EDITOR

        /// <summary>
        /// Apply proper names to all Control Points
        /// </summary>
        public void ApplyControlPointsNames()
        {
            // rename them and set their order based on ControlPoint list
            for (short i = 0; i < ControlPoints.Count; i++)
                ControlPoints[i].name = GetControlPointName(i);
        }

#endif

        /// <summary>
        /// Rebuilds the ControlPoints list from the hierarchy. It sets the spline as Dirty
        /// </summary>
        public void SyncSplineFromHierarchy()
        {
            ClearControlPoints();
            for (int i = 0; i < transform.childCount; i++)
            {
                CurvySplineSegment cp = transform.GetChild(i).GetComponent<CurvySplineSegment>();
                if (cp)
                    AddControlPoint(cp);
            }
        }

        #endregion

        #region --- Utilities ---

        /// <summary>
        /// Checks if the curve is planar
        /// </summary>
        /// <param name="ignoreAxis">returns the axis that can be ignored (0=x,1=y,2=z)</param>
        /// <returns>true if a planar axis was found</returns>
        public bool IsPlanar(out int ignoreAxis)
        {
            bool xp, yp;
            bool res = IsPlanar(out xp, out yp, out _);
            if (xp)
                ignoreAxis = 0;
            else if (yp)
                ignoreAxis = 1;
            else
                ignoreAxis = 2;
            return res;
        }

        /// <summary>
        /// Checks if the curve is planar
        /// </summary>
        /// <param name="xplanar">whether the x-axis is planar</param>
        /// <param name="yplanar">whether the y-axis is planar</param>
        /// <param name="zplanar">whether the z-axis is planar</param>
        /// <returns>true if at least on axis is planar</returns>
        public bool IsPlanar(out bool xplanar, out bool yplanar, out bool zplanar)
        {
            xplanar = true;
            yplanar = true;
            zplanar = true;
            if (ControlPointCount == 0) return true;
            Vector3 p = ControlPoints[0].transform.localPosition;
            for (int i = 1; i < ControlPointCount; i++)
            {
                if (!Mathf.Approximately(ControlPoints[i].transform.localPosition.x, p.x))
                    xplanar = false;
                if (!Mathf.Approximately(ControlPoints[i].transform.localPosition.y, p.y))
                    yplanar = false;
                if (!Mathf.Approximately(ControlPoints[i].transform.localPosition.z, p.z))
                    zplanar = false;

                if (xplanar == false && yplanar == false && zplanar == false)
                    return false;

            }
            return true;
        }

        /// <summary>
        /// Determines if the spline is at zero position on a certain plane
        /// </summary>
        /// <param name="plane">the plane the spline should be tested against</param>
        /// <returns>true if the spline is on the plane</returns>
        public bool IsPlanar(CurvyPlane plane)
        {
            switch (plane)
            {
                case CurvyPlane.XY:
                    for (int i = 0; i < ControlPointCount; i++)
                        if (ControlPoints[i].transform.localPosition.z.Approximately(0f) == false)
                            return false;
                    break;
                case CurvyPlane.XZ:
                    for (int i = 0; i < ControlPointCount; i++)
                        if (ControlPoints[i].transform.localPosition.y.Approximately(0f) == false)
                            return false;
                    break;
                case CurvyPlane.YZ:
                    for (int i = 0; i < ControlPointCount; i++)
                        if (ControlPoints[i].transform.localPosition.x.Approximately(0f) == false)
                            return false;
                    break;
            }
            return true;
        }

        /// <summary>
        /// Forces the spline to be at zero position on a certain plane
        /// </summary>
        /// <param name="plane">the plane the should be on</param>
        public void MakePlanar(CurvyPlane plane)
        {
            switch (plane)
            {
                case CurvyPlane.XY:
                    for (int i = 0; i < ControlPointCount; i++)
                        if (ControlPoints[i].transform.localPosition.z != 0)
                        {
#if UNITY_EDITOR
                            if (!Application.isPlaying)
                                Undo.RecordObject(ControlPoints[i].transform, "MakePlanar");
#endif
                            ControlPoints[i].SetLocalPosition(new Vector3(ControlPoints[i].transform.localPosition.x, ControlPoints[i].transform.localPosition.y, 0));
                        }
                    break;
                case CurvyPlane.XZ:
                    for (int i = 0; i < ControlPointCount; i++)
                        if (ControlPoints[i].transform.localPosition.y != 0)
                        {
#if UNITY_EDITOR
                            if (!Application.isPlaying)
                                Undo.RecordObject(ControlPoints[i].transform, "MakePlanar");
#endif
                            ControlPoints[i].SetLocalPosition(new Vector3(ControlPoints[i].transform.localPosition.x, 0, ControlPoints[i].transform.localPosition.z));
                        }
                    break;
                case CurvyPlane.YZ:
                    for (int i = 0; i < ControlPointCount; i++)
                        if (ControlPoints[i].transform.localPosition.x != 0)
                        {
#if UNITY_EDITOR
                            if (!Application.isPlaying)
                                Undo.RecordObject(ControlPoints[i].transform, "MakePlanar");
#endif
                            ControlPoints[i].SetLocalPosition(new Vector3(0, ControlPoints[i].transform.localPosition.y, ControlPoints[i].transform.localPosition.z));
                        }
                    break;
                default:
                    throw new NotImplementedException();
            }
            Refresh();
        }

        /// <summary>
        /// Equalize one axis of the spline to match the first control points's value
        /// </summary>
        /// <param name="axis">the axis to equalize (0=x,1=y,2=z)</param>
        public void MakePlanar(int axis)
        {
            Vector3 p = ControlPoints[0].transform.localPosition;
            for (int i = 1; i < ControlPointCount; i++)
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    Undo.RecordObject(ControlPoints[i].transform, "MakePlanar");
#endif
                Vector3 pi = ControlPoints[i].transform.localPosition;
                switch (axis)
                {
                    case 0: pi.x = p.x; break;
                    case 1: pi.y = p.y; break;
                    case 2: pi.z = p.z; break;
                }
                ControlPoints[i].transform.localPosition = pi;
            }
            SetDirtyAll(SplineDirtyingType.Everything, true);
            Refresh();
        }


        /// <summary>
        /// Subdivides the spline, i.e. adds additional segments to a certain range
        /// </summary>
        /// <param name="fromCP">starting ControlPoint</param>
        /// <param name="toCP">ending ControlPoint</param>
        public void Subdivide(CurvySplineSegment fromCP = null, CurvySplineSegment toCP = null)
        {
            if (!fromCP)
                fromCP = FirstVisibleControlPoint;
            if (!toCP)
                toCP = LastVisibleControlPoint;

            if (fromCP == null || toCP == null || fromCP.Spline != this || toCP.Spline != this)
            {
                Debug.Log("CurvySpline.Subdivide: Not a valid range selection!");
                return;
            }

            int startCPIndex = Mathf.Clamp(fromCP.Spline.GetControlPointIndex(fromCP), 0, ControlPointCount - 2);
            int endCPIndex = Mathf.Clamp(toCP.Spline.GetControlPointIndex(toCP), startCPIndex + 1, ControlPointCount - 1);

            if (endCPIndex - startCPIndex < 1)
            {
                Debug.Log("CurvySpline.Subdivide: Not a valid range selection!");
            }
            else
            {
                OnBeforeControlPointAddEvent(defaultAddAfterEventArgs);

                Dictionary<int, Vector3> newCPsPosition = new Dictionary<int, Vector3>();
                //We first iterate to compute the positions. Interpolate should be called on non Dirty splines, that's why I first call Interpolate then in a latter loop update the spline (which will dirty it)
                for (int i = endCPIndex - 1; i >= startCPIndex; i--)
                    newCPsPosition[i] = ControlPoints[i].Interpolate(0.5f, Space.Self);

                for (int i = endCPIndex - 1; i >= startCPIndex; i--)
                {
                    CurvySplineSegment previousControlPoint = ControlPoints[i];
                    CurvySplineSegment nextControlPoint = ControlPoints[i + 1];
                    CurvySplineSegment newControlPoint =
                        InsertAfter(
                        ControlPoints[i],
                        newCPsPosition[i],
                        true,
                        Space.Self);

                    if (Interpolation == CurvyInterpolation.Bezier)
                    {
#if UNITY_EDITOR
                        if (!Application.isPlaying)
                        {
                            Undo.RecordObject(nextControlPoint, "Subdivide");
                            Undo.RecordObject(previousControlPoint, "Subdivide");
                        }
#endif

                        //Update Bzier handles to maintain the spline's shape
                        //Based on De Casteljau's algorithm. The following is it's special case implementation for a subdivision at the middle of a spline segment.
                        //Here is a picture explaining things: https://jeremykun.files.wordpress.com/2013/05/subdivision.png from https://jeremykun.com/2013/05/11/bezier-curves-and-picasso/

                        Vector3 P0 = previousControlPoint.transform.position;
                        Vector3 P1 = previousControlPoint.HandleOutPosition;
                        Vector3 P2 = nextControlPoint.HandleInPosition;
                        Vector3 P3 = nextControlPoint.transform.position;

                        Vector3 m0 = (P0 + P1) / 2;
                        Vector3 m1 = (P1 + P2) / 2;
                        Vector3 m2 = (P2 + P3) / 2;

                        Vector3 q0 = (m0 + m1) / 2;
                        Vector3 q1 = (m1 + m2) / 2;

                        previousControlPoint.AutoHandles = false;
                        previousControlPoint.HandleOutPosition = m0;

                        nextControlPoint.AutoHandles = false;
                        nextControlPoint.HandleInPosition = m2;

                        newControlPoint.AutoHandles = false;
                        newControlPoint.HandleInPosition = q0;
                        newControlPoint.HandleOutPosition = q1;
                    }
#if UNITY_EDITOR
                    if (!Application.isPlaying)
                        Undo.RegisterCreatedObjectUndo(newControlPoint.gameObject, "Subdivide");
#endif
                }

                Refresh();
                OnAfterControlPointAddEvent(defaultAddAfterEventArgs);
                OnAfterControlPointChangesEvent(defaultSplineEventArgs);
            }
        }

        /// <summary>
        /// Simplifies the spline, i.e. remove segments from a certain range
        /// </summary>
        /// <param name="fromCP">starting ControlPoint</param>
        /// <param name="toCP">ending ControlPoint</param>
        public void Simplify(CurvySplineSegment fromCP = null, CurvySplineSegment toCP = null)
        {
            if (!fromCP)
                fromCP = FirstVisibleControlPoint;
            if (!toCP)
                toCP = LastVisibleControlPoint;

            if (fromCP == null || toCP == null || fromCP.Spline != this || toCP.Spline != this)
            {
                Debug.Log("CurvySpline.Simplify: Not a valid range selection!");
                return;
            }
            int startCPIndex = Mathf.Clamp(fromCP.Spline.GetControlPointIndex(fromCP), 0, ControlPointCount - 2);
            int endCPIndex = Mathf.Clamp(toCP.Spline.GetControlPointIndex(toCP), startCPIndex + 2, ControlPointCount - 1);
            if (endCPIndex - startCPIndex < 2)
            {
                Debug.Log("CurvySpline.Simplify: Not a valid range selection!");
            }
            else
            {
                OnBeforeControlPointDeleteEvent(defaultDeleteEventArgs);

                for (int i = endCPIndex - 2; i >= startCPIndex; i -= 2)
                {
                    Delete(ControlPoints[i + 1], true);
#if UNITY_EDITOR
                    _newSelectionInstanceIDINTERNAL = 0;
#endif
                }
                Refresh();
                OnAfterControlPointChangesEvent(defaultSplineEventArgs);
            }
        }

        /// <summary>
        /// Equalizes the segment length of a certain range
        /// </summary>
        /// <param name="fromCP">starting ControlPoint</param>
        /// <param name="toCP">ending ControlPoint</param>
        public void Equalize(CurvySplineSegment fromCP = null, CurvySplineSegment toCP = null)
        {
            if (!fromCP)
                fromCP = FirstVisibleControlPoint;
            if (!toCP)
                toCP = LastVisibleControlPoint;

            if (fromCP == null || toCP == null || fromCP.Spline != this || toCP.Spline != this)
            {
                Debug.Log("CurvySpline.Equalize: Not a valid range selection!");
                return;
            }
            int startCPIndex = Mathf.Clamp(GetControlPointIndex(fromCP), 0, ControlPointCount - 2);
            int endCPIndex = Mathf.Clamp(GetControlPointIndex(toCP), startCPIndex + 2, ControlPointCount - 1);
            if (endCPIndex - startCPIndex < 2)
            {
                Debug.Log("CurvySpline.Equalize: Not a valid range selection!");
                return;
            }
            float segmentLength = ControlPoints[endCPIndex].Distance - ControlPoints[startCPIndex].Distance;
            float equal = segmentLength / (endCPIndex - startCPIndex);
            float dist = ControlPoints[startCPIndex].Distance;

            Vector3[] newCpPositions = new Vector3[endCPIndex - startCPIndex - 1];

            for (int i = startCPIndex + 1; i < endCPIndex; i++)
            {
                int iterationIndex = i - startCPIndex - 1;
                newCpPositions[iterationIndex] = InterpolateByDistance(dist + (iterationIndex + 1) * equal);
            }

            for (int i = startCPIndex + 1; i < endCPIndex; i++)
            {
                int iterationIndex = i - startCPIndex - 1;
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    Undo.RecordObject(ControlPoints[i].transform, "Equalize");
#endif
                ControlPoints[i].SetLocalPosition(newCpPositions[iterationIndex]);
            }
            Refresh();
        }

        /// <summary>
        /// Applies a spline's scale to it's Control Points and resets scale
        /// </summary>
        public void Normalize()
        {
            Vector3 scl = transform.localScale;

            if (scl != Vector3.one)
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    Undo.RecordObject(transform, "Normalize Spline");
#endif
                transform.localScale = Vector3.one;
                for (int i = 0; i < ControlPointCount; i++)
                {
                    CurvySplineSegment curvySplineSegment = ControlPoints[i];
#if UNITY_EDITOR
                    if (!Application.isPlaying)
                    {
                        Undo.RecordObject(curvySplineSegment.transform, "Normalize Spline");
                        Undo.RecordObject(curvySplineSegment, "Normalize Spline");
                    }
#endif
                    curvySplineSegment.SetLocalPosition(Vector3.Scale(curvySplineSegment.transform.localPosition, scl));
                    curvySplineSegment.HandleIn = Vector3.Scale(curvySplineSegment.HandleIn, scl);
                    curvySplineSegment.HandleOut = Vector3.Scale(curvySplineSegment.HandleOut, scl);

                }
                Refresh();
            }
        }

        /// <summary>
        /// Sets the pivot of the spline
        /// </summary>
        /// <param name="xRel">-1 to 1</param>
        /// <param name="yRel">-1 to 1</param>
        /// <param name="zRel">-1 to 1</param>
        /// <param name="preview">if true, only return the new pivot position</param>
        /// <returns>the new pivot position</returns>
        public Vector3 SetPivot(float xRel = 0, float yRel = 0, float zRel = 0, bool preview = false)
        {
            Bounds b = Bounds;
            Vector3 v = new Vector3(b.min.x + b.size.x * ((xRel + 1) / 2),
                                    b.max.y - b.size.y * ((yRel + 1) / 2),
                                    b.min.z + b.size.z * ((zRel + 1) / 2));

            Vector3 off = transform.position - v;
            if (preview)
                return transform.position - off;

            for (int index = 0; index < ControlPoints.Count; index++)
            {
                CurvySplineSegment cp = ControlPoints[index];
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    Undo.RecordObject(cp.transform, "SetPivot");
#endif
                cp.transform.position += off;
            }
#if UNITY_EDITOR
            if (!Application.isPlaying)
                Undo.RecordObject(transform, "SetPivot");
#endif
            transform.position -= off;
            SetDirtyAll(SplineDirtyingType.Everything, true);
            return transform.position;
        }

        /// <summary>
        /// Flips the direction of the spline, i.e. the first Control Point will become the last and vice versa.
        /// </summary>
        public void Flip()
        {
            if (ControlPointCount <= 1)
                return;
#if UNITY_EDITOR
            if (!Application.isPlaying)
                Undo.RegisterFullObjectHierarchyUndo(this, "Flip Spline");
#endif
            switch (Interpolation)
            {
                case CurvyInterpolation.TCB:
                    Bias *= -1;
                    for (int i = ControlPointCount - 1; i >= 0; i--)
                    {
                        CurvySplineSegment cur = ControlPoints[i];

                        int j = i - 1;
                        if (j >= 0)
                        {
                            CurvySplineSegment prev = ControlPoints[j];

                            cur.EndBias = prev.StartBias * -1;
                            cur.EndContinuity = prev.StartContinuity;
                            cur.EndTension = prev.StartTension;

                            cur.StartBias = prev.EndBias * -1;
                            cur.StartContinuity = prev.EndContinuity;
                            cur.StartTension = prev.EndTension;

                            cur.OverrideGlobalBias = prev.OverrideGlobalBias;
                            cur.OverrideGlobalContinuity = prev.OverrideGlobalContinuity;
                            cur.OverrideGlobalTension = prev.OverrideGlobalTension;

                            cur.SynchronizeTCB = prev.SynchronizeTCB;
                        }
                    }
                    break;
                case CurvyInterpolation.Bezier:
                    for (int i = ControlPointCount - 1; i >= 0; i--)
                    {
                        CurvySplineSegment cur = ControlPoints[i];

                        (cur.HandleIn, cur.HandleOut) = (cur.HandleOut, cur.HandleIn);
                    }
                    break;
            }
            ReverseControlPoints();
            Refresh();
        }

        /// <summary>
        /// Moves ControlPoints from this spline, inserting them after a destination ControlPoint of another spline
        /// </summary>
        /// <param name="startIndex">ControlPointIndex of the first CP to move</param>
        /// <param name="count">number of ControlPoints to move</param>
        /// <param name="destCP">ControlPoint at the destination spline to insert after</param>
        public void MoveControlPoints(int startIndex, int count, CurvySplineSegment destCP)
        {
            if (!destCP || this == destCP.Spline || destCP.Spline.GetControlPointIndex(destCP) == -1)
                return;
            startIndex = Mathf.Clamp(startIndex, 0, ControlPointCount - 1);
            count = Mathf.Clamp(count, startIndex, ControlPointCount - startIndex);

            CurvySplineSegment cp;
            for (int i = 0; i < count; i++)
            {
                cp = ControlPoints[startIndex];
                RemoveControlPoint(cp);
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    Undo.SetTransformParent(cp.transform, destCP.Spline.transform, "Move ControlPoints");
                else
#endif
                    cp.transform.SetParent(destCP.Spline.transform, true);

                destCP.Spline.InsertControlPoint(destCP.Spline.GetControlPointIndex(destCP) + i + 1, cp);
            }
            Refresh();
            destCP.Spline.Refresh();
        }

        /// <summary>
        /// Insert this spline after another spline's destination Control Point and delete this spline
        /// </summary>
        /// <param name="destCP">the Control Point of the destination spline</param>
        public void JoinWith(CurvySplineSegment destCP)
        {
            if (destCP.Spline == this)
                return;
            MoveControlPoints(0, ControlPointCount, destCP);
            gameObject.Destroy(true, true);
        }

        /// <summary>
        /// Splits this spline with the parameter controlPoint becoming the first Control Point of the new spline
        /// </summary>
        /// <returns>The new spline</returns>
        public CurvySpline Split(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            CurvySpline newSpline = CurvySpline.Create(this);
            newSpline.transform.SetParent(transform.parent, true);
            newSpline.name = name + "_parted";

#if UNITY_EDITOR
            if (!Application.isPlaying)
                Undo.RegisterCreatedObjectUndo(newSpline.gameObject, "Split Spline");
#endif

            // Move CPs
            List<CurvySplineSegment> affectedControlPoints;
            {
                int controlPointIndex = GetSegmentIndex(controlPoint);
                affectedControlPoints = new List<CurvySplineSegment>(ControlPointCount - controlPointIndex);
                for (int i = controlPointIndex; i < ControlPointCount; i++)
                    affectedControlPoints.Add(ControlPoints[i]);
            }

            for (int i = 0; i < affectedControlPoints.Count; i++)
            {
                CurvySplineSegment curvySplineSegment = affectedControlPoints[i];
                RemoveControlPoint(curvySplineSegment);
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    Undo.SetTransformParent(curvySplineSegment.transform, newSpline.transform, "Split Spline");
#endif
                if (Application.isPlaying)
                    curvySplineSegment.transform.SetParent(newSpline.transform, true);
                newSpline.AddControlPoint(curvySplineSegment);
            }

            Refresh();
            newSpline.Refresh();
            return newSpline;
        }

        /// <summary>
        /// Defines the given Control Point to be the first Control Point of the spline
        /// </summary>
        /// <param name="controlPoint">One of this spline's control points</param>
        public void SetFirstControlPoint(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            short controlPointIndex = GetControlPointIndex(controlPoint);
            CurvySplineSegment[] controlPointsToMove = new CurvySplineSegment[controlPointIndex];
            for (int i = 0; i < controlPointIndex; i++)
                controlPointsToMove[i] = ControlPoints[i];

            for (int index = 0; index < controlPointsToMove.Length; index++)
            {
                CurvySplineSegment seg = controlPointsToMove[index];
                RemoveControlPoint(seg);
                AddControlPoint(seg);
            }
            Refresh();
        }

        #endregion

        #region Query data about control points

        /// <summary>
        /// Is the control point an orientation anchor? The answer is related to the control point's serialized OrientationAnchor value, plus it's position in the spline.
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        public bool IsControlPointAnOrientationAnchor(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            return IsControlPointVisible(controlPoint) && (controlPoint.SerializedOrientationAnchor || (controlPoint == FirstVisibleControlPoint || controlPoint == LastVisibleControlPoint));
        }

        /// <summary>
        /// Can this control point have a Follow-Up? This is true if the control point is the beginning of the first segment or the end of the last segment of an open spline
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        public bool CanControlPointHaveFollowUp(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            return controlPoint.GetExtrinsicPropertiesINTERNAL().CanHaveFollowUp;
        }

        /// <summary>
        /// Index of the control point
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        public short GetControlPointIndex(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            short controlPointIndex = controlPoint.GetExtrinsicPropertiesINTERNAL().ControlPointIndex;
#if CURVY_SANITY_CHECKS_PRIVATE//Judged too expensive in cpu time to be part of the sanity checks available to users
            UnityEngine.Assertions.Assert.IsTrue(controlPoint == ControlPoints[controlPointIndex]);
#endif

            return controlPointIndex;
        }

        /// <summary>
        /// Index of the segment that this control point starts. -1 if control point does not start a segment.
        /// </summary>
        /// <param name="segment"></param>
        /// <returns></returns>
        public short GetSegmentIndex(CurvySplineSegment segment)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, segment.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, segment, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            short segementIndex = segment.GetExtrinsicPropertiesINTERNAL().SegmentIndex;
#if CURVY_SANITY_CHECKS_PRIVATE//Judged too expensive in cpu time to be part of the sanity checks available to users
            UnityEngine.Assertions.Assert.IsTrue(segementIndex == -1 || segment == mSegments[segementIndex]);
#endif
            return segementIndex;
        }

        /// <summary>
        /// The next control point on the spline. Is null if none. Follow-Up not considered
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        [CanBeNull]
        public CurvySplineSegment GetNextControlPoint(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            short nextControlPointIndex = controlPoint.GetExtrinsicPropertiesINTERNAL().NextControlPointIndex;
            return nextControlPointIndex == -1 ? null : ControlPoints[nextControlPointIndex];
        }

        /// <summary>
        /// The index of the next control point on the spline. Is -1 if none. Follow-Up not considered
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        [CanBeNull]
        public short GetNextControlPointIndex(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            return controlPoint.GetExtrinsicPropertiesINTERNAL().NextControlPointIndex;
        }

        /// <summary>
        /// The next control point. Is null if none. Follow-Up is considered
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        [CanBeNull]
        public CurvySplineSegment GetNextControlPointUsingFollowUp(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            return controlPoint.FollowUp != null && ReferenceEquals(LastVisibleControlPoint, controlPoint)
                ? GetFollowUpHeadingControlPoint(controlPoint.FollowUp, controlPoint.FollowUpHeading)
                : GetNextControlPoint(controlPoint);
        }

        /// <summary>
        /// The previous control point on the spline. Is null if none. Follow-Up not considered
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        [CanBeNull]
        public CurvySplineSegment GetPreviousControlPoint(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            short previousControlPointIndex = controlPoint.GetExtrinsicPropertiesINTERNAL().PreviousControlPointIndex;
            return previousControlPointIndex == -1 ? null : ControlPoints[previousControlPointIndex];
        }

        /// <summary>
        /// The index of the previous control point on the spline. Is -1 if none. Follow-Up not considered
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        [CanBeNull]
        public short GetPreviousControlPointIndex(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            return controlPoint.GetExtrinsicPropertiesINTERNAL().PreviousControlPointIndex;
        }

        /// <summary>
        /// The previous control point. Is null if none. Follow-Up is considered
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        [CanBeNull]
        public CurvySplineSegment GetPreviousControlPointUsingFollowUp(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            return controlPoint.FollowUp != null && ReferenceEquals(FirstVisibleControlPoint, controlPoint)
                ? GetFollowUpHeadingControlPoint(controlPoint.FollowUp, controlPoint.FollowUpHeading)
                : GetPreviousControlPoint(controlPoint);
        }

        /// <summary>
        /// The next control point on the spline if it starts a segment. Is null if none. Follow-Up not considered
        /// </summary>
        /// <param name="segment"></param>
        /// <returns></returns>
        [CanBeNull]
        public CurvySplineSegment GetNextSegment(CurvySplineSegment segment)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, segment.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, segment, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);

            CurvySplineSegment.ControlPointExtrinsicProperties cpExtrinsicProperties = segment.GetExtrinsicPropertiesINTERNAL();
            return cpExtrinsicProperties.NextControlPointIsSegment
                ? ControlPoints[cpExtrinsicProperties.NextControlPointIndex]
                : null;
        }

        /// <summary>
        /// The previous control point on the spline if it starts a segment. Is null if none. Follow-Up not considered. 
        /// </summary>
        /// <param name="segment"></param>
        /// <returns></returns>
        [CanBeNull]
        public CurvySplineSegment GetPreviousSegment(CurvySplineSegment segment)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, segment.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, segment, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            CurvySplineSegment.ControlPointExtrinsicProperties cpExtrinsicProperties = segment.GetExtrinsicPropertiesINTERNAL();
            return cpExtrinsicProperties.PreviousControlPointIsSegment
                ? ControlPoints[cpExtrinsicProperties.PreviousControlPointIndex]
                : null;
        }

        /// <summary>
        /// Is the control point the start of a segment?
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        public bool IsControlPointASegment(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            return controlPoint.GetExtrinsicPropertiesINTERNAL().IsSegment;
        }

        /// <summary>
        /// Is the control point part of a segment (whether starting it or ending it)
        /// </summary>
        /// <param name="controlPoint"></param>
        /// <returns></returns>
        public bool IsControlPointVisible(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            return controlPoint.GetExtrinsicPropertiesINTERNAL().IsVisible;
        }

        /// <summary>
        /// The index of the control point being the orientation anchor for the anchor group containing the controlPoint
        /// Is -1 for non visible control points
        /// </summary>
        public short GetControlPointOrientationAnchorIndex(CurvySplineSegment controlPoint)
        {
#if CURVY_SANITY_CHECKS
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));
#endif

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);
            return controlPoint.GetExtrinsicPropertiesINTERNAL().OrientationAnchorIndex;
        }
        #endregion

        /// <summary>
        /// Event-friendly helper that sets a field or property value
        /// </summary>
        /// <param name="fieldAndValue">e.g. "MyValue=42"</param>
        public void SetFromString(string fieldAndValue)
        {
            string[] f = fieldAndValue.Split('=');
            if (f.Length != 2)
                return;

            FieldInfo fi = this.GetType().FieldByName(f[0], true, false);
            if (fi != null)
            {
                try
                {
                    if (fi.FieldType.IsEnum)
                        fi.SetValue(this, System.Enum.Parse(fi.FieldType, f[1]));
                    else
                        fi.SetValue(this, System.Convert.ChangeType(f[1], fi.FieldType, System.Globalization.CultureInfo.InvariantCulture));
                }
                catch (System.Exception e)
                {
                    Debug.LogWarning(this.name + ".SetFromString(): " + e.ToString());
                }
            }
            else
            {
                PropertyInfo pi = this.GetType().PropertyByName(f[0], true, false);
                if (pi != null)
                {
                    try
                    {
                        if (pi.PropertyType.IsEnum)
                            pi.SetValue(this, System.Enum.Parse(pi.PropertyType, f[1]), null);
                        else
                            pi.SetValue(this, System.Convert.ChangeType(f[1], pi.PropertyType, System.Globalization.CultureInfo.InvariantCulture), null);
                    }
                    catch (System.Exception e)
                    {
                        Debug.LogWarning(this.name + ".SetFromString(): " + e.ToString());
                    }
                }
            }
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySpline.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineDefaultValues.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 99611b5d3dd7bc74c9a0f49dbedd1e78
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Here you can find all the default values for CurvySpline's serialized fields. If you don't find a field here, this means that it's type's default value is the same than the field's default value, except for <see cref="CurvySpline.Interpolation"/> which default value is user defined, see <see cref="CurvyGlobalManager.DefaultInterpolation"/>
    /// </summary>
    public static class CurvySplineDefaultValues
    {
        public const bool AutoEndTangents = true;
        public const CurvyOrientation Orientation = CurvyOrientation.Dynamic;
        public const float AutoHandleDistance = 0.39f;
        public const int CacheDensity = 50;
        public const float MaxPointsPerUnit = 8;
        public const bool UsePooling = true;
        public const CurvyUpdateMethod UpdateIn = CurvyUpdateMethod.Update;
        public const bool CheckTransform = true;
        public const int BSplineDegree = 2;
        public const bool IsBSplineClamped = true;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineDefaultValues.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment.ControlPointExtrinsicProperties.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 776cd6a1dc4e38e4f843a10b00a09c5b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;

namespace FluffyUnderware.Curvy
{
    public partial class CurvySplineSegment
    {
        /// <summary>
        /// Contains data about a control point related to it's parent spline. For example, is a control point a valid segment in the spline or not.
        /// </summary>
        internal readonly struct ControlPointExtrinsicProperties : IEquatable<ControlPointExtrinsicProperties>
        {
            private readonly bool isVisible;
            /// <summary>
            /// Is the control point part of a segment (whether starting it or ending it)
            /// </summary>
            internal bool IsVisible
            {
                get { return isVisible; }
            }

            private readonly float tf;
            /// <summary>
            /// Gets the TF of this Control Point
            /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.
            /// This is the "time" parameter used in the splines' formulas.
            /// A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
            /// </summary>
            internal float TF
            {
                get { return tf; }
            }

            private readonly short segmentIndex;
            /// <summary>
            /// Index of the segment that this control point starts. -1 if control point does not start a segment.
            /// </summary>
            internal short SegmentIndex
            {
                get { return segmentIndex; }
            }

            private readonly short controlPointIndex;
            /// <summary>
            /// Index of the control point
            /// </summary>
            internal short ControlPointIndex
            {
                get { return controlPointIndex; }
            }

            private readonly short nextControlPointIndex;
            /// <summary>
            /// The index of the next control point on the spline. Is -1 if none. Follow-Up not considered
            /// </summary>
            internal short NextControlPointIndex
            {
                get { return nextControlPointIndex; }
            }

            private readonly short previousControlPointIndex;
            /// <summary>
            /// The index of the previous control point on the spline. Is -1 if none. Follow-Up not considered. 
            /// </summary>
            internal short PreviousControlPointIndex
            {
                get { return previousControlPointIndex; }
            }

            private readonly bool previousControlPointIsSegment;
            /// <summary>
            /// Is previous Control Point a segment start?
            /// </summary>
            internal bool PreviousControlPointIsSegment
            {
                get { return previousControlPointIsSegment; }
            }

            private readonly bool nextControlPointIsSegment;
            /// <summary>
            /// Is next Control Point a segment start?
            /// </summary>
            internal bool NextControlPointIsSegment
            {
                get { return nextControlPointIsSegment; }
            }

            private readonly bool canHaveFollowUp;
            /// <summary>
            /// Can this control point have a Follow-Up? This is true if the control point is visible and does not have a previous or next control point on its spline
            /// </summary>
            internal bool CanHaveFollowUp
            {
                get { return canHaveFollowUp; }
            }

            /// <summary>
            /// Is the control point the start of a segment?
            /// </summary>
            internal bool IsSegment { get { return SegmentIndex != -1; } }

            private readonly short orientationAnchorIndex;
            /// <summary>
            /// The index of the control point being the orientation anchor for the anchor group containing the current control point
            /// Is -1 for non visible control points
            /// </summary>
            internal short OrientationAnchorIndex
            {
                get { return orientationAnchorIndex; }
            }

            internal ControlPointExtrinsicProperties(bool isVisible, float tf, short segmentIndex, short controlPointIndex, short previousControlPointIndex, short nextControlPointIndex, bool previousControlPointIsSegment, bool nextControlPointIsSegment, bool canHaveFollowUp, short orientationAnchorIndex)
            {
                this.isVisible = isVisible;
                this.tf = tf;
                this.segmentIndex = segmentIndex;
                this.controlPointIndex = controlPointIndex;
                this.nextControlPointIndex = nextControlPointIndex;
                this.previousControlPointIndex = previousControlPointIndex;
                this.previousControlPointIsSegment = previousControlPointIsSegment;
                this.nextControlPointIsSegment = nextControlPointIsSegment;
                this.canHaveFollowUp = canHaveFollowUp;
                this.orientationAnchorIndex = orientationAnchorIndex;
            }

            public bool Equals(ControlPointExtrinsicProperties other)
            {
                return IsVisible == other.IsVisible
                       && TF == other.TF
                       && SegmentIndex == other.SegmentIndex
                       && ControlPointIndex == other.ControlPointIndex
                       && NextControlPointIndex == other.NextControlPointIndex
                       && PreviousControlPointIndex == other.PreviousControlPointIndex
                       && PreviousControlPointIsSegment == other.PreviousControlPointIsSegment
                       && NextControlPointIsSegment == other.NextControlPointIsSegment
                       && CanHaveFollowUp == other.CanHaveFollowUp
                       && OrientationAnchorIndex == other.OrientationAnchorIndex;
            }

            public override bool Equals(object obj)
            {
                if (ReferenceEquals(null, obj))
                    return false;
                return obj is ControlPointExtrinsicProperties && Equals((ControlPointExtrinsicProperties)obj);
            }

            public override int GetHashCode()
            {
                unchecked
                {
                    int hashCode = IsVisible.GetHashCode();
                    hashCode = (hashCode * 397) ^ TF.GetHashCode();
                    hashCode = (hashCode * 397) ^ SegmentIndex.GetHashCode();
                    hashCode = (hashCode * 397) ^ ControlPointIndex.GetHashCode();
                    hashCode = (hashCode * 397) ^ NextControlPointIndex.GetHashCode();
                    hashCode = (hashCode * 397) ^ PreviousControlPointIndex.GetHashCode();
                    hashCode = (hashCode * 397) ^ PreviousControlPointIsSegment.GetHashCode();
                    hashCode = (hashCode * 397) ^ NextControlPointIsSegment.GetHashCode();
                    hashCode = (hashCode * 397) ^ CanHaveFollowUp.GetHashCode();
                    hashCode = (hashCode * 397) ^ OrientationAnchorIndex.GetHashCode();
                    return hashCode;
                }
            }

            public static bool operator ==(ControlPointExtrinsicProperties left, ControlPointExtrinsicProperties right)
            {
                return left.Equals(right);
            }

            public static bool operator !=(ControlPointExtrinsicProperties left, ControlPointExtrinsicProperties right)
            {
                return !left.Equals(right);
            }

        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment.ControlPointExtrinsicProperties.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1f3c8d58ac75eab43bd8d07d598ce5bd
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Utils;
using System.Collections.Generic;
using FluffyUnderware.DevTools;
using UnityEngine.Serialization;
using System.Reflection;
using System;
using System.Collections.ObjectModel;
using System.Linq;
#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
using JetBrains.Annotations;
using UnityEngine.Assertions;


namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Class covering a Curvy Spline Segment / ControlPoint
    /// </summary>
    [ExecuteAlways]
    [HelpURL(CurvySpline.DOCLINK + "curvysplinesegment")]
    public partial class CurvySplineSegment : DTVersionedMonoBehaviour, IPoolable
    {
        /// <summary>
        /// The color used in Gizmos to draw a segment's tangents
        /// </summary>
        public static readonly Color GizmoTangentColor = new Color(0, 0.7f, 0);

        #region ### Public Properties ###

        /// <summary>
        /// List of precalculated interpolations
        /// </summary>
        /// <remarks>Based on Spline's CacheDensity</remarks>
        [NonSerialized]
        public Vector3[] Approximation = new Vector3[0];

        /// <summary>
        /// List of precalculated distances
        /// </summary>
        /// <remarks>Based on Spline's CacheDensity</remarks>
        [NonSerialized]
        public float[] ApproximationDistances = new float[0];

        /// <summary>
        /// List of precalculated Up-Vectors
        /// </summary>
        /// <remarks>Based on Spline's CacheDensity</remarks>
        [NonSerialized]
        public Vector3[] ApproximationUp = new Vector3[0];

        /// <summary>
        /// List of precalculated Tangent-Normals
        /// </summary>
        /// <remarks>Based on Spline's CacheDensity</remarks>
        [NonSerialized]
        public Vector3[] ApproximationT = new Vector3[0];

        /// <summary>
        /// If set, Control Point's rotation will be set to the calculated Up-Vector3
        /// </summary>
        /// <remarks>This is particularly useful when connecting splines</remarks>
        public bool AutoBakeOrientation
        {
            get { return m_AutoBakeOrientation; }
            set
            {
                if (m_AutoBakeOrientation != value)
                {
                    m_AutoBakeOrientation = value;
                }
            }
        }

        /// <summary>
        /// The serialized value of OrientationAnchor. This value is ignored in some cases (invisible control points, first and last visible control points). Use <see cref="CurvySpline.IsControlPointAnOrientationAnchor"/> to get the correct value.
        /// </summary>
        public bool SerializedOrientationAnchor
        {
            get { return m_OrientationAnchor; }
            set
            {
                if (m_OrientationAnchor != value)
                {
                    m_OrientationAnchor = value;
                    Spline.SetDirty(this, SplineDirtyingType.OrientationOnly);
                    Spline.InvalidateControlPointsRelationshipCacheINTERNAL();
                }
            }
        }

        /// <summary>
        /// Swirling Mode
        /// </summary>
        public CurvyOrientationSwirl Swirl
        {
            get { return m_Swirl; }
            set
            {
                if (m_Swirl != value)
                {
                    m_Swirl = value;
                    Spline.SetDirty(this, SplineDirtyingType.OrientationOnly);
                }
            }
        }

        /// <summary>
        /// Turns to swirl
        /// </summary>
        public float SwirlTurns
        {
            get { return m_SwirlTurns; }
            set
            {
                if (m_SwirlTurns != value)
                {
                    m_SwirlTurns = value;
                    Spline.SetDirty(this, SplineDirtyingType.OrientationOnly);
                }
            }
        }

        #region --- Bezier ---
        //TODO Make sure that every place in the code setting Handles respects the constraints of Sync length, Sync direction and Sync connections

        /// <summary>
        /// Bzier spline left handle in spline's local coordinates
        /// </summary>
        public Vector3 HandleIn
        {
            get
            { return m_HandleIn; }
            set
            {
                if (m_HandleIn != value)
                {
                    m_HandleIn = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// Bzier spline right handle in spline's local coordinates
        /// </summary>
        public Vector3 HandleOut
        {
            get { return m_HandleOut; }
            set
            {
                if (m_HandleOut != value)
                {
                    m_HandleOut = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        //BUG this doesn't handle scaled splines. Go through all similar situations and fix them, or add as a constraint that scaled splines should be normalized (scale set back to 1) before doing any operations on them
        /// <summary>
        /// Bzier spline left handle in world coordinates
        /// </summary>
        public Vector3 HandleInPosition
        {
            get
            {
                return cachedTransform.position + Spline.transform.rotation * HandleIn;
            }
            set
            {
                HandleIn = Spline.transform.InverseTransformDirection(value - cachedTransform.position);
            }
        }

        /// <summary>
        /// Bzier spline right handle in world coordinates
        /// </summary>
        public Vector3 HandleOutPosition
        {
            get
            {
                return cachedTransform.position + Spline.transform.rotation * HandleOut;
            }
            set
            {
                HandleOut = Spline.transform.InverseTransformDirection(value - cachedTransform.position);
            }
        }
        /// <summary>
        /// Gets or Sets Auto Handles. When setting it the value of connected control points is also updated
        /// </summary>
        public bool AutoHandles
        {
            get { return m_AutoHandles; }
            set
            {
                if (SetAutoHandles(value))
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
            }
        }

        public float AutoHandleDistance
        {
            get { return m_AutoHandleDistance; }
            set
            {
                if (m_AutoHandleDistance != value)
                {
                    float clampedDistance = Mathf.Clamp01(value);
                    if (m_AutoHandleDistance != clampedDistance)
                    {
                        m_AutoHandleDistance = clampedDistance;
                        Spline.SetDirty(this, SplineDirtyingType.Everything);
                    }
                }
            }
        }

        #endregion

        #region --- TCB ---

        /// <summary>
        /// Keep Start/End-TCB synchronized
        /// </summary>
        /// <remarks>Applies only to TCB Interpolation</remarks>
        public bool SynchronizeTCB
        {
            get { return m_SynchronizeTCB; }
            set
            {
                if (m_SynchronizeTCB != value)
                {
                    m_SynchronizeTCB = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// Whether local Tension should be used
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Tension</remarks>
        public bool OverrideGlobalTension
        {
            get { return m_OverrideGlobalTension; }
            set
            {
                if (m_OverrideGlobalTension != value)
                {
                    m_OverrideGlobalTension = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// Whether local Continuity should be used
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Continuity</remarks>
        public bool OverrideGlobalContinuity
        {
            get { return m_OverrideGlobalContinuity; }
            set
            {
                if (m_OverrideGlobalContinuity != value)
                {
                    m_OverrideGlobalContinuity = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// Whether local Bias should be used
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Bias</remarks>
        public bool OverrideGlobalBias
        {
            get { return m_OverrideGlobalBias; }
            set
            {
                if (m_OverrideGlobalBias != value)
                {
                    m_OverrideGlobalBias = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// Start Tension
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Tension</remarks>
        public float StartTension
        {
            get { return m_StartTension; }
            set
            {
                if (m_StartTension != value)
                {
                    m_StartTension = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// Start Continuity
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Continuity</remarks>
        public float StartContinuity
        {
            get { return m_StartContinuity; }
            set
            {
                if (m_StartContinuity != value)
                {
                    m_StartContinuity = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// Start Bias
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Bias</remarks>
        public float StartBias
        {
            get { return m_StartBias; }
            set
            {
                if (m_StartBias != value)
                {
                    m_StartBias = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// End Tension
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Tension</remarks>
        public float EndTension
        {
            get { return m_EndTension; }
            set
            {
                if (m_EndTension != value)
                {
                    m_EndTension = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// End Continuity
        /// </summary>
        /// <remarks>This only applies to interpolation methods using Continuity</remarks>
        public float EndContinuity
        {
            get { return m_EndContinuity; }
            set
            {
                if (m_EndContinuity != value)
                {
                    m_EndContinuity = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// End Bias
        /// </summary>
        ///<remarks>This only applies to interpolation methods using Bias</remarks>
        public float EndBias
        {
            get { return m_EndBias; }
            set
            {
                if (m_EndBias != value)
                {
                    m_EndBias = value;
                    Spline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }


        #endregion
        /*
#region --- CG ---

        /// <summary>
        /// Material ID (used by PCG)
        /// </summary>
        public int CGMaterialID
        {
            get
            {
                return m_CGMaterialID;
            }
            set
            {
                if (m_CGMaterialID != Mathf.Max(0, value))
                    m_CGMaterialID = Mathf.Max(0, value);
            }
        }

        /// <summary>
        /// Whether to create a hard edge or not (used by PCG)
        /// </summary>
        public bool CGHardEdge
        {
            get { return m_CGHardEdge; }
            set
            {
                if (m_CGHardEdge != value)
                    m_CGHardEdge = value;
            }
        }
        /// <summary>
        /// Maximum vertex distance when using optimization (0=infinite)
        /// </summary>
        public float CGMaxStepDistance
        {
            get
            {
                return m_CGMaxStepDistance;
            }
            set
            {
                if (m_CGMaxStepDistance != Mathf.Max(0, value))
                    m_CGMaxStepDistance = Mathf.Max(0, value);
            }
        }

#endregion
        */
        #region --- Connections ---
        /// <summary>
        /// Gets the connected Control Point that is set as "Head To"
        /// </summary>
        public CurvySplineSegment FollowUp
        {
            get
            {
                //TODO reactivate this sanity check once the connections related data are no more stored in the control point but in the connection. Right now the check is disabled because the code in CurvyConnection.RemoveControlPoint needs to get the follow up while m_FollowUp.Connection == Connection is not true so that it can correct the situation
                //#if CURVY_SANITY_CHECKS
                //                Assert.IsTrue(m_FollowUp == null || m_FollowUp.Connection == Connection);
                //#endif
                return m_FollowUp;
            }
            private set
            {
                if (m_FollowUp != value)
                {
                    m_FollowUp = value;
#if CURVY_SANITY_CHECKS
                    Assert.IsTrue(m_FollowUp == null || m_FollowUp.Connection == Connection);
#endif
                    if (mSpline != null)
                        mSpline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }


        /// <summary>
        /// Gets or sets the heading toward the "Head To" segment
        /// </summary>
        //Remark Set/Get value is validated through GetValidateConnectionHeading
        public ConnectionHeadingEnum FollowUpHeading
        {
            get
            {
                return GetValidateConnectionHeading(m_FollowUpHeading, FollowUp);
            }
            set
            {
                value = GetValidateConnectionHeading(value, FollowUp);

                if (m_FollowUpHeading != value)
                {
                    m_FollowUpHeading = value;
                    if (mSpline != null)
                        mSpline.SetDirty(this, SplineDirtyingType.Everything);
                }
            }
        }

        /// <summary>
        /// When part of a <see cref="CurvyConnection"/>, this defines whether the connection's position is applied to this Control Point
        /// The synchronization process is applied by <see cref="CurvyConnection"/> at each frame in its update methods. So if you modify the value of this property, and want the synchronization to happen right away, you will have to call the connection's <see cref="CurvyConnection.SetSynchronisationPositionAndRotation(Vector3, Quaternion)"/> with the connection's position and rotation as parameters
        /// </summary>
        public bool ConnectionSyncPosition
        {
            get { return m_ConnectionSyncPosition; }
            set
            {
                if (m_ConnectionSyncPosition != value)
                {
                    m_ConnectionSyncPosition = value;
                    //DESIGN think about removing the code that handles ConnectionSyncPosition and ConnectionSyncRotation, and replace it with a code that always runs in Refresh, and make that code happen by calling SetDirty() here;
                }
            }
        }

        /// <summary>
        /// When part of a <see cref="CurvyConnection"/>, this defines whether the connection's rotation is applied to this Control Point
        /// The synchronization process is applied by <see cref="CurvyConnection"/> at each frame in its update methods. So if you modify the value of this property, and want the synchronization to happen right away, you will have to call the connection's <see cref="CurvyConnection.SetSynchronisationPositionAndRotation(Vector3, Quaternion)"/> with the connection's position and rotation as parameters
        /// </summary>
        public bool ConnectionSyncRotation
        {
            get { return m_ConnectionSyncRotation; }
            set
            {
                if (m_ConnectionSyncRotation != value)
                {
                    m_ConnectionSyncRotation = value;
                    //DESIGN think about removing the code that handles ConnectionSyncPosition and ConnectionSyncRotation, and replace it with a code that always runs in Refresh, and make that code happen by calling SetDirty() here;
                }
            }
        }

        /// <summary>
        /// Gets/Sets the connection handler this Control Point is using (if any)
        /// </summary>
        /// <remarks>If set to null, FollowUp wil be set to null to</remarks>
        public CurvyConnection Connection
        {
            get { return m_Connection; }
            internal set
            {
                if (SetConnection(value))
                    if (mSpline != null)
                        mSpline.SetDirty(this, SplineDirtyingType.Everything);
            }
        }

        #endregion


        /// <summary>
        /// Gets the number of individual cache points of this segment
        /// </summary>
        /// <remarks>The actual approximations arrays' size is CacheSize + 1</remarks>
        public int CacheSize
        {
            get
            {
#if CURVY_SANITY_CHECKS
                Assert.IsTrue(Approximation.Length > 0, "[Curvy] CurvySplineSegment has uninitialized cache");
#endif
                return Approximation.Length - 1;
            }

        }

        /// <summary>
        /// Gets this segment's bounds in world space
        /// </summary>
        public Bounds Bounds
        {
            get
            {
                if (!mBounds.HasValue)
                {
                    Bounds result;
                    if (Approximation.Length == 0)
                        result = new Bounds(cachedTransform.position, Vector3.zero);
                    else
                    {
                        Matrix4x4 mat = Spline.transform.localToWorldMatrix;
                        result = new Bounds(mat.MultiplyPoint3x4(Approximation[0]), Vector3.zero);
                        int u = Approximation.Length;
                        for (int i = 1; i < u; i++)
                            result.Encapsulate(mat.MultiplyPoint3x4(Approximation[i]));
                    }

                    mBounds = result;
                }
                return mBounds.Value;
            }
        }

        /// <summary>
        /// Gets the length of this spline segment
        /// </summary>
        public float Length { get; private set; }

        /// <summary>
        /// Gets the distance from spline start to the first control point (localF=0) 
        /// </summary>
        public float Distance { get; internal set; }

        /// <summary>
        /// Gets the TF of this Control Point
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end.
        /// This is the "time" parameter used in the splines' formulas.
        /// A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <remarks>This yields the same result as LocalFToTF(0)</remarks>
        public float TF
        {
            get
            {
                return mSpline.SegmentToTF(this);
            }
#if UNITY_2020_3_OR_NEWER
            [Obsolete("Setting a TF value is not allowed anymore")]
#endif
            internal set => Debug.LogError("[Curvy] CurvySplineSegment.TF: Setting a TF value is not allowed");
        }

        /// <summary>
        /// Gets whether this Control Point is the first IGNORING closed splines
        /// </summary>
        public bool IsFirstControlPoint
        {
            get
            {
                return (Spline.GetControlPointIndex(this) == 0);
            }
        }

        /// <summary>
        /// Gets whether this Control Point is the last IGNORING closed splines
        /// </summary>
        public bool IsLastControlPoint
        {
            get
            {
                return (Spline.GetControlPointIndex(this) == Spline.ControlPointCount - 1);
            }
        }

        /// <summary>
        /// The Metadata components added to this GameObject
        /// </summary>
        public HashSet<CurvyMetadataBase> Metadata
        {
            get
            {
                return mMetadata;
            }
        }

        /// <summary>
        /// Gets the parent spline
        /// </summary>
        public CurvySpline Spline
        {
            get
            {
                return mSpline;
            }
        }


        /// <summary>
        /// Returns true if the local position is different than the last one used in the segment approximations cache computation
        /// </summary>
        public bool HasUnprocessedLocalPosition { get { return cachedTransform.localPosition.Approximately(lastProcessedLocalPosition) == false; } }
        /// <summary>
        /// Returns true if the local orientation is different than the last one used in the segment approximations cache computation
        /// </summary>
        public bool HasUnprocessedLocalOrientation { get { return cachedTransform.localRotation.DifferentOrientation(lastProcessedLocalRotation); } }
        /// <summary>
        /// Returns wheter the orientation of this Control Point influences the orientation of its containing spline's approximation points.
        /// Returns false if control point is not part of a spline
        /// </summary>
        public bool OrientatinInfluencesSpline { get { return mSpline != null && (mSpline.Orientation == CurvyOrientation.Static || mSpline.IsControlPointAnOrientationAnchor(this)); } }

        #endregion

        #region ### Public Methods ###

        /// <summary>
        /// Sets Bezier HandleIn
        /// </summary>
        /// <param name="position">HandleIn position</param>
        /// <param name="space">The space (spline's local space or the world space) in which the <paramref name="position"/> is expressed</param>
        /// <param name="mode">Handle synchronization mode</param>
        public void SetBezierHandleIn(Vector3 position, Space space = Space.Self, CurvyBezierModeEnum mode = CurvyBezierModeEnum.None)
        {
            if (space == Space.Self)
                HandleIn = position;
            else
                HandleInPosition = position;

            bool syncDirections = (mode & CurvyBezierModeEnum.Direction) == CurvyBezierModeEnum.Direction;
            bool syncLengths = (mode & CurvyBezierModeEnum.Length) == CurvyBezierModeEnum.Length;
            bool syncConnectedCPs = (mode & CurvyBezierModeEnum.Connections) == CurvyBezierModeEnum.Connections;

            if (syncDirections)
                HandleOut = HandleOut.magnitude * (HandleIn.normalized * -1);
            if (syncLengths)
                HandleOut = HandleIn.magnitude * ((HandleOut == Vector3.zero) ? HandleIn.normalized * -1 : HandleOut.normalized);
            if (Connection && syncConnectedCPs && (syncDirections || syncLengths))
            {
                ReadOnlyCollection<CurvySplineSegment> connectionControlPoints = Connection.ControlPointsList;
                for (int index = 0; index < connectionControlPoints.Count; index++)
                {
                    CurvySplineSegment connectedCp = connectionControlPoints[index];
                    if (connectedCp == this)
                        continue;

                    if (connectedCp.HandleIn.magnitude == 0)
                        connectedCp.HandleIn = HandleIn;

                    if (syncDirections)
                        connectedCp.SetBezierHandleIn(connectedCp.HandleIn.magnitude * HandleIn.normalized * Mathf.Sign(Vector3.Dot(HandleIn, connectedCp.HandleIn)), Space.Self, CurvyBezierModeEnum.Direction);
                    if (syncLengths)
                        connectedCp.SetBezierHandleIn(connectedCp.HandleIn.normalized * HandleIn.magnitude, Space.Self, CurvyBezierModeEnum.Length);
                }
            }
        }

        /// <summary>
        /// Sets Bezier HandleOut
        /// </summary>
        /// <param name="position">HandleOut position</param>
        /// <param name="space">The space (spline's local space or the world space) in which the <paramref name="position"/> is expressed</param>
        /// <param name="mode">Handle synchronization mode</param>
        public void SetBezierHandleOut(Vector3 position, Space space = Space.Self, CurvyBezierModeEnum mode = CurvyBezierModeEnum.None)
        {
            if (space == Space.Self)
                HandleOut = position;
            else
                HandleOutPosition = position;

            bool syncDirections = (mode & CurvyBezierModeEnum.Direction) == CurvyBezierModeEnum.Direction;
            bool syncLengths = (mode & CurvyBezierModeEnum.Length) == CurvyBezierModeEnum.Length;
            bool syncConnectedCPs = (mode & CurvyBezierModeEnum.Connections) == CurvyBezierModeEnum.Connections;

            if (syncDirections)
                HandleIn = HandleIn.magnitude * (HandleOut.normalized * -1);
            if (syncLengths)
                HandleIn = HandleOut.magnitude * ((HandleIn == Vector3.zero) ? HandleOut.normalized * -1 : HandleIn.normalized);

            if (Connection && syncConnectedCPs && (syncDirections || syncLengths))
            {
                for (int index = 0; index < (Connection.ControlPointsList).Count; index++)
                {
                    CurvySplineSegment connectedCp = (Connection.ControlPointsList)[index];
                    if (connectedCp == this)
                        continue;

                    if (connectedCp.HandleOut.magnitude == 0)
                        connectedCp.HandleOut = HandleOut;

                    if (syncDirections)
                        connectedCp.SetBezierHandleOut(connectedCp.HandleOut.magnitude * HandleOut.normalized * Mathf.Sign(Vector3.Dot(HandleOut, connectedCp.HandleOut)), Space.Self, CurvyBezierModeEnum.Direction);
                    if (syncLengths)
                        connectedCp.SetBezierHandleOut(connectedCp.HandleOut.normalized * HandleOut.magnitude, Space.Self, CurvyBezierModeEnum.Length);
                }
            }
        }

        /// <summary>
        /// Automatically place Bezier handles relative to neighbour Control Points
        /// </summary>
        /// <param name="distanceFrag">how much % distance between neighbouring CPs are applied to the handle length?</param>
        /// <param name="setIn">Set HandleIn?</param>
        /// <param name="setOut">Set HandleOut?</param>
        /// <param name="noDirtying">If true, the Bezier handles will be modified without dirtying any spline</param>
        public void SetBezierHandles(float distanceFrag = -1, bool setIn = true, bool setOut = true, bool noDirtying = false)
        {
            Vector3 pIn = Vector3.zero;
            Vector3 pOut = Vector3.zero;
            if (distanceFrag == -1)
                distanceFrag = AutoHandleDistance;
            if (distanceFrag > 0)
            {
                CurvySpline spline = Spline;

                CurvySplineSegment nextControlPoint = spline.GetNextControlPoint(this);
                Transform nextTt = nextControlPoint
                    ? nextControlPoint.transform
                    : cachedTransform;
                CurvySplineSegment previousControlPoint = spline.GetPreviousControlPoint(this);
                Transform previousTt = previousControlPoint
                    ? previousControlPoint.transform
                    : cachedTransform;


                Vector3 c = cachedTransform.localPosition;
                Vector3 p = previousTt.localPosition - c;
                Vector3 n = nextTt.localPosition - c;
                SetBezierHandles(distanceFrag, p, n, setIn, setOut, noDirtying);
            }
            else
            {
                // Fallback to zero
                if (setIn)
                    if (noDirtying)
                        m_HandleIn = pIn;
                    else
                        HandleIn = pIn;

                if (setOut)
                    if (noDirtying)
                        m_HandleOut = pOut;
                    else
                        HandleOut = pOut;
            }

        }

        /// <summary>
        /// Automatically place Bezier handles
        /// </summary>
        /// <param name="distanceFrag">how much % distance between neighbouring CPs are applied to the handle length?</param>
        /// <param name="p">Position the In-Handle relates to</param>
        /// <param name="n">Position the Out-Handle relates to</param>
        /// <param name="setIn">Set HandleIn?</param>
        /// <param name="setOut">Set HandleOut?</param>
        /// <param name="noDirtying">If true, the Bezier handles will be modified without dirtying any spline</param>
        public void SetBezierHandles(float distanceFrag, Vector3 p, Vector3 n, bool setIn = true, bool setOut = true, bool noDirtying = false)
        {
            float pLen = p.magnitude;
            float nLen = n.magnitude;
            Vector3 pIn = Vector3.zero;
            Vector3 pOut = Vector3.zero;

            if (pLen != 0 || nLen != 0)
            {
                Vector3 dir = ((pLen / nLen) * n - p).normalized;
                pIn = -dir * (pLen * distanceFrag);
                pOut = dir * (nLen * distanceFrag);
            }

            // Fallback to zero
            if (setIn)
                if (noDirtying)
                    m_HandleIn = pIn;
                else
                    HandleIn = pIn;

            if (setOut)
                if (noDirtying)
                    m_HandleOut = pOut;
                else
                    HandleOut = pOut;
        }


        /// <summary>
        /// Sets Follow-Up of this Control Point
        /// </summary>
        /// <param name="target">the Control Point to follow to</param>
        /// <param name="heading">the Heading on the target's spline</param>
        public void SetFollowUp(CurvySplineSegment target, ConnectionHeadingEnum heading = ConnectionHeadingEnum.Auto)
        {
            if (target == null)
            {
                FollowUp = target;
                FollowUpHeading = heading;
            }
            else if (Spline.CanControlPointHaveFollowUp(this))
            {
                if (Connection == null || Connection != target.Connection)
                    DTLog.LogError("[Curvy] Trying to set as a Follow-Up a Control Point that is not part of the same connection", this);
                else
                {
                    FollowUp = target;
                    FollowUpHeading = heading;
                }
            }
            else
                DTLog.LogError("[Curvy] Setting a Follow-Up to a Control Point that can't have one", this);
        }

        /// <summary>
        /// Resets the connections related data (Connection, FollowUp, etc) while updating the Connection object and dirtying relevant splines.
        /// </summary>
        public void Disconnect()
        {
            Disconnect(true);
        }

        /// <summary>
        /// Resets the connections related data (Connection, FollowUp, etc) while updating the Connection object and dirtying relevant splines.
        /// </summary>
        /// <param name="destroyEmptyConnection">whether the related <see cref="Connection"/> should be destroyed if it becomes empty due to this Disconnect call</param>
        public void Disconnect(bool destroyEmptyConnection)
        {
            if (Connection)
                Connection.RemoveControlPoint(this, destroyEmptyConnection);

            //TODO make all this data part of the connection and not the CP
            //Reset connection related data
            FollowUp = null;
            FollowUpHeading = ConnectionHeadingEnum.Auto;
            ConnectionSyncPosition = false;
            ConnectionSyncRotation = false;
        }

        /// <summary>
        /// Gets the position of a point on the spline segment
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public Vector3 Interpolate(float localF, Space space = Space.Self)
        {
            CurvySpline spline = Spline;

#if CURVY_SANITY_CHECKS
            if (spline.Dirty)
                DTLog.LogWarning("Interpolate should not be called on segment of a dirty spline. Call CurvySpline.Refresh first", this);
            Assert.IsTrue(spline.IsControlPointASegment(this));
            Assert.IsTrue(spline.IsCpsRelationshipCacheValidINTERNAL);
#endif
            CurvyInterpolation curvyInterpolation = spline.Interpolation;

            Vector3 result;
            localF = Mathf.Clamp01(localF);

            //If you modify this, modify also the inlined version of this method in refreshCurveINTERNAL()
            switch (curvyInterpolation)
            {
                case CurvyInterpolation.BSpline:
                    result = BSpline(spline.ControlPointsList, spline.SegmentToTF(this, localF), spline.IsBSplineClamped, spline.Closed, spline.BSplineDegree, BSplineP0Array.Array);
                    break;
                case CurvyInterpolation.Bezier:
                    {
                        result = CurvySpline.Bezier(threadSafeLocalPosition.Addition(HandleOut),
                            threadSafeLocalPosition,
                            threadSafeNextCpLocalPosition,
                            threadSafeNextCpLocalPosition.Addition(cachedNextControlPoint.HandleIn),
                            localF);
                        break;
                    }
                case CurvyInterpolation.CatmullRom:
                case CurvyInterpolation.TCB:
                    {
                        if (curvyInterpolation == CurvyInterpolation.TCB)
                        {
                            float t0 = StartTension; float t1 = EndTension;
                            float c0 = StartContinuity; float c1 = EndContinuity;
                            float b0 = StartBias; float b1 = EndBias;

                            if (!OverrideGlobalTension)
                                t0 = t1 = mSpline.Tension;
                            if (!OverrideGlobalContinuity)
                                c0 = c1 = mSpline.Continuity;
                            if (!OverrideGlobalBias)
                                b0 = b1 = mSpline.Bias;

                            result = CurvySpline.TCB(threadSafePreviousCpLocalPosition,
                                threadSafeLocalPosition,
                                threadSafeNextCpLocalPosition,
                                cachedNextControlPoint.threadSafeNextCpLocalPosition,
                                localF, t0, c0, b0, t1, c1, b1);
                        }
                        else
                            result = CurvySpline.CatmullRom(threadSafePreviousCpLocalPosition,
                                threadSafeLocalPosition,
                                threadSafeNextCpLocalPosition,
                                cachedNextControlPoint.threadSafeNextCpLocalPosition,
                                localF);
                    }
                    break;
                case CurvyInterpolation.Linear:
                    result = OptimizedOperators.LerpUnclamped(
                        threadSafeLocalPosition,
                        threadSafeNextCpLocalPosition,
                        localF);
                    break;
                default:
                    DTLog.LogError("[Curvy] Invalid interpolation value " + curvyInterpolation, this);
                    return Vector3.zero;
            }

            if (space == Space.World)
                result = spline.ToWorldPosition(result);
            return result;
        }

        /// <summary>
        /// Gets the position of a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public Vector3 InterpolateFast(float localF, Space space = Space.Self)
        {
            Vector3 result;
            if (Approximation.Length > 1)
            {
                float frag;
                int idx = getApproximationIndexINTERNAL(localF, out frag);
                result = OptimizedOperators.LerpUnclamped(Approximation[idx], Approximation[idx + 1], frag);
            }
            else
                result = Approximation[0];

            if (space == Space.World)
                result = Spline.ToWorldPosition(result);
            return result;
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public Vector3 GetTangent(float localF, Space space = Space.Self)
        {
            localF = Mathf.Clamp01(localF);
            Vector3 position = Interpolate(localF, space);
            return GetTangent(localF, position, space);
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment.
        /// This method is faster than <see cref="GetTangent(float, Space)"/> if you have already the position of the point.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="position">the position of the point at localF. In other words, the result of <see cref="Interpolate(float, Space)"/></param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public Vector3 GetTangent(float localF, Vector3 position, Space space = Space.Self)
        {
            CurvySpline curvySpline = Spline;
#if CONTRACTS_FULL
            Contract.Requires(curvySpline != null);
#endif
            Vector3 p2;
            int leave = 2;
            const float fIncrement = 0.01f;
            do
            {
                float f2 = localF + fIncrement;
                if (f2 > 1)
                {
                    CurvySplineSegment nSeg = curvySpline.GetNextSegment(this);
                    if (nSeg)
                        p2 = nSeg.Interpolate(f2 - 1, space);//return (NextSegment.Interpolate(f2 - 1) - position).normalized;
                    else
                    {
                        f2 = localF - fIncrement;
                        return OptimizedOperators.Normalize(position.Subtraction(Interpolate(f2, space)));
                    }
                }
                else
                    p2 = Interpolate(f2, space); // return (Interpolate(f2) - position).normalized;

                localF += fIncrement;
            } while (p2 == position && --leave > 0);

            return OptimizedOperators.Normalize(p2.Subtraction(position));
        }

        /// <summary>
        /// Gets the normalized tangent at a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public Vector3 GetTangentFast(float localF, Space space = Space.Self)
        {
            Vector3 result;
            if (ApproximationT.Length > 1)
            {
                float frag;
                int idx = getApproximationIndexINTERNAL(localF, out frag);
                result = Vector3.SlerpUnclamped(ApproximationT[idx], ApproximationT[idx + 1], frag);
            }
            else
                result = ApproximationT[0];

            if (space == Space.World)
                result = Spline.ToWorldDirection(result);
            return result;
        }

        /// <summary>
        /// Gets the position and normalized tangent at a point on the spline segment
        /// Is Faster than calling <see cref="Interpolate(float, Space)"/> and <see cref="Interpolate(float, Space)"/> separately
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="position">the output position</param>
        /// <param name="tangent">the output tangent</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public void InterpolateAndGetTangent(float localF, out Vector3 position, out Vector3 tangent, Space space = Space.Self)
        {
            localF = Mathf.Clamp01(localF);
            position = Interpolate(localF, space);
            tangent = GetTangent(localF, position, space);
        }

        /// <summary>
        /// Gets the position and normalized tangent at a point on the spline segment
        /// Is Faster than calling <see cref="Interpolate(float, Space)"/> and <see cref="Interpolate(float, Space)"/> separately
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="position">the output position</param>
        /// <param name="tangent">the output tangent</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public void InterpolateAndGetTangentFast(float localF, out Vector3 position, out Vector3 tangent, Space space = Space.Self)
        {
            if (Approximation.Length > 1)
            {
                float frag;
                int idx = getApproximationIndexINTERNAL(localF, out frag);
                int idx2 = idx + 1;
                position = OptimizedOperators.LerpUnclamped(Approximation[idx], Approximation[idx2], frag);
                tangent = Vector3.SlerpUnclamped(ApproximationT[idx], ApproximationT[idx2], frag);
            }
            else
            {
                position = Approximation[0];
                tangent = ApproximationT[0];
            }


            if (space == Space.World)
            {
                position = Spline.ToWorldPosition(position);
                tangent = Spline.ToWorldDirection(tangent);
            }
        }

        /// <summary>
        /// Gets the Up vector of a point on the spline segment.
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public Vector3 GetOrientationUpFast(float localF, Space space = Space.Self)
        {
            Vector3 result;
            if (ApproximationUp.Length > 1)
            {
                float frag;
                int idx = getApproximationIndexINTERNAL(localF, out frag);
                result = Vector3.SlerpUnclamped(ApproximationUp[idx], ApproximationUp[idx + 1], frag);
            }
            else
                result = ApproximationUp[0];

            if (space == Space.World)
                result = Spline.ToWorldDirection(result);
            return result;
        }

        /// <summary>
        /// Gets the rotation of a point on the spline segment. The rotation's forward is the segment's tangent, and it's up is the segment's orientation
        /// Instead of computing the exact value, this method uses a linear interpolation between cached points for faster result
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <param name="inverse">whether the orientation should look at the opposite direction of the tangent</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param>
        public Quaternion GetOrientationFast(float localF, bool inverse = false, Space space = Space.Self)
        {
            Vector3 view = GetTangentFast(localF, space);

            Quaternion result;
            if (view != Vector3.zero)
            {
                if (inverse)
                    view *= -1;
                result = Quaternion.LookRotation(view, GetOrientationUpFast(localF, space));
            }
            else
            {
#if CURVY_SANITY_CHECKS
                Debug.LogError(string.Format("[Curvy] Invalid Orientation for segment {0} at localF {1}", this, localF));
#endif
                result = Quaternion.identity;
            }

            return result;

        }


        #region MetaData handling

        /// <summary>
        /// Rebuilds <see cref="Metadata"/>
        /// </summary>
        public void ReloadMetaData()
        {
            Metadata.Clear();
            CurvyMetadataBase[] metaDataComponents = GetComponents<CurvyMetadataBase>();
            foreach (CurvyMetadataBase metaData in metaDataComponents)
                Metadata.Add(metaData);

            CheckAgainstMetaDataDuplication();
        }

        /// <summary>
        /// Adds a MetaData instance to <see cref="Metadata"/>
        /// </summary>
        public void RegisterMetaData(CurvyMetadataBase metaData)
        {
            Metadata.Add(metaData);
            CheckAgainstMetaDataDuplication();
        }

        /// <summary>
        /// Removes a MetaData instance from <see cref="Metadata"/>
        /// </summary>
        public void UnregisterMetaData(CurvyMetadataBase metaData)
        {
            Metadata.Remove(metaData);
        }

        /// <summary>
        /// Gets Metadata of this ControlPoint
        /// </summary>
        /// <typeparam name="T">Metadata type</typeparam>
        /// <param name="autoCreate">whether to create the Metadata component if it's not present</param>
        /// <returns>the Metadata component or null</returns>
        public T GetMetadata<T>(bool autoCreate = false) where T : CurvyMetadataBase
        {
            Type type = typeof(T);
            T result = null;

            foreach (CurvyMetadataBase metaData in Metadata)
                if (metaData != null && metaData.GetType() == type)
                {
                    result = (T)metaData;
                    break;
                }

            if (autoCreate && result == null)
            {
                result = gameObject.AddComponent<T>();
                Metadata.Add(result);
            }
            return result;
        }

        /// <summary>
        /// Gets an interpolated Metadata value for a certain F
        /// </summary>
        /// <typeparam name="T">Metadata type inheriting from CurvyInterpolatableMetadataBase</typeparam>
        /// <typeparam name="U">Metadata's Value type</typeparam>
        /// <param name="f">a local F in the range 0..1</param>
        /// <returns>The interpolated value. If no Metadata of specified type is present at the given tf, the default value of type U is returned</returns>
        public U GetInterpolatedMetadata<T, U>(float f) where T : CurvyInterpolatableMetadataBase<U>
        {
            T metaData = GetMetadata<T>();
            if (metaData != null)
            {
                CurvySplineSegment nextCp = Spline.GetNextControlPointUsingFollowUp(this);
                CurvyInterpolatableMetadataBase<U> nextMetaData = null;
                if (nextCp)
                    nextMetaData = nextCp.GetMetadata<T>();
                return metaData.Interpolate(nextMetaData, f);
            }
            return default;
        }

        /// <summary>
        /// Removes all Metadata components of this Control Point
        /// </summary>
        public void DeleteMetadata()
        {
            List<CurvyMetadataBase> metaDataList = Metadata.ToList();
            for (int i = metaDataList.Count - 1; i >= 0; i--)
                metaDataList[i].Destroy(true, false);
        }
        #endregion

        /// <summary>
        /// Gets the localF of the point on the segment that is the nearest to a given position
        /// localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment
        /// </summary>
        /// <param name="position">The point's position</param>
        /// <param name="space">The space (spline's local space or the world space) in which the returned result is expressed</param> <paramref name="position"/> is expressed</param>
        /// <remarks>This method's precision and speed depend on the <see cref="CurvySpline.CacheDensity"/></remarks>
        public float GetNearestPointF(Vector3 position, Space space = Space.Self)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(CacheSize >= 0, "[Curvy] CurvySplineSegment has uninitialized cache. Call Refresh() on the CurvySpline it belongs to.");
#endif
            if (space == Space.World)
                position = Spline.ToLocalPosition(position);

            CurvyUtility.GetNearestPointIndex(position, Approximation, Approximation.Length, out int index, out float frag);

            // return the nearest collision
            return (index + frag) / (Approximation.Length - 1);

        }


        /// <summary>
        /// Gets the local F of a point given its local distance
        /// Local F stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment
        /// </summary>
        /// <param name="localDistance">The distance between the segment's start and the point you are interested in. Value should be in the range from 0 to <see cref="Length"/> inclusive</param>>
        public float DistanceToLocalF(float localDistance)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(localDistance >= 0);
            Assert.IsTrue(localDistance <= Length);
#endif
            int approximationDistancesLength = ApproximationDistances.Length;

            if (approximationDistancesLength <= 1 || localDistance == 0)
                return 0;

            int lowerIndex = CurvyUtility.InterpolationSearch(ApproximationDistances, ApproximationDistances.Length, localDistance);
            if (lowerIndex == approximationDistancesLength - 1)
                return 1;

            //BUG this basically interpolates linearly the F value between two cache points. This is an approximation that is not correct because F does not vary linearly between two points, unlike distance that does. The issue is not big as long as there is a lot of cache points to keep the difference between the correct answer and the approximate one small enough.
            float frag = (localDistance - ApproximationDistances[lowerIndex]) / (ApproximationDistances[lowerIndex + 1] - ApproximationDistances[lowerIndex]);
            return (lowerIndex + frag) / (approximationDistancesLength - 1);
        }

        /// <summary>
        /// Gets the local distance of a point at a certain localF.
        /// Local distance is the distance between a point and the start of its segment. Value ranges from 0 to the segment's <see cref="Length"/>, inclusive
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        public float LocalFToDistance(float localF)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(localF >= 0);
            Assert.IsTrue(localF <= 1);
#endif
            if (ApproximationDistances.Length <= 1 || localF == 0)
                return 0;

            if (localF == 1f)
                return Length;

            float frag;
            int idx = getApproximationIndexINTERNAL(localF, out frag);
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(idx >= 0);
            Assert.IsTrue(idx < ApproximationDistances.Length - 1);
#endif
            float d = ApproximationDistances[idx + 1] - ApproximationDistances[idx];
            return ApproximationDistances[idx] + d * frag;
        }

        /// <summary>
        /// Gets TF for a certain local F
        /// TF stands for Total Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the spline's start and 1 means the spline's end. This is the "time" parameter used in the splines' formulas. A point's TF is not proportional to its distance from the spline's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the spline
        /// </summary>
        /// <param name="localF">localF stands for Local Fragment. It's a value ranging from 0 to 1 inclusive. 0 means the segment's start and 1 means the segment's end. This is the "time" parameter used in the splines' formulas. A point's localF is not proportional to its distance from the segment's start. Depending on the spline, a value of 0.5 does not always mean the middle, distance wise, of the segment</param>
        /// <returns>a TF value</returns>
        public float LocalFToTF(float localF)
        {
            return Spline.SegmentToTF(this, localF);
        }

        public override string ToString()
        {
            if (Spline != null)
                return Spline.name + "." + name;
            else
                return base.ToString();
        }

        /// <summary>
        /// Modify the control point's local rotation to match the segment's orientation
        /// </summary>
        public void BakeOrientationToTransform()
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(ApproximationUp.Length > 0);
#endif

            Quaternion orientation = GetOrientationFast(0);
            if (cachedTransform.localRotation.DifferentOrientation(orientation))
                SetLocalRotation(orientation);
        }

        /// <summary>
        /// Internal, gets the index of mApproximation by F and the remaining fragment
        /// </summary>
        public int getApproximationIndexINTERNAL(float localF, out float frag)
        {
            int approximationLength = Approximation.Length;

            float f = localF * (approximationLength - 1);

            int tempIndex = (int)f;
            int index = tempIndex <= 0
                ? 0
                : tempIndex >= approximationLength - 2
                    ? approximationLength - 2
                    : tempIndex;

            float tempFrag = f - index;
            frag = tempFrag <= 0
                ? 0
                : tempFrag >= 1
                    ? 1
                    : tempFrag;

            return index;
        }

        public void LinkToSpline(CurvySpline spline)
        {
#if CURVY_SANITY_CHECKS
            //The following assertion is commented because, when dragging CPs from spline A to Spline B, we might have B's SyncSplineFromHierarchy executed before A's, and will call A's CP.LinkToSpline(B) while A's CP still has mSpline != null
            //Assert.IsTrue(mSpline == null, name);
#endif

            mSpline = spline;
        }

        public void UnlinkFromSpline()
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(mSpline != null);
#endif
            mSpline = null;
        }

#if CONTRACTS_FULL
        [ContractInvariantMethod]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "Required for code contracts.")]
        private void ObjectInvariant()
        {
            //Contract.Invariant(mSpline == null || transform.parent.GetComponent<CurvySpline>() == mSpline);
            //Contract.Invariant((mSpline == null) == (mControlPointIndex == -1));
            //Contract.Invariant(mSpline == null || mControlPointIndex < mSpline.ControlPointCount);
            //Contract.Invariant(mSpline == null || mSpline.ControlPoints.ElementAt(mControlPointIndex) == this);
            Contract.Invariant(Connection == null || Connection.ControlPoints.Contains(this));
            Contract.Invariant(Connection == null || Spline != null);
            Contract.Invariant(FollowUp == null || Connection != null);

            //TODO CONTRACT reactivate these if you find a way to call GetNextControlPoint and GetPreviousControlPoint without modifying the cache
            //Contract.Invariant(FollowUp == null || Spline.GetNextControlPoint(this) == null || Spline.GetPreviousControlPoint(this) == null);
        }
#endif

        #region Update position and rotation

        /// <summary>
        /// Sets the local position while dirtying the spline, dirtying the connected splines, and updating the connected control points' positions accordingly.
        /// </summary>
        /// <param name="newPosition"></param>
        public void SetLocalPosition(Vector3 newPosition)
        {
            if (cachedTransform.localPosition != newPosition)
            {
                cachedTransform.localPosition = newPosition;
                Spline.SetDirtyPartial(this, SplineDirtyingType.Everything);
                if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
                    Connection.SetSynchronisationPositionAndRotation(
                        ConnectionSyncPosition ? cachedTransform.position : Connection.transform.position,
                        ConnectionSyncRotation ? cachedTransform.rotation : Connection.transform.rotation);
            }
        }

        /// <summary>
        /// Sets the global position while dirtying the spline, dirtying the connected splines, and updating the connected control points' positions accordingly.
        /// </summary>
        /// <param name="value"></param>
        public void SetPosition(Vector3 value)
        {
            if (cachedTransform.position != value)
            {
                cachedTransform.position = value;
                Spline.SetDirtyPartial(this, SplineDirtyingType.Everything);
                if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
                    Connection.SetSynchronisationPositionAndRotation(
                        ConnectionSyncPosition ? cachedTransform.position : Connection.transform.position,
                        ConnectionSyncRotation ? cachedTransform.rotation : Connection.transform.rotation);
            }
        }

        /// <summary>
        /// Sets the local rotation while dirtying the spline, dirtying the connected splines, and updating the connected control points' rotations accordingly.
        /// </summary>
        /// <param name="value"></param>
        public void SetLocalRotation(Quaternion value)
        {
            if (cachedTransform.localRotation != value)
            {
                cachedTransform.localRotation = value;
                if (OrientatinInfluencesSpline)
                    Spline.SetDirtyPartial(this, SplineDirtyingType.OrientationOnly);
                if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
                    Connection.SetSynchronisationPositionAndRotation(
                        ConnectionSyncPosition ? cachedTransform.position : Connection.transform.position,
                        ConnectionSyncRotation ? cachedTransform.rotation : Connection.transform.rotation);
            }
        }

        /// <summary>
        /// Sets the global rotation while dirtying the spline, dirtying the connected splines, and updating the connected control points' rotations accordingly.
        /// </summary>
        /// <param name="value"></param>
        public void SetRotation(Quaternion value)
        {
            if (cachedTransform.rotation != value)
            {
                cachedTransform.rotation = value;
                if (OrientatinInfluencesSpline)
                    Spline.SetDirtyPartial(this, SplineDirtyingType.OrientationOnly);
                if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
                    Connection.SetSynchronisationPositionAndRotation(
                        ConnectionSyncPosition ? cachedTransform.position : Connection.transform.position,
                        ConnectionSyncRotation ? cachedTransform.rotation : Connection.transform.rotation);
            }
        }

        #endregion

        /// <summary>
        /// Returns true if followUp can be associated with a heading direction of <see cref="ConnectionHeadingEnum.Minus"/>
        /// </summary>
        public static bool CanFollowUpHeadToStart([NotNull] CurvySplineSegment followUp)
        {
            return followUp.Spline.GetPreviousControlPointIndex(followUp) != -1;
        }

        /// <summary>
        /// Returns true if followUp can be associated with a heading direction of <see cref="ConnectionHeadingEnum.Plus"/>
        /// </summary>
        public static bool CanFollowUpHeadToEnd([NotNull] CurvySplineSegment followUp)
        {
            return followUp.Spline.GetNextControlPointIndex(followUp) != -1;
        }

        /// <summary>
        /// Gets the position of a point on the B-Spline
        /// </summary>
        /// <param name="controlPoints">The spline's control points.</param>
        /// <param name="tf">A value between 0 and 1 defining where the point is on the spline</param>
        /// <param name="isClamped"><see cref="CurvySpline.IsBSplineClamped"/></param>
        /// <param name="isClosed"><see cref="CurvySpline.Closed"/></param>
        /// <param name="degree"><see cref="CurvySpline.BSplineDegree"/></param>
        /// <param name="p0Array">An array used in internal computations. This is to avoid excessive allocations.The length of the array should be greater or equal to <paramref name="degree"/> + 1. The content of the array does not matter, since it gets overwritten by the method</param>
        public static Vector3 BSpline([NotNull] ReadOnlyCollection<CurvySplineSegment> controlPoints, float tf, bool isClamped, bool isClosed, int degree, [NotNull] Vector3[] p0Array)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(p0Array.Length >= degree + 1);
            Assert.IsTrue(tf.IsBetween0And1());
#endif
            int controlPointsCount = controlPoints.Count;
            int n = BSplineHelper.GetBSplineN(controlPointsCount, degree, isClosed);
            BSplineHelper.GetBSplineUAndK(tf, isClamped, degree, n, out float u, out int k);
            GetBSplineP0s(controlPoints, controlPointsCount, degree, k, p0Array);
            return isClamped
                ? BSplineHelper.DeBoorClamped(degree, k, u, n + 1, p0Array)
                : BSplineHelper.DeBoorUnclamped(degree, k, u, p0Array);
        }

        #endregion

        #region ### Interface Implementations ###

        //IPoolable
        public void OnBeforePush()
        {
            this.StripComponents();
            Disconnect();
            DeleteMetadata();
        }

        //IPoolable
        public void OnAfterPop()
        {
            Reset();
        }

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegmentDefaultValues.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e978a42d747dc414a880c903dec0e67f
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Here you can find all the default values for CurvySplineSegment's serialized fields. If you don't find a field here, this means that it's type's default value is the same than the field's default value
    /// </summary>
    public static class CurvySplineSegmentDefaultValues
    {
        public const CurvyOrientationSwirl Swirl = CurvyOrientationSwirl.None;
        public const bool SynchronizeTCB = true;
        public const bool AutoHandles = true;
        public const float AutoHandleDistance = 0.39f;
        public static readonly Vector3 HandleIn = new Vector3(-1, 0, 0);
        public static readonly Vector3 HandleOut = new Vector3(1, 0, 0);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegmentDefaultValues.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment_private.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 948d240c45adf9141b1aaaa44f7d5254
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using FluffyUnderware.DevTools.Extensions;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Utils;
using System.Collections.Generic;
using FluffyUnderware.DevTools;
using UnityEngine.Serialization;
using System.Reflection;
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Runtime.CompilerServices;
using FluffyUnderware.Curvy.Pools;
#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
using JetBrains.Annotations;
using ToolBuddy.Pooling.Collections;
using ToolBuddy.Pooling.Pools;
using UnityEngine.Assertions;


namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Class covering a Curvy Spline Segment / ControlPoint
    /// </summary>
    public partial class CurvySplineSegment : DTVersionedMonoBehaviour, IPoolable
    {

        #region ### Serialized Fields ###

        #region --- General ---

        [Group("General")]
        [FieldAction("CBBakeOrientation", Position = ActionAttribute.ActionPositionEnum.Below)]
        [Label("Bake Orientation", "Automatically apply orientation to CP transforms?")]
        [SerializeField]
        private bool m_AutoBakeOrientation;

        [Group("General")]
        [Tooltip("Check to use this transform's rotation")]
        [FieldCondition(nameof(IsOrientationAnchorEditable), true)]
        [SerializeField]
        private bool m_OrientationAnchor;

        [Label("Swirl", "Add Swirl to orientation?")]
        [Group("General")]
        [FieldCondition(nameof(canHaveSwirl), true)]
        [SerializeField]
        private CurvyOrientationSwirl m_Swirl = CurvySplineSegmentDefaultValues.Swirl;

        [Label("Turns", "Number of swirl turns")]
        [Group("General")]
        [FieldCondition(nameof(canHaveSwirl), true, false, ConditionalAttribute.OperatorEnum.AND, "m_Swirl", CurvyOrientationSwirl.None, true)]
        [SerializeField]
        private float m_SwirlTurns;

        #endregion

        #region --- Bezier ---

        [Section("Bezier Options", Sort = 1, HelpURL = CurvySpline.DOCLINK + "curvysplinesegment_bezier")]
        [GroupCondition(nameof(interpolation), CurvyInterpolation.Bezier)]
        [SerializeField]
        private bool m_AutoHandles = CurvySplineSegmentDefaultValues.AutoHandles;

        [RangeEx(0, 1, "Distance %", "Handle length by distance to neighbours")]
        [FieldCondition(nameof(m_AutoHandles), true, Action = ConditionalAttribute.ActionEnum.Enable)]
        [SerializeField]
        private float m_AutoHandleDistance = CurvySplineSegmentDefaultValues.AutoHandleDistance;

        [VectorEx(Precision = 3, Options = AttributeOptionsFlags.Clipboard | AttributeOptionsFlags.Negate, Color = "#FFFF00")]
        [SerializeField, FormerlySerializedAs("HandleIn")]
        private Vector3 m_HandleIn = CurvySplineSegmentDefaultValues.HandleIn;

        [VectorEx(Precision = 3, Options = AttributeOptionsFlags.Clipboard | AttributeOptionsFlags.Negate, Color = "#00FF00")]
        [SerializeField, FormerlySerializedAs("HandleOut")]
        private Vector3 m_HandleOut = CurvySplineSegmentDefaultValues.HandleOut;

        #endregion

        #region --- TCB ---

        [Section("TCB Options", Sort = 1, HelpURL = CurvySpline.DOCLINK + "curvysplinesegment_tcb")]
        [GroupCondition(nameof(interpolation), CurvyInterpolation.TCB)]
        [GroupAction("TCBOptionsGUI", Position = ActionAttribute.ActionPositionEnum.Below)]

        [Label("Local Tension", "Override Spline Tension?")]
        [SerializeField, FormerlySerializedAs("OverrideGlobalTension")]
        private bool m_OverrideGlobalTension;

        [Label("Local Continuity", "Override Spline Continuity?")]
        [SerializeField, FormerlySerializedAs("OverrideGlobalContinuity")]
        private bool m_OverrideGlobalContinuity;

        [Label("Local Bias", "Override Spline Bias?")]
        [SerializeField, FormerlySerializedAs("OverrideGlobalBias")]
        private bool m_OverrideGlobalBias;
        [Tooltip("Synchronize Start and End Values")]
        [SerializeField, FormerlySerializedAs("SynchronizeTCB")]
        private bool m_SynchronizeTCB = CurvySplineSegmentDefaultValues.SynchronizeTCB;
        [Label("Tension"), FieldCondition("m_OverrideGlobalTension", true)]
        [SerializeField, FormerlySerializedAs("StartTension")]
        private float m_StartTension;

        [Label("Tension (End)"), FieldCondition("m_OverrideGlobalTension", true, false, ConditionalAttribute.OperatorEnum.AND, "m_SynchronizeTCB", false, false)]
        [SerializeField, FormerlySerializedAs("EndTension")]
        private float m_EndTension;

        [Label("Continuity"), FieldCondition("m_OverrideGlobalContinuity", true)]
        [SerializeField, FormerlySerializedAs("StartContinuity")]
        private float m_StartContinuity;

        [Label("Continuity (End)"), FieldCondition("m_OverrideGlobalContinuity", true, false, ConditionalAttribute.OperatorEnum.AND, "m_SynchronizeTCB", false, false)]
        [SerializeField, FormerlySerializedAs("EndContinuity")]
        private float m_EndContinuity;

        [Label("Bias"), FieldCondition("m_OverrideGlobalBias", true)]
        [SerializeField, FormerlySerializedAs("StartBias")]
        private float m_StartBias;

        [Label("Bias (End)"), FieldCondition("m_OverrideGlobalBias", true, false, ConditionalAttribute.OperatorEnum.AND, "m_SynchronizeTCB", false, false)]
        [SerializeField, FormerlySerializedAs("EndBias")]
        private float m_EndBias;

        #endregion
        /*
#region --- CG Options ---
        
        /// <summary>
        /// Material ID (used by CG)
        /// </summary>
        [Section("Generator Options", true, Sort = 5, HelpURL = CurvySpline.DOCLINK + "curvysplinesegment_cg")]
        [Positive(Label="Material ID")]
        [SerializeField]
        int m_CGMaterialID;

        /// <summary>
        /// Whether to create a hard edge or not (used by PCG)
        /// </summary>
        [Label("Hard Edge")]
        [SerializeField]
        bool m_CGHardEdge;
        /// <summary>
        /// Maximum vertex distance when using optimization (0=infinite)
        /// </summary>
        [Positive(Label="Max Step Size",Tooltip="Max step distance when using optimization")]
        [SerializeField]
        float m_CGMaxStepDistance;
#endregion
        */
        #region --- Connections ---

        [SerializeField, HideInInspector] private CurvySplineSegment m_FollowUp;
        [SerializeField, HideInInspector] private ConnectionHeadingEnum m_FollowUpHeading = ConnectionHeadingEnum.Auto;
        //DESIGN: shouldn't these two be part of Connection? By spreading them on the ControlPoints, we risk a desynchronisation between m_ConnectionSyncPosition's value of a CP and the one of the connected CP
        [SerializeField, HideInInspector] private bool m_ConnectionSyncPosition;
        [SerializeField, HideInInspector] private bool m_ConnectionSyncRotation;

        [SerializeField, HideInInspector] private CurvyConnection m_Connection;

        #endregion

        #endregion

        #region ### Private Fields ###

        //Because Unity pre 2019 doesn't act like it is supposed to, I have to make two different codes for cachedTransform. Here is the issue:
        //cachedTransform is used as an optim. The idea is to get transform once at script's start, and then use it later. Execution order says that CurvySplineSegment runs before CurvySpline. So all CSS's OnEnable methods should run before CS's ones. But this is not the case in pre 2019. So you end up with CS's OnEnable accessing (through public members) to CSS's cachedTransform, which is still set to null because its OnEnable was not called yet.
#if (UNITY_2019_1_OR_NEWER)
        private Transform cachedTransform;
#else
        private Transform _cachedTransform;
        private Transform cachedTransform
        {
            get
            {
                if (ReferenceEquals(_cachedTransform, null))
                    _cachedTransform = transform;
                return _cachedTransform;
            }
            set
            {
                _cachedTransform = value;
            }
        }
#endif


        /// <summary>
        /// This exists because Transform can not be accessed in non main threads. So before refreshing the spline, we store the local position here so it can be accessed in multithread spline refreshing code
        /// </summary>
        /// <remarks>Warning: Make sure it is set with valid value before using it</remarks>
        private Vector3 threadSafeLocalPosition;
        /// <summary>
        /// Same as <see cref="threadSafeLocalPosition"/>, but for the next CP. Is equal to <see cref="threadSafeLocalPosition"/> if no next cp. Takes into consideration Follow-Ups if spline uses them to define its shape
        /// </summary>
        private Vector3 threadSafeNextCpLocalPosition;
        /// <summary>
        /// Same as <see cref="threadSafeLocalPosition"/>, but for the next CP. Is equal to <see cref="threadSafeLocalPosition"/> if no previous cp. Takes into consideration Follow-Ups if spline uses them to define its shape
        /// </summary>
        private Vector3 threadSafePreviousCpLocalPosition;
        /// <summary>
        /// This exists because Transform can not be accesed in non main threads. So before refreshing the spline, we store the local rotation here so it can be accessed in multithread spline refreshing code
        /// </summary>
        /// <remarks>Warning: Make sure it is set with valid value before using it</remarks>
        private Quaternion threadSafeLocalRotation;
        /// <summary>
        /// The cached result of Spline.GetNextControlPoint(this)
        /// OPTIM: use this more often?
        /// </summary>
        private CurvySplineSegment cachedNextControlPoint;

        private CurvySpline mSpline;
        private Bounds? mBounds;

        /// <summary>
        /// The Metadata components added to this GameObject
        /// </summary>
        private readonly HashSet<CurvyMetadataBase> mMetadata = new HashSet<CurvyMetadataBase>();
        /// <summary>
        /// The local position used in the segment approximations cache latest computation
        /// </summary>
        private Vector3 lastProcessedLocalPosition;
        /// <summary>
        /// The local rotation used in the segment approximations cache latest computation
        /// </summary>
        private Quaternion lastProcessedLocalRotation;

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */


        private void Awake()
        {
            //Happens when duplicating a spline that has a connection. This can be avoided
            if (Connection && Connection.ControlPointsList.Contains(this) == false)
                SetConnection(null);

            cachedTransform = transform;
            ReloadMetaData();
        }

        private void OnEnable()
        {
            Awake();
        }

#if UNITY_EDITOR

        private void OnDrawGizmos()
        {
            if (Spline && Spline.IsInitialized && Spline.ShowGizmos)
            {
                bool isSelected = Selection.Contains(gameObject.GetInstanceID());
                bool isThisOrParentSelected;
                {
                    if (isSelected)
                    {
                        isThisOrParentSelected = true;
                    }
                    else
                    {
                        Transform testedTransform = gameObject.transform.parent;
                        do
                        {
                            isThisOrParentSelected = Selection.Contains(testedTransform.gameObject.GetInstanceID());
                            testedTransform = testedTransform.parent;
                        }
                        while (!isThisOrParentSelected && ReferenceEquals(testedTransform, null) == false);
                    }
                }

                bool willOnDrawGizmosSelectedGetCalled;
                {
#if UNITY_2022_1_OR_NEWER
                    willOnDrawGizmosSelectedGetCalled = isSelected;
#else
                    willOnDrawGizmosSelectedGetCalled = isThisOrParentSelected;
#endif
                }

                if (willOnDrawGizmosSelectedGetCalled == false)
                {
#if UNITY_2022_1_OR_NEWER
                    doGizmos(isThisOrParentSelected);
#else
                    doGizmos(false);
#endif
                }
            }
        }

        private void OnDrawGizmosSelected()
        {
            if (Spline && Spline.IsInitialized)
                doGizmos(true);
        }
#endif

        private void OnDestroy()
        {
            //BUG? Why do we have that realDestroy boolean? Why not always do the same thing? This might hide something bad
            //When asked about this jake said:
            //That was quite a dirty hack as far as I remember, to counter issues with Unity's serialization
            //TBH I'm not sure if those issues still are present, so you might want to see if it's working without it now.
            bool realDestroy = true;
#if UNITY_EDITOR
            if (EditorApplication.isPlayingOrWillChangePlaymode && !EditorApplication.isPlaying)
                realDestroy = false;
#endif
            //Debug.Log("realDestroy " + realDestroy);
#if UNITY_EDITOR
            //mSpline is non null when the user delete only this CP. mSpline is null when the user deletes the spline, which then leads to this method to be called
            if (mSpline != null)
            {
                if (!Application.isPlaying &&
                    (CurvySpline._newSelectionInstanceIDINTERNAL == 0 || CurvySpline._newSelectionInstanceIDINTERNAL == GetInstanceID())
                    )
                {
                    if (Spline.GetPreviousControlPoint(this))
                        CurvySpline._newSelectionInstanceIDINTERNAL = Spline.GetPreviousControlPoint(this).GetInstanceID();
                    else if (Spline.GetNextControlPoint(this))
                        CurvySpline._newSelectionInstanceIDINTERNAL = Spline.GetNextControlPoint(this).GetInstanceID();
                    else
                        CurvySpline._newSelectionInstanceIDINTERNAL = mSpline.GetInstanceID();
                }
            }
#endif
            if (realDestroy)
            {
                Disconnect();
                if (bSplineP0Array.Count > 0)
                    ArrayPools.Vector3.Free(bSplineP0Array);
            }
        }

#if UNITY_EDITOR
        private void OnValidate()
        {
            //Debug.Log("    OnValidate " + name);
            SetAutoHandles(m_AutoHandles);
            SetConnection(m_Connection);
            if (mSpline != null)
            {
                Spline.SetDirtyAll(SplineDirtyingType.Everything, true);
                Spline.InvalidateControlPointsRelationshipCacheINTERNAL();
            }
        }

#endif

        /// <summary>
        /// Resets the properties of this control point, but will not remove its Connection if it has any.
        /// </summary>
        public void Reset()
        {
            m_OrientationAnchor = false;
            m_Swirl = CurvySplineSegmentDefaultValues.Swirl;
            m_SwirlTurns = 0;
            // Bezier
            m_AutoHandles = CurvySplineSegmentDefaultValues.AutoHandles;
            m_AutoHandleDistance = CurvySplineSegmentDefaultValues.AutoHandleDistance;
            m_HandleIn = CurvySplineSegmentDefaultValues.HandleIn;
            m_HandleOut = CurvySplineSegmentDefaultValues.HandleOut;
            // TCB
            m_SynchronizeTCB = CurvySplineSegmentDefaultValues.SynchronizeTCB;
            m_OverrideGlobalTension = false;
            m_OverrideGlobalContinuity = false;
            m_OverrideGlobalBias = false;
            m_StartTension = 0;
            m_EndTension = 0;
            m_StartContinuity = 0;
            m_EndContinuity = 0;
            m_StartBias = 0;
            m_EndBias = 0;
            if (mSpline)
            {
                Spline.SetDirty(this, SplineDirtyingType.Everything);
                Spline.InvalidateControlPointsRelationshipCacheINTERNAL();
            }
        }
        /*! \endcond */
        #endregion

        #region ### Privates & Internals ###
        /*! \cond PRIVATE */

        #region Properties used in inspector's field condition and group condition

        // Used as a group condition
        private CurvyInterpolation interpolation
        {
            get { return Spline ? Spline.Interpolation : CurvyInterpolation.Linear; }
        }

        // Used as a field condition
        private bool isDynamicOrientation
        {
            get { return Spline && Spline.Orientation == CurvyOrientation.Dynamic; }
        }

        // Used as a field condition
        private bool IsOrientationAnchorEditable
        {
            get
            {
                CurvySpline curvySpline = Spline;
                return isDynamicOrientation && curvySpline.IsControlPointVisible(this) && curvySpline.FirstVisibleControlPoint != this && curvySpline.LastVisibleControlPoint != this;
            }
        }

        // Used as a field condition
        private bool canHaveSwirl
        {
            get
            {
                CurvySpline curvySpline = Spline;
                return isDynamicOrientation && curvySpline && curvySpline.IsControlPointAnOrientationAnchor(this) && (curvySpline.Closed || curvySpline.LastVisibleControlPoint != this);
            }
        }

        #endregion

        #region BSplines

        /// <summary>
        /// A subArray used in the computation of B-Splines, to avoid arrays computation at each computation
        /// </summary>
        private SubArray<Vector3> bSplineP0Array;

        /// <summary>
        /// A subArray used in the computation of B-Splines, to avoid arrays computation at each computation
        /// </summary>
        private SubArray<Vector3> BSplineP0Array
        {
            get
            {
                if (bSplineP0Array.Count != mSpline.BSplineDegree + 1)
                {
                    ArrayPool<Vector3> arrayPool = ArrayPools.Vector3;
                    if (bSplineP0Array.Count > 0)
                        arrayPool.Free((SubArray<Vector3>)bSplineP0Array);
                    bSplineP0Array = arrayPool.Allocate(Spline.BSplineDegree + 1, false);
                }
                return bSplineP0Array;
            }
        }

        /// <summary>
        /// Fills <paramref name="pArray"/> with the P0s numbers as defined in the B-Spline section, De Boor's algorithm, here: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void GetBSplineP0s([NotNull] ReadOnlyCollection<CurvySplineSegment> controlPoints, int controlPointsCount, int degree, int k, [NotNull] Vector3[] pArray)
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(pArray.Length >= degree + 1);
#endif
            for (int j = 0; j <= degree; j++)
            {
                int index = j + k - degree;
                pArray[j] = controlPoints[
                        index < controlPointsCount
                            ? index
                            : (index - controlPointsCount)
                    ]
                    .threadSafeLocalPosition;
            }
        }

        #endregion

        #region Extrinsic properties

        private ControlPointExtrinsicProperties extrinsicPropertiesINTERNAL;

        /// <summary>
        /// Properties describing the relationship between this CurvySplineSegment and its containing CurvySpline.
        /// </summary>
        internal void SetExtrinsicPropertiesINTERNAL(ControlPointExtrinsicProperties value)
        {
            extrinsicPropertiesINTERNAL = value;
        }
        internal ref readonly ControlPointExtrinsicProperties GetExtrinsicPropertiesINTERNAL()
        {
            return ref extrinsicPropertiesINTERNAL;
        }

        #endregion

        private void CheckAgainstMetaDataDuplication()
        {
            if (Metadata.Count > 1)
            {
                HashSet<Type> metaDataTypes = new HashSet<Type>();
                foreach (CurvyMetadataBase metaData in Metadata)
                {
                    Type componentType = metaData.GetType();
                    if (metaDataTypes.Contains(componentType))
                        DTLog.LogWarning(String.Format("[Curvy] Game object '{0}' has multiple Components of type '{1}'. Control Points should have no more than one Component instance for each MetaData type.", this.ToString(), componentType), this);
                    else
                        metaDataTypes.Add(componentType);
                }
            }
        }

        /// <summary>
        /// Sets the connection handler this Control Point is using
        /// </summary>
        /// <param name="newConnection"></param>
        /// <returns>Whether a modification was done or not</returns>
        /// <remarks>If set to null, FollowUp wil be set to null to</remarks>
        private bool SetConnection(CurvyConnection newConnection)
        {
            bool modificationDone = false;
            if (m_Connection != newConnection)
            {
                modificationDone = true;
                m_Connection = newConnection;
            }
            if (m_Connection == null && m_FollowUp != null)
            {
                modificationDone = true;
                m_FollowUp = null;
            }
            return modificationDone;
        }

        /// <summary>
        /// Returns a different ConnectionHeadingEnum value when connectionHeading has a value that is no more valid in the context of this spline. For example, heading to start (Minus) when there is no previous CP
        /// </summary>
        private static ConnectionHeadingEnum GetValidateConnectionHeading(ConnectionHeadingEnum connectionHeading, [CanBeNull] CurvySplineSegment followUp)
        {
            if (followUp == null)
                return connectionHeading;

            if ((connectionHeading == ConnectionHeadingEnum.Minus && CanFollowUpHeadToStart(followUp) == false)
                || (connectionHeading == ConnectionHeadingEnum.Plus && CanFollowUpHeadToEnd(followUp) == false))
                return ConnectionHeadingEnum.Auto;

            return connectionHeading;
        }

        /// <summary>
        /// Sets Auto Handles. When setting it the value of connected control points is also updated
        /// </summary>
        /// <param name="newValue"></param>
        /// <returns>Whether a modifcation was done or not</returns>
        private bool SetAutoHandles(bool newValue)
        {
            bool modificationDone = false;
            if (Connection)
            {
                ReadOnlyCollection<CurvySplineSegment> controlPoints = Connection.ControlPointsList;
                for (int index = 0; index < controlPoints.Count; index++)
                {
                    CurvySplineSegment controlPoint = controlPoints[index];
                    modificationDone = modificationDone || controlPoint.m_AutoHandles != newValue;
                    controlPoint.m_AutoHandles = newValue;
                }
            }
            else
            {
                modificationDone = m_AutoHandles != newValue;
                m_AutoHandles = newValue;
            }
            return modificationDone;
        }

        #region approximations cache computation

        internal void refreshCurveINTERNAL()
        {
            CurvySpline spline = Spline;
            bool isControlPointASegment = spline.IsControlPointASegment(this);
            int newCacheSize;
            if (isControlPointASegment)
            {
#if CURVY_SANITY_CHECKS
                Assert.IsNotNull(cachedNextControlPoint);
#endif
                newCacheSize = CurvySpline.CalculateCacheSize(
                    spline.CacheDensity,
                    (cachedNextControlPoint.threadSafeLocalPosition.Subtraction(threadSafeLocalPosition)).magnitude,
                    spline.MaxPointsPerUnit);
            }
            else
                newCacheSize = 0;

            Array.Resize(ref Approximation, newCacheSize + 1);
            Array.Resize(ref ApproximationT, newCacheSize + 1);
            Array.Resize(ref ApproximationDistances, newCacheSize + 1);
            Array.Resize(ref ApproximationUp, newCacheSize + 1);

            bool hasNextControlPoint = ReferenceEquals(cachedNextControlPoint, null) == false;

            //set Approximation[0] and Approximation[newCacheSize]
            switch (interpolation)
            {
                case CurvyInterpolation.Linear:
                case CurvyInterpolation.CatmullRom:
                case CurvyInterpolation.TCB:
                case CurvyInterpolation.Bezier:
                    Approximation[0] = threadSafeLocalPosition;
                    if (newCacheSize != 0)
                        Approximation[newCacheSize] = hasNextControlPoint
                            ? cachedNextControlPoint.threadSafeLocalPosition
                            : threadSafeLocalPosition;
                    break;
                case CurvyInterpolation.BSpline:
                    if (isControlPointASegment)
                    {
                        Approximation[0] = BSpline(spline.ControlPointsList, spline.SegmentToTF(this), spline.IsBSplineClamped, spline.Closed, spline.BSplineDegree, BSplineP0Array.Array);
                        Approximation[newCacheSize] = BSpline(spline.ControlPointsList, spline.SegmentToTF(this, 1), spline.IsBSplineClamped, spline.Closed, spline.BSplineDegree, BSplineP0Array.Array);
                    }
                    else
                        //staying coherent with other interpolation types. TODO check why Approximation should have the element 0 when not a segment. What happens if we simply keep the array empty?
                        Approximation[0] = threadSafeLocalPosition;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            ApproximationDistances[0] = 0;
            //  ApproximationT[0] and ApproximationUp[0] are handled later
            mBounds = null;
            Length = 0;

            if (isControlPointASegment)
            {
                float segmentLength = 0;
                switch (spline.Interpolation)
                {
                    case CurvyInterpolation.BSpline:
                        segmentLength = InterpolateBSplineSegment(newCacheSize);
                        break;
                    case CurvyInterpolation.Bezier:
                        segmentLength = InterpolateBezierSegment(cachedNextControlPoint, newCacheSize);
                        break;
                    case CurvyInterpolation.CatmullRom:
                        segmentLength = InterpolateCatmullSegment(cachedNextControlPoint, newCacheSize);
                        break;
                    case CurvyInterpolation.TCB:
                        segmentLength = InterpolateTCBSegment(cachedNextControlPoint, newCacheSize, spline.Tension, spline.Continuity, spline.Bias);
                        break;
                    case CurvyInterpolation.Linear:
                        segmentLength = InterpolateLinearSegment(cachedNextControlPoint, newCacheSize);
                        break;
                    default:
                        DTLog.LogError("[Curvy] Invalid interpolation value " + spline.Interpolation, this);
                        break;
                }
                Length = segmentLength;

                Vector3 tangent = Approximation[newCacheSize].Subtraction(Approximation[newCacheSize - 1]);
                Length += tangent.magnitude;
                ApproximationDistances[newCacheSize] = Length;
                ApproximationT[newCacheSize - 1] = tangent.normalized;
                // ApproximationT[cacheSize] is set in Spline's Refresh method
                ApproximationT[newCacheSize] = ApproximationT[newCacheSize - 1];
            }
            else
            {
                if (hasNextControlPoint)
                    ApproximationT[0] = (cachedNextControlPoint.threadSafeLocalPosition.Subtraction(Approximation[0])).normalized;
                else
                {
                    short previousControlPointIndex = spline.GetPreviousControlPointIndex(this);
                    if (previousControlPointIndex != -1)
                        ApproximationT[0] = (Approximation[0].Subtraction(spline.ControlPointsList[previousControlPointIndex].threadSafeLocalPosition)).normalized;
                    else
                        ApproximationT[0] = threadSafeLocalRotation * Vector3.forward;
                }

                //Last visible control point gets the last tangent from the previous segment. This is done in Spline's Refresh method 

            }

            lastProcessedLocalPosition = threadSafeLocalPosition;
        }


        #region Inlined code for optimization


        private float InterpolateBSplineSegment(int newCacheSize)
        {
            CurvySpline spline = Spline;

            float mStepSize = 1f / newCacheSize;
            float lengthAccumulator = 0;

            bool isClamped = spline.IsBSplineClamped;
            ReadOnlyCollection<CurvySplineSegment> controlPoints = spline.ControlPointsList;
            int degree = spline.BSplineDegree;
            float segmentTF = spline.SegmentToTF(this);
            float tfIncrement = mStepSize / spline.Count;

            int controlPointsCount = controlPoints.Count;
            int n = BSplineHelper.GetBSplineN(controlPointsCount, degree, spline.Closed);
            int previousK = int.MinValue;

            SubArray<Vector3> splinePsVector = BSplineP0Array;
            Vector3[] ps = splinePsVector.Array;
            int psCount = splinePsVector.Count;

            SubArray<Vector3> psCopySubArray = ArrayPools.Vector3.Allocate(psCount);
            Vector3[] psCopy = psCopySubArray.Array;

            int nPlus1 = n + 1;
            for (int i = 1; i < newCacheSize; i++)
            {
                float tf = segmentTF + tfIncrement * i;
                BSplineHelper.GetBSplineUAndK(tf, isClamped, degree, n, out float u, out int k);

                if (k != previousK)
                {
                    GetBSplineP0s(controlPoints, controlPointsCount, degree, k, ps);
                    previousK = k;
                }

                Array.Copy(ps, 0, psCopy, 0, psCount);

                Approximation[i] = isClamped ? BSplineHelper.DeBoorClamped(degree, k, u, nPlus1, psCopy) : BSplineHelper.DeBoorUnclamped(degree, k, u, psCopy);

                Vector3 delta = Approximation[i].Subtraction(Approximation[i - 1]);
                lengthAccumulator += delta.magnitude;
                ApproximationDistances[i] = lengthAccumulator;
                ApproximationT[i - 1] = OptimizedOperators.Normalize(delta);
            }

            ArrayPools.Vector3.Free(psCopySubArray);

            return lengthAccumulator;
        }

        private float InterpolateBezierSegment(CurvySplineSegment nextControlPoint, int newCacheSize)
        {
            //The following code is the inlined version of this code:
            //        for (int i = 1; i < CacheSize; i++)
            //        {
            //            Approximation[i] = interpolateBezier(i * mStepSize);
            //            t = (Approximation[i] - Approximation[i - 1]);
            //            Length += t.magnitude;
            //            ApproximationDistances[i] = Length;
            //            ApproximationT[i - 1] = t.normalized;
            //        }

            float mStepSize = 1f / newCacheSize;

            float lengthAccumulator = 0;
            CurvySplineSegment ncp = nextControlPoint;
            Vector3 p0 = threadSafeLocalPosition;
            Vector3 t0 = p0 + HandleOut;
            Vector3 p1 = ncp.threadSafeLocalPosition;
            Vector3 t1 = p1 + ncp.HandleIn;

            const double Ft2 = 3;
            const double Ft3 = -3;
            const double Fu1 = 3;
            const double Fu2 = -6;
            const double Fu3 = 3;
            const double Fv1 = -3;
            const double Fv2 = 3;

            double FAX = -p0.x + Ft2 * t0.x + Ft3 * t1.x + p1.x;
            double FBX = Fu1 * p0.x + Fu2 * t0.x + Fu3 * t1.x;
            double FCX = Fv1 * p0.x + Fv2 * t0.x;
            double FDX = p0.x;

            double FAY = -p0.y + Ft2 * t0.y + Ft3 * t1.y + p1.y;
            double FBY = Fu1 * p0.y + Fu2 * t0.y + Fu3 * t1.y;
            double FCY = Fv1 * p0.y + Fv2 * t0.y;
            double FDY = p0.y;

            double FAZ = -p0.z + Ft2 * t0.z + Ft3 * t1.z + p1.z;
            double FBZ = Fu1 * p0.z + Fu2 * t0.z + Fu3 * t1.z;
            double FCZ = Fv1 * p0.z + Fv2 * t0.z;
            double FDZ = p0.z;
            Vector3 tangent;

            for (int i = 1; i < newCacheSize; i++)
            {
                float localF = i * mStepSize;

                Approximation[i].x = (float)(((FAX * localF + FBX) * localF + FCX) * localF + FDX);
                Approximation[i].y = (float)(((FAY * localF + FBY) * localF + FCY) * localF + FDY);
                Approximation[i].z = (float)(((FAZ * localF + FBZ) * localF + FCZ) * localF + FDZ);

                tangent.x = (Approximation[i].x - Approximation[i - 1].x);
                tangent.y = (Approximation[i].y - Approximation[i - 1].y);
                tangent.z = (Approximation[i].z - Approximation[i - 1].z);

                float tMagnitude = Mathf.Sqrt((float)(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z));
                lengthAccumulator += tMagnitude;
                ApproximationDistances[i] = lengthAccumulator;
                if ((double)tMagnitude > 9.99999974737875E-06)
                {
                    float oneOnMagnitude = 1 / tMagnitude;
                    ApproximationT[i - 1].x = tangent.x * oneOnMagnitude;
                    ApproximationT[i - 1].y = tangent.y * oneOnMagnitude;
                    ApproximationT[i - 1].z = tangent.z * oneOnMagnitude;
                }
                else
                {
                    ApproximationT[i - 1].x = 0;
                    ApproximationT[i - 1].y = 0;
                    ApproximationT[i - 1].z = 0;
                }
            }
            return lengthAccumulator;
        }


        private float InterpolateTCBSegment(CurvySplineSegment nextControlPoint, int newCacheSize, float splineTension, float splineContinuity, float splineBias)
        {
            //The following code is the inlined version of this code:
            //        for (int i = 1; i < CacheSize; i++)
            //        {
            //            Approximation[i] = interpolateCatmull(i * mStepSize);
            //            t = (Approximation[i] - Approximation[i - 1]);
            //            Length += t.magnitude;
            //            ApproximationDistances[i] = Length;
            //            ApproximationT[i - 1] = t.normalized;
            //        }

            float mStepSize = 1f / newCacheSize;

            float lengthAccumulator = 0;

            float ft0 = StartTension;
            float ft1 = EndTension;
            float fc0 = StartContinuity;
            float fc1 = EndContinuity;
            float fb0 = StartBias;
            float fb1 = EndBias;

            if (!OverrideGlobalTension)
                ft0 = ft1 = splineTension;
            if (!OverrideGlobalContinuity)
                fc0 = fc1 = splineContinuity;
            if (!OverrideGlobalBias)
                fb0 = fb1 = splineBias;

            Vector3 p0 = threadSafeLocalPosition;
            Vector3 p1 = threadSafeNextCpLocalPosition;
            Vector3 t0 = threadSafePreviousCpLocalPosition;
            Vector3 t1 = nextControlPoint.threadSafeNextCpLocalPosition;

            double FFA = (1 - ft0) * (1 + fc0) * (1 + fb0);
            double FFB = (1 - ft0) * (1 - fc0) * (1 - fb0);
            double FFC = (1 - ft1) * (1 - fc1) * (1 + fb1);
            double FFD = (1 - ft1) * (1 + fc1) * (1 - fb1);

            double DD = 2;
            double Ft1 = -FFA / DD;
            double Ft2 = (+4 + FFA - FFB - FFC) / DD;
            double Ft3 = (-4 + FFB + FFC - FFD) / DD;
            double Ft4 = FFD / DD;
            double Fu1 = +2 * FFA / DD;
            double Fu2 = (-6 - 2 * FFA + 2 * FFB + FFC) / DD;
            double Fu3 = (+6 - 2 * FFB - FFC + FFD) / DD;
            double Fu4 = -FFD / DD;
            double Fv1 = -FFA / DD;
            double Fv2 = (FFA - FFB) / DD;
            double Fv3 = FFB / DD;
            double Fw2 = +2 / DD;

            double FAX = Ft1 * t0.x + Ft2 * p0.x + Ft3 * p1.x + Ft4 * t1.x;
            double FBX = Fu1 * t0.x + Fu2 * p0.x + Fu3 * p1.x + Fu4 * t1.x;
            double FCX = Fv1 * t0.x + Fv2 * p0.x + Fv3 * p1.x;
            double FDX = Fw2 * p0.x;

            double FAY = Ft1 * t0.y + Ft2 * p0.y + Ft3 * p1.y + Ft4 * t1.y;
            double FBY = Fu1 * t0.y + Fu2 * p0.y + Fu3 * p1.y + Fu4 * t1.y;
            double FCY = Fv1 * t0.y + Fv2 * p0.y + Fv3 * p1.y;
            double FDY = Fw2 * p0.y;

            double FAZ = Ft1 * t0.z + Ft2 * p0.z + Ft3 * p1.z + Ft4 * t1.z;
            double FBZ = Fu1 * t0.z + Fu2 * p0.z + Fu3 * p1.z + Fu4 * t1.z;
            double FCZ = Fv1 * t0.z + Fv2 * p0.z + Fv3 * p1.z;
            double FDZ = Fw2 * p0.z;
            Vector3 tangent;
            for (int i = 1; i < newCacheSize; i++)
            {
                float localF = i * mStepSize;

                Approximation[i].x = (float)(((FAX * localF + FBX) * localF + FCX) * localF + FDX);
                Approximation[i].y = (float)(((FAY * localF + FBY) * localF + FCY) * localF + FDY);
                Approximation[i].z = (float)(((FAZ * localF + FBZ) * localF + FCZ) * localF + FDZ);

                tangent.x = (Approximation[i].x - Approximation[i - 1].x);
                tangent.y = (Approximation[i].y - Approximation[i - 1].y);
                tangent.z = (Approximation[i].z - Approximation[i - 1].z);

                float tMagnitude = Mathf.Sqrt((float)(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z));
                lengthAccumulator += tMagnitude;
                ApproximationDistances[i] = lengthAccumulator;
                if ((double)tMagnitude > 9.99999974737875E-06)
                {
                    float oneOnMagnitude = 1 / tMagnitude;
                    ApproximationT[i - 1].x = tangent.x * oneOnMagnitude;
                    ApproximationT[i - 1].y = tangent.y * oneOnMagnitude;
                    ApproximationT[i - 1].z = tangent.z * oneOnMagnitude;
                }
                else
                {
                    ApproximationT[i - 1].x = 0;
                    ApproximationT[i - 1].y = 0;
                    ApproximationT[i - 1].z = 0;
                }
            }
            return lengthAccumulator;
        }

        private float InterpolateCatmullSegment(CurvySplineSegment nextControlPoint, int newCacheSize)
        {
            //The following code is the inlined version of this code:
            //        for (int i = 1; i < CacheSize; i++)
            //        {
            //            Approximation[i] = interpolateTCB(i * mStepSize);
            //            t = (Approximation[i] - Approximation[i - 1]);
            //            Length += t.magnitude;
            //            ApproximationDistances[i] = Length;
            //            ApproximationT[i - 1] = t.normalized;
            //        }

            float mStepSize = 1f / newCacheSize;

            float lengthAccumulator = 0;

            Vector3 p0 = threadSafeLocalPosition;
            Vector3 p1 = threadSafeNextCpLocalPosition;
            Vector3 t0 = threadSafePreviousCpLocalPosition;
            Vector3 t1 = nextControlPoint.threadSafeNextCpLocalPosition;

            const double Ft1 = -0.5;
            const double Ft2 = 1.5;
            const double Ft3 = -1.5;
            const double Ft4 = 0.5;
            const double Fu2 = -2.5;
            const double Fu3 = 2;
            const double Fu4 = -0.5;
            const double Fv1 = -0.5;
            const double Fv3 = 0.5;

            double FAX = Ft1 * t0.x + Ft2 * p0.x + Ft3 * p1.x + Ft4 * t1.x;
            double FBX = t0.x + Fu2 * p0.x + Fu3 * p1.x + Fu4 * t1.x;
            double FCX = Fv1 * t0.x + Fv3 * p1.x;
            double FDX = p0.x;

            double FAY = Ft1 * t0.y + Ft2 * p0.y + Ft3 * p1.y + Ft4 * t1.y;
            double FBY = t0.y + Fu2 * p0.y + Fu3 * p1.y + Fu4 * t1.y;
            double FCY = Fv1 * t0.y + Fv3 * p1.y;
            double FDY = p0.y;

            double FAZ = Ft1 * t0.z + Ft2 * p0.z + Ft3 * p1.z + Ft4 * t1.z;
            double FBZ = t0.z + Fu2 * p0.z + Fu3 * p1.z + Fu4 * t1.z;
            double FCZ = Fv1 * t0.z + Fv3 * p1.z;
            double FDZ = p0.z;
            Vector3 tangent;
            for (int i = 1; i < newCacheSize; i++)
            {
                float localF = i * mStepSize;

                Approximation[i].x = (float)(((FAX * localF + FBX) * localF + FCX) * localF + FDX);
                Approximation[i].y = (float)(((FAY * localF + FBY) * localF + FCY) * localF + FDY);
                Approximation[i].z = (float)(((FAZ * localF + FBZ) * localF + FCZ) * localF + FDZ);

                tangent.x = (Approximation[i].x - Approximation[i - 1].x);
                tangent.y = (Approximation[i].y - Approximation[i - 1].y);
                tangent.z = (Approximation[i].z - Approximation[i - 1].z);

                float tMagnitude = Mathf.Sqrt((float)(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z));
                lengthAccumulator += tMagnitude;
                ApproximationDistances[i] = lengthAccumulator;
                if ((double)tMagnitude > 9.99999974737875E-06)
                {
                    float oneOnMagnitude = 1 / tMagnitude;
                    ApproximationT[i - 1].x = tangent.x * oneOnMagnitude;
                    ApproximationT[i - 1].y = tangent.y * oneOnMagnitude;
                    ApproximationT[i - 1].z = tangent.z * oneOnMagnitude;
                }
                else
                {
                    ApproximationT[i - 1].x = 0;
                    ApproximationT[i - 1].y = 0;
                    ApproximationT[i - 1].z = 0;
                }
            }
            return lengthAccumulator;
        }

        private float InterpolateLinearSegment(CurvySplineSegment nextControlPoint, int newCacheSize)
        {
            //The following code is the inlined version of this code:
            //        for (int i = 1; i < CacheSize; i++)
            //        {
            //            Approximation[i] = interpolateLinear(i * mStepSize);
            //            t = (Approximation[i] - Approximation[i - 1]);
            //            Length += t.magnitude;
            //            ApproximationDistances[i] = Length;
            //            ApproximationT[i - 1] = t.normalized;
            //        }

            float mStepSize = 1f / newCacheSize;

            float lengthAccumulator = 0;
            Vector3 pStart = threadSafeLocalPosition;
            Vector3 pEnd = nextControlPoint.threadSafeLocalPosition;
            Vector3 tangent;
            for (int i = 1; i < newCacheSize; i++)
            {
                float localF = i * mStepSize;
                Approximation[i] = OptimizedOperators.LerpUnclamped(pStart, pEnd, localF);

                tangent.x = (Approximation[i].x - Approximation[i - 1].x);
                tangent.y = (Approximation[i].y - Approximation[i - 1].y);
                tangent.z = (Approximation[i].z - Approximation[i - 1].z);

                float tMagnitude = Mathf.Sqrt((float)(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z));
                lengthAccumulator += tMagnitude;
                ApproximationDistances[i] = lengthAccumulator;
                if ((double)tMagnitude > 9.99999974737875E-06)
                {
                    float oneOnMagnitude = 1 / tMagnitude;
                    ApproximationT[i - 1].x = tangent.x * oneOnMagnitude;
                    ApproximationT[i - 1].y = tangent.y * oneOnMagnitude;
                    ApproximationT[i - 1].z = tangent.z * oneOnMagnitude;
                }
                else
                {
                    ApproximationT[i - 1].x = 0;
                    ApproximationT[i - 1].y = 0;
                    ApproximationT[i - 1].z = 0;
                }
            }
            return lengthAccumulator;
        }

        #endregion

        internal void refreshOrientationNoneINTERNAL()
        {
            Array.Clear(ApproximationUp, 0, ApproximationUp.Length);
            lastProcessedLocalRotation = threadSafeLocalRotation;
        }

        internal void refreshOrientationStaticINTERNAL()
        {
            Vector3 firstUp = ApproximationUp[0] = getOrthoUp0INTERNAL();
            if (Approximation.Length > 1)
            {
                int cachedCachesize = CacheSize;
                Vector3 lastUp = ApproximationUp[cachedCachesize] = getOrthoUp1INTERNAL();
                float oneOnCachSize = 1f / cachedCachesize;
                for (int i = 1; i < cachedCachesize; i++)
                    ApproximationUp[i] = Vector3.SlerpUnclamped(firstUp, lastUp, i * oneOnCachSize);
            }

            lastProcessedLocalRotation = threadSafeLocalRotation;
        }

        /// <summary>
        /// Set each point's up as the initialUp rotated by the same rotation than the one that rotates initial tangent to the point's tangent
        /// </summary>
        /// <remarks>Does not handle swirl</remarks>
        /// <param name="initialUp"></param>
        internal void refreshOrientationDynamicINTERNAL(Vector3 initialUp)
        {
            int upsLength = ApproximationUp.Length;
            ApproximationUp[0] = initialUp;
            for (int i = 1; i < upsLength; i++)
            {
                //Inlined version of ups[i] = DTMath.ParallelTransportFrame(ups[i-1], tangents[i - 1], tangents[i]) and with less checks for performance reasons
                Vector3 tan0 = ApproximationT[i - 1];
                Vector3 tan1 = ApproximationT[i];
                //Inlined version of Vector3 A = Vector3.Cross(tan0, tan1);
                Vector3 A;
                {
                    A.x = tan0.y * tan1.z - tan0.z * tan1.y;
                    A.y = tan0.z * tan1.x - tan0.x * tan1.z;
                    A.z = tan0.x * tan1.y - tan0.y * tan1.x;
                }
                //Inlined version of float a = (float)Math.Atan2(A.magnitude, Vector3.Dot(tan0, tan1));
                float a = (float)Math.Atan2(
                    Math.Sqrt(A.x * A.x + A.y * A.y + A.z * A.z),
                    tan0.x * tan1.x + tan0.y * tan1.y + tan0.z * tan1.z);
                ApproximationUp[i] = Quaternion.AngleAxis(Mathf.Rad2Deg * a, A) * ApproximationUp[i - 1];
            }

            lastProcessedLocalRotation = threadSafeLocalRotation;
        }

        #endregion

        internal void ClearBoundsINTERNAL()
        {
            mBounds = null;
        }

        /// <summary>
        /// Gets Transform.up orthogonal to ApproximationT[0]
        /// </summary>
        internal Vector3 getOrthoUp0INTERNAL()
        {
            Vector3 u = threadSafeLocalRotation * Vector3.up;
            Vector3.OrthoNormalize(ref ApproximationT[0], ref u);
            return u;
        }

        private Vector3 getOrthoUp1INTERNAL()
        {
            CurvySplineSegment nextControlPoint = Spline.GetNextControlPoint(this);
            Quaternion nextRotation = nextControlPoint
                ? nextControlPoint.threadSafeLocalRotation
                : threadSafeLocalRotation;
            Vector3 u = nextRotation * Vector3.up;
            Vector3.OrthoNormalize(ref ApproximationT[CacheSize], ref u);
            return u;
        }

        internal void UnsetFollowUpWithoutDirtyingINTERNAL()
        {
            m_FollowUp = null;
            m_FollowUpHeading = ConnectionHeadingEnum.Auto;
        }

#if UNITY_EDITOR

#endif

        #region Gizmo drawing

        private static readonly Plane[] gizomTestCameraPlanes = new Plane[6];
        private static Vector3 gizomTestCamearPosition;
        private static Vector3 gizomTestCameraForward;
        private static float gizomTestFov;
        private static float gizomTestPixelWidth;
        private static float gizomTestPixelHeight;


        private void doGizmos(bool selected)
        {
            //OPTIM try multithreading some of the loops in this method. All loops have in them operations that unity forbids the usage of outside the main thread (drawline, worldtoscreen, ...). Maybe using Unity's jobs?
            if (CurvyGlobalManager.Gizmos == CurvySplineGizmos.None)
                return;

            Camera currentCamera = Camera.current;
            int cameraPixelWidth = currentCamera.pixelWidth;
            int cameraPixelHeight = currentCamera.pixelHeight;
            Transform cameraTransform = currentCamera.transform;
            Vector3 cameraPosition = cameraTransform.position;
            Vector3 cameraZDirection;
            Vector3 cameraXDirection;
            {
                Quaternion cameraRotation = cameraTransform.rotation;
                Vector3 direction;
                {
                    direction.x = 0;
                    direction.y = 0;
                    direction.z = 1;
                }
                cameraZDirection = cameraRotation * direction;

                {
                    direction.x = 1;
                    direction.y = 0;
                    direction.z = 0;
                }
                cameraXDirection = cameraRotation * direction;
            }
            Bounds bounds = Bounds;


            //Update gizomTestCameraPlanes if camera changed
            if (gizomTestCamearPosition != cameraPosition ||
                gizomTestCameraForward != cameraZDirection ||
                gizomTestPixelWidth != cameraPixelWidth ||
                gizomTestPixelHeight != cameraPixelHeight ||
                gizomTestFov != currentCamera.fieldOfView)
            {
                //Design Reading and writing static fields can be dangerous if this code is multi-threaded
                gizomTestCamearPosition = cameraPosition;
                gizomTestCameraForward = cameraZDirection;
                gizomTestPixelWidth = cameraPixelWidth;
                gizomTestPixelHeight = cameraPixelHeight;
                gizomTestFov = currentCamera.fieldOfView;
                GeometryUtility.CalculateFrustumPlanes(currentCamera, gizomTestCameraPlanes);
            }

            // Skip if the segment isn't in view
            if (!GeometryUtility.TestPlanesAABB(gizomTestCameraPlanes, bounds))
                return;

            CurvySpline spline = Spline;
            Transform splineTransform = spline.transform;
            Vector3 splineTransformLocalScale = splineTransform.localScale;
            Vector3 scale;
            {
                scale.x = 1 / splineTransformLocalScale.x;
                scale.y = 1 / splineTransformLocalScale.y;
                scale.z = 1 / splineTransformLocalScale.z;
            }
            Color splineGizmoColor = (selected) ? spline.GizmoSelectionColor : spline.GizmoColor;
            Vector3 transformPosition = transform.position;
            float cameraCenterWidth = cameraPixelWidth * 0.5f;
            float cameraCenterHeight = cameraPixelHeight * 0.5f;

            bool viewCurve = CurvyGlobalManager.ShowCurveGizmo;

            // Control Point
            if (viewCurve)
            {
                Gizmos.color = splineGizmoColor;
                float handleSize = DTUtility.GetHandleSize(transformPosition, currentCamera, cameraCenterWidth, cameraCenterHeight, cameraPosition, cameraZDirection, cameraXDirection);
                float cpGizmoSize = handleSize * (selected ? 1 : 0.7f) * CurvyGlobalManager.GizmoControlPointSize;

                if (spline.RestrictTo2D)
                    Gizmos.DrawCube(transformPosition, OptimizedOperators.Multiply(Vector3.one, cpGizmoSize));
                else
                    Gizmos.DrawSphere(transformPosition, cpGizmoSize);
            }

            //Remaining
            if (spline.IsControlPointASegment(this))
            {
                if (spline.Dirty)
                    spline.Refresh();

                Matrix4x4 initialGizmoMatrix = Gizmos.matrix;
                Matrix4x4 currentGizmoMatrix = Gizmos.matrix = splineTransform.localToWorldMatrix;

                //Spline lines
                if (viewCurve)
                {
                    float steps;
                    {
                        float camDistance = (cameraPosition.Subtraction(bounds.ClosestPoint(cameraPosition))).magnitude;

                        float df = Mathf.Clamp(camDistance, 1, 3000) / 3000;
                        df = (df < 0.01f) ? DTTween.SineOut(df, 0, 1) : DTTween.QuintOut(df, 0, 1);

                        steps = Mathf.Clamp((Length * CurvyGlobalManager.SceneViewResolution * 0.1f) / df, 1, 10000);
                    }
                    DrawGizmoLines(1 / steps);
                }

                //Approximations
                if (Approximation.Length > 0 && CurvyGlobalManager.ShowApproximationGizmo)
                {
                    Gizmos.color = spline.GizmoColor.Multiply(0.8f);
                    Vector3 size = OptimizedOperators.Multiply(0.1f, scale);
                    for (int i = 0; i < Approximation.Length; i++)
                    {
                        float handleSize = DTUtility.GetHandleSize(currentGizmoMatrix.MultiplyPoint3x4(Approximation[i]), currentCamera, cameraCenterWidth, cameraCenterHeight, cameraPosition, cameraZDirection, cameraXDirection);

                        Gizmos.DrawCube(Approximation[i], handleSize.Multiply(size));
                    }
                }

                //Orientation
                if (spline.Orientation != CurvyOrientation.None && ApproximationUp.Length > 0 && CurvyGlobalManager.ShowOrientationGizmo)
                {
                    Gizmos.color = CurvyGlobalManager.GizmoOrientationColor;
                    Vector3 orientationGizmoSize = scale.Multiply(CurvyGlobalManager.GizmoOrientationLength);

                    for (int i = 0; i < ApproximationUp.Length; i++)
                    {
                        Vector3 lineEnd;
                        lineEnd.x = Approximation[i].x + ApproximationUp[i].x * orientationGizmoSize.x;
                        lineEnd.y = Approximation[i].y + ApproximationUp[i].y * orientationGizmoSize.y;
                        lineEnd.z = Approximation[i].z + ApproximationUp[i].z * orientationGizmoSize.z;

                        Gizmos.DrawLine(Approximation[i], lineEnd);
                    }


                    if (spline.IsControlPointAnOrientationAnchor(this) && spline.Orientation == CurvyOrientation.Dynamic)
                    {
                        if (ApproximationUp.Length != 0)
                        {
                            Gizmos.color = CurvyGlobalManager.GizmoOrientationColor;
                            Vector3 u = ApproximationUp[0];
                            u.Set(u.x * scale.x, u.y * scale.y, u.z * scale.z);
                            Gizmos.DrawRay(Approximation[0],
                                CurvyGlobalManager.GizmoOrientationLength * 1.75f * u);
                        }
                    }
                }

                //Tangent
                if (ApproximationT.Length > 0 && CurvyGlobalManager.ShowTangentsGizmo)
                {
                    int segmentCacheSize = CacheSize;
                    float tangentSize = CurvyGlobalManager.GizmoOrientationLength;
                    for (int i = 0; i < ApproximationT.Length; i++)
                    {
                        //updating gizmo color
                        if (i == 0)
                            Gizmos.color = Color.blue;
                        else if (i == 1)
                            Gizmos.color = GizmoTangentColor;
                        else if (i == segmentCacheSize)
                            Gizmos.color = Color.black;

                        Vector3 lineEnd;
                        lineEnd.y = Approximation[i].y + ApproximationT[i].y * tangentSize;
                        lineEnd.z = Approximation[i].z + ApproximationT[i].z * tangentSize;
                        lineEnd.x = Approximation[i].x + ApproximationT[i].x * tangentSize;

                        Gizmos.DrawLine(Approximation[i], lineEnd);
                    }
                }
                Gizmos.matrix = initialGizmoMatrix;
            }

        }

        /// <summary>
        /// Draw gizmo lines representing the spline segment
        /// </summary>
        /// <param name="stepSize">The relative distance between the start and end of each line. Must be exclusively between 0 and 1</param>
        private void DrawGizmoLines(float stepSize)
        {
            CurvySpline spline = Spline;
            CurvyInterpolation splineInterpolation = spline.Interpolation;

#if CURVY_SANITY_CHECKS
            if (spline.Dirty)
                DTLog.LogWarning("Interpolate should not be called on segment of a dirty spline. Call CurvySpline.Refresh first", this);
            Assert.IsTrue(spline.IsControlPointASegment(this));
            Assert.IsTrue(spline.IsCpsRelationshipCacheValidINTERNAL);
            Assert.IsTrue(stepSize > 0);
            Assert.IsTrue(stepSize <= 1);
#endif
            if (splineInterpolation == CurvyInterpolation.Linear)
                Gizmos.DrawLine(Interpolate(0), Interpolate(1));
            else
            {
                Vector3 startPoint;
                if (splineInterpolation == CurvyInterpolation.BSpline)
                    startPoint = BSpline(spline.ControlPointsList, spline.SegmentToTF(this), spline.IsBSplineClamped, spline.Closed, spline.BSplineDegree, BSplineP0Array.Array);
                else
                    startPoint = threadSafeLocalPosition;

                //used only in BSplines for performance reasons
                bool isBSplineClamped = default;
                int bSplineDegree = default;
                ReadOnlyCollection<CurvySplineSegment> controlPoints = default;
                int controlPointsCount = default;
                float segmentTF = default;
                int n = default;
                int nPlus1 = default;
                int previousK = default;
                Vector3[] ps = default;
                int psCount = default;
                Vector3[] psCopy = default;
                SubArray<Vector3> psCopySubArray = default;
                if (splineInterpolation == CurvyInterpolation.BSpline)
                {
                    isBSplineClamped = spline.IsBSplineClamped;
                    bSplineDegree = spline.BSplineDegree;
                    controlPoints = spline.ControlPointsList;
                    segmentTF = spline.SegmentToTF(this);
                    controlPointsCount = controlPoints.Count;
                    n = BSplineHelper.GetBSplineN(controlPointsCount, bSplineDegree, spline.Closed);
                    nPlus1 = n + 1;
                    previousK = int.MinValue;
                    SubArray<Vector3> splinePsVector = BSplineP0Array;
                    ps = splinePsVector.Array;
                    psCount = splinePsVector.Count;
                    psCopySubArray = ArrayPools.Vector3.Allocate(psCount);
                    psCopy = psCopySubArray.Array;
                }

                for (float localF = 0; localF < 1; localF += stepSize)
                {
                    Vector3 interpolatedPoint;
                    {
                        Vector3 result;
                        //Inlined version of Interpolate, stripped from some code for performance reasons
                        //If you modify this, modify also the inlined version of this method in refreshCurveINTERNAL()
                        switch (splineInterpolation)
                        {
                            case CurvyInterpolation.BSpline:
                                {

                                    float tf = segmentTF + localF / spline.Count;
                                    BSplineHelper.GetBSplineUAndK(tf, isBSplineClamped, bSplineDegree, n, out float u, out int k);
                                    if (k != previousK)
                                    {
                                        GetBSplineP0s(controlPoints, controlPointsCount, bSplineDegree, k, ps);
                                        previousK = k;
                                    }
                                    Array.Copy(ps, 0, psCopy, 0, psCount);
                                    result = isBSplineClamped ? BSplineHelper.DeBoorClamped(bSplineDegree, k, u, nPlus1, psCopy) : BSplineHelper.DeBoorUnclamped(bSplineDegree, k, u, psCopy);
                                    break;
                                }
                            case CurvyInterpolation.CatmullRom:
                                {
                                    result = CurvySpline.CatmullRom(threadSafePreviousCpLocalPosition,
                                        threadSafeLocalPosition,
                                        threadSafeNextCpLocalPosition,
                                        cachedNextControlPoint.threadSafeNextCpLocalPosition,
                                        localF);
                                }
                                break;
                            case CurvyInterpolation.Bezier:
                                {
                                    result = CurvySpline.Bezier(threadSafeLocalPosition.Addition(HandleOut),
                                        threadSafeLocalPosition,
                                        threadSafeNextCpLocalPosition,
                                        threadSafeNextCpLocalPosition.Addition(cachedNextControlPoint.HandleIn),
                                        localF);
                                    break;
                                }
                            case CurvyInterpolation.TCB:
                                {
                                    float t0 = StartTension; float t1 = EndTension;
                                    float c0 = StartContinuity; float c1 = EndContinuity;
                                    float b0 = StartBias; float b1 = EndBias;

                                    if (!OverrideGlobalTension)
                                        t0 = t1 = mSpline.Tension;
                                    if (!OverrideGlobalContinuity)
                                        c0 = c1 = mSpline.Continuity;
                                    if (!OverrideGlobalBias)
                                        b0 = b1 = mSpline.Bias;

                                    result = CurvySpline.TCB(threadSafePreviousCpLocalPosition,
                                        threadSafeLocalPosition,
                                        threadSafeNextCpLocalPosition,
                                        cachedNextControlPoint.threadSafeNextCpLocalPosition,
                                        localF, t0, c0, b0, t1, c1, b1);
                                }
                                break;
                            default:
                                DTLog.LogError("[Curvy] Invalid interpolation value " + splineInterpolation, this);
                                result = startPoint;
                                break;
                        }

                        interpolatedPoint = result;
                    }

                    Gizmos.DrawLine(startPoint, interpolatedPoint);
                    startPoint = interpolatedPoint;
                }

                if (interpolation == CurvyInterpolation.BSpline)
                    ArrayPools.Vector3.Free(psCopySubArray);

                Vector3 endPoint;
                if (splineInterpolation == CurvyInterpolation.BSpline)
                    endPoint = BSpline(spline.ControlPointsList, spline.SegmentToTF(this, 1), spline.IsBSplineClamped, spline.Closed, spline.BSplineDegree, BSplineP0Array.Array);
                else
                    endPoint = threadSafeNextCpLocalPosition;
                ;
                Gizmos.DrawLine(startPoint, endPoint);
            }
        }
        #endregion

        /// <summary>
        /// Set the correct values to the thread safe local positions and rotation
        /// When multithreading, you can't access Transform in the not main threads. Here we cache that data so it is available for threads
        /// </summary>
        internal void PrepareThreadCompatibleDataINTERNAL(bool useFollowUp)
        {
            CurvySpline spline = Spline;
            CurvySplineSegment previousCP = spline.GetPreviousControlPoint(this);
            CurvySplineSegment nextCP = spline.GetNextControlPoint(this);

            //TODO: get rid of this the day you will be able to access transforms in threads
            threadSafeLocalPosition = cachedTransform.localPosition;
            threadSafeLocalRotation = cachedTransform.localRotation;

            //This isn't cached for thread compatibility, but for performance
            cachedNextControlPoint = nextCP;

            if (useFollowUp)
            {
                CurvySplineSegment followUpPreviousCP;
                bool hasFollowUp = FollowUp != null;
                if (hasFollowUp && ReferenceEquals(spline.FirstVisibleControlPoint, this))
                    followUpPreviousCP = CurvySpline.GetFollowUpHeadingControlPoint(FollowUp, this.FollowUpHeading);
                else
                    followUpPreviousCP = previousCP;
                CurvySplineSegment followUpNextCP;
                if (hasFollowUp && ReferenceEquals(spline.LastVisibleControlPoint, this))
                    followUpNextCP = CurvySpline.GetFollowUpHeadingControlPoint(FollowUp, this.FollowUpHeading);
                else
                    followUpNextCP = nextCP;

                if (followUpPreviousCP != null)
                {
                    threadSafePreviousCpLocalPosition = ReferenceEquals(followUpPreviousCP.Spline, spline) ?
                        followUpPreviousCP.cachedTransform.localPosition :
                        spline.transform.InverseTransformPoint(followUpPreviousCP.cachedTransform.position);
                }
                else
                    threadSafePreviousCpLocalPosition = threadSafeLocalPosition;

                if (followUpNextCP != null)
                {
                    threadSafeNextCpLocalPosition = ReferenceEquals(followUpNextCP.Spline, spline) ?
                        followUpNextCP.cachedTransform.localPosition :
                        spline.transform.InverseTransformPoint(followUpNextCP.cachedTransform.position);
                }
                else
                    threadSafeNextCpLocalPosition = threadSafeLocalPosition;
            }
            else
            {
                threadSafePreviousCpLocalPosition = ReferenceEquals(previousCP, null) == false ? previousCP.cachedTransform.localPosition :
                    threadSafeLocalPosition;

                threadSafeNextCpLocalPosition = ReferenceEquals(nextCP, null) == false ? nextCP.cachedTransform.localPosition :
                    threadSafeLocalPosition;
            }
        }

        /*! \endcond */
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySplineSegment_private.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySpline_private.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0f1fc37177eb11444bdb58be9d5bd79e
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using UnityEngine.Serialization;
using FluffyUnderware.DevTools.Extensions;
using System.Reflection;
using JetBrains.Annotations;
#if UNITY_EDITOR
using UnityEditor;
#endif
#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
using UnityEngine.Assertions;


namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Curvy Spline class
    /// </summary>
    public partial class CurvySpline : DTVersionedMonoBehaviour
    {
        #region ### Privates Fields ###

        #region ### Serialized fields ###

        #region --- General ---

        [Section("General", HelpURL = CurvySpline.DOCLINK + "curvyspline_general")]
        [Tooltip("Interpolation Method")]
        [SerializeField, FormerlySerializedAs("Interpolation")]
        private CurvyInterpolation m_Interpolation = CurvyGlobalManager.DefaultInterpolation;

        [Tooltip("Restrict Control Points to a local 2D plane")]
        [SerializeField]
        private bool m_RestrictTo2D;

        [Tooltip("The local 2D plane to restrict the spline's control points to")]
        [SerializeField]
        [FieldCondition(nameof(RestrictTo2D), true)]
        [FieldAction("CBCheck2DPlanar")]
        private CurvyPlane restricted2DPlane = CurvyPlane.XY;

        [SerializeField, FormerlySerializedAs("Closed")]
        private bool m_Closed;

        [FieldCondition(nameof(CanHaveManualEndCp), Action = ActionAttribute.ActionEnum.Enable)]
        [Tooltip("Handle End Control Points automatically?")]
        [SerializeField, FormerlySerializedAs("AutoEndTangents")]
        private bool m_AutoEndTangents = CurvySplineDefaultValues.AutoEndTangents;

        [Tooltip("Orientation Flow")]
        [SerializeField, FormerlySerializedAs("Orientation")]
        private CurvyOrientation m_Orientation = CurvySplineDefaultValues.Orientation;

        #endregion

        #region --- Bezier Options ---

        [Section("Global Bezier Options", HelpURL = CurvySpline.DOCLINK + "curvyspline_bezier")]
        [GroupCondition(nameof(m_Interpolation), CurvyInterpolation.Bezier)]
        [RangeEx(0, 1, "Default Distance %", "Handle length by distance to neighbours")]
        [SerializeField]
        private float m_AutoHandleDistance = CurvySplineDefaultValues.AutoHandleDistance;

        #endregion

        #region --- TCB Options ---

        [Section("Global TCB Options", HelpURL = CurvySpline.DOCLINK + "curvyspline_tcb")]
        [GroupCondition(nameof(m_Interpolation), CurvyInterpolation.TCB)]
        [GroupAction("TCBOptionsGUI", Position = ActionAttribute.ActionPositionEnum.Below)]
        [SerializeField, FormerlySerializedAs("Tension")]
        private float m_Tension;

        [SerializeField, FormerlySerializedAs("Continuity")]
        private float m_Continuity;

        [SerializeField, FormerlySerializedAs("Bias")]
        private float m_Bias;
        #endregion

        #region --- B-Spline Options ---

        [Section("B-Spline Options", HelpURL = CurvySpline.DOCLINK + "curvyspline_bspline")]
        [GroupCondition(nameof(m_Interpolation), CurvyInterpolation.BSpline)]
        [RangeEx(minBSplineDegree, nameof(MaxBSplineDegree), "Degree", "The degree of the piecewise polynomial functions.\nIs in the range [2; control points count - 1]")]
        [SerializeField]
        private int bSplineDegree = CurvySplineDefaultValues.BSplineDegree;


        [FieldCondition(nameof(CanBeClamped), Action = ActionAttribute.ActionEnum.Enable)]
        [Label("Clamped", "Make the curve pass through the first and last control points by increasing the multiplicity of the first and last knots.\n\nIn technical terms, when this parameter is true, the knot vector is [0, 0, ...,0, 1, 2, ..., N-1, N, N, ..., N]. When false, it is [0, 1, 2, ..., N-1, N]")]
        [SerializeField]
        private bool isBSplineClamped = CurvySplineDefaultValues.IsBSplineClamped;

        #endregion

        #region --- Advanced Settings ---

        [Section("Advanced Settings", HelpURL = CurvySpline.DOCLINK + "curvyspline_advanced")]
        [FieldAction("ShowGizmoGUI", Position = ActionAttribute.ActionPositionEnum.Above)]
        [Label("Color", "Gizmo color")]
        [SerializeField]
        private Color m_GizmoColor = CurvyGlobalManager.DefaultGizmoColor;

        [FieldAction("CheckGizmoColor", Position = ActionAttribute.ActionPositionEnum.Above)]
        [FieldAction("CheckGizmoSelectionColor", Position = ActionAttribute.ActionPositionEnum.Below)]
        [Label("Active Color", "Selected Gizmo color")]
        [SerializeField]
        private Color m_GizmoSelectionColor = CurvyGlobalManager.DefaultGizmoSelectionColor;

        [RangeEx(1, 100)]
        [SerializeField, FormerlySerializedAs("Granularity"), Tooltip("Defines how densely the cached points are. When the value is 100, the number of cached points per world distance unit is equal to the spline's MaxPointsPerUnit")]
        private int m_CacheDensity = CurvySplineDefaultValues.CacheDensity;
        [SerializeField, Tooltip("The maximum number of sampling points per world distance unit. Sampling is used in caching or shape extrusion for example")]
        private float m_MaxPointsPerUnit = CurvySplineDefaultValues.MaxPointsPerUnit;
        [SerializeField, Tooltip("Use a GameObject pool at runtime")]
        private bool m_UsePooling = CurvySplineDefaultValues.UsePooling;
        [SerializeField, Tooltip("Use threading where applicable. Threading is is currently not supported when targetting WebGL and Universal Windows Platform")]
        private bool m_UseThreading;
        [Tooltip("Refresh when Control Point position change?")]
        [SerializeField, FormerlySerializedAs("AutoRefresh")]
        private bool m_CheckTransform = CurvySplineDefaultValues.CheckTransform;
        [SerializeField] private CurvyUpdateMethod m_UpdateIn = CurvySplineDefaultValues.UpdateIn;
        #endregion

        #region --- Events ---

        /*! \cond PRIVATE */

        [Group("Events", Expanded = false, Sort = 1000, HelpURL = DOCLINK + "curvyspline_events")]
        [SortOrder(0)]
        [SerializeField]
        protected CurvySplineEvent m_OnRefresh = new CurvySplineEvent();
        [Group("Events", Sort = 1000)]
        [SortOrder(1)]
        [SerializeField]
        protected CurvySplineEvent m_OnAfterControlPointChanges = new CurvySplineEvent();
        [Group("Events", Sort = 1000)]
        [SortOrder(2)]
        [SerializeField]
        protected CurvyControlPointEvent m_OnBeforeControlPointAdd = new CurvyControlPointEvent();
        [Group("Events", Sort = 1000)]
        [SortOrder(3)]
        [SerializeField]
        protected CurvyControlPointEvent m_OnAfterControlPointAdd = new CurvyControlPointEvent();
        [Group("Events", Sort = 1000)]
        [SortOrder(4)]
        [SerializeField]
        protected CurvyControlPointEvent m_OnBeforeControlPointDelete = new CurvyControlPointEvent();

        /*! \endcond */

        #endregion

        #endregion

        private bool mIsInitialized;

        private bool isStarted;
        private bool sendOnRefreshEventNextUpdate;
        private readonly object controlPointsRelationshipCacheLock = new object();
#if UNITY_EDITOR
        private bool transformChildrenChanged;
        private bool syncHierarchyFromSplineNeeded;
#endif

        //OPTIM Instead of having a segments list, use the controlPointsList, while providing the methods to convert from a segment index to a control point index.
        /// <summary>
        /// Controlpoints that start a valid spline segment
        /// </summary>
        private readonly List<CurvySplineSegment> mSegments = new List<CurvySplineSegment>();
        /// <summary>
        /// Read-only version of <see cref="controlPoints"/>
        /// </summary>
        private ReadOnlyCollection<CurvySplineSegment> readOnlyControlPoints;

        private float length = -1;
        private int mCacheSize = -1;
        private Bounds? mBounds;
        private bool mDirtyCurve;
        private bool mDirtyOrientation;
        private readonly HashSet<CurvySplineSegment> dirtyControlPointsMinimalSet = new HashSet<CurvySplineSegment>();

        private readonly List<CurvySplineSegment> dirtyCpsExtendedList = new List<CurvySplineSegment>();
        //DESIGN I think allControlPointsAreDirty can be removed, and related code can just fill dirtyControlPointsMinimalSet with all control points instead. Check that perfs lose is not significant before doing so.
        private bool allControlPointsAreDirty;
        //TODO mThreadWorker is disposable. CurvySpline should dispose it. See rule CA1001
        //https://docs.microsoft.com/en-us/visualstudio/code-quality/ca1001-types-that-own-disposable-fields-should-be-disposable?view=vs-2019
        private readonly ThreadPoolWorker<CurvySplineSegment> mThreadWorker = new ThreadPoolWorker<CurvySplineSegment>();

        //reusable events
        private readonly CurvySplineEventArgs defaultSplineEventArgs;
        private readonly CurvyControlPointEventArgs defaultAddAfterEventArgs;
        private readonly CurvyControlPointEventArgs defaultDeleteEventArgs;

        /// <summary>
        /// ControlPointsDistances[i] is equal to ControlPoints[i].Distance. ControlPointsDistances exists only to make search time shorter when searching for a Cp based on its Distance
        /// </summary>
        private float[] controlPointsDistances = new float[0];

        private readonly Action<CurvySplineSegment, int, int> refreshCurveAction;

#if CURVY_SANITY_CHECKS
        private int sanityErrorLogsThisFrame;
        private int sanityWaringLogsThisFrame;
#endif

        #region Keeping track of transform's change

        /// <summary>
        /// The global position of the spline the last time it was checked. Checks are done at least once a frame.
        /// </summary>
        private Vector3 lastProcessedPosition;
        /// <summary>
        /// The global rotation of the spline the last time it was checked. Checks are done at least once a frame.
        /// </summary>
        private Quaternion lastProcessedRotation;
        /// <summary>
        /// The global scale of the spline the last time it was checked. Checks are done at least once a frame.
        /// </summary>
        private Vector3 lastProcessedScale;
        /// <summary>
        /// True if the global position, rotation or scale of the spline has changed this frame
        /// </summary>
        private bool globalCoordinatesChangedThisFrame;

        #endregion


        #region ControlPoints relastionship cache

        private bool isCpsRelationshipCacheValid;
        private CurvySplineSegment firstSegment;
        private CurvySplineSegment lastSegment;
        private CurvySplineSegment firstVisibleControlPoint;
        private CurvySplineSegment lastVisibleControlPoint;

        #endregion

        #endregion


        #region ### Unity Callbacks ###
        /*! \cond UNITY */
#if UNITY_EDITOR
        private void OnValidate()
        {
            //Debug.Log("OnValidate " + name);

            Closed = m_Closed;
            Interpolation = m_Interpolation;
            AutoEndTangents = m_AutoEndTangents;
            MaxPointsPerUnit = m_MaxPointsPerUnit;
            BSplineDegree = bSplineDegree;

            InvalidateControlPointsRelationshipCacheINTERNAL();
            SetDirtyAll(SplineDirtyingType.Everything, true);
        }
#endif

        private void Awake()
        {
            cachedTransform = transform;

            //Debug.Log("Awake " + name);

            if (UsePooling)
            {
                //Create the CurvyGlobalManager if not existing already
                _ = CurvyGlobalManager.Instance;
            }
        }

        private void OnEnable()
        {
            cachedTransform = transform;

            SyncSplineFromHierarchy();
#if UNITY_EDITOR
            EditorApplication.update += EditorUpdate;
#endif
            if (isStarted)
            {
                bool processedDirtyCps = Initialize();
                if (processedDirtyCps)
                    OnRefreshEvent(defaultSplineEventArgs);

            }
        }

        /// <summary>
        /// Initialize the spline. This is called automatically by Unity at the first frame.
        /// The only situation I see where you will need to call it manually is if you instantiate a CurvySpline via Unity API, and need to use it the same frame before Unity calls Start() on it the next frame.
        /// </summary>
        public void Start()
        {
            //Debug.Log("Start");
            if (isStarted == false)
            {
                bool processedDirtyCps = Initialize();
                isStarted = true;
                if (processedDirtyCps)
                    OnRefreshEvent(defaultSplineEventArgs);
            }
        }

        private void OnDisable()
        {
            //Debug.Log("OnDisable " + name);
            mIsInitialized = false;
#if UNITY_EDITOR
            EditorApplication.update -= EditorUpdate;
#endif
        }

        private void OnDestroy()
        {
            //BUG? Why do we have that realDestroy boolean? Why not always do the same thing? This might hide something bad
            //When asked about this jake said:
            //That was quite a dirty hack as far as I remember, to counter issues with Unity's serialization
            //TBH I'm not sure if those issues still are present, so you might want to see if it's working without it now.
            //Debug.Log("OnDestroy " + name);
            bool realDestroy = true;
#if UNITY_EDITOR
            if (EditorApplication.isPlayingOrWillChangePlaymode && !EditorApplication.isPlaying)
                realDestroy = false;
#endif
            if (realDestroy)
            {
                if (UsePooling && Application.isPlaying)
                {
                    CurvyGlobalManager curvyGlobalManager = CurvyGlobalManager.Instance;
                    if (curvyGlobalManager != null)
                        for (int i = 0; i < ControlPointCount; i++)
                            curvyGlobalManager.ControlPointPool.Push(ControlPoints[i]);
                }
                else
                    mThreadWorker.Dispose();
            }
            ClearControlPoints();
            isStarted = false;
        }

#if UNITY_EDITOR
        private void OnTransformChildrenChanged()
        {
            transformChildrenChanged = true;
        }
#endif


        virtual protected void Reset()
        {
            //Debug.Log("Reset " + name);

            Interpolation = CurvyGlobalManager.DefaultInterpolation;
            RestrictTo2D = false;
            AutoHandleDistance = 0.39f;
            Closed = false;
            AutoEndTangents = CurvySplineDefaultValues.AutoEndTangents;
            // Orientation
            Orientation = CurvySplineDefaultValues.Orientation;
            // Advanced
            GizmoColor = CurvyGlobalManager.DefaultGizmoColor;
            GizmoSelectionColor = CurvyGlobalManager.DefaultGizmoSelectionColor;
            CacheDensity = CurvySplineDefaultValues.CacheDensity;
            MaxPointsPerUnit = CurvySplineDefaultValues.MaxPointsPerUnit;
            CheckTransform = CurvySplineDefaultValues.CheckTransform;
            // TCB
            Tension = 0;
            Continuity = 0;
            Bias = 0;
            BSplineDegree = CurvySplineDefaultValues.BSplineDegree;
            IsBSplineClamped = CurvySplineDefaultValues.IsBSplineClamped;
            SyncSplineFromHierarchy();
        }

        private void Update()
        {
#if UNITY_EDITOR
            if (syncHierarchyFromSplineNeeded)
            {
                syncHierarchyFromSplineNeeded = false;
                SyncHierarchyFromSpline();
            }
#endif
#if CURVY_SANITY_CHECKS
            if (Application.isPlaying)
            {
                sanityWaringLogsThisFrame = 0;
                sanityErrorLogsThisFrame = 0;
            }
#endif

            if (Application.isPlaying && UpdateIn == CurvyUpdateMethod.Update)
                DoUpdate();
        }

        private void LateUpdate()
        {
            if (Application.isPlaying && UpdateIn == CurvyUpdateMethod.LateUpdate)
                DoUpdate();
        }

        private void FixedUpdate()
        {
            if (Application.isPlaying && UpdateIn == CurvyUpdateMethod.FixedUpdate)
                DoUpdate();
        }
        /*! \endcond */
        #endregion

        #region ### Privates & Internals ###
        /*! \cond PRIVATE */

        private const float MinimalMaxPointsPerUnit = 0.0001f;
        /// <summary>
        /// The maximal size of the cache of a spline's segment
        /// </summary>
        private const float MaxSegmentCacheSize = 1000000;

        private static readonly string InvalidCPErrorMessage = "[Curvy] Method called with a control point '{0}' that is not part of the current spline '{1}'";

#if CURVY_SANITY_CHECKS
        /// <summary>
        /// Returns isCpsRelationshipCacheValid. Getter was created just for the sake of some sanity checks
        /// </summary>
        internal bool IsCpsRelationshipCacheValidINTERNAL
        {
            get { return isCpsRelationshipCacheValid; }
        }
#endif

        //cachedTransform in CurvySplineSegment is subject to an issue in Unity that leads to a bug. Read its comment to understand what it is. The same issue applies to CurvySpline, but does not lead to a known bug. So just as a precaution, I am avoiding the issue here too
#if (UNITY_2019_1_OR_NEWER)
        private Transform cachedTransform;
#else
        private Transform _cachedTransform;
        private Transform cachedTransform
        {
            get
            {
                if (ReferenceEquals(_cachedTransform, null))
                    _cachedTransform = transform;
                return _cachedTransform;
            }
            set
            {
                _cachedTransform = value;
            }
        }
#endif

        /// <summary>
        /// Access the list of Segments
        /// </summary>
        /// <remarks>The returned list should not be modified</remarks>
        private List<CurvySplineSegment> Segments
        {
            get
            {
                if (isCpsRelationshipCacheValid == false)
                    RebuildControlPointsRelationshipCache(true);
                return mSegments;
            }
        }

        private const int minBSplineDegree = 2;//update CurvySplineDefaultValues.BSplineDegree and documentation/tooltip of IsBSplineClamped if you modify this
        private int MaxBSplineDegree => Mathf.Max(minBSplineDegree, ControlPoints.Count - 1);

#if UNITY_EDITOR
        public static int _newSelectionInstanceIDINTERNAL; // Editor Bridge helper to determine new selection after object deletion
#endif

#if CONTRACTS_FULL
        [ContractInvariantMethod]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "Required for code contracts.")]
        private void ObjectInvariant()
        {
            Contract.Invariant(MaxPointsPerUnit.IsANumber());
            Contract.Invariant(MaxPointsPerUnit > 0);

            //TODO CONTRACT reactivate these if you find a way to call GetSegmentIndex and IsSegment without modifying the cache
            //Contract.Invariant(Contract.ForAll(Segments, s => GetSegmentIndex(s) == Segments.IndexOf(s)));
            //Contract.Invariant(Contract.ForAll(Segments, s => IsSegment(s)));

            //TODO CONTRACT more code contracts
            Contract.Invariant(Contract.ForAll(ControlPoints, cp => cp.Spline == this));
        }
#endif

        private bool Initialize()
        {
            SetDirtyAll(SplineDirtyingType.Everything, false);
            bool processedDirtyCps = ProcessDirtyControlPoints();
            UpdatedLastProcessedGlobalCoordinates();
            mIsInitialized = true;
            return processedDirtyCps;
        }

#if CURVY_SANITY_CHECKS

        [System.Diagnostics.Conditional("UNITY_ASSERTIONS")]
        private void DoSanityChecks()
        {
            const int limit = 20;
            if (!IsInitialized)
            {
                if (sanityErrorLogsThisFrame < limit)
                {
                    if (sanityErrorLogsThisFrame == limit - 1)
                        DTLog.LogError("[Curvy] Too many errors to display.", this);
                    else
                        DTLog.LogError("[Curvy] Calling public method on non initialized spline.", this);
                    sanityErrorLogsThisFrame++;
                }
            }
            else if (Dirty)
            {
                if (sanityWaringLogsThisFrame < limit)
                {
                    if (sanityWaringLogsThisFrame == limit - 1)
                        DTLog.LogWarning("[Curvy] Too many warnings to display.", this);
                    else
                        DTLog.LogWarning(string.Format(System.Globalization.CultureInfo.InvariantCulture, "[Curvy] Calling public method on a dirty spline. The returned result will not be up to date. Either refresh the spline manually by calling Refresh(), or wait for it to be refreshed automatically at the next {0} call", UpdateIn.ToString()), this);
                    sanityWaringLogsThisFrame++;
                }
            }
        }
#endif

#if UNITY_EDITOR
        private void EditorUpdate()
        {
#if CURVY_SANITY_CHECKS
            if (Application.isPlaying == false)
            {
                sanityWaringLogsThisFrame = 0;
                sanityErrorLogsThisFrame = 0;
            }
#endif
            if (Application.isPlaying == false && IsInitialized)
            {
                if (syncHierarchyFromSplineNeeded)
                {
                    syncHierarchyFromSplineNeeded = false;
                    SyncHierarchyFromSpline();
                }
                DoUpdate();
            }
        }
#endif


        private void DoUpdate()
        {
#if UNITY_EDITOR
            if (transformChildrenChanged)
            {
                transformChildrenChanged = false;
                if (ControlPoints.Count != GetComponentsInChildren<CurvySplineSegment>().Length)
                {
                    //The SyncSplineFromHierarchy is meant only to handle the case where the user adds or removes a contol point from the editor hierarchy. The addition or removal of a control point through Curvy's API is handled efficiently elsewhere. I said efficiently because, contrary to SyncSplineFromHierarchy, it does not lead to rebuilding the whole spline.
                    //There is in fact another case where the following code would be useful, which is removing a CP's gameobject through Unity's API. In this case, even if UNITY_EDITOR == false, the syncing would be necessary. But, to not impact the performances of the common user case (using Curvy API to modify CPs), I decided to not handle this case. Removing cps, or adding them, via Unity API is not supported.
                    SyncSplineFromHierarchy();
                }
            }
#endif

            int controlPointCount = ControlPointCount;
            for (int index = 0; index < controlPointCount; index++)
            {
                CurvySplineSegment controlPoint = ControlPoints[index];
                if (controlPoint.AutoBakeOrientation && controlPoint.ApproximationUp.Length > 0)
                    controlPoint.BakeOrientationToTransform();
            }

            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);

            globalCoordinatesChangedThisFrame = false;
            if (cachedTransform.hasChanged)
            {
                cachedTransform.hasChanged = false;

                //This additional test is done since transform.hasChanged is true even when changing parent with no change in both local and global coordinates. And even a change in local coordinates doesn't interest us, since bounds computation only need global coordinates
                if (cachedTransform.position.NotApproximately(lastProcessedPosition) || cachedTransform.rotation.DifferentOrientation(lastProcessedRotation) || cachedTransform.lossyScale != lastProcessedScale)
                {
                    globalCoordinatesChangedThisFrame = true;
                    UpdatedLastProcessedGlobalCoordinates();

                    mBounds = null;
                    //OPTIM Right now, transform change lead to recomputing the bounds in world space. This can be avoided by computing the bounds in local space only when the spline is modified, and transform that to the world space here, where a spline transform has changed.
                    for (int i = 0; i < controlPointCount; i++)
                        ControlPoints[i].ClearBoundsINTERNAL();
                }

            }

            if ((CheckTransform || !Application.isPlaying) && (allControlPointsAreDirty == false))
                for (int i = 0; i < controlPointCount; i++)
                {
                    CurvySplineSegment currentControlPoint = ControlPoints[i];
                    bool dirtyCurve = currentControlPoint.HasUnprocessedLocalPosition;
                    if (dirtyCurve || currentControlPoint.HasUnprocessedLocalOrientation && currentControlPoint.OrientatinInfluencesSpline)
                        currentControlPoint.Spline.SetDirty(currentControlPoint, dirtyCurve == false ? SplineDirtyingType.OrientationOnly : SplineDirtyingType.Everything);
                }

            if (Dirty)
                Refresh();
            else if (sendOnRefreshEventNextUpdate)
                OnRefreshEvent(defaultSplineEventArgs);

            sendOnRefreshEventNextUpdate = false;

            if (globalCoordinatesChangedThisFrame && OnGlobalCoordinatesChanged != null)
                OnGlobalCoordinatesChanged.Invoke(this);
        }

        /// <summary>
        /// are manual start/end CP's allowed?
        /// </summary>
        private bool CanHaveManualEndCp()
        {
            return !Closed && (Interpolation == CurvyInterpolation.CatmullRom || Interpolation == CurvyInterpolation.TCB);
        }

        private bool CanBeClamped()
        {
            return !Closed && (Interpolation == CurvyInterpolation.BSpline);
        }

#if UNITY_EDITOR


        /// <summary>
        /// Get the correct control point name that should be displayed in the hierarchy
        /// </summary>
        /// <param name="controlPointIndex"></param>
        static private string GetControlPointName(short controlPointIndex)
        {
            if (controlPointIndex < CachedControlPointsNameCount)
                return controlPointNames[controlPointIndex];

            return MakeControlPointName(controlPointIndex);
        }

        private static string[] GetControlPointNames()
        {
            string[] names = new string[CachedControlPointsNameCount];
            for (short i = 0; i < CachedControlPointsNameCount; i++)
                names[i] = MakeControlPointName(i);
            return names;
        }

        static private string MakeControlPointName(short controlPointIndex)
        {
            return "CP" + controlPointIndex.ToString("D4", System.Globalization.CultureInfo.InvariantCulture);
        }
#endif

        /// <summary>
        /// Marks a Control Point to get recalculated on next call to Refresh(). Will also mark connected control points if dirtyConnection is set to true.  Will also mark control points that depend on the current one through the Follow-Up feature.
        /// </summary>
        /// <param name="controlPoint">the Control Point to refresh</param>
        /// <param name="dirtyingType">Defines what aspect should be dirtied</param>
        /// <param name="previousControlPoint"></param>
        /// <param name="nextControlPoint"></param>
        /// <param name="ignoreConnectionOfInputControlPoint">If true, this method will not mark as dirty the control points connected to the "controlPoint" parameter</param>
        private void SetDirty(CurvySplineSegment controlPoint, SplineDirtyingType dirtyingType, CurvySplineSegment previousControlPoint, CurvySplineSegment nextControlPoint, bool ignoreConnectionOfInputControlPoint)
        {
            if (ReferenceEquals(this, controlPoint.Spline) == false)
                throw new ArgumentException(String.Format(InvalidCPErrorMessage, controlPoint, name));

#if CURVY_LOG_DIRTYING
            Debug.Log("Set Dirty CP " + dirtyingType);
#endif
            if (ignoreConnectionOfInputControlPoint == false && controlPoint.Connection)
            {
                //Setting all connected CPs is a bit overkill, but at least, you are sure to avoid the multitude of Connections related bugs, plus simplifies the code a lot. You might try to OPTIM by dirtying only the relevant connected CPs, and only in the relevant scenarios, but (seeing the old code that I removed) it is a very dangerous optimization, and you can surely optimize other stuff that will take less time to optimize, and can generate less bugs
                ReadOnlyCollection<CurvySplineSegment> connectionControlPoints = controlPoint.Connection.ControlPointsList;
                for (int index = 0; index < connectionControlPoints.Count; index++)
                {
                    CurvySplineSegment connectedControlPoint = connectionControlPoints[index];
                    CurvySpline connectedSpline = connectedControlPoint.Spline;
                    if (connectedSpline)
                    {
                        connectedSpline.dirtyControlPointsMinimalSet.Add(connectedControlPoint);
                        connectedSpline.SetDirtyingFlags(dirtyingType);
                    }
                }
#if CURVY_SANITY_CHECKS
                if (connectionControlPoints.Contains(controlPoint) == false)
                    DTLog.LogError("[Curvy] SetDirty couldn't find the dirtying control point in the connection.", this);
#endif
            }
            else
            {
                dirtyControlPointsMinimalSet.Add(controlPoint);
                SetDirtyingFlags(dirtyingType);
            }

            //Dirty CPs that could depend on the current CP through the Follow-Up feature
            {
                if (previousControlPoint && previousControlPoint.Connection)
                {
                    ReadOnlyCollection<CurvySplineSegment> connectionControlPoints = previousControlPoint.Connection.ControlPointsList;
                    for (int index = 0; index < connectionControlPoints.Count; index++)
                    {
                        CurvySplineSegment connectedControlPoint = connectionControlPoints[index];
                        CurvySpline connectedSpline = connectedControlPoint.Spline;
                        if (connectedSpline && connectedControlPoint.FollowUp == previousControlPoint)
                        {
                            connectedSpline.dirtyControlPointsMinimalSet.Add(connectedControlPoint);
                            connectedSpline.SetDirtyingFlags(dirtyingType);
                        }
                    }
                }

                if (nextControlPoint && nextControlPoint.Connection)
                {
                    ReadOnlyCollection<CurvySplineSegment> connectionControlPoints = nextControlPoint.Connection.ControlPointsList;
                    for (int index = 0; index < connectionControlPoints.Count; index++)
                    {
                        CurvySplineSegment connectedControlPoint = connectionControlPoints[index];
                        CurvySpline connectedSpline = connectedControlPoint.Spline;
                        if (connectedSpline && connectedControlPoint.FollowUp == nextControlPoint)
                        {
                            connectedSpline.dirtyControlPointsMinimalSet.Add(connectedControlPoint);
                            connectedSpline.SetDirtyingFlags(dirtyingType);
                        }
                    }
                }
            }
        }

        private void SetDirtyingFlags(SplineDirtyingType dirtyingType)
        {
            mDirtyCurve = mDirtyCurve || dirtyingType == SplineDirtyingType.Everything;
            mDirtyOrientation = true;

            if (mDirtyCurve)
            {
                mCacheSize = -1;
                length = -1;
                mBounds = null;
            }
        }

        private void ReverseControlPoints()
        {
            ControlPoints.Reverse();
            InvalidateControlPointsRelationshipCacheINTERNAL();
            SetDirtyAll(SplineDirtyingType.Everything, true);
        }

        static private short GetNextControlPointIndex(short controlPointIndex, bool isSplineClosed, int controlPointsCount)
        {
            if (isSplineClosed && controlPointsCount <= 1)
                return -1;
            if (controlPointIndex + 1 < controlPointsCount)
                return (short)(controlPointIndex + 1);
            return (short)(isSplineClosed ? 0 : -1);
        }

        static private short GetPreviousControlPointIndex(short controlPointIndex, bool isSplineClosed, int controlPointsCount)
        {
            if (isSplineClosed && controlPointsCount <= 1)
                return -1;
            if (controlPointIndex - 1 >= 0)
                return (short)(controlPointIndex - 1);
            return (short)(isSplineClosed ? controlPointsCount - 1 : -1);
        }

        //OPTIM should you use this instead of the isSegment poperties in ControlPointExtrinsicProperties?
        private static bool IsControlPointASegment(int controlPointIndex, int controlPointCount, bool isClosed, bool notAutoEndTangentsAndIsCatmullRomOrTCB, bool isBSpline, int bSplineDegree)
        {
#if CONTRACTS_FULL
            Contract.Requires(controlPointIndex >= 0 && controlPointIndex < ControlPointCount);
            Contract.Requires(bSplineDegree >= 0);
#endif

            return (isBSpline == false || bSplineDegree < controlPointCount)
                   &&
                   (isClosed && controlPointCount > 1
                     || (notAutoEndTangentsAndIsCatmullRomOrTCB
                         ? controlPointIndex > 0 && controlPointIndex < controlPointCount - 2
                         : controlPointIndex < controlPointCount - 1));
        }

        #region Modifying control points list
        private void AddControlPoint(CurvySplineSegment item)
        {
            ControlPoints.Add(item);
            item.LinkToSpline(this);
            InvalidateControlPointsRelationshipCacheINTERNAL();
            short previousControlPointIndex = GetPreviousControlPointIndex((short)(ControlPoints.Count - 1), Closed, ControlPoints.Count);
            short nextControlPointIndex = GetNextControlPointIndex((short)(ControlPoints.Count - 1), Closed, ControlPoints.Count);
            SetDirty(item, SplineDirtyingType.Everything,
                previousControlPointIndex != -1 ? ControlPoints[previousControlPointIndex] : null,
                nextControlPointIndex != -1 ? ControlPoints[nextControlPointIndex] : null, false);
        }

        /// <summary>
        /// Adds a control point at a specific index
        /// </summary>
        /// <param name="index"></param>
        /// <param name="item"></param>
        private void InsertControlPoint(int index, CurvySplineSegment item)
        {
            ControlPoints.Insert(index, item);
            item.LinkToSpline(this);
            InvalidateControlPointsRelationshipCacheINTERNAL();
            //Dirtying
            {
                short previousControlPointIndex = GetPreviousControlPointIndex((short)index, Closed, ControlPoints.Count);
                short nextControlPointIndex = GetNextControlPointIndex((short)index, Closed, ControlPoints.Count);
                SetDirty(item, SplineDirtyingType.Everything,
                    previousControlPointIndex == -1 ? null : ControlPoints[previousControlPointIndex],
                    nextControlPointIndex == -1 ? null : ControlPoints[nextControlPointIndex], false);
            }
        }

        private void RemoveControlPoint(CurvySplineSegment item)
        {
            int indexOftItem = GetControlPointIndex(item);
            //Dirtying
            if (ControlPoints.Count == 1)//Removing the last CP
                SetDirtyAll(SplineDirtyingType.Everything, true);
            else
            {
                short previousControlPointIndex = GetPreviousControlPointIndex((short)indexOftItem, Closed, ControlPoints.Count);
                short nextControlPointIndex = GetNextControlPointIndex((short)indexOftItem, Closed, ControlPoints.Count);
                if (previousControlPointIndex != -1)
                    SetDirty(ControlPoints[previousControlPointIndex], SplineDirtyingType.Everything);
                if (nextControlPointIndex != -1)
                    SetDirty(ControlPoints[nextControlPointIndex], SplineDirtyingType.Everything);
            }
            ControlPoints.RemoveAt(indexOftItem);
            dirtyControlPointsMinimalSet.Remove(item);
            if (item.Spline == this)
                item.UnlinkFromSpline();
            InvalidateControlPointsRelationshipCacheINTERNAL();
        }

        private void ClearControlPoints()
        {
            SetDirtyAll(SplineDirtyingType.Everything, true);
            for (int index = 0; index < ControlPoints.Count; index++)
            {
                CurvySplineSegment controlPoint = ControlPoints[index];
                if (controlPoint && //controlPoint can be null if you create a spline via the pen tool, and then undo it
                    controlPoint.Spline == this) //This if is to avoid the case where the code, executed because of a change in the number of children, will unlink a CP that has been moved to another spline through the hierarchy editor.
                    controlPoint.UnlinkFromSpline();
            }
            ControlPoints.Clear();
            dirtyControlPointsMinimalSet.Clear();
            InvalidateControlPointsRelationshipCacheINTERNAL();
        }
        #endregion

        #region ControlPoints relastionship cache

        internal void InvalidateControlPointsRelationshipCacheINTERNAL()
        {
            if (isCpsRelationshipCacheValid)
            {
                lock (controlPointsRelationshipCacheLock)
                {
                    isCpsRelationshipCacheValid = false;
                    firstSegment = lastSegment = firstVisibleControlPoint = lastVisibleControlPoint = null;
                }
            }
        }

        /// <summary>
        /// Is not thread safe
        /// </summary>
        /// <param name="fixNonCoherentControlPoints">If true, control points with properties that are no more coherent with their position in the spline will get modified</param>
        /// <remarks>Is not thread safe</remarks>
        private void RebuildControlPointsRelationshipCache(bool fixNonCoherentControlPoints)
        {
            lock (controlPointsRelationshipCacheLock)
            {
                if (isCpsRelationshipCacheValid)
                    return;

                //force clamping of B-spline's degree, in case control points got removed
                BSplineDegree = bSplineDegree;

                //TODO Try to do elsewhere the work done here when fixNonCoherentControlPoints, so it is always true, and not only true when Relationship cache is build
                int controlPointsCount = ControlPoints.Count;
                mSegments.Clear();
                mSegments.Capacity = controlPointsCount;
                if (controlPointsCount > 0)
                {
                    CurvySplineSegment firsAssignedSegment = null;
                    bool firstSegmentFound = false;
                    CurvySplineSegment lastAssignedSegment = null;

                    CurvySplineSegment.ControlPointExtrinsicProperties previousCpInfo = new CurvySplineSegment.ControlPointExtrinsicProperties(false, -1, -1, -1, -1, -1, false, false, false, -1);

                    bool isSplineClosed = Closed;
                    bool isCatmullRomOrTcb = (Interpolation == CurvyInterpolation.CatmullRom || Interpolation == CurvyInterpolation.TCB);
                    bool notAutoEndTangentsAndIsCatmullRomOrTcb = AutoEndTangents == false && isCatmullRomOrTcb;
                    bool isBSpline = Interpolation == CurvyInterpolation.BSpline;


                    float tfInverseDenominator;
                    {
                        if (notAutoEndTangentsAndIsCatmullRomOrTcb)
                            tfInverseDenominator = 1f / (controlPointsCount > 3 ? controlPointsCount - 3 : 1);
                        else if (isSplineClosed)
                            tfInverseDenominator = 1f / controlPointsCount;
                        else
                            tfInverseDenominator = 1f / (controlPointsCount > 1 ? controlPointsCount - 1 : 1);
                    }

                    short segmentIndex = 0;
                    short lastProcessedOrientationAnchorIndex = -1;
                    for (short index = 0; index < controlPointsCount; index++)
                    {
                        CurvySplineSegment controlPoint = ControlPoints[index];

                        short previousControlPointIndex = GetPreviousControlPointIndex(index, isSplineClosed, controlPointsCount);
                        short nextControlPointIndex = GetNextControlPointIndex(index, isSplineClosed, controlPointsCount);

                        bool isSegment = IsControlPointASegment(index, controlPointsCount, isSplineClosed, notAutoEndTangentsAndIsCatmullRomOrTcb, isBSpline, bSplineDegree);
                        bool isVisible = isSegment || previousCpInfo.IsSegment;

                        if (isVisible
                            && (lastProcessedOrientationAnchorIndex == -1//is first segment
                                || controlPoint.SerializedOrientationAnchor// is anchor
                                || !isSegment))// is last visible CP
                            lastProcessedOrientationAnchorIndex = index;

                        bool canHaveFollowUp = isVisible && (nextControlPointIndex == -1 || previousControlPointIndex == -1);

                        float tf;
                        {
                            if (notAutoEndTangentsAndIsCatmullRomOrTcb)
                                tf = tfInverseDenominator
                                     * (index == 0
                                        ? 0
                                        : index == controlPointsCount - 1
                                            ? Math.Max(0, index - 2)
                                            : index - 1);
                            else
                                tf = tfInverseDenominator * index;
                        }

                        previousCpInfo = new CurvySplineSegment.ControlPointExtrinsicProperties(
                            isVisible,
                            tf,
                            isSegment ? segmentIndex : (short)-1,
                            index,
                            previousControlPointIndex,
                            nextControlPointIndex,
                            previousControlPointIndex != -1
                                && IsControlPointASegment(previousControlPointIndex, controlPointsCount, isSplineClosed, notAutoEndTangentsAndIsCatmullRomOrTcb, isBSpline, bSplineDegree),
                            nextControlPointIndex != -1
                                && IsControlPointASegment(nextControlPointIndex, controlPointsCount, isSplineClosed, notAutoEndTangentsAndIsCatmullRomOrTcb, isBSpline, bSplineDegree),
                            canHaveFollowUp,
                            isVisible ? lastProcessedOrientationAnchorIndex : (short)-1);
                        controlPoint.SetExtrinsicPropertiesINTERNAL(previousCpInfo);

                        if (isSegment)
                        {
                            mSegments.Add(controlPoint);
                            segmentIndex++;
                            if (firstSegmentFound == false)
                            {
                                firstSegmentFound = true;
                                firsAssignedSegment = controlPoint;
                            }
                            lastAssignedSegment = controlPoint;
                        }

                        if (fixNonCoherentControlPoints && canHaveFollowUp == false)
                            controlPoint.UnsetFollowUpWithoutDirtyingINTERNAL();
                    }

                    firstSegment = firsAssignedSegment;
                    lastSegment = lastAssignedSegment;
                    firstVisibleControlPoint = firstSegment;
                    lastVisibleControlPoint = ReferenceEquals(lastSegment, null) == false
                        ? ControlPoints[lastSegment.GetExtrinsicPropertiesINTERNAL().NextControlPointIndex]
                        : null;
                }
                else
                {
                    firstSegment = lastSegment = firstVisibleControlPoint = lastVisibleControlPoint = null;
                }

                isCpsRelationshipCacheValid = true;

#if UNITY_EDITOR
                if (fixNonCoherentControlPoints)
                    syncHierarchyFromSplineNeeded = true;
#endif
            }
        }

        #endregion

        private bool ProcessDirtyControlPoints()
        {
            if (isCpsRelationshipCacheValid == false)
                RebuildControlPointsRelationshipCache(true);

            FillDirtyCpsExtendedList();

            bool thereAreDirtyControlPoints = allControlPointsAreDirty || dirtyCpsExtendedList.Count > 0;

            dirtyControlPointsMinimalSet.Clear();
            allControlPointsAreDirty = false;

            //OPTIM: the current implementation will refresh all dirty CP's orientations, even if one of them needed it, and the others needed only position related refresh. This is because the mDirtyCurve and mDirtyOrientation are spline wide, and not per CP. This can be improved
            //OPTIM: make all the per CP work threadable, and multi thread everything
            if (thereAreDirtyControlPoints)
            {
                if (!(mDirtyOrientation || mDirtyCurve))
                    Debug.LogError("Invalid dirtying flags");

                PrepareThreadCompatibleData();

                int controlPointsCount = ControlPointCount;

                if (mDirtyCurve)
                {
                    #region --- Curve ---

                    // Update Bezier Handles
                    if (Interpolation == CurvyInterpolation.Bezier)
                    {
                        for (int i = 0; i < dirtyCpsExtendedList.Count; i++)
                        {
                            CurvySplineSegment dirtyControlPoint = dirtyCpsExtendedList[i];
                            if (dirtyControlPoint.AutoHandles)
                                dirtyControlPoint.SetBezierHandles(-1f, true, true, true);
                        }
                    }

                    // Iterate through all changed for threadable tasks (cache Approximation, ApproximationT, ApproximationDistance)
                    if (UseThreading)
                        mThreadWorker.ParallelFor(refreshCurveAction, dirtyCpsExtendedList);
                    else
                        for (int i = 0; i < dirtyCpsExtendedList.Count; i++)
                            dirtyCpsExtendedList[i].refreshCurveINTERNAL();

                    // Iterate through all ControlPoints for some basic actions
                    if (controlPointsCount > 0)
                    {

                        List<CurvySplineSegment> segments = Segments;
                        int segmentsCount = segments.Count;

                        Array.Resize(ref controlPointsDistances, controlPointsCount);

                        //// Distances
                        controlPointsDistances[0] = ControlPoints[0].Distance = 0;
                        for (int i = 1; i < controlPointsCount; i++)
                            controlPointsDistances[i] = ControlPoints[i].Distance = ControlPoints[i - 1].Distance + ControlPoints[i - 1].Length;

                        for (int index = 0; index < segmentsCount; index++)
                        {
                            CurvySplineSegment segment = segments[index];
                            CurvySplineSegment nextSegment = GetNextSegment(segment);
                            if (nextSegment)
                                //enforce tangents continuity
                                segment.ApproximationT[segment.CacheSize] = nextSegment.ApproximationT[0];
                            else
                            {
                                //handles tangent of last visible control point
                                GetNextControlPoint(segment).ApproximationT[0] = segment.ApproximationT[segment.CacheSize];
                            }
                        }
                    }

                    #endregion
                }

                if (mDirtyOrientation && Count > 0)
                {
                    #region --- Orientation ---

                    switch (Orientation)
                    {
                        case CurvyOrientation.None:

                            #region --- None ---

                            //No threading here since the operation is too quick to have any benefice in multithreading it
                            for (int i = 0; i < dirtyCpsExtendedList.Count; i++)
                                dirtyCpsExtendedList[i].refreshOrientationNoneINTERNAL();
                            break;

                        #endregion

                        case CurvyOrientation.Static:

                            #region --- Static ---

                            if (UseThreading)
                            {
                                Action<CurvySplineSegment, int, int> action = (controlPoint, cpIndex, cpsCount) => controlPoint.refreshOrientationStaticINTERNAL();
                                mThreadWorker.ParallelFor(action, dirtyCpsExtendedList);
                            }
                            else
                            {
                                for (int i = 0; i < dirtyCpsExtendedList.Count; i++)
                                    dirtyCpsExtendedList[i].refreshOrientationStaticINTERNAL();
                            }

                            break;

                        #endregion

                        case CurvyOrientation.Dynamic:

                            #region --- Dynamic ---

                            // process PTF and smoothing for all anchor groups of dirty CPs
                            int dead = controlPointsCount + 1;
                            do
                            {
                                CurvySplineSegment currentDirtyControlPoint = dirtyCpsExtendedList[0];
                                if (IsControlPointASegment(currentDirtyControlPoint) == false)
                                {
                                    currentDirtyControlPoint.refreshOrientationDynamicINTERNAL(currentDirtyControlPoint.getOrthoUp0INTERNAL());
                                    dirtyCpsExtendedList.RemoveAt(0);
                                }
                                else
                                {
                                    short currentOrientationAnchorIndex = GetControlPointOrientationAnchorIndex(currentDirtyControlPoint);
                                    CurvySplineSegment currentOrientationAnchor = ControlPoints[currentOrientationAnchorIndex];

                                    float swirlPerSegment;
                                    float smoothingAngleStep;
                                    int sampleCount = 0;
                                    short firstCpOutsideAnchorGroupIndex;
                                    {
                                        short anchorGroupCurrentCpIndex = currentOrientationAnchorIndex;
                                        CurvySplineSegment anchorGroupCurrentCp = currentOrientationAnchor;
                                        int anchorgroupSegmentCount = 0;
                                        float anchorgroupLength = 0;
                                        Vector3 nextControlPointInitialUp = currentOrientationAnchor.getOrthoUp0INTERNAL();
                                        do
                                        {
                                            sampleCount += anchorGroupCurrentCp.CacheSize;
                                            anchorgroupSegmentCount++;
                                            anchorgroupLength += anchorGroupCurrentCp.Length;

                                            anchorGroupCurrentCp.refreshOrientationDynamicINTERNAL(nextControlPointInitialUp);
                                            nextControlPointInitialUp = anchorGroupCurrentCp.ApproximationUp[anchorGroupCurrentCp.ApproximationUp.Length - 1];

                                            anchorGroupCurrentCpIndex = GetNextControlPointIndex(anchorGroupCurrentCpIndex, m_Closed, controlPointsCount);
                                            anchorGroupCurrentCp = ControlPoints[anchorGroupCurrentCpIndex];
                                        } while (!IsControlPointAnOrientationAnchor(anchorGroupCurrentCp));
                                        firstCpOutsideAnchorGroupIndex = anchorGroupCurrentCpIndex;
                                        smoothingAngleStep = nextControlPointInitialUp.AngleSigned(anchorGroupCurrentCp.getOrthoUp0INTERNAL(), anchorGroupCurrentCp.ApproximationT[0]) / sampleCount;

                                        // Apply swirl
                                        {
                                            switch (currentOrientationAnchor.Swirl)
                                            {
                                                case CurvyOrientationSwirl.Segment:
                                                    swirlPerSegment = currentOrientationAnchor.SwirlTurns * 360;
                                                    break;
                                                case CurvyOrientationSwirl.AnchorGroup:
                                                    swirlPerSegment = (currentOrientationAnchor.SwirlTurns * 360 / anchorgroupSegmentCount);
                                                    break;
                                                case CurvyOrientationSwirl.AnchorGroupAbs:
                                                    swirlPerSegment = (currentOrientationAnchor.SwirlTurns * 360) / anchorgroupLength;
                                                    break;
                                                case CurvyOrientationSwirl.None:
                                                    swirlPerSegment = 0;
                                                    break;
                                                default:
                                                    swirlPerSegment = 0;
                                                    DTLog.LogError("[Curvy] Invalid Swirl value " + currentOrientationAnchor.Swirl, this);
                                                    break;
                                            }
                                        }
                                    }


                                    {
                                        float angleAccumulator = smoothingAngleStep;
                                        short anchorGroupCurrentCpIndex = currentOrientationAnchorIndex;
                                        bool isSwirlAnchorGroupAbs = currentOrientationAnchor.Swirl == CurvyOrientationSwirl.AnchorGroupAbs;
                                        Vector3 nextControlPointInitialUp = currentOrientationAnchor.ApproximationUp[0];
                                        do
                                        {
                                            CurvySplineSegment anchorGroupCurrentCp = ControlPoints[anchorGroupCurrentCpIndex];
                                            float swirlAngleStep = isSwirlAnchorGroupAbs
                                                ? smoothingAngleStep + swirlPerSegment * anchorGroupCurrentCp.Length / anchorGroupCurrentCp.CacheSize
                                                : smoothingAngleStep + swirlPerSegment / anchorGroupCurrentCp.CacheSize;

                                            //rotate Ups around tangents
                                            Vector3[] tangents = anchorGroupCurrentCp.ApproximationT;
                                            Vector3[] ups = anchorGroupCurrentCp.ApproximationUp;
                                            int upsLength = ups.Length;
                                            ups[0] = nextControlPointInitialUp;

                                            //OPTIM: I thought that the commented version of the code will be faster because of SIMD, but it doesn't seem so. Maybe further work on parallelisation will indded make it faster, but a quick test with Parallel.For didn't show any increase in perfs, but the opposite. Maybe parallelising the ups on a single CP is too little work for multi-threading. Maybe if all the cps' ups were computed in the same loop, multithreading will be worth it.
                                            /*
                                            float angleAccumulatorLoopStart = angleAccumulator;
                                            for (int i = 1; i < upsLength; i++)
                                                ups[i] = Quaternion.AngleAxis(angleAccumulatorLoopStart + (i - 1) * swirlAngleStep, tangents[i]) * ups[i];
                                            angleAccumulator = angleAccumulatorLoopStart + (upsLength - 1) * swirlAngleStep;
                                            */
                                            for (int i = 1; i < upsLength; i++)
                                            {
                                                ups[i] = Quaternion.AngleAxis(angleAccumulator, tangents[i]) * ups[i];
                                                angleAccumulator += swirlAngleStep;
                                            }
                                            nextControlPointInitialUp = ups[upsLength - 1];
                                            dirtyCpsExtendedList.Remove(anchorGroupCurrentCp);

                                            anchorGroupCurrentCpIndex = GetNextControlPointIndex(anchorGroupCurrentCpIndex, m_Closed, controlPointsCount);
                                        } while (anchorGroupCurrentCpIndex != firstCpOutsideAnchorGroupIndex);
                                    }
                                }
                            } while (dirtyCpsExtendedList.Count > 0 && dead-- > 0);
                            if (dead <= 0)
                                DTLog.LogWarning("[Curvy] Deadloop in CurvySpline.Refresh! Please raise a bugreport!", this);
                            break;
                        default:
                            DTLog.LogError("[Curvy] Invalid Orientation value " + Orientation, this);
                            break;
                            #endregion
                    }

                    // Handle very last CP
                    if (!Closed)
                    {
                        CurvySplineSegment beforLastVisibleCp = GetPreviousControlPoint(LastVisibleControlPoint);
                        LastVisibleControlPoint.ApproximationUp[0] = beforLastVisibleCp.ApproximationUp[beforLastVisibleCp.CacheSize];
                    }

                    #endregion
                }
            }

#if CURVY_SANITY_CHECKS
            //These asserts are to make sure that the Refresh code doesn't modify the dirtiness state, which was the case before and could create bugs or unecessary calculations
            Assert.IsTrue(dirtyControlPointsMinimalSet.Count == 0);
            Assert.IsTrue(allControlPointsAreDirty == false);
#endif
            mDirtyCurve = false;
            mDirtyOrientation = false;

            return thereAreDirtyControlPoints;
        }

        /// <summary>
        /// Set the correct values to the thread compatible local positions and rotation
        /// When multithreading, you can't access Transform in the not main threads. Here we cache that data so it is available for threads
        /// </summary>
        private void PrepareThreadCompatibleData()
        {
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(isCpsRelationshipCacheValid);
#endif
            int controlPointsCount = ControlPointCount;
            bool useFollowUp = Interpolation == CurvyInterpolation.CatmullRom || Interpolation == CurvyInterpolation.TCB;

            //prepare the TTransform for all needed control points, which are ....
            // OPTIM: preparing the TTransform of all those CPs is overkill. Restrict the following the prepared CPs to only the CPs being related to the dirtied CPs
            //... all the spline's control points, and ...
            for (int i = 0; i < controlPointsCount; i++)
            {
                CurvySplineSegment controlPoint = ControlPoints[i];
                controlPoint.PrepareThreadCompatibleDataINTERNAL(useFollowUp);
            }
            //... possible other splines' control points because of the followup feature ...
            if (Count > 0)
            {
                CurvySplineSegment beforeFirst = GetPreviousControlPointUsingFollowUp(FirstVisibleControlPoint);
                //before first can be contorlPoints[0] in the case of a spline with AutoEndTangent set to false
                if (ReferenceEquals(beforeFirst, null) == false && beforeFirst.Spline != this)
                    beforeFirst.PrepareThreadCompatibleDataINTERNAL(useFollowUp);
                CurvySplineSegment afterLast = GetNextControlPointUsingFollowUp(LastVisibleControlPoint);
                //afterLast first can be contorlPoints[controlPoints.Count - 1] in the case of a spline with AutoEndTangent set to false
                if (ReferenceEquals(afterLast, null) == false && afterLast.Spline != this)
                    afterLast.PrepareThreadCompatibleDataINTERNAL(useFollowUp);
            }
        }

        /// <summary>
        /// Fills dirtyCpsExtendedList from dirtyControlPointsMinimalSet
        /// </summary>
        private void FillDirtyCpsExtendedList()
        {
            int controlPointsCount = ControlPoints.Count;
            dirtyCpsExtendedList.Clear();
            if (allControlPointsAreDirty)
                for (int i = 0; i < controlPointsCount; i++)
                    dirtyCpsExtendedList.Add(ControlPoints[i]);
            else
            {
                //OPTIM use cps indexes in dirtyControlPointsMinimalSet instead of cps references, will reduce the time passed in getHash and ==

                int minimalDirtyCpsCount = dirtyControlPointsMinimalSet.Count;
                //We expend dirtyControlPointsMinimalSet to include the extended list of dirty control points
                for (int index = 0; index < minimalDirtyCpsCount; index++)
                {
                    //OPTIM ElementAt allocates enumerator, avoid this. Maybe a way to avoid it is to use dirtyControlPointsMinimalSet.Copyto(array) to copy the content of the hashset into an array, and then iterate on that array instead of the hashset. The array needs to be a member of the CurvySpline class, so it is allocated only one
                    CurvySplineSegment dirtyCp = dirtyControlPointsMinimalSet.ElementAt(index);

                    {
                        switch (Interpolation)
                        {
                            case CurvyInterpolation.Linear:
                                {
                                    CurvySplineSegment previousCp = GetPreviousControlPoint(dirtyCp);
                                    if (previousCp)
                                        dirtyControlPointsMinimalSet.Add(previousCp);
                                }
                                break;
                            case CurvyInterpolation.CatmullRom:
                            case CurvyInterpolation.TCB:
                            case CurvyInterpolation.Bezier:
                                {
                                    CurvySplineSegment previousCp = GetPreviousControlPoint(dirtyCp);
                                    if (previousCp)
                                        dirtyControlPointsMinimalSet.Add(previousCp);

                                    //Add other segments to reflect the effect of Bezier handles (and Auto Handles) and Catmull-Rom and TCB's extended influence of CPs.
                                    //OPTIM in the bezier case, always including this extended set of CPs is overkill, but at least it avoids bugs and the complicated dirtying logic associated with the Bezier handles handling code.
                                    if (previousCp)
                                    {
                                        //OPTIM you can get dirtyCp's index, then use GetPreviousControlPointIndex to get previousCp and previousPreviousCp
                                        CurvySplineSegment previousPreviousCp = GetPreviousControlPoint(previousCp);
                                        if (previousPreviousCp)
                                            dirtyControlPointsMinimalSet.Add(previousPreviousCp);
                                    }

                                    CurvySplineSegment nextCp = GetNextControlPoint(dirtyCp);
                                    if (nextCp)
                                        dirtyControlPointsMinimalSet.Add(nextCp);
                                }
                                break;
                            case CurvyInterpolation.BSpline:
                                {
                                    int degree = BSplineDegree;
                                    bool closed = Closed;
                                    bool isClamped = IsBSplineClamped;
                                    int n = BSplineHelper.GetBSplineN(controlPointsCount, degree, closed);
                                    int dirtyCpIndex = GetControlPointIndex(dirtyCp);
                                    for (int testedCpIndex = 0; testedCpIndex < controlPointsCount; testedCpIndex++)
                                    {
                                        CurvySplineSegment testedCP = ControlPoints[testedCpIndex];

                                        int startK;
                                        int endK;

                                        BSplineHelper.GetBSplineUAndK(
                                            SegmentToTF(testedCP), isClamped, degree, n,
                                            out _, out startK);

                                        if (dirtyCpIndex >= startK - degree && dirtyCpIndex <= startK)
                                            dirtyCpsExtendedList.Add(testedCP);
                                        else
                                        {
                                            BSplineHelper.GetBSplineUAndK(
                                                SegmentToTF(testedCP, 1), isClamped, degree, n,
                                                out _, out endK);
                                            if (dirtyCpIndex >= endK - degree && dirtyCpIndex <= endK)
                                                dirtyCpsExtendedList.Add(testedCP);
                                            else if (closed)
                                            {
                                                int loopedCpIndex = dirtyCpIndex + controlPointsCount;
                                                if (loopedCpIndex >= startK - degree && loopedCpIndex <= startK)
                                                    dirtyCpsExtendedList.Add(testedCP);
                                                else
                                                {
                                                    BSplineHelper.GetBSplineUAndK(
                                                        SegmentToTF(testedCP, 1), isClamped, degree, n,
                                                        out _, out endK);
                                                    if (loopedCpIndex >= endK - degree && loopedCpIndex <= endK)
                                                        dirtyCpsExtendedList.Add(testedCP);
                                                }
                                            }
                                        }
                                    }
                                }
                                break;
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                }

#if CURVY_SANITY_CHECKS
                Assert.IsTrue(isCpsRelationshipCacheValid);
#endif
                dirtyCpsExtendedList.AddRange(dirtyControlPointsMinimalSet);
            }
        }

        /// <summary>
        /// Call this to make the spline send an event to notify its listeners of the change in the spline data.
        /// </summary>
        internal void NotifyMetaDataModification()
        {
            //DESIGN until 2.2.3, meta data change triggered OnRefresh event by dirtying its associated control point. I think spline should have different events (or at least a param in the event) to distinguish between the event coming from an actual change in the spline's geometry, and a change in its meta data.
            sendOnRefreshEventNextUpdate = true;
        }

        /// <summary>
        /// Rebuilds the hierarchy from the ControlPoints list
        /// </summary>
        private void SyncHierarchyFromSpline(bool renameControlPoints = true)
        {
#if UNITY_EDITOR
            // rename them and set their order based on ControlPoint list
            int count = ControlPoints.Count;
            for (short i = 0; i < count; i++)
            {
                CurvySplineSegment curvySplineSegment = ControlPoints[i];
                if (curvySplineSegment)
                //curvySplineSegment was null in the following case:
                //In edit mode, using the pen tool, added a new spline with a cp (CTRL + Left click on empty spot), then added a connected spline (CTRL + Right click on empty spot), and then hit ctrl+Z, which undone the creation of the connected spline, and in the next update this code is called with ControlPoints containing destroyed CPs 
                {
                    curvySplineSegment.transform.SetSiblingIndex(i);

                    if (renameControlPoints)
                        curvySplineSegment.name = GetControlPointName(i);
                }
            }
#endif
        }

        private void UpdatedLastProcessedGlobalCoordinates()
        {
            lastProcessedPosition = cachedTransform.position;
            lastProcessedRotation = cachedTransform.rotation;
            lastProcessedScale = cachedTransform.lossyScale;
        }

        /// <summary>
        /// Inserts a Control Point, trigger events and refresh spline
        /// </summary>
        /// <param name="controlPoint">A control point used as a param of the OnBeforeControlPointAddEvent</param>
        /// <param name="position">The position of the control point at its creation</param>
        /// <param name="insertionIndex">Index at which the newly created control point will be inserted in the spline.</param>
        /// <param name="insertionMode">Used as a param of send events</param>
        /// <param name="skipRefreshingAndEvents">If true, the spline's <see cref="Refresh"/> method will not be called, and the relevant events will not be triggered</param>
        /// <param name="space">Whether the positions are in the local or global space</param>
        /// <returns>The created Control Point</returns>
        private CurvySplineSegment InsertAt(CurvySplineSegment controlPoint, Vector3 position, int insertionIndex, CurvyControlPointEventArgs.ModeEnum insertionMode, bool skipRefreshingAndEvents, Space space)
        {
#if CONTRACTS_FULL
            Contract.Requires(controlPoint.Spline == this);
            Contract.Requires(controlPoints.Contains(controlPoint));
#endif

            if (skipRefreshingAndEvents == false)
                OnBeforeControlPointAddEvent(new CurvyControlPointEventArgs(this, this, controlPoint, insertionMode));

            GameObject go;
            CurvySplineSegment insertedControlPoint;

            if (UsePooling && Application.isPlaying)
            {
                CurvyGlobalManager curvyGlobalManager = CurvyGlobalManager.Instance;
                if (curvyGlobalManager != null)
                {
                    insertedControlPoint = curvyGlobalManager.ControlPointPool.Pop<CurvySplineSegment>(cachedTransform);//TODO should this be callse with "null" instead of "transform", to be coherent with the other branches, and knowing that the parent is set to "transform" anyway in subsequent calls?
                    go = insertedControlPoint.gameObject;
                }
                else
                {
                    DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.", this);
                    go = new GameObject("NewCP", typeof(CurvySplineSegment));
                    insertedControlPoint = go.GetComponent<CurvySplineSegment>();
                }
            }
            else
            {
                go = new GameObject("NewCP", typeof(CurvySplineSegment));
                insertedControlPoint = go.GetComponent<CurvySplineSegment>();
            }

            go.layer = gameObject.layer;
            go.transform.SetParent(cachedTransform);

            InsertControlPoint(insertionIndex, insertedControlPoint);
            insertedControlPoint.AutoHandleDistance = AutoHandleDistance;
            if (space == Space.World)
                insertedControlPoint.transform.position = position;
            else
                insertedControlPoint.transform.localPosition = position;
            insertedControlPoint.transform.localRotation = Quaternion.identity;
            insertedControlPoint.transform.localScale = Vector3.one;

            if (skipRefreshingAndEvents == false)
            {
                Refresh();
                OnAfterControlPointAddEvent(new CurvyControlPointEventArgs(this, this, insertedControlPoint, insertionMode));
                OnAfterControlPointChangesEvent(defaultSplineEventArgs);
            }

            return insertedControlPoint;
        }

        #region Events

        private CurvySplineEventArgs OnRefreshEvent(CurvySplineEventArgs e)
        {
            if (OnRefresh != null)
                OnRefresh.Invoke(e);
            return e;
        }

        private CurvyControlPointEventArgs OnBeforeControlPointAddEvent(CurvyControlPointEventArgs e)
        {
            if (OnBeforeControlPointAdd != null)
                OnBeforeControlPointAdd.Invoke(e);
            return e;
        }

        private CurvyControlPointEventArgs OnAfterControlPointAddEvent(CurvyControlPointEventArgs e)
        {
            if (OnAfterControlPointAdd != null)
                OnAfterControlPointAdd.Invoke(e);
            return e;
        }

        private CurvyControlPointEventArgs OnBeforeControlPointDeleteEvent(CurvyControlPointEventArgs e)
        {
            if (OnBeforeControlPointDelete != null)
                OnBeforeControlPointDelete.Invoke(e);
            return e;
        }

        private CurvySplineEventArgs OnAfterControlPointChangesEvent(CurvySplineEventArgs e)
        {
            if (OnAfterControlPointChanges != null)
                OnAfterControlPointChanges.Invoke(e);
            return e;
        }

        #endregion


        /*! \endcond */

        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvySpline_private.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvyUISpline.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3a6c45371b22846469f6b81fca388a48
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Spline component that fits perfectly to uGUI Canvas
    /// </summary>
    [RequireComponent(typeof(RectTransform))]
    [AddComponentMenu("Curvy/Curvy UI Spline")]
    [HelpURL(CurvySpline.DOCLINK + "curvyuispline")]
    public class CurvyUISpline : CurvySpline
    {
        //DESIGN Isn't there a better way to create UI splines? The current code is set in a way that will not set up the spline properly if you don't go through the CreateUISpline method. This is an issue.
        //Jake explains here that CurvyUISpline just to have a different PPU https://forum.curvyeditor.com/thread-431-post-1672.html#pid1672

        /// <summary>
        /// Creates a GameObject with a CurvyUISpline attached
        /// </summary>
        /// <returns>the component</returns>
        public static CurvyUISpline CreateUISpline(string gameObjectName = "Curvy UI Spline")
        {
            CurvyUISpline spl = new GameObject(gameObjectName, typeof(CurvyUISpline)).GetComponent<CurvyUISpline>();
            spl.SetupUISpline();
            return spl;
        }

        override protected void Reset()
        {
            base.Reset();
            SetupUISpline();
        }

        private void SetupUISpline()
        {
            RestrictTo2D = true;
            MaxPointsPerUnit = 1;
            Orientation = CurvyOrientation.None;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/CurvyUISpline.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Metadata/CurvyInterpolatableMetadataBaseGeneric.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: aae93c9564267e4419881a7c0347a902
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using System;
using UnityEngine;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Base class for Metadata classes that support interpolation.
    /// </summary>
    /// <typeparam name="T">The Type of the Metadata's value</typeparam>
    [ExecuteAlways]
    public abstract class CurvyInterpolatableMetadataBase<T> : CurvyMetadataBase
    {
        /// <summary>
        /// The value stored within this Metadata instance
        /// </summary>
        public abstract T MetaDataValue { get; }

        /// <summary>
        /// Interpolates between the current Metadata's value and the one from the next Control Point's Metadata.
        /// </summary>
        /// <param name="nextMetadata">The Metadata from the Control Point next to the current one</param>
        /// <param name="interpolationTime">The local F value on the segment defined by the current Control Point and the next one</param>
        /// <returns></returns>
        public abstract T Interpolate(CurvyInterpolatableMetadataBase<T> nextMetadata, float interpolationTime);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Metadata/CurvyInterpolatableMetadataBaseGeneric.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Metadata/CurvyMetadataBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6b43fe84c1280624d89fe7b112993489
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using FluffyUnderware.DevTools;
using UnityEngine;

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Base class for all Metadata classes.
    /// A Metadata is a custom data attached to a Control Point
    /// </summary>
    [RequireComponent(typeof(CurvySplineSegment))]
    [ExecuteAlways]
    public abstract class CurvyMetadataBase : DTVersionedMonoBehaviour
    {
        #region ### Serialized Fields ###
        #endregion

        #region ### Public Properties ###

        public CurvySplineSegment ControlPoint
        {
            get { return mCP; }
        }

        public CurvySpline Spline
        {
            get
            {
                //DESIGN should this throw an exception if mCP is null?
                return (mCP) ? mCP.Spline : null;
            }
        }

        #endregion

        #region ### Private Fields & Properties ###

        private CurvySplineSegment mCP;

        #endregion

        #region ### Unity Callbacks ###
        /*! \cond UNITY */

        protected virtual void Awake()
        {
            mCP = GetComponent<CurvySplineSegment>();
            mCP.RegisterMetaData(this);
        }

        private void OnDestroy()
        {
            mCP.UnregisterMetaData(this);
        }

        /*! \endcond */
        #endregion

        #region ### Public Methods ###

        public T GetPreviousData<T>(bool autoCreate = true, bool segmentsOnly = true, bool useFollowUp = false) where T : CurvyMetadataBase
        {
            if (ControlPoint)
            {
                CurvySplineSegment controlPoint = ControlPoint;
                CurvySpline spline = Spline;


                CurvySplineSegment previousControlPoint;
                if (!spline || spline.ControlPointsList.Count == 0)
                    previousControlPoint = null;
                else
                {
                    previousControlPoint = useFollowUp
                        ? spline.GetPreviousControlPointUsingFollowUp(controlPoint)
                        : spline.GetPreviousControlPoint(controlPoint);

                    if (segmentsOnly && previousControlPoint && previousControlPoint.Spline.IsControlPointASegment(previousControlPoint) == false)
                        previousControlPoint = null;
                }

                if (previousControlPoint)
                    return previousControlPoint.GetMetadata<T>(autoCreate);
            }
            return default;
        }

        public T GetNextData<T>(bool autoCreate = true, bool segmentsOnly = true, bool useFollowUp = false) where T : CurvyMetadataBase
        {
            if (ControlPoint)
            {
                CurvySplineSegment controlPoint = ControlPoint;
                CurvySpline spline = Spline;

                CurvySplineSegment nextControlPoint;
                if (!spline || spline.ControlPointsList.Count == 0)
                    nextControlPoint = null;
                else
                {
                    nextControlPoint = useFollowUp
                        ? spline.GetNextControlPointUsingFollowUp(controlPoint)
                        : spline.GetNextControlPoint(controlPoint);

                    if (segmentsOnly && nextControlPoint && nextControlPoint.Spline.IsControlPointASegment(nextControlPoint) == false)
                        nextControlPoint = null;
                }

                if (nextControlPoint)
                    return nextControlPoint.GetMetadata<T>(autoCreate);
            }
            return default;
        }

        /// <summary>
        /// Call this to make the owner spline send an event to notify its listeners of the change in the spline data.
        /// </summary>
        protected void NotifyModification()
        {
            CurvySpline spline = Spline;
            if (spline && spline.IsInitialized)
                spline.NotifyMetaDataModification();
        }

        #endregion

        #region ### Privates ###
        /*! \cond PRIVATES */


        /*! \endcond */
        #endregion

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/Metadata/CurvyMetadataBase.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/SplineDirtyingType.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0e4eb203c5d588c48926e1ee743423ab
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Used as a parameter for dirtying methods. Instructs if only the spline's orientation cache should be recomputed, or the whole approximations cache
    /// </summary>
    public enum SplineDirtyingType
    {
        /// <summary>
        /// Orientation approximations cache will be dirtied. Positions approximations cache will be ignored.
        /// </summary>
        OrientationOnly,
        /// <summary>
        /// Orientation approximations cache and positions approximations cache will be dirtied.
        /// </summary>
        Everything
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/SplineDirtyingType.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/SplineEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e5224b0feeae2424abf53d1d1c4eafc6
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2022 ToolBuddy
// All rights reserved
// 
// http://www.toolbuddy.net
// =====================================================================

using UnityEngine;
using FluffyUnderware.DevTools;
using UnityEngine.Assertions;

#if CONTRACTS_FULL
using System.Diagnostics.Contracts;
#endif
namespace FluffyUnderware.Curvy
{
    /// <summary>
    /// Class used by spline related events
    /// </summary>
    [System.Serializable]
    public class CurvySplineEvent : UnityEventEx<CurvySplineEventArgs> { }

    /// <summary>
    /// Class used by spline related events
    /// </summary>
    [System.Serializable]
    public class CurvyControlPointEvent : UnityEventEx<CurvyControlPointEventArgs> { }

    /// <summary>
    /// EventArgs used by CurvyControlPointEvent events
    /// </summary>
    public class CurvyControlPointEventArgs : CurvySplineEventArgs
    {
        /// <summary>
        /// Event Mode
        /// </summary>
        public enum ModeEnum
        {
            /// <summary>
            /// Send for events that are not related to control points adding or removal
            /// </summary>
            None,
            /// <summary>
            /// Send when a Control point is added before an existing one
            /// </summary>
            AddBefore,
            /// <summary>
            /// Send when a Control point is added after an existing one
            /// </summary>
            AddAfter,
            /// <summary>
            /// Send when a Control point is deleted
            /// </summary>
            Delete
        }

        /// <summary>
        /// Determines the action this event was raised for
        /// </summary>
        public readonly ModeEnum Mode;
        /// <summary>
        /// Related Control Point
        /// </summary>
        public readonly CurvySplineSegment ControlPoint;

        public CurvyControlPointEventArgs(MonoBehaviour sender, CurvySpline spline, CurvySplineSegment cp, ModeEnum mode = ModeEnum.None, object data = null) : base(sender, spline, data)
        {
            ControlPoint = cp;
            Mode = mode;
        }
    }



    /// <summary>
    /// EventArgs used by CurvySplineEvent events
    /// </summary>
    public class CurvySplineEventArgs : CurvyEventArgs
    {
        /// <summary>
        /// The related spline
        /// </summary>
        public readonly CurvySpline Spline;

        public CurvySplineEventArgs(MonoBehaviour sender, CurvySpline spline, object data = null) : base(sender, data)
        {
            Spline = spline;


#if CURVY_SANITY_CHECKS
            Assert.IsTrue(System.Object.ReferenceEquals(Spline,null) == false);
#endif
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Assets/Curvy/Scripts/Splines/SplineEvents.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Attributes.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 353b27613f9971242bf7f5673b2529a5
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Reflection;
using System;
using System.Collections.Generic;
using FluffyUnderware.DevTools.Extensions;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FluffyUnderware.DevTools
{
    #region ### Interfaces ###
    /// <summary>
    /// Interface for attributes that change group parsing options
    /// </summary>
    public interface IDTGroupParsingAttribute 
    {
        string Path { get; }
    }
    /// <summary>
    /// Interface for attributes that change field parsing options
    /// </summary>
    public interface IDTFieldParsingAttribute { }
    /// <summary>
    /// Interface for attributes that change group rendering options
    /// </summary>
    public interface IDTGroupRenderAttribute { }
    /// <summary>
    /// Interface for attributes that change field rendering options
    /// </summary>
    public interface IDTFieldRenderAttribute { }

    #endregion

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public class DTVersionAttribute : System.Attribute
    {
        public readonly string Version;

        public DTVersionAttribute(string version)
        {
            Version = version;
        }
    }


    #region ### Base Attributes ###
    //OPTIM: all the attributes bellow (and maybe DTVersionAttribute too) seem to be used only in editor code. If so, and there overhead is big, make their compilation conditional to gain performance in the build applications

    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    public class DTAttribute : System.Attribute, IComparable
    {
        public int TypeSort { get; protected set; }
        public int Sort = 100;
        public bool ShowBelowProperty;
        public int Space;

        public virtual int CompareTo(object obj)
        {
            DTAttribute other = (DTAttribute)obj;
            int v = ShowBelowProperty.CompareTo(other.ShowBelowProperty);
            if (v == 0)
            {
                int ts = TypeSort.CompareTo(other.TypeSort);
                if (ts == 0)
                    return Sort.CompareTo(other.Sort);
                else
                    return ts;
            }
            else
                return v;
        }

        public DTAttribute(int sortOrder, bool showBelow = false)
        {
            TypeSort = sortOrder;
            ShowBelowProperty = showBelow;
        }
    }

    /// <summary>
    /// Explicitely add the next field to a specific group
    /// </summary>
    public class GroupAttribute : DTAttribute, IDTGroupParsingAttribute, IDTGroupRenderAttribute
    {
        public string Path
        {
            get { return mPath; }
            protected set
            {
                PathIsAbsolute = !string.IsNullOrEmpty(value) && value.StartsWith("@");
                if (PathIsAbsolute)
                {
                    mPath = value.Substring(1);
                    if (string.IsNullOrEmpty(mPath))
                        mPath = null;
                }
                else
                    mPath = value;
            }
        }
        public bool PathIsAbsolute { get; private set; }

        public bool Expanded = true;
        public bool Invisible;
        public string Label = null;
        public string Tooltip = null;
        public string HelpURL = null;

        string mPath;

        public GroupAttribute(string pathAndName)
            : base(15)
        {
            Path = pathAndName;
        }
    }

    public class ActionAttribute : DTAttribute
    {
        public enum ActionEnum { Show, Hide, Enable, Disable, ShowInfo, ShowWarning, ShowError, Callback }
        public enum ActionPositionEnum { Above, Below }
        public ActionEnum Action = ActionEnum.Callback;
        public ActionPositionEnum Position = ActionPositionEnum.Below;
        public object ActionData;

        MethodInfo mCallback;

        protected ActionAttribute(string actionData, ActionEnum action = ActionEnum.Callback)
            : base(50)
        {
            ActionData = actionData;
            Action = action;
        }

        public void Callback(object classInstance)
        {
            string methodName = ActionData as string;
            if (!string.IsNullOrEmpty(methodName))
            {
                if (mCallback == null)
                    mCallback = classInstance.GetType().MethodByName(methodName, true, true);

                if (mCallback != null)
                    mCallback.Invoke(classInstance, null);
                else
                    Debug.LogWarningFormat("[DevTools] Unable to find method '{0}' at class '{1}' !", methodName, classInstance.GetType().Name);
            }
        }
    }

    public class ConditionalAttribute : ActionAttribute
    {
        public enum OperatorEnum { AND, OR };
        public class Condition
        {
            public string FieldName;
            public FieldInfo FieldInfo;
            public PropertyInfo PropertyInfo;
            public object CompareTo;
            public bool CompareFalse;
            public OperatorEnum Operator;
            public MethodInfo MethodInfo;
            public string MethodName;
        }

        public Condition[] Conditions;


        protected ConditionalAttribute(string fieldOrProperty, object compareTo, bool compareFalse = false)
            : base(null, ActionEnum.Show)
        {
            TypeSort = 55;
            Conditions = new Condition[1]
            {
                new Condition()
                {
                    FieldName=fieldOrProperty,
                    CompareTo=compareTo,
                    CompareFalse=compareFalse
                }
            };
        }

        protected ConditionalAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op,
                                    string fieldOrProperty2, object compareTo2, bool compareFalse2)
            : base(null, ActionEnum.Show)
        {
            TypeSort = 55;
            Conditions = new Condition[2]
            {
                new Condition()
                {
                    FieldName=fieldOrProperty,
                    CompareTo=compareTo,
                    CompareFalse=compareFalse
                },
                new Condition()
                {
                    FieldName=fieldOrProperty2,
                    CompareTo=compareTo2,
                    CompareFalse=compareFalse2,
                    Operator=op
                }
            };
        }

        protected ConditionalAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op,
                                    string fieldOrProperty2, object compareTo2, bool compareFalse2,
                                    string fieldOrProperty3, object compareTo3, bool compareFalse3)
            : base(null, ActionEnum.Show)
        {
            TypeSort = 55;
            Conditions = new Condition[3]
            {
                new Condition()
                {
                    FieldName=fieldOrProperty,
                    CompareTo=compareTo,
                    CompareFalse=compareFalse
                },
                new Condition()
                {
                    FieldName=fieldOrProperty2,
                    CompareTo=compareTo2,
                    CompareFalse=compareFalse2,
                    Operator=op
                },
                new Condition()
                {
                    FieldName=fieldOrProperty3,
                    CompareTo=compareTo3,
                    CompareFalse=compareFalse3,
                    Operator=op
                }
            };
        }

        protected ConditionalAttribute(string methodToQuery)
            : base(null, ActionEnum.Show)
        {
            TypeSort = 55;
            Conditions = new Condition[1]
            {
                new Condition()
                {
                    MethodName=methodToQuery,
                    CompareTo=null
                }
            };
        }


        public virtual bool ConditionMet(object classInstance)
        {
            bool result = evaluate(Conditions[0], classInstance);

            for (int i = 1; i < Conditions.Length; i++)
            {
                Condition c = Conditions[i];
                switch (c.Operator)
                {
                    case OperatorEnum.AND:
                        result = result && evaluate(c, classInstance);
                        break;
                    case OperatorEnum.OR:
                        result = result || evaluate(c, classInstance);
                        break;
                }
            }
            return result;


        }

        bool evaluate(Condition cond, object classInstance)
        {
            if (!string.IsNullOrEmpty(cond.MethodName))
            {
                if (cond.MethodInfo == null)
                    cond.MethodInfo = classInstance.GetType().MethodByName(cond.MethodName, true, true);
                if (cond.MethodInfo != null)
                {
                    if (cond.CompareFalse)
                        return !(bool)cond.MethodInfo.Invoke(classInstance, null);
                    else
                        return (bool)cond.MethodInfo.Invoke(classInstance, null);
                }
                else
                {
                    Debug.LogWarningFormat("[DevTools] Unable to find method '{0}' at class '{1}' !", cond.MethodName, classInstance.GetType().Name);
                    return cond.CompareFalse;
                }
            }
            else
            {
                if (cond.FieldInfo == null)
                {
                    cond.FieldInfo = classInstance.GetType().FieldByName(cond.FieldName, true, true);
                    if (cond.FieldInfo == null)
                    {
                        cond.PropertyInfo = classInstance.GetType().PropertyByName(cond.FieldName, true, true);
                    }
                }
                object value = null;
                if (cond.FieldInfo != null)
                    value = cond.FieldInfo.GetValue(classInstance);
                else if (cond.PropertyInfo != null)
                    value = cond.PropertyInfo.GetValue(classInstance, null);

                if (value == null)
                {
                    return (cond.CompareTo == null && !cond.CompareFalse);
                }
                else
                    return value.Equals(cond.CompareTo) == !cond.CompareFalse;
            }
        }

    }

    #endregion

    #region ### Attributes handling Nesting/Parsing ###

    public class SortOrderAttribute : DTAttribute, IDTFieldParsingAttribute
    {
        public SortOrderAttribute(int sort = 100) : base(0)
        {
            Sort = sort;
        }
    }

    /// <summary>
    /// Show children inside a section. Start the path with "@" to break out of any previous sections
    /// </summary>
    public class AsGroupAttribute : GroupAttribute, IDTFieldParsingAttribute, IDTFieldRenderAttribute
    {

        public AsGroupAttribute(string pathAndName = null)
            : base(pathAndName)
        {
            TypeSort = 10;
        }
    }

    /// <summary>
    /// Show all subsequent fields inside a section rendered as a tab
    /// </summary>
    public class TabAttribute : GroupAttribute
    {
        public readonly string TabName;
        public readonly string TabBarName;

        public TabAttribute(string pathAndName)
            : base("")
        {
            TypeSort = 10;
            string p;
            split(pathAndName, out p, out TabBarName, out TabName);
            Path = p;
        }

        static bool split(string pathAndName, out string path, out string tabBar, out string tabname)
        {
            string[] p = pathAndName.Split('/');
            path = string.Empty;
            tabBar = string.Empty;
            tabname = pathAndName;
            if (p.Length == 0)
                return false;
            else if (p.Length == 1)
            {
                tabname = p[0];
                tabBar = "Default";
                return true;
            }
            else
            {
                tabname = p[p.Length - 1];
                tabBar = p[p.Length - 2];
                path = string.Join("/", p, 0, p.Length - 2);
                return true;
            }

        }
    }

    /// <summary>
    /// Show all subsequent fields inside a section.
    /// </summary>
    public class SectionAttribute : GroupAttribute
    {
        public bool Fixed;

        public SectionAttribute(string name, bool expanded = true, bool fix = false, int sort = 100)
            : base(name)
        {
            Expanded = expanded;
            TypeSort = 10;
            Sort = sort;
            Fixed = fix;
        }
    }

    /// <summary>
    /// Ends any section
    /// </summary>
    public class NoSectionAttribute : SectionAttribute
    {
        public NoSectionAttribute() : base("")
        {
            TypeSort = 10;
        }
    }



    /// <summary>
    /// Hides Field and doesn't enter children
    /// </summary>
    public class Hide : DTAttribute, IDTFieldParsingAttribute, IDTFieldRenderAttribute
    {
        public Hide() : base(20) { }
    }

    /// <summary>
    /// Hides Field, but enter children
    /// </summary>
    public class Inline : DTAttribute, IDTFieldParsingAttribute, IDTFieldRenderAttribute
    {
        public Inline() : base(21) { }
    }





    #endregion

    #region ### Attributes handling visual representation ###

    public class ArrayExAttribute : DTAttribute, IDTFieldParsingAttribute
    {
        public bool Draggable = true;
        public bool ShowHeader = true;
        public bool ShowAdd = true;
        public bool ShowDelete = true;
        public bool DropTarget = true;

        public ArrayExAttribute()
            : base(35)
        {
        }
    }

    #endregion

    #region ### Attributes handling actions and dynamic evaluation ###



    public class FieldActionAttribute : ActionAttribute, IDTFieldRenderAttribute
    {
        public FieldActionAttribute(string actionData, ActionEnum action = ActionEnum.Callback)
            : base(actionData, action) { }

    }

    public class GroupActionAttribute : ActionAttribute, IDTGroupRenderAttribute
    {
        public GroupActionAttribute(string actionData, ActionEnum action = ActionEnum.Callback)
            : base(actionData, action) { }
    }



    public class FieldConditionAttribute : ConditionalAttribute, IDTFieldRenderAttribute
    {
        public FieldConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse = false, ActionEnum action = ActionEnum.Show, object actionData = null, ActionPositionEnum position = ActionPositionEnum.Below)
            : base(fieldOrProperty, compareTo, compareFalse)
        {
            Action = action;
            ActionData = actionData;
            Position = position;
        }


        public FieldConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op,
                                    string fieldOrProperty2, object compareTo2, bool compareFalse2)
            : base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2) { }


        public FieldConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op,
                                    string fieldOrProperty2, object compareTo2, bool compareFalse2,
                                    string fieldOrProperty3, object compareTo3, bool compareFalse3)
            : base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2, fieldOrProperty3, compareTo3, compareFalse3) { }

        public FieldConditionAttribute(string methodToQuery)
            : base(methodToQuery) { }

    }
    public class GroupConditionAttribute : ConditionalAttribute, IDTGroupRenderAttribute
    {
        public GroupConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse = false)
            : base(fieldOrProperty, compareTo, compareFalse) { }


        public GroupConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op,
                                    string fieldOrProperty2, object compareTo2, bool compareFalse2)
            : base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2) { }


        public GroupConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op,
                                    string fieldOrProperty2, object compareTo2, bool compareFalse2,
                                    string fieldOrProperty3, object compareTo3, bool compareFalse3)
            : base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2, fieldOrProperty3, compareTo3, compareFalse3) { }

        public GroupConditionAttribute(string methodToQuery)
            : base(methodToQuery) { }
    }

    #endregion

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Attributes.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Couple.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c3f887f64f3b22845b9c93163066963a
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FluffyUnderware.DevTools
{
    public class Couple<T1, T2>
    {
        public T1 First { get; set; }
        public T2 Second { get; set; }
        public Couple(T1 first, T2 second)
        {
            First = first;
            Second = second;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Couple.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Data.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 45f5314b4eeb54743a8d8494c74a292b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using JetBrains.Annotations;
using Random = UnityEngine.Random;

namespace FluffyUnderware.DevTools
{
    [System.Serializable]
    public struct FloatRegion : IEquatable<FloatRegion>
    {
        public float From;
        public float To;
        public bool SimpleValue;

        public FloatRegion(float value)
        {
            From = value;
            To = value;
            SimpleValue = true;
        }

        public FloatRegion(float A, float B)
        {
            this.From = A;
            this.To = B;
            SimpleValue = false;
        }

        public static FloatRegion ZeroOne
        {
            get { return new FloatRegion(0, 1); }
        }

        public void MakePositive()
        {
            if (To < From)
            {
                (From, To) = (To, From);
            }
        }

        public void Clamp(float low, float high)
        {
            Low = Mathf.Clamp(Low, low, high);
            High = Mathf.Clamp(High, low, high);
        }

        public bool Positive
        {
            get { return From <= To; }
        }

        public float Low
        {
            get { return (Positive) ? From : To; }
            set
            {
                if (Positive)
                    From = value;
                else
                    To = value;
            }
        }

        public float High
        {
            get { return (Positive) ? To : From; }
            set
            {
                if (Positive)
                    To = value;
                else
                    From = value;
            }
        }

        public float Random
        {
            get
            {
                return UnityEngine.Random.Range(From, To);
            }
        }

        /// <summary>
        /// Gets the next value in the range
        /// <remarks>Depending on the value of <see cref="SimpleValue"/>, this call will or will not make the Random generator's seed progress</remarks>
        /// </summary>
        public float Next
        {
            get
            {
                if (SimpleValue)
                    return From;
                else
                    return Random;
            }
        }

        public float Length
        {
            get
            {
                return To - From;
            }
        }

        public float LengthPositive
        {
            get { return (Positive) ? To - From : From - To; }
        }

        public override string ToString()
        {
            return string.Format("({0:F2}-{1:F2})", From, To);
        }

        public override int GetHashCode()
        {
            return From.GetHashCode() ^ To.GetHashCode() << 2;
        }

        public bool Equals(FloatRegion other)
        {
            return From.Equals(other.From) && To.Equals(other.To);
        }

        public override bool Equals(object other)
        {
            if (!(other is FloatRegion))
            {
                return false;
            }
            FloatRegion r = (FloatRegion)other;
            return From.Equals(r.From) && To.Equals(r.To);
        }

        public static FloatRegion operator +(FloatRegion a, FloatRegion b)
        {
            return new FloatRegion(a.From + b.From, a.To + b.To);
        }

        public static FloatRegion operator -(FloatRegion a, FloatRegion b)
        {
            return new FloatRegion(a.From - b.From, a.To - b.To);
        }

        public static FloatRegion operator -(FloatRegion a)
        {
            return new FloatRegion(-a.From, -a.To);
        }

        public static FloatRegion operator *(FloatRegion a, float v)
        {
            return new FloatRegion(a.From * v, a.To * v);
        }

        public static FloatRegion operator *(float v, FloatRegion a)
        {
            return new FloatRegion(a.From * v, a.To * v);
        }

        public static FloatRegion operator /(FloatRegion a, float v)
        {
            return new FloatRegion(a.From / v, a.To / v);
        }

        public static bool operator ==(FloatRegion lhs, FloatRegion rhs)
        {
            return lhs.SimpleValue == rhs.SimpleValue && Mathf.Approximately(lhs.From, rhs.From) && Mathf.Approximately(lhs.To, rhs.To);
        }
        public static bool operator !=(FloatRegion lhs, FloatRegion rhs)
        {
            return lhs.SimpleValue != rhs.SimpleValue || !Mathf.Approximately(lhs.From, rhs.From) || !Mathf.Approximately(lhs.To, rhs.To);
        }
    }

    [System.Serializable]
    public struct IntRegion : IEquatable<IntRegion>
    {
        public int From;
        public int To;
        public bool SimpleValue;


        public IntRegion(int value)
        {
            From = value;
            To = value;
            SimpleValue = true;

        }

        public IntRegion(int A, int B)
        {
            this.From = A;
            this.To = B;
            SimpleValue = false;

        }

        public static IntRegion ZeroOne
        {
            get { return new IntRegion(0, 1); }
        }

        public void MakePositive()
        {
            if (To < From)
            {
                (From, To) = (To, From);
            }
        }

        public void Clamp(int low, int high)
        {
            Low = Mathf.Clamp(Low, low, high);
            High = Mathf.Clamp(High, low, high);
        }

        public bool Positive
        {
            get { return From <= To; }
        }

        public int Low
        {
            get { return (Positive) ? From : To; }
            set
            {
                if (Positive)
                    From = value;
                else
                    To = value;
            }
        }

        public int High
        {
            get { return (Positive) ? To : From; }
            set
            {
                if (Positive)
                    To = value;
                else
                    From = value;
            }
        }

        public int Random
        {
            get
            {
                return UnityEngine.Random.Range(From, To);
            }
        }

        public int Length
        {
            get
            {
                return To - From;
            }
        }

        public int LengthPositive
        {
            get { return (Positive) ? To - From : From - To; }
        }

        public override string ToString()
        {
            return string.Format("({0}-{1})", From, To);
        }

        public override int GetHashCode()
        {
            return From.GetHashCode() ^ To.GetHashCode() << 2;
        }

        public bool Equals(IntRegion other)
        {
            return From.Equals(other.From) && To.Equals(other.To);
        }

        public override bool Equals(object other)
        {
            if (!(other is IntRegion))
            {
                return false;
            }
            IntRegion r = (IntRegion)other;
            return From.Equals(r.From) && To.Equals(r.To);
        }

        public static IntRegion operator +(IntRegion a, IntRegion b)
        {
            return new IntRegion(a.From + b.From, a.To + b.To);
        }

        public static IntRegion operator -(IntRegion a, IntRegion b)
        {
            return new IntRegion(a.From - b.From, a.To - b.To);
        }

        public static IntRegion operator -(IntRegion a)
        {
            return new IntRegion(-a.From, -a.To);
        }

        public static IntRegion operator *(IntRegion a, int v)
        {
            return new IntRegion(a.From * v, a.To * v);
        }

        public static IntRegion operator *(int v, IntRegion a)
        {
            return new IntRegion(a.From * v, a.To * v);
        }

        public static IntRegion operator /(IntRegion a, int v)
        {
            return new IntRegion(a.From / v, a.To / v);
        }

        public static bool operator ==(IntRegion lhs, IntRegion rhs)
        {
            return lhs.From == rhs.From && lhs.To == rhs.To && lhs.SimpleValue != rhs.SimpleValue;
        }
        public static bool operator !=(IntRegion lhs, IntRegion rhs)
        {
            return lhs.From != rhs.From || lhs.To != rhs.To || lhs.SimpleValue != rhs.SimpleValue;
        }
    }

    /// <summary>
    /// Simple but effective ShuffleBag<T> implementation
    /// </summary>
    public class WeightedRandom<T>
    {
        readonly List<T> mData;
        int mCurrentPosition = -1;
        T mCurrentItem;

        public int Seed { get; set; }

        public bool RandomizeSeed { get; set; }

        private int Capacity { get { return mData.Capacity; } }
        public int Size { get { return mData.Count; } }

        public WeightedRandom(int initCapacity = 0)
        {
            mData = new List<T>(initCapacity);
        }

        public WeightedRandom(int initCapacity, int seed):this(initCapacity)
        {
            Seed = seed;
        }

        /// <summary>
        /// Adds items to the bag
        /// </summary>
        /// <param name="item">the item</param>
        /// <param name="amount">number of times this item should be added</param>
        public void Add(T item, int amount)
        {
            for (int i = 0; i < amount; i++)
                mData.Add(item);
            mCurrentPosition = Size - 1;
        }

        /// <summary>
        /// Gets a random item from the bag
        /// </summary>
        /// <returns>an item</returns>
        public T Next()
        {
            if (mCurrentPosition < 1)
            {
                mCurrentPosition = Size - 1;
                mCurrentItem = mData[0];
                return mCurrentItem;
            }
            Random.State s = Random.state;
            if (RandomizeSeed)
                Seed = Random.Range(0, int.MaxValue);
            Random.InitState(Seed);
            int idx = Random.Range(0, mCurrentPosition);
            Random.state = s;

            mCurrentItem = mData[idx];
            mData[idx] = mData[mCurrentPosition];
            mData[mCurrentPosition] = mCurrentItem;
            mCurrentPosition--;
            return mCurrentItem;
        }

        /// <summary>
        /// Refill the bag
        /// </summary>
        public void Reset()
        {
            mCurrentPosition = Size - 1;
        }

        /// <summary>
        /// Clear the bag
        /// </summary>
        public void Clear()
        {
            mData.Clear();
            mCurrentPosition = -1;
        }

    }

    public class Ring<T> : IList<T>
    {
        readonly List<T> mList;
        public int Size { get; private set; }

        int mIndex;

        public Ring(int size)
        {
            mList = new List<T>(size);
            Size = size;
        }

        public void Add(T item)
        {
            if (mList.Count == Size)
            {
                mList[mIndex++] = item;
                if (mIndex == mList.Count)
                    mIndex = 0;
            }
            else
                mList.Add(item);
        }

        public void Clear()
        {
            mList.Clear();
            mIndex = 0;
        }


        public int IndexOf(T item)
        {
            return mList.IndexOf(item);
        }

        public void Insert(int index, T item)
        {
            throw new System.NotSupportedException();
        }

        public void RemoveAt(int index)
        {
            throw new System.NotSupportedException();
        }

        public T this[int index]
        {
            get
            {
                return mList[index];
            }
            set
            {
                mList[index] = value;
            }
        }

        public IEnumerator GetEnumerator()
        {
            return mList.GetEnumerator();
        }


        public bool Contains(T item)
        {
            return mList.Contains(item);
        }

        public void CopyTo(T[] array, int arrayIndex)
        {
            mList.CopyTo(array, arrayIndex);
        }

        public int Count
        {
            get { return mList.Count; }
        }

        public bool IsReadOnly
        {
            get { throw new System.NotSupportedException(); }
        }

        public bool Remove(T item)
        {
            return mList.Remove(item);
        }

        IEnumerator<T> IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
        }
    }

    public class Pool<T> : IPool
    {
        readonly List<T> mObjects = new List<T>();

        public string Identifier { get; set; }

        public PoolSettings Settings { get; protected set; }

        public System.Type Type
        {
            get { return typeof(T); }
        }

        double mLastTime;
        double mDeltaTime;


        public Pool(PoolSettings settings = null)
        {
            Settings = settings ?? new PoolSettings();
            Identifier = typeof(T).FullName;
            mLastTime = DTTime.TimeSinceStartup + UnityEngine.Random.Range(0, Settings.Speed);
            if (Settings.Prewarm)
                Reset();
        }

        public void Update()
        {
            mDeltaTime += DTTime.TimeSinceStartup - mLastTime;
            mLastTime = DTTime.TimeSinceStartup;

            if (Settings.Speed > 0)
            {
                int c = (int)(mDeltaTime / Settings.Speed);
                mDeltaTime -= c;

                if (Count > Settings.Threshold)
                {
                    c = Mathf.Min(c, Count - Settings.Threshold);
                    while (c-- > 0)
                    {
                        destroy(mObjects[0]);
                        mObjects.RemoveAt(0);
                        log("Threshold exceeded: Deleting item");
                    }
                }
                else if (Count < Settings.MinItems)
                {
                    c = Mathf.Min(c, Settings.MinItems - Count);
                    while (c-- > 0)
                    {
                        mObjects.Add(create());
                        log("Below MinItems: Adding item");
                    }
                }
            }
            else
                mDeltaTime = 0;
        }

        public void Reset()
        {
            if (Application.isPlaying)
            {
                while (Count < Settings.MinItems)
                {
                    mObjects.Add(create());
                }
                while (Count > Settings.Threshold)
                {
                    destroy(mObjects[0]);
                    mObjects.RemoveAt(0);
                }
                log("Prewarm/Reset");
            }
        }

        public void Clear()
        {
            log("Clear");
            for (int i = 0; i < Count; i++)
                destroy(mObjects[i]);
            mObjects.Clear();
        }

        public int Count
        {
            get { return mObjects.Count; }
        }

        public virtual T Pop(Transform parent = null)
        {
            T item = default;
            if (Count > 0)
            {
                item = mObjects[0];
                mObjects.RemoveAt(0);

            }
            else
            {
                if (Settings.AutoCreate || !Application.isPlaying)
                {
                    log("Auto create item");
                    item = create();

                }
            }
            if (item != null)
            {
                sendAfterPop(item);
                setParent(item, parent);
                log("Pop " + item);
            }

            return item;
        }

        public virtual void Push(T item)
        {
            log("Push " + item);
            if (Application.isPlaying && item != null)
            {
                sendBeforePush(item);
                mObjects.Add(item);
            }
        }

        protected virtual void sendBeforePush(T item)
        {
            if (item is IPoolable)
                ((IPoolable)item).OnBeforePush();
        }

        protected virtual void sendAfterPop(T item)
        {
            if (item is IPoolable)
                ((IPoolable)item).OnAfterPop();
        }

        protected virtual void setParent(T item, Transform parent)
        {
        }

        protected virtual T create()
        {
            return System.Activator.CreateInstance<T>();
        }

        protected virtual void destroy(T item)
        {
        }

        void log(string msg)
        {
            if (Settings.Debug)
                Debug.Log(string.Format("[{0}] ({1} items) {2}", Identifier, Count, msg));
        }
    }


    [System.Serializable]
    public class PoolSettings
    {
        [SerializeField]
        bool m_Prewarm = false;
        [SerializeField]
        bool m_AutoCreate = true;
        [SerializeField]
        bool m_AutoEnableDisable = true;
        [Positive]
        [SerializeField]
        int m_MinItems = 0;

        [Positive]
        [SerializeField]
        int m_Threshold = 0;

        [Positive]
        [SerializeField]
        float m_Speed = 1;




        public bool Debug;

        public PoolSettings() { }

        public PoolSettings(PoolSettings src)
        {
            Prewarm = src.Prewarm;
            AutoCreate = src.AutoCreate;
            MinItems = src.MinItems;
            Threshold = src.Threshold;
            Speed = src.Speed;
            Debug = src.Debug;
        }

        public bool Prewarm
        {
            get { return m_Prewarm; }
            set
            {
                if (m_Prewarm != value)
                    m_Prewarm = value;
            }
        }

        public bool AutoCreate
        {
            get { return m_AutoCreate; }
            set
            {
                if (m_AutoCreate != value)
                    m_AutoCreate = value;
            }
        }

        public bool AutoEnableDisable
        {
            get { return m_AutoEnableDisable; }
            set
            {
                if (m_AutoEnableDisable != value)
                    m_AutoEnableDisable = value;
            }
        }

        public int MinItems
        {
            get { return m_MinItems; }
            set
            {
                int v = Mathf.Max(0, value);
                if (m_MinItems != v)
                    m_MinItems = v;
            }
        }

        public int Threshold
        {
            get { return m_Threshold; }
            set
            {
                int v = Mathf.Max(MinItems, value);
                if (m_Threshold != v)
                    m_Threshold = v;
            }
        }

        public float Speed
        {
            get { return m_Speed; }
            set
            {
                float v = Mathf.Max(0, value);
                if (m_Speed != v)
                    m_Speed = v;
            }
        }

        public void OnValidate()
        {
            MinItems = m_MinItems;
            Threshold = m_Threshold;
            Speed = m_Speed;
        }
    }


    public interface IPool
    {
        [NotNull]
        string Identifier { get; set; }
        PoolSettings Settings { get; }
        void Clear();
        void Reset();
        void Update();
        int Count { get; }
    }

    public interface IPoolable
    {
        void OnBeforePush();

        void OnAfterPop();
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/Data.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTEase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d57d3ecf09b87c9438cf6d0622a903fb
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;

namespace FluffyUnderware.DevTools
{
    public static class DTTween
    {
        public enum EasingMethod
        {
            Linear              = 0,
            ExponentialIn       = 1,
            ExponentialOut      = 2,
            ExponentialInOut    = 3,
            ExponentialOutIn    = 4,
            CircularIn          = 5,
            CircularOut         = 6,
            CircularInOut       = 7,
            CircularOutIn       = 8,
            QuadraticIn         = 9,
            QuadraticOut        = 10,
            QuadraticInOut      = 11,
            QuadraticOutIn      = 12,
            SinusIn             = 13,
            SinusOut            = 14,
            SinusInOut          = 15,
            SinusOutIn          = 16,
            CubicIn             = 17,
            CubicOut            = 18,
            CubicInOut          = 19,
            CubicOutIn          = 20,
            QuarticIn           = 21,
            QuarticOut          = 22,
            QuarticInOut        = 23,
            QuarticOutIn        = 24,
            QuinticIn           = 25,
            QuinticOut          = 26,
            QuinticInOut        = 27,
            QuinticOutIn        = 28
        }


        /// <summary>
        /// Tween
        /// </summary>
        /// <param name="method">Tweening method</param>
        /// <param name="t">Time (0..1)</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float Ease(EasingMethod method, float t, float b, float c)
        {
            switch (method)
            {
                case EasingMethod.ExponentialIn: return ExpoIn(t, b, c);
                case EasingMethod.ExponentialOut: return ExpoOut(t, b, c);
                case EasingMethod.ExponentialInOut: return ExpoInOut(t, b, c);
                case EasingMethod.ExponentialOutIn: return ExpoOutIn(t, b, c);
                case EasingMethod.CircularIn: return CircIn(t, b, c);
                case EasingMethod.CircularOut: return CircOut(t, b, c);
                case EasingMethod.CircularInOut: return CircInOut(t, b, c);
                case EasingMethod.CircularOutIn: return CircOutIn(t, b, c);
                case EasingMethod.QuadraticIn: return QuadIn(t, b, c);
                case EasingMethod.QuadraticOut: return QuadOut(t, b, c);
                case EasingMethod.QuadraticInOut: return QuadInOut(t, b, c);
                case EasingMethod.QuadraticOutIn: return QuadOutIn(t, b, c);
                case EasingMethod.SinusIn: return SineIn(t, b, c);
                case EasingMethod.SinusOut: return SineOut(t, b, c);
                case EasingMethod.SinusInOut: return SineInOut(t, b, c);
                case EasingMethod.SinusOutIn: return SineOutIn(t, b, c);
                case EasingMethod.CubicIn: return CubicIn(t, b, c);
                case EasingMethod.CubicOut: return CubicOut(t, b, c);
                case EasingMethod.CubicInOut: return CubicInOut(t, b, c);
                case EasingMethod.CubicOutIn: return CubicOutIn(t, b, c);
                case EasingMethod.QuarticIn: return QuartIn(t, b, c);
                case EasingMethod.QuarticOut: return QuartOut(t, b, c);
                case EasingMethod.QuarticInOut: return QuartInOut(t, b, c);
                case EasingMethod.QuarticOutIn: return QuartOutIn(t, b, c);
                case EasingMethod.QuinticIn: return QuintIn(t, b, c);
                case EasingMethod.QuinticOut: return QuintOut(t, b, c);
                case EasingMethod.QuinticInOut: return QuintInOut(t, b, c);
                case EasingMethod.QuinticOutIn: return QuintOutIn(t, b, c);
                default: return Linear(t, b, c);
            }
        }

        /// <summary>
        /// Tween
        /// </summary>
        /// <param name="method">Tweening method</param>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float Ease(EasingMethod method, float t, float b, float c, float d)
        {
            switch (method)
            {
                case EasingMethod.ExponentialIn: return ExpoIn(t, b, c, d);
                case EasingMethod.ExponentialOut: return ExpoOut(t, b, c, d);
                case EasingMethod.ExponentialInOut : return ExpoInOut(t, b, c, d);
                case EasingMethod.ExponentialOutIn: return ExpoOutIn(t, b, c, d);
                case EasingMethod.CircularIn: return CircIn(t, b, c, d);
                case EasingMethod.CircularOut: return CircOut(t, b, c, d);
                case EasingMethod.CircularInOut: return CircInOut(t, b, c, d);
                case EasingMethod.CircularOutIn: return CircOutIn(t, b, c, d);
                case EasingMethod.QuadraticIn : return QuadIn(t, b, c, d);
                case EasingMethod.QuadraticOut : return QuadOut(t, b, c, d);
                case EasingMethod.QuadraticInOut : return QuadInOut(t, b, c, d);
                case EasingMethod.QuadraticOutIn : return QuadOutIn(t, b, c, d);
                case EasingMethod.SinusIn: return SineIn(t, b, c, d);
                case EasingMethod.SinusOut: return SineOut(t, b, c, d);
                case EasingMethod.SinusInOut : return SineInOut(t, b, c, d);
                case EasingMethod.SinusOutIn  : return SineOutIn(t, b, c, d);
                case EasingMethod.CubicIn: return CubicIn(t, b, c, d);
                case EasingMethod.CubicOut: return CubicOut(t, b, c, d);
                case EasingMethod.CubicInOut: return CubicInOut(t, b, c, d);
                case EasingMethod.CubicOutIn: return CubicOutIn(t, b, c, d);
                case EasingMethod.QuarticIn: return QuartIn(t, b, c, d);
                case EasingMethod.QuarticOut: return QuartOut(t, b, c, d);
                case EasingMethod.QuarticInOut: return QuartInOut(t, b, c, d);
                case EasingMethod.QuarticOutIn: return QuartOutIn(t, b, c, d);
                case EasingMethod.QuinticIn: return QuintIn(t, b, c, d);
                case EasingMethod.QuinticOut: return QuintOut(t, b, c, d);
                case EasingMethod.QuinticInOut: return QuintInOut(t, b, c, d);
                case EasingMethod.QuinticOutIn: return QuintOutIn(t, b, c, d);
                default: return Linear(t, b, c, d);
            }
        }

        #region ### Linear ###
        /// <summary>
        /// Linear tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float Linear(float t, float b, float c)
        {
            return c * Mathf.Clamp01(t) + b;
        }
        /// <summary>
        /// Linear tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float Linear(float t, float b, float c, float d)
        {
            return c * t / d + b;
        }
        #endregion

        #region ### Exponential ###
        /// <summary>
        /// Exponential tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float ExpoOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return (t == 1) ? b + c : c * (-Mathf.Pow(2, -10 * t) + 1) + b;
        }
        /// <summary>
        /// Exponential tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float ExpoOut(float t, float b, float c, float d)
        {
            return (t == d) ? b + c : c * (-Mathf.Pow(2, -10 * t / d) + 1) + b;
        }

        /// <summary>
        /// Exponential tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float ExpoIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return (t == 0) ? b : c * Mathf.Pow(2, 10 * (t-1)) + b;
        }
        /// <summary>
        /// Exponential tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float ExpoIn(float t, float b, float c, float d)
        {
            return (t == 0) ? b : c * Mathf.Pow(2, 10 * (t / d - 1)) + b;
        }

        /// <summary>
        /// Exponential tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float ExpoInOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t == 0)
                return b;

            if (t == 1)
                return b + c;

            if ((t /= .5f) < 1)
                return c / 2 * Mathf.Pow(2, 10 * (t - 1)) + b;

            return c / 2 * (-Mathf.Pow(2, -10 * --t) + 2) + b;
        }
        /// <summary>
        /// Exponential tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float ExpoInOut(float t, float b, float c, float d)
        {
            if (t == 0)
                return b;

            if (t == d)
                return b + c;

            if ((t /= d / 2) < 1)
                return c / 2 * Mathf.Pow(2, 10 * (t - 1)) + b;

            return c / 2 * (-Mathf.Pow(2, -10 * --t) + 2) + b;
        }

        /// <summary>
        /// Exponential tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float ExpoOutIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t < .5f)
                return ExpoOut(t * 2, b, c / 2);

            return ExpoIn((t * 2) - 1, b + c / 2, c / 2);
        }
        /// <summary>
        /// Exponential tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float ExpoOutIn(float t, float b, float c, float d)
        {
            if (t < d / 2)
                return ExpoOut(t * 2, b, c / 2, d);

            return ExpoIn((t * 2) - d, b + c / 2, c / 2, d);
        }

        #endregion

        #region ### Circular ###
        /// <summary>
        /// Circular tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CircOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return c * Mathf.Sqrt(1 - (t = t - 1) * t) + b;
        }
        /// <summary>
        /// Circular tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CircOut(float t, float b, float c, float d)
        {
            return c * Mathf.Sqrt(1 - (t = t / d - 1) * t) + b;
        }

        /// <summary>
        /// Circular tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CircIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return -c * (Mathf.Sqrt(1 - t * t) - 1) + b;
        }
        /// <summary>
        /// Circular tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CircIn(float t, float b, float c, float d)
        {
            return -c * (Mathf.Sqrt(1 - (t /= d) * t) - 1) + b;
        }

        /// <summary>
        /// Circular tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CircInOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if ((t /= .5f) < 1)
                return -c / 2 * (Mathf.Sqrt(1 - t * t) - 1) + b;

            return c / 2 * (Mathf.Sqrt(1 - (t -= 2) * t) + 1) + b;
        }
        /// <summary>
        /// Circular tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CircInOut(float t, float b, float c, float d)
        {
            if ((t /= d / 2) < 1)
                return -c / 2 * (Mathf.Sqrt(1 - t * t) - 1) + b;

            return c / 2 * (Mathf.Sqrt(1 - (t -= 2) * t) + 1) + b;
        }

        /// <summary>
        /// Circular tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CircOutIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t < .5f)
                return CircOut(t * 2, b, c / 2);

            return CircIn((t * 2) - 1, b + c / 2, c / 2);
        }
        /// <summary>
        /// Circular tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CircOutIn(float t, float b, float c, float d)
        {
            if (t < d / 2)
                return CircOut(t * 2, b, c / 2, d);

            return CircIn((t * 2) - d, b + c / 2, c / 2, d);
        }

        #endregion

        #region ### Quadratic ###
        /// <summary>
        /// Quadratic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuadOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return -c * t * (t - 2) + b;
        }
        /// <summary>
        /// Quadratic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuadOut(float t, float b, float c, float d)
        {
            return -c * (t /= d) * (t - 2) + b;
        }

        /// <summary>
        /// Quadratic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuadIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return c * t * t + b;
        }
        /// <summary>
        /// Quadratic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuadIn(float t, float b, float c, float d)
        {
            return c * (t /= d) * t + b;
        }

        /// <summary>
        /// Quadratic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuadInOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if ((t /= .5f) < 1)
                return -c / 2 * (Mathf.Sqrt(1 - t * t) - 1) + b;

            return c / 2 * (Mathf.Sqrt(1 - (t -= 2) * t) + 1) + b;
        }
        /// <summary>
        /// Quadratic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuadInOut(float t, float b, float c, float d)
        {
            if ((t /= d / 2) < 1)
                return -c / 2 * (Mathf.Sqrt(1 - t * t) - 1) + b;

            return c / 2 * (Mathf.Sqrt(1 - (t -= 2) * t) + 1) + b;
        }

        /// <summary>
        /// Quadratic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuadOutIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t < .5f)
                return QuadOut(t * 2, b, c / 2);

            return QuadIn((t * 2) - 1, b + c / 2, c / 2);
        }

        /// <summary>
        /// Quadratic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuadOutIn(float t, float b, float c, float d)
        {
            if (t < d / 2)
                return QuadOut(t * 2, b, c / 2, d);

            return QuadIn((t * 2) - d, b + c / 2, c / 2, d);
        }

        #endregion

        #region ### Sinus ###
        /// <summary>
        /// Sinusoidal tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float SineOut(float t, float b, float c)
        {
            return c * Mathf.Sin(Mathf.Clamp01(t) * (Mathf.PI / 2)) + b;
        }
        /// <summary>
        /// Sinusoidal tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float SineOut(float t, float b, float c, float d)
        {
            return c * Mathf.Sin(t / d * (Mathf.PI / 2)) + b;
        }

        /// <summary>
        /// Sinusoidal tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float SineIn(float t, float b, float c)
        {
            return -c * Mathf.Cos(Mathf.Clamp01(t) * (Mathf.PI / 2)) + c + b;
        }
        /// <summary>
        /// Sinusoidal tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float SineIn(float t, float b, float c, float d)
        {
            return -c * Mathf.Cos(t / d * (Mathf.PI / 2)) + c + b;
        }

        /// <summary>
        /// Sinusoidal tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float SineInOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if ((t /= .5f) < 1)
                return c / 2 * (Mathf.Sin(Mathf.PI * t / 2)) + b;

            return -c / 2 * (Mathf.Cos(Mathf.PI * --t / 2) - 2) + b;

        }
        /// <summary>
        /// Sinusoidal tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float SineInOut(float t, float b, float c, float d)
        {
            if ((t /= d / 2) < 1)
                return c / 2 * (Mathf.Sin(Mathf.PI * t / 2)) + b;

            return -c / 2 * (Mathf.Cos(Mathf.PI * --t / 2) - 2) + b;
        }

        /// <summary>
        /// Sinusoidal tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float SineOutIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t < .5f)
                return SineOut(t * 2, b, c / 2);

            return SineIn((t * 2) - 1, b + c / 2, c / 2);
        }

        /// <summary>
        /// Sinusoidal tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float SineOutIn(float t, float b, float c, float d)
        {
            if (t < d / 2)
                return SineOut(t * 2, b, c / 2, d);

            return SineIn((t * 2) - d, b + c / 2, c / 2, d);
        }

        #endregion

        #region ### Cubic ###

        /// <summary>
        /// Cubic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CubicOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return c * ((t = t - 1) * t * t + 1) + b;
        }
        /// <summary>
        /// Cubic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CubicOut(float t, float b, float c, float d)
        {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        }

        /// <summary>
        /// Cubic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CubicIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return c * t * t * t + b;
        }
        /// <summary>
        /// Cubic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CubicIn(float t, float b, float c, float d)
        {
            return c * (t /= d) * t * t + b;
        }

        /// <summary>
        /// Cubic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CubicInOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if ((t /= .5f) < 1)
                return c / 2 * t * t * t + b;

            return c / 2 * ((t -= 2) * t * t + 2) + b;

        }
        /// <summary>
        /// Cubic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CubicInOut(float t, float b, float c, float d)
        {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t + b;

            return c / 2 * ((t -= 2) * t * t + 2) + b;
        }

        /// <summary>
        /// Cubic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float CubicOutIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t < .5f)
                return CubicOut(t * 2, b, c / 2);

            return CubicIn((t * 2) - 1, b + c / 2, c / 2);
        }

        /// <summary>
        /// Cubic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float CubicOutIn(float t, float b, float c, float d)
        {
            if (t < d / 2)
                return CubicOut(t * 2, b, c / 2, d);

            return CubicIn((t * 2) - d, b + c / 2, c / 2, d);
        }

        #endregion

        #region ### Quartic ###

        /// <summary>
        /// Quartic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuartOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return -c * ((t = t - 1) * t * t * t - 1) + b;
        }
        /// <summary>
        /// Quartic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuartOut(float t, float b, float c, float d)
        {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b;
        }

        /// <summary>
        /// Quartic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuartIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return c * t * t * t * t + b;
        }
        /// <summary>
        /// Quartic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuartIn(float t, float b, float c, float d)
        {
            return c * (t /= d) * t * t * t + b;
        }

        /// <summary>
        /// Quartic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuartInOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if ((t /= .5f) < 1)
                return c / 2 * t * t * t * t + b;

            return -c / 2 * ((t -= 2) * t * t * t - 2) + b;

        }
        /// <summary>
        /// Quartic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuartInOut(float t, float b, float c, float d)
        {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t * t + b;

            return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
        }

        /// <summary>
        /// Quartic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuartOutIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t < .5f)
                return QuartOut(t * 2, b, c / 2);

            return QuartIn((t * 2) - 1, b + c / 2, c / 2);
        }

        /// <summary>
        /// Quartic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuartOutIn(float t, float b, float c, float d)
        {
            if ( t < d / 2 )
                return QuartOut( t * 2, b, c / 2, d );

            return QuartIn( ( t * 2 ) - d, b + c / 2, c / 2, d );
        }

        #endregion

        #region ### Quintic ###

        /// <summary>
        /// Quintic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuintOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return c * ((t = t - 1) * t * t * t * t + 1) + b;
        }
        /// <summary>
        /// Quintic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuintOut(float t, float b, float c, float d)
        {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        }

        /// <summary>
        /// Quintic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuintIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            return c * t * t * t * t * t + b;
        }
        /// <summary>
        /// Quintic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuintIn(float t, float b, float c, float d)
        {
            return c * (t /= d) * t * t * t * t + b;
        }

        /// <summary>
        /// Quintic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuintInOut(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if ((t /= .5f) < 1)
                return c / 2 * t * t * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;

        }
        /// <summary>
        /// Quintic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuintInOut(float t, float b, float c, float d)
        {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        }

        /// <summary>
        /// Quintic tween with t clamped to 0..1
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <returns>tweened value</returns>
        public static float QuintOutIn(float t, float b, float c)
        {
            t = Mathf.Clamp01(t);
            if (t < .5f)
                return QuintOut(t * 2, b, c / 2);
            return QuintIn((t * 2) - 1, b + c / 2, c / 2);
        }

        /// <summary>
        /// Quintic tween
        /// </summary>
        /// <param name="t">Time</param>
        /// <param name="b">Start value</param>
        /// <param name="c">Delta value</param>
        /// <param name="d">Duration</param>
        /// <returns>tweened value</returns>
        public static float QuintOutIn(float t, float b, float c, float d)
        {
            if (t < d / 2)
                return QuintOut(t * 2, b, c / 2, d);
            return QuintIn((t * 2) - d, b + c / 2, c / 2, d);
        }

        #endregion

        // TODO: Add missing formulas (Elastic etc.) from here: http://wpf-animation.googlecode.com/svn/trunk/src/WPF/Animation/PennerDoubleAnimation.cs
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTEase.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTObjectDump.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 64b16d693c41e7a44979cd06b6d9e47b
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Text;
using System;
using System.Reflection;
using FluffyUnderware.DevTools.Extensions;

namespace FluffyUnderware.DevTools
{

    public class DTObjectDump
    {
        const int INDENTSPACES = 5;
        string mIndent;
        StringBuilder mSB;
        object mObject;

        public DTObjectDump(object o, int indent = 0)
        {
            mIndent = new string(' ', indent);
            mSB = new StringBuilder();
            mObject = o;

            Type T = o.GetType();
            FieldInfo[] fia = T.GetAllFields(false, true);
            if (fia.Length > 0)
                AppendHeader("Fields");
            foreach (FieldInfo fi in fia)
                AppendMember(fi);

            PropertyInfo[] pia = T.GetAllProperties(false, true);
            if (pia.Length > 0)
                AppendHeader("Properties");
            foreach (PropertyInfo pi in pia)
                AppendMember(pi);
        }

        public override string ToString()
        {
            return mSB.ToString();
        }

        void AppendHeader(string name)
        {
            mSB.AppendLine(mIndent + "<b>---===| " + name + " |===---</b>\n");
        }

        void AppendMember(MemberInfo info)
        {
            Type type;
            string typeName;
            object value;

            FieldInfo fi = info as FieldInfo;
            if (fi != null)
            {
                type = fi.FieldType;
                typeName = type.Name;
                value = fi.GetValue(mObject);
            }
            else
            {
                PropertyInfo pi = info as PropertyInfo;
                type = pi.PropertyType;
                typeName = type.Name;
                value = pi.GetValue(mObject, null);
            }

            if (value != null)
            {
                if (typeof(IEnumerable).IsAssignableFrom(type))
                {
                    string tmp = mIndent;
                    int count = 0;
                    IEnumerable ie = value as IEnumerable;
                    if (ie != null)
                    {
                        if (type.GetEnumerableType().BaseType == typeof(ValueType))
                        {
                            foreach (object e in ie)
                                tmp = string.Concat(tmp, string.Format("<b>{0}</b>: {1} ", (count++).ToString(), e.ToString()));
                        }
                        else
                        {
                            if (typeof(IList).IsAssignableFrom(type))
                                typeName = "IList<" + type.GetEnumerableType() + ">";
                            tmp += "\n";
                            foreach (object e in ie)
                                tmp = string.Concat(tmp, string.Format("<b>{0}</b>: {1} ", (count++).ToString(), new DTObjectDump(e, mIndent.Length + INDENTSPACES).ToString()));
                        }
                    }
                    mSB.Append(mIndent);
                    mSB.AppendFormat("(<i>{0}</i>) <b>{1}[{2}]</b> = ", typeName, info.Name, count);
                    mSB.AppendLine(tmp);
                }
                else
                {
                    mSB.Append(mIndent);
                    mSB.AppendFormat("(<i>{0}</i>) <b>{1}</b> = ", typeName, info.Name);
                    mSB.AppendLine(mIndent + value.ToString());
                }
            }
        }
    }

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTObjectDump.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d3a715a2c19f08a4ba8b136add10408f
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System;
using System.Text;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using UnityEngine.Events;
using Object = UnityEngine.Object;
#if UNITY_EDITOR
using UnityEditor;
using System.Linq;
#endif

namespace FluffyUnderware.DevTools
{
    public static class DTUtility
    {
        /// <summary>
        /// The base Url for DT components' documentation
        /// </summary>
        public const string HelpUrlBase = "https://curvyeditor.com/doclink/";

#if UNITY_EDITOR
        static MethodInfo mGetBuiltinExtraResourcesMethod;
#endif

        public static Material GetDefaultMaterial()
        {
#if UNITY_EDITOR
            if (mGetBuiltinExtraResourcesMethod == null)
            {
                BindingFlags bfs = BindingFlags.NonPublic | BindingFlags.Static;
                mGetBuiltinExtraResourcesMethod = typeof(UnityEditor.EditorGUIUtility).GetMethod("GetBuiltinExtraResource", bfs);
            }

            Material result;
            if (mGetBuiltinExtraResourcesMethod == null)
            {
                result = null;
                Debug.LogError("Couldn't find method GetBuiltinExtraResource in type UnityEditor.EditorGUIUtility");
            }
            else
                result = (Material)mGetBuiltinExtraResourcesMethod.Invoke(null, new object[] { typeof(Material), "Default-Diffuse.mat" });

            return result;
#else
            return null;
#endif
        }


        public static bool IsEditorStateChange
        {
            get
            {
#if UNITY_EDITOR
                if (UnityEditor.EditorApplication.isPlayingOrWillChangePlaymode && !UnityEditor.EditorApplication.isPlaying)
                    return true;
                else
#endif
                    return false;
            }
        }


#if UNITY_EDITOR
        private const string INDENT_STRING = "    ";
        public static string FormatJson(string str)
        {
            int indent = 0;
            bool quoted = false;
            StringBuilder sb = new System.Text.StringBuilder();
            for (int i = 0; i < str.Length; i++)
            {
                char ch = str[i];
                switch (ch)
                {
                    case '{':
                    case '[':
                        sb.Append(ch);
                        if (!quoted)
                        {
                            sb.AppendLine();
                            Enumerable.Range(0, ++indent).ForEach(item => sb.Append(INDENT_STRING));
                        }
                        break;
                    case '}':
                    case ']':
                        if (!quoted)
                        {
                            sb.AppendLine();
                            Enumerable.Range(0, --indent).ForEach(item => sb.Append(INDENT_STRING));
                        }
                        sb.Append(ch);
                        break;
                    case '"':
                        sb.Append(ch);
                        bool escaped = false;
                        int index = i;
                        while (index > 0 && str[--index] == '\\')
                            escaped = !escaped;
                        if (!escaped)
                            quoted = !quoted;
                        break;
                    case ',':
                        sb.Append(ch);
                        if (!quoted)
                        {
                            sb.AppendLine();
                            Enumerable.Range(0, indent).ForEach(item => sb.Append(INDENT_STRING));
                        }
                        break;
                    case ':':
                        sb.Append(ch);
                        if (!quoted)
                            sb.Append(" ");
                        break;
                    default:
                        sb.Append(ch);
                        break;
                }
            }
            return sb.ToString();
        }
#endif

        /// <summary>
        /// Much like HandleUtility.GetHandleSize(), but works for gizmos
        /// </summary>
        /// <param name="position"> handle position in world space</param>
        public static float GetHandleSize(Vector3 position)
        {
            Camera camera = Camera.current;

            if (camera)
            {
                Transform cameraTransform = camera.transform;

                Vector3 localDirection;
                localDirection.x = 0;
                localDirection.y = 0;
                localDirection.z = 1;
                Vector3 cameraZDirection = cameraTransform.TransformDirection(localDirection);

                localDirection.x = 1;
                localDirection.y = 0;
                localDirection.z = 0;
                Vector3 cameraXDirection = cameraTransform.TransformDirection(localDirection);


                return GetHandleSize(Gizmos.matrix.MultiplyPoint3x4(position), camera, camera.pixelWidth * 0.5f, camera.pixelHeight * 0.5f, cameraTransform.position, cameraZDirection, cameraXDirection);
            }

            return 20f;
        }

        /// <summary>
        /// Much like HandleUtility.GetHandleSize(), but works for gizmos
        /// </summary>
        /// <param name="position"> handle position in world space</param>
        /// <param name="camera"> the camera through which the object is displayed</param>
        /// <param name="cameraCenterWidth"> camera.pixelWidth * 0.5f</param>
        /// <param name="cameraCenterHeight"> camera.pixelHeight * 0.5f</param>
        /// <param name="cameraPosition"> camera.transform.position</param>
        /// <param name="cameraZDirection"> camera.transform.forward</param>
        /// <param name="cameraXDirection"> camera.transform.right</param>
        public static float GetHandleSize(Vector3 position, Camera camera, float cameraCenterWidth, float cameraCenterHeight, Vector3 cameraPosition, Vector3 cameraZDirection, Vector3 cameraXDirection)
        {
            //inlined version of Vector3.Dot(positionMinusCameraPosition, cameraZDirection)
            float z = (position.x - cameraPosition.x) * cameraZDirection.x +
                      (position.y - cameraPosition.y) * cameraZDirection.y +
                      (position.z - cameraPosition.z) * cameraZDirection.z;

            //OPTIM
            //If you reaaaally need those extra milliseconds, use this
            //return z * 0.15f;
            //This will give a good enough result. The problem with this method is that the handle size is unsatisfying when transitioning between Perspective and Orthogonal view, and when the scene view window is too narrow to the point that it changes the FOV of the scene view.

            Vector3 b;
            {
                Vector3 camPosPlusDirB;
                camPosPlusDirB.x = cameraPosition.x + cameraZDirection.x * z + cameraXDirection.x;
                camPosPlusDirB.y = cameraPosition.y + cameraZDirection.y * z + cameraXDirection.y;
                camPosPlusDirB.z = cameraPosition.z + cameraZDirection.z * z + cameraXDirection.z;
                b = camera.WorldToScreenPoint(camPosPlusDirB, Camera.MonoOrStereoscopicEye.Mono);
            }

            float aMinusBX = cameraCenterWidth - b.x;
            float aMinusBY = cameraCenterHeight - b.y;
            return 80f / (float)Math.Sqrt(aMinusBX * aMinusBX +
                                          aMinusBY * aMinusBY);
        }

        public static void SetPlayerPrefs<T>(string key, T value)
        {
            Type tt = typeof(T);
            if (tt.IsEnum)
            {
                PlayerPrefs.SetInt(key, Convert.ToInt32(Enum.Parse(typeof(T), value.ToString()) as Enum));
            }
            else if (tt.IsArray)
            {
                throw new System.NotImplementedException();
            }
            else if (tt.Matches(typeof(int), typeof(Int32)))
                PlayerPrefs.SetInt(key, (value as int?).Value);
            else if (tt == typeof(string))
                PlayerPrefs.SetString(key, (value as string));
            else if (tt == typeof(float))
                PlayerPrefs.SetFloat(key, (value as float?).Value);
            else if (tt == typeof(bool))
                PlayerPrefs.SetInt(key, ((value as bool?).Value == true) ? 1 : 0);
            else if (tt == typeof(Color))
                PlayerPrefs.SetString(key, (value as Color?).Value.ToHtml());
            else
                Debug.LogError("[DevTools.SetEditorPrefs] Unsupported datatype: " + tt.Name);
        }

        public static T GetPlayerPrefs<T>(string key, T defaultValue)
        {
            if (PlayerPrefs.HasKey(key))
            {
                Type tt = typeof(T);
                try
                {
                    if (tt.IsEnum || tt.Matches(typeof(int), typeof(Int32)))
                    {
                        return (T)(object)PlayerPrefs.GetInt(key, (int)(object)defaultValue);
                    }
                    else if (tt.IsArray)
                    {
                        throw new System.NotImplementedException();
                    }
                    else if (tt == typeof(string))
                        return (T)(object)PlayerPrefs.GetString(key, defaultValue.ToString());
                    else if (tt == typeof(float))
                        return (T)(object)PlayerPrefs.GetFloat(key, (float)(object)defaultValue);
                    else if (tt == typeof(bool))
                        return (T)(object)(PlayerPrefs.GetInt(key, ((bool)(object)defaultValue == true) ? 1 : 0) == 1);
                    else if (tt == typeof(Color))
                        return (T)(object)PlayerPrefs.GetString(key, ((Color)(object)defaultValue).ToHtml()).ColorFromHtml();
                    else
                        Debug.LogError("[DevTools.SetEditorPrefs] Unsupported datatype: " + tt.Name);
                }
                catch (Exception e)
                {
                    Debug.LogException(e);
                    return defaultValue;
                }
            }


            return defaultValue;
        }

        public static float RandomSign()
        {
            return UnityEngine.Random.Range(0, 2) * 2 - 1;
        }

        public static string GetHelpUrl(object forClass)
        {
            return (forClass == null) ? string.Empty : GetHelpUrl(forClass.GetType());
        }

        public static string GetHelpUrl(Type classType)
        {
            if (classType != null)
            {
                object[] attribs = classType.GetCustomAttributes(typeof(HelpURLAttribute), true);
                if (attribs.Length > 0)
                    return (((HelpURLAttribute)attribs[0]).URL);
            }
            return string.Empty;
        }

        public static Vector3 GetCenterPosition(Vector3 fallback, params Vector3[] vectors)
        {
            if (vectors.Length == 0)
                return fallback;
            Vector3 v = vectors[0];
            for (int i = 1; i < vectors.Length; i++)
                v += vectors[i];
            return (v / vectors.Length);
        }

        public static T CreateGameObject<T>(Transform parent, string name) where T : MonoBehaviour
        {
            GameObject go = new GameObject(name);
            go.transform.parent = parent;
            go.transform.localPosition = Vector3.zero;
            go.transform.localRotation = Quaternion.identity;
            T cmp = go.AddComponent<T>();
            return cmp;
        }

#if UNITY_EDITOR
        /// <summary>
        /// Returns true if the object's prefab instance status allows for deletion
        /// </summary>
        /// <param name="object">The input object to test</param>
        /// <param name="errorMessage"> Is set to empty string if method returns true, otherwise it is set to a message error, similar to the one display by Unity, explaining the issue.</param>
        /// <see cref="PrefabInstanceStatus"/>
        public static bool DoesPrefabStatusAllowDeletion(this UnityEngine.Object @object, out string errorMessage)
        {
            PrefabInstanceStatus prefabInstanceStatus = default;
            bool isDeletionAllowed = @object is GameObject == false || DoesPrefabStatusAllowDeletion((GameObject)@object, out prefabInstanceStatus);
            if (isDeletionAllowed == false)
            {
                errorMessage = $"You initiated an operation that leads to the deletion of the Game Object '{@object.name}', which is part of a Prefab instance.\n\n";
                if (prefabInstanceStatus == PrefabInstanceStatus.MissingAsset)
                    errorMessage += "The Prefab asset is missing. You have to unpack the Prefab instance to be able to execute this operation";
                else
                    errorMessage += $"Children of a Prefab instance cannot be deleted or moved, and components cannot be reordered. \n\nYou have to open the Prefab in Prefab Mode to restructure the Prefab Asset itself, or unpack the Prefab instance to remove its Prefab connection.";
            }
            else
            {
                errorMessage = string.Empty;
            }

            return isDeletionAllowed;
        }

        /// <summary>
        /// Returns true if the object's prefab instance status allows for deletion
        /// </summary>
        /// <param name="gameObject">The input object to test</param>
        /// <param name="prefabInstanceStatus"> The prefab instance status of the gameObject</param>
        public static bool DoesPrefabStatusAllowDeletion(this GameObject gameObject, out PrefabInstanceStatus prefabInstanceStatus)
        {
            prefabInstanceStatus = PrefabUtility.GetPrefabInstanceStatus(gameObject);
            return prefabInstanceStatus != PrefabInstanceStatus.Connected || PrefabUtility.IsOutermostPrefabInstanceRoot(gameObject);
        }
#endif

        /// <summary>
        /// Returns whether the code is executed in edit mode or not
        /// </summary>
        public static bool IsInEditMode
        {
            get
            {
                bool result;
#if UNITY_EDITOR
                result = !Application.isPlaying;
#else
                result = false;
#endif
                return result;
            }
        }
    }

    public static class DTTime
    {
        static float _EditorDeltaTime;
        static float _EditorLastTime;

        public static double TimeSinceStartup
        {
            get
            {
#if UNITY_EDITOR
                if (!Application.isPlaying)
                    return UnityEditor.EditorApplication.timeSinceStartup;
#endif
                return Time.timeSinceLevelLoad;
            }
        }

        [Obsolete("Seems to me that this is not working properly. Probably because InitializeEditorTime and UpdateEditorTime are never called. Fix this before using it")]
        public static float deltaTime
        {
            get
            {
                return (Application.isPlaying) ? Time.deltaTime : _EditorDeltaTime;
            }
        }

        public static void InitializeEditorTime()
        {
            _EditorLastTime = Time.realtimeSinceStartup;
            _EditorDeltaTime = 0;
        }

        public static void UpdateEditorTime()
        {
            float cur = Time.realtimeSinceStartup;
            float timeDelta = (cur - _EditorLastTime);

            _EditorDeltaTime = timeDelta;
            _EditorLastTime = cur;

            /*
            if (frameDelta > 20 || timeDelta > 1)
            {
                _EditorLastFrame = Time.frameCount;
                _EditorLastTime = cur;
                _EditorDeltaTime = 0;
            }
            else if (frameDelta > 0)
            {
                _EditorDeltaTime = timeDelta / frameDelta;
                _EditorLastTime = cur;
                _EditorLastFrame = Time.frameCount;
            }*/
        }


    }

    public class TimeMeasure : Ring<long>
    {
        public System.Diagnostics.Stopwatch mWatch = new System.Diagnostics.Stopwatch();

        public TimeMeasure(int size) : base(size)
        { }

        public void Start()
        {
            mWatch.Start();
        }

        public void Stop()
        {
            mWatch.Stop();
            Add(mWatch.ElapsedTicks);
            mWatch.Reset();
        }

        public void Pause()
        {
            mWatch.Stop();
        }

        public double LastTicks
        {
            get
            {
                return this[this.Count - 1];
            }
        }

        public double LastMS
        {
            get
            {
                return LastTicks / (double)System.TimeSpan.TicksPerMillisecond;
            }
        }

        public double AverageMS
        {
            get
            {
                long d = 0;
                for (int i = 0; i < this.Count; i++)
                    d += this[i];

                return DTMath.FixNaN((d / (double)System.TimeSpan.TicksPerMillisecond) / Count);
            }
        }

        public double MinimumMS
        {
            get
            {
                long d = long.MaxValue;
                for (int i = 0; i < this.Count; i++)
                    d = System.Math.Min(d, this[i]);

                return DTMath.FixNaN(d / (double)System.TimeSpan.TicksPerMillisecond);
            }
        }

        public double MaximumMS
        {
            get
            {
                long d = long.MinValue;
                for (int i = 0; i < this.Count; i++)
                    d = System.Math.Max(d, this[i]);

                return DTMath.FixNaN(d / (double)System.TimeSpan.TicksPerMillisecond);
            }
        }

        public double AverageTicks
        {
            get
            {
                long d = 0;
                for (int i = 0; i < this.Count; i++)
                    d += this[i];
                return d / (double)Count;
            }
        }

        public double MinimumTicks
        {
            get
            {
                long d = long.MaxValue;
                for (int i = 0; i < this.Count; i++)
                    d = System.Math.Min(d, this[i]);
                return d;
            }
        }

        public double MaximumTicks
        {
            get
            {
                long d = 0;
                for (int i = 0; i < this.Count; i++)
                    d = System.Math.Max(d, this[i]);
                return d;
            }
        }
    }

    public static class DTMath
    {
        public static Vector3 ParallelTransportFrame(Vector3 up, Vector3 tan0, Vector3 tan1)
        {
            Vector3 A = Vector3.Cross(tan0, tan1);
            if (tan0 == -tan1) //Result is undefined in this case
            {
                Debug.LogWarning("[DevTools] ParallelTransportFrame's result is undefined for cases where tan0 == -tan1");
            }
            float a = Mathf.Atan2(A.magnitude, Vector3.Dot(tan0, tan1));
            return Quaternion.AngleAxis(Mathf.Rad2Deg * a, A) * up;
        }

        public static Vector3 LeftTan(ref Vector3 tan, ref Vector3 up)
        {
            return Vector3.Cross(tan, up);
        }

        public static Vector3 RightTan(ref Vector3 tan, ref Vector3 up)
        {
            return Vector3.Cross(up, tan);
        }

        /// <summary>
        /// Much like Mathf.Repeat(), but DTMath.Repeat(v,v) returns v instead of 0
        /// </summary>
        public static float Repeat(float t, float length)
        {
            return (t == length) ? t : t - Mathf.Floor(t / length) * length;
        }

        public static double FixNaN(double v)
        {
            if (double.IsNaN(v))
                v = 0;
            return v;
        }

        public static float FixNaN(float v)
        {
            if (float.IsNaN(v))
                v = 0;
            return v;
        }

        public static Vector2 FixNaN(Vector2 v)
        {
            if (float.IsNaN(v.x))
            {
                v.x = 0;
            }
            if (float.IsNaN(v.y))
            {
                v.y = 0;
            }
            return v;
        }

        /// <summary>
        /// Fixes NaN for Vector3
        /// </summary>
        /// <param name="v">a Vector3</param>
        /// <returns>the "cleaned up" vector</returns>
        public static Vector3 FixNaN(Vector3 v)
        {
            if (float.IsNaN(v.x))
            {
                v.x = 0;
            }
            if (float.IsNaN(v.y))
            {
                v.y = 0;
            }
            if (float.IsNaN(v.z))
            {
                v.z = 0;
            }
            return v;
        }

        /// <summary>
        /// Maps a value from a source range to a destination range
        /// </summary>
        /// <param name="min">min destination value</param>
        /// <param name="max">max destination value</param>
        /// <param name="value">current source value</param>
        /// <param name="vMin">min source value</param>
        /// <param name="vMax">max source value</param>
        /// <returns></returns>
        public static float MapValue(float min, float max, float value, float vMin = -1, float vMax = 1)
        {
            return min + (max - min) * (value - vMin) / (vMax - vMin);
        }

        public static float SnapPrecision(float value, int decimals)
        {
            return (decimals >= 0) ? (float)System.Math.Round(value, decimals) : value;
        }

        public static Vector2 SnapPrecision(Vector2 value, int decimals)
        {
            if (decimals < 0)
                return value;

            value.Set(SnapPrecision(value.x, decimals), SnapPrecision(value.y, decimals));
            return value;
        }

        public static Vector3 SnapPrecision(Vector3 value, int decimals)
        {
            if (decimals < 0)
                return value;
            value.Set(SnapPrecision(value.x, decimals), SnapPrecision(value.y, decimals), SnapPrecision(value.z, decimals));
            return value;
        }

        /// <summary>
        /// Gets the squared distance to the nearest point on a line
        /// </summary>
        /// <param name="l1">Line P1</param>
        /// <param name="l2">Line P2</param>
        /// <param name="p">a Point</param>
        /// <param name="frag">fragment on the line (0..1) of the nearest point</param>
        /// <returns>sqrMagnitude</returns>
        public static float LinePointDistanceSqr(Vector3 l1, Vector3 l2, Vector3 p, out float frag)
        {
            Vector3 v = l2;
            v.x -= l1.x;
            v.y -= l1.y;
            v.z -= l1.z;

            Vector3 w = p;
            w.x -= l1.x;
            w.y -= l1.y;
            w.z -= l1.z;

            float c1 = Vector3.Dot(w, v);
            if (c1 <= 0)
            {
                frag = 0;
                return w.sqrMagnitude;
            }
            float c2 = Vector3.Dot(v, v);
            if (c2 <= c1)
            {
                frag = 1;

                Vector3 pMinusl2 = p;
                pMinusl2.x -= l2.x;
                pMinusl2.y -= l2.y;
                pMinusl2.z -= l2.z;

                return pMinusl2.sqrMagnitude;
            }
            frag = c1 / c2;

            Vector3 fragMulv = v;
            fragMulv.x *= frag;
            fragMulv.y *= frag;
            fragMulv.z *= frag;

            Vector3 pb = l1;
            pb.x += fragMulv.x;
            pb.y += fragMulv.y;
            pb.z += fragMulv.z;

            Vector3 pMinuspb = p;
            pMinuspb.x -= pb.x;
            pMinuspb.y -= pb.y;
            pMinuspb.z -= pb.z;

            return pMinuspb.sqrMagnitude;
        }

        /// <summary>
        /// Collide a ray (point + direction) against a line segment and return the hit point
        /// </summary>
        /// <param name="r0">Ray position</param>
        /// <param name="dir">Ray direction</param>
        /// <param name="l1">Line P1</param>
        /// <param name="l2">Line P2</param>
        /// <param name="hit">Collision Point</param>
        /// <param name="frag">fragment on the line (0..1) of the collision point</param>
        /// <returns>true if collision occurs</returns>
        public static bool RayLineSegmentIntersection(Vector2 r0, Vector2 dir, Vector2 l1, Vector2 l2, out Vector2 hit, out float frag)
        {
            Vector2 s2 = l2 - l1;
            float t;
            frag = (-dir.y * (r0.x - l1.x) + dir.x * (r0.y - l1.y)) / (-s2.x * dir.y + dir.x * s2.y);
            t = (s2.x * (r0.y - l1.y) - s2.y * (r0.x - l1.x)) / (-s2.x * dir.y + dir.x * s2.y);

            if (frag >= 0 && frag <= 1 && t > 0)
            {
                hit = new Vector2(r0.x + (t * dir.x), r0.y + (t * dir.y));
                return true;
            }
            hit = Vector2.zero;
            return false;
        }

        /// <summary>
        /// Calculates the intersection line segment between 2 lines (not segments).
        /// </summary>
        /// <returns>false if no solution can be found</returns>
        public static bool ShortestIntersectionLine(Vector3 line1A, Vector3 line1B,
            Vector3 line2A, Vector3 line2B, out Vector3 resultSegmentA, out Vector3 resultSegmentB)
        {
            // Algorithm is ported from the C algorithm of 
            // Paul Bourke at http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline3d/
            resultSegmentA = Vector3.zero;
            resultSegmentB = Vector3.zero;

            Vector3 p1 = line1A;
            Vector3 p2 = line1B;
            Vector3 p3 = line2A;
            Vector3 p4 = line2B;
            Vector3 p13 = p1 - p3;
            Vector3 p43 = p4 - p3;

            if (p43.sqrMagnitude < Mathf.Epsilon)
            {
                return false;
            }
            Vector3 p21 = p2 - p1;
            if (p21.sqrMagnitude < Mathf.Epsilon)
            {
                return false;
            }

            double d1343 = p13.x * (double)p43.x + (double)p13.y * p43.y + (double)p13.z * p43.z;
            double d4321 = p43.x * (double)p21.x + (double)p43.y * p21.y + (double)p43.z * p21.z;
            double d1321 = p13.x * (double)p21.x + (double)p13.y * p21.y + (double)p13.z * p21.z;
            double d4343 = p43.x * (double)p43.x + (double)p43.y * p43.y + (double)p43.z * p43.z;
            double d2121 = p21.x * (double)p21.x + (double)p21.y * p21.y + (double)p21.z * p21.z;

            double denom = d2121 * d4343 - d4321 * d4321;
            if (System.Math.Abs(denom) < double.Epsilon)
            {
                return false;
            }
            double numer = d1343 * d4321 - d1321 * d4343;

            double mua = numer / denom;
            double mub = (d1343 + d4321 * (mua)) / d4343;
            resultSegmentA = new Vector3((float)(p1.x + mua * p21.x), (float)(p1.y + mua * p21.y), (float)(p1.z + mua * p21.z));
            resultSegmentB = new Vector3((float)(p3.x + mub * p43.x), (float)(p3.y + mub * p43.y), (float)(p3.z + mub * p43.z));
            return true;
        }

        /// <summary>
        /// Calculates the intersection between two line segments
        /// </summary>
        /// <returns>false if no solution can be found</returns>
        public static bool LineLineIntersection(Vector3 line1A, Vector3 line1B, Vector3 line2A, Vector3 line2B, out Vector3 hitPoint)
        {
            Vector3 resB;
            if (ShortestIntersectionLine(line1A, line1B, line2A, line2B, out hitPoint, out resB))
            {
                if ((resB - hitPoint).sqrMagnitude <= Mathf.Epsilon * Mathf.Epsilon)
                    return true;
            }
            return false;
        }

        public static bool LineLineIntersect(Vector2 line1A, Vector2 line1B, Vector2 line2A, Vector2 line2B, out Vector2 hitPoint, bool segmentOnly = true)
        {
            hitPoint = Vector2.zero;
            // Denominator for ua and ub are the same, so store this calculation
            double d =
               (line2B.y - line2A.y) * (line1B.x - line1A.x)
               -
               (line2B.x - line2A.x) * (line1B.y - line1A.y);

            //n_a and n_b are calculated as seperate values for readability
            double n_a =
               (line2B.x - line2A.x) * (line1A.y - line2A.y)
               -
               (line2B.y - line2A.y) * (line1A.x - line2A.x);

            double n_b =
               (line1B.x - line1A.x) * (line1A.y - line2A.y)
               -
               (line1B.y - line1A.y) * (line1A.x - line2A.x);

            // Make sure there is not a division by zero - this also indicates that
            // the lines are parallel.  
            // If n_a and n_b were both equal to zero the lines would be on top of each 
            // other (coincidental).  This check is not done because it is not 
            // necessary for this implementation (the parallel check accounts for this).
            if (d == 0)
                return false;

            // Calculate the intermediate fractional point that the lines potentially intersect.
            double ua = n_a / d;
            double ub = n_b / d;

            // The fractional point will be between 0 and 1 inclusive if the lines
            // intersect.  If the fractional calculation is larger than 1 or smaller
            // than 0 the lines would need to be longer to intersect.
            if (!segmentOnly || (ua >= 0d && ua <= 1d && ub >= 0d && ub <= 1d))
            {
                hitPoint.Set((float)(line1A.x + (ua * (line1B.x - line1A.x))), (float)(line1A.y + (ua * (line1B.y - line1A.y))));
                return true;
            }
            return false;
        }

        public static bool PointInsideTriangle(Vector3 A, Vector3 B, Vector3 C, Vector3 p, out float ac, out float ab, bool edgesAllowed)
        {
            Vector3 v0 = C - A;
            Vector3 v1 = B - A;
            Vector3 v2 = p - A;
            float dot00 = Vector3.Dot(v0, v0);
            float dot01 = Vector3.Dot(v0, v1);
            float dot02 = Vector3.Dot(v0, v2);
            float dot11 = Vector3.Dot(v1, v1);
            float dot12 = Vector3.Dot(v1, v2);
            float invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
            ac = (dot11 * dot02 - dot01 * dot12) * invDenom;
            ab = (dot00 * dot12 - dot01 * dot02) * invDenom;
            if (edgesAllowed)
                return ac >= 0 && ab >= 0 && (ac + ab < 1);
            else
                return ac > 0 && ab > 0 && (ac + ab < 1);
        }
    }

    /// <summary>
    /// Extended UnityEvent
    /// </summary>
    public class UnityEventEx<T0> : UnityEvent<T0>
    {
        object mCallerList;
        MethodInfo mCallsCount;
        int mCount = -1;

        /// <summary>
        /// Removes and adds a listener, ensuring it's only bound once
        /// </summary>
        /// <param name="call"></param>
        public void AddListenerOnce(UnityAction<T0> call)
        {
            base.RemoveListener(call);
            base.AddListener(call);
            CheckForListeners();
        }

        /// <summary>
        /// Whether the event has any listeners at all
        /// </summary>
        /// <returns></returns>
        public bool HasListeners()
        {
            if (mCallsCount == null)
            {
                FieldInfo fi = typeof(UnityEventBase).FieldByName("m_Calls", false, true);
                if (fi != null)
                {
                    mCallerList = fi.GetValue(this);
                    if (mCallerList != null)
                        mCallsCount = mCallerList.GetType().PropertyByName("Count").GetGetMethod();
                }
            }
            if (mCount == -1)
            {
                if (mCallerList != null && mCallsCount != null)
                    mCount = (int)mCallsCount.Invoke(mCallerList, null); //.GetValue(mCallerList, null);
                mCount += GetPersistentEventCount();
            }
            return (mCount > 0);
        }

        /// <summary>
        /// Force HasListeners() to recheck for dynamically bound events
        /// </summary>
        public void CheckForListeners()
        {
            mCount = -1;
        }
    }

    /// <summary>
    /// Same functionality as various UnityEngine.Debug methods
    /// </summary>
    /// <remarks>Used to distinct between temporarly debug output and regular package output</remarks>
    public static class DTLog
    {
        public static void Log(object message)
        {
            Debug.Log(message);
        }

        public static void Log(object message, [CanBeNull] Object context)
        {
            Debug.Log(message, context);
        }

        public static void LogError(object message)
        {
            Debug.LogError(message);
        }

        public static void LogError(object message, [CanBeNull] Object context)
        {
            Debug.LogError(message, context);
        }

        public static void LogErrorFormat(string format, params object[] args)
        {
            Debug.LogErrorFormat(format, args);
        }

        public static void LogErrorFormat(UnityEngine.Object context, string format, params object[] args)
        {
            Debug.LogErrorFormat(context, format, args);
        }

        public static void LogException(Exception exception)
        {
            Debug.LogException(exception);
        }

        public static void LogException(Exception exception, [CanBeNull] Object context)
        {
            Debug.LogException(exception, context);
        }

        public static void LogFormat(string format, params object[] args)
        {
            Debug.LogFormat(format, args);
        }

        public static void LogFormat(UnityEngine.Object context, string format, params object[] args)
        {
            Debug.LogFormat(context, format, args);
        }

        public static void LogWarning(object message)
        {
            Debug.LogWarning(message);
        }

        public static void LogWarning(object message, [CanBeNull] Object context)
        {
            Debug.LogWarning(message, context);
        }

        public static void LogWarningFormat(string format, params object[] args)
        {
            Debug.LogWarningFormat(format, args);
        }

        public static void LogWarningFormat(Object context, string format, params object[] args)
        {
            Debug.LogWarningFormat(context, format, args);
        }
    }

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/DTUtility.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/PropertyAttributes.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eed9fb14b94dcae4e826c61c76e7e7b2
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;
using System;
using System.Reflection;

namespace FluffyUnderware.DevTools
{
    public enum DTMessageType
    {
        None = 0,
        Info = 1,
        Warning = 2,
        Error = 3,
    }

    public enum AttributeOptionsFlags : int
    {
        None = 0,
        Compact = 1,
        Clipboard = 128,
        Zero = 256,
        One = 512,
        Negate = 1024,
        Full = 1920,
        FullCompact = 1921
    }

    public class DTPropertyAttribute : PropertyAttribute
    {
        
        public string Label;
        public string Tooltip;
        public string Color;
        public AttributeOptionsFlags Options;
        public int Precision = -1;

        public DTPropertyAttribute(string label="", string tooltip = "")
        {
            Label = label;
            Tooltip = tooltip;
        }
    }

    public class LabelAttribute : DTPropertyAttribute
    {
        public LabelAttribute() : base() { }
        public LabelAttribute(string label, string tooltip = "") : base(label, tooltip) { }
    }

    public class ToggleButtonAttribute : DTPropertyAttribute
    {
        public ToggleButtonAttribute(string label = "", string tooltip = "") : base(label, tooltip)
        {
        }
    }

    public class LayerAttribute : DTPropertyAttribute
    {
        public LayerAttribute(string label = "", string tooltip = "")
            : base(label, tooltip)
        {
        }
    }

    public class TagAttribute : DTPropertyAttribute
    {
        public TagAttribute(string label = "", string tooltip = "")
            : base(label, tooltip)
        {
        }
    }

    public class VectorExAttribute : DTPropertyAttribute
    {
        public VectorExAttribute(string label = "", string tooltip = "") : base(label, tooltip)
        {
            Options = AttributeOptionsFlags.Full;
        }
    }

    public class AnimationCurveExAttribute : DTPropertyAttribute
    {
        public AnimationCurveExAttribute(string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            Options = AttributeOptionsFlags.Clipboard;
        }
    }

    public class MinAttribute : DTPropertyAttribute
    {
        public float MinValue;
        public string MinFieldOrPropertyName;

        public MinAttribute(float value, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MinValue = value;
        }

        public MinAttribute(string fieldOrProperty, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MinFieldOrPropertyName = fieldOrProperty;
        }
    }

    public class PositiveAttribute : MinAttribute
    {
        public PositiveAttribute() : base(0) { }
    }

    public class MaxAttribute : DTPropertyAttribute
    {
        public float MaxValue;
        public string MaxFieldOrPropertyName;

        public MaxAttribute(float value, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MaxValue = value;
        }

        public MaxAttribute(string fieldOrProperty, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MaxFieldOrPropertyName = fieldOrProperty;
        }
    }

    public class RangeExAttribute : DTPropertyAttribute
    {
        public float MinValue;
        public string MinFieldOrPropertyName;
        public float MaxValue;
        public string MaxFieldOrPropertyName;
        public bool Slider=true;

        public RangeExAttribute(float minValue, float maxValue, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MinValue = minValue;
            MaxValue = maxValue;
        }

        public RangeExAttribute(string minFieldOrProperty, float maxValue, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MinFieldOrPropertyName = minFieldOrProperty;
            MaxValue = maxValue;
        }

        public RangeExAttribute(float minValue, string  maxFieldOrProperty, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MinValue = minValue;
            MaxFieldOrPropertyName = maxFieldOrProperty;
        }

        public RangeExAttribute(string minFieldOrProperty, string maxFieldOrProperty, string label = "", string tooltip = "")
            : base(label, tooltip)
        {
            MinFieldOrPropertyName = minFieldOrProperty;
            MaxFieldOrPropertyName = maxFieldOrProperty;
        }

    }

    public class MinMaxAttribute : DTPropertyAttribute
    {
        public readonly string MaxValueField;
        public float Min;
        public string MinBoundFieldOrPropertyName;
        public float Max;
        public string MaxBoundFieldOrPropertyName;

        public MinMaxAttribute(string maxValueField, string label="", string tooltip="") : base(label, tooltip) 
        {
            MaxValueField = maxValueField;
            Min = 0;
            Max = 1;
        }
    }

    public class EnumFlagAttribute : DTPropertyAttribute
    {
        public EnumFlagAttribute(string label = "", string tooltip = "") : base(label,tooltip) { }
    }

    public class ObjectSelectorAttribute : DTPropertyAttribute
    {
        public ObjectSelectorAttribute(string label = "", string tooltip = "") : base(label, tooltip)
        { }
    }

    public class PathSelectorAttribute : DTPropertyAttribute
    {
        public enum DialogMode
        {
            OpenFile,
            OpenFolder,
            CreateFile
        }

        public readonly DialogMode Mode;
        public string Title;
        public string Directory;
        public string Extension;
        public string DefaultName;

        public PathSelectorAttribute(DialogMode mode=DialogMode.OpenFile)
        {
            Mode = mode;
            Directory = Application.dataPath;
        }
    }

    public class EnumSelectionGridAttribute : DTPropertyAttribute
    {
        public EnumSelectionGridAttribute(string label="",string tooltip="") : base(label,tooltip) { }
    }

    public class DTRegionAttribute : DTPropertyAttribute
    {
        public bool RegionIsOptional;
        public string RegionOptionsPropertyName;
        public bool UseSlider=true;
    }

    public class FloatRegionAttribute : DTRegionAttribute { }
    public class IntRegionAttribute : DTRegionAttribute { }

    public struct RegionOptions<T>
    {
        public string LabelFrom;
        public string LabelTo;
        public string OptionalTooltip;
        public DTValueClamping ClampFrom;
        public DTValueClamping ClampTo;
        public T FromMin;
        public T FromMax;
        public T ToMin;
        public T ToMax;

        public static RegionOptions<T> Default
        {
            get
            {
                return new RegionOptions<T>
                {
                    OptionalTooltip = "Range",
                    LabelFrom= "From",
                    LabelTo= "To",
                    ClampFrom = DTValueClamping.None,
                    ClampTo = DTValueClamping.None
                };
            }
        }

        public static RegionOptions<T> MinMax(T min, T max)
        {
            return new RegionOptions<T>
            {
                LabelFrom = "From",
                LabelTo = "To",
                ClampFrom = DTValueClamping.Range,
                ClampTo = DTValueClamping.Range,
                FromMin=min,
                FromMax=max,
                ToMin=min,
                ToMax=max
            };
            
        }
    }

    public enum DTValueClamping
    {
        None = 0,
        Min = 1,
        Max = 2,
        Range = 3
    }

    
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/PropertyAttributes.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/ThreadPoolWorker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a997f755ef82a3e439a530a09753ae2f
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;
using System;
using System.Collections.Generic;
using System.Linq;
#if ENABLE_IL2CPP == false
using System.Linq.Expressions;
#endif
using System.Runtime.CompilerServices;
using UnityEngine.Assertions;
#if !UNITY_WSA && !UNITY_WEBGL
using System.Threading;
#endif

namespace FluffyUnderware.DevTools
{
    /// <summary>
    /// A class to execute actions in a multi-threaded way
    /// </summary>
    /// <typeparam name="T">The type of the action input</typeparam>
    public class ThreadPoolWorker<T> : IDisposable
    {
        //TODO OPTIM Is ThreadPoolWorker still needed. Aren't all unity version handling .Net's parallel fors now?
#if !UNITY_WSA && !UNITY_WEBGL
        private readonly SimplePool<QueuedCallback> queuedCallbackPool = new SimplePool<QueuedCallback>(4);
        private readonly SimplePool<LoopState<T>> loopStatePool = new SimplePool<LoopState<T>>(4);

        private int _remainingWorkItems = 1;
        private ManualResetEvent _done = new ManualResetEvent(false);
        private readonly WaitCallback handleWorkItemCallBack;
        private readonly WaitCallback handleLoopCallBack;

        public ThreadPoolWorker()
        {
            handleWorkItemCallBack = o =>
            {
                QueuedCallback queuedCallback = (QueuedCallback)o;
                try
                {
                    queuedCallback.Callback(queuedCallback.State);
                }
                finally
                {
                    lock (queuedCallbackPool)
                        queuedCallbackPool.ReleaseItem(queuedCallback);
                    DoneWorkItem();
                }
            };

            handleLoopCallBack = state =>
            {
                LoopState<T> loopS = (LoopState<T>)state;
                for (int i = loopS.StartIndex; i <= loopS.EndIndex; i++)
                {
                    loopS.Action(loopS.Items.ElementAt(i), i, loopS.ItemsCount);
                }
                lock (loopStatePool)
                    loopStatePool.ReleaseItem(loopS);
            };
        }

        [Obsolete("Use ParallelFor(Action<T,int,int> action, IEnumerable<T> list) instead")]
        public void ParralelFor(Action<T> action, List<T> list)
        {
            ParallelFor((item, itemIndex, itemsCount) => action(item), list, list.Count());
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ParallelFor(Action<T, int, int> action, IEnumerable<T> list)
        {
            ParallelFor(action, list, list.Count());
        }

        public void ParallelFor(Action<T, int, int> action, IEnumerable<T> list, int elementsCount)
        {
            int threadsToUseCount;
            {
                int availableThreads;
#if NET_4_6
                int temp;
                ThreadPool.GetAvailableThreads(out availableThreads, out temp);
#else
                availableThreads = Environment.ProcessorCount - 1;
#endif
                threadsToUseCount = 1 /*main thread*/ + Math.Min(availableThreads, Environment.ProcessorCount - 1 /*keep one processor for the main thead*/);
            }
            //BUG a bug in iterationPerThread leads to sometimes not using all available threads. For example, if you have 5 items and 4 cores, only 3 cores will be used
            int iterationPerThread = threadsToUseCount == 1
                ? elementsCount
                : (int)Math.Ceiling((float)elementsCount / threadsToUseCount);
#if CURVY_SANITY_CHECKS
            Assert.IsTrue(iterationPerThread * threadsToUseCount >= elementsCount);
#endif
            int currentIndex = 0;
            while (currentIndex < elementsCount)
            {
                int endEndex = Math.Min(currentIndex + iterationPerThread - 1, elementsCount - 1);

                if (endEndex == elementsCount - 1)
                    for (int i = currentIndex; i <= endEndex; i++)
                        action(list.ElementAt(i), i, elementsCount);
                else
                {

                    QueuedCallback queuedCallback;
                    {
                        lock (queuedCallbackPool)
                            queuedCallback = queuedCallbackPool.GetItem();
                    }


                    LoopState<T> loopState;
                    {
                        lock (loopStatePool)
                            loopState = loopStatePool.GetItem();
                    }

                    loopState.Set((short)currentIndex,
                        (short)endEndex,
                        list,
                        elementsCount,
                        action);

                    queuedCallback.State = loopState;
                    queuedCallback.Callback = handleLoopCallBack;

                    ThrowIfDisposed();
                    //Debug.LogWarning("New thread " + " from "+ loopState.StartIndex +  " to " + loopState.EndIndex);
                    lock (_done)
                        _remainingWorkItems++;
                    ThreadPool.QueueUserWorkItem(handleWorkItemCallBack, queuedCallback);
                }
                currentIndex = endEndex + 1;
            }

            WaitAll(-1, false);
        }

        bool WaitAll(int millisecondsTimeout, bool exitContext)
        {
            ThrowIfDisposed();
            DoneWorkItem();
            bool rv = _done.WaitOne(millisecondsTimeout, exitContext);
            lock (_done)
            {
                if (rv)
                {
                    _remainingWorkItems = 1;
                    _done.Reset();
                }
                else
                    _remainingWorkItems++;
            }
            return rv;
        }

        private void ThrowIfDisposed()
        {
            if (_done == null)
                throw new ObjectDisposedException(GetType().Name);
        }

        private void DoneWorkItem()
        {
            lock (_done)
            {
                --_remainingWorkItems;
                if (_remainingWorkItems == 0)
                    _done.Set();
            }
        }

        public void Dispose()
        {
            if (_done != null)
            {
                ((IDisposable)_done).Dispose();
                _done = null;
            }
        }
#else
        public ThreadPoolWorker()
        {
        }

        [Obsolete("Use ParallelFor(Action<T,int,int> action, IEnumerable<T> list) instead")]
        public void ParralelFor(Action<T> action, List<T> list)
        {
            for (var i = 0; i < list.Count; i++)
                action(list[i]);
        }

        public void ParallelFor(Action<T, int, int> action, IEnumerable<T> list)
        {
            ParallelFor(action, list, list.Count());
        }

        public void ParallelFor(Action<T, int, int> action, IEnumerable<T> list, int elementsCount)
        {
            for (int i = 0; i < elementsCount; i++)
                action(list.ElementAt(i), i, elementsCount);
        }

        public void Dispose()
        {
        }
#endif
    }

    internal class SimplePool<T> where T : new()
    {
        private readonly List<T> freeItemsBackfield;
#if ENABLE_IL2CPP == false
        private static readonly Func<T> OptimizedInstantiator = Expression.Lambda<Func<T>>(
            Expression.New(typeof(T))
        ).Compile();
#endif

        public SimplePool(int preCreatedElementsCount)
        {
            freeItemsBackfield = new List<T>();
            for (int i = 0; i < preCreatedElementsCount; i++)
                freeItemsBackfield.Add(
#if ENABLE_IL2CPP == false
                    OptimizedInstantiator.Invoke()
#else
                    new T()
#endif
                    );
        }

        public T GetItem()
        {
            T item;
            if (freeItemsBackfield.Count == 0)
                item =
#if ENABLE_IL2CPP == false
                    OptimizedInstantiator.Invoke()
#else
                    new T()
#endif
                    ;
            else
            {
                int lastIndex = freeItemsBackfield.Count - 1;
                item = freeItemsBackfield[lastIndex];
                freeItemsBackfield.RemoveAt(lastIndex);
            }
            return item;
        }

        public void ReleaseItem(T item)
        {
            freeItemsBackfield.Add(item);
        }
    }

#if !UNITY_WSA && !UNITY_WEBGL
    class QueuedCallback
    {
        public WaitCallback Callback;
        public object State;
    }

    class LoopState<T>
    {
        public short StartIndex { get; private set; }
        public short EndIndex { get; private set; }
        public IEnumerable<T> Items { get; private set; }
        public int ItemsCount { get; private set; }
        public Action<T, int, int> Action { get; private set; }

        public LoopState()
        {
        }

        public LoopState(short startIndex, short endIndex, IEnumerable<T> items, int itemsCount, Action<T, int, int> action)
        {
            Set(startIndex, endIndex, items, itemsCount, action);
        }

        public void Set(short startIndex, short endIndex, IEnumerable<T> items, int itemsCount, Action<T, int, int> action)
        {
            StartIndex = startIndex;
            EndIndex = endIndex;
            Items = items;
            ItemsCount = itemsCount;
            Action = action;
        }
    }
#endif


    /// <summary>
    /// This class is not very optimized. For better performance, use the generic version of ThreadPoolWorker instead
    /// </summary>
#if !UNITY_WSA && !UNITY_WEBGL
    [Obsolete("Use ThreadPoolWorker<T> instead")]
    public class ThreadPoolWorker : IDisposable
    {
        private int _remainingWorkItems = 1;
        private ManualResetEvent _done = new ManualResetEvent(false);

        public void QueueWorkItem(WaitCallback callback)
        {
            QueueWorkItem(callback, null);
        }

        public void QueueWorkItem(Action act)
        {
            QueueWorkItem(act, null);
        }

        public void ParralelFor<T>(Action<T> action, List<T> list)
        {
            int threadsToUseCount;
            {
                int availableThreads;
#if NET_4_6
                int temp;
                ThreadPool.GetAvailableThreads(out availableThreads, out temp);
#else
                availableThreads = Environment.ProcessorCount - 1;
#endif
                threadsToUseCount = 1 /*main thread*/ + Math.Min(availableThreads, Environment.ProcessorCount - 1 /*keep one processor for the main thead*/);
            }
            int iterationsCount = list.Count;
            if (threadsToUseCount == 1 || iterationsCount == 1)
            {
                for (int i = 0; i < iterationsCount; i++)
                {
                    action(list[i]);
                }
            }
            else
            {
                int iterationPerThread = (int)Math.Ceiling((float)iterationsCount / threadsToUseCount);
                int currentIndex = 0;
                while (currentIndex < iterationsCount)
                {
                    QueuedCallback queuedCallback = new QueuedCallback();

                    int endEndex = Math.Min(currentIndex + iterationPerThread, iterationsCount - 1);

                    LoopState<T> loopState = new LoopState<T>((short)currentIndex,
                        (short)endEndex,
                        list,
                        iterationsCount,
                        (item,
                            itemIndex,
                            itemsCount) => action(item));
                    queuedCallback.State = loopState;

                    queuedCallback.Callback = state =>
                    {
                        LoopState<T> loopS = (LoopState<T>)state;
                        for (int i = loopS.StartIndex; i <= loopS.EndIndex; i++)
                        {
                            loopS.Action(loopS.Items.ElementAt(i), i, iterationsCount);
                        }
                    };


                    QueueWorkItem(queuedCallback);

                    currentIndex = endEndex + 1;
                }
            }
        }

        private void QueueWorkItem(QueuedCallback callback)
        {
            ThrowIfDisposed();
            lock (_done)
                _remainingWorkItems++;
            ThreadPool.QueueUserWorkItem(new WaitCallback(HandleWorkItem), callback);
        }

        public void QueueWorkItem(WaitCallback callback, object state)
        {
            QueuedCallback qc = new QueuedCallback();
            qc.Callback = callback;
            qc.State = state;
            QueueWorkItem(qc);
        }

        public void QueueWorkItem(Action act, object state)
        {
            QueuedCallback qc = new QueuedCallback();
            qc.Callback = (x => act());
            qc.State = state;
            QueueWorkItem(qc);
        }

        public bool WaitAll()
        {
            return WaitAll(-1, false);
        }

        public bool WaitAll(TimeSpan timeout, bool exitContext)
        {
            return WaitAll((int)timeout.TotalMilliseconds, exitContext);
        }

        public bool WaitAll(int millisecondsTimeout, bool exitContext)
        {
            ThrowIfDisposed();
            DoneWorkItem();
            bool rv = _done.WaitOne(millisecondsTimeout, exitContext);
            lock (_done)
            {
                if (rv)
                {
                    _remainingWorkItems = 1;
                    _done.Reset();
                }
                else
                    _remainingWorkItems++;
            }
            return rv;
        }

        private void HandleWorkItem(object state)
        {
            QueuedCallback qc = (QueuedCallback)state;
            try
            {
                qc.Callback(qc.State);
            }
            finally
            {
                DoneWorkItem();
            }
        }

        private void DoneWorkItem()
        {
            lock (_done)
            {
                --_remainingWorkItems;
                if (_remainingWorkItems == 0)
                    _done.Set();
            }
        }

        private void ThrowIfDisposed()
        {
            if (_done == null)
                throw new ObjectDisposedException(GetType().Name);
        }

        public void Dispose()
        {
            if (_done != null)
            {
                ((IDisposable)_done).Dispose();
                _done = null;
            }
        }
    }
#else
    public class ThreadPoolWorker{}
#endif

}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Classes/ThreadPoolWorker.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/ComponentPool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 62f98941b92097f49bd5ff480ec47122
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.DevTools.Extensions;
#if CURVY_SANITY_CHECKS_PRIVATE
using UnityEngine.Assertions;
#endif
using UnityEngine.SceneManagement;

namespace FluffyUnderware.DevTools
{
    /// <summary>
    /// A pool of instances of the UnityEngine.Component class
    /// </summary>
    [HelpURL(DTUtility.HelpUrlBase + "dtcomponentpool")]
    public class ComponentPool : DTVersionedMonoBehaviour, IPool, ISerializationCallbackReceiver
    {
        [SerializeField, HideInInspector]
        private string m_Identifier;

        [Inline]
        [SerializeField]
        private PoolSettings m_Settings;

        public PoolSettings Settings
        {
            get { return m_Settings; }
            set
            {
                if (m_Settings != value)
                    m_Settings = value;
                if (m_Settings != null)
                    m_Settings.OnValidate();
            }
        }

        private PoolManager mManager;

        public PoolManager Manager
        {
            get
            {
                if (mManager == null)
                    mManager = GetComponent<PoolManager>();
                return mManager;
            }
        }

        /// <summary>
        /// Due to bad design decisions, Identifier is used to store the type of the pooled objects. And the setter does nothing
        /// </summary>
        public string Identifier
        {
            get
            {
#if CURVY_SANITY_CHECKS_PRIVATE
                Assert.IsNotNull(m_Identifier);
#endif
                return m_Identifier;
            }
            set
            {
                throw new InvalidOperationException("Component pool's identifier should always indicate the pooled type's assembly qualified name");
                /*Here is why:
                In the Initialize method, m_Identifier is set as a fully qualified type name.
                The Type getter uses m_Identifier as a fully qualified type name.
                If needed, add a field that contains the pooled type name, and use it instead of Identifier when you need to find the right pool for the right component type*/
            }
        }

        /// <summary>
        /// The type of the pooled objects
        /// </summary>
        public Type Type
        {
            get
            {
                Type type = Type.GetType(Identifier);
                if (type == null)
                    DTLog.LogWarning("[DevTools] ComponentPool's Type is an unknown type " + m_Identifier, this);
                return type;
            }
        }


        public int Count
        {
            get { return mObjects.Count; }
        }

        private readonly List<Component> mObjects = new List<Component>();

        private double mLastTime;
        private double mDeltaTime;

        public void Initialize(Type type, PoolSettings settings)
        {
            m_Identifier = type.AssemblyQualifiedName;
#if CURVY_SANITY_CHECKS_PRIVATE
            Assert.IsNotNull(m_Identifier);
#endif
            m_Settings = settings;
            mLastTime = DTTime.TimeSinceStartup + UnityEngine.Random.Range(0, Settings.Speed);
            if (Settings.Prewarm)
                Reset();
        }

        private void Start()
        {
            if (Settings.Prewarm)
                Reset();
        }

#if UNITY_EDITOR
        private void OnValidate()
        {
            Settings = m_Settings;
        }
#endif

        private void OnEnable()
        {
            SceneManager.sceneLoaded += OnSceneLoaded;
        }

        public void Update()
        {
            if (Application.isPlaying)
            {
                mDeltaTime += DTTime.TimeSinceStartup - mLastTime;
                mLastTime = DTTime.TimeSinceStartup;

                if (Settings.Speed > 0)
                {
                    int c = (int)(mDeltaTime / Settings.Speed);
                    mDeltaTime -= c;

                    if (Count > Settings.Threshold)
                    {
                        c = Mathf.Min(c, Count - Settings.Threshold);
                        while (c-- > 0)
                        {
                            if (Settings.Debug)
                                log("Threshold exceeded: Deleting item");
                            destroy(mObjects[0]);
                            mObjects.RemoveAt(0);
                        }
                    }
                    else if (Count < Settings.MinItems)
                    {
                        c = Mathf.Min(c, Settings.MinItems - Count);
                        while (c-- > 0)
                        {
                            if (Settings.Debug)
                                log("Below MinItems: Adding item");
                            mObjects.Add(create());
                        }
                    }
                }
                else
                    mDeltaTime = 0;
            }
        }

        public void Reset()
        {
            if (Application.isPlaying)
            {
                while (Count < Settings.MinItems)
                {
                    mObjects.Add(create());
                }
                while (Count > Settings.Threshold)
                {
                    destroy(mObjects[0]);
                    mObjects.RemoveAt(0);
                }
                if (Settings.Debug)
                    log("Prewarm/Reset");
            }
        }

        public void OnSceneLoaded(Scene scn, LoadSceneMode mode)
        {
            for (int i = mObjects.Count - 1; i >= 0; i--)
                if (mObjects[i] == null)
                    mObjects.RemoveAt(i);
        }

        public void Clear()
        {
            if (Settings.Debug)
                log("Clear");
            for (int i = 0; i < Count; i++)
                destroy(mObjects[i]);
            mObjects.Clear();
        }

        public void Push(Component item)
        {
            sendBeforePush(item);
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                item.gameObject.Destroy(false, true);
            }
            else
#endif
                if (item != null)
            {
                mObjects.Add(item);
                item.transform.parent = Manager.transform;
                item.gameObject.hideFlags = (Settings.Debug)
                    ? HideFlags.DontSave
                    : HideFlags.HideAndDontSave;
                if (Settings.AutoEnableDisable)
                    item.gameObject.SetActive(false);
            }
        }

        public Component Pop(Transform parent = null)
        {
            Component item = null;
            if (Count > 0)
            {
                item = mObjects[0];
                mObjects.RemoveAt(0);
            }
            else
            {
                if (Settings.AutoCreate || !Application.isPlaying)
                {
                    if (Settings.Debug)
                        log("Auto create item");
                    item = create();
                }
            }
            if (item)
            {
                item.gameObject.hideFlags = HideFlags.None;
                item.transform.parent = parent;
                if (Settings.AutoEnableDisable)
                    item.gameObject.SetActive(true);
                sendAfterPop(item);
                if (Settings.Debug)
                    log("Pop " + item);
            }

            return item;
        }

        public T Pop<T>(Transform parent) where T : Component
        {
            return Pop(parent) as T;
        }

        private Component create()
        {
            GameObject go = new GameObject();
            go.name = Identifier;
            go.transform.parent = Manager.transform;
            if (Settings.AutoEnableDisable)
                go.SetActive(false);
            Type componentType = Type;
            Component component = null;
            if (componentType != null)
                component = go.AddComponent(componentType);
            else
                DTLog.LogError(String.Format("[DevTools] ComponentPool {0} could not create component because the associated type is null", m_Identifier), this);
            return component;
        }

        private void destroy(Component item)
        {
            if (item != null)
                item.gameObject.Destroy(false, true);
        }

        private void setParent(Component item, Transform parent)
        {
            if (item != null)
                item.transform.parent = parent;
        }

        private void sendAfterPop(Component item)
        {
            GameObject itemGameObject = item.gameObject;
            if (itemGameObject.activeSelf && itemGameObject.activeInHierarchy)
                //Send message works only for active game objects. Source: https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html
                itemGameObject.SendMessage(nameof(IPoolable.OnAfterPop), SendMessageOptions.DontRequireReceiver);
            else
            {
                if (item is IPoolable)
                    ((IPoolable)item).OnAfterPop();
                else
                    DTLog.LogWarning("[Curvy] sendAfterPop could not send message because the receiver " + item.name + " is not active", this);
            }
        }

        private void sendBeforePush(Component item)
        {
            GameObject itemGameObject = item.gameObject;
            if (itemGameObject.activeSelf && itemGameObject.activeInHierarchy)
                //Send message works only for active game objects. Source: https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html
                itemGameObject.SendMessage(nameof(IPoolable.OnBeforePush), SendMessageOptions.DontRequireReceiver);
            else
            {
                if (item is IPoolable)
                    ((IPoolable)item).OnBeforePush();
                else
                    DTLog.LogWarning("[Curvy] sendBeforePush could not send message because the receiver " + item.name + " is not active", this);
            }
        }

        private void log(string msg)
        {
            Debug.Log(string.Format("[{0}] ({1} items) {2}", Identifier, Count, msg));
        }

        #region ISerializationCallbackReceiver
        /*! \cond PRIVATE */
        /// <summary>
        /// Implementation of UnityEngine.ISerializationCallbackReceiver
        /// Called automatically by Unity, is not meant to be called by Curvy's users
        /// </summary>
        public void OnBeforeSerialize()
        {
        }

        /// <summary>
        /// Implementation of UnityEngine.ISerializationCallbackReceiver
        /// Called automatically by Unity, is not meant to be called by Curvy's users
        /// </summary>
        public void OnAfterDeserialize()
        {
            if (Type.GetType(m_Identifier) == null)
            {

                //Handles cases where the component is migrated to another assembly (for example if using Unity's Assembly Definitions feature

                const char separator = ',';
                const string separatorString = ",";
                string[] splittedAssemblyQualifiedName = m_Identifier.Split(separator);
                if (splittedAssemblyQualifiedName.Length >= 5)
                {
                    string typeName = String.Join(separatorString, splittedAssemblyQualifiedName.SubArray(0, splittedAssemblyQualifiedName.Length - 4));
                    //As you can see with this example: 
                    //"FluffyUnderware.Curvy.CurvySplineSegment, ToolBuddy.Curvy, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null"
                    //the 4 last elements do not contain the type name. Keep in mind that a type name can include a ',' like  Dictionary<int, List<double>>

#if UNITY_EDITOR
                    var knownTypes = UnityEditor.TypeCache.GetTypesDerivedFrom(typeof(System.Object));
#else

                    Type[] knownTypes = TypeExt.GetLoadedTypes();

#endif
                    Type type = knownTypes.FirstOrDefault(t => t.FullName == typeName);
                    if (type != null)
                    {
                        m_Identifier = type.AssemblyQualifiedName;
#if CURVY_SANITY_CHECKS_PRIVATE
                        Assert.IsNotNull(m_Identifier);
#endif
                    }
                }
            }
        }
        /*! \endcond */
        #endregion
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/ComponentPool.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DTSingleton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: be97567edb4b04d4b864736d9e10f36f
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.DevTools.Extensions;
using UnityEngine;

namespace FluffyUnderware.DevTools
{

    public class DTSingleton<T> : MonoBehaviour, IDTSingleton where T : MonoBehaviour, IDTSingleton
    {
        static T _instance;
        static readonly object _lock = new object();
        static bool applicationIsQuitting = false;
        bool isDuplicateInstance = false;

        public static bool HasInstance
        {
            get { return _instance != null; }
        }

        public static T Instance
        {
            get
            {
                if (!Application.isPlaying)
                    applicationIsQuitting = false;
                if (applicationIsQuitting)
                    return null;

                if (_instance == null)
                    lock (_lock)
                        if (_instance == null)
                        {
                            IEnumerable<Object> objectsOfTypeT = FindObjectsOfType(typeof(T)).Where(o => o != null);
#if CURVY_SANITY_CHECKS
                            if (objectsOfTypeT.Count() != FindObjectsOfType(typeof(T)).Length)
                                DTLog.LogError("[Curvy] DTSingleton.Instance : FindObjectsOfType " + typeof(T).FullName + " returned at least one null reference");
#endif                              

                            _instance = objectsOfTypeT.Any()
                                ? (T)objectsOfTypeT.ElementAt(0)
                                : new GameObject().AddComponent<T>();
                        }

                return _instance;
            }
        }

        public virtual void Awake()
        {
            T instance = Instance;
            lock (_lock)
            {
                if (instance == null)
                    DTLog.LogError("[DevTools] DTSingleton instance was null. This happens if the instance is destroyed by the user, which is not a supported operation. If you did not destroy the singleton's instance, then please fill a bug report.", this);
                else
                    if (GetInstanceID() != instance.GetInstanceID())
                    {
                        instance.MergeDoubleLoaded((IDTSingleton)this);
                        this.isDuplicateInstance = true;
                        this.Invoke(nameof(DestroySelf), 0);
                    }
            }
        }

        protected virtual void OnDestroy()
        {
            lock (_lock)
                if (Application.isPlaying && !isDuplicateInstance)
                {
                    applicationIsQuitting = true;
                    _instance = null;
                }
        }

        public virtual void MergeDoubleLoaded(IDTSingleton newInstance)
        {
        }

        void DestroySelf()
        {
            gameObject.Destroy(false, true);
        }

    }

    public interface IDTSingleton
    {
        void MergeDoubleLoaded(IDTSingleton newInstance);
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DTSingleton.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DTVersionedMonoBehaviour.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b3c2cf93621e06d43b51fbde3128ce03
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using System;
using UnityEngine;
using System.Collections;
using FluffyUnderware.DevTools.Extensions;

namespace FluffyUnderware.DevTools
{
    /// <summary>
    /// A MonoBehaviour with a version number, useful to handle upgrades if needed
    /// </summary>
    public abstract class DTVersionedMonoBehaviour : MonoBehaviour
    {
        [SerializeField, HideInInspector]
        string m_Version;

        /// <summary>
        /// Gets the version of this component
        /// </summary>
        public string Version
        {
            get { return m_Version; }
            protected set { m_Version = value; }
        }

        /// <summary>
        /// Destroys the gameobject
        /// </summary>
        [Obsolete("Use ObjectExt.Destroy(...) instead")]
        public void Destroy()
        {
            gameObject.Destroy(false, true);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DTVersionedMonoBehaviour.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DuplicateEditorMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a648044f27666564a9cf38d201465713
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;


namespace FluffyUnderware.DevTools
{
    /// <summary>
    /// Add this script to a GameObject with a MeshFilter to ensure it will be properly duplicated in the editor!
    /// </summary>
    /// <remarks>On Duplicating, Awake() checks if the sharedMesh is already used in the scene. If yes, a new mesh will be created to ensure that each sharedMesh is unique</remarks>
    [ExecuteAlways]
    [RequireComponent(typeof(MeshFilter))]
    public abstract class DuplicateEditorMesh : DTVersionedMonoBehaviour
    {
        MeshFilter mFilter;

        public MeshFilter Filter
        {
            get {
                if (mFilter == null)
                    mFilter = GetComponent<MeshFilter>();
                return mFilter; 
            }
        }

        protected virtual void Awake()
        {
            if (!Application.isPlaying)
            {
                MeshFilter meshFilter = Filter;
                if (meshFilter && meshFilter.sharedMesh != null)
                {
                    DuplicateEditorMesh[] otherWatchdogs = GameObject.FindObjectsOfType<DuplicateEditorMesh>();
                    foreach (DuplicateEditorMesh dog in otherWatchdogs)
                    {
                        if (dog != this)
                        {
                            MeshFilter otherMF = dog.Filter;
                            if (otherMF && otherMF.sharedMesh == meshFilter.sharedMesh)
                            {
                                Mesh m = new Mesh();
                                m.name = otherMF.sharedMesh.name;
                                meshFilter.mesh = m;
                            }
                        }
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/DuplicateEditorMesh.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/InspectorNote.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eed5f71264f54224aaf071d6a2e69915
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;

namespace FluffyUnderware.DevTools
{
    /// <summary>
    /// A component to display notes in the inspector
    /// </summary>
    [HelpURL(DTUtility.HelpUrlBase + "dtinspectornode")]
    public class InspectorNote : DTVersionedMonoBehaviour
    {

        [TextArea(5,20)]
        [SerializeField]
        string m_Note;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/InspectorNote.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/PoolManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3d8a3277e999b164d99f199328dc5d2d
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;

namespace FluffyUnderware.DevTools
{
    /// <summary>
    /// Manages the object's pools components
    /// </summary>
    [HelpURL(DTUtility.HelpUrlBase + "dtpoolmanager")]
    [ExecuteAlways]
    [DisallowMultipleComponent]
    public class PoolManager : DTVersionedMonoBehaviour
    {
        [Section("General")]
        [SerializeField]
        bool m_AutoCreatePools = true;

        [AsGroup(Expanded = false)]
        [SerializeField]
        PoolSettings m_DefaultSettings = new PoolSettings();

        public bool AutoCreatePools
        {
            get { return m_AutoCreatePools; }
            set
            {
                if (m_AutoCreatePools != value)
                    m_AutoCreatePools = value;
            }
        }

        public PoolSettings DefaultSettings
        {
            get { return m_DefaultSettings; }
            set
            {
                if (m_DefaultSettings != value)
                    m_DefaultSettings = value;
                if (m_DefaultSettings != null)
                    m_DefaultSettings.OnValidate();
            }
        }

        public bool IsInitialized { get; private set; }
        public int Count { get { return Pools.Count + TypePools.Count; } }

        public Dictionary<string, IPool> Pools = new Dictionary<string, IPool>();

        public Dictionary<Type, IPool> TypePools = new Dictionary<Type, IPool>();

        IPool[] mPools = new IPool[0];

#if UNITY_EDITOR
        void OnValidate()
        {
            DefaultSettings = m_DefaultSettings;
        }
#endif

        void OnDisable()
        {
            IsInitialized = false;
        }

        void Update()
        {
            bool initialize;
#if UNITY_EDITOR
            //this forces the pool manager to initialize every frame. Not a good idea.
            //I assume it was done to force the checks done in the Initialize method to be executed every frame, to handle pools duplication for example.
            //A better way to do this would be to separate initialization with checks, and execute the checks only when needed
            initialize = !Application.isPlaying;
#else
            initialize = !IsInitialized;
#endif
            if (initialize)
                Initialize();

            if (mPools.Length != TypePools.Count)
            {
                System.Array.Resize(ref mPools, TypePools.Count);
                TypePools.Values.CopyTo(mPools, 0);
            }
            for (int i = 0; i < mPools.Length; i++)
                mPools[i].Update();
        }

        void Initialize()
        {
            Pools.Clear();
            IPool[] goPools = GetComponents<IPool>();
            foreach (IPool p in goPools)
            {
                if (p is ComponentPool)
                {
                    if (Pools.ContainsKey(p.Identifier) == false)
                        Pools.Add(p.Identifier, p);
                    else
                    {
                        DTLog.Log("[DevTools] Found a duplicated ComponentPool for type " + p.Identifier + ". The duplicated pool will be destroyed", this);
                        (p as ComponentPool).Destroy(false, false);
                    }
                }
                else
                {
                    p.Identifier = GetUniqueIdentifier(p.Identifier);
                    Pools.Add(p.Identifier, p);
                }
            }

            IsInitialized = true;
        }

        [NotNull]
        public string GetUniqueIdentifier([NotNull] string ident)
        {
            int num = 0;
            string id = ident;
            while (Pools.ContainsKey(id))
                id = ident + (++num).ToString();
            return id;
        }


        public Pool<T> GetTypePool<T>()
        {
            IPool res;
            if (!TypePools.TryGetValue(typeof(T), out res))
            {
                if (AutoCreatePools)
                {
                    res = CreateTypePool<T>();
                }
            }
            return (Pool<T>)res;
        }

        public ComponentPool GetComponentPool<T>() where T : Component
        {
            if (!IsInitialized)
                Initialize();
            IPool res;
            if (!Pools.TryGetValue(typeof(T).AssemblyQualifiedName, out res))
            {
                if (AutoCreatePools)
                {
                    res = CreateComponentPool<T>();
                }
            }
            return (ComponentPool)res;
        }

        public PrefabPool GetPrefabPool([NotNull] string identifier, params GameObject[] prefabs)
        {
            if (!IsInitialized)
                Initialize();
            IPool pool;
            if (!Pools.TryGetValue(identifier, out pool))
            {
                if (AutoCreatePools)
                    pool = CreatePrefabPool(identifier, null, prefabs);
            }
            return (PrefabPool)pool;
        }

        public Pool<T> CreateTypePool<T>(PoolSettings settings = null)
        {
            PoolSettings s = settings ?? new PoolSettings(DefaultSettings);
            IPool res;
            if (!TypePools.TryGetValue(typeof(T), out res))
            {
                res = new Pool<T>(s);
                TypePools.Add(typeof(T), res);
            }
            return (Pool<T>)res;
        }

        public ComponentPool CreateComponentPool<T>(PoolSettings settings = null) where T : Component
        {
            if (!IsInitialized)
                Initialize();
            PoolSettings s = settings ?? new PoolSettings(DefaultSettings);
            IPool res;
            if (!Pools.TryGetValue(typeof(T).AssemblyQualifiedName, out res))
            {
                res = gameObject.AddComponent<ComponentPool>();
                ((ComponentPool)res).Initialize(typeof(T), s);
                Pools.Add(res.Identifier, res);
            }
            return (ComponentPool)res;
        }

        public PrefabPool CreatePrefabPool([NotNull] string name, PoolSettings settings = null, params GameObject[] prefabs)
        {
            if (!IsInitialized)
                Initialize();
            PoolSettings s = settings ?? new PoolSettings(DefaultSettings);

            IPool pool;
            if (!Pools.TryGetValue(name, out pool))
            {
                PrefabPool p = gameObject.AddComponent<PrefabPool>();
                p.Initialize(name, s, prefabs);
                Pools.Add(name, p);
                return p;
            }
            return (PrefabPool)pool;
        }

        public List<IPool> FindPools(string identifierStartsWith)
        {
            List<IPool> res = new List<IPool>();
            foreach (KeyValuePair<string, IPool> kv in Pools)
                if (kv.Key.StartsWith(identifierStartsWith))
                    res.Add(kv.Value);
            return res;
        }

        public void DeletePools(string startsWith)
        {
            List<IPool> toDelete = FindPools(startsWith);
            for (int i = toDelete.Count - 1; i >= 0; i--)
                DeletePool(toDelete[i]);

        }

        public void DeletePool(IPool pool)
        {
            if (pool is PrefabPool || pool is ComponentPool)
            {
                ((MonoBehaviour)pool).Destroy(false, false);
                Pools.Remove(pool.Identifier);
            }
        }

        public void DeletePool<T>()
        {
            TypePools.Remove(typeof(T));
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/PoolManager.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/PrefabPool.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4f3bdfa960a223645a04f11686263106
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================

using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System.Collections;
using System;
using System.Collections.Generic;
using System.Linq;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;

namespace FluffyUnderware.DevTools
{
    /// <summary>
    /// A pool of instances of a prefab GameObject
    /// </summary>
    [RequireComponent(typeof(PoolManager))]
    [HelpURL(DTUtility.HelpUrlBase + "dtprefabpool")]
    public class PrefabPool : DTVersionedMonoBehaviour, IPool
    {
        [FieldCondition(nameof(m_Identifier), "", false, ActionAttribute.ActionEnum.ShowWarning, "Please enter an identifier! (Select a prefab to set automatically)")]
        [SerializeField]
        string m_Identifier = String.Empty;

        [SerializeField]
        List<GameObject> m_Prefabs = new List<GameObject>();

        [Inline]
        [SerializeField]
        PoolSettings m_Settings;



        PoolManager mManager;

        public string Identifier
        {
            get { return m_Identifier; }
            set
            {
                if (m_Identifier != value)
                {
                    m_Identifier = value;
                }
            }

        }
        public List<GameObject> Prefabs
        {
            get { return m_Prefabs; }
            set
            {
                if (m_Prefabs != value)
                    m_Prefabs = value;
            }
        }


        public PoolSettings Settings
        {
            get { return m_Settings; }
            set
            {
                if (m_Settings != value)
                    m_Settings = value;
                if (m_Settings != null)
                    m_Settings.OnValidate();
            }
        }

        [Obsolete("This member is no more used by Curvy Splines, and will get removed in a future update. Use GetComponent<PoolManager>() instead")]
        public PoolManager Manager
        {
            get
            {
                if (mManager == null)
                    mManager = GetComponent<PoolManager>();
                return mManager;
            }
        }

        List<GameObject> mObjects = new List<GameObject>();

        double mLastTime;
        double mDeltaTime;

        void Start()
        {
            if (Settings.Prewarm)
                Reset();
        }

#if UNITY_EDITOR
        void OnValidate()
        {
            Settings = m_Settings;
            if (m_Identifier == String.Empty && Prefabs.Any(p => p != null))
                Identifier = Prefabs.First().name;
        }
#endif

        public void Initialize([NotNull] string ident, PoolSettings settings, params GameObject[] prefabs)
        {
            Identifier = ident;
            m_Settings = settings;
            Prefabs = new List<GameObject>(prefabs);
            mLastTime = DTTime.TimeSinceStartup + UnityEngine.Random.Range(0, Settings.Speed);
            if (Settings.Prewarm)
                Reset();
        }

        public void Update()
        {
            if (Application.isPlaying)
            {
                mDeltaTime += DTTime.TimeSinceStartup - mLastTime;
                mLastTime = DTTime.TimeSinceStartup;

                if (Settings.Speed > 0)
                {
                    int c = (int)(mDeltaTime / Settings.Speed);
                    mDeltaTime -= c;

                    if (Count > Settings.Threshold)
                    {
                        c = Mathf.Min(c, Count - Settings.Threshold);
                        while (c-- > 0)
                        {
                            if (Settings.Debug)
                                log("Threshold exceeded: Deleting item");
                            destroy(mObjects[0]);
                            mObjects.RemoveAt(0);
                        }
                    }
                    else if (Count < Settings.MinItems)
                    {
                        c = Mathf.Min(c, Settings.MinItems - Count);
                        while (c-- > 0)
                        {
                            if (Settings.Debug)
                                log("Below MinItems: Adding item");
                            mObjects.Add(create());
                        }
                    }
                }
                else
                    mDeltaTime = 0;
            }
        }

        public void Reset()
        {
            if (Application.isPlaying)
            {
                while (Count < Settings.MinItems)
                {
                    mObjects.Add(create());
                }
                while (Count > Settings.Threshold)
                {
                    destroy(mObjects[0]);
                    mObjects.RemoveAt(0);
                }
                if (Settings.Debug)
                    log("Prewarm/Reset");
            }
        }

        public void Clear()
        {
            if (Settings.Debug)
                log("Clear");
            for (int i = 0; i < Count; i++)
                destroy(mObjects[i]);
            mObjects.Clear();
        }

        public int Count
        {
            get { return mObjects.Count; }
        }

        public GameObject Pop(Transform parent = null)
        {
            GameObject item = null;
            if (Count > 0)
            {
                item = mObjects[0];
                mObjects.RemoveAt(0);
            }
            else
            {
                if (Settings.AutoCreate || !Application.isPlaying)
                {
                    if (Settings.Debug)
                        log("Auto create item");
                    item = create();
                }
            }
            if (item)
            {
                item.hideFlags = HideFlags.None;
                item.transform.parent = parent;
                if (Settings.AutoEnableDisable)
                    item.SetActive(true);
                sendAfterPop(item);
                if (Settings.Debug)
                    log("Pop " + item);
            }

            return item;
        }

        public virtual void Push(GameObject item)
        {
            if (Settings.Debug)
                log("Push " + item);
#if UNITY_EDITOR
            if (!Application.isPlaying)
            {
                item.Destroy(false, true);
            }
            else
#endif
            if (item != null)
            {
                sendBeforePush(item);
                mObjects.Add(item);
                item.transform.parent = transform;
                item.hideFlags = (Settings.Debug) ? HideFlags.DontSave : HideFlags.HideAndDontSave;
                if (Settings.AutoEnableDisable)
                    item.SetActive(false);
            }
        }

        GameObject create()
        {
            if (Prefabs.Count == 0)
                throw new InvalidOperationException(String.Format("[Curvy] The Prefab Pool '{0}' in game object '{1}' could not create a pool element because its Prefabs list is empty", this.Identifier, this.gameObject.name));

            //TODO should this Random.Range call be deterministic?
            GameObject prefab = Prefabs[UnityEngine.Random.Range(0, Prefabs.Count)];
            GameObject result;
            {
#if UNITY_EDITOR
                bool isPrefabAsset;
                //We have to check GetPrefabInstanceStatus first, because GetPrefabAssetType returns (as far as I understand) the same thing for both a prefab asset and a prefab instance
                if (PrefabUtility.GetPrefabInstanceStatus(prefab) == PrefabInstanceStatus.NotAPrefab)
                {
                    PrefabAssetType prefabAssetType = PrefabUtility.GetPrefabAssetType(prefab);
                    isPrefabAsset = prefabAssetType == PrefabAssetType.Regular || prefabAssetType == PrefabAssetType.Variant;
                }
                else
                    isPrefabAsset = false;

                result = isPrefabAsset
                    ? PrefabUtility.InstantiatePrefab(prefab) as GameObject
                    : Instantiate(prefab);
#else
                result = Instantiate(prefab);
#endif
            }

            result.name = prefab.name;
            result.transform.parent = transform;
            if (Settings.AutoEnableDisable)
                result.SetActive(false);
            return result;
        }

        void destroy(GameObject go)
        {
            go.Destroy(false, true);
        }

        void log(string msg)
        {
            Debug.Log(string.Format("[{0}] ({1} items) {2}", Identifier, Count, msg));
        }

        void setParent(Transform item, Transform parent)
        {
            if (item != null)
                item.parent = parent;
        }

        void sendAfterPop(GameObject item)
        {
            item.SendMessage(nameof(IPoolable.OnAfterPop), SendMessageOptions.DontRequireReceiver);
        }

        void sendBeforePush(GameObject item)
        {
            item.SendMessage(nameof(IPoolable.OnBeforePush), SendMessageOptions.DontRequireReceiver);
        }


    }


}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Components/PrefabPool.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Extensions/Extensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c750636a308f02746931c9fd1a75c27a
# ASMDEF: ToolBuddy.Curvy.dll
# ---
// =====================================================================
// Copyright 2013-2017 Fluffy Underware
// All rights reserved
// 
// http://www.fluffyunderware.com
// =====================================================================
using UnityEngine;
using System.Collections;
using System;
using System.Reflection;
using System.Collections.Generic;
using UnityEngine.Events;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System.Text;
using System.IO;
using System.Linq;
using Object = UnityEngine.Object;

namespace FluffyUnderware.DevTools.Extensions
{
    public static class AnimationCurveExt
    {
        /// <summary>
        /// Returns true if all the values on the curve are equal to 1
        /// </summary>
        public static bool ValueIsOne(this AnimationCurve curve)
        {
            bool result = true;

            const float comparisonMargin = 8 * Single.Epsilon; //Same margin as in Mathf.Approximately
            int keysLength = curve.keys.Length;
            for (int index = 0;
                 index < keysLength;
                 index++)
            {
                Keyframe k = curve.keys[index];

                if (k.inTangent != 0 ||
                    k.outTangent != 0 ||
                    Math.Abs(k.value - 1) > comparisonMargin)
                {
                    result = false;
                    break;
                }
            }

            return result;
        }
    }

    public static class ObjectExt
    {

        /// <summary>
        /// Calls the proper destruction method based on whether we are in Edit mode or not
        /// Will show a display dialogue if attempting to destroy a GameObject part of a prefab instance
        /// </summary>
        /// <param name="object">The object to destroy</param>
        [Obsolete("Use the other overload of this method")]
        public static bool Destroy(this UnityEngine.Object @object)
        {
            return Destroy(@object, true, true);
        }

        /// <summary>
        /// Calls the proper destruction method based on whether we are in Edit mode or not
        /// Will show a display dialogue if attempting to destroy a GameObject part of a prefab instance
        /// </summary>
        /// <param name="object">The object to destroy</param>
        /// <param name="isUndoable">Should the object destruction be undoable</param>
        /// <param name="doPrefabCheck">Should this method check that the object destruction is valid, i.e. not deleting a game object that is part of a prefab instance</param>
        public static bool Destroy(this UnityEngine.Object @object, bool isUndoable, bool doPrefabCheck)
        {
            bool wasDestroyed;

            bool isInEditMode = DTUtility.IsInEditMode;

            if (isInEditMode)
            {
#if UNITY_EDITOR
                string errorMessage = string.Empty;
                bool needsPrefabModification = doPrefabCheck && DTUtility.DoesPrefabStatusAllowDeletion(@object, out errorMessage) == false;
                if (needsPrefabModification)
                {
                    EditorUtility.DisplayDialog($"Cannot delete Game Object '{@object.name}'", errorMessage, "Ok");
                    DTLog.LogError("[Curvy] Invalid operation:" + errorMessage.Replace("\n", String.Empty), @object);

                    wasDestroyed = false;
                }
                else
                {
                    if (isUndoable)
                        Undo.DestroyObjectImmediate(@object);
                    else
                        Object.DestroyImmediate(@object);
                    wasDestroyed = true;
                }
#else
            wasDestroyed = false;
#endif
            }
            else
            {
                if (@object is Component)
                    Object.DestroyImmediate(@object);
                else
                    Object.Destroy(@object);
                wasDestroyed = true;
            }

            return wasDestroyed;
        }

        public static string ToDumpString(this object o)
        {
            return new DTObjectDump(o).ToString();
        }
    }

    public static class FloatExt
    {
        /// <summary>
        /// Return true if v is between 0 and 1 inclusive
        /// </summary>
        public static bool IsBetween0And1(this float v)
        {
            return v >= 0 && v <= 1;
        }

        /// <summary>
        /// Return true if v is between a and b inclusive
        /// </summary>
        public static bool IsBetween(this float v, float a, float b)
        {
            return v >= a && v <= b
                || v >= b && v <= a;
        }
    }

    public static class Vector2Ext
    {
        public static Vector2 Snap(this Vector2 v, float snapX, float snapY = -1)
        {
            if (snapY == -1)
                snapY = snapX;
            return (new Vector2(v.x - v.x % snapX, v.y - v.y % snapY));
        }

        public static float AngleSigned(this Vector2 a, Vector2 b)
        {
            float sign = Mathf.Sign(a.x * b.y - a.y * b.x);
            return Vector2.Angle(a, b) * sign;
        }

        public static Vector2 LeftNormal(this Vector2 v)
        {
            return new Vector2(-v.y, v.x);
        }
        public static Vector2 RightNormal(this Vector2 v)
        {
            return new Vector2(v.y, -v.x);
        }

        public static Vector2 Rotate(this Vector2 v, float degree)
        {
            float rad = degree * Mathf.Deg2Rad;
            float c = Mathf.Cos(rad);
            float s = Mathf.Sin(rad);
            return new Vector2(c * v.x - s * v.y, s * v.x + c * v.y);
        }

        public static Vector2 ToVector3(this Vector2 v)
        {
            return new Vector3(v.x, v.y, 0);
        }


    }

    public static class Vector3Ext
    {
        public static float AngleSigned(this Vector3 a, Vector3 b, Vector3 normal)
        {
            return Mathf.Atan2(Vector3.Dot(normal, Vector3.Cross(a, b)), Vector3.Dot(a, b)) * Mathf.Rad2Deg;
        }

        public static Vector3 RotateAround(this Vector3 point, Vector3 origin, Quaternion rotation)
        {
            Vector3 dir = point - origin;
            dir = rotation * dir;
            return origin + dir;
        }

        public static Vector2 ToVector2(this Vector3 v)
        {
            Vector2 result;
            result.x = v.x;
            result.y = v.y;
            return result;
        }


        /// <summary>
        /// Return true if v1 and v2 are equal, or different but very close.
        /// </summary>
        /// <param name="v1"></param>
        /// <param name="v2"></param>
        /// <returns></returns>
        public static bool Approximately(this Vector3 v1, Vector3 v2)
        {
            Vector3 v1MinusV2 = v1;
            v1MinusV2.x -= v2.x;
            v1MinusV2.y -= v2.y;
            v1MinusV2.z -= v2.z;
            if (Vector3.SqrMagnitude(v1MinusV2) < 0.000001f)
                return true;

            if (Mathf.Approximately(v1.x, v2.x)
                && Mathf.Approximately(v1.y, v2.y)
                && Mathf.Approximately(v1.z, v2.z))
            {
#if CURVY_SANITY_CHECKS_PRIVATE
                Debug.LogWarning("Approximately went in the third branch");
#endif
                return true;
            }

            return false;
        }

        /// <summary>
        /// The opposite of <see cref="Approximately"/>
        /// </summary>
        /// <param name="v1"></param>
        /// <param name="v2"></param>
        /// <returns></returns>
        public static bool NotApproximately(this Vector3 v1, Vector3 v2)
        {
            return Approximately(v1, v2) == false;
        }
    }

    /// <summary>
    /// Extension methods for quaternions
    /// </summary>
    static public class QuaternionExt
    {
        /// <summary>
        /// Two quaternions can represent different rotations that lead to the same final orientation (one rotating around Axis with Angle, the other around -Axis with 2Pi-Angle). In this case, the quaternion == operator will return false. This method will return true.
        /// </summary>
        /// <param name="q1"></param>
        /// <param name="q2"></param>
        /// <returns></returns>
        public static bool SameOrientation(this Quaternion q1, Quaternion q2)
        {
            return Math.Abs((double)Quaternion.Dot(q1, q2)) > 0.999998986721039;
        }

        /// <summary>
        /// Two quaternions can represent different rotations that lead to the same final orientation (one rotating around Axis with Angle, the other around -Axis with 2Pi-Angle). In this case, the quaternion != operator will return true. This method will return false.
        /// </summary>
        /// <param name="q1"></param>
        /// <param name="q2"></param>
        /// <returns></returns>
        public static bool DifferentOrientation(this Quaternion q1, Quaternion q2)
        {
            return Math.Abs((double)Quaternion.Dot(q1, q2)) <= 0.999998986721039;
        }
    }

    public static class GameObjectExt
    {
        /// <summary>
        /// Duplicates a GameObject
        /// </summary>
        /// <param name="source">a component being part of the source GameObject</param>
        /// <returns>the component from the cloned GameObject</returns>
        public static GameObject DuplicateGameObject(this GameObject source, Transform newParent, bool keepPrefabReference = false)
        {
            if (!source)
                return null;

            GameObject newGO;
#if UNITY_EDITOR
            UnityEngine.Object prefabRoot = PrefabUtility.GetCorrespondingObjectFromSource(source.gameObject);

            if (prefabRoot != null && keepPrefabReference)
                newGO = PrefabUtility.InstantiatePrefab(prefabRoot) as GameObject;
            else
#endif
                newGO = Object.Instantiate(source.gameObject) as GameObject;

            if (newGO)
                newGO.transform.parent = newParent;

            return newGO;
        }

        public static void StripComponents(this GameObject go, params Type[] toKeep)
        {
            List<Type> keep = new List<Type>(toKeep)
            {
                typeof(Transform),
                typeof(RectTransform)
            };
            Component[] cmps = go.GetComponents<Component>();
            for (int i = 0; i < cmps.Length; i++)
                if (!keep.Contains(cmps[i].GetType()))
                    cmps[i].Destroy(false, false);
        }
    }

    public static class ComponentExt
    {
        public static void StripComponents(this Component c, params Type[] toKeep)
        {
            if (toKeep.Length == 0)
                c.gameObject.StripComponents(c.GetType());
            else
                c.gameObject.StripComponents(toKeep);
        }

        public static GameObject AddChildGameObject(this Component c, string name)
        {
            GameObject go = new GameObject(name);
            go.transform.SetParent(c.transform);
            return go;
        }

        public static T AddChildGameObject<T>(this Component c, string name) where T : Component
        {
            GameObject go = new GameObject(name);
            if (go)
            {
                go.transform.SetParent(c.transform);
                return go.AddComponent<T>();
            }
            else
                return null;
        }

        /// <summary>
        /// Duplicates the GameObject of a component, returning the component
        /// </summary>
        /// <param name="source">a component being part of the source GameObject</param>
        /// <returns>the component from the cloned GameObject</returns>
        public static T DuplicateGameObject<T>(this Component source, Transform newParent, bool keepPrefabConnection = false) where T : Component
        {
            if (!source || !source.gameObject)
                return null;

            List<Component> cmps = new List<Component>(source.gameObject.GetComponents<Component>());
            int sourceIdx = cmps.IndexOf(source);
            GameObject newGO;
#if UNITY_EDITOR
            UnityEngine.Object prefabRoot = PrefabUtility.GetCorrespondingObjectFromSource(source.gameObject);

            if (prefabRoot != null && keepPrefabConnection)
                newGO = PrefabUtility.InstantiatePrefab(prefabRoot) as GameObject;
            else
#endif
                newGO = Object.Instantiate(source.gameObject);

            if (newGO)
            {
                newGO.transform.SetParent(newParent, false);
                Component[] newCmps = newGO.GetComponents<Component>();
                return newCmps[sourceIdx] as T;
            }
            else
                return null;
        }

        /// <summary>
        /// Duplicates the GameObject of a component, returning the component
        /// </summary>
        /// <param name="source">a component being part of the source GameObject</param>
        /// <returns>the component from the cloned GameObject</returns>
        public static Component DuplicateGameObject(this Component source, Transform newParent, bool keepPrefabConnection = false)
        {
            if (!source || !source.gameObject || !newParent)
                return null;

            List<Component> cmps = new List<Component>(source.gameObject.GetComponents<Component>());
            int sourceIdx = cmps.IndexOf(source);
            GameObject newGO;
#if UNITY_EDITOR
            UnityEngine.Object prefabRoot = PrefabUtility.GetCorrespondingObjectFromSource(source.gameObject);

            if (prefabRoot != null && keepPrefabConnection)
                newGO = PrefabUtility.InstantiatePrefab(prefabRoot) as GameObject;
            else
#endif
                newGO = Object.Instantiate(source.gameObject);

            if (newGO)
            {
                newGO.transform.SetParent(newParent, false);
                Component[] newCmps = newGO.GetComponents<Component>();
                return newCmps[sourceIdx];
            }
            else
                return null;
        }

    }

    public static class ColorExt
    {
        public static string ToHtml(this Color c)
        {
            Color32 col = c;
            return string.Format("#{0:X2}{1:X2}{2:X2}{3:X2}", new object[] { col.r, col.g, col.b, col.a });
        }


    }

    public static class EnumExt
    {

        /// <summary>
        /// Checks if at least one of the provided flags is set in variable
        /// </summary>
        public static bool HasFlag(this Enum variable, params Enum[] flags)
        {
            if (flags.Length == 0)
                throw new ArgumentNullException("flags");

            int varInt = Convert.ToInt32(variable);

            Type T = variable.GetType();
            for (int i = 0; i < flags.Length; i++)
            {
                if (!Enum.IsDefined(T, flags[i]))
                {
                    throw new ArgumentException(string.Format(
                    "Enumeration type mismatch.  The flag is of type '{0}', was expecting '{1}'.",
                    flags[i].GetType(), T));
                }
                int num = Convert.ToInt32(flags[i]);
                if ((varInt & num) == num)
                    return true;
            }
            return false;
        }

        public static bool HasFlag<T>(this T value, T flag) where T : struct
        {
            long lValue = Convert.ToInt64(value);
            long lFlag = Convert.ToInt64(flag);
            return (lValue & lFlag) != 0;
        }

        /// <summary>
        /// Sets a flag
        /// </summary>
        public static T Set<T>(this Enum value, T append) { return Set(value, append, true); }
        /// <summary>
        /// Sets a flag
        /// </summary>
        /// <param name="OnOff">whether to set or unset the value</param>
        public static T Set<T>(this Enum value, T append, bool OnOff)
        {
            if (append == null)
                throw new ArgumentNullException("append");

            Type type = value.GetType();
            //return the final value
            if (OnOff)
                return (T)Enum.Parse(type, (Convert.ToUInt64(value) | Convert.ToUInt64(append)).ToString());
            else
                return (T)Enum.Parse(type, (Convert.ToUInt64(value) & ~Convert.ToUInt64(append)).ToString());
        }
    }

    public static class RectExt
    {

        public static Rect Set(this Rect rect, Vector2 pos, Vector2 size)
        {
            rect.Set(pos.x, pos.y, size.x, size.y);
            return new Rect(rect);
        }

        public static Rect SetBetween(this Rect rect, Vector2 pos, Vector2 pos2)
        {
            rect.Set(pos.x, pos.y, pos2.x - pos.x, pos2.y - pos.y);
            return new Rect(rect);
        }

        /// <summary>
        /// Sets x/y
        /// </summary>
        public static Rect SetPosition(this Rect rect, Vector2 pos)
        {
            rect.x = pos.x;
            rect.y = pos.y;
            return new Rect(rect);
        }

        /// <summary>
        /// Sets x/y
        /// </summary>
        public static Rect SetPosition(this Rect rect, float x, float y)
        {
            rect.x = x;
            rect.y = y;
            return new Rect(rect);
        }

        /// <summary>
        /// gets width/height as Vector2
        /// </summary>
        public static Vector2 GetSize(this Rect rect)
        {
            return new Vector2(rect.width, rect.height);
        }
        /// <summary>
        /// Sets width/height
        /// </summary>
        public static Rect SetSize(this Rect rect, Vector2 size)
        {
            rect.width = size.x;
            rect.height = size.y;
            return new Rect(rect);
        }


        /// <summary>
        /// Grow/Shrink a rect
        /// </summary>
        public static Rect ScaleBy(this Rect rect, int pixel) { return ScaleBy(rect, pixel, pixel); }
        /// <summary>
        /// Grow/Shrink a rect
        /// </summary>
        public static Rect ScaleBy(this Rect rect, int x, int y)
        {
            rect.x -= (float)x;
            rect.y -= (float)y;
            rect.width += (float)x * 2;
            rect.height += (float)y * 2;
            return new Rect(rect);
        }

        public static Rect ShiftBy(this Rect rect, int x, int y)
        {
            rect.x += (float)x;
            rect.y += (float)y;
            return new Rect(rect);
        }

        public static Rect Include(this Rect rect, Rect other)
        {
            Rect r = new Rect();
            r.xMin = Mathf.Min(rect.xMin, other.xMin);
            r.xMax = Mathf.Max(rect.xMax, other.xMax);
            r.yMin = Mathf.Min(rect.yMin, other.yMin);
            r.yMax = Mathf.Max(rect.yMax, other.yMax);
            return r;
        }

    }

    public static class StringExt
    {
        /// <summary>
        /// Converts a HTML color endcoded string int a color
        /// </summary>
        /// <param name="hexString">html color of type [#]rrggbb[aa]</param>
        /// <returns>a Color</returns>
        public static Color ColorFromHtml(this string hexString)
        {
            if (hexString.Length < 9)
                hexString += "FF";
            if (hexString.StartsWith("#") && hexString.Length == 9)
            {
                int[] rgba = new int[4];
                try
                {
                    rgba[0] = int.Parse(hexString.Substring(1, 2), System.Globalization.NumberStyles.HexNumber);
                    rgba[1] = int.Parse(hexString.Substring(3, 2), System.Globalization.NumberStyles.HexNumber);
                    rgba[2] = int.Parse(hexString.Substring(5, 2), System.Globalization.NumberStyles.HexNumber);
                    rgba[3] = int.Parse(hexString.Substring(7, 2), System.Globalization.NumberStyles.HexNumber);
                    return new Color(rgba[0] / 255f, rgba[1] / 255f, rgba[2] / 255f, rgba[3] / 255f);
                }
                catch (Exception e)
                {
                    Debug.LogException(e);
                    return Color.white;
                }
            }
            return Color.white;
        }

        public static string TrimStart(this string s, string trim, StringComparison compare = StringComparison.CurrentCultureIgnoreCase)
        {
            if (!s.StartsWith(trim, compare))
                return s;
            else
            {
                return s.Substring(trim.Length);
            }
        }

        public static string TrimEnd(this string s, string trim, StringComparison compare = StringComparison.CurrentCultureIgnoreCase)
        {
            if (!s.EndsWith(trim, compare))
                return s;
            else
            {
                return s.Substring(0, s.Length - trim.Length);
            }
        }


    }

    public static class IEnumerableExt
    {
        public static void ForEach<T>(this IEnumerable<T> ie, Action<T> action)
        {
            foreach (T i in ie)
            {
                action(i);
            }
        }
    }

    public static class ArrayExt
    {
        public static T[] SubArray<T>(this T[] data, int index, int length)
        {
            length = Mathf.Clamp(length, 0, data.Length - index);
            T[] result = new T[length];
            if (length > 0)
                Array.Copy(data, index, result, 0, length);
            return result;
        }

        public static T[] RemoveAt<T>(this T[] source, int index)
        {
            T[] dest = new T[source.Length - 1];
            if (index > 0)
                Array.Copy(source, 0, dest, 0, index);

            if (index < source.Length - 1)
                Array.Copy(source, index + 1, dest, index, source.Length - index - 1);

            return dest;
        }

        public static T[] InsertAt<T>(this T[] source, int index)
        {
            T[] dest = new T[source.Length + 1];
            index = Mathf.Clamp(index, 0, source.Length - 1);

            if (index > 0)
                Array.Copy(source, 0, dest, 0, index);

            Array.Copy(source, index, dest, index + 1, source.Length - index);

            return dest;
        }

        public static T[] Swap<T>(this T[] source, int index, int with)
        {
            index = Mathf.Clamp(index, 0, source.Length - 1);
            with = Mathf.Clamp(index, 0, source.Length - 1);
            (source[with], source[index]) = (source[index], source[with]);
            return source;
        }

        public static T[] Add<T>(this T[] source, T item)
        {
            Array.Resize(ref source, source.Length + 1);
            source[source.Length - 1] = item;
            return source;
        }

        public static T[] AddRange<T>(this T[] source, T[] items)
        {
            Array.Resize(ref source, source.Length + items.Length);
            Array.Copy(items, 0, source, source.Length - items.Length, items.Length);
            return source;
        }

        public static T[] RemoveDuplicates<T>(this T[] source)
        {
            List<T> res = new List<T>();
            HashSet<T> hash = new HashSet<T>();
            foreach (T p in source)
            {
                if (hash.Add(p))
                {
                    res.Add(p);
                }
            }
            return res.ToArray();
        }

        public static int IndexOf<T>(this T[] source, T item)
        {
            for (int i = 0; i < source.Length; i++)
                if (source[i].Equals(item))
                    return i;
            return -1;
        }

        public static T[] Remove<T>(this T[] source, T item)
        {
            int idx = source.IndexOf<T>(item);
            if (idx > -1)
                return source.RemoveAt<T>(idx);
            else
                return source;
        }
    }

    public static class MeshFilterExt
    {
        /// <summary>
        /// Returns a shared mesh to work with. If existing, it will be cleared
        /// </summary>
        public static Mesh PrepareNewShared(this MeshFilter m, string name = "Mesh")
        {
            if (m == null)
                return null;
            if (m.sharedMesh == null)
            {
                Mesh msh = new Mesh();
                msh.MarkDynamic();
                msh.name = name;
                m.sharedMesh = msh;
            }
            else
            {
                m.sharedMesh.Clear();
                m.sharedMesh.name = name;
                m.sharedMesh.subMeshCount = 0;
            }
            return m.sharedMesh;
        }

        [Obsolete("No more used in Curvy. Will get removed. Copy it if you still need it")]
        public static void CalculateTangents(this MeshFilter m)
        {
            //speed up math by copying the mesh arrays
            int[] triangles = m.sharedMesh.triangles;
            Vector3[] vertices = m.sharedMesh.vertices;
            Vector2[] uv = m.sharedMesh.uv;
            Vector3[] normals = m.sharedMesh.normals;

            if (uv.Length == 0)
                return;

            //variable definitions
            int triangleCount = triangles.Length;
            int vertexCount = vertices.Length;

            Vector3[] tan1 = new Vector3[vertexCount];
            Vector3[] tan2 = new Vector3[vertexCount];

            Vector4[] tangents = new Vector4[vertexCount];

            for (int a = 0; a < triangleCount; a += 3)
            {
                int i1 = triangles[a + 0];
                int i2 = triangles[a + 1];
                int i3 = triangles[a + 2];

                Vector3 v1 = vertices[i1];
                Vector3 v2 = vertices[i2];
                Vector3 v3 = vertices[i3];

                Vector2 w1 = uv[i1];
                Vector2 w2 = uv[i2];
                Vector2 w3 = uv[i3];

                float x1 = v2.x - v1.x;
                float x2 = v3.x - v1.x;
                float y1 = v2.y - v1.y;
                float y2 = v3.y - v1.y;
                float z1 = v2.z - v1.z;
                float z2 = v3.z - v1.z;

                float s1 = w2.x - w1.x;
                float s2 = w3.x - w1.x;
                float t1 = w2.y - w1.y;
                float t2 = w3.y - w1.y;

                float div = s1 * t2 - s2 * t1;
                float r = div == 0.0f ? 0.0f : 1.0f / div;

                float sdirX = (t2 * x1 - t1 * x2) * r;
                float sdirY = (t2 * y1 - t1 * y2) * r;
                float sdirZ = (t2 * z1 - t1 * z2) * r;
                float tdirX = (s1 * x2 - s2 * x1) * r;
                float tdirY = (s1 * y2 - s2 * y1) * r;
                float tdirZ = (s1 * z2 - s2 * z1) * r;

                tan1[i1].x += sdirX;
                tan1[i1].y += sdirY;
                tan1[i1].z += sdirZ;

                tan1[i2].x += sdirX;
                tan1[i2].y += sdirY;
                tan1[i2].z += sdirZ;

                tan1[i3].x += sdirX;
                tan1[i3].y += sdirY;
                tan1[i3].z += sdirZ;


                tan2[i1].x += tdirX;
                tan2[i1].y += tdirY;
                tan2[i1].z += tdirZ;

                tan2[i2].x += tdirX;
                tan2[i2].y += tdirY;
                tan2[i2].z += tdirZ;

                tan2[i3].x += tdirX;
                tan2[i3].y += tdirY;
                tan2[i3].z += tdirZ;
            }


            for (int a = 0; a < vertexCount; ++a)
            {
                Vector3 n = normals[a];
                Vector3 t = tan1[a];
                Vector3.OrthoNormalize(ref n, ref t);
                tangents[a].x = t.x;
                tangents[a].y = t.y;
                tangents[a].z = t.z;

                //inlined version of float dotOfCross = (Vector3.Dot(Vector3.Cross(n, t), tan2[a]) < 0.0f)
                float dotOfCross = ((n.y * t.z - n.z * t.y) * tan2[a].x + (n.z * t.x - n.x * t.z) * tan2[a].y + (n.x * t.y - n.y * t.x) * tan2[a].z);
                tangents[a].w = (dotOfCross < 0.0f) ? -1.0f : 1.0f;
            }

            m.sharedMesh.tangents = tangents;
        }
    }

    public static class TypeExt
    {

        /// <summary>
        /// Gets all types loaded in the current domain.
        /// </summary>
        public static Type[] GetLoadedTypes()
        {
#if UNITY_EDITOR
            return TypeCache.GetTypesDerivedFrom(typeof(System.Object)).ToArray();
#else
            IEnumerable<Assembly> loadedAssemblies = GetLoadedAssemblies();
            List<Type> types = new List<Type>(loadedAssemblies.Count() * 100);//An estimation of 100 type per assembly. This is based on no statistical analysis, just a guess.
            foreach (Assembly assembly in loadedAssemblies)
            {
                try
                {
                    types.AddRange(assembly.GetTypes());
                }
                catch (ReflectionTypeLoadException exception)
                {
                    for (int index = 0; index < exception.Types.Length; index++)
                    {
                        Type type = exception.Types[index];
                        if (type != null)
                            types.Add(type);
                    }
                }
            }
            return types.ToArray();
#endif
        }

        /// <summary>
        /// Gets all types loaded assemblies in the current domain.
        /// </summary>
        static public IEnumerable<Assembly> GetLoadedAssemblies()
        {
            //OPTIM use .Where(a => a.GlobalAssemblyCache == false)?
            return AppDomain.CurrentDomain.GetAssemblies();
        }

        /// <summary>
        /// Gets all Types T that have an attribute U
        /// </summary>
        public static Dictionary<U, Type> GetAllTypesWithAttribute<U>(this Type type)
        {
            Dictionary<U, Type> res = new Dictionary<U, Type>();

            IEnumerable<Type> loadedTypes;
#if UNITY_EDITOR
            loadedTypes = TypeCache.GetTypesDerivedFrom(type);
#else
            loadedTypes = GetLoadedTypes();
#endif

            foreach (Type t in loadedTypes)
            {
#if UNITY_EDITOR == false
                if (t.IsSubclassOf(type))
#endif
                {
                    object[] attribs = t.GetCustomAttributes(typeof(U), false);

                    if (attribs.Length > 0)
                    {
                        res.Add((U)attribs[0], t);
                    }
                }
            }
            return res;
        }

        /// <summary>
        /// Gets all fields of a type that have a certain attribute
        /// </summary>
        public static List<FieldInfo> GetFieldsWithAttribute<T>(this Type type, bool includeInherited = false, bool includePrivate = false) where T : Attribute
        {
            FieldInfo[] flds = type.GetAllFields(includeInherited, includePrivate);
            List<FieldInfo> res = new List<FieldInfo>();
            foreach (FieldInfo fi in flds)
            {
                if (fi.GetCustomAttribute<T>() != null)
                    res.Add(fi);
            }
            return res;
        }

        /// <summary>
        /// Gets a custom attribute from a type (Crossplatform)
        /// </summary>
        public static T GetCustomAttribute<T>(this Type type) where T : Attribute
        {
            object[] at = (object[])type.GetCustomAttributes(typeof(T), true);
            return (at.Length > 0) ? (T)at[0] : null;

        }

        /// <summary>
        /// Finds a Method (Crossplatform)
        /// </summary>
        /// <param name="type">type containing the method</param>
        /// <param name="name">Name of method</param>
        /// <param name="includeInherited">Whether methods of base classes should be returned as well</param>
        /// <param name="includePrivate">Whether private methods should be returned as well</param>
        public static MethodInfo MethodByName(this Type type, string name, bool includeInherited = false, bool includePrivate = false)
        {
            BindingFlags flags = BindingFlags.Public | BindingFlags.Instance;
            if (includePrivate)
                flags = flags | BindingFlags.NonPublic;

            if (includeInherited)
                return type.GetMethodIncludingBaseClasses(name, flags);
            else
                return type.GetMethod(name, flags);
        }
        /// <summary>
        /// Finds a Field (Crossplatform)
        /// </summary>
        /// <param name="type">type containing the field</param>
        /// <param name="name">Name of field</param>
        /// <param name="includeInherited">Whether fields of base classes should be returned as well</param>
        /// <param name="includePrivate">Whether private fields should be returned as well</param>
        public static FieldInfo FieldByName(this Type type, string name, bool includeInherited = false, bool includePrivate = false)
        {
            BindingFlags flags = BindingFlags.Public | BindingFlags.Instance;
            if (includePrivate)
                flags = flags | BindingFlags.NonPublic;

            if (includeInherited)
                return type.GetFieldIncludingBaseClasses(name, flags);
            else
                return type.GetField(name, flags);
        }
        /// <summary>
        /// Finds a Property (Crossplatform)
        /// </summary>
        /// <param name="type">type containing the property</param>
        /// <param name="name">Name of property</param>
        /// <param name="includeInherited">Whether properties of base classes should be returned as well</param>
        /// <param name="includePrivate">Whether private properties should be returned as well</param>
        public static PropertyInfo PropertyByName(this Type type, string name, bool includeInherited = false, bool includePrivate = false)
        {

            BindingFlags flags = BindingFlags.Public | BindingFlags.Instance;
            if (includePrivate)
                flags = flags | BindingFlags.NonPublic;

            if (includeInherited)
                return type.GetPropertyIncludingBaseClasses(name, flags);
            else
                return type.GetProperty(name, flags);
        }
        /// <summary>
        /// Gets all fields (Crossplatform)
        /// </summary>
        /// <param name="type">type to reflect</param>
        /// <param name="includeInherited">Whether fields of base classes should be returned as well</param>
        /// <param name="includePrivate">Whether private fields should be returned as well</param>
        public static FieldInfo[] GetAllFields(this Type type, bool includeInherited = false, bool includePrivate = false)
        {
            BindingFlags flags = BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly;
            if (includePrivate)
                flags = flags | BindingFlags.NonPublic;

            if (includeInherited)
            {
                Type currentType = type;
                List<FieldInfo> res = new List<FieldInfo>();
                while (currentType != typeof(object))
                {
                    res.AddRange(currentType.GetFields(flags));
                    currentType = currentType.BaseType;
                }
                return res.ToArray();
            }
            else
                return type.GetFields(flags);
        }
        /// <summary>
        /// Gets all properties (Crossplatform)
        /// </summary>
        /// <param name="type">type to reflect</param>
        /// <param name="includeInherited">Whether properties of base classes should be returned as well</param>
        /// <param name="includePrivate">Whether private properties should be returned as well</param>
        public static PropertyInfo[] GetAllProperties(this Type type, bool includeInherited = false, bool includePrivate = false)
        {
            BindingFlags flags = BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly;
            if (includePrivate)
                flags = flags | BindingFlags.NonPublic;

            if (includeInherited)
            {
                Type currentType = type;
                List<PropertyInfo> res = new List<PropertyInfo>();
                while (currentType != typeof(object))
                {
                    res.AddRange(currentType.GetProperties(flags));
                    currentType = currentType.BaseType;
                }
                return res.ToArray();
            }
            else
                return type.GetProperties(flags);
        }

        /// <summary>
        /// Whether the type is a framework type, i.e. a primitive, string or DateTime (Crossplatform)
        /// </summary>
        public static bool IsFrameworkType(this Type type)
        {
            return type.IsPrimitive || type.Equals(typeof(string)) || type.Equals(typeof(DateTime));
        }

        public static bool IsArrayOrList(this Type type)
        {
            return (type.IsArray || (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>)));
        }


        public static Type GetEnumerableType(this Type t)
        {
            Type ienum = FindIEnumerable(t);
            if (ienum == null) return t;
            return ienum.GetGenericArguments()[0];
        }

        static Type FindIEnumerable(Type seqType)
        {
            if (seqType == null || seqType == typeof(string))
                return null;
            if (seqType.IsArray)
                return typeof(IEnumerable<>).MakeGenericType(seqType.GetElementType());

            if (seqType.IsGenericType)
            {
                foreach (Type arg in seqType.GetGenericArguments())
                {
                    Type ienum = typeof(IEnumerable<>).MakeGenericType(arg);
                    if (ienum.IsAssignableFrom(seqType))
                    {
                        return ienum;
                    }
                }
            }
            Type[] ifaces = seqType.GetInterfaces();
            if (ifaces != null && ifaces.Length > 0)
            {
                foreach (Type iface in ifaces)
                {
                    Type ienum = FindIEnumerable(iface);
                    if (ienum != null) return ienum;
                }
            }

            if (seqType.BaseType != null && seqType.BaseType != typeof(object))
            {
                return FindIEnumerable(seqType.BaseType);
            }
            return null;
        }

        static MethodInfo GetMethodIncludingBaseClasses(this Type type, string name, BindingFlags bindingFlags)
        {
            // If this class doesn't have a base, don't waste any time
            MethodInfo mi = type.GetMethod(name, bindingFlags);
            if (type.BaseType == typeof(object))
            {
                return mi;
            }
            else
            {   // Otherwise, collect all types up to the furthest base class
                Type currentType = type;
                while (currentType != typeof(object))
                {
                    mi = currentType.GetMethod(name, bindingFlags);
                    if (mi != null)
                        return mi;
                    currentType = currentType.BaseType;
                }
                return null;
            }
        }
        static FieldInfo GetFieldIncludingBaseClasses(this Type type, string name, BindingFlags bindingFlags)
        {
            FieldInfo fieldInfo = type.GetField(name, bindingFlags);

            // If this class doesn't have a base, don't waste any time
            if (type.BaseType == typeof(object))
            {
                return fieldInfo;
            }
            else
            {   // Otherwise, collect all types up to the furthest base class
                Type currentType = type;
                while (currentType != typeof(object))
                {
                    fieldInfo = currentType.GetField(name, bindingFlags);
                    if (fieldInfo != null)
                        return fieldInfo;
                    currentType = currentType.BaseType;
                }
                return null;
            }
        }
        static PropertyInfo GetPropertyIncludingBaseClasses(this Type type, string name, BindingFlags bindingFlags)
        {
            PropertyInfo propertyInfo = type.GetProperty(name, bindingFlags);

            // If this class doesn't have a base, don't waste any time
            if (type.BaseType == typeof(object))
            {
                return propertyInfo;
            }
            else
            {   // Otherwise, collect all types up to the furthest base class
                Type currentType = type;
                while (currentType != typeof(object))
                {
                    propertyInfo = currentType.GetProperty(name, bindingFlags);
                    if (propertyInfo != null)
                        return propertyInfo;
                    currentType = currentType.BaseType;
                }
                return null;
            }
        }

        public static bool Matches(this Type type, params Type[] types)
        {
            foreach (Type t in types)
                if (type == t || type.IsAssignableFrom(t))
                    return true;

            return false;
        }




    }

    public static class FieldInfoExt
    {
        /// <summary>
        /// Gets a custom attribute (CrossPlatform)
        /// </summary>
        public static T GetCustomAttribute<T>(this FieldInfo field) where T : Attribute
        {
            object[] at = field.GetCustomAttributes(typeof(T), true);
            return (at.Length > 0) ? (T)at[0] : null;

        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/DevTools/Extensions/Extensions.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Dict.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3102f422c6eae044d9449fcda12bf2a8
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    internal class Dict<TValue> where TValue : class
    {
        public class Node
        {
            internal TValue _key;
            internal Node _prev, _next;

            public TValue Key { get { return _key; } }
            public Node Prev { get { return _prev; } }
            public Node Next { get { return _next; } }
        }

        public delegate bool LessOrEqual(TValue lhs, TValue rhs);

        private LessOrEqual _leq;
        Node _head;

        public Dict(LessOrEqual leq)
        {
            _leq = leq;

            _head = new Node { _key = null };
            _head._prev = _head;
            _head._next = _head;
        }

        public Node Insert(TValue key)
        {
            return InsertBefore(_head, key);
        }

        public Node InsertBefore(Node node, TValue key)
        {
            do {
                node = node._prev;
            } while (node._key != null && !_leq(node._key, key));

            var newNode = new Node { _key = key };
            newNode._next = node._next;
            node._next._prev = newNode;
            newNode._prev = node;
            node._next = newNode;

            return newNode;
        }

        public Node Find(TValue key)
        {
            var node = _head;
            do {
                node = node._next;
            } while (node._key != null && !_leq(key, node._key));
            return node;
        }

        public Node Min()
        {
            return _head._next;
        }

        public void Remove(Node node)
        {
            node._next._prev = node._prev;
            node._prev._next = node._next;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Dict.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Geom.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0414da14dce5a6c4382f13dd89869f01
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

using System;
using System.Diagnostics;

using Real = System.Single;
namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    internal static class Geom
    {
        public static bool IsWindingInside(WindingRule rule, int n)
        {
            switch (rule)
            {
                case WindingRule.EvenOdd:
                    return (n & 1) == 1;
                case WindingRule.NonZero:
                    return n != 0;
                case WindingRule.Positive:
                    return n > 0;
                case WindingRule.Negative:
                    return n < 0;
                case WindingRule.AbsGeqTwo:
                    return n >= 2 || n <= -2;
            }
            throw new Exception("Wrong winding rule");
        }

        public static bool VertCCW(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
        {
            return (u._s * (v._t - w._t) + v._s * (w._t - u._t) + w._s * (u._t - v._t)) >= 0.0f;
        }
        public static bool VertEq(MeshUtils.Vertex lhs, MeshUtils.Vertex rhs)
        {
            return lhs._s == rhs._s && lhs._t == rhs._t;
        }
        public static bool VertLeq(MeshUtils.Vertex lhs, MeshUtils.Vertex rhs)
        {
            return (lhs._s < rhs._s) || (lhs._s == rhs._s && lhs._t <= rhs._t);
        }

        /// <summary>
        /// Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),
        /// evaluates the t-coord of the edge uw at the s-coord of the vertex v.
        /// Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.
        /// If uw is vertical (and thus passes thru v), the result is zero.
        /// 
        /// The calculation is extremely accurate and stable, even when v
        /// is very close to u or w.  In particular if we set v->t = 0 and
        /// let r be the negated result (this evaluates (uw)(v->s)), then
        /// r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).
        /// </summary>
        public static Real EdgeEval(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
        {
            Debug.Assert(VertLeq(u, v) && VertLeq(v, w));

            var gapL = v._s - u._s;
            var gapR = w._s - v._s;

            if (gapL + gapR > 0.0f)
            {
                if (gapL < gapR)
                {
                    return (v._t - u._t) + (u._t - w._t) * (gapL / (gapL + gapR));
                }
                else
                {
                    return (v._t - w._t) + (w._t - u._t) * (gapR / (gapL + gapR));
                }
            }
            /* vertical line */
            return 0;
        }

        /// <summary>
        /// Returns a number whose sign matches EdgeEval(u,v,w) but which
        /// is cheaper to evaluate. Returns > 0, == 0 , or < 0
        /// as v is above, on, or below the edge uw.
        /// </summary>
        public static Real EdgeSign(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
        {
            Debug.Assert(VertLeq(u, v) && VertLeq(v, w));

            var gapL = v._s - u._s;
            var gapR = w._s - v._s;

            if (gapL + gapR > 0.0f)
            {
                return (v._t - w._t) * gapL + (v._t - u._t) * gapR;
            }
            /* vertical line */
            return 0;
        }

        public static bool TransLeq(MeshUtils.Vertex lhs, MeshUtils.Vertex rhs)
        {
            return (lhs._t < rhs._t) || (lhs._t == rhs._t && lhs._s <= rhs._s);
        }

        public static Real TransEval(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
        {
            Debug.Assert(TransLeq(u, v) && TransLeq(v, w));

            var gapL = v._t - u._t;
            var gapR = w._t - v._t;

            if (gapL + gapR > 0.0f)
            {
                if (gapL < gapR)
                {
                    return (v._s - u._s) + (u._s - w._s) * (gapL / (gapL + gapR));
                }
                else
                {
                    return (v._s - w._s) + (w._s - u._s) * (gapR / (gapL + gapR));
                }
            }
            /* vertical line */
            return 0;
        }

        public static Real TransSign(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
        {
            Debug.Assert(TransLeq(u, v) && TransLeq(v, w));

            var gapL = v._t - u._t;
            var gapR = w._t - v._t;

            if (gapL + gapR > 0.0f)
            {
                return (v._s - w._s) * gapL + (v._s - u._s) * gapR;
            }
            /* vertical line */
            return 0;
        }

        public static bool EdgeGoesLeft(MeshUtils.Edge e)
        {
            return VertLeq(e._Dst, e._Org);
        }

        public static bool EdgeGoesRight(MeshUtils.Edge e)
        {
            return VertLeq(e._Org, e._Dst);
        }

        public static Real VertL1dist(MeshUtils.Vertex u, MeshUtils.Vertex v)
        {
            return Math.Abs(u._s - v._s) + Math.Abs(u._t - v._t);
        }

        public static void AddWinding(MeshUtils.Edge eDst, MeshUtils.Edge eSrc)
        {
            eDst._winding += eSrc._winding;
            eDst._Sym._winding += eSrc._Sym._winding;
        }

        public static Real Interpolate(Real a, Real x, Real b, Real y)
        {
            if (a < 0.0f)
            {
                a = 0.0f;
            }
            if (b < 0.0f)
            {
                b = 0.0f;
            }
            return ((a <= b) ? ((b == 0.0f) ? ((x+y) / 2.0f)
                    : (x + (y-x) * (a/(a+b))))
                    : (y + (x-y) * (b/(a+b))));
        }

        static void Swap(ref MeshUtils.Vertex a, ref MeshUtils.Vertex b)
        {
            (b, a) = (a, b);
        }

        /// <summary>
        /// Given edges (o1,d1) and (o2,d2), compute their point of intersection.
        /// The computed point is guaranteed to lie in the intersection of the
        /// bounding rectangles defined by each edge.
        /// </summary>
        public static void EdgeIntersect(MeshUtils.Vertex o1, MeshUtils.Vertex d1, MeshUtils.Vertex o2, MeshUtils.Vertex d2, MeshUtils.Vertex v)
        {
            // This is certainly not the most efficient way to find the intersection
            // of two line segments, but it is very numerically stable.
            // 
            // Strategy: find the two middle vertices in the VertLeq ordering,
            // and interpolate the intersection s-value from these.  Then repeat
            // using the TransLeq ordering to find the intersection t-value.

            if (!VertLeq(o1, d1)) { Swap(ref o1, ref d1); }
            if (!VertLeq(o2, d2)) { Swap(ref o2, ref d2); }
            if (!VertLeq(o1, o2)) { Swap(ref o1, ref o2); Swap(ref d1, ref d2); }

            if (!VertLeq(o2, d1))
            {
                // Technically, no intersection -- do our best
                v._s = (o2._s + d1._s) / 2.0f;
            }
            else if (VertLeq(d1, d2))
            {
                // Interpolate between o2 and d1
                var z1 = EdgeEval(o1, o2, d1);
                var z2 = EdgeEval(o2, d1, d2);
                if (z1 + z2 < 0.0f)
                {
                    z1 = -z1;
                    z2 = -z2;
                }
                v._s = Interpolate(z1, o2._s, z2, d1._s);
            }
            else
            {
                // Interpolate between o2 and d2
                var z1 = EdgeSign(o1, o2, d1);
                var z2 = -EdgeSign(o1, d2, d1);
                if (z1 + z2 < 0.0f)
                {
                    z1 = -z1;
                    z2 = -z2;
                }
                v._s = Interpolate(z1, o2._s, z2, d2._s);
            }

            // Now repeat the process for t

            if (!TransLeq(o1, d1)) { Swap(ref o1, ref d1); }
            if (!TransLeq(o2, d2)) { Swap(ref o2, ref d2); }
            if (!TransLeq(o1, o2)) { Swap(ref o1, ref o2); Swap(ref d1, ref d2); }

            if (!TransLeq(o2, d1))
            {
                // Technically, no intersection -- do our best
                v._t = (o2._t + d1._t) / 2.0f;
            }
            else if (TransLeq(d1, d2))
            {
                // Interpolate between o2 and d1
                var z1 = TransEval(o1, o2, d1);
                var z2 = TransEval(o2, d1, d2);
                if (z1 + z2 < 0.0f)
                {
                    z1 = -z1;
                    z2 = -z2;
                }
                v._t = Interpolate(z1, o2._t, z2, d1._t);
            }
            else
            {
                // Interpolate between o2 and d2
                var z1 = TransSign(o1, o2, d1);
                var z2 = -TransSign(o1, d2, d1);
                if (z1 + z2 < 0.0f)
                {
                    z1 = -z1;
                    z2 = -z2;
                }
                v._t = Interpolate(z1, o2._t, z2, d2._t);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Geom.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/LTMesh.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 71c6f8ed26841f945bf72bd9a722a62c
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

using System;
using System.Diagnostics;

namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    internal class LTMesh : MeshUtils.Pooled<LTMesh>
    {
        internal MeshUtils.Vertex _vHead;
        internal MeshUtils.Face _fHead;
        internal MeshUtils.Edge _eHead, _eHeadSym;

        public LTMesh()
        {
            var v = _vHead = MeshUtils.Vertex.Create();
            var f = _fHead = MeshUtils.Face.Create();

            var pair = MeshUtils.EdgePair.Create();
            var e = _eHead = pair._e;
            var eSym = _eHeadSym = pair._eSym;

            v._next = v._prev = v;
            v._anEdge = null;

            f._next = f._prev = f;
            f._anEdge = null;
            f._trail = null;
            f._marked = false;
            f._inside = false;

            e._next = e;
            e._Sym = eSym;
            e._Onext = null;
            e._Lnext = null;
            e._Org = null;
            e._Lface = null;
            e._winding = 0;
            e._activeRegion = null;

            eSym._next = eSym;
            eSym._Sym = e;
            eSym._Onext = null;
            eSym._Lnext = null;
            eSym._Org = null;
            eSym._Lface = null;
            eSym._winding = 0;
            eSym._activeRegion = null;
        }

        public override void Reset()
        {
            _vHead = null;
            _fHead = null;
            _eHead = _eHeadSym = null;
        }

        public override void OnFree()
        {
            for (MeshUtils.Face f = _fHead._next, fNext = _fHead; f != _fHead; f = fNext)
            {
                fNext = f._next;
                f.Free();
            }
            for (MeshUtils.Vertex v = _vHead._next, vNext = _vHead; v != _vHead; v = vNext)
            {
                vNext = v._next;
                v.Free();
            }
            for (MeshUtils.Edge e = _eHead._next, eNext = _eHead; e != _eHead; e = eNext)
            {
                eNext = e._next;
                e.Free();
            }
        }

        /// <summary>
        /// Creates one edge, two vertices and a loop (face).
        /// The loop consists of the two new half-edges.
        /// </summary>
        public MeshUtils.Edge MakeEdge()
        {
            var e = MeshUtils.MakeEdge(_eHead);

            MeshUtils.MakeVertex(e, _vHead);
            MeshUtils.MakeVertex(e._Sym, _vHead);
            MeshUtils.MakeFace(e, _fHead);

            return e;
        }

        /// <summary>
        /// Splice is the basic operation for changing the
        /// mesh connectivity and topology.  It changes the mesh so that
        ///     eOrg->Onext = OLD( eDst->Onext )
        ///     eDst->Onext = OLD( eOrg->Onext )
        /// where OLD(...) means the value before the meshSplice operation.
        /// 
        /// This can have two effects on the vertex structure:
        ///  - if eOrg->Org != eDst->Org, the two vertices are merged together
        ///  - if eOrg->Org == eDst->Org, the origin is split into two vertices
        /// In both cases, eDst->Org is changed and eOrg->Org is untouched.
        /// 
        /// Similarly (and independently) for the face structure,
        ///  - if eOrg->Lface == eDst->Lface, one loop is split into two
        ///  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
        /// In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
        /// 
        /// Some special cases:
        /// If eDst == eOrg, the operation has no effect.
        /// If eDst == eOrg->Lnext, the new face will have a single edge.
        /// If eDst == eOrg->Lprev, the old face will have a single edge.
        /// If eDst == eOrg->Onext, the new vertex will have a single edge.
        /// If eDst == eOrg->Oprev, the old vertex will have a single edge.
        /// </summary>
        public void Splice(MeshUtils.Edge eOrg, MeshUtils.Edge eDst)
        {
            if (eOrg == eDst)
            {
                return;
            }

            bool joiningVertices = false;
            if (eDst._Org != eOrg._Org)
            {
                // We are merging two disjoint vertices -- destroy eDst->Org
                joiningVertices = true;
                MeshUtils.KillVertex(eDst._Org, eOrg._Org);
            }
            bool joiningLoops = false;
            if (eDst._Lface != eOrg._Lface)
            {
                // We are connecting two disjoint loops -- destroy eDst->Lface
                joiningLoops = true;
                MeshUtils.KillFace(eDst._Lface, eOrg._Lface);
            }

            // Change the edge structure
            MeshUtils.Splice(eDst, eOrg);

            if (!joiningVertices)
            {
                // We split one vertex into two -- the new vertex is eDst->Org.
                // Make sure the old vertex points to a valid half-edge.
                MeshUtils.MakeVertex(eDst, eOrg._Org);
                eOrg._Org._anEdge = eOrg;
            }
            if (!joiningLoops)
            {
                // We split one loop into two -- the new loop is eDst->Lface.
                // Make sure the old face points to a valid half-edge.
                MeshUtils.MakeFace(eDst, eOrg._Lface);
                eOrg._Lface._anEdge = eOrg;
            }
        }

        /// <summary>
        /// Removes the edge eDel. There are several cases:
        /// if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
        /// eDel->Lface is deleted. Otherwise, we are splitting one loop into two;
        /// the newly created loop will contain eDel->Dst. If the deletion of eDel
        /// would create isolated vertices, those are deleted as well.
        /// </summary>
        public void Delete(MeshUtils.Edge eDel)
        {
            var eDelSym = eDel._Sym;

            // First step: disconnect the origin vertex eDel->Org.  We make all
            // changes to get a consistent mesh in this "intermediate" state.

            bool joiningLoops = false;
            if (eDel._Lface != eDel._Rface)
            {
                // We are joining two loops into one -- remove the left face
                joiningLoops = true;
                MeshUtils.KillFace(eDel._Lface, eDel._Rface);
            }

            if (eDel._Onext == eDel)
            {
                MeshUtils.KillVertex(eDel._Org, null);
            }
            else
            {
                // Make sure that eDel->Org and eDel->Rface point to valid half-edges
                eDel._Rface._anEdge = eDel._Oprev;
                eDel._Org._anEdge = eDel._Onext;

                MeshUtils.Splice(eDel, eDel._Oprev);

                if (!joiningLoops)
                {
                    // We are splitting one loop into two -- create a new loop for eDel.
                    MeshUtils.MakeFace(eDel, eDel._Lface);
                }
            }

            // Claim: the mesh is now in a consistent state, except that eDel->Org
            // may have been deleted.  Now we disconnect eDel->Dst.

            if (eDelSym._Onext == eDelSym)
            {
                MeshUtils.KillVertex(eDelSym._Org, null);
                MeshUtils.KillFace(eDelSym._Lface, null);
            }
            else
            {
                // Make sure that eDel->Dst and eDel->Lface point to valid half-edges
                eDel._Lface._anEdge = eDelSym._Oprev;
                eDelSym._Org._anEdge = eDelSym._Onext;
                MeshUtils.Splice(eDelSym, eDelSym._Oprev);
            }

            // Any isolated vertices or faces have already been freed.
            MeshUtils.KillEdge(eDel);
        }

        /// <summary>
        /// Creates a new edge such that eNew == eOrg.Lnext and eNew.Dst is a newly created vertex.
        /// eOrg and eNew will have the same left face.
        /// </summary>
        public MeshUtils.Edge AddEdgeVertex(MeshUtils.Edge eOrg)
        {
            var eNew = MeshUtils.MakeEdge(eOrg);
            var eNewSym = eNew._Sym;

            // Connect the new edge appropriately
            MeshUtils.Splice(eNew, eOrg._Lnext);

            // Set vertex and face information
            eNew._Org = eOrg._Dst;
            MeshUtils.MakeVertex(eNewSym, eNew._Org);
            eNew._Lface = eNewSym._Lface = eOrg._Lface;

            return eNew;
        }

        /// <summary>
        /// Splits eOrg into two edges eOrg and eNew such that eNew == eOrg.Lnext.
        /// The new vertex is eOrg.Dst == eNew.Org.
        /// eOrg and eNew will have the same left face.
        /// </summary>
        public MeshUtils.Edge SplitEdge(MeshUtils.Edge eOrg)
        {
            var eTmp = AddEdgeVertex(eOrg);
            var eNew = eTmp._Sym;

            // Disconnect eOrg from eOrg->Dst and connect it to eNew->Org
            MeshUtils.Splice(eOrg._Sym, eOrg._Sym._Oprev);
            MeshUtils.Splice(eOrg._Sym, eNew);

            // Set the vertex and face information
            eOrg._Dst = eNew._Org;
            eNew._Dst._anEdge = eNew._Sym; // may have pointed to eOrg->Sym
            eNew._Rface = eOrg._Rface;
            eNew._winding = eOrg._winding; // copy old winding information
            eNew._Sym._winding = eOrg._Sym._winding;

            return eNew;
        }

        /// <summary>
        /// Creates a new edge from eOrg->Dst to eDst->Org, and returns the corresponding half-edge eNew.
        /// If eOrg->Lface == eDst->Lface, this splits one loop into two,
        /// and the newly created loop is eNew->Lface.  Otherwise, two disjoint
        /// loops are merged into one, and the loop eDst->Lface is destroyed.
        /// 
        /// If (eOrg == eDst), the new face will have only two edges.
        /// If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
        /// If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
        /// </summary>
        public MeshUtils.Edge Connect(MeshUtils.Edge eOrg, MeshUtils.Edge eDst)
        {
            var eNew = MeshUtils.MakeEdge(eOrg);
            var eNewSym = eNew._Sym;

            bool joiningLoops = false;
            if (eDst._Lface != eOrg._Lface)
            {
                // We are connecting two disjoint loops -- destroy eDst->Lface
                joiningLoops = true;
                MeshUtils.KillFace(eDst._Lface, eOrg._Lface);
            }

            // Connect the new edge appropriately
            MeshUtils.Splice(eNew, eOrg._Lnext);
            MeshUtils.Splice(eNewSym, eDst);

            // Set the vertex and face information
            eNew._Org = eOrg._Dst;
            eNewSym._Org = eDst._Org;
            eNew._Lface = eNewSym._Lface = eOrg._Lface;

            // Make sure the old face points to a valid half-edge
            eOrg._Lface._anEdge = eNewSym;

            if (!joiningLoops)
            {
                MeshUtils.MakeFace(eNew, eOrg._Lface);
            }

            return eNew;
        }

        /// <summary>
        /// Destroys a face and removes it from the global face list. All edges of
        /// fZap will have a NULL pointer as their left face. Any edges which
        /// also have a NULL pointer as their right face are deleted entirely
        /// (along with any isolated vertices this produces).
        /// An entire mesh can be deleted by zapping its faces, one at a time,
        /// in any order. Zapped faces cannot be used in further mesh operations!
        /// </summary>
        public void ZapFace(MeshUtils.Face fZap)
        {
            var eStart = fZap._anEdge;

            // walk around face, deleting edges whose right face is also NULL
            var eNext = eStart._Lnext;
            MeshUtils.Edge e, eSym;
            do {
                e = eNext;
                eNext = e._Lnext;

                e._Lface = null;
                if (e._Rface == null)
                {
                    // delete the edge -- see TESSmeshDelete above

                    if (e._Onext == e)
                    {
                        MeshUtils.KillVertex(e._Org, null);
                    }
                    else
                    {
                        // Make sure that e._Org points to a valid half-edge
                        e._Org._anEdge = e._Onext;
                        MeshUtils.Splice(e, e._Oprev);
                    }
                    eSym = e._Sym;
                    if (eSym._Onext == eSym)
                    {
                        MeshUtils.KillVertex(eSym._Org, null);
                    }
                    else
                    {
                        // Make sure that eSym._Org points to a valid half-edge
                        eSym._Org._anEdge = eSym._Onext;
                        MeshUtils.Splice(eSym, eSym._Oprev);
                    }
                    MeshUtils.KillEdge(e);
                }
            } while (e != eStart);

            /* delete from circular doubly-linked list */
            var fPrev = fZap._prev;
            var fNext = fZap._next;
            fNext._prev = fPrev;
            fPrev._next = fNext;

            fZap.Free();
        }

        public void MergeConvexFaces(int maxVertsPerFace)
        {
            for (var f = _fHead._next; f != _fHead; f = f._next)
            {
                // Skip faces which are outside the result
                if (!f._inside)
                {
                    continue;
                }

                var eCur = f._anEdge;
                var vStart = eCur._Org;

                while (true)
                {
                    var eNext = eCur._Lnext;
                    var eSym = eCur._Sym;

                    if (eSym != null && eSym._Lface != null && eSym._Lface._inside)
                    {
                        // Try to merge the neighbour faces if the resulting polygons
                        // does not exceed maximum number of vertices.
                        int curNv = f.VertsCount;
                        int symNv = eSym._Lface.VertsCount;
                        if ((curNv + symNv - 2) <= maxVertsPerFace)
                        {
                            // Merge if the resulting poly is convex.
                            if (Geom.VertCCW(eCur._Lprev._Org, eCur._Org, eSym._Lnext._Lnext._Org) &&
                                Geom.VertCCW(eSym._Lprev._Org, eSym._Org, eCur._Lnext._Lnext._Org))
                            {
                                eNext = eSym._Lnext;
                                Delete(eSym);
                                eCur = null;
                            }
                        }
                    }

                    if (eCur != null && eCur._Lnext._Org == vStart)
                        break;

                    // Continue to next edge.
                    eCur = eNext;
                }
            }
        }

        [Conditional("DEBUG")]
        public void Check()
        {
            MeshUtils.Edge e;

            MeshUtils.Face fPrev = _fHead, f;
            for (fPrev = _fHead; (f = fPrev._next) != _fHead; fPrev = f)
            {
                e = f._anEdge;
                do {
                    Debug.Assert(e._Sym != e);
                    Debug.Assert(e._Sym._Sym == e);
                    Debug.Assert(e._Lnext._Onext._Sym == e);
                    Debug.Assert(e._Onext._Sym._Lnext == e);
                    Debug.Assert(e._Lface == f);
                    e = e._Lnext;
                } while (e != f._anEdge);
            }
            Debug.Assert(f._prev == fPrev && f._anEdge == null);

            MeshUtils.Vertex vPrev = _vHead, v;
            for (vPrev = _vHead; (v = vPrev._next) != _vHead; vPrev = v)
            {
                Debug.Assert(v._prev == vPrev);
                e = v._anEdge;
                do
                {
                    Debug.Assert(e._Sym != e);
                    Debug.Assert(e._Sym._Sym == e);
                    Debug.Assert(e._Lnext._Onext._Sym == e);
                    Debug.Assert(e._Onext._Sym._Lnext == e);
                    Debug.Assert(e._Org == v);
                    e = e._Onext;
                } while (e != v._anEdge);
            }
            Debug.Assert(v._prev == vPrev && v._anEdge == null);

            MeshUtils.Edge ePrev = _eHead;
            for (ePrev = _eHead; (e = ePrev._next) != _eHead; ePrev = e)
            {
                Debug.Assert(e._Sym._next == ePrev._Sym);
                Debug.Assert(e._Sym != e);
                Debug.Assert(e._Sym._Sym == e);
                Debug.Assert(e._Org != null);
                Debug.Assert(e._Dst != null);
                Debug.Assert(e._Lnext._Onext._Sym == e);
                Debug.Assert(e._Onext._Sym._Lnext == e);
            }
            Debug.Assert(e._Sym._next == ePrev._Sym
                && e._Sym == _eHeadSym
                && e._Sym._Sym == e
                && e._Org == null && e._Dst == null
                && e._Lface == null && e._Rface == null);
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/LTMesh.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/MeshUtils.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1906f51f269f2e8408b7aa54e1c8f10e
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

using System;
using System.Collections.Generic;
using System.Diagnostics;
#if ENABLE_IL2CPP == false
using System.Linq.Expressions;
#endif
using Real = System.Single;
namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    public struct Vec3
    {
        public readonly static Vec3 Zero = new Vec3();

        public Real X, Y, Z;

        public Real this[int index]
        {
            get
            {
                if (index == 0) return X;
                if (index == 1) return Y;
                if (index == 2) return Z;
                throw new IndexOutOfRangeException();
            }
            set
            {
                if (index == 0) X = value;
                else if (index == 1) Y = value;
                else if (index == 2) Z = value;
                else throw new IndexOutOfRangeException();
            }
        }

        public static void Sub(ref Vec3 lhs, ref Vec3 rhs, out Vec3 result)
        {
            result.X = lhs.X - rhs.X;
            result.Y = lhs.Y - rhs.Y;
            result.Z = lhs.Z - rhs.Z;
        }

        public static void Neg(ref Vec3 v)
        {
            v.X = -v.X;
            v.Y = -v.Y;
            v.Z = -v.Z;
        }

        public static void Dot(ref Vec3 u, ref Vec3 v, out Real dot)
        {
            dot = u.X * v.X + u.Y * v.Y + u.Z * v.Z;
        }

        public static void Normalize(ref Vec3 v)
        {
            var len = v.X * v.X + v.Y * v.Y + v.Z * v.Z;
            Debug.Assert(len >= 0.0f);
            len = 1.0f / (Real)Math.Sqrt(len);
            v.X *= len;
            v.Y *= len;
            v.Z *= len;
        }

        public static int LongAxis(ref Vec3 v)
        {
            int i = 0;
            if (Math.Abs(v.Y) > Math.Abs(v.X)) i = 1;
            if (Math.Abs(v.Z) > Math.Abs(i == 0 ? v.X : v.Y)) i = 2;
            return i;
        }

        public override string ToString()
        {
            return string.Format("{0}, {1}, {2}", X, Y, Z);
        }
    }

    internal static class MeshUtils
    {
        public const int Undef = ~0;

        public abstract class Pooled<T> where T : Pooled<T>, new()
        {
            private static Stack<T> _stack;

            public abstract void Reset();
            public virtual void OnFree() {}

#if ENABLE_IL2CPP == false
            private static readonly Func<T> OptimizedInstantiator = Expression.Lambda<Func<T>>(
                Expression.New(typeof(T))
            ).Compile();
#endif

            public static T Create()
            {
                if (_stack != null && _stack.Count > 0)
                {
                    return _stack.Pop();
                }
                return
#if ENABLE_IL2CPP == false
                    OptimizedInstantiator.Invoke()
#else
                    new T()
#endif
                    ;
            }

            public void Free()
            {
                OnFree();
                Reset();
                if (_stack == null)
                {
                    _stack = new Stack<T>();
                }
                _stack.Push((T)this);
            }
        }

        public class Vertex : Pooled<Vertex>
        {
            internal Vertex _prev, _next;
            internal Edge _anEdge;

            internal Vec3 _coords;
            internal Real _s, _t;
            internal PQHandle _pqHandle;
            internal int _n;
            internal object _data;

            public override void Reset()
            {
                _prev = _next = null;
                _anEdge = null;
                _coords = Vec3.Zero;
                _s = 0;
                _t = 0;
                _pqHandle = new PQHandle();
                _n = 0;
                _data = null;
            }
        }

        public class Face : Pooled<Face>
        {
            internal Face _prev, _next;
            internal Edge _anEdge;

            internal Face _trail;
            internal int _n;
            internal bool _marked, _inside;

            internal int VertsCount
            {
                get
                {
                    int n = 0;
                    var eCur = _anEdge;
                    do {
                        n++;
                        eCur = eCur._Lnext;
                    } while (eCur != _anEdge);
                    return n;
                }
            }

            public override void Reset()
            {
                _prev = _next = null;
                _anEdge = null;
                _trail = null;
                _n = 0;
                _marked = false;
                _inside = false;
            }
        }

        public struct EdgePair
        {
            internal Edge _e, _eSym;

            public static EdgePair Create()
            {
                var pair = new MeshUtils.EdgePair();
                pair._e = MeshUtils.Edge.Create();
                pair._e._pair = pair;
                pair._eSym = MeshUtils.Edge.Create();
                pair._eSym._pair = pair;
                return pair;
            }

            public void Reset()
            {
                _e = _eSym = null;
            }
        }

        public class Edge : Pooled<Edge>
        {
            internal EdgePair _pair;
            internal Edge _next, _Sym, _Onext, _Lnext;
            internal Vertex _Org;
            internal Face _Lface;
            internal Tess.ActiveRegion _activeRegion;
            internal int _winding;

            internal Face _Rface { get { return _Sym._Lface; } set { _Sym._Lface = value; } }
            internal Vertex _Dst { get { return _Sym._Org; }  set { _Sym._Org = value; } }

            internal Edge _Oprev { get { return _Sym._Lnext; } set { _Sym._Lnext = value; } }
            internal Edge _Lprev { get { return _Onext._Sym; } set { _Onext._Sym = value; } }
            internal Edge _Dprev { get { return _Lnext._Sym; } set { _Lnext._Sym = value; } }
            internal Edge _Rprev { get { return _Sym._Onext; } set { _Sym._Onext = value; } }
            internal Edge _Dnext { get { return _Rprev._Sym; } set { _Rprev._Sym = value; } }
            internal Edge _Rnext { get { return _Oprev._Sym; } set { _Oprev._Sym = value; } }

            internal static void EnsureFirst(ref Edge e)
            {
                if (e == e._pair._eSym)
                {
                    e = e._Sym;
                }
            }

            public override void Reset()
            {
                _pair.Reset();
                _next = _Sym = _Onext = _Lnext = null;
                _Org = null;
                _Lface = null;
                _activeRegion = null;
                _winding = 0;
            }
        }

        /// <summary>
        /// MakeEdge creates a new pair of half-edges which form their own loop.
        /// No vertex or face structures are allocated, but these must be assigned
        /// before the current edge operation is completed.
        /// </summary>
        public static Edge MakeEdge(Edge eNext)
        {
            Debug.Assert(eNext != null);

            var pair = EdgePair.Create();
            var e = pair._e;
            var eSym = pair._eSym;

            // Make sure eNext points to the first edge of the edge pair
            Edge.EnsureFirst(ref eNext);

            // Insert in circular doubly-linked list before eNext.
            // Note that the prev pointer is stored in Sym->next.
            var ePrev = eNext._Sym._next;
            eSym._next = ePrev;
            ePrev._Sym._next = e;
            e._next = eNext;
            eNext._Sym._next = eSym;

            e._Sym = eSym;
            e._Onext = e;
            e._Lnext = eSym;
            e._Org = null;
            e._Lface = null;
            e._winding = 0;
            e._activeRegion = null;

            eSym._Sym = e;
            eSym._Onext = eSym;
            eSym._Lnext = e;
            eSym._Org = null;
            eSym._Lface = null;
            eSym._winding = 0;
            eSym._activeRegion = null;

            return e;
        }

        /// <summary>
        /// Splice( a, b ) is best described by the Guibas/Stolfi paper or the
        /// CS348a notes (see Mesh.cs). Basically it modifies the mesh so that
        /// a->Onext and b->Onext are exchanged. This can have various effects
        /// depending on whether a and b belong to different face or vertex rings.
        /// For more explanation see Mesh.Splice().
        /// </summary>
        public static void Splice(Edge a, Edge b)
        {
            var aOnext = a._Onext;
            var bOnext = b._Onext;

            aOnext._Sym._Lnext = b;
            bOnext._Sym._Lnext = a;
            a._Onext = bOnext;
            b._Onext = aOnext;
        }

        /// <summary>
        /// MakeVertex( eOrig, vNext ) attaches a new vertex and makes it the
        /// origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
        /// a place to insert the new vertex in the global vertex list. We insert
        /// the new vertex *before* vNext so that algorithms which walk the vertex
        /// list will not see the newly created vertices.
        /// </summary>
        public static void MakeVertex(Edge eOrig, Vertex vNext)
        {
            var vNew = MeshUtils.Vertex.Create();

            // insert in circular doubly-linked list before vNext
            var vPrev = vNext._prev;
            vNew._prev = vPrev;
            vPrev._next = vNew;
            vNew._next = vNext;
            vNext._prev = vNew;

            vNew._anEdge = eOrig;
            // leave coords, s, t undefined

            // fix other edges on this vertex loop
            var e = eOrig;
            do {
                e._Org = vNew;
                e = e._Onext;
            } while (e != eOrig);
        }

        /// <summary>
        /// MakeFace( eOrig, fNext ) attaches a new face and makes it the left
        /// face of all edges in the face loop to which eOrig belongs. "fNext" gives
        /// a place to insert the new face in the global face list. We insert
        /// the new face *before* fNext so that algorithms which walk the face
        /// list will not see the newly created faces.
        /// </summary>
        public static void MakeFace(Edge eOrig, Face fNext)
        {
            var fNew = MeshUtils.Face.Create();

            // insert in circular doubly-linked list before fNext
            var fPrev = fNext._prev;
            fNew._prev = fPrev;
            fPrev._next = fNew;
            fNew._next = fNext;
            fNext._prev = fNew;

            fNew._anEdge = eOrig;
            fNew._trail = null;
            fNew._marked = false;

            // The new face is marked "inside" if the old one was. This is a
            // convenience for the common case where a face has been split in two.
            fNew._inside = fNext._inside;

            // fix other edges on this face loop
            var e = eOrig;
            do {
                e._Lface = fNew;
                e = e._Lnext;
            } while (e != eOrig);
        }

        /// <summary>
        /// KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
        /// and removes from the global edge list.
        /// </summary>
        public static void KillEdge(Edge eDel)
        {
            // Half-edges are allocated in pairs, see EdgePair above
            Edge.EnsureFirst(ref eDel);

            // delete from circular doubly-linked list
            var eNext = eDel._next;
            var ePrev = eDel._Sym._next;
            eNext._Sym._next = ePrev;
            ePrev._Sym._next = eNext;

            eDel.Free();
        }

        /// <summary>
        /// KillVertex( vDel ) destroys a vertex and removes it from the global
        /// vertex list. It updates the vertex loop to point to a given new vertex.
        /// </summary>
        public static void KillVertex(Vertex vDel, Vertex newOrg)
        {
            var eStart = vDel._anEdge;

            // change the origin of all affected edges
            var e = eStart;
            do {
                e._Org = newOrg;
                e = e._Onext;
            } while (e != eStart);

            // delete from circular doubly-linked list
            var vPrev = vDel._prev;
            var vNext = vDel._next;
            vNext._prev = vPrev;
            vPrev._next = vNext;

            vDel.Free();
        }

        /// <summary>
        /// KillFace( fDel ) destroys a face and removes it from the global face
        /// list. It updates the face loop to point to a given new face.
        /// </summary>
        public static void KillFace(Face fDel, Face newLFace)
        {
            var eStart = fDel._anEdge;

            // change the left face of all affected edges
            var e = eStart;
            do {
                e._Lface = newLFace;
                e = e._Lnext;
            } while (e != eStart);

            // delete from circular doubly-linked list
            var fPrev = fDel._prev;
            var fNext = fDel._next;
            fNext._prev = fPrev;
            fPrev._next = fNext;

            fDel.Free();
        }

        /// <summary>
        /// Return signed area of face.
        /// </summary>
        public static Real FaceArea(Face f)
        {
            Real area = 0;
            var e = f._anEdge;
            do
            {
                area += (e._Org._s - e._Dst._s) * (e._Org._t + e._Dst._t);
                e = e._Lnext;
            } while (e != f._anEdge);
            return area;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/MeshUtils.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/PriorityHeap.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e673e736d2b91564b83bbdcb63f296b7
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

using System;
using System.Diagnostics;

namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    internal struct PQHandle
    {
        public static readonly int Invalid = 0x0fffffff;
        internal int _handle;
    }

    internal class PriorityHeap<TValue> where TValue : class
    {
        public delegate bool LessOrEqual(TValue lhs, TValue rhs);

        protected class HandleElem
        {
            internal TValue _key;
            internal int _node;
        }

        private readonly LessOrEqual _leq;
        private int[] _nodes;
        private HandleElem[] _handles;
        private int _size, _max;
        private int _freeList;
        private bool _initialized;

        public bool Empty { get { return _size == 0; } }

        public PriorityHeap(int initialSize, LessOrEqual leq)
        {
            _leq = leq;

            _nodes = new int[initialSize + 1];
            _handles = new HandleElem[initialSize + 1];

            _size = 0;
            _max = initialSize;
            _freeList = 0;
            _initialized = false;

            _nodes[1] = 1;
            _handles[1] = new HandleElem { _key = null };
        }

        private void FloatDown(int curr)
        {
            int child;
            int hCurr, hChild;

            hCurr = _nodes[curr];
            while (true)
            {
                child = curr << 1;
                if (child < _size && _leq(_handles[_nodes[child + 1]]._key, _handles[_nodes[child]]._key))
                {
                    ++child;
                }

                Debug.Assert(child <= _max);

                hChild = _nodes[child];
                if (child > _size || _leq(_handles[hCurr]._key, _handles[hChild]._key))
                {
                    _nodes[curr] = hCurr;
                    _handles[hCurr]._node = curr;
                    break;
                }

                _nodes[curr] = hChild;
                _handles[hChild]._node = curr;
                curr = child;
            }
        }

        private void FloatUp(int curr)
        {
            int parent;
            int hCurr, hParent;

            hCurr = _nodes[curr];
            while (true)
            {
                parent = curr >> 1;
                hParent = _nodes[parent];
                if (parent == 0 || _leq(_handles[hParent]._key, _handles[hCurr]._key))
                {
                    _nodes[curr] = hCurr;
                    _handles[hCurr]._node = curr;
                    break;
                }
                _nodes[curr] = hParent;
                _handles[hParent]._node = curr;
                curr = parent;
            }
        }

        public void Init()
        {
            for (int i = _size; i >= 1; --i)
            {
                FloatDown(i);
            }
            _initialized = true;
        }

        public PQHandle Insert(TValue value)
        {
            int curr = ++_size;
            if ((curr * 2) > _max)
            {
                _max <<= 1;
                Array.Resize(ref _nodes, _max + 1);
                Array.Resize(ref _handles, _max + 1);
            }

            int free;
            if (_freeList == 0)
            {
                free = curr;
            }
            else
            {
                free = _freeList;
                _freeList = _handles[free]._node;
            }

            _nodes[curr] = free;
            if (_handles[free] == null)
            {
                _handles[free] = new HandleElem { _key = value, _node = curr };
            }
            else
            {
                _handles[free]._node = curr;
                _handles[free]._key = value;
            }

            if (_initialized)
            {
                FloatUp(curr);
            }

            Debug.Assert(free != PQHandle.Invalid);
            return new PQHandle { _handle = free };
        }

        public TValue ExtractMin()
        {
            Debug.Assert(_initialized);

            int hMin = _nodes[1];
            TValue min = _handles[hMin]._key;

            if (_size > 0)
            {
                _nodes[1] = _nodes[_size];
                _handles[_nodes[1]]._node = 1;

                _handles[hMin]._key = null;
                _handles[hMin]._node = _freeList;
                _freeList = hMin;

                if (--_size > 0)
                {
                    FloatDown(1);
                }
            }

            return min;
        }

        public TValue Minimum()
        {
            Debug.Assert(_initialized);
            return _handles[_nodes[1]]._key;
        }

        public void Remove(PQHandle handle)
        {
            Debug.Assert(_initialized);

            int hCurr = handle._handle;
            Debug.Assert(hCurr >= 1 && hCurr <= _max && _handles[hCurr]._key != null);

            int curr = _handles[hCurr]._node;
            _nodes[curr] = _nodes[_size];
            _handles[_nodes[curr]]._node = curr;

            if (curr <= --_size)
            {
                if (curr <= 1 || _leq(_handles[_nodes[curr >> 1]]._key, _handles[_nodes[curr]]._key))
                {
                    FloatDown(curr);
                }
                else
                {
                    FloatUp(curr);
                }
            }

            _handles[hCurr]._key = null;
            _handles[hCurr]._node = _freeList;
            _freeList = hCurr;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/PriorityHeap.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/PriorityQueue.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 82a1a0638ccce9f42acb7e3e0c3134ba
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    internal class PriorityQueue<TValue> where TValue : class
    {
        private PriorityHeap<TValue>.LessOrEqual _leq;
        private PriorityHeap<TValue> _heap;
        private TValue[] _keys;
        private int[] _order;

        private int _size, _max;
        private bool _initialized;

        public bool Empty { get { return _size == 0 && _heap.Empty; } }

        public PriorityQueue(int initialSize, PriorityHeap<TValue>.LessOrEqual leq)
        {
            _leq = leq;
            _heap = new PriorityHeap<TValue>(initialSize, leq);

            _keys = new TValue[initialSize];

            _size = 0;
            _max = initialSize;
            _initialized = false;
        }

        class StackItem
        {
            internal int p, r;
        };

        static void Swap(ref int a, ref int b)
        {
            (b, a) = (a, b);
        }

        public void Init()
        {
            var stack = new Stack<StackItem>();
            int p, r, i, j, piv;
            uint seed = 2016473283;

            p = 0;
            r = _size - 1;
            _order = new int[_size + 1];
            for (piv = 0, i = p; i <= r; ++piv, ++i)
            {
                _order[i] = piv;
            }

            stack.Push(new StackItem { p = p, r = r });
            while (stack.Count > 0)
            {
                var top = stack.Pop();
                p = top.p;
                r = top.r;

                while (r > p + 10)
                {
                    seed = seed * 1539415821 + 1;
                    i = p + (int)(seed % (r - p + 1));
                    piv = _order[i];
                    _order[i] = _order[p];
                    _order[p] = piv;
                    i = p - 1;
                    j = r + 1;
                    do {
                        do { ++i; } while (!_leq(_keys[_order[i]], _keys[piv]));
                        do { --j; } while (!_leq(_keys[piv], _keys[_order[j]]));
                        Swap(ref _order[i], ref _order[j]);
                    } while (i < j);
                    Swap(ref _order[i], ref _order[j]);
                    if (i - p < r - j)
                    {
                        stack.Push(new StackItem { p = j + 1, r = r });
                        r = i - 1;
                    }
                    else
                    {
                        stack.Push(new StackItem { p = p, r = i - 1 });
                        p = j + 1;
                    }
                }
                for (i = p + 1; i <= r; ++i)
                {
                    piv = _order[i];
                    for (j = i; j > p && !_leq(_keys[piv], _keys[_order[j - 1]]); --j)
                    {
                        _order[j] = _order[j - 1];
                    }
                    _order[j] = piv;
                }
            }

#if DEBUG
            p = 0;
            r = _size - 1;
            for (i = p; i < r; ++i)
            {
                Debug.Assert(_leq(_keys[_order[i + 1]], _keys[_order[i]]), "Wrong sort");
            }
#endif

            _max = _size;
            _initialized = true;
            _heap.Init();
        }

        public PQHandle Insert(TValue value)
        {
            if (_initialized)
            {
                return _heap.Insert(value);
            }

            int curr = _size;
            if (++_size >= _max)
            {
                _max <<= 1;
                Array.Resize(ref _keys, _max);
            }

            _keys[curr] = value;
            return new PQHandle { _handle = -(curr + 1) };
        }

        public TValue ExtractMin()
        {
            Debug.Assert(_initialized);

            if (_size == 0)
            {
                return _heap.ExtractMin();
            }
            TValue sortMin = _keys[_order[_size - 1]];
            if (!_heap.Empty)
            {
                TValue heapMin = _heap.Minimum();
                if (_leq(heapMin, sortMin))
                    return _heap.ExtractMin();
            }
            do {
                --_size;
            } while (_size > 0 && _keys[_order[_size - 1]] == null);

            return sortMin;
        }

        public TValue Minimum()
        {
            Debug.Assert(_initialized);

            if (_size == 0)
            {
                return _heap.Minimum();
            }
            TValue sortMin = _keys[_order[_size - 1]];
            if (!_heap.Empty)
            {
                TValue heapMin = _heap.Minimum();
                if (_leq(heapMin, sortMin))
                    return heapMin;
            }
            return sortMin;
        }

        public void Remove(PQHandle handle)
        {
            Debug.Assert(_initialized);

            int curr = handle._handle;
            if (curr >= 0)
            {
                _heap.Remove(handle);
                return;
            }
            curr = -(curr + 1);
            Debug.Assert(curr < _max && _keys[curr] != null);

            _keys[curr] = null;
            while (_size > 0 && _keys[_order[_size - 1]] == null)
            {
                --_size;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/PriorityQueue.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Sweep.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eef0fc2628b35374394c6de7d1de2c34
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

using System;
using System.Diagnostics;

using Real = System.Single;
namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    public partial class Tess
    {
        internal class ActiveRegion
        {
            internal MeshUtils.Edge _eUp;
            internal Dict<ActiveRegion>.Node _nodeUp;
            internal int _windingNumber;
            internal bool _inside, _sentinel, _dirty, _fixUpperEdge;
        }

        private ActiveRegion RegionBelow(ActiveRegion reg)
        {
            return reg._nodeUp._prev._key;
        }

        private ActiveRegion RegionAbove(ActiveRegion reg)
        {
            return reg._nodeUp._next._key;
        }

        /// <summary>
        /// Both edges must be directed from right to left (this is the canonical
        /// direction for the upper edge of each region).
        /// 
        /// The strategy is to evaluate a "t" value for each edge at the
        /// current sweep line position, given by tess->event. The calculations
        /// are designed to be very stable, but of course they are not perfect.
        /// 
        /// Special case: if both edge destinations are at the sweep event,
        /// we sort the edges by slope (they would otherwise compare equally).
        /// </summary>
        private bool EdgeLeq(ActiveRegion reg1, ActiveRegion reg2)
        {
            var e1 = reg1._eUp;
            var e2 = reg2._eUp;

            if (e1._Dst == _event)
            {
                if (e2._Dst == _event)
                {
                    // Two edges right of the sweep line which meet at the sweep event.
                    // Sort them by slope.
                    if (Geom.VertLeq(e1._Org, e2._Org))
                    {
                        return Geom.EdgeSign(e2._Dst, e1._Org, e2._Org) <= 0.0f;
                    }
                    return Geom.EdgeSign(e1._Dst, e2._Org, e1._Org) >= 0.0f;
                }
                return Geom.EdgeSign(e2._Dst, _event, e2._Org) <= 0.0f;
            }
            if (e2._Dst == _event)
            {
                return Geom.EdgeSign(e1._Dst, _event, e1._Org) >= 0.0f;
            }

            // General case - compute signed distance *from* e1, e2 to event
            var t1 = Geom.EdgeEval(e1._Dst, _event, e1._Org);
            var t2 = Geom.EdgeEval(e2._Dst, _event, e2._Org);
            return (t1 >= t2);
        }

        private void DeleteRegion(ActiveRegion reg)
        {
            if (reg._fixUpperEdge)
            {
                // It was created with zero winding number, so it better be
                // deleted with zero winding number (ie. it better not get merged
                // with a real edge).
                Debug.Assert(reg._eUp._winding == 0);
            }
            reg._eUp._activeRegion = null;
            _dict.Remove(reg._nodeUp);
        }

        /// <summary>
        /// Replace an upper edge which needs fixing (see ConnectRightVertex).
        /// </summary>
        private void FixUpperEdge(ActiveRegion reg, MeshUtils.Edge newEdge)
        {
            Debug.Assert(reg._fixUpperEdge);
            _mesh.Delete(reg._eUp);
            reg._fixUpperEdge = false;
            reg._eUp = newEdge;
            newEdge._activeRegion = reg;
        }

        private ActiveRegion TopLeftRegion(ActiveRegion reg)
        {
            var org = reg._eUp._Org;

            // Find the region above the uppermost edge with the same origin
            do {
                reg = RegionAbove(reg);
            } while (reg._eUp._Org == org);

            // If the edge above was a temporary edge introduced by ConnectRightVertex,
            // now is the time to fix it.
            if (reg._fixUpperEdge)
            {
                var e = _mesh.Connect(RegionBelow(reg)._eUp._Sym, reg._eUp._Lnext);
                FixUpperEdge(reg, e);
                reg = RegionAbove(reg);
            }

            return reg;
        }

        private ActiveRegion TopRightRegion(ActiveRegion reg)
        {
            var dst = reg._eUp._Dst;

            // Find the region above the uppermost edge with the same destination
            do {
                reg = RegionAbove(reg);
            } while (reg._eUp._Dst == dst);

            return reg;
        }

        /// <summary>
        /// Add a new active region to the sweep line, *somewhere* below "regAbove"
        /// (according to where the new edge belongs in the sweep-line dictionary).
        /// The upper edge of the new region will be "eNewUp".
        /// Winding number and "inside" flag are not updated.
        /// </summary>
        private ActiveRegion AddRegionBelow(ActiveRegion regAbove, MeshUtils.Edge eNewUp)
        {
            var regNew = new ActiveRegion();

            regNew._eUp = eNewUp;
            regNew._nodeUp = _dict.InsertBefore(regAbove._nodeUp, regNew);
            regNew._fixUpperEdge = false;
            regNew._sentinel = false;
            regNew._dirty = false;

            eNewUp._activeRegion = regNew;

            return regNew;
        }

        private void ComputeWinding(ActiveRegion reg)
        {
            reg._windingNumber = RegionAbove(reg)._windingNumber + reg._eUp._winding;
            reg._inside = Geom.IsWindingInside(_windingRule, reg._windingNumber);
        }

        /// <summary>
        /// Delete a region from the sweep line. This happens when the upper
        /// and lower chains of a region meet (at a vertex on the sweep line).
        /// The "inside" flag is copied to the appropriate mesh face (we could
        /// not do this before -- since the structure of the mesh is always
        /// changing, this face may not have even existed until now).
        /// </summary>
        private void FinishRegion(ActiveRegion reg)
        {
            var e = reg._eUp;
            var f = e._Lface;

            f._inside = reg._inside;
            f._anEdge = e;
            DeleteRegion(reg);
        }

        /// <summary>
        /// We are given a vertex with one or more left-going edges.  All affected
        /// edges should be in the edge dictionary.  Starting at regFirst->eUp,
        /// we walk down deleting all regions where both edges have the same
        /// origin vOrg.  At the same time we copy the "inside" flag from the
        /// active region to the face, since at this point each face will belong
        /// to at most one region (this was not necessarily true until this point
        /// in the sweep).  The walk stops at the region above regLast; if regLast
        /// is null we walk as far as possible.  At the same time we relink the
        /// mesh if necessary, so that the ordering of edges around vOrg is the
        /// same as in the dictionary.
        /// </summary>
        private MeshUtils.Edge FinishLeftRegions(ActiveRegion regFirst, ActiveRegion regLast)
        {
            var regPrev = regFirst;
            var ePrev = regFirst._eUp;

            while (regPrev != regLast)
            {
                regPrev._fixUpperEdge = false;	// placement was OK
                var reg = RegionBelow(regPrev);
                var e = reg._eUp;
                if (e._Org != ePrev._Org)
                {
                    if (!reg._fixUpperEdge)
                    {
                        // Remove the last left-going edge.  Even though there are no further
                        // edges in the dictionary with this origin, there may be further
                        // such edges in the mesh (if we are adding left edges to a vertex
                        // that has already been processed).  Thus it is important to call
                        // FinishRegion rather than just DeleteRegion.
                        FinishRegion(regPrev);
                        break;
                    }
                    // If the edge below was a temporary edge introduced by
                    // ConnectRightVertex, now is the time to fix it.
                    e = _mesh.Connect(ePrev._Lprev, e._Sym);
                    FixUpperEdge(reg, e);
                }

                // Relink edges so that ePrev.Onext == e
                if (ePrev._Onext != e)
                {
                    _mesh.Splice(e._Oprev, e);
                    _mesh.Splice(ePrev, e);
                }
                FinishRegion(regPrev); // may change reg.eUp
                ePrev = reg._eUp;
                regPrev = reg;
            }

            return ePrev;
        }

        /// <summary>
        /// Purpose: insert right-going edges into the edge dictionary, and update
        /// winding numbers and mesh connectivity appropriately.  All right-going
        /// edges share a common origin vOrg.  Edges are inserted CCW starting at
        /// eFirst; the last edge inserted is eLast.Oprev.  If vOrg has any
        /// left-going edges already processed, then eTopLeft must be the edge
        /// such that an imaginary upward vertical segment from vOrg would be
        /// contained between eTopLeft.Oprev and eTopLeft; otherwise eTopLeft
        /// should be null.
        /// </summary>
        private void AddRightEdges(ActiveRegion regUp, MeshUtils.Edge eFirst, MeshUtils.Edge eLast, MeshUtils.Edge eTopLeft, bool cleanUp)
        {
            bool firstTime = true;

            var e = eFirst; do
            {
                Debug.Assert(Geom.VertLeq(e._Org, e._Dst));
                AddRegionBelow(regUp, e._Sym);
                e = e._Onext;
            } while (e != eLast);

            // Walk *all* right-going edges from e.Org, in the dictionary order,
            // updating the winding numbers of each region, and re-linking the mesh
            // edges to match the dictionary ordering (if necessary).
            if (eTopLeft == null)
            {
                eTopLeft = RegionBelow(regUp)._eUp._Rprev;
            }

            ActiveRegion regPrev = regUp, reg;
            var ePrev = eTopLeft;
            while (true)
            {
                reg = RegionBelow(regPrev);
                e = reg._eUp._Sym;
                if (e._Org != ePrev._Org) break;

                if (e._Onext != ePrev)
                {
                    // Unlink e from its current position, and relink below ePrev
                    _mesh.Splice(e._Oprev, e);
                    _mesh.Splice(ePrev._Oprev, e);
                }
                // Compute the winding number and "inside" flag for the new regions
                reg._windingNumber = regPrev._windingNumber - e._winding;
                reg._inside = Geom.IsWindingInside(_windingRule, reg._windingNumber);

                // Check for two outgoing edges with same slope -- process these
                // before any intersection tests (see example in tessComputeInterior).
                regPrev._dirty = true;
                if (!firstTime && CheckForRightSplice(regPrev))
                {
                    Geom.AddWinding(e, ePrev);
                    DeleteRegion(regPrev);
                    _mesh.Delete(ePrev);
                }
                firstTime = false;
                regPrev = reg;
                ePrev = e;
            }
            regPrev._dirty = true;
            Debug.Assert(regPrev._windingNumber - e._winding == reg._windingNumber);

            if (cleanUp)
            {
                // Check for intersections between newly adjacent edges.
                WalkDirtyRegions(regPrev);
            }
        }

        /// <summary>
        /// Two vertices with idential coordinates are combined into one.
        /// e1.Org is kept, while e2.Org is discarded.
        /// </summary>
        private void SpliceMergeVertices(MeshUtils.Edge e1, MeshUtils.Edge e2)
        {
            _mesh.Splice(e1, e2);
        }

        /// <summary>
        /// Find some weights which describe how the intersection vertex is
        /// a linear combination of "org" and "dest".  Each of the two edges
        /// which generated "isect" is allocated 50% of the weight; each edge
        /// splits the weight between its org and dst according to the
        /// relative distance to "isect".
        /// </summary>
        private void VertexWeights(MeshUtils.Vertex isect, MeshUtils.Vertex org, MeshUtils.Vertex dst, out Real w0, out Real w1)
        {
            var t1 = Geom.VertL1dist(org, isect);
            var t2 = Geom.VertL1dist(dst, isect);

            w0 = (t2 / (t1 + t2)) / 2.0f;
            w1 = (t1 / (t1 + t2)) / 2.0f;

            isect._coords.X += w0 * org._coords.X + w1 * dst._coords.X;
            isect._coords.Y += w0 * org._coords.Y + w1 * dst._coords.Y;
            isect._coords.Z += w0 * org._coords.Z + w1 * dst._coords.Z;
        }

        /// <summary>
        /// We've computed a new intersection point, now we need a "data" pointer
        /// from the user so that we can refer to this new vertex in the
        /// rendering callbacks.
        /// </summary>
        private void GetIntersectData(MeshUtils.Vertex isect, MeshUtils.Vertex orgUp, MeshUtils.Vertex dstUp, MeshUtils.Vertex orgLo, MeshUtils.Vertex dstLo)
        {
            isect._coords = Vec3.Zero;
            Real w0, w1, w2, w3;
            VertexWeights(isect, orgUp, dstUp, out w0, out w1);
            VertexWeights(isect, orgLo, dstLo, out w2, out w3);

            if (_combineCallback != null)
            {
                isect._data = _combineCallback(
                    isect._coords,
                    new object[] { orgUp._data, dstUp._data, orgLo._data, dstLo._data },
                    new Real[] { w0, w1, w2, w3 }
                );
            }
        }

        /// <summary>
        /// Check the upper and lower edge of "regUp", to make sure that the
        /// eUp->Org is above eLo, or eLo->Org is below eUp (depending on which
        /// origin is leftmost).
        /// 
        /// The main purpose is to splice right-going edges with the same
        /// dest vertex and nearly identical slopes (ie. we can't distinguish
        /// the slopes numerically).  However the splicing can also help us
        /// to recover from numerical errors.  For example, suppose at one
        /// point we checked eUp and eLo, and decided that eUp->Org is barely
        /// above eLo.  Then later, we split eLo into two edges (eg. from
        /// a splice operation like this one).  This can change the result of
        /// our test so that now eUp->Org is incident to eLo, or barely below it.
        /// We must correct this condition to maintain the dictionary invariants.
        /// 
        /// One possibility is to check these edges for intersection again
        /// (ie. CheckForIntersect).  This is what we do if possible.  However
        /// CheckForIntersect requires that tess->event lies between eUp and eLo,
        /// so that it has something to fall back on when the intersection
        /// calculation gives us an unusable answer.  So, for those cases where
        /// we can't check for intersection, this routine fixes the problem
        /// by just splicing the offending vertex into the other edge.
        /// This is a guaranteed solution, no matter how degenerate things get.
        /// Basically this is a combinatorial solution to a numerical problem.
        /// </summary>
        private bool CheckForRightSplice(ActiveRegion regUp)
        {
            var regLo = RegionBelow(regUp);
            var eUp = regUp._eUp;
            var eLo = regLo._eUp;

            if (Geom.VertLeq(eUp._Org, eLo._Org))
            {
                if (Geom.EdgeSign(eLo._Dst, eUp._Org, eLo._Org) > 0.0f)
                {
                    return false;
                }

                // eUp.Org appears to be below eLo
                if (!Geom.VertEq(eUp._Org, eLo._Org))
                {
                    // Splice eUp._Org into eLo
                    _mesh.SplitEdge(eLo._Sym);
                    _mesh.Splice(eUp, eLo._Oprev);
                    regUp._dirty = regLo._dirty = true;
                }
                else if (eUp._Org != eLo._Org)
                {
                    // merge the two vertices, discarding eUp.Org
                    _pq.Remove(eUp._Org._pqHandle);
                    SpliceMergeVertices(eLo._Oprev, eUp);
                }
            }
            else
            {
                if (Geom.EdgeSign(eUp._Dst, eLo._Org, eUp._Org) < 0.0f)
                {
                    return false;
                }

                // eLo.Org appears to be above eUp, so splice eLo.Org into eUp
                RegionAbove(regUp)._dirty = regUp._dirty = true;
                _mesh.SplitEdge(eUp._Sym);
                _mesh.Splice(eLo._Oprev, eUp);
            }
            return true;
        }
        
        /// <summary>
        /// Check the upper and lower edge of "regUp", to make sure that the
        /// eUp->Dst is above eLo, or eLo->Dst is below eUp (depending on which
        /// destination is rightmost).
        /// 
        /// Theoretically, this should always be true.  However, splitting an edge
        /// into two pieces can change the results of previous tests.  For example,
        /// suppose at one point we checked eUp and eLo, and decided that eUp->Dst
        /// is barely above eLo.  Then later, we split eLo into two edges (eg. from
        /// a splice operation like this one).  This can change the result of
        /// the test so that now eUp->Dst is incident to eLo, or barely below it.
        /// We must correct this condition to maintain the dictionary invariants
        /// (otherwise new edges might get inserted in the wrong place in the
        /// dictionary, and bad stuff will happen).
        /// 
        /// We fix the problem by just splicing the offending vertex into the
        /// other edge.
        /// </summary>
        private bool CheckForLeftSplice(ActiveRegion regUp)
        {
            var regLo = RegionBelow(regUp);
            var eUp = regUp._eUp;
            var eLo = regLo._eUp;

            Debug.Assert(!Geom.VertEq(eUp._Dst, eLo._Dst));

            if (Geom.VertLeq(eUp._Dst, eLo._Dst))
            {
                if (Geom.EdgeSign(eUp._Dst, eLo._Dst, eUp._Org) < 0.0f)
                {
                    return false;
                }

                // eLo.Dst is above eUp, so splice eLo.Dst into eUp
                RegionAbove(regUp)._dirty = regUp._dirty = true;
                var e = _mesh.SplitEdge(eUp);
                _mesh.Splice(eLo._Sym, e);
                e._Lface._inside = regUp._inside;
            }
            else
            {
                if (Geom.EdgeSign(eLo._Dst, eUp._Dst, eLo._Org) > 0.0f)
                {
                    return false;
                }

                // eUp.Dst is below eLo, so splice eUp.Dst into eLo
                regUp._dirty = regLo._dirty = true;
                var e = _mesh.SplitEdge(eLo);
                _mesh.Splice(eUp._Lnext, eLo._Sym);
                e._Rface._inside = regUp._inside;
            }
            return true;
        }

        /// <summary>
        /// Check the upper and lower edges of the given region to see if
        /// they intersect.  If so, create the intersection and add it
        /// to the data structures.
        /// 
        /// Returns TRUE if adding the new intersection resulted in a recursive
        /// call to AddRightEdges(); in this case all "dirty" regions have been
        /// checked for intersections, and possibly regUp has been deleted.
        /// </summary>
        private bool CheckForIntersect(ActiveRegion regUp)
        {
            var regLo = RegionBelow(regUp);
            var eUp = regUp._eUp;
            var eLo = regLo._eUp;
            var orgUp = eUp._Org;
            var orgLo = eLo._Org;
            var dstUp = eUp._Dst;
            var dstLo = eLo._Dst;

            Debug.Assert(!Geom.VertEq(dstLo, dstUp));
            Debug.Assert(Geom.EdgeSign(dstUp, _event, orgUp) <= 0.0f);
            Debug.Assert(Geom.EdgeSign(dstLo, _event, orgLo) >= 0.0f);
            Debug.Assert(orgUp != _event && orgLo != _event);
            Debug.Assert(!regUp._fixUpperEdge && !regLo._fixUpperEdge);

            if( orgUp == orgLo )
            {
                // right endpoints are the same
                return false;
            }

            var tMinUp = Math.Min(orgUp._t, dstUp._t);
            var tMaxLo = Math.Max(orgLo._t, dstLo._t);
            if( tMinUp > tMaxLo )
            {
                // t ranges do not overlap
                return false;
            }

            if (Geom.VertLeq(orgUp, orgLo))
            {
                if (Geom.EdgeSign( dstLo, orgUp, orgLo ) > 0.0f)
                {
                    return false;
                }
            }
            else
            {
                if (Geom.EdgeSign( dstUp, orgLo, orgUp ) < 0.0f)
                {
                    return false;
                }
            }

            // At this point the edges intersect, at least marginally

            var isect = MeshUtils.Vertex.Create();
            Geom.EdgeIntersect(dstUp, orgUp, dstLo, orgLo, isect);
            // The following properties are guaranteed:
            Debug.Assert(Math.Min(orgUp._t, dstUp._t) <= isect._t);
            Debug.Assert(isect._t <= Math.Max(orgLo._t, dstLo._t));
            Debug.Assert(Math.Min(dstLo._s, dstUp._s) <= isect._s);
            Debug.Assert(isect._s <= Math.Max(orgLo._s, orgUp._s));

            if (Geom.VertLeq(isect, _event))
            {
                // The intersection point lies slightly to the left of the sweep line,
                // so move it until it''s slightly to the right of the sweep line.
                // (If we had perfect numerical precision, this would never happen
                // in the first place). The easiest and safest thing to do is
                // replace the intersection by tess._event.
                isect._s = _event._s;
                isect._t = _event._t;
            }
            // Similarly, if the computed intersection lies to the right of the
            // rightmost origin (which should rarely happen), it can cause
            // unbelievable inefficiency on sufficiently degenerate inputs.
            // (If you have the test program, try running test54.d with the
            // "X zoom" option turned on).
            var orgMin = Geom.VertLeq(orgUp, orgLo) ? orgUp : orgLo;
            if (Geom.VertLeq(orgMin, isect))
            {
                isect._s = orgMin._s;
                isect._t = orgMin._t;
            }

            if (Geom.VertEq(isect, orgUp) || Geom.VertEq(isect, orgLo))
            {
                // Easy case -- intersection at one of the right endpoints
                CheckForRightSplice(regUp);
                return false;
            }

            if (   (! Geom.VertEq(dstUp, _event)
                && Geom.EdgeSign(dstUp, _event, isect) >= 0.0f)
                || (! Geom.VertEq(dstLo, _event)
                && Geom.EdgeSign(dstLo, _event, isect) <= 0.0f))
            {
                // Very unusual -- the new upper or lower edge would pass on the
                // wrong side of the sweep event, or through it. This can happen
                // due to very small numerical errors in the intersection calculation.
                if (dstLo == _event)
                {
                    // Splice dstLo into eUp, and process the new region(s)
                    _mesh.SplitEdge(eUp._Sym);
                    _mesh.Splice(eLo._Sym, eUp);
                    regUp = TopLeftRegion(regUp);
                    eUp = RegionBelow(regUp)._eUp;
                    FinishLeftRegions(RegionBelow(regUp), regLo);
                    AddRightEdges(regUp, eUp._Oprev, eUp, eUp, true);
                    return true;
                }
                if( dstUp == _event ) {
                    /* Splice dstUp into eLo, and process the new region(s) */
                    _mesh.SplitEdge(eLo._Sym);
                    _mesh.Splice(eUp._Lnext, eLo._Oprev);
                    regLo = regUp;
                    regUp = TopRightRegion(regUp);
                    var e = RegionBelow(regUp)._eUp._Rprev;
                    regLo._eUp = eLo._Oprev;
                    eLo = FinishLeftRegions(regLo, null);
                    AddRightEdges(regUp, eLo._Onext, eUp._Rprev, e, true);
                    return true;
                }
                // Special case: called from ConnectRightVertex. If either
                // edge passes on the wrong side of tess._event, split it
                // (and wait for ConnectRightVertex to splice it appropriately).
                if (Geom.EdgeSign( dstUp, _event, isect ) >= 0.0f)
                {
                    RegionAbove(regUp)._dirty = regUp._dirty = true;
                    _mesh.SplitEdge(eUp._Sym);
                    eUp._Org._s = _event._s;
                    eUp._Org._t = _event._t;
                }
                if (Geom.EdgeSign(dstLo, _event, isect) <= 0.0f)
                {
                    regUp._dirty = regLo._dirty = true;
                    _mesh.SplitEdge(eLo._Sym);
                    eLo._Org._s = _event._s;
                    eLo._Org._t = _event._t;
                }
                // leave the rest for ConnectRightVertex
                return false;
            }

            // General case -- split both edges, splice into new vertex.
            // When we do the splice operation, the order of the arguments is
            // arbitrary as far as correctness goes. However, when the operation
            // creates a new face, the work done is proportional to the size of
            // the new face.  We expect the faces in the processed part of
            // the mesh (ie. eUp._Lface) to be smaller than the faces in the
            // unprocessed original contours (which will be eLo._Oprev._Lface).
            _mesh.SplitEdge(eUp._Sym);
            _mesh.SplitEdge(eLo._Sym);
            _mesh.Splice(eLo._Oprev, eUp);
            eUp._Org._s = isect._s;
            eUp._Org._t = isect._t;
            eUp._Org._pqHandle = _pq.Insert(eUp._Org);
            if (eUp._Org._pqHandle._handle == PQHandle.Invalid)
            {
                throw new InvalidOperationException("PQHandle should not be invalid");
            }
            GetIntersectData(eUp._Org, orgUp, dstUp, orgLo, dstLo);
            RegionAbove(regUp)._dirty = regUp._dirty = regLo._dirty = true;
            return false;
        }

        /// <summary>
        /// When the upper or lower edge of any region changes, the region is
        /// marked "dirty".  This routine walks through all the dirty regions
        /// and makes sure that the dictionary invariants are satisfied
        /// (see the comments at the beginning of this file).  Of course
        /// new dirty regions can be created as we make changes to restore
        /// the invariants.
        /// </summary>
        private void WalkDirtyRegions(ActiveRegion regUp)
        {
            var regLo = RegionBelow(regUp);
            MeshUtils.Edge eUp, eLo;

            while (true)
            {
                // Find the lowest dirty region (we walk from the bottom up).
                while (regLo._dirty)
                {
                    regUp = regLo;
                    regLo = RegionBelow(regLo);
                }
                if (!regUp._dirty)
                {
                    regLo = regUp;
                    regUp = RegionAbove( regUp );
                    if(regUp == null || !regUp._dirty)
                    {
                        // We've walked all the dirty regions
                        return;
                    }
                }
                regUp._dirty = false;
                eUp = regUp._eUp;
                eLo = regLo._eUp;

                if (eUp._Dst != eLo._Dst)
                {
                    // Check that the edge ordering is obeyed at the Dst vertices.
                    if (CheckForLeftSplice(regUp))
                    {

                        // If the upper or lower edge was marked fixUpperEdge, then
                        // we no longer need it (since these edges are needed only for
                        // vertices which otherwise have no right-going edges).
                        if (regLo._fixUpperEdge)
                        {
                            DeleteRegion(regLo);
                            _mesh.Delete(eLo);
                            regLo = RegionBelow(regUp);
                            eLo = regLo._eUp;
                        }
                        else if( regUp._fixUpperEdge )
                        {
                            DeleteRegion(regUp);
                            _mesh.Delete(eUp);
                            regUp = RegionAbove(regLo);
                            eUp = regUp._eUp;
                        }
                    }
                }
                if (eUp._Org != eLo._Org)
                {
                    if(    eUp._Dst != eLo._Dst
                        && ! regUp._fixUpperEdge && ! regLo._fixUpperEdge
                        && (eUp._Dst == _event || eLo._Dst == _event) )
                    {
                        // When all else fails in CheckForIntersect(), it uses tess._event
                        // as the intersection location. To make this possible, it requires
                        // that tess._event lie between the upper and lower edges, and also
                        // that neither of these is marked fixUpperEdge (since in the worst
                        // case it might splice one of these edges into tess.event, and
                        // violate the invariant that fixable edges are the only right-going
                        // edge from their associated vertex).
                        if (CheckForIntersect(regUp))
                        {
                            // WalkDirtyRegions() was called recursively; we're done
                            return;
                        }
                    }
                    else
                    {
                        // Even though we can't use CheckForIntersect(), the Org vertices
                        // may violate the dictionary edge ordering. Check and correct this.
                        CheckForRightSplice(regUp);
                    }
                }
                if (eUp._Org == eLo._Org && eUp._Dst == eLo._Dst)
                {
                    // A degenerate loop consisting of only two edges -- delete it.
                    Geom.AddWinding(eLo, eUp);
                    DeleteRegion(regUp);
                    _mesh.Delete(eUp);
                    regUp = RegionAbove(regLo);
                }
            }
        }

        /// <summary>
        /// Purpose: connect a "right" vertex vEvent (one where all edges go left)
        /// to the unprocessed portion of the mesh.  Since there are no right-going
        /// edges, two regions (one above vEvent and one below) are being merged
        /// into one.  "regUp" is the upper of these two regions.
        /// 
        /// There are two reasons for doing this (adding a right-going edge):
        ///  - if the two regions being merged are "inside", we must add an edge
        ///    to keep them separated (the combined region would not be monotone).
        ///  - in any case, we must leave some record of vEvent in the dictionary,
        ///    so that we can merge vEvent with features that we have not seen yet.
        ///    For example, maybe there is a vertical edge which passes just to
        ///    the right of vEvent; we would like to splice vEvent into this edge.
        /// 
        /// However, we don't want to connect vEvent to just any vertex.  We don''t
        /// want the new edge to cross any other edges; otherwise we will create
        /// intersection vertices even when the input data had no self-intersections.
        /// (This is a bad thing; if the user's input data has no intersections,
        /// we don't want to generate any false intersections ourselves.)
        /// 
        /// Our eventual goal is to connect vEvent to the leftmost unprocessed
        /// vertex of the combined region (the union of regUp and regLo).
        /// But because of unseen vertices with all right-going edges, and also
        /// new vertices which may be created by edge intersections, we don''t
        /// know where that leftmost unprocessed vertex is.  In the meantime, we
        /// connect vEvent to the closest vertex of either chain, and mark the region
        /// as "fixUpperEdge".  This flag says to delete and reconnect this edge
        /// to the next processed vertex on the boundary of the combined region.
        /// Quite possibly the vertex we connected to will turn out to be the
        /// closest one, in which case we won''t need to make any changes.
        /// </summary>
        private void ConnectRightVertex(ActiveRegion regUp, MeshUtils.Edge eBottomLeft)
        {
            var eTopLeft = eBottomLeft._Onext;
            var regLo = RegionBelow(regUp);
            var eUp = regUp._eUp;
            var eLo = regLo._eUp;
            bool degenerate = false;

            if (eUp._Dst != eLo._Dst)
            {
                CheckForIntersect(regUp);
            }

            // Possible new degeneracies: upper or lower edge of regUp may pass
            // through vEvent, or may coincide with new intersection vertex
            if (Geom.VertEq(eUp._Org, _event))
            {
                _mesh.Splice(eTopLeft._Oprev, eUp);
                regUp = TopLeftRegion(regUp);
                eTopLeft = RegionBelow(regUp)._eUp;
                FinishLeftRegions(RegionBelow(regUp), regLo);
                degenerate = true;
            }
            if (Geom.VertEq(eLo._Org, _event))
            {
                _mesh.Splice(eBottomLeft, eLo._Oprev);
                eBottomLeft = FinishLeftRegions(regLo, null);
                degenerate = true;
            }
            if (degenerate)
            {
                AddRightEdges(regUp, eBottomLeft._Onext, eTopLeft, eTopLeft, true);
                return;
            }

            // Non-degenerate situation -- need to add a temporary, fixable edge.
            // Connect to the closer of eLo.Org, eUp.Org.
            MeshUtils.Edge eNew;
            if (Geom.VertLeq(eLo._Org, eUp._Org))
            {
                eNew = eLo._Oprev;
            }
            else
            {
                eNew = eUp;
            }
            eNew = _mesh.Connect(eBottomLeft._Lprev, eNew);

            // Prevent cleanup, otherwise eNew might disappear before we've even
            // had a chance to mark it as a temporary edge.
            AddRightEdges(regUp, eNew, eNew._Onext, eNew._Onext, false);
            eNew._Sym._activeRegion._fixUpperEdge = true;
            WalkDirtyRegions(regUp);
        }

        /// <summary>
        /// The event vertex lies exacty on an already-processed edge or vertex.
        /// Adding the new vertex involves splicing it into the already-processed
        /// part of the mesh.
        /// </summary>
        private void ConnectLeftDegenerate(ActiveRegion regUp, MeshUtils.Vertex vEvent)
        {
            var e = regUp._eUp;
            if (Geom.VertEq(e._Org, vEvent))
            {
                // e.Org is an unprocessed vertex - just combine them, and wait
                // for e.Org to be pulled from the queue
                // C# : in the C version, there is a flag but it was never implemented
                // the vertices are before beginning the tesselation
                throw new InvalidOperationException("Vertices should have been merged before");
            }

            if (!Geom.VertEq(e._Dst, vEvent))
            {
                // General case -- splice vEvent into edge e which passes through it
                _mesh.SplitEdge(e._Sym);
                if (regUp._fixUpperEdge)
                {
                    // This edge was fixable -- delete unused portion of original edge
                    _mesh.Delete(e._Onext);
                    regUp._fixUpperEdge = false;
                }
                _mesh.Splice(vEvent._anEdge, e);
                SweepEvent(vEvent);	// recurse
                return;
            }

            // See above
            throw new InvalidOperationException("Vertices should have been merged before");
        }

        /// <summary>
        /// Purpose: connect a "left" vertex (one where both edges go right)
        /// to the processed portion of the mesh.  Let R be the active region
        /// containing vEvent, and let U and L be the upper and lower edge
        /// chains of R.  There are two possibilities:
        /// 
        /// - the normal case: split R into two regions, by connecting vEvent to
        ///   the rightmost vertex of U or L lying to the left of the sweep line
        /// 
        /// - the degenerate case: if vEvent is close enough to U or L, we
        ///   merge vEvent into that edge chain.  The subcases are:
        ///     - merging with the rightmost vertex of U or L
        ///     - merging with the active edge of U or L
        ///     - merging with an already-processed portion of U or L
        /// </summary>
        private void ConnectLeftVertex(MeshUtils.Vertex vEvent)
        {
            var tmp = new ActiveRegion();

            // Get a pointer to the active region containing vEvent
            tmp._eUp = vEvent._anEdge._Sym;
            var regUp = _dict.Find(tmp).Key;
            var regLo = RegionBelow(regUp);
            if (regLo == null)
            {
                // This may happen if the input polygon is coplanar.
                return;
            }
            var eUp = regUp._eUp;
            var eLo = regLo._eUp;

            // Try merging with U or L first
            if (Geom.EdgeSign(eUp._Dst, vEvent, eUp._Org) == 0.0f)
            {
                ConnectLeftDegenerate(regUp, vEvent);
                return;
            }

            // Connect vEvent to rightmost processed vertex of either chain.
            // e._Dst is the vertex that we will connect to vEvent.
            var reg = Geom.VertLeq(eLo._Dst, eUp._Dst) ? regUp : regLo;

            if (regUp._inside || reg._fixUpperEdge)
            {
                MeshUtils.Edge eNew;
                if (reg == regUp)
                {
                    eNew = _mesh.Connect(vEvent._anEdge._Sym, eUp._Lnext);
                }
                else
                {
                    eNew = _mesh.Connect(eLo._Dnext, vEvent._anEdge)._Sym;
                }
                if (reg._fixUpperEdge)
                {
                    FixUpperEdge(reg, eNew);
                }
                else
                {
                    ComputeWinding(AddRegionBelow(regUp, eNew));
                }
                SweepEvent(vEvent);
            }
            else
            {
                // The new vertex is in a region which does not belong to the polygon.
                // We don't need to connect this vertex to the rest of the mesh.
                AddRightEdges(regUp, vEvent._anEdge, vEvent._anEdge, null, true);
            }
        }

        /// <summary>
        /// Does everything necessary when the sweep line crosses a vertex.
        /// Updates the mesh and the edge dictionary.
        /// </summary>
        private void SweepEvent(MeshUtils.Vertex vEvent)
        {
            _event = vEvent;

            // Check if this vertex is the right endpoint of an edge that is
            // already in the dictionary. In this case we don't need to waste
            // time searching for the location to insert new edges.
            var e = vEvent._anEdge;
            while (e._activeRegion == null)
            {
                e = e._Onext;
                if (e == vEvent._anEdge)
                {
                    // All edges go right -- not incident to any processed edges
                    ConnectLeftVertex(vEvent);
                    return;
                }
            }

            // Processing consists of two phases: first we "finish" all the
            // active regions where both the upper and lower edges terminate
            // at vEvent (ie. vEvent is closing off these regions).
            // We mark these faces "inside" or "outside" the polygon according
            // to their winding number, and delete the edges from the dictionary.
            // This takes care of all the left-going edges from vEvent.
            var regUp = TopLeftRegion(e._activeRegion);
            var reg = RegionBelow(regUp);
            var eTopLeft = reg._eUp;
            var eBottomLeft = FinishLeftRegions(reg, null);

            // Next we process all the right-going edges from vEvent. This
            // involves adding the edges to the dictionary, and creating the
            // associated "active regions" which record information about the
            // regions between adjacent dictionary edges.
            if (eBottomLeft._Onext == eTopLeft)
            {
                // No right-going edges -- add a temporary "fixable" edge
                ConnectRightVertex(regUp, eBottomLeft);
            }
            else
            {
                AddRightEdges(regUp, eBottomLeft._Onext, eTopLeft, eTopLeft, true);
            }
        }

        /// <summary>
        /// Make the sentinel coordinates big enough that they will never be
        /// merged with real input features.
        /// 
        /// We add two sentinel edges above and below all other edges,
        /// to avoid special cases at the top and bottom.
        /// </summary>
        private void AddSentinel(Real smin, Real smax, Real t)
        {
            var e = _mesh.MakeEdge();
            e._Org._s = smax;
            e._Org._t = t;
            e._Dst._s = smin;
            e._Dst._t = t;
            _event = e._Dst; // initialize it

            var reg = new ActiveRegion();
            reg._eUp = e;
            reg._windingNumber = 0;
            reg._inside = false;
            reg._fixUpperEdge = false;
            reg._sentinel = true;
            reg._dirty = false;
            reg._nodeUp = _dict.Insert(reg);
        }

        /// <summary>
        /// We maintain an ordering of edge intersections with the sweep line.
        /// This order is maintained in a dynamic dictionary.
        /// </summary>
        private void InitEdgeDict()
        {
            _dict = new Dict<ActiveRegion>(EdgeLeq);

            AddSentinel(-SentinelCoord, SentinelCoord, -SentinelCoord);
            AddSentinel(-SentinelCoord, SentinelCoord, +SentinelCoord);
        }

        private void DoneEdgeDict()
        {
            int fixedEdges = 0;

            ActiveRegion reg;
            while ((reg = _dict.Min().Key) != null)
            {
                // At the end of all processing, the dictionary should contain
                // only the two sentinel edges, plus at most one "fixable" edge
                // created by ConnectRightVertex().
                if (!reg._sentinel)
                {
                    Debug.Assert(reg._fixUpperEdge);
                    Debug.Assert(++fixedEdges == 1);
                }
                Debug.Assert(reg._windingNumber == 0);
                DeleteRegion(reg);
            }

            _dict = null;
        }

        /// <summary>
        /// Remove zero-length edges, and contours with fewer than 3 vertices.
        /// </summary>
        private void RemoveDegenerateEdges()
        {
            MeshUtils.Edge eHead = _mesh._eHead, e, eNext, eLnext;

            for (e = eHead._next; e != eHead; e = eNext)
            {
                eNext = e._next;
                eLnext = e._Lnext;

                if (Geom.VertEq(e._Org, e._Dst) && e._Lnext._Lnext != e)
                {
                    // Zero-length edge, contour has at least 3 edges

                    SpliceMergeVertices(eLnext, e);	// deletes e.Org
                    _mesh.Delete(e); // e is a self-loop
                    e = eLnext;
                    eLnext = e._Lnext;
                }
                if (eLnext._Lnext == e)
                {
                    // Degenerate contour (one or two edges)

                    if (eLnext != e)
                    {
                        if (eLnext == eNext || eLnext == eNext._Sym)
                        {
                            eNext = eNext._next;
                        }
                        _mesh.Delete(eLnext);
                    }
                    if (e == eNext || e == eNext._Sym)
                    {
                        eNext = eNext._next;
                    }
                    _mesh.Delete(e);
                }
            }
        }

        /// <summary>
        /// Insert all vertices into the priority queue which determines the
        /// order in which vertices cross the sweep line.
        /// </summary>
        private void InitPriorityQ()
        {
            MeshUtils.Vertex vHead = _mesh._vHead, v;
            int vertexCount = 0;

            for (v = vHead._next; v != vHead; v = v._next)
            {
                vertexCount++;
            }
            // Make sure there is enough space for sentinels.
            vertexCount += 8;
    
            _pq = new PriorityQueue<MeshUtils.Vertex>(vertexCount, Geom.VertLeq);

            vHead = _mesh._vHead;
            for( v = vHead._next; v != vHead; v = v._next ) {
                v._pqHandle = _pq.Insert(v);
                if (v._pqHandle._handle == PQHandle.Invalid)
                {
                    throw new InvalidOperationException("PQHandle should not be invalid");
                }
            }
            _pq.Init();
        }

        private void DonePriorityQ()
        {
            _pq = null;
        }

        /// <summary>
        /// Delete any degenerate faces with only two edges.  WalkDirtyRegions()
        /// will catch almost all of these, but it won't catch degenerate faces
        /// produced by splice operations on already-processed edges.
        /// The two places this can happen are in FinishLeftRegions(), when
        /// we splice in a "temporary" edge produced by ConnectRightVertex(),
        /// and in CheckForLeftSplice(), where we splice already-processed
        /// edges to ensure that our dictionary invariants are not violated
        /// by numerical errors.
        /// 
        /// In both these cases it is *very* dangerous to delete the offending
        /// edge at the time, since one of the routines further up the stack
        /// will sometimes be keeping a pointer to that edge.
        /// </summary>
        private void RemoveDegenerateFaces()
        {
            MeshUtils.Face f, fNext;
            MeshUtils.Edge e;

            for (f = _mesh._fHead._next; f != _mesh._fHead; f = fNext)
            {
                fNext = f._next;
                e = f._anEdge;
                Debug.Assert(e._Lnext != e);

                if (e._Lnext._Lnext == e)
                {
                    // A face with only two edges
                    Geom.AddWinding(e._Onext, e);
                    _mesh.Delete(e);
                }
            }
        }

        /// <summary>
        /// ComputeInterior computes the planar arrangement specified
        /// by the given contours, and further subdivides this arrangement
        /// into regions.  Each region is marked "inside" if it belongs
        /// to the polygon, according to the rule given by windingRule.
        /// Each interior region is guaranteed to be monotone.
        /// </summary>
        protected void ComputeInterior()
        {
            // Each vertex defines an event for our sweep line. Start by inserting
            // all the vertices in a priority queue. Events are processed in
            // lexicographic order, ie.
            // 
            // e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)
            RemoveDegenerateEdges();
            InitPriorityQ();
            RemoveDegenerateFaces();
            InitEdgeDict();

            MeshUtils.Vertex v, vNext;
            while ((v = _pq.ExtractMin()) != null)
            {
                 while (true)
                 {
                    vNext = _pq.Minimum();
                    if (vNext == null || !Geom.VertEq(vNext, v))
                    {
                        break;
                    }

                    // Merge together all vertices at exactly the same location.
                    // This is more efficient than processing them one at a time,
                    // simplifies the code (see ConnectLeftDegenerate), and is also
                    // important for correct handling of certain degenerate cases.
                    // For example, suppose there are two identical edges A and B
                    // that belong to different contours (so without this code they would
                    // be processed by separate sweep events). Suppose another edge C
                    // crosses A and B from above. When A is processed, we split it
                    // at its intersection point with C. However this also splits C,
                    // so when we insert B we may compute a slightly different
                    // intersection point. This might leave two edges with a small
                    // gap between them. This kind of error is especially obvious
                    // when using boundary extraction (BoundaryOnly).
                    vNext = _pq.ExtractMin();
                    SpliceMergeVertices(v._anEdge, vNext._anEdge);
                }
                SweepEvent(v);
            }

            DoneEdgeDict();
            DonePriorityQ();

            RemoveDegenerateFaces();
            _mesh.Check();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Sweep.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Tess.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9bec9383a2ce0664baaa05ed927186d6
# ASMDEF: ToolBuddy.Curvy.dll
# ---
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) 2011 Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Original Author: Eric Veach, July 1994.
** libtess2: Mikko Mononen, http://code.google.com/p/libtess2/.
** LibTessDotNet: Remi Gillig, https://github.com/speps/LibTessDotNet
*/

using System;
using System.Collections.Generic;
using System.Diagnostics;
using ToolBuddy.Pooling;
using ToolBuddy.Pooling.Collections;
using ToolBuddy.Pooling.Pools;
using Real = System.Single;
namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    public enum WindingRule
    {
        EvenOdd,
        NonZero,
        Positive,
        Negative,
        AbsGeqTwo
    }

    public enum ElementType
    {
        Polygons,
        ConnectedPolygons,
        BoundaryContours
    }

    public enum ContourOrientation
    {
        Original,
        Clockwise,
        CounterClockwise
    }

    public struct ContourVertex
    {
        public Vec3 Position;
        public object Data;

        public override string ToString()
        {
            return string.Format("{0}, {1}", Position, Data);
        }
    }

    public delegate object CombineCallback(Vec3 position, object[] data, Real[] weights);

    public partial class Tess

    {
        private LTMesh _mesh;
        private Vec3 _normal;
        private Vec3 _sUnit;
        private Vec3 _tUnit;

        private Real _bminX, _bminY, _bmaxX, _bmaxY;

        private WindingRule _windingRule;

        private Dict<ActiveRegion> _dict;
        private PriorityQueue<MeshUtils.Vertex> _pq;
        private MeshUtils.Vertex _event;

        private CombineCallback _combineCallback;

        private ContourVertex[] _vertices;

        private int _vertexCount;

        private SubArray<int>? elementsList;
        private int _elementCount;

        public Vec3 Normal { get { return _normal; } set { _normal = value; } }

        public Real SUnitX = 1;
        public Real SUnitY = 0;
        public Real SentinelCoord = 4e30f;

        /// <summary>
        /// If true, will remove empty (zero area) polygons.
        /// </summary>
        public bool NoEmptyPolygons = false;

        /// <summary>
        /// If true, will use pooling to reduce GC (compare performance with/without, can vary wildly).
        /// </summary>
        public bool UsePooling = false;

        public ContourVertex[] Vertices { get { return _vertices; } }
        public int VertexCount { get { return _vertexCount; } }


        /// <summary>
        /// The elements list
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use ElementsArray instead")]
        public int[] Elements
        {
            get { return elementsList?.CopyToArray(ArrayPoolsProvider.GetPool<int>()); }
        }

        /// <summary>
        /// The elements list
        /// </summary>
        /// <remarks>This getter returns a copy of the actual array. For performance reasons, use the equivalent getter returning a <see cref="SubArray{T}"/> instance, which allows you to directly access and modify the underlying array</remarks>
        [Obsolete("Use ElementsArray instead")]
        public IList<int> ElementsList
        {
            get { return Elements; }
        }

        /// <summary>
        /// The elements list
        /// </summary>
        /// <remarks>Setting a new <see cref="SubArray{T}"/> will <see cref="ArrayPool{T}.Free(ToolBuddy.Pooling.Collections.SubArray{T})"/> the current <see cref="SubArray{T}"/>  instance</remarks>
        public SubArray<int>? ElementsArray
        {
            get { return elementsList; }
        }

        public int ElementCount
        {
            get { return _elementCount; }
        }

        public Tess()
        {
            _normal = Vec3.Zero;
            _bminX = _bminY = _bmaxX = _bmaxY = 0;

            _windingRule = WindingRule.EvenOdd;
            _mesh = null;

            _vertices = null;
            _vertexCount = 0;
            elementsList = null;
            _elementCount = 0;
        }

        private void ComputeNormal(ref Vec3 norm)
        {
            var v = _mesh._vHead._next;

            var minVal = new Real[3] { v._coords.X, v._coords.Y, v._coords.Z };
            var minVert = new MeshUtils.Vertex[3] { v, v, v };
            var maxVal = new Real[3] { v._coords.X, v._coords.Y, v._coords.Z };
            var maxVert = new MeshUtils.Vertex[3] { v, v, v };

            for (; v != _mesh._vHead; v = v._next)
            {
                if (v._coords.X < minVal[0]) { minVal[0] = v._coords.X; minVert[0] = v; }
                if (v._coords.Y < minVal[1]) { minVal[1] = v._coords.Y; minVert[1] = v; }
                if (v._coords.Z < minVal[2]) { minVal[2] = v._coords.Z; minVert[2] = v; }
                if (v._coords.X > maxVal[0]) { maxVal[0] = v._coords.X; maxVert[0] = v; }
                if (v._coords.Y > maxVal[1]) { maxVal[1] = v._coords.Y; maxVert[1] = v; }
                if (v._coords.Z > maxVal[2]) { maxVal[2] = v._coords.Z; maxVert[2] = v; }
            }

            // Find two vertices separated by at least 1/sqrt(3) of the maximum
            // distance between any two vertices
            int i = 0;
            if (maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) { i = 1; }
            if (maxVal[2] - minVal[2] > maxVal[i] - minVal[i]) { i = 2; }
            if (minVal[i] >= maxVal[i])
            {
                // All vertices are the same -- normal doesn't matter
                norm = new Vec3 { X = 0, Y = 0, Z = 1 };
                return;
            }

            // Look for a third vertex which forms the triangle with maximum area
            // (Length of normal == twice the triangle area)
            Real maxLen2 = 0, tLen2;
            var v1 = minVert[i];
            var v2 = maxVert[i];
            Vec3 d1, d2, tNorm;
            Vec3.Sub(ref v1._coords, ref v2._coords, out d1);
            for (v = _mesh._vHead._next; v != _mesh._vHead; v = v._next)
            {
                Vec3.Sub(ref v._coords, ref v2._coords, out d2);
                tNorm.X = d1.Y * d2.Z - d1.Z * d2.Y;
                tNorm.Y = d1.Z * d2.X - d1.X * d2.Z;
                tNorm.Z = d1.X * d2.Y - d1.Y * d2.X;
                tLen2 = tNorm.X * tNorm.X + tNorm.Y * tNorm.Y + tNorm.Z * tNorm.Z;
                if (tLen2 > maxLen2)
                {
                    maxLen2 = tLen2;
                    norm = tNorm;
                }
            }

            if (maxLen2 <= 0.0f)
            {
                // All points lie on a single line -- any decent normal will do
                norm = Vec3.Zero;
                i = Vec3.LongAxis(ref d1);
                norm[i] = 1;
            }
        }

        private void CheckOrientation()
        {
            // When we compute the normal automatically, we choose the orientation
            // so that the the sum of the signed areas of all contours is non-negative.
            Real area = 0.0f;
            for (var f = _mesh._fHead._next; f != _mesh._fHead; f = f._next)
            {
                if (f._anEdge._winding <= 0)
                {
                    continue;
                }

                area += MeshUtils.FaceArea(f);
            }

            if (area < 0.0f)
            {
                // Reverse the orientation by flipping all the t-coordinates
                for (var v = _mesh._vHead._next; v != _mesh._vHead; v = v._next)
                {
                    v._t = -v._t;
                }

                Vec3.Neg(ref _tUnit);
            }
        }

        private void ProjectPolygon()
        {
            var norm = _normal;

            bool computedNormal = false;
            if (norm.X == 0.0f && norm.Y == 0.0f && norm.Z == 0.0f)
            {
                ComputeNormal(ref norm);
                _normal = norm;
                computedNormal = true;
            }

            int i = Vec3.LongAxis(ref norm);

            _sUnit[i] = 0;
            _sUnit[(i + 1) % 3] = SUnitX;
            _sUnit[(i + 2) % 3] = SUnitY;

            _tUnit[i] = 0;
            _tUnit[(i + 1) % 3] = norm[i] > 0.0f ? -SUnitY : SUnitY;
            _tUnit[(i + 2) % 3] = norm[i] > 0.0f ? SUnitX : -SUnitX;

            // Project the vertices onto the sweep plane
            for (var v = _mesh._vHead._next; v != _mesh._vHead; v = v._next)
            {
                Vec3.Dot(ref v._coords, ref _sUnit, out v._s);
                Vec3.Dot(ref v._coords, ref _tUnit, out v._t);
            }

            if (computedNormal)
            {
                CheckOrientation();
            }

            // Compute ST bounds.
            bool first = true;
            for (var v = _mesh._vHead._next; v != _mesh._vHead; v = v._next)
            {
                if (first)
                {
                    _bminX = _bmaxX = v._s;
                    _bminY = _bmaxY = v._t;
                    first = false;
                }
                else
                {
                    if (v._s < _bminX) _bminX = v._s;
                    if (v._s > _bmaxX) _bmaxX = v._s;
                    if (v._t < _bminY) _bminY = v._t;
                    if (v._t > _bmaxY) _bmaxY = v._t;
                }
            }
        }

        /// <summary>
        /// TessellateMonoRegion( face ) tessellates a monotone region
        /// (what else would it do??)  The region must consist of a single
        /// loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
        /// case means that any vertical line intersects the interior of the
        /// region in a single interval.  
        /// 
        /// Tessellation consists of adding interior edges (actually pairs of
        /// half-edges), to split the region into non-overlapping triangles.
        /// 
        /// The basic idea is explained in Preparata and Shamos (which I don't
        /// have handy right now), although their implementation is more
        /// complicated than this one.  The are two edge chains, an upper chain
        /// and a lower chain.  We process all vertices from both chains in order,
        /// from right to left.
        /// 
        /// The algorithm ensures that the following invariant holds after each
        /// vertex is processed: the untessellated region consists of two
        /// chains, where one chain (say the upper) is a single edge, and
        /// the other chain is concave.  The left vertex of the single edge
        /// is always to the left of all vertices in the concave chain.
        /// 
        /// Each step consists of adding the rightmost unprocessed vertex to one
        /// of the two chains, and forming a fan of triangles from the rightmost
        /// of two chain endpoints.  Determining whether we can add each triangle
        /// to the fan is a simple orientation test.  By making the fan as large
        /// as possible, we restore the invariant (check it yourself).
        /// </summary>
        private void TessellateMonoRegion(MeshUtils.Face face)
        {
            // All edges are oriented CCW around the boundary of the region.
            // First, find the half-edge whose origin vertex is rightmost.
            // Since the sweep goes from left to right, face->anEdge should
            // be close to the edge we want.
            var up = face._anEdge;
            Debug.Assert(up._Lnext != up && up._Lnext._Lnext != up);

            for (; Geom.VertLeq(up._Dst, up._Org); up = up._Lprev) ;
            for (; Geom.VertLeq(up._Org, up._Dst); up = up._Lnext) ;

            var lo = up._Lprev;

            while (up._Lnext != lo)
            {
                if (Geom.VertLeq(up._Dst, lo._Org))
                {
                    // up.Dst is on the left. It is safe to form triangles from lo.Org.
                    // The EdgeGoesLeft test guarantees progress even when some triangles
                    // are CW, given that the upper and lower chains are truly monotone.
                    while (lo._Lnext != up && (Geom.EdgeGoesLeft(lo._Lnext)
                                               || Geom.EdgeSign(lo._Org, lo._Dst, lo._Lnext._Dst) <= 0.0f))
                    {
                        lo = _mesh.Connect(lo._Lnext, lo)._Sym;
                    }

                    lo = lo._Lprev;
                }
                else
                {
                    // lo.Org is on the left.  We can make CCW triangles from up.Dst.
                    while (lo._Lnext != up && (Geom.EdgeGoesRight(up._Lprev)
                                               || Geom.EdgeSign(up._Dst, up._Org, up._Lprev._Org) >= 0.0f))
                    {
                        up = _mesh.Connect(up, up._Lprev)._Sym;
                    }

                    up = up._Lnext;
                }
            }

            // Now lo.Org == up.Dst == the leftmost vertex.  The remaining region
            // can be tessellated in a fan from this leftmost vertex.
            Debug.Assert(lo._Lnext != up);
            while (lo._Lnext._Lnext != up)
            {
                lo = _mesh.Connect(lo._Lnext, lo)._Sym;
            }
        }

        /// <summary>
        /// TessellateInterior( mesh ) tessellates each region of
        /// the mesh which is marked "inside" the polygon. Each such region
        /// must be monotone.
        /// </summary>
        private void TessellateInterior()
        {
            MeshUtils.Face f, next;
            for (f = _mesh._fHead._next; f != _mesh._fHead; f = next)
            {
                // Make sure we don't try to tessellate the new triangles.
                next = f._next;
                if (f._inside)
                {
                    TessellateMonoRegion(f);
                }
            }
        }

        /// <summary>
        /// DiscardExterior zaps (ie. sets to null) all faces
        /// which are not marked "inside" the polygon.  Since further mesh operations
        /// on NULL faces are not allowed, the main purpose is to clean up the
        /// mesh so that exterior loops are not represented in the data structure.
        /// </summary>
        private void DiscardExterior()
        {
            MeshUtils.Face f, next;

            for (f = _mesh._fHead._next; f != _mesh._fHead; f = next)
            {
                // Since f will be destroyed, save its next pointer.
                next = f._next;
                if( ! f._inside ) {
                    _mesh.ZapFace(f);
                }
            }
        }

        /// <summary>
        /// SetWindingNumber( value, keepOnlyBoundary ) resets the
        /// winding numbers on all edges so that regions marked "inside" the
        /// polygon have a winding number of "value", and regions outside
        /// have a winding number of 0.
        /// 
        /// If keepOnlyBoundary is TRUE, it also deletes all edges which do not
        /// separate an interior region from an exterior one.
        /// </summary>
        private void SetWindingNumber(int value, bool keepOnlyBoundary)
        {
            MeshUtils.Edge e, eNext;

            for (e = _mesh._eHead._next; e != _mesh._eHead; e = eNext)
            {
                eNext = e._next;
                if (e._Rface._inside != e._Lface._inside)
                {

                    /* This is a boundary edge (one side is interior, one is exterior). */
                    e._winding = (e._Lface._inside) ? value : -value;
                }
                else
                {

                    /* Both regions are interior, or both are exterior. */
                    if (!keepOnlyBoundary)
                    {
                        e._winding = 0;
                    }
                    else
                    {
                        _mesh.Delete(e);
                    }
                }
            }

        }

        private int GetNeighbourFace(MeshUtils.Edge edge)
        {
            if (edge._Rface == null)
                return MeshUtils.Undef;
            if (!edge._Rface._inside)
                return MeshUtils.Undef;
            return edge._Rface._n;
        }

        private void OutputPolymesh(ElementType elementType, int polySize)
        {
            MeshUtils.Vertex v;
            MeshUtils.Face f;
            MeshUtils.Edge edge;
            int maxFaceCount = 0;
            int maxVertexCount = 0;
            int faceVerts, i;

            if (polySize < 3)
            {
                polySize = 3;
            }

            // Assume that the input data is triangles now.
            // Try to merge as many polygons as possible
            if (polySize > 3)
            {
                _mesh.MergeConvexFaces(polySize);
            }

            // Mark unused
            for (v = _mesh._vHead._next; v != _mesh._vHead; v = v._next)
                v._n = MeshUtils.Undef;

            // Create unique IDs for all vertices and faces.
            for (f = _mesh._fHead._next; f != _mesh._fHead; f = f._next)
            {
                f._n = MeshUtils.Undef;
                if (!f._inside) continue;

                if (NoEmptyPolygons)
                {
                    var area = MeshUtils.FaceArea(f);
                    if (Math.Abs(area) < Real.Epsilon)
                    {
                        continue;
                    }
                }

                edge = f._anEdge;
                faceVerts = 0;
                do {
                    v = edge._Org;
                    if (v._n == MeshUtils.Undef)
                    {
                        v._n = maxVertexCount;
                        maxVertexCount++;
                    }

                    faceVerts++;
                    edge = edge._Lnext;
                }
                while (edge != f._anEdge);

                Debug.Assert(faceVerts <= polySize);

                f._n = maxFaceCount;
                ++maxFaceCount;
            }

            _elementCount = maxFaceCount;
            if (elementType == ElementType.ConnectedPolygons)
                maxFaceCount *= 2;

            ArrayPool<int> arrayPool = ArrayPoolsProvider.GetPool<Int32>();
            if (elementsList != null)
                arrayPool.Free(elementsList.Value);
            elementsList = arrayPool.Allocate(maxFaceCount * polySize);

            _vertexCount = maxVertexCount;
            _vertices = new ContourVertex[_vertexCount];

            // Output vertices.
            for (v = _mesh._vHead._next; v != _mesh._vHead; v = v._next)
            {
                if (v._n != MeshUtils.Undef)
                {
                    // Store coordinate
                    _vertices[v._n].Position = v._coords;
                    _vertices[v._n].Data = v._data;
                }
            }

            // Output indices.
            int elementIndex = 0;
            for (f = _mesh._fHead._next; f != _mesh._fHead; f = f._next)
            {
                if (!f._inside) continue;

                if (NoEmptyPolygons)
                {
                    var area = MeshUtils.FaceArea(f);
                    if (Math.Abs(area) < Real.Epsilon)
                    {
                        continue;
                    }
                }

                // Store polygon
                edge = f._anEdge;
                faceVerts = 0;
                do {
                    v = edge._Org;
                    elementsList.Value.Array[elementIndex++] = v._n;
                    faceVerts++;
                    edge = edge._Lnext;
                } while (edge != f._anEdge);

                // Fill unused.
                for (i = faceVerts; i < polySize; ++i)
                {
                    elementsList.Value.Array[elementIndex++] = MeshUtils.Undef;
                }

                // Store polygon connectivity
                if (elementType == ElementType.ConnectedPolygons)
                {
                    edge = f._anEdge;
                    do
                    {
                        elementsList.Value.Array[elementIndex++] = GetNeighbourFace(edge);
                        edge = edge._Lnext;
                    } while (edge != f._anEdge);

                    // Fill unused.
                    for (i = faceVerts; i < polySize; ++i)
                    {
                        elementsList.Value.Array[elementIndex++] = MeshUtils.Undef;
                    }
                }
            }
        }

        private void OutputContours()
        {
            MeshUtils.Face f;
            MeshUtils.Edge edge, start;
            int startVert = 0;
            int vertCount = 0;

            _vertexCount = 0;
            _elementCount = 0;

            for (f = _mesh._fHead._next; f != _mesh._fHead; f = f._next)
            {
                if (!f._inside) continue;

                start = edge = f._anEdge;
                do
                {
                    ++_vertexCount;
                    edge = edge._Lnext;
                }
                while (edge != start);

                ++_elementCount;
            }

            ArrayPool<int> arrayPool = ArrayPoolsProvider.GetPool<Int32>();
            if (elementsList != null)
                arrayPool.Free(elementsList.Value);
            elementsList = arrayPool.Allocate(_elementCount * 2);

            _vertices = new ContourVertex[_vertexCount];

            int vertIndex = 0;
            int elementIndex = 0;

            startVert = 0;

            for (f = _mesh._fHead._next; f != _mesh._fHead; f = f._next)
            {
                if (!f._inside) continue;

                vertCount = 0;
                start = edge = f._anEdge;
                do {
                    _vertices[vertIndex].Position = edge._Org._coords;
                    _vertices[vertIndex].Data = edge._Org._data;
                    ++vertIndex;
                    ++vertCount;
                    edge = edge._Lnext;
                } while (edge != start);

                elementsList.Value.Array[elementIndex++] = startVert;
                elementsList.Value.Array[elementIndex++] = vertCount;

                startVert += vertCount;
            }
        }

        private Real SignedArea(ContourVertex[] vertices)
        {
            Real area = 0.0f;

            for (int i = 0; i < vertices.Length; i++)
            {
                var v0 = vertices[i];
                var v1 = vertices[(i + 1) % vertices.Length];

                area += v0.Position.X * v1.Position.Y;
                area -= v0.Position.Y * v1.Position.X;
            }

            return 0.5f * area;
        }

        public void AddContour(ContourVertex[] vertices)
        {
            AddContour(vertices, ContourOrientation.Original);
        }

        public void AddContour(ContourVertex[] vertices, ContourOrientation forceOrientation)
        {
            if (_mesh == null)
            {
                _mesh = new LTMesh();
            }

            bool reverse = false;
            if (forceOrientation != ContourOrientation.Original)
            {
                var area = SignedArea(vertices);
                reverse = (forceOrientation == ContourOrientation.Clockwise && area < 0.0f) || (forceOrientation == ContourOrientation.CounterClockwise && area > 0.0f);
            }

            MeshUtils.Edge e = null;
            for (int i = 0; i < vertices.Length; ++i)
            {
                if (e == null)
                {
                    e = _mesh.MakeEdge();
                    _mesh.Splice(e, e._Sym);
                }
                else
                {
                    // Create a new vertex and edge which immediately follow e
                    // in the ordering around the left face.
                    _mesh.SplitEdge(e);
                    e = e._Lnext;
                }

                int index = reverse ? vertices.Length - 1 - i : i;
                // The new vertex is now e._Org.
                e._Org._coords = vertices[index].Position;
                e._Org._data = vertices[index].Data;

                // The winding of an edge says how the winding number changes as we
                // cross from the edge's right face to its left face.  We add the
                // vertices in such an order that a CCW contour will add +1 to
                // the winding number of the region inside the contour.
                e._winding = 1;
                e._Sym._winding = -1;
            }
        }

        public void Tessellate(WindingRule windingRule, ElementType elementType, int polySize)
        {
            Tessellate(windingRule, elementType, polySize, null);
        }

        public void Tessellate(WindingRule windingRule, ElementType elementType, int polySize, CombineCallback combineCallback)
        {
            _normal = Vec3.Zero;
            _vertices = null;
            elementsList = null;

            _windingRule = windingRule;
            _combineCallback = combineCallback;

            if (_mesh == null)
            {
                return;
            }

            // Determine the polygon normal and project vertices onto the plane
            // of the polygon.
            ProjectPolygon();

            // ComputeInterior computes the planar arrangement specified
            // by the given contours, and further subdivides this arrangement
            // into regions.  Each region is marked "inside" if it belongs
            // to the polygon, according to the rule given by windingRule.
            // Each interior region is guaranteed be monotone.
            ComputeInterior();

            // If the user wants only the boundary contours, we throw away all edges
            // except those which separate the interior from the exterior.
            // Otherwise we tessellate all the regions marked "inside".
            if (elementType == ElementType.BoundaryContours)
            {
                SetWindingNumber(1, true);
            }
            else
            {
                TessellateInterior();
            }

            _mesh.Check();

            if (elementType == ElementType.BoundaryContours)
            {
                OutputContours();
            }
            else
            {
                OutputPolymesh(elementType, polySize);
            }

            if (UsePooling)
            {
                _mesh.Free();
            }

            _mesh = null;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/Tess.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/UnityUtility.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 568ec354b4db48d418238be196862ce5
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections.Generic;
using ToolBuddy.Pooling;
using ToolBuddy.Pooling.Collections;
using UnityEngine;


namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
    public static class LibTessVector3Extension
    {
        public static Vec3 Vec3(this Vector3 v)
        {
            return new Vec3() { X = v.x, Y = v.y, Z = v.z };
        }

        public static ContourVertex ContourVertex(this Vector3 v)
        {
            var r = new ContourVertex();
            r.Position = v.Vec3();
            return r;
        }

    }

    [Obsolete("No more used in Curvy. Will get removed. Copy it if you still need it")]
    public static class LibTessV3Extension
    {
        public static Vector3 Vector3(this Vec3 v)
        {
            return new Vector3(v.X, v.Y, v.Z);
        }
    }




    public static class UnityLibTessUtility
    {
        [Obsolete("No more used in Curvy. Will get removed. Copy it if you still need it")]
        public static ContourVertex[] ToContourVertex(Vector3[] v, bool zeroZ = false)
        {
            var res = new ContourVertex[v.Length];
            for (int i = 0; i < v.Length; i++)
            {
                res[i].Position.X = v[i].x;
                res[i].Position.Y = v[i].y;
                res[i].Position.Z = (zeroZ) ? 0 : v[i].z;
            }
            return res;
        }

        public static ContourVertex[] ToContourVertex(SubArray<Vector3> v, bool zeroZ = false)
        {
            int count = v.Count;
            Vector3[] vArray = v.Array;
            ContourVertex[] res = new ContourVertex[count];
            for (int i = 0; i < count; i++)
            {
                res[i].Position.X = vArray[i].x;
                res[i].Position.Y = vArray[i].y;
                res[i].Position.Z = (zeroZ) ? 0 : vArray[i].z;
            }
            return res;
        }

        public static void FromContourVertex(ContourVertex[] v, SubArray<Vector3> output)
        {
            var count = output.Count;
            var array = output.Array;

            for (int i = 0; i < count; i++)
            {
                array[i].x = v[i].Position.X;
                array[i].y = v[i].Position.Y;
                array[i].z = v[i].Position.Z;
            }
        }

        public static SubArray<Vector3> ContourVerticesToPositions(ContourVertex[] v)
        {
            var result = ArrayPoolsProvider.GetPool<Vector3>().Allocate(v.Length);
            var res = result.Array;
            for (int i = 0; i < result.Count; i++)
            {
                res[i].x = v[i].Position.X;
                res[i].y = v[i].Position.Y;
                res[i].z = v[i].Position.Z;
            }

            return result;
        }

        [Obsolete("No more used in Curvy. Will get removed. Copy it if you still need it")]
        public static void SetFromContourVertex(ref Vector3[] v3Array, ref ContourVertex[] cvArray)
        {
            System.Array.Resize(ref v3Array, cvArray.Length);
            for (int i = 0; i < v3Array.Length; i++)
            {
                v3Array[i].x = cvArray[i].Position.X;
                v3Array[i].y = cvArray[i].Position.Y;
                v3Array[i].z = cvArray[i].Position.Z;
            }
        }

        [Obsolete("No more used in Curvy. Will get removed. Copy it if you still need it")]
        public static void SetToContourVertex(ref ContourVertex[] cvArray, ref Vector3[] v3Array)
        {
            System.Array.Resize(ref cvArray, v3Array.Length);
            for (int i = 0; i < cvArray.Length; i++)
            {
                cvArray[i].Position.X = v3Array[i].x;
                cvArray[i].Position.Y = v3Array[i].y;
                cvArray[i].Position.Z = v3Array[i].z;
            }
        }

    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/LibTessDotNet/UnityUtility.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/Matrix2D.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 600ae451aa325bb479e48e4f91cf17e1
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using UnityEngine;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    /// <summary>A 2x3 transformation matrix used for 2D operations.</summary>
    public struct Matrix2D
    {
        // memory layout:
        //
        //                row no (=vertical)
        //               |  0   1   2
        //            ---+------------
        //            0  | m00 m10  0
        // column no  1  | m01 m11  0
        // (=horiz)   2  | m02 m12  1

        /// <summary>The matrix member at (0,0)</summary>
        public float m00;
        /// <summary>The matrix member at (1,0)</summary>
        public float m10;

        /// <summary>The matrix member at (0,1)</summary>
        public float m01;
        /// <summary>The matrix member at (1,1)</summary>
        public float m11;

        /// <summary>The matrix member at (0,2)</summary>
        public float m02;
        /// <summary>The matrix member at (1,2)</summary>
        public float m12;

        /// <summary>Initializes a Matrix2D with column vectors</summary>
        /// <param name="column0">The first column</param>
        /// <param name="column1">The second column</param>
        /// <param name="column2">The third column</param>
        public Matrix2D(Vector2 column0, Vector2 column1, Vector2 column2)
        {
            this.m00 = column0.x; this.m01 = column1.x; this.m02 = column2.x;
            this.m10 = column0.y; this.m11 = column1.y; this.m12 = column2.y;
        }

        /// <summary>Access element at [row, column].</summary>
        /// <returns>The value at [row, column]</returns>
        public float this[int row, int column]
        {
            get
            {
                return this[row + column * 2];
            }

            set
            {
                this[row + column * 2] = value;
            }
        }

        /// <summary>Access element at sequential index (0..5 inclusive).</summary>
        /// <returns>The value at [index]</returns>
        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return m00;
                    case 1: return m10;
                    case 2: return m01;
                    case 3: return m11;
                    case 4: return m02;
                    case 5: return m12;
                    default:
                        throw new IndexOutOfRangeException("Invalid matrix index!");
                }
            }

            set
            {
                switch (index)
                {
                    case 0: m00 = value; break;
                    case 1: m10 = value; break;
                    case 2: m01 = value; break;
                    case 3: m11 = value; break;
                    case 4: m02 = value; break;
                    case 5: m12 = value; break;

                    default:
                        throw new IndexOutOfRangeException("Invalid matrix index!");
                }
            }
        }

        /// <summary>Gets a hashcode of the matrix.</summary>
        /// <remarks>Used to allow Matrix3x3s to be used as keys in hash tables.</remarks>
        /// <returns>The hashcode of the matrix</returns>
        public override int GetHashCode()
        {
            return GetColumn(0).GetHashCode() ^ (GetColumn(1).GetHashCode() << 2) ^ (GetColumn(2).GetHashCode() >> 2);
        }

        /// <summary>Checks if two matrices are equal.</summary>
        /// <param name="other">The other matrix to compare with</param>
        /// <remarks>Used to allow Matrix3x3s to be used as keys in hash tables.</remarks>
        /// <returns>True when the matrix is equal to "other"</returns>
        public override bool Equals(object other)
        {
            if (!(other is Matrix2D)) return false;

            Matrix2D rhs = (Matrix2D)other;
            return GetColumn(0).Equals(rhs.GetColumn(0))
                && GetColumn(1).Equals(rhs.GetColumn(1))
                && GetColumn(2).Equals(rhs.GetColumn(2));
        }

        /// <summary>Multiplies two matrices.</summary>
        /// <param name="lhs">The left hand side matrix of the operation</param>
        /// <param name="rhs">The right hand side matrix of the operation</param>
        /// <returns>The multiplied matrix</returns>
        public static Matrix2D operator*(Matrix2D lhs, Matrix2D rhs)
        {
            Matrix2D res;
            res.m00 = lhs.m00 * rhs.m00 + lhs.m01 * rhs.m10;
            res.m01 = lhs.m00 * rhs.m01 + lhs.m01 * rhs.m11;
            res.m02 = lhs.m00 * rhs.m02 + lhs.m01 * rhs.m12 + lhs.m02;

            res.m10 = lhs.m10 * rhs.m00 + lhs.m11 * rhs.m10;
            res.m11 = lhs.m10 * rhs.m01 + lhs.m11 * rhs.m11;
            res.m12 = lhs.m10 * rhs.m02 + lhs.m11 * rhs.m12 + lhs.m12;

            return res;
        }

        /// <summary>Transforms a Vector2 by a matrix.</summary>
        /// <param name="lhs">The left hand side matrix of the operation</param>
        /// <param name="vector">The vector the matrix will be multiplied with</param>
        /// <returns>The transformed vector</returns>
        public static Vector2 operator*(Matrix2D lhs, Vector2 vector)
        {
            Vector2 res;
            res.x = lhs.m00 * vector.x + lhs.m01 * vector.y + lhs.m02;
            res.y = lhs.m10 * vector.x + lhs.m11 * vector.y + lhs.m12;
            return res;
        }

        /// <summary>Checks if two matrices are equal.</summary>
        /// <param name="lhs">The left hand side matrix of the comparison</param>
        /// <param name="rhs">The right hand side matrix of the comparison</param>
        /// <returns>True if "lhs" and "rhs" are equal, or false otherwise.</returns>
        public static bool operator==(Matrix2D lhs, Matrix2D rhs)
        {
            // Returns false in the presence of NaN values.
            return lhs.GetColumn(0) == rhs.GetColumn(0)
                && lhs.GetColumn(1) == rhs.GetColumn(1)
                && lhs.GetColumn(2) == rhs.GetColumn(2);
        }

        /// <summary>Checks if two matrices are not equal.</summary>
        /// <param name="lhs">The left hand side matrix of the comparison</param>
        /// <param name="rhs">The right hand side matrix of the comparison</param>
        /// <returns>True if "lhs" and "rhs" not are equal, or false otherwise.</returns>
        public static bool operator!=(Matrix2D lhs, Matrix2D rhs)
        {
            // Returns true in the presence of NaN values.
            return !(lhs == rhs);
        }

        /// <summary>Gets a column of the matrix.</summary>
        /// <param name="index">The column index, between 0 and 2 inclusively</param>
        /// <returns>The column at "index"</returns>
        public Vector2 GetColumn(int index)
        {
            switch (index)
            {
                case 0: return new Vector2(m00, m10);
                case 1: return new Vector2(m01, m11);
                case 2: return new Vector2(m02, m12);
                default:
                    throw new IndexOutOfRangeException("Invalid column index!");
            }
        }

        /// <summary>Gets a row of the matrix.</summary>
        /// <param name="index">The row index, between 0 and 1 inclusively</param>
        /// <returns>The row at "index"</returns>
        public Vector3 GetRow(int index)
        {
            switch (index)
            {
                case 0: return new Vector3(m00, m01, m02);
                case 1: return new Vector3(m10, m11, m12);
                default:
                    throw new IndexOutOfRangeException("Invalid row index!");
            }
        }

        /// <summary>Sets a column of the matrix.</summary>
        /// <param name="index">The column index, between 0 and 2 inclusively</param>
        /// <param name="column">The column</param>
        public void SetColumn(int index, Vector2 column)
        {
            this[0, index] = column.x;
            this[1, index] = column.y;
        }

        /// <summary>Sets a row of the matrix.</summary>
        /// <param name="index">The column index, between 0 and 1 inclusively</param>
        /// <param name="row">The row</param>
        public void SetRow(int index, Vector3 row)
        {
            this[index, 0] = row.x;
            this[index, 1] = row.y;
            this[index, 2] = row.z;
        }

        /// <summary>Transforms a position by this matrix (effectively by 2x3).</summary>
        /// <param name="point">The point to multiply with this matrix</param>
        /// <returns>The multiplied point</returns>
        public Vector2 MultiplyPoint(Vector2 point)
        {
            Vector2 res;
            res.x = this.m00 * point.x + this.m01 * point.y + this.m02;
            res.y = this.m10 * point.x + this.m11 * point.y + this.m12;
            return res;
        }

        /// <summary>Transforms a direction by this matrix.</summary>
        /// <param name="vector">The direction to multiply with this matrix</param>
        /// <returns>The multiplied direction</returns>
        public Vector2 MultiplyVector(Vector2 vector)
        {
            Vector2 res;
            res.x = this.m00 * vector.x + this.m01 * vector.y;
            res.y = this.m10 * vector.x + this.m11 * vector.y;
            return res;
        }

        /// <summary>Computes the inverse of the matrix.</summary>
        /// <returns>The inverse matrix</returns>
        public Matrix2D Inverse()
        {
            Matrix2D invMat = new Matrix2D();

            float det = this[0, 0] * this[1, 1] - this[0, 1] * this[1, 0];
            if (Mathf.Approximately(0.0f, det))
                return zero;

            float invDet = 1.0F / det;

            invMat[0, 0] = this[1, 1] * invDet;
            invMat[0, 1] = -this[0, 1] * invDet;
            invMat[1, 0] = -this[1, 0] * invDet;
            invMat[1, 1] = this[0, 0] * invDet;

            // Do the translation part
            invMat[0, 2] = -(this[0, 2] * invMat[0, 0] + this[1, 2] * invMat[0, 1]);
            invMat[1, 2] = -(this[0, 2] * invMat[1, 0] + this[1, 2] * invMat[1, 1]);

            return invMat;
        }

        /// <summary>Creates a scaling matrix.</summary>
        /// <param name="vector">The scaling vector</param>
        /// <returns>The scaling matrix</returns>
        public static Matrix2D Scale(Vector2 vector)
        {
            Matrix2D m;
            m.m00 = vector.x; m.m01 = 0F; m.m02 = 0F;
            m.m10 = 0F; m.m11 = vector.y; m.m12 = 0F;
            return m;
        }

        /// <summary>Creates a translation matrix.</summary>
        /// <param name="vector">The translation vector</param>
        /// <returns>The translation matrix</returns>
        public static Matrix2D Translate(Vector2 vector)
        {
            Matrix2D m;
            m.m00 = 1F; m.m01 = 0F; m.m02 = vector.x;
            m.m10 = 0F; m.m11 = 1F; m.m12 = vector.y;
            return m;
        }

        /// <summary>Creates a right-hand side rotation matrix.</summary>
        /// <param name="angleRadians">The rotation angle, in radians</param>
        /// <returns>The rotation matrix</returns>
        public static Matrix2D RotateRH(float angleRadians)
        {
            return RotateLH(-angleRadians);
        }

        /// <summary>Creates a left-hand side rotation matrix.</summary>
        /// <param name="angleRadians">The rotation angle, in radians</param>
        /// <returns>The rotation matrix</returns>
        public static Matrix2D RotateLH(float angleRadians)
        {
            // No SinCos? I hope the compiler optimizes this
            float s = Mathf.Sin(angleRadians);
            float c = Mathf.Cos(angleRadians);

            Matrix2D m;
            m.m00 = c; m.m10 = -s;
            m.m01 = s; m.m11 = c;
            m.m02 = 0.0F; m.m12 = 0.0F;
            return m;
        }

        /// <summary>Creates a skew matrix on X.</summary>
        /// <param name="angleRadians">The skew angle, in radians</param>
        /// <returns>The skew matrix</returns>        
        public static Matrix2D SkewX(float angleRadians)
        {
            Matrix2D m;
            m.m00 = 1.0f; m.m01 = Mathf.Tan(angleRadians); m.m02 = 0F;
            m.m10 = 0F; m.m11 = 1.0f; m.m12 = 0F;
            return m;
        }

        /// <summary>Creates a skew matrix on U.</summary>
        /// <param name="angleRadians">The skew angle, in radians</param>
        /// <returns>The skew matrix</returns>        
        public static Matrix2D SkewY(float angleRadians)
        {
            Matrix2D m;
            m.m00 = 1.0f; m.m01 = 0F; m.m02 = 0F;
            m.m10 = Mathf.Tan(angleRadians); m.m11 = 1.0f; m.m12 = 0F;
            return m;
        }

        static readonly Matrix2D zeroMatrix = new Matrix2D(new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0));

        /// <summary>Returns a matrix with all elements set to zero (read-only).</summary>
        /// <returns>The zero matrix</returns>
        public static Matrix2D zero { get { return zeroMatrix; } }

        static readonly Matrix2D identityMatrix = new Matrix2D(new Vector2(1, 0), new Vector2(0, 1), new Vector2(0, 0));

        /// <summary>Returns the identity matrix (read-only).</summary>
        /// <returns>The identity matrix</returns>
        public static Matrix2D identity { get { return identityMatrix; } }

        /// <summary>Returns a string representation of the matrix.</summary>
        /// <returns>The matrix string representation</returns>
        public override string ToString()
        {
            return string.Format("{0:F5}\t{1:F5}\t{2:F5}\n{3:F5}\t{4:F5}\t{5:F5}\n", m00, m01, m02, m10, m11, m12);
        }

        /// <summary>Returns a string representation of the matrix using a format.</summary>
        /// <param name="format">The format to be used for the matrix components</param>
        /// <returns>The matrix string representation</returns>
        public string ToString(string format)
        {
            return string.Format("{0}\t{1}\t{2}\n{3}\t{4}\t{5}\n",
                m00.ToString(format), m01.ToString(format), m02.ToString(format),
                m10.ToString(format), m11.ToString(format), m12.ToString(format));
        }
    }
} //namespace
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/Matrix2D.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/SVGParser.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: aa2162f8539d856468fef95fc49e02e8
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.IO;
using System.Collections.Generic;
using System.Globalization;
using System.Xml;
using System.Linq;
using UnityEngine;
using UnityEngine.Networking;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    /// <summary>An enum describing the viewport options to use when importing the SVG document.</summary>
    public enum ViewportOptions
    {
        /// <summary>Don't preserve the viewport defined in the SVG document.</summary>
        DontPreserve,

        /// <summary>Preserves the viewport defined in the SVG document.</summary>
        PreserveViewport,

        /// <summary>Applies the root view-box defined in the SVG document (if any).</summary>
        /// <remarks>
        /// This option will rescale the SVG asset to a unit size if a view-box is defined in the SVG document.
        /// If no view-box is defined, this option will have the same behavior as `DontPreserve`.
        /// It has limited use and is only available for legacy reasons.
        /// </remarks>
        OnlyApplyRootViewBox
    }

    /// <summary>Reads an SVG document and builds a vector scene.</summary>
    public class SVGParser
    {
        /// <summary>A structure containing the SVG scene data.</summary>
        public struct SceneInfo
        {
            internal SceneInfo(Scene scene, Rect sceneViewport, Dictionary<SceneNode, float> nodeOpacities, Dictionary<string, SceneNode> nodeIDs)
            {
                Scene = scene;
                SceneViewport = sceneViewport;
                NodeOpacity = nodeOpacities;
                NodeIDs = nodeIDs;
            }
        
            /// <summary>The vector scene.</summary>
            public Scene Scene { get; }

            /// <summary>The position and size of the SVG document</summary>
            public Rect SceneViewport { get; }

            /// <summary>A dictionary containing the opacity of the scene nodes.</summary>
            public Dictionary<SceneNode, float> NodeOpacity { get; }

            /// <summary>A dictionary containing the scene node for a given ID</summary>
            public Dictionary<string, SceneNode> NodeIDs { get; }
        }

        /// <summary>Kicks off an SVG file import.</summary>
        /// <param name="textReader">The reader object containing the SVG file data</param>
        /// <param name="dpi">The DPI of the SVG file, or 0 to use the device's DPI</param>
        /// <param name="pixelsPerUnit">How many SVG units fit in a Unity unit</param>
        /// <param name="windowWidth">The default with of the viewport, may be 0</param>
        /// <param name="windowHeight">The default height of the viewport, may be 0</param>
        /// <param name="clipViewport">Whether the vector scene should be clipped by the SVG document's viewport</param>
        /// <returns>A SceneInfo object containing the scene data</returns>
        public static SceneInfo ImportSVG(TextReader textReader, float dpi = 0.0f, float pixelsPerUnit = 1.0f, int windowWidth = 0, int windowHeight = 0, bool clipViewport = false)
        {
            var viewportOptions = clipViewport ? ViewportOptions.PreserveViewport : ViewportOptions.DontPreserve;
            return ImportSVG(textReader, viewportOptions, dpi, pixelsPerUnit, windowWidth, windowHeight);
        }

        /// <summary>Kicks off an SVG file import.</summary>
        /// <param name="textReader">The reader object containing the SVG file data</param>
        /// <param name="viewportOptions">The viewport options to use</param>
        /// <param name="dpi">The DPI of the SVG file, or 0 to use the device's DPI</param>
        /// <param name="pixelsPerUnit">How many SVG units fit in a Unity unit</param>
        /// <param name="windowWidth">The default with of the viewport, may be 0</param>
        /// <param name="windowHeight">The default height of the viewport, may be 0</param>
        /// <returns>A SceneInfo object containing the scene data</returns>
        public static SceneInfo ImportSVG(TextReader textReader, ViewportOptions viewportOptions, float dpi = 0.0f, float pixelsPerUnit = 1.0f, int windowWidth = 0, int windowHeight = 0)
        {
            var scene = new Scene();
            var settings = new XmlReaderSettings();
            settings.IgnoreComments = true;
            settings.IgnoreProcessingInstructions = true;
            settings.IgnoreWhitespace = true;

            // Validation and resolving can reach through HTTP to fetch and validate against schemas/DTDs, which could take ages
#if (NET_STANDARD_2_0 || NET_4_6)
            settings.DtdProcessing = System.Xml.DtdProcessing.Ignore;
#else
            settings.ProhibitDtd = false;
#endif
            settings.ValidationFlags = System.Xml.Schema.XmlSchemaValidationFlags.None;
            settings.ValidationType = ValidationType.None;
            settings.XmlResolver = null;

            if (dpi == 0.0f)
                dpi = Screen.dpi;

            Dictionary<SceneNode, float> nodeOpacities;
            Dictionary<string, SceneNode> nodeIDs;

            SVGDocument doc;
            using (var reader = XmlReader.Create(textReader, settings))
            {
                bool applyRootViewBox =
                    (viewportOptions == ViewportOptions.PreserveViewport) ||
                    (viewportOptions == ViewportOptions.OnlyApplyRootViewBox);
                doc = new SVGDocument(reader, dpi, scene, windowWidth, windowHeight, applyRootViewBox);
                doc.Import();
                nodeOpacities = doc.NodeOpacities;
                nodeIDs = doc.NodeIDs;
            }

            float scale = 1.0f / pixelsPerUnit;
            if ((scale != 1.0f) && (scene != null) && (scene.Root != null))
                scene.Root.Transform = scene.Root.Transform * Matrix2D.Scale(new Vector2(scale, scale));

            if ((viewportOptions == ViewportOptions.PreserveViewport) && (scene != null) && (scene.Root != null))
            {
                // Only add clipper if the scene isn't entirely contained in the viewport
                var sceneBounds = VectorUtils.SceneNodeBounds(scene.Root);
                if (!doc.sceneViewport.Contains(sceneBounds.min) || !doc.sceneViewport.Contains(sceneBounds.max))
                {
                    var rectClip = new Shape();
                    VectorUtils.MakeRectangleShape(rectClip, doc.sceneViewport);

                    // We cannot add the clipper directly on scene.Root since it may have a viewbox transform applied.
                    // The simplest is to replace the root node with the new "clipped" one, then the clipping
                    // rectangle can stay in the viewport space (no need to take the viewbox transform into account).
                    scene.Root = new SceneNode()
                    {
                        Children = new List<SceneNode> { scene.Root },
                        Clipper = new SceneNode() { Shapes = new List<Shape>() { rectClip } }
                    };
                }
            }
            
            return new SceneInfo(scene, doc.sceneViewport, nodeOpacities, nodeIDs);
        }
    }

    internal class XmlReaderIterator
    {
        internal class Node
        {
            public Node(XmlReader reader) { this.reader = reader; name = reader.Name; depth = reader.Depth; }
            public string Name { get { return name; } }
            public string this[string attrib] { get { return reader.GetAttribute(attrib); } }
            public SVGPropertySheet GetAttributes()
            {
                var atts = new SVGPropertySheet();
                for (int i = 0; i < reader.AttributeCount; ++i)
                {
                    reader.MoveToAttribute(i);
                    atts[reader.Name] = reader.Value;
                }
                reader.MoveToElement();
                return atts;
            }
            public SVGFormatException GetException(string message) { return new SVGFormatException(reader, message); }
            public SVGFormatException GetUnsupportedAttribValException(string attrib)
            {
                return new SVGFormatException(reader, "Value '" + this[attrib] + "' is invalid for attribute '" + attrib + "'");
            }

            public int Depth { get { return depth; } }
            XmlReader reader;
            int depth;
            string name;
        }

        public XmlReaderIterator(XmlReader reader) { this.reader = reader; }
        public bool GoToRoot(string tagName) { return reader.ReadToFollowing(tagName) && reader.Depth == 0; }
        public Node VisitCurrent() { currentElementVisited = true; return new Node(reader); }
        public bool IsEmptyElement() { return reader.IsEmptyElement; }

        public bool GoToNextChild(Node node)
        {
            if (!currentElementVisited)
                return reader.Depth == node.Depth + 1;

            reader.Read();
            while ((reader.NodeType != XmlNodeType.None) && (reader.NodeType != XmlNodeType.Element))
                reader.Read();
            if (reader.NodeType != XmlNodeType.Element)
                return false;

            currentElementVisited = false;
            return reader.Depth == node.Depth + 1;
        }

        public void SkipCurrentChildTree(Node node)
        {
            while (GoToNextChild(node))
                SkipCurrentChildTree(VisitCurrent());
        }

        public string ReadTextWithinElement()
        {
            if (reader.IsEmptyElement)
                return "";
            
            var text = "";
            while (reader.Read() && reader.NodeType != XmlNodeType.EndElement)
                text += reader.Value;

            return text;
        }

        XmlReader reader;
        bool currentElementVisited;
    }

    internal class SVGFormatException : Exception
    {
        public SVGFormatException() {}
        public SVGFormatException(string message) : base(ComposeMessage(null, message)) {}
        public SVGFormatException(XmlReader reader, string message) : base(ComposeMessage(reader, message)) {}

        public static SVGFormatException StackError { get { return new SVGFormatException("Vector scene construction mismatch"); } }

        static string ComposeMessage(XmlReader reader, string message)
        {
            IXmlLineInfo li = reader as IXmlLineInfo;
            if (li != null)
                return "SVG Error (line " + li.LineNumber + ", character " + li.LinePosition + "): " + message;
            return "SVG Error: " + message;
        }
    }

    internal class SVGDictionary : Dictionary<string, object> {}
    internal class SVGPostponedFills : Dictionary<IFill, string> { }

    internal class SVGDocument
    {
        public SVGDocument(XmlReader docReader, float dpi, Scene scene, int windowWidth, int windowHeight, bool applyRootViewBox)
        {
            allElems = new ElemHandler[]
            { circle, defs, ellipse, g, image, line, linearGradient, path, polygon, polyline, radialGradient, clipPath, pattern, mask, rect, symbol, use, style };

            // These elements excluded below should not be immediatelly part of the hierarchy and can only be referenced
            elemsToAddToHierarchy = new HashSet<ElemHandler>(new ElemHandler[]
                    { circle, /*defs,*/ ellipse, g, image, line, path, polygon, polyline, rect, /*symbol,*/ svg, use });

            this.docReader = new XmlReaderIterator(docReader);
            this.scene = scene;
            this.dpiScale = dpi / 90.0f; // SVG specs assume 90DPI but this machine might use something else
            this.windowWidth = windowWidth;
            this.windowHeight = windowHeight;
            this.applyRootViewBox = applyRootViewBox;
            this.svgObjects[StockBlackNonZeroFillName] = new SolidFill() { Color = new Color(0, 0, 0), Mode = FillMode.NonZero };
            this.svgObjects[StockBlackOddEvenFillName] = new SolidFill() { Color = new Color(0, 0, 0), Mode = FillMode.OddEven };
        }

        public void Import()
        {
            if (scene == null) throw new ArgumentNullException();
            if (!docReader.GoToRoot("svg"))
                throw new SVGFormatException("Document doesn't have 'svg' root");

            currentContainerSize.Push(new Vector2(windowWidth, windowHeight));

            svg();

            currentContainerSize.Pop();
            if (currentContainerSize.Count > 0)
                throw SVGFormatException.StackError;

            PostProcess(scene.Root);
            RemoveInvisibleNodes();
        }

        public Dictionary<SceneNode, float> NodeOpacities { get { return nodeOpacity; } }
        public Dictionary<string, SceneNode> NodeIDs { get { return nodeIDs; } }

        internal const float SVGLengthFactor = 1.41421356f; // Used when calculating relative lengths. See http://www.w3.org/TR/SVG/coords.html#Units
        static internal string StockBlackNonZeroFillName { get { return "unity_internal_black_nz"; } }
        static internal string StockBlackOddEvenFillName { get { return "unity_internal_black_oe"; } }

        void ParseChildren(XmlReaderIterator.Node node, string nodeName)
        {
            var sceneNode = currentSceneNode.Peek();

            var supportedChildren = subTags[nodeName];
            while (docReader.GoToNextChild(node))
            {
                var child = docReader.VisitCurrent();

                ElemHandler handler;
                if (!supportedChildren.TryGetValue(child.Name, out handler))
                {
                    System.Diagnostics.Debug.WriteLine("Skipping over unsupported child (" + child.Name + ") of a (" + node.Name + ")");
                    docReader.SkipCurrentChildTree(child);
                    continue;
                }

                bool addToSceneHierarchy = elemsToAddToHierarchy.Contains(handler);
                SceneNode childVectorNode = null;
                if (addToSceneHierarchy)
                {
                    if (sceneNode.Children == null)
                        sceneNode.Children = new List<SceneNode>();
                    childVectorNode = new SceneNode();
                    nodeGlobalSceneState[childVectorNode] = new NodeGlobalSceneState() { ContainerSize = currentContainerSize.Peek() };
                    sceneNode.Children.Add(childVectorNode);
                    currentSceneNode.Push(childVectorNode);
                }

                styles.PushNode(child);

                if (childVectorNode != null)
                {
                    styles.SaveLayerForSceneNode(childVectorNode);
                    if (styles.Evaluate("display") == "none")
                        invisibleNodes.Add(new NodeWithParent() { node = childVectorNode, parent = sceneNode });
                }

                handler();
                ParseChildren(child, child.Name); // Recurse

                styles.PopNode();

                if (addToSceneHierarchy && currentSceneNode.Pop() != childVectorNode)
                    throw SVGFormatException.StackError;
            }
        }

        #region Tag handling
        void circle()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            var fill = SVGAttribParser.ParseFill(node, svgObjects, postponedFills, styles);
            PathCorner strokeCorner;
            PathEnding strokeEnding;
            var stroke = ParseStrokeAttributeSet(node, out strokeCorner, out strokeEnding);

            float cx = AttribLengthVal(node, "cx", 0.0f, DimType.Width);
            float cy = AttribLengthVal(node, "cy", 0.0f, DimType.Height);
            float r = AttribLengthVal(node, "r", 0.0f, DimType.Length);

            var circle = new Shape();
            VectorUtils.MakeCircleShape(circle, new Vector2(cx, cy), r);
            circle.PathProps = new PathProperties() { Stroke = stroke, Head = strokeEnding, Tail = strokeEnding, Corners = strokeCorner };
            circle.Fill = fill;

            sceneNode.Shapes = new List<Shape>(1);
            sceneNode.Shapes.Add(circle);

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void defs()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = new SceneNode(); // A new scene node instead of one precreated for us
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, allElems);

            currentSceneNode.Push(sceneNode);
            ParseChildren(node, node.Name);
            if (currentSceneNode.Pop() != sceneNode)
                throw SVGFormatException.StackError;
        }

        void ellipse()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            var fill = SVGAttribParser.ParseFill(node, svgObjects, postponedFills, styles);
            PathCorner strokeCorner;
            PathEnding strokeEnding;
            var stroke = ParseStrokeAttributeSet(node, out strokeCorner, out strokeEnding);

            float cx = AttribLengthVal(node, "cx", 0.0f, DimType.Width);
            float cy = AttribLengthVal(node, "cy", 0.0f, DimType.Height);
            float rx = AttribLengthVal(node, "rx", 0.0f, DimType.Length);
            float ry = AttribLengthVal(node, "ry", 0.0f, DimType.Length);

            var ellipse = new Shape();
            VectorUtils.MakeEllipseShape(ellipse, new Vector2(cx, cy), rx, ry);
            ellipse.PathProps = new PathProperties() { Stroke = stroke, Corners = strokeCorner, Head = strokeEnding, Tail = strokeEnding };
            ellipse.Fill = fill;

            sceneNode.Shapes = new List<Shape>(1);
            sceneNode.Shapes.Add(ellipse);

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void g()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, allElems);
        }

        void image()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            // Try to get the referenced image first, if we fail, we just ignore the whole thing
            var url = node["xlink:href"];
            if (url != null)
            {
                var textureFill = new TextureFill();
                textureFill.Mode = FillMode.NonZero;
                textureFill.Addressing = AddressMode.Clamp;

                var lowercaseURL = url.ToLower();
                if (lowercaseURL.StartsWith("data:"))
                {
                    textureFill.Texture = DecodeTextureData(url);
                }
                else
                {
                    if (!lowercaseURL.Contains("://"))
                    {
                        #if UNITY_EDITOR
                        textureFill.Texture = UnityEditor.AssetDatabase.LoadAssetAtPath<Texture2D>("Assets/" + url);
                        #endif
                    }
                    else if (lowercaseURL.StartsWith("http://") || lowercaseURL.StartsWith("https://"))
                    {
                        #pragma warning disable 618
                        // WWW is obsolete (replaced with UnityWebRequest), but this is the class that works best
                        // with editor code. We will continue to use WWW until UnityWebRequest works better in an editor
                        // environment.
                        using (WWW www = new WWW(url))
                        {
                            while (www.keepWaiting)
                                System.Threading.Thread.Sleep(10); // Progress bar please...
                            textureFill.Texture = www.texture;
                        }
                        #pragma warning restore 618
                    }
                    else
                    {
                        Debug.LogWarning("Unsupported URL scheme for <image> (only http/https is supported): " + url);
                    }
                }

                if (textureFill.Texture != null)
                {
                    // Fills and strokes don't seem to apply to image despite what the specs say
                    // All browsers and editing tools seem to ignore them, so we'll just do as well
                    ParseID(node, sceneNode);
                    ParseOpacity(sceneNode);
                    sceneNode.Transform = SVGAttribParser.ParseTransform(node);

                    var viewPort = ParseViewport(node, sceneNode, currentContainerSize.Peek());
                    sceneNode.Transform = sceneNode.Transform * Matrix2D.Translate(viewPort.position);
                    var viewBoxInfo = new ViewBoxInfo();
                    viewBoxInfo.ViewBox = new Rect(0, 0, textureFill.Texture.width, textureFill.Texture.height);
                    ParseViewBoxAspectRatio(node, ref viewBoxInfo);
                    ApplyViewBox(sceneNode, viewBoxInfo, viewPort);

                    var rect = new Shape();
                    VectorUtils.MakeRectangleShape(rect, new Rect(0, 0, textureFill.Texture.width, textureFill.Texture.height));
                    rect.Fill = textureFill;
                    sceneNode.Shapes = new List<Shape>(1);
                    sceneNode.Shapes.Add(rect);

                    ParseClipAndMask(node, sceneNode);
                }
            }

            // Resolve any previous node that was referencing this image
            string id = node["id"];
            if (!string.IsNullOrEmpty(id))
            {
                List<NodeReferenceData> refList;
                if (postponedSymbolData.TryGetValue(id, out refList))
                {
                    foreach (var refData in refList)
                        ResolveReferencedNode(sceneNode, refData, true);
                }
            }

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void line()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            PathCorner strokeCorner;
            PathEnding strokeEnding;
            var stroke = ParseStrokeAttributeSet(node, out strokeCorner, out strokeEnding);

            float x1 = AttribLengthVal(node, "x1", 0.0f, DimType.Width);
            float y1 = AttribLengthVal(node, "y1", 0.0f, DimType.Height);
            float x2 = AttribLengthVal(node, "x2", 0.0f, DimType.Width);
            float y2 = AttribLengthVal(node, "y2", 0.0f, DimType.Height);

            var path = new Shape();
            path.PathProps = new PathProperties() { Stroke = stroke, Head = strokeEnding, Tail = strokeEnding };
            path.Contours = new BezierContour[] {
                new BezierContour() { Segments = VectorUtils.BezierSegmentToPath(VectorUtils.MakeLine(new Vector2(x1, y1), new Vector2(x2, y2))) }
            };
            sceneNode.Shapes = new List<Shape>(1);
            sceneNode.Shapes.Add(path);

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void linearGradient()
        {
            var node = docReader.VisitCurrent();

            var link = node["xlink:href"];
            var refFill = SVGAttribParser.ParseRelativeRef(link, svgObjects) as GradientFill;
            var refFillData = refFill != null ? gradientExInfo[refFill] as LinearGradientExData : null;

            bool relativeToWorld = refFillData != null ? refFillData.WorldRelative : false;
            switch (node["gradientUnits"])
            {
                case null:
                    break;

                case "objectBoundingBox":
                    relativeToWorld = false;
                    break;

                case "userSpaceOnUse":
                    relativeToWorld = true;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("gradientUnits");
            }

            AddressMode addressing = refFill != null ? refFill.Addressing : AddressMode.Clamp;
            switch (node["spreadMethod"])
            {
                case null:
                    break;

                case "pad":
                    addressing = AddressMode.Clamp;
                    break;

                case "reflect":
                    addressing = AddressMode.Mirror;
                    break;

                case "repeat":
                    addressing = AddressMode.Wrap;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("spreadMethod");
            }

            var gradientTransform = SVGAttribParser.ParseTransform(node, "gradientTransform");

            GradientFill fill = CloneGradientFill(refFill);
            if (fill == null)
                fill = new GradientFill() { Addressing = addressing, Type = GradientFillType.Linear };

            LinearGradientExData fillExData = new LinearGradientExData() { WorldRelative = relativeToWorld, FillTransform = gradientTransform };
            gradientExInfo[fill] = fillExData;

            // Fills are defined outside of a shape scope, so we can't resolve relative coordinates here.
            // We defer this entire operation to AdjustFills pass, but we still do value validation here
            // nonetheless to give meaningful error messages to the user if any.
            currentContainerSize.Push(Vector2.one);

            fillExData.X1 = node["x1"];
            fillExData.Y1 = node["y1"];
            fillExData.X2 = node["x2"];
            fillExData.Y2 = node["y2"];

            // The calls below are ineffective but they validate the inputs and throw an error if wrong values are specified, so don't remove them
            AttribLengthVal(fillExData.X1, node, "x1", 0.0f, DimType.Width);
            AttribLengthVal(fillExData.Y1, node, "y1", 0.0f, DimType.Height);
            AttribLengthVal(fillExData.X2, node, "x2", 1.0f, DimType.Width);
            AttribLengthVal(fillExData.Y2, node, "y2", 0.0f, DimType.Height);

            currentContainerSize.Pop();
            currentGradientFill = fill; // Children stops will register to this fill now
            currentGradientId = node["id"];
            currentGradientLink = SVGAttribParser.CleanIri(link);

            if (!string.IsNullOrEmpty(link) && !svgObjects.ContainsKey(link))
            {
                // Reference may be defined later in the file. Save for postponed processing.
                if (!postponedStopData.ContainsKey(currentGradientLink))
                    postponedStopData.Add(currentGradientLink, new List<PostponedStopData>());
                postponedStopData[currentGradientLink].Add(new PostponedStopData() { fill = fill });
            }

            AddToSVGDictionaryIfPossible(node, fill);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, stop);
        }

        void path()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            var fill = SVGAttribParser.ParseFill(node, svgObjects, postponedFills, styles);
            PathCorner strokeCorner;
            PathEnding strokeEnding;
            var stroke = ParseStrokeAttributeSet(node, out strokeCorner, out strokeEnding);
            var pathProps = new PathProperties() { Stroke = stroke, Corners = strokeCorner, Head = strokeEnding, Tail = strokeEnding };

            // A path may have 1 or more sub paths. Each for us is an individual vector path.
            var contours = SVGAttribParser.ParsePath(node);
            if ((contours != null) && (contours.Count > 0))
            {
                //float pathLength = AttribFloatVal(node, "pathLength"); // This is useful for animation purposes mostly

                sceneNode.Shapes = new List<Shape>(1);
                sceneNode.Shapes.Add(new Shape() { Contours = contours.ToArray(), Fill = fill, PathProps = pathProps });

                AddToSVGDictionaryIfPossible(node, sceneNode);
            }

            ParseClipAndMask(node, sceneNode);

            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void polygon()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            var fill = SVGAttribParser.ParseFill(node, svgObjects, postponedFills, styles);
            PathCorner strokeCorner;
            PathEnding strokeEnding;
            var stroke = ParseStrokeAttributeSet(node, out strokeCorner, out strokeEnding);

            var pointsAttribVal = node["points"];
            var pointsString = (pointsAttribVal != null) ? pointsAttribVal.Split(whiteSpaceNumberChars, StringSplitOptions.RemoveEmptyEntries) : null;
            if (pointsString != null)
            {
                if ((pointsString.Length & 1) == 1)
                    throw node.GetException("polygon 'points' must specify x,y for each coordinate");
                if (pointsString.Length < 4)
                    throw node.GetException("polygon 'points' do not even specify one triangle");

                var pathProps = new PathProperties() { Stroke = stroke, Corners = strokeCorner, Head = strokeEnding, Tail = strokeEnding };
                var contour = new BezierContour() { Closed = true };
                var lastPoint = new Vector2(
                        AttribLengthVal(pointsString[0], node, "points", 0.0f, DimType.Width),
                        AttribLengthVal(pointsString[1], node, "points", 0.0f, DimType.Height));
                int maxSegments = pointsString.Length / 2;
                var segments = new List<BezierPathSegment>(maxSegments);
                for (int i = 1; i < maxSegments; i++)
                {
                    var newPoint = new Vector2(
                            AttribLengthVal(pointsString[i * 2 + 0], node, "points", 0.0f, DimType.Width),
                            AttribLengthVal(pointsString[i * 2 + 1], node, "points", 0.0f, DimType.Height));
                    if (newPoint == lastPoint)
                        continue;
                    var seg = VectorUtils.MakeLine(lastPoint, newPoint);
                    segments.Add(new BezierPathSegment() { P0 = seg.P0, P1 = seg.P1, P2 = seg.P2 });
                    lastPoint = newPoint;
                }

                if (segments.Count > 0)
                {
                    var connect = VectorUtils.MakeLine(lastPoint, segments[0].P0);
                    segments.Add(new BezierPathSegment() { P0 = connect.P0, P1 = connect.P1, P2 = connect.P2 });
                    contour.Segments = segments.ToArray();

                    var shape = new Shape() { Contours = new BezierContour[] { contour }, PathProps = pathProps, Fill = fill };
                    sceneNode.Shapes = new List<Shape>(1);
                    sceneNode.Shapes.Add(shape);
                }
            }

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void polyline()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            var fill = SVGAttribParser.ParseFill(node, svgObjects, postponedFills, styles);
            PathCorner strokeCorner;
            PathEnding strokeEnding;
            var stroke = ParseStrokeAttributeSet(node, out strokeCorner, out strokeEnding);

            var pointsAttribVal = node["points"];
            var pointsString = (pointsAttribVal != null) ? pointsAttribVal.Split(whiteSpaceNumberChars, StringSplitOptions.RemoveEmptyEntries) : null;
            if (pointsString != null)
            {
                if ((pointsString.Length & 1) == 1)
                    throw node.GetException("polyline 'points' must specify x,y for each coordinate");
                if (pointsString.Length < 4)
                    throw node.GetException("polyline 'points' do not even specify one line");

                var shape = new Shape() { Fill = fill };
                shape.PathProps = new PathProperties() { Stroke = stroke, Corners = strokeCorner, Head = strokeEnding, Tail = strokeEnding };
                var lastPoint = new Vector2(
                        AttribLengthVal(pointsString[0], node, "points", 0.0f, DimType.Width),
                        AttribLengthVal(pointsString[1], node, "points", 0.0f, DimType.Height));
                int maxSegments = pointsString.Length / 2;
                var segments = new List<BezierPathSegment>(maxSegments);
                for (int i = 1; i < maxSegments; i++)
                {
                    var newPoint = new Vector2(
                            AttribLengthVal(pointsString[i * 2 + 0], node, "points", 0.0f, DimType.Width),
                            AttribLengthVal(pointsString[i * 2 + 1], node, "points", 0.0f, DimType.Height));
                    if (newPoint == lastPoint)
                        continue;
                    var seg = VectorUtils.MakeLine(lastPoint, newPoint);
                    segments.Add(new BezierPathSegment() { P0 = seg.P0, P1 = seg.P1, P2 = seg.P2 });
                    lastPoint = newPoint;
                }
                if (segments.Count > 0 )
                {
                    var connect = VectorUtils.MakeLine(lastPoint, segments[0].P0);
                    segments.Add(new BezierPathSegment() { P0 = connect.P0, P1 = connect.P1, P2 = connect.P2 });
                    shape.Contours = new BezierContour[] {
                         new BezierContour() { Segments = segments.ToArray() }
                    };
                    sceneNode.Shapes = new List<Shape>(1);
                    sceneNode.Shapes.Add(shape);
                }
            }

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void radialGradient()
        {
            var node = docReader.VisitCurrent();

            var link = node["xlink:href"];
            var refFill = SVGAttribParser.ParseRelativeRef(link, svgObjects) as GradientFill;
            var refFillData = refFill != null ? gradientExInfo[refFill] as RadialGradientExData : null;

            bool relativeToWorld = refFillData != null ? refFillData.WorldRelative : false;
            switch (node["gradientUnits"])
            {
                case null:
                    break;

                case "objectBoundingBox":
                    relativeToWorld = false;
                    break;

                case "userSpaceOnUse":
                    relativeToWorld = true;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("gradientUnits");
            }

            AddressMode addressing = refFill != null ? refFill.Addressing : AddressMode.Clamp;
            switch (node["spreadMethod"])
            {
                case null:
                    break;

                case "pad":
                    addressing = AddressMode.Clamp;
                    break;

                case "reflect":
                    addressing = AddressMode.Mirror;
                    break;

                case "repeat":
                    addressing = AddressMode.Wrap;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("spreadMethod");
            }

            var gradientTransform = SVGAttribParser.ParseTransform(node, "gradientTransform");

            GradientFill fill = CloneGradientFill(refFill);
            if (fill == null)
                fill = new GradientFill() { Addressing = addressing, Type = GradientFillType.Radial };

            RadialGradientExData fillExData = new RadialGradientExData() { WorldRelative = relativeToWorld, FillTransform = gradientTransform };
            gradientExInfo[fill] = fillExData;

            // Fills are defined outside of a shape scope, so we can't resolve relative coordinates here.
            // We defer this entire operation to AdjustFills pass, but we still do value validation here
            // nonetheless to give meaningful error messages to the user if any.
            currentContainerSize.Push(Vector2.one);

            fillExData.Cx = node["cx"];
            fillExData.Cy = node["cy"];
            fillExData.Fx = node["fx"];
            fillExData.Fy = node["fy"];
            fillExData.R = node["r"];

            // The calls below are ineffective but they validate the inputs and throw an error if wrong values are specified, so don't remove them
            AttribLengthVal(fillExData.Cx, node, "cx", 0.5f, DimType.Width);
            AttribLengthVal(fillExData.Cy, node, "cy", 0.5f, DimType.Height);
            AttribLengthVal(fillExData.Fx, node, "fx", 0.5f, DimType.Width);
            AttribLengthVal(fillExData.Fy, node, "fy", 0.5f, DimType.Height);
            AttribLengthVal(fillExData.R, node, "r", 0.5f, DimType.Length);

            currentContainerSize.Pop();
            currentGradientFill = fill; // Children stops will register to this fill now
            currentGradientId = node["id"];
            currentGradientLink = SVGAttribParser.CleanIri(link);

            if (!string.IsNullOrEmpty(link) && !svgObjects.ContainsKey(link))
            {
                // Reference may be defined later in the file. Save for postponed processing.
                if (!postponedStopData.ContainsKey(currentGradientLink))
                    postponedStopData.Add(currentGradientLink, new List<PostponedStopData>());
                postponedStopData[currentGradientLink].Add(new PostponedStopData() { fill = fill });
            }

            AddToSVGDictionaryIfPossible(node, fill);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, stop);
        }

        void clipPath()
        {
            var node = docReader.VisitCurrent();
            string id = node["id"];

             // A new scene node instead of one precreated for us
            var clipRoot = new SceneNode() {
                Transform = SVGAttribParser.ParseTransform(node)
            };

            bool relativeToWorld;
            switch (node["clipPathUnits"])
            {
                case null:
                case "userSpaceOnUse":
                    relativeToWorld = true;
                    break;

                case "objectBoundingBox":
                    relativeToWorld = false;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("clipPathUnits");
            }

            clipData[clipRoot] = new ClipData() { WorldRelative = relativeToWorld };

            AddToSVGDictionaryIfPossible(node, clipRoot);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, allElems);

            currentSceneNode.Push(clipRoot);
            ParseChildren(node, node.Name);
            if (currentSceneNode.Pop() != clipRoot)
                throw SVGFormatException.StackError;
            
            // Resolve any previous node that was referencing this clipping path
            if (!string.IsNullOrEmpty(id))
            {
                List<PostponedClip> clips;
                if (postponedClip.TryGetValue(id, out clips))
                {
                    foreach (var clip in clips)
                        ApplyClipper(clipRoot, clip.node, relativeToWorld);
                }
            }

        }

        void pattern()
        {
            var node = docReader.VisitCurrent();

            // A new scene node instead of one precreated for us
            var patternRoot = new SceneNode() {
                Transform = Matrix2D.identity
            };

            bool relativeToWorld = false;
            switch (node["patternUnits"])
            {
                case null:
                case "objectBoundingBox":
                    relativeToWorld = false;
                    break;

                case "userSpaceOnUse":
                    relativeToWorld = true;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("patternUnits");
            }

            bool contentRelativeToWorld = true;
            switch (node["patternContentUnits"])
            {
                case null:
                case "userSpaceOnUse":
                    contentRelativeToWorld = true;
                    break;

                case "objectBoundingBox":
                    contentRelativeToWorld = false;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("patternContentUnits");
            }

            var x = AttribLengthVal(node["x"], node, "x", 0.0f, DimType.Width);
            var y = AttribLengthVal(node["y"], node, "y", 0.0f, DimType.Height);
            var w = AttribLengthVal(node["width"], node, "width", 0.0f, DimType.Width);
            var h = AttribLengthVal(node["height"], node, "height", 0.0f, DimType.Height);

            var patternTransform = SVGAttribParser.ParseTransform(node, "patternTransform");

            patternData[patternRoot] = new PatternData() {
                WorldRelative = relativeToWorld,
                ContentWorldRelative = contentRelativeToWorld,
                PatternTransform = patternTransform
            };

            var fill = new PatternFill() { 
                Pattern = patternRoot,
                Rect = new Rect(x, y, w, h)
            };

            AddToSVGDictionaryIfPossible(node, fill);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, allElems);

            currentSceneNode.Push(patternRoot);
            ParseChildren(node, node.Name);
            if (currentSceneNode.Pop() != patternRoot)
                throw SVGFormatException.StackError;
        }

        void mask()
        {
            var node = docReader.VisitCurrent();

            // A new scene node instead of one precreated for us
            var maskRoot = new SceneNode() {
                Transform = Matrix2D.identity
            };

            bool relativeToWorld;
            switch (node["maskUnits"])
            {
                case null:
                case "userSpaceOnUse":
                    relativeToWorld = true;
                    break;

                case "objectBoundingBox":
                    relativeToWorld = false;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("maskUnits");
            }

            bool contentRelativeToWorld;
            switch (node["maskContentUnits"])
            {
                case null:
                case "userSpaceOnUse":
                    contentRelativeToWorld = true;
                    break;

                case "objectBoundingBox":
                    contentRelativeToWorld = false;
                    break;

                default:
                    throw node.GetUnsupportedAttribValException("maskContentUnits");
            }

            maskData[maskRoot] = new MaskData() {
                WorldRelative = relativeToWorld,
                ContentWorldRelative = contentRelativeToWorld,
            };

            AddToSVGDictionaryIfPossible(node, maskRoot);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, allElems);

            currentSceneNode.Push(maskRoot);
            ParseChildren(node, node.Name);
            if (currentSceneNode.Pop() != maskRoot)
                throw SVGFormatException.StackError;
        }

        void rect()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            var fill = SVGAttribParser.ParseFill(node, svgObjects, postponedFills, styles);
            PathCorner strokeCorner;
            PathEnding strokeEnding;
            var stroke = ParseStrokeAttributeSet(node, out strokeCorner, out strokeEnding);

            float x = AttribLengthVal(node, "x", 0.0f, DimType.Width);
            float y = AttribLengthVal(node, "y", 0.0f, DimType.Height);
            float rx = AttribLengthVal(node, "rx", -1.0f, DimType.Length);
            float ry = AttribLengthVal(node, "ry", -1.0f, DimType.Length);
            float width = AttribLengthVal(node, "width", 0.0f, DimType.Length);
            float height = AttribLengthVal(node, "height", 0.0f, DimType.Length);

            if ((rx < 0.0f) && (ry >= 0.0f))
                rx = ry;
            else if ((ry < 0.0f) && (rx >= 0.0f))
                ry = rx;
            else if ((ry < 0.0f) && (rx < 0.0f))
                rx = ry = 0.0f;
            rx = Mathf.Min(rx, width * 0.5f);
            ry = Mathf.Min(ry, height * 0.5f);

            var rad = new Vector2(rx, ry);
            var rect = new Shape();
            VectorUtils.MakeRectangleShape(rect, new Rect(x, y, width, height), rad, rad, rad, rad);
            rect.Fill = fill;
            rect.PathProps = new PathProperties() { Stroke = stroke, Head = strokeEnding, Tail = strokeEnding, Corners = strokeCorner };
            sceneNode.Shapes = new List<Shape>(1);
            sceneNode.Shapes.Add(rect);

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void stop()
        {
            var node = docReader.VisitCurrent();
            System.Diagnostics.Debug.Assert(currentGradientFill != null);

            GradientStop stop = new GradientStop();

            string stopColor = styles.Evaluate("stop-color");
            Color color = stopColor != null ? SVGAttribParser.ParseColor(stopColor) : Color.black;

            color.a = AttribFloatVal("stop-opacity", 1.0f);
            stop.Color = color;

            string offsetString = styles.Evaluate("offset");
            if (!string.IsNullOrEmpty(offsetString))
            {
                bool percentage = offsetString.EndsWith("%");
                if (percentage)
                    offsetString = offsetString.Substring(0, offsetString.Length - 1);
                stop.StopPercentage = SVGAttribParser.ParseFloat(offsetString);
                if (percentage)
                    stop.StopPercentage /= 100.0f;

                stop.StopPercentage = Mathf.Max(0.0f, stop.StopPercentage);
                stop.StopPercentage = Mathf.Min(1.0f, stop.StopPercentage);
            }

            // I don't like this, but hopefully there aren't many stops in a gradient
            GradientStop[] newStops;
            if (currentGradientFill.Stops == null || currentGradientFill.Stops.Length == 0)
                newStops = new GradientStop[1];
            else
            {
                newStops = new GradientStop[currentGradientFill.Stops.Length + 1];
                currentGradientFill.Stops.CopyTo(newStops, 0);
            }
            newStops[newStops.Length - 1] = stop;
            currentGradientFill.Stops = newStops;

            // Apply postponed stops if this was defined later in the file
            if (!string.IsNullOrEmpty(currentGradientId) && postponedStopData.ContainsKey(currentGradientId))
            {
                foreach (var postponedStop in postponedStopData[currentGradientId])
                    postponedStop.fill.Stops = newStops;
            }

            // Local stops overrides referenced ones
            if (!string.IsNullOrEmpty(currentGradientLink) && postponedStopData.ContainsKey(currentGradientLink))
            {
                var stopDataList = postponedStopData[currentGradientLink];
                foreach (var postponedStop in stopDataList)
                {
                    if (postponedStop.fill == currentGradientFill)
                    {
                        stopDataList.Remove(postponedStop);
                        break;
                    }
                }
            }

            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void svg()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = new SceneNode();
            if (scene.Root == null) // If this is the root SVG element, then we set the vector scene root as well
            {
                System.Diagnostics.Debug.Assert(currentSceneNode.Count == 0);
                scene.Root = sceneNode;
            }

            styles.PushNode(node);

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);

            sceneViewport = ParseViewport(node, sceneNode, new Vector2(windowWidth, windowHeight));
            var viewBoxInfo = ParseViewBox(node, sceneNode, sceneViewport);
            if (applyRootViewBox)
                ApplyViewBox(sceneNode, viewBoxInfo, sceneViewport);

            currentContainerSize.Push(sceneViewport.size);
            if (!viewBoxInfo.IsEmpty)
                currentViewBoxSize.Push(viewBoxInfo.ViewBox.size);

            currentSceneNode.Push(sceneNode);
            nodeGlobalSceneState[sceneNode] = new NodeGlobalSceneState() { ContainerSize = currentContainerSize.Peek() };

            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, allElems);
            ParseChildren(node, "svg");

            if (currentSceneNode.Pop() != sceneNode)
                throw SVGFormatException.StackError;

            if (!viewBoxInfo.IsEmpty)
                currentViewBoxSize.Pop();
            currentContainerSize.Pop();

            styles.PopNode();
        }

        void symbol()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = new SceneNode(); // A new scene node instead of one precreated for us
            string id = node["id"];

            ParseID(node, sceneNode);
            ParseOpacity(sceneNode);
            sceneNode.Transform = Matrix2D.identity;

            Rect viewportRect = new Rect(Vector2.zero, currentContainerSize.Peek());
            var viewBoxInfo = ParseViewBox(node, sceneNode, viewportRect);
            if (!viewBoxInfo.IsEmpty)
                currentViewBoxSize.Push(viewBoxInfo.ViewBox.size);

            symbolViewBoxes[sceneNode] = viewBoxInfo;

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node, allElems);

            currentSceneNode.Push(sceneNode);
            ParseChildren(node, node.Name);
            if (currentSceneNode.Pop() != sceneNode)
                throw SVGFormatException.StackError;

            if (!viewBoxInfo.IsEmpty)
                currentViewBoxSize.Pop();

            ParseClipAndMask(node, sceneNode);

            // Resolve any previous node that was referencing this symbol
            if (!string.IsNullOrEmpty(id))
            {
                List<NodeReferenceData> refList;
                if (postponedSymbolData.TryGetValue(id, out refList))
                {
                    foreach (var refData in refList)
                        ResolveReferencedNode(sceneNode, refData, true);
                }
            }
        }

        void use()
        {
            var node = docReader.VisitCurrent();
            var sceneNode = currentSceneNode.Peek();

            ParseOpacity(sceneNode);

            var sceneViewport = ParseViewport(node, sceneNode, Vector2.zero);
            var refData = new NodeReferenceData() {
                node = sceneNode,
                viewport = sceneViewport,
                id = node["id"]
            };

            var iri = node["xlink:href"];
            var referencedNode = SVGAttribParser.ParseRelativeRef(iri, svgObjects) as SceneNode;
            if (referencedNode == null && !string.IsNullOrEmpty(iri) && iri.StartsWith("#"))
            {
                // The referenced node may be defined later in the file, save it for later
                iri = iri.Substring(1);
                List<NodeReferenceData> refList;
                if (!postponedSymbolData.TryGetValue(iri, out refList))
                {
                    refList = new List<NodeReferenceData>();
                    postponedSymbolData[iri] = refList;
                }
                refList.Add(refData);
            }

            sceneNode.Transform = SVGAttribParser.ParseTransform(node);
            sceneNode.Transform = sceneNode.Transform * Matrix2D.Translate(sceneViewport.position);

            if (referencedNode != null)
                ResolveReferencedNode(referencedNode, refData, false);

            ParseClipAndMask(node, sceneNode);

            AddToSVGDictionaryIfPossible(node, sceneNode);
            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }

        void style()
        {
            var node = docReader.VisitCurrent();
            var text = docReader.ReadTextWithinElement();

            if (text.Length > 0)
                styles.SetGlobalStyleSheet(SVGStyleSheetUtils.Parse(text));

            if (ShouldDeclareSupportedChildren(node))
                SupportElems(node);  // No children supported
        }
        #endregion

        #region Symbol Reference Processing
        private void ResolveReferencedNode(SceneNode referencedNode, NodeReferenceData refData, bool isDeferred)
        {
            // Note we don't use the viewport size because the <use> element doesn't establish a viewport for its referenced elements
            ViewBoxInfo viewBoxInfo;
            if (symbolViewBoxes.TryGetValue(referencedNode, out viewBoxInfo))
                ApplyViewBox(refData.node, viewBoxInfo, refData.viewport); // When using a symbol we need to apply the symbol's view box

            if (refData.node.Children == null)
                refData.node.Children = new List<SceneNode>();

            SVGStyleResolver.StyleLayer rootLayer = null;
            if (isDeferred)
            {
                // If deferred, push back the original <use> tag style layer to be in the same "style environment"
                rootLayer = styles.GetLayerForScenNode(refData.node);
                if (rootLayer != null)
                    styles.PushLayer(rootLayer);
            }

            // Activate the styles of the referenced node
            var styleLayer = nodeStyleLayers[referencedNode];
            if (styleLayer != null)
                styles.PushLayer(styleLayer);

            // Build a map to be able to retrieve the original node's style layer
            var originalNodes = new List<SceneNode>(10);
            foreach (var child in VectorUtils.SceneNodes(referencedNode))
                originalNodes.Add(child);

            var node = CloneSceneNode(referencedNode);

            int originalIndex = 0;
            foreach (var child in VectorUtils.SceneNodes(node))
            {
                var nodeIndex = originalIndex++;
                if (child.Shapes == null)
                    continue;

                var originalNode = originalNodes[nodeIndex];
                var layer = styles.GetLayerForScenNode(originalNode);
                if (layer != null)
                    styles.PushLayer(layer);

                bool isDefaultFill;
                var fill = SVGAttribParser.ParseFill(null, svgObjects, postponedFills, styles, Inheritance.Inherited, out isDefaultFill);
                PathCorner strokeCorner;
                PathEnding strokeEnding;
                var stroke = ParseStrokeAttributeSet(null, out strokeCorner, out strokeEnding);

                foreach (var shape in child.Shapes)
                {
                    var pathProps = shape.PathProps;
                    pathProps.Stroke = stroke;
                    pathProps.Corners = strokeCorner;
                    pathProps.Head = strokeEnding;
                    shape.PathProps = pathProps;
                    shape.Fill = isDefaultFill ? shape.Fill : fill;
                }

                if (layer != null)
                    styles.PopLayer();
            }

            if (styleLayer != null)
                styles.PopLayer();

            if (rootLayer != null)
                styles.PopLayer();

            // We process the node ID here to refer to the proper scene node
            if (!string.IsNullOrEmpty(refData.id))
                nodeIDs[refData.id] = node;

            refData.node.Children.Add(node);
        }
        #endregion

        #region Scene Node Cloning
        // This is a poor man's cloning system, until we have proper serialization in VectorScene.
        private SceneNode CloneSceneNode(SceneNode node)
        {
            if (node == null)
                return null;

            List<SceneNode> children = null;
            if (node.Children != null)
            {
                children = new List<SceneNode>(node.Children.Count);
                foreach (var c in node.Children)
                    children.Add(CloneSceneNode(c));
            }

            List<Shape> shapes = null;
            if (node.Shapes != null)
            {
                shapes = new List<Shape>(node.Shapes.Count);
                foreach (var d in node.Shapes)
                    shapes.Add(CloneShape(d));
            }

            var n = new SceneNode() {
                Children = children,
                Shapes = shapes,
                Transform = node.Transform,
                Clipper = CloneSceneNode(node.Clipper)
            };

            if (nodeGlobalSceneState.ContainsKey(node))
                nodeGlobalSceneState[n] = nodeGlobalSceneState[node];
            if (nodeOpacity.ContainsKey(node))
                nodeOpacity[n] = nodeOpacity[node];

            return n;
        }

        private Shape CloneShape(Shape shape)
        {
            if (shape == null)
                return null;

            BezierContour[] contours = null;
            if (shape.Contours != null)
            {
                contours = new BezierContour[shape.Contours.Length];
                for (int i = 0; i < contours.Length; ++i)
                    contours[i] = CloneContour(shape.Contours[i]);
            }
            return new Shape() {
                Fill = CloneFill(shape.Fill),
                FillTransform = shape.FillTransform,
                PathProps = ClonePathProps(shape.PathProps),
                Contours = contours,
                IsConvex = shape.IsConvex
            };
        }

        private BezierContour CloneContour(BezierContour c)
        {
            BezierPathSegment[] segs = null;
            if (c.Segments != null)
            {
                segs = new BezierPathSegment[c.Segments.Length];
                for (int i = 0; i < segs.Length; ++i)
                {
                    var s = c.Segments[i];
                    segs[i] = new BezierPathSegment() { P0 = s.P0, P1 = s.P1, P2 = s.P2 };
                }
            }
            return new BezierContour() { Segments = segs, Closed = c.Closed };
        }

        private IFill CloneFill(IFill fill)
        {
            if (fill == null)
                return null;

            IFill f = null;
            if (fill is SolidFill)
            {
                var solid = fill as SolidFill;
                f = new SolidFill() {
                    Color = solid.Color,
                    Opacity = solid.Opacity,
                    Mode = solid.Mode
                };
            }
            else if (fill is GradientFill)
            {
                var grad = fill as GradientFill;
                GradientStop[] stops = null;
                if (grad.Stops != null)
                {
                    stops = new GradientStop[grad.Stops.Length];
                    for (int i = 0; i < stops.Length; ++i)
                    {
                        var stop = grad.Stops[i];
                        stops[i] = new GradientStop() { Color = stop.Color, StopPercentage = stop.StopPercentage };
                    }
                }
                var gradientFill = new GradientFill() {
                    Type = grad.Type,
                    Stops = stops,
                    Mode = grad.Mode,
                    Opacity = grad.Opacity,
                    Addressing = grad.Addressing,
                    RadialFocus = grad.RadialFocus
                };
                gradientExInfo[gradientFill] = gradientExInfo[grad];
                f = gradientFill;
            }
            else if (fill is TextureFill)
            {
                var tex = fill as TextureFill;
                f = new TextureFill() {
                    Texture = tex.Texture,
                    Mode = tex.Mode,
                    Opacity = tex.Opacity,
                    Addressing = tex.Addressing
                };
            }
            else if (fill is PatternFill)
            {
                var pat = fill as PatternFill;
                f = new PatternFill() {
                    Mode = pat.Mode,
                    Opacity = pat.Opacity,
                    Pattern = CloneSceneNode(pat.Pattern),
                    Rect = pat.Rect
                };
            }
            return f;
        }

        private PathProperties ClonePathProps(PathProperties props)
        {
            Stroke stroke = null;
            if (props.Stroke != null)
            {
                float[] pattern = null;
                if (props.Stroke.Pattern != null)
                {
                    pattern = new float[props.Stroke.Pattern.Length];
                    for (int i = 0; i < pattern.Length; ++i)
                        pattern[i] = props.Stroke.Pattern[i];
                }
                stroke = new Stroke() {
                    Fill = CloneFill(props.Stroke.Fill),
                    FillTransform = props.Stroke.FillTransform,
                    HalfThickness = props.Stroke.HalfThickness,
                    Pattern = pattern,
                    PatternOffset = props.Stroke.PatternOffset,
                    TippedCornerLimit = props.Stroke.TippedCornerLimit
                };
            }

            return new PathProperties() {
                Stroke = stroke,
                Head = props.Head,
                Tail = props.Tail,
                Corners = props.Corners
            };
        }
        #endregion

        #region Utilities
        private GradientFill CloneGradientFill(GradientFill other)
        {
            if (other == null)
                return null;

            // This is a very fragile gradient fill cloning used since Illustrator
            // will sometimes refer to another fill using a "xlink:href" attribute.
            return new GradientFill() {
                Type = other.Type,
                Stops = other.Stops,
                Mode = other.Mode,
                Opacity = other.Opacity,
                Addressing = other.Addressing,
                RadialFocus = other.RadialFocus
            };
        }
        #endregion

        #region Simple Attribute Handling
        int AttribIntVal(string attribName) { return AttribIntVal(attribName, 0); }
        int AttribIntVal(string attribName, int defaultVal)
        {
            string val = styles.Evaluate(attribName);
            return (val != null) ? int.Parse(val) : defaultVal;
        }

        float AttribFloatVal(string attribName) { return AttribFloatVal(attribName, 0.0f); }
        float AttribFloatVal(string attribName, float defaultVal)
        {
            string val = styles.Evaluate(attribName);
            return (val != null) ? SVGAttribParser.ParseFloat(val) : defaultVal;
        }

        float AttribLengthVal(XmlReaderIterator.Node node, string attribName, DimType dimType) { return AttribLengthVal(node, attribName, 0.0f, dimType); }
        float AttribLengthVal(XmlReaderIterator.Node node, string attribName, float defaultUnitVal, DimType dimType)
        {
            var val = styles.Evaluate(attribName);
            return AttribLengthVal(val, node, attribName, defaultUnitVal, dimType);
        }

        float AttribLengthVal(string val, XmlReaderIterator.Node node, string attribName, float defaultUnitVal, DimType dimType)
        {
            // For reference: http://www.w3.org/TR/SVG/coords.html#Units
            if (val == null) return defaultUnitVal;
            val = val.Trim();
            string unitType = "px";
            char lastChar = val[val.Length - 1];
            if (lastChar == '%')
            {
                float number = SVGAttribParser.ParseFloat(val.Substring(0, val.Length - 1));
                if (number < 0)
                    throw node.GetException("Number in " + attribName + " cannot be negative");
                number /= 100.0f;

                // If there's an active viewbox, this should be used as the reference size for relative coordinates.
                // See https://www.w3.org/TR/SVG/coords.html#Units
                Vector2 vpSize = currentViewBoxSize.Count > 0 ? currentViewBoxSize.Peek() : currentContainerSize.Peek();

                switch (dimType)
                {
                    case DimType.Width: return number * vpSize.x;
                    case DimType.Height: return number * vpSize.y;
                    case DimType.Length: return (number * vpSize.magnitude / SVGLengthFactor); // See http://www.w3.org/TR/SVG/coords.html#Units
                }
            }
            else if (val.Length >= 2)
            {
                unitType = val.Substring(val.Length - 2);
            }

            if (char.IsDigit(lastChar) || (lastChar == '.'))
                return SVGAttribParser.ParseFloat(val); // No unit specified.. assume pixels (one px unit is defined to be equal to one user unit)

            float length = SVGAttribParser.ParseFloat(val.Substring(0, val.Length - 2));
            switch (unitType)
            {
                case "em": throw new NotImplementedException();
                case "ex": throw new NotImplementedException();
                case "px": return length;
                case "in": return 90.0f * length * dpiScale;       // "1in" equals "90px" (and therefore 90 user units)
                case "cm": return 35.43307f * length * dpiScale;   // "1cm" equals "35.43307px" (and therefore 35.43307 user units)
                case "mm": return 3.543307f * length * dpiScale;   // "1mm" would be "3.543307px" (3.543307 user units)
                case "pt": return 1.25f * length * dpiScale;       // "1pt" equals "1.25px" (and therefore 1.25 user units)
                case "pc": return 15.0f * length * dpiScale;       // "1pc" equals "15px" (and therefore 15 user units)
                default:
                    throw new FormatException("Unknown length unit type (" + unitType + ")");
            }
        }

        #endregion

        #region Attribute Set Handling
        void AddToSVGDictionaryIfPossible(XmlReaderIterator.Node node, object vectorElement)
        {
            string id = node["id"];
            if (!string.IsNullOrEmpty(id))
                svgObjects[id] = vectorElement;
        }

        Rect ParseViewport(XmlReaderIterator.Node node, SceneNode sceneNode, Vector2 defaultViewportSize)
        {
            scenePos.x = AttribLengthVal(node, "x", DimType.Width);
            scenePos.y = AttribLengthVal(node, "y", DimType.Height);
            sceneSize.x = AttribLengthVal(node, "width", defaultViewportSize.x, DimType.Width);
            sceneSize.y = AttribLengthVal(node, "height", defaultViewportSize.y, DimType.Height);

            // The size could be all 0, in which case we should ignore the viewport sizing logic altogether
            return new Rect(scenePos, sceneSize);
        }

        enum ViewBoxAlign { Min, Mid, Max }
        enum ViewBoxAspectRatio { DontPreserve, FitLargestDim, FitSmallestDim }
        struct ViewBoxInfo { public Rect ViewBox; public ViewBoxAspectRatio AspectRatio; public ViewBoxAlign AlignX, AlignY; public bool IsEmpty; }
        ViewBoxInfo ParseViewBox(XmlReaderIterator.Node node, SceneNode sceneNode, Rect sceneViewport)
        {
            var viewBoxInfo = new ViewBoxInfo() { IsEmpty = true };
            string viewBoxString = node["viewBox"];
            viewBoxString = viewBoxString != null ? viewBoxString.Trim() : null;
            if (string.IsNullOrEmpty(viewBoxString))
                return viewBoxInfo;

            var viewBoxValues = viewBoxString.Split(new char[] { ' ', ',' }, StringSplitOptions.RemoveEmptyEntries);
            if (viewBoxValues.Length != 4)
                throw node.GetException("Invalid viewBox specification");
            Vector2 viewBoxMin = new Vector2(
                    AttribLengthVal(viewBoxValues[0], node, "viewBox", 0.0f, DimType.Width),
                    AttribLengthVal(viewBoxValues[1], node, "viewBox", 0.0f, DimType.Height));
            Vector2 viewBoxSize = new Vector2(
                    AttribLengthVal(viewBoxValues[2], node, "viewBox", sceneViewport.width, DimType.Width),
                    AttribLengthVal(viewBoxValues[3], node, "viewBox", sceneViewport.height, DimType.Height));

            viewBoxInfo.ViewBox = new Rect(viewBoxMin, viewBoxSize);
            ParseViewBoxAspectRatio(node, ref viewBoxInfo);

            viewBoxInfo.IsEmpty = false;
            return viewBoxInfo;
        }

        void ParseViewBoxAspectRatio(XmlReaderIterator.Node node, ref ViewBoxInfo viewBoxInfo)
        {
            viewBoxInfo.AspectRatio = ViewBoxAspectRatio.FitLargestDim;
            viewBoxInfo.AlignX = ViewBoxAlign.Mid;
            viewBoxInfo.AlignY = ViewBoxAlign.Mid;

            string preserveAspectRatioString = node["preserveAspectRatio"];
            preserveAspectRatioString = preserveAspectRatioString != null ? preserveAspectRatioString.Trim() : null;
            bool wantNone = false;
            if (!string.IsNullOrEmpty(preserveAspectRatioString))
            {
                var preserveAspectRatioValues = preserveAspectRatioString.Split(new char[] { ' ', ',' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var value in preserveAspectRatioValues)
                {
                    switch (value)
                    {
                        case "defer": break; // This is only meaningful on <image> that references another SVG, we don't support that
                        case "none": wantNone = true; break;
                        case "xMinYMin": viewBoxInfo.AlignX = ViewBoxAlign.Min; viewBoxInfo.AlignY = ViewBoxAlign.Min; break;
                        case "xMidYMin": viewBoxInfo.AlignX = ViewBoxAlign.Mid; viewBoxInfo.AlignY = ViewBoxAlign.Min; break;
                        case "xMaxYMin": viewBoxInfo.AlignX = ViewBoxAlign.Max; viewBoxInfo.AlignY = ViewBoxAlign.Min; break;
                        case "xMinYMid": viewBoxInfo.AlignX = ViewBoxAlign.Min; viewBoxInfo.AlignY = ViewBoxAlign.Mid; break;
                        case "xMidYMid": viewBoxInfo.AlignX = ViewBoxAlign.Mid; viewBoxInfo.AlignY = ViewBoxAlign.Mid; break;
                        case "xMaxYMid": viewBoxInfo.AlignX = ViewBoxAlign.Max; viewBoxInfo.AlignY = ViewBoxAlign.Mid; break;
                        case "xMinYMax": viewBoxInfo.AlignX = ViewBoxAlign.Min; viewBoxInfo.AlignY = ViewBoxAlign.Max; break;
                        case "xMidYMax": viewBoxInfo.AlignX = ViewBoxAlign.Mid; viewBoxInfo.AlignY = ViewBoxAlign.Max; break;
                        case "xMaxYMax": viewBoxInfo.AlignX = ViewBoxAlign.Max; viewBoxInfo.AlignY = ViewBoxAlign.Max; break;
                        case "meet": viewBoxInfo.AspectRatio = ViewBoxAspectRatio.FitLargestDim; break;
                        case "slice": viewBoxInfo.AspectRatio = ViewBoxAspectRatio.FitSmallestDim; break;
                    }
                }
            }

            if (wantNone) // Override aspect ratio no matter what other modes are chosen (meet/slice)
                viewBoxInfo.AspectRatio = ViewBoxAspectRatio.DontPreserve;
        }

        void ApplyViewBox(SceneNode sceneNode, ViewBoxInfo viewBoxInfo, Rect sceneViewport)
        {
            if ((viewBoxInfo.ViewBox.size == Vector2.zero) || (sceneViewport.size == Vector2.zero))
                return;

            Vector2 scale = Vector2.one, offset = -viewBoxInfo.ViewBox.position;
            if (viewBoxInfo.AspectRatio == ViewBoxAspectRatio.DontPreserve)
            {
                scale = sceneViewport.size / viewBoxInfo.ViewBox.size;
            }
            else
            {
                scale.x = scale.y = sceneViewport.width / viewBoxInfo.ViewBox.width;
                bool fitsOnWidth;
                if (viewBoxInfo.AspectRatio == ViewBoxAspectRatio.FitLargestDim)
                    fitsOnWidth = viewBoxInfo.ViewBox.height * scale.y <= sceneViewport.height;
                else fitsOnWidth = viewBoxInfo.ViewBox.height * scale.y > sceneViewport.height;

                Vector2 alignOffset = Vector2.zero;
                if (fitsOnWidth)
                {
                    // We fit on the width, so apply the vertical alignment rules
                    if (viewBoxInfo.AlignY == ViewBoxAlign.Mid)
                        alignOffset.y = (sceneViewport.height - viewBoxInfo.ViewBox.height * scale.y) * 0.5f;
                    else if (viewBoxInfo.AlignY == ViewBoxAlign.Max)
                        alignOffset.y = sceneViewport.height - viewBoxInfo.ViewBox.height * scale.y;
                }
                else
                {
                    // We didn't fit on width, meaning we should fit on height and use the wiggle room on width
                    scale.x = scale.y = sceneViewport.height / viewBoxInfo.ViewBox.height;

                    // Apply the horizontal alignment rules
                    if (viewBoxInfo.AlignX == ViewBoxAlign.Mid)
                        alignOffset.x = (sceneViewport.width - viewBoxInfo.ViewBox.width * scale.x) * 0.5f;
                    else if (viewBoxInfo.AlignX == ViewBoxAlign.Max)
                        alignOffset.x = sceneViewport.width - viewBoxInfo.ViewBox.width * scale.x;
                }

                offset += alignOffset / scale;
            }

            // Aaaaand finally, the transform
            sceneNode.Transform = sceneNode.Transform * Matrix2D.Scale(scale) * Matrix2D.Translate(offset);
        }

        Stroke ParseStrokeAttributeSet(XmlReaderIterator.Node node, out PathCorner strokeCorner, out PathEnding strokeEnding, Inheritance inheritance = Inheritance.Inherited)
        {
            var stroke = SVGAttribParser.ParseStrokeAndOpacity(node, svgObjects, styles, inheritance);
            strokeCorner = PathCorner.Tipped;
            strokeEnding = PathEnding.Chop;
            if (stroke != null)
            {
                string strokeWidth = styles.Evaluate("stroke-width", inheritance);
                stroke.HalfThickness = AttribLengthVal(strokeWidth, node, "stroke-width", 1.0f, DimType.Length) * 0.5f;
                switch (styles.Evaluate("stroke-linecap", inheritance))
                {
                    case "butt": strokeEnding = PathEnding.Chop; break;
                    case "square": strokeEnding = PathEnding.Square; break;
                    case "round": strokeEnding = PathEnding.Round; break;
                }
                switch (styles.Evaluate("stroke-linejoin", inheritance))
                {
                    case "miter": strokeCorner = PathCorner.Tipped; break;
                    case "round": strokeCorner = PathCorner.Round; break;
                    case "bevel": strokeCorner = PathCorner.Beveled; break;
                }

                string pattern = styles.Evaluate("stroke-dasharray", inheritance);
                if (pattern != null && pattern != "none")
                {
                    string[] entries = pattern.Split(whiteSpaceNumberChars, StringSplitOptions.RemoveEmptyEntries);
                    // If the pattern is odd, then we duplicate it to make it even as per the spec
                    int totalCount = (entries.Length & 1) == 1 ? entries.Length * 2 : entries.Length;
                    stroke.Pattern = new float[totalCount];
                    for (int i = 0; i < entries.Length; i++)
                        stroke.Pattern[i] = AttribLengthVal(entries[i], node, "stroke-dasharray", 0.0f, DimType.Length);

                    // Duplicate the pattern
                    if (totalCount > entries.Length)
                    {
                        for (int i = 0; i < entries.Length; i++)
                            stroke.Pattern[i + entries.Length] = stroke.Pattern[i];
                    }

                    var dashOffset = styles.Evaluate("stroke-dashoffset", inheritance);
                    stroke.PatternOffset = AttribLengthVal(dashOffset, node, "stroke-dashoffset", 0.0f, DimType.Length);
                }

                var strokeMiterLimit = styles.Evaluate("stroke-miterlimit", inheritance);
                stroke.TippedCornerLimit = AttribLengthVal(strokeMiterLimit, node, "stroke-miterlimit", 4.0f, DimType.Length);
                if (stroke.TippedCornerLimit < 1.0f)
                    throw node.GetException("'stroke-miterlimit' should be greater or equal to 1");
            } // If stroke is specified
            return stroke;
        }

        void ParseID(XmlReaderIterator.Node node, SceneNode sceneNode)
        {
            string id = node["id"];
            if (!string.IsNullOrEmpty(id))
            {
                nodeIDs[id] = sceneNode;

                // Store the style layer of this node since it can be referenced later by a <use> tag
                nodeStyleLayers[sceneNode] = styles.PeekLayer();
            }
        }

        float ParseOpacity(SceneNode sceneNode)
        {
            float opacity = AttribFloatVal("opacity", 1.0f);
            if (opacity != 1.0f && sceneNode != null)
                nodeOpacity[sceneNode] = opacity;
            return opacity;
        }

        void ParseClipAndMask(XmlReaderIterator.Node node, SceneNode sceneNode)
        {
            ParseClip(node, sceneNode);
            ParseMask(node, sceneNode);
        }

        void ParseClip(XmlReaderIterator.Node node, SceneNode sceneNode)
        {
            string reference = null;
            string clipPath = styles.Evaluate("clip-path");
            if (clipPath != null)
                reference = SVGAttribParser.ParseURLRef(clipPath);

            if (reference == null)
                return;

            var clipper = SVGAttribParser.ParseRelativeRef(reference, svgObjects) as SceneNode;
            if (clipper == null && reference.Length > 1 && reference.StartsWith("#"))
            {
                // Clipper may be defined later in the file
                List<PostponedClip> clips;
                if (!postponedClip.TryGetValue(reference, out clips))
                    clips = new List<PostponedClip>(1);
                clips.Add(new PostponedClip() { node = sceneNode });
                postponedClip[reference.Substring(1)] = clips;
                return;
            }
            var clipperRoot = clipper;

            bool worldRelative = true;
            ClipData data;
            if (clipData.TryGetValue(clipper, out data))
                worldRelative = data.WorldRelative;

            ApplyClipper(clipper, sceneNode, worldRelative);
        }

        void ApplyClipper(SceneNode clipper, SceneNode target, bool worldRelative)
        {
            SceneNode clipperRoot = clipper;
            if (!worldRelative)
            {
                // If the referenced clip path units is in bounding-box space, we add an intermediate
                // node to scale the content to the correct size.
                var rect = VectorUtils.SceneNodeBounds(target);
                var transform = Matrix2D.Translate(rect.position) * Matrix2D.Scale(rect.size);

                clipperRoot = new SceneNode() {
                    Children = new List<SceneNode> { clipper },
                    Transform = transform
                };
            }
            target.Clipper = clipperRoot;
        }

        void ParseMask(XmlReaderIterator.Node node, SceneNode sceneNode)
        {
            string reference = null;
            string maskRef = node["mask"];
            if (maskRef != null)
                reference = SVGAttribParser.ParseURLRef(maskRef);

            if (reference == null)
                return;

            var maskPath = SVGAttribParser.ParseRelativeRef(reference, svgObjects) as SceneNode;
            var maskRoot = maskPath;

            MaskData data;
            if (maskData.TryGetValue(maskPath, out data) && !data.ContentWorldRelative)
            {
                // If the referenced mask units is in bounding-box space, we add an intermediate
                // node to scale the content to the correct size.
                var rect = VectorUtils.SceneNodeBounds(sceneNode);
                var transform = Matrix2D.Translate(rect.position) * Matrix2D.Scale(rect.size);

                maskRoot = new SceneNode() {
                    Children = new List<SceneNode> { maskPath },
                    Transform = transform
                };
            }

            sceneNode.Clipper = maskRoot;
        }

        #endregion

        #region Textures
        Texture2D DecodeTextureData(string dataURI)
        {
            int pos = 5; // Skip "data:"
            int length = dataURI.Length;

            int startPos = pos;
            while (pos < length && dataURI[pos] != ';' && dataURI[pos] != ',')
                ++pos;

            var mediaType = dataURI.Substring(startPos, pos-startPos);
            if (mediaType != "image/png" && mediaType != "image/jpeg")
                return null;

            while (pos < length && dataURI[pos] != ',')
                ++pos;

            ++pos; // Skip ','

            if (pos >= length)
                return null;

            var data = Convert.FromBase64String(dataURI.Substring(pos));

            var tex = new Texture2D(1, 1);
            if (tex.LoadImage(data))
                return tex;

            return null;
        }
        #endregion

        #region Post-processing

        void PostProcess(SceneNode root)
        {
            AdjustFills(root);
        }

        struct HierarchyUpdate
        {
            public SceneNode Parent;
            public SceneNode NewNode;
            public SceneNode ReplaceNode;
        }

        void AdjustFills(SceneNode root)
        {
            var hierarchyUpdates = new List<HierarchyUpdate>();

            // Adjust fills on all objects
            foreach (var nodeInfo in VectorUtils.WorldTransformedSceneNodes(root, nodeOpacity))
            {
                if (nodeInfo.Node.Shapes == null)
                    continue;
                foreach (var shape in nodeInfo.Node.Shapes)
                {
                    if (shape.Fill != null)
                    {
                        // This fill may be a placeholder for postponed reference, try to resolve it here.
                        string reference;
                        if (postponedFills.TryGetValue(shape.Fill, out reference))
                        {
                            var fill = SVGAttribParser.ParseRelativeRef(reference, svgObjects) as IFill;
                            if (fill != null)
                                shape.Fill = fill;
                        }
                    }

                    var stroke = shape.PathProps.Stroke;
                    if (stroke != null && stroke.Fill is GradientFill)
                    {
                        var fillTransform = Matrix2D.identity;
                        AdjustGradientFill(nodeInfo.Node, nodeInfo.WorldTransform, stroke.Fill, shape.Contours, ref fillTransform);
                        stroke.FillTransform = fillTransform;
                    }

                    if (shape.Fill is GradientFill)
                    {
                        var fillTransform = Matrix2D.identity;
                        AdjustGradientFill(nodeInfo.Node, nodeInfo.WorldTransform, shape.Fill, shape.Contours, ref fillTransform);
                        shape.FillTransform = fillTransform;
                    }
                    else if (shape.Fill is PatternFill)
                    {
                        var fillNode = AdjustPatternFill(nodeInfo.Node, nodeInfo.WorldTransform, shape);
                        if (fillNode != null)
                        {
                            hierarchyUpdates.Add(new HierarchyUpdate()
                            {
                                Parent = nodeInfo.Parent,
                                NewNode = fillNode,
                                ReplaceNode = nodeInfo.Node
                            });
                        }
                    }
                }
            }

            foreach (var update in hierarchyUpdates)
            {
                var index = update.Parent.Children.IndexOf(update.ReplaceNode);
                update.Parent.Children.RemoveAt(index);
                update.Parent.Children.Insert(index, update.NewNode);
            }
        }

        void AdjustGradientFill(SceneNode node, Matrix2D worldTransform, IFill fill, BezierContour[] contours, ref Matrix2D computedTransform)
        {
            var gradientFill = fill as GradientFill;
            if (fill == null || contours == null || contours.Length == 0)
                return;

            var min = new Vector2(float.MaxValue, float.MaxValue);
            var max = new Vector2(-float.MaxValue, -float.MaxValue);
            foreach (var contour in contours)
            {
                var bbox = VectorUtils.Bounds(contour.Segments);
                min = Vector2.Min(min, bbox.min);
                max = Vector2.Max(max, bbox.max);
            }

            Rect bounds = new Rect(min, max - min);

            GradientExData extInfo = (GradientExData)gradientExInfo[gradientFill];
            var containerSize = nodeGlobalSceneState[node].ContainerSize;
            Matrix2D gradTransform = Matrix2D.identity;

            currentContainerSize.Push(extInfo.WorldRelative ? containerSize : Vector2.one);

            // If the fill is object relative, then the dimensions will come to us in
            // a normalized space, we must adjust those to the object's dimensions
            if (extInfo is LinearGradientExData)
            {
                // In SVG, linear gradients are expressed using two vectors. A vector and normal. The vector determines
                // the direction where the gradient increases. The normal determines the slant of the gradient along the vector.
                // Due to transformations, it is possible that those two vectors (the gradient vector and its normal) are not
                // actually perpendicular. That's why a skew transformation is involved here.
                // VectorScene just maps linear gradients from 0 to 1 across the entire bounding box width, so we
                // need to figure out a super transformation that takes those simply-mapped UVs and have them express
                // the linear gradient with its slant and all the fun involved.
                var linGradEx = (LinearGradientExData)extInfo;
                Vector2 lineStart = new Vector2(
                        AttribLengthVal(linGradEx.X1, null, null, 0.0f, DimType.Width),
                        AttribLengthVal(linGradEx.Y1, null, null, 0.0f, DimType.Height));
                Vector2 lineEnd = new Vector2(
                        AttribLengthVal(linGradEx.X2, null, null, currentContainerSize.Peek().x, DimType.Width),
                        AttribLengthVal(linGradEx.Y2, null, null, 0.0f, DimType.Height));

                var gradientVector = lineEnd - lineStart;
                float gradientVectorInvLength = 1.0f / gradientVector.magnitude;
                var scale = Matrix2D.Scale(new Vector2(bounds.width * gradientVectorInvLength, bounds.height * gradientVectorInvLength));
                var rotation = Matrix2D.RotateLH(Mathf.Atan2(gradientVector.y, gradientVector.x));
                var offset = Matrix2D.Translate(-lineStart);
                gradTransform = scale * rotation * offset;
            }
            else if (extInfo is RadialGradientExData)
            {
                // VectorScene positions radial gradiants at the center of the bbox, and picks the radii (not one radius, but two)
                // to fill the space between the center and the two edges (horizontal and vertical). So in the general case
                // the radial is actually an ellipsoid. So we need to do an SRT transformation to position the radial gradient according
                // to the SVG center point and radius
                var radGradEx = (RadialGradientExData)extInfo;
                Vector2 halfCurrentContainerSize = currentContainerSize.Peek() * 0.5f;
                Vector2 center = new Vector2(
                        AttribLengthVal(radGradEx.Cx, null, null, halfCurrentContainerSize.x, DimType.Width),
                        AttribLengthVal(radGradEx.Cy, null, null, halfCurrentContainerSize.y, DimType.Height));
                Vector2 focus = new Vector2(
                        AttribLengthVal(radGradEx.Fx, null, null, center.x, DimType.Width),
                        AttribLengthVal(radGradEx.Fy, null, null, center.y, DimType.Height));
                float radius = AttribLengthVal(radGradEx.R, null, null, halfCurrentContainerSize.magnitude / SVGLengthFactor, DimType.Length);

                // This block below tells that radial focus cannot change per object, but is realized correctly for the first object
                // that requests this gradient. If the gradient is using object-relative coordinates to specify the focus location,
                // then only the first object will look correct, and the rest will potentially not look right. The alternative is
                // to detect if it is necessary and generate a new atlas entry for it
                if (!radGradEx.Parsed)
                {
                    // VectorGradientFill radialFocus is (-1,1) relative to the outer circle
                    gradientFill.RadialFocus = (focus - center) / radius;
                    if (gradientFill.RadialFocus.sqrMagnitude > 1.0f - VectorUtils.Epsilon)
                        gradientFill.RadialFocus = gradientFill.RadialFocus.normalized * (1.0f - VectorUtils.Epsilon); // Stick within the unit circle

                    radGradEx.Parsed = true;
                }

                gradTransform =
                    Matrix2D.Scale(bounds.size * 0.5f / radius) *
                    Matrix2D.Translate(new Vector2(radius, radius) - center);
            }
            else
            {
                Debug.LogError("Unsupported gradient type: " + extInfo);
            }

            currentContainerSize.Pop();

            var uvToWorld = extInfo.WorldRelative ? Matrix2D.Translate(bounds.min) * Matrix2D.Scale(bounds.size) : Matrix2D.identity;
            var boundsInv = new Vector2(1.0f / bounds.width, 1.0f / bounds.height);
            computedTransform = Matrix2D.Scale(boundsInv) * gradTransform * extInfo.FillTransform.Inverse() * uvToWorld;
        }

        SceneNode AdjustPatternFill(SceneNode node, Matrix2D worldTransform, Shape shape)
        {
            PatternFill patternFill = shape.Fill as PatternFill;
            if (patternFill == null ||
                Mathf.Abs(patternFill.Rect.width) < VectorUtils.Epsilon ||
                Mathf.Abs(patternFill.Rect.height) < VectorUtils.Epsilon)
            {
                return null;
            }
            
            var data = patternData[patternFill.Pattern];

            var nodeBounds = VectorUtils.SceneNodeBounds(node);
            var patternRect = patternFill.Rect;
            if (!data.WorldRelative)
            {
                patternRect.position *= nodeBounds.size;
                patternRect.size *= nodeBounds.size;
            }

            // The pattern fill will create a new clipped node containing the repeating pattern
            // as well as a sibling containing the original node. This will replace the original node.
            var replacementNode = new SceneNode() {
                Transform = node.Transform,
                Children = new List<SceneNode>(2)
            };
            node.Transform = Matrix2D.identity;

            // The pattern node will be wrapped in a scaling node if content isn't world relative
            var patternNode = patternFill.Pattern;
            if (!data.ContentWorldRelative)
            {
                patternNode = new SceneNode() {
                    Transform = Matrix2D.Scale(nodeBounds.size),
                    Children = new List<SceneNode> { patternFill.Pattern }
                };
            }

            PostProcess(patternNode); // This will take care of adjusting gradients/inner-patterns

            // Duplicate the filling pattern
            var grid = new SceneNode() {
                Transform = data.PatternTransform,
                Children = new List<SceneNode>(20)
            };

            var fill = new SceneNode() {
                Transform = Matrix2D.identity,
                Children = new List<SceneNode> { grid },
                Clipper = node
            };

            // SVG patterns are clipped in their respective "boxes"
            var clippingBox = new Shape();
            VectorUtils.MakeRectangleShape(clippingBox,  new Rect(0,0,patternRect.width, patternRect.height));

            var box = new SceneNode() {
                Transform = Matrix2D.identity,
                Shapes = new List<Shape> { clippingBox }
            };

            // Compute the bounds of the shape to be filled, taking into account the pattern transform
            var bounds = VectorUtils.SceneNodeBounds(node);
            var invPatternTransform = data.PatternTransform.Inverse();
            var boundVerts = new Vector2[] {
                invPatternTransform * new Vector2(bounds.xMin, bounds.yMin),
                invPatternTransform * new Vector2(bounds.xMax, bounds.yMin),
                invPatternTransform * new Vector2(bounds.xMax, bounds.yMax),
                invPatternTransform * new Vector2(bounds.xMin, bounds.yMax)
            };
            bounds = VectorUtils.Bounds(boundVerts);

            const int kMaxReps = 5000;
            float xCount = bounds.xMax / patternRect.width;
            float yCount = bounds.yMax / patternRect.height;
            if (Mathf.Abs(patternRect.width) < VectorUtils.Epsilon ||
                Mathf.Abs(patternRect.height) < VectorUtils.Epsilon ||
                (xCount*yCount) > kMaxReps)
            {
                Debug.LogWarning("Ignoring pattern which would result in too many repetitions");
                return null;
            }

            // Start the pattern filling process
            var offset = patternRect.position;
            float xStart = (int)(bounds.x / patternRect.width) * patternRect.width - patternRect.width;
            float yStart = (int)(bounds.y / patternRect.height) * patternRect.height - patternRect.height;

            for (float y = yStart; y < bounds.yMax; y += patternRect.height)
            {
                for (float x = xStart; x < bounds.xMax; x += patternRect.width)
                {
                    var pattern = new SceneNode() {
                        Transform = Matrix2D.Translate(new Vector2(x, y) + offset),
                        Children = new List<SceneNode> { patternNode },
                        Clipper = box
                    };
                    grid.Children.Add(pattern);
                }
            }

            replacementNode.Children.Add(fill);
            replacementNode.Children.Add(node);

            return replacementNode;
        }

        void RemoveInvisibleNodes()
        {
            foreach (var n in invisibleNodes)
            {
                if (n.parent.Children != null)
                    n.parent.Children.Remove(n.node);
            }
        }

        #endregion

        delegate void ElemHandler();
        class Handlers : Dictionary<string, ElemHandler>
        {
            public Handlers(int capacity) : base(capacity) {}
        }
        bool ShouldDeclareSupportedChildren(XmlReaderIterator.Node node) { return !subTags.ContainsKey(node.Name); }
        void SupportElems(XmlReaderIterator.Node node, params ElemHandler[] handlers)
        {
            var elems = new Handlers(handlers.Length);
            foreach (var h in handlers)
                elems[h.Method.Name] = h;
            subTags[node.Name] = elems;
        }

        static char[] whiteSpaceNumberChars = " \r\n\t,".ToCharArray();
        enum DimType { Width, Height, Length };
        XmlReaderIterator docReader;
        Scene scene;
        float dpiScale;
        int windowWidth, windowHeight;
        Vector2 scenePos, sceneSize;
        SVGDictionary svgObjects = new SVGDictionary(); // Named elements are looked up in this
        Dictionary<string, Handlers> subTags = new Dictionary<string, Handlers>(); // For each element, the set of elements supported as its children
        Dictionary<GradientFill, GradientExData> gradientExInfo = new Dictionary<GradientFill, GradientExData>();
        Dictionary<SceneNode, ViewBoxInfo> symbolViewBoxes = new Dictionary<SceneNode, ViewBoxInfo>();
        Dictionary<SceneNode, NodeGlobalSceneState> nodeGlobalSceneState = new Dictionary<SceneNode, NodeGlobalSceneState>();
        Dictionary<SceneNode, float> nodeOpacity = new Dictionary<SceneNode, float>();
        Dictionary<string, SceneNode> nodeIDs = new Dictionary<string, SceneNode>();
        Dictionary<SceneNode, SVGStyleResolver.StyleLayer> nodeStyleLayers = new Dictionary<SceneNode, SVGStyleResolver.StyleLayer>();
        Dictionary<SceneNode, ClipData> clipData = new Dictionary<SceneNode, ClipData>();
        Dictionary<SceneNode, PatternData> patternData = new Dictionary<SceneNode, PatternData>();
        Dictionary<SceneNode, MaskData> maskData = new Dictionary<SceneNode, MaskData>();
        Dictionary<string, List<NodeReferenceData>> postponedSymbolData = new Dictionary<string, List<NodeReferenceData>>();
        Dictionary<string, List<PostponedStopData>> postponedStopData = new Dictionary<string, List<PostponedStopData>>();
        Dictionary<string, List<PostponedClip>> postponedClip = new Dictionary<string, List<PostponedClip>>();
        SVGPostponedFills postponedFills = new SVGPostponedFills();
        List<NodeWithParent> invisibleNodes = new List<NodeWithParent>();
        Stack<Vector2> currentContainerSize = new Stack<Vector2>();
        Stack<Vector2> currentViewBoxSize = new Stack<Vector2>();
        Stack<SceneNode> currentSceneNode = new Stack<SceneNode>();
        GradientFill currentGradientFill;
        string currentGradientId;
        string currentGradientLink;
        ElemHandler[] allElems;
        HashSet<ElemHandler> elemsToAddToHierarchy;
        SVGStyleResolver styles = new SVGStyleResolver();
        bool applyRootViewBox;

        internal Rect sceneViewport;

        struct NodeGlobalSceneState
        {
            public Vector2 ContainerSize;
        }

        class GradientExData
        {
            public bool WorldRelative;
            public Matrix2D FillTransform;
        }

        class LinearGradientExData : GradientExData
        {
            public string X1, Y1, X2, Y2;
        }

        class RadialGradientExData : GradientExData
        {
            public bool Parsed;
            public string Cx, Cy, Fx, Fy, R;
        }

        struct ClipData
        {
            public bool WorldRelative;
        }

        struct PatternData
        {
            public bool WorldRelative;
            public bool ContentWorldRelative;
            public Matrix2D PatternTransform;
        }

        struct MaskData
        {
            public bool WorldRelative;
            public bool ContentWorldRelative;
        }

        struct NodeWithParent
        {
            public SceneNode node;
            public SceneNode parent;
        }

        struct NodeReferenceData
        {
            public SceneNode node;
            public Rect viewport;
            public string id;
        }

        struct PostponedStopData
        {
            public GradientFill fill;
        }

        struct PostponedClip
        {
            public SceneNode node;
        }
    }

    internal enum Inheritance
    {
        None,
        Inherited
    }

    internal class SVGStyleResolver
    {
        public void PushNode(XmlReaderIterator.Node node)
        {
            var nodeData = new NodeData();
            nodeData.node = node;
            nodeData.name = node.Name;
            var klass = node["class"];
            if (klass != null)
                nodeData.classes = node["class"].Split(' ').Select(x => x.Trim()).ToList();
            else
                nodeData.classes = new List<string>();
            nodeData.classes = SortedClasses(nodeData.classes).ToList();
            nodeData.id = node["id"];

            var layer = new StyleLayer();
            layer.nodeData = nodeData;
            layer.attributeSheet = node.GetAttributes();
            layer.styleSheet = new SVGStyleSheet();

            var cssText = node["style"];
            if (cssText != null)
            {
                var props = SVGStyleSheetUtils.ParseInline(cssText);
                layer.styleSheet[node.Name] = props;
            }

            PushLayer(layer);
        }

        public void PopNode()
        {
            PopLayer();
        }

        public void PushLayer(StyleLayer layer)
        {
            layers.Add(layer);
        }

        public void PopLayer()
        {
            if (layers.Count == 0)
                throw SVGFormatException.StackError;

            layers.RemoveAt(layers.Count - 1);
        }

        public StyleLayer PeekLayer()
        {
            if (layers.Count == 0)
                return null;
            return layers[layers.Count-1];
        }

        public void SaveLayerForSceneNode(SceneNode node)
        {
            nodeLayers[node] = PeekLayer();
        }

        public StyleLayer GetLayerForScenNode(SceneNode node)
        {
            if (!nodeLayers.ContainsKey(node))
                return null;
            return nodeLayers[node];
        }

        public void SetGlobalStyleSheet(SVGStyleSheet sheet)
        {
            foreach (var sel in sheet.selectors)
                globalStyleSheet[sel] = sheet[sel];
        }

        public string Evaluate(string attribName, Inheritance inheritance = Inheritance.None)
        {
            for (int i = layers.Count-1; i >= 0; --i)
            {
                string attrib = null;
                if (LookupStyleOrAttribute(layers[i], attribName, inheritance, out attrib))
                    return attrib;
                
                if (inheritance == Inheritance.None)
                    break;
            }
            return null;
        }

        private bool LookupStyleOrAttribute(StyleLayer layer, string attribName, Inheritance inheritance, out string attrib)
        {
            // Try to match a CSS style first
            if (LookupProperty(layer.nodeData, attribName, layer.styleSheet, out attrib))
                return true;

            // Try to match a global CSS style
            if (LookupProperty(layer.nodeData, attribName, globalStyleSheet, out attrib))
                return true;

            // Else, fallback on attribute
            if (layer.attributeSheet.ContainsKey(attribName))
            {
                attrib = layer.attributeSheet[attribName];
                return true;
            }

            return false;
        }

        private bool LookupProperty(NodeData nodeData, string attribName, SVGStyleSheet sheet, out string val)
        {
            var id = string.IsNullOrEmpty(nodeData.id) ? null : "#" + nodeData.id;
            var name = string.IsNullOrEmpty(nodeData.name) ? null : nodeData.name;

            if (LookupPropertyInSheet(sheet, attribName, id, out val))
                return true;

            foreach (var c in nodeData.classes)
            {
                var klass = "." + c;
                if (LookupPropertyInSheet(sheet, attribName, klass, out val))
                    return true;
            }

            if (LookupPropertyInSheet(sheet, attribName, name, out val))
                return true;

            if (LookupPropertyInSheet(sheet, attribName, "*", out val))
                return true;

            val = null;
            return false;
        }

        private bool LookupPropertyInSheet(SVGStyleSheet sheet, string attribName, string selector, out string val)
        {
            if (selector == null)
            {
                val = null;
                return false;
            }

            if (sheet.selectors.Contains(selector))
            {
                var props = sheet[selector];
                if (props.ContainsKey(attribName))
                {
                    val = props[attribName];
                    return true;
                }
            }

            val = null;
            return false;
        }

        private IEnumerable<string> SortedClasses(List<string> classes)
        {
            // We may not have parsed the global sheets yet (happens when setting a class on the root <svg> element).
            if (globalStyleSheet.selectors.Count() == 0)
            {
                foreach (var klass in classes)
                    yield return klass;
            }

            // We match classes in reverse order of their appearance. This isn't conformant to CSS selectors priority,
            // but this works well enough for auto-generated CSS styles.
            foreach (var sel in globalStyleSheet.selectors.Reverse())
            {
                if (sel[0] != '.')
                    continue;
                var klass = sel.Substring(1);
                if (classes.Contains(klass))
                    yield return klass;
            }
        }

        public struct NodeData
        {
            public XmlReaderIterator.Node node;
            public string name;
            public List<string> classes;
            public string id;
        }

        public class StyleLayer
        {
            public SVGStyleSheet styleSheet;
            public SVGPropertySheet attributeSheet;
            public NodeData nodeData;
        }

        private List<StyleLayer> layers = new List<StyleLayer>();
        private SVGStyleSheet globalStyleSheet = new SVGStyleSheet();
        private Dictionary<SceneNode, StyleLayer> nodeLayers = new Dictionary<SceneNode, StyleLayer>();
    }

    internal class SVGAttribParser
    {
        public static List<BezierContour> ParsePath(XmlReaderIterator.Node node)
        {
            string path = node["d"];
            if (string.IsNullOrEmpty(path))
                return null;

            try
            {
                return (new SVGAttribParser(path, AttribPath.Path)).contours;
            }
            catch (Exception e)
            {
                throw node.GetException(e.Message);
            }
        }

        public static Matrix2D ParseTransform(XmlReaderIterator.Node node)
        {
            return ParseTransform(node, "transform");
        }

        public static Matrix2D ParseTransform(XmlReaderIterator.Node node, string attribName)
        {
            // Transforms aren't part of styling and shouldn't be evaluated,
            // they have to be specified as node attributes
            string transform = node[attribName];
            if (string.IsNullOrEmpty(transform))
                return Matrix2D.identity;
            try
            {
                return (new SVGAttribParser(transform, attribName, AttribTransform.Transform)).transform;
            }
            catch (Exception e)
            {
                throw node.GetException(e.Message);
            }
        }

        public static IFill ParseFill(XmlReaderIterator.Node node, SVGDictionary dict, SVGPostponedFills postponedFills, SVGStyleResolver styles, Inheritance inheritance = Inheritance.Inherited)
        {
            bool isDefaultFill;
            return ParseFill(node, dict, postponedFills, styles, inheritance, out isDefaultFill);
        }

        public static IFill ParseFill(XmlReaderIterator.Node node, SVGDictionary dict, SVGPostponedFills postponedFills, SVGStyleResolver styles, Inheritance inheritance, out bool isDefaultFill)
        {
            string opacityAttrib = styles.Evaluate("fill-opacity", inheritance);
            float opacity = (opacityAttrib != null) ? ParseFloat(opacityAttrib) : 1.0f;
            string fillMode = styles.Evaluate("fill-rule", inheritance);
            FillMode mode = FillMode.NonZero;
            if (fillMode != null)
            {
                if (fillMode == "nonzero")
                    mode = FillMode.NonZero;
                else if (fillMode == "evenodd")
                    mode = FillMode.OddEven;
                else throw new Exception("Unknown fill-rule: " + fillMode);
            }

            try
            {
                var fill = styles.Evaluate("fill", inheritance);
                isDefaultFill = (fill == null && opacityAttrib == null);
                return (new SVGAttribParser(fill, "fill", opacity, mode, dict, postponedFills)).fill;
            }
            catch (Exception e)
            {
                throw node.GetException(e.Message);
            }
        }

        public static Stroke ParseStrokeAndOpacity(XmlReaderIterator.Node node, SVGDictionary dict, SVGStyleResolver styles, Inheritance inheritance = Inheritance.Inherited)
        {
            string strokeAttrib = styles.Evaluate("stroke", inheritance);
            if (string.IsNullOrEmpty(strokeAttrib))
                return null; // If stroke is not specified, no other stroke properties matter

            string opacityAttrib = styles.Evaluate("stroke-opacity", inheritance);
            float opacity = (opacityAttrib != null) ? ParseFloat(opacityAttrib) : 1.0f;

            IFill strokeFill = null;
            try
            {
                strokeFill = (new SVGAttribParser(strokeAttrib, "stroke", opacity, FillMode.NonZero, dict, null)).fill;
            }
            catch (Exception e)
            {
                throw node.GetException(e.Message);
            }

            if (strokeFill == null)
                return null;

            return new Stroke() { Fill = strokeFill };
        }

        public static Color ParseColor(string colorString)
        {
            if (colorString[0] == '#')
            {
                // Hex format
                var hexVal = UInt32.Parse(colorString.Substring(1), NumberStyles.HexNumber);
                if (colorString.Length == 4)
                {
                    // #ABC >> #AABBCC
                    return new Color(
                        ((((hexVal >> 8) & 0xF) << 0) | (((hexVal >> 8) & 0xF) << 4)) / 255.0f,
                        ((((hexVal >> 4) & 0xF) << 0) | (((hexVal >> 4) & 0xF) << 4)) / 255.0f,
                        ((((hexVal >> 0) & 0xF) << 0) | (((hexVal >> 0) & 0xF) << 4)) / 255.0f);
                }
                else
                {
                    // #ABCDEF
                    return new Color(
                        ((hexVal >> 16) & 0xFF) / 255.0f,
                        ((hexVal >> 8) & 0xFF) / 255.0f,
                        ((hexVal >> 0) & 0xFF) / 255.0f);
                }
            }
            if (colorString.StartsWith("rgb(") && colorString.EndsWith(")"))
            {
                string numbersString = colorString.Substring(4, colorString.Length-5);
                string[] numbers = numbersString.Split(new char[] { ',', '%' }, StringSplitOptions.RemoveEmptyEntries);
                if (numbers.Length != 3)
                    throw new Exception("Invalid rgb() color specification");
                float divisor = colorString.Contains("%") ? 100.0f : 255.0f;
                return new Color(Byte.Parse(numbers[0]) / divisor, Byte.Parse(numbers[1]) / divisor, Byte.Parse(numbers[2]) / divisor);
            }
            else if (colorString.StartsWith("rgba(") && colorString.EndsWith(")"))
            {
                string numbersString = colorString.Substring(5, colorString.Length-6);
                string[] numbers = numbersString.Split(new char[] { ',', '%' }, StringSplitOptions.RemoveEmptyEntries);
                if (numbers.Length != 4)
                    throw new Exception("Invalid rgba() color specification");
                float divisor = colorString.Contains("%") ? 100.0f : 255.0f;
                return new Color(
                    Byte.Parse(numbers[0]) / divisor,
                    Byte.Parse(numbers[1]) / divisor,
                    Byte.Parse(numbers[2]) / divisor,
                    divisor == 100.0f ? Byte.Parse(numbers[3]) / divisor : ParseFloat(numbers[3]));
            }

            // Named color
            if (namedColors == null)
                namedColors = new NamedWebColorDictionary();
            return namedColors[colorString.ToLower()];
        }

        public static string ParseURLRef(string url)
        {
            if (url.StartsWith("url(") && url.EndsWith(")"))
                return url.Substring(4, url.Length - 5);
            return null;
        }

        public static object ParseRelativeRef(string iri, SVGDictionary dict)
        {
            if (iri == null)
                return null;

            if (!iri.StartsWith("#"))
                throw new Exception("Unsupported reference type (" + iri + ")");
            iri = iri.Substring(1);
            object obj;
            dict.TryGetValue(iri, out obj);
            return obj;
        }

        public static string CleanIri(string iri)
        {
            if (iri == null)
                return null;
            if (!iri.StartsWith("#"))
                throw new Exception("Unsupported reference type (" + iri + ")");
            iri = iri.Substring(1);
            return iri;
        }

        SVGAttribParser(string attrib, AttribPath attribPath)
        {
            attribName = "path";
            attribString = attrib;
            NextPathCommand(true);
            if (pathCommand != 'm' && pathCommand != 'M')
                throw new Exception("Path must start with a MoveTo pathCommand");

            char lastCmdNoCase = '\0';
            Vector2 lastQCtrlPoint = Vector2.zero;

            while (NextPathCommand() != (char)0)
            {
                bool relative = (pathCommand >= 'a') && (pathCommand <= 'z');
                char cmdNoCase = char.ToLower(pathCommand);
                if (cmdNoCase == 'm') // Move-to
                {
                    penPos = NextVector2(relative);
                    pathCommand = relative ? 'l' : 'L'; // After a move-to, we automatically switch to a line-to of the same relativity
                    ConcludePath(false);
                }
                else if (cmdNoCase == 'z') // ClosePath
                {
                    if (currentContour.First != null)
                        penPos = currentContour.First.Value.P0;
                    ConcludePath(true);
                }
                else if (cmdNoCase == 'l') // Line-to
                {
                    var to = NextVector2(relative);
                    if ((to - penPos).magnitude > VectorUtils.Epsilon)
                        currentContour.AddLast(VectorUtils.MakeLine(penPos, to));
                    penPos = to;
                }
                else if (cmdNoCase == 'h') // Horizontal-line-to
                {
                    float x = relative ? penPos.x + NextFloat() : NextFloat();
                    var to = new Vector2(x, penPos.y);
                    if ((to - penPos).magnitude > VectorUtils.Epsilon)
                        currentContour.AddLast(VectorUtils.MakeLine(penPos, to));
                    penPos = to;
                }
                else if (cmdNoCase == 'v') // Vertical-line-to
                {
                    float y = relative ? penPos.y + NextFloat() : NextFloat();
                    var to = new Vector2(penPos.x, y);
                    if ((to - penPos).magnitude > VectorUtils.Epsilon)
                        currentContour.AddLast(VectorUtils.MakeLine(penPos, to));
                    penPos = to;
                }
                else if (cmdNoCase == 'c' || cmdNoCase == 'q') // Cubic-bezier-curve or quadratic-bezier-curve
                {
                    // If relative, the pen position is on P0 and is only moved to P3
                    BezierSegment bs = new BezierSegment();
                    bs.P0 = penPos;
                    bs.P1 = NextVector2(relative);
                    if (cmdNoCase == 'c')
                        bs.P2 = NextVector2(relative);
                    bs.P3 = NextVector2(relative);

                    if (cmdNoCase == 'q')
                    {
                        lastQCtrlPoint = bs.P1;
                        var t = 2.0f/3.0f;
                        bs.P1 = bs.P0 + t * (lastQCtrlPoint - bs.P0);
                        bs.P2 = bs.P3 + t * (lastQCtrlPoint - bs.P3);
                    }

                    penPos = bs.P3;

                    if (!VectorUtils.IsEmptySegment(bs))
                        currentContour.AddLast(bs);
                }
                else if (cmdNoCase == 's' || cmdNoCase == 't') // Smooth cubic-bezier-curve or smooth quadratic-bezier-curve
                {
                    Vector2 reflectedP1 = penPos;
                    if (currentContour.Count > 0 && (lastCmdNoCase == 'c' || lastCmdNoCase == 'q' || lastCmdNoCase == 's' || lastCmdNoCase == 't'))
                        reflectedP1 += currentContour.Last.Value.P3 - ((lastCmdNoCase == 'q' || lastCmdNoCase == 't') ? lastQCtrlPoint : currentContour.Last.Value.P2);

                    // If relative, the pen position is on P0 and is only moved to P3
                    BezierSegment bs = new BezierSegment();
                    bs.P0 = penPos;
                    bs.P1 = reflectedP1;
                    if (cmdNoCase == 's')
                        bs.P2 = NextVector2(relative);
                    bs.P3 = NextVector2(relative);

                    if (cmdNoCase == 't')
                    {
                        lastQCtrlPoint = bs.P1;
                        var t = 2.0f / 3.0f;
                        bs.P1 = bs.P0 + t * (lastQCtrlPoint - bs.P0);
                        bs.P2 = bs.P3 + t * (lastQCtrlPoint - bs.P3);
                    }

                    penPos = bs.P3;

                    if (!VectorUtils.IsEmptySegment(bs))
                        currentContour.AddLast(bs);
                }
                else if (cmdNoCase == 'a') // Elliptical-arc-to
                {
                    Vector2 radii = NextVector2();
                    float xAxisRotation = NextFloat();
                    bool largeArcFlag = NextBool();
                    bool sweepFlag = NextBool();
                    Vector2 to = NextVector2(relative);

                    if (radii.magnitude <= VectorUtils.Epsilon)
                    {
                        if ((to - penPos).magnitude > VectorUtils.Epsilon)
                            currentContour.AddLast(VectorUtils.MakeLine(penPos, to));
                    }
                    else
                    {
                        var ellipsePath = VectorUtils.BuildEllipsePath(penPos, to, -xAxisRotation * Mathf.Deg2Rad, radii.x, radii.y, largeArcFlag, sweepFlag);
                        foreach (var seg in VectorUtils.SegmentsInPath(ellipsePath))
                            currentContour.AddLast(seg);
                    }

                    penPos = to;
                }

                lastCmdNoCase = cmdNoCase;

            } // While commands exist in the string

            ConcludePath(false);
        }

        SVGAttribParser(string attrib, string attribNameVal, AttribTransform attribTransform)
        {
            attribString = attrib;
            attribName = attribNameVal;
            transform = Matrix2D.identity;
            while (stringPos < attribString.Length)
            {
                int cmdPos = stringPos;
                var trasformCommand = NextStringCommand();
                if (string.IsNullOrEmpty(trasformCommand))
                    return;
                SkipSymbol('(');

                if (trasformCommand == "matrix")
                {
                    Matrix2D mat = new Matrix2D();
                    mat.m00 = NextFloat();
                    mat.m10 = NextFloat();
                    mat.m01 = NextFloat();
                    mat.m11 = NextFloat();
                    mat.m02 = NextFloat();
                    mat.m12 = NextFloat();
                    transform *= mat;
                }
                else if (trasformCommand == "translate")
                {
                    float x = NextFloat();
                    float y = 0;
                    if (!PeekSymbol(')'))
                        y = NextFloat();
                    transform *= Matrix2D.Translate(new Vector2(x, y));
                }
                else if (trasformCommand == "scale")
                {
                    float x = NextFloat();
                    float y = x;
                    if (!PeekSymbol(')'))
                        y = NextFloat();
                    transform *= Matrix2D.Scale(new Vector2(x, y));
                }
                else if (trasformCommand == "rotate")
                {
                    float a = NextFloat() * Mathf.Deg2Rad;
                    float cx = 0, cy = 0;
                    if (!PeekSymbol(')'))
                    {
                        cx = NextFloat();
                        cy = NextFloat();
                    }
                    transform *= Matrix2D.Translate(new Vector2(cx, cy)) * Matrix2D.RotateLH(-a) * Matrix2D.Translate(new Vector2(-cx, -cy));
                }
                else if ((trasformCommand == "skewX") || (trasformCommand == "skewY"))
                {
                    float a = Mathf.Tan(NextFloat() * Mathf.Deg2Rad);
                    Matrix2D mat = Matrix2D.identity;
                    if (trasformCommand == "skewY")
                        mat.m10 = a;
                    else mat.m01 = a;
                    transform *= mat;
                }
                else throw new Exception("Unknown transform command at " + cmdPos + " in trasform specification");

                SkipSymbol(')');
            }
        }

        SVGAttribParser(string attrib, string attribName, float opacity, FillMode mode, SVGDictionary dict, SVGPostponedFills postponedFills, bool allowReference = true)
        {
            this.attribName = attribName;
            if (string.IsNullOrEmpty(attrib))
            {
                if (opacity < 1.0f)
                    fill = new SolidFill() { Color = new Color(0, 0, 0, opacity) };
                else
                    fill = dict[mode == FillMode.NonZero ?
                                SVGDocument.StockBlackNonZeroFillName :
                                SVGDocument.StockBlackOddEvenFillName] as IFill;
                return;
            }

            if (attrib == "none" || attrib == "transparent")
                return;

            if (attrib == "currentColor")
            {
                Debug.LogError("currentColor is not supported as a " + attribName + " value");
                return;
            }

            string[] paintParts = attrib.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            if (allowReference)
            {
                string reference = ParseURLRef(paintParts[0]);
                if (reference != null)
                {
                    fill = ParseRelativeRef(reference, dict) as IFill;
                    if (fill == null)
                    {
                        if (paintParts.Length > 1)
                        {
                            fill = (new SVGAttribParser(paintParts[1], attribName, opacity, mode, dict, postponedFills, false)).fill;
                        }
                        else if (postponedFills != null)
                        {
                            // The reference doesn't exist, but may be defined later in the file.
                            // Make a dummy fill to be replaced later.
                            fill = new SolidFill() { Color = Color.clear };
                            postponedFills[fill] = reference;
                        }
                    }

                    if (fill != null)
                        fill.Opacity = opacity;
    
                    return;
                }
            }

            var clr = ParseColor(string.Join("", paintParts));
            clr.a *= opacity;
            if (paintParts.Length > 1)
            {
                // TODO: Support ICC-Color
            }
            fill = new SolidFill() { Color = clr, Mode = mode };
        }

        void ConcludePath(bool joinEnds)
        {
            // No need to manually close the path with the last line. It is implied.
            //if (joinEnds && currentPath.Count >= 2)
            //{
            //    BezierSegment bs = new BezierSegment();
            //    bs.MakeLine(currentPath.Last.Value.P3, currentPath.First.Value.P0);
            //    currentPath.AddLast(bs);
            //}
            if (currentContour.Count > 0)
            {
                BezierContour contour = new BezierContour();
                contour.Closed = joinEnds && (currentContour.Count >= 1);
                contour.Segments = new BezierPathSegment[currentContour.Count + 1];
                int index = 0;
                foreach (var bs in currentContour)
                    contour.Segments[index++] = new BezierPathSegment() { P0 = bs.P0, P1 = bs.P1, P2 = bs.P2  };
                var connect = VectorUtils.MakeLine(currentContour.Last.Value.P3, contour.Segments[0].P0);
                contour.Segments[index] = new BezierPathSegment() { P0 = connect.P0, P1 = connect.P1, P2 = connect.P2 };
                contours.Add(contour);
            }
            currentContour.Clear(); // Restart a new path
        }

        Vector2 NextVector2(bool relative = false)
        {
            var v = new Vector2(NextFloat(), NextFloat());
            return relative ? v + penPos : v;
        }

        float NextFloat()
        {
            SkipWhitespaces();
            if (stringPos >= attribString.Length)
                throw new Exception(attribName + " specification ended before sufficing numbers required by the last pathCommand");

            int startPos = stringPos;
            if (attribString[stringPos] == '-')
                stringPos++; // Skip over the negative sign if it exists

            bool gotPeriod = false;
            bool gotE = false;
            while (stringPos < attribString.Length)
            {
                char c = attribString[stringPos];
                if (!gotPeriod && (c == '.'))
                {
                    gotPeriod = true;
                    stringPos++;
                    continue;
                }
                if (!gotE && ((c == 'e') || (c == 'E')))
                {
                    gotE = true;
                    stringPos++;
                    if ((stringPos < attribString.Length) && (attribString[stringPos] == '-'))
                        stringPos++; // Skip over the negative sign if it exists for the e
                    continue;
                }
                if (!char.IsDigit(c))
                    break;
                stringPos++;
            }

            if ((stringPos - startPos == 0) ||
                ((stringPos - startPos == 1) && attribString[startPos] == '-'))
                throw new Exception("Missing number at " + startPos + " in " + attribName + " specification");

            return ParseFloat(attribString.Substring(startPos, stringPos - startPos));
        }

        internal static float ParseFloat(string s)
        {
            return float.Parse(s, NumberStyles.Number | NumberStyles.AllowExponent, CultureInfo.InvariantCulture);
        }

        bool NextBool()
        {
            return Mathf.Abs(NextFloat()) > VectorUtils.Epsilon;
        }

        char NextPathCommand(bool noCommandInheritance = false)
        {
            SkipWhitespaces();
            if (stringPos >= attribString.Length)
                return (char)0;

            char newCmd = attribString[stringPos];
            if ((newCmd >= 'a' && newCmd <= 'z') || (newCmd >= 'A' && newCmd <= 'Z'))
            {
                pathCommand = newCmd;
                stringPos++;
                return newCmd;
            }

            if (!noCommandInheritance && (char.IsDigit(newCmd) || (newCmd == '.') || (newCmd == '-')))
                return pathCommand; // Stepped onto a number, which means we keep the last pathCommand
            throw new Exception("Unexpected character at " + stringPos + " in path specification");
        }

        string NextStringCommand()
        {
            SkipWhitespaces();
            if (stringPos >= attribString.Length)
                return null;

            int startPos = stringPos;
            while (stringPos < attribString.Length)
            {
                char c = attribString[stringPos];
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
                    stringPos++;
                else break;
            }

            if (stringPos - startPos == 0)
                throw new Exception("Unexpected character at " + stringPos + " in " + attribName + " specification");

            return attribString.Substring(startPos, stringPos - startPos);
        }

        void SkipSymbol(char s)
        {
            SkipWhitespaces();
            if (stringPos >= attribString.Length || (attribString[stringPos] != s))
                throw new Exception("Expected " + s + " at " + stringPos + " of " + attribName + " specification");
            stringPos++;
        }

        bool PeekSymbol(char s)
        {
            SkipWhitespaces();
            return (stringPos < attribString.Length) && (attribString[stringPos] == s);
        }

        void SkipWhitespaces()
        {
            while (stringPos < attribString.Length)
            {
                switch (attribString[stringPos])
                {
                    case ' ':
                    case '\r':
                    case '\n':
                    case '\t':
                    case ',':
                        stringPos++;
                        break;
                    default:
                        return;
                }
            }
        }

        enum AttribPath { Path };
        enum AttribTransform { Transform };
        enum AttribStroke { Stroke };

        // Path data
        LinkedList<BezierSegment> currentContour = new LinkedList<BezierSegment>();
        List<BezierContour> contours = new List<BezierContour>();
        Vector2 penPos;
        string attribString;
        char pathCommand;

        // Transform data
        Matrix2D transform;

        // Fill data
        IFill fill;

        // Parsing data
        string attribName;
        int stringPos;

        static NamedWebColorDictionary namedColors;
    }

    class NamedWebColorDictionary : Dictionary<string, Color>
    {
        public NamedWebColorDictionary()
        {
            this["aliceblue"] = new Color(240.0f / 255.0f, 248.0f / 255.0f, 255.0f / 255.0f);
            this["antiquewhite"] = new Color(250.0f / 255.0f, 235.0f / 255.0f, 215.0f / 255.0f);
            this["aqua"] = new Color(0.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f);
            this["aquamarine"] = new Color(127.0f / 255.0f, 255.0f / 255.0f, 212.0f / 255.0f);
            this["azure"] = new Color(240.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f);
            this["beige"] = new Color(245.0f / 255.0f, 245.0f / 255.0f, 220.0f / 255.0f);
            this["bisque"] = new Color(255.0f / 255.0f, 228.0f / 255.0f, 196.0f / 255.0f);
            this["black"] = new Color(0.0f / 255.0f, 0.0f / 255.0f, 0.0f / 255.0f);
            this["blanchedalmond"] = new Color(255.0f / 255.0f, 235.0f / 255.0f, 205.0f / 255.0f);
            this["blue"] = new Color(0.0f / 255.0f, 0.0f / 255.0f, 255.0f / 255.0f);
            this["blueviolet"] = new Color(138.0f / 255.0f, 43.0f / 255.0f, 226.0f / 255.0f);
            this["brown"] = new Color(165.0f / 255.0f, 42.0f / 255.0f, 42.0f / 255.0f);
            this["burlywood"] = new Color(222.0f / 255.0f, 184.0f / 255.0f, 135.0f / 255.0f);
            this["cadetblue"] = new Color(95.0f / 255.0f, 158.0f / 255.0f, 160.0f / 255.0f);
            this["chartreuse"] = new Color(127.0f / 255.0f, 255.0f / 255.0f, 0.0f / 255.0f);
            this["chocolate"] = new Color(210.0f / 255.0f, 105.0f / 255.0f, 30.0f / 255.0f);
            this["coral"] = new Color(255.0f / 255.0f, 127.0f / 255.0f, 80.0f / 255.0f);
            this["cornflowerblue"] = new Color(100.0f / 255.0f, 149.0f / 255.0f, 237.0f / 255.0f);
            this["cornsilk"] = new Color(255.0f / 255.0f, 248.0f / 255.0f, 220.0f / 255.0f);
            this["crimson"] = new Color(220.0f / 255.0f, 20.0f / 255.0f, 60.0f / 255.0f);
            this["cyan"] = new Color(0.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f);
            this["darkblue"] = new Color(0.0f / 255.0f, 0.0f / 255.0f, 139.0f / 255.0f);
            this["darkcyan"] = new Color(0.0f / 255.0f, 139.0f / 255.0f, 139.0f / 255.0f);
            this["darkgoldenrod"] = new Color(184.0f / 255.0f, 134.0f / 255.0f, 11.0f / 255.0f);
            this["darkgray"] = new Color(169.0f / 255.0f, 169.0f / 255.0f, 169.0f / 255.0f);
            this["darkgrey"] = new Color(169.0f / 255.0f, 169.0f / 255.0f, 169.0f / 255.0f);
            this["darkgreen"] = new Color(0.0f / 255.0f, 100.0f / 255.0f, 0.0f / 255.0f);
            this["darkkhaki"] = new Color(189.0f / 255.0f, 183.0f / 255.0f, 107.0f / 255.0f);
            this["darkmagenta"] = new Color(139.0f / 255.0f, 0.0f / 255.0f, 139.0f / 255.0f);
            this["darkolivegreen"] = new Color(85.0f / 255.0f, 107.0f / 255.0f, 47.0f / 255.0f);
            this["darkorange"] = new Color(255.0f / 255.0f, 140.0f / 255.0f, 0.0f / 255.0f);
            this["darkorchid"] = new Color(153.0f / 255.0f, 50.0f / 255.0f, 204.0f / 255.0f);
            this["darkred"] = new Color(139.0f / 255.0f, 0.0f / 255.0f, 0.0f / 255.0f);
            this["darksalmon"] = new Color(233.0f / 255.0f, 150.0f / 255.0f, 122.0f / 255.0f);
            this["darkseagreen"] = new Color(143.0f / 255.0f, 188.0f / 255.0f, 143.0f / 255.0f);
            this["darkslateblue"] = new Color(72.0f / 255.0f, 61.0f / 255.0f, 139.0f / 255.0f);
            this["darkslategray"] = new Color(47.0f / 255.0f, 79.0f / 255.0f, 79.0f / 255.0f);
            this["darkslategrey"] = new Color(47.0f / 255.0f, 79.0f / 255.0f, 79.0f / 255.0f);
            this["darkturquoise"] = new Color(0.0f / 255.0f, 206.0f / 255.0f, 209.0f / 255.0f);
            this["darkviolet"] = new Color(148.0f / 255.0f, 0.0f / 255.0f, 211.0f / 255.0f);
            this["deeppink"] = new Color(255.0f / 255.0f, 20.0f / 255.0f, 147.0f / 255.0f);
            this["deepskyblue"] = new Color(0.0f / 255.0f, 191.0f / 255.0f, 255.0f / 255.0f);
            this["dimgray"] = new Color(105.0f / 255.0f, 105.0f / 255.0f, 105.0f / 255.0f);
            this["dimgrey"] = new Color(105.0f / 255.0f, 105.0f / 255.0f, 105.0f / 255.0f);
            this["dodgerblue"] = new Color(30.0f / 255.0f, 144.0f / 255.0f, 255.0f / 255.0f);
            this["firebrick"] = new Color(178.0f / 255.0f, 34.0f / 255.0f, 34.0f / 255.0f);
            this["floralwhite"] = new Color(255.0f / 255.0f, 250.0f / 255.0f, 240.0f / 255.0f);
            this["forestgreen"] = new Color(34.0f / 255.0f, 139.0f / 255.0f, 34.0f / 255.0f);
            this["fuchsia"] = new Color(255.0f / 255.0f, 0.0f / 255.0f, 255.0f / 255.0f);
            this["gainsboro"] = new Color(220.0f / 255.0f, 220.0f / 255.0f, 220.0f / 255.0f);
            this["ghostwhite"] = new Color(248.0f / 255.0f, 248.0f / 255.0f, 255.0f / 255.0f);
            this["gold"] = new Color(255.0f / 255.0f, 215.0f / 255.0f, 0.0f / 255.0f);
            this["goldenrod"] = new Color(218.0f / 255.0f, 165.0f / 255.0f, 32.0f / 255.0f);
            this["gray"] = new Color(128.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f);
            this["grey"] = new Color(128.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f);
            this["green"] = new Color(0.0f / 255.0f, 128.0f / 255.0f, 0.0f / 255.0f);
            this["greenyellow"] = new Color(173.0f / 255.0f, 255.0f / 255.0f, 47.0f / 255.0f);
            this["honeydew"] = new Color(240.0f / 255.0f, 255.0f / 255.0f, 240.0f / 255.0f);
            this["hotpink"] = new Color(255.0f / 255.0f, 105.0f / 255.0f, 180.0f / 255.0f);
            this["indianred"] = new Color(205.0f / 255.0f, 92.0f / 255.0f, 92.0f / 255.0f);
            this["indigo"] = new Color(75.0f / 255.0f, 0.0f / 255.0f, 130.0f / 255.0f);
            this["ivory"] = new Color(255.0f / 255.0f, 255.0f / 255.0f, 240.0f / 255.0f);
            this["khaki"] = new Color(240.0f / 255.0f, 230.0f / 255.0f, 140.0f / 255.0f);
            this["lavender"] = new Color(230.0f / 255.0f, 230.0f / 255.0f, 250.0f / 255.0f);
            this["lavenderblush"] = new Color(255.0f / 255.0f, 240.0f / 255.0f, 245.0f / 255.0f);
            this["lawngreen"] = new Color(124.0f / 255.0f, 252.0f / 255.0f, 0.0f / 255.0f);
            this["lemonchiffon"] = new Color(255.0f / 255.0f, 250.0f / 255.0f, 205.0f / 255.0f);
            this["lightblue"] = new Color(173.0f / 255.0f, 216.0f / 255.0f, 230.0f / 255.0f);
            this["lightcoral"] = new Color(240.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f);
            this["lightcyan"] = new Color(224.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f);
            this["lightgoldenrodyellow"] = new Color(250.0f / 255.0f, 250.0f / 255.0f, 210.0f / 255.0f);
            this["lightgray"] = new Color(211.0f / 255.0f, 211.0f / 255.0f, 211.0f / 255.0f);
            this["lightgrey"] = new Color(211.0f / 255.0f, 211.0f / 255.0f, 211.0f / 255.0f);
            this["lightgreen"] = new Color(144.0f / 255.0f, 238.0f / 255.0f, 144.0f / 255.0f);
            this["lightpink"] = new Color(255.0f / 255.0f, 182.0f / 255.0f, 193.0f / 255.0f);
            this["lightsalmon"] = new Color(255.0f / 255.0f, 160.0f / 255.0f, 122.0f / 255.0f);
            this["lightseagreen"] = new Color(32.0f / 255.0f, 178.0f / 255.0f, 170.0f / 255.0f);
            this["lightskyblue"] = new Color(135.0f / 255.0f, 206.0f / 255.0f, 250.0f / 255.0f);
            this["lightslategray"] = new Color(119.0f / 255.0f, 136.0f / 255.0f, 153.0f / 255.0f);
            this["lightslategrey"] = new Color(119.0f / 255.0f, 136.0f / 255.0f, 153.0f / 255.0f);
            this["lightsteelblue"] = new Color(176.0f / 255.0f, 196.0f / 255.0f, 222.0f / 255.0f);
            this["lightyellow"] = new Color(255.0f / 255.0f, 255.0f / 255.0f, 224.0f / 255.0f);
            this["lime"] = new Color(0.0f / 255.0f, 255.0f / 255.0f, 0.0f / 255.0f);
            this["limegreen"] = new Color(50.0f / 255.0f, 205.0f / 255.0f, 50.0f / 255.0f);
            this["linen"] = new Color(250.0f / 255.0f, 240.0f / 255.0f, 230.0f / 255.0f);
            this["magenta"] = new Color(255.0f / 255.0f, 0.0f / 255.0f, 255.0f / 255.0f);
            this["maroon"] = new Color(128.0f / 255.0f, 0.0f / 255.0f, 0.0f / 255.0f);
            this["mediumaquamarine"] = new Color(102.0f / 255.0f, 205.0f / 255.0f, 170.0f / 255.0f);
            this["mediumblue"] = new Color(0.0f / 255.0f, 0.0f / 255.0f, 205.0f / 255.0f);
            this["mediumorchid"] = new Color(186.0f / 255.0f, 85.0f / 255.0f, 211.0f / 255.0f);
            this["mediumpurple"] = new Color(147.0f / 255.0f, 112.0f / 255.0f, 219.0f / 255.0f);
            this["mediumseagreen"] = new Color(60.0f / 255.0f, 179.0f / 255.0f, 113.0f / 255.0f);
            this["mediumslateblue"] = new Color(123.0f / 255.0f, 104.0f / 255.0f, 238.0f / 255.0f);
            this["mediumspringgreen"] = new Color(0.0f / 255.0f, 250.0f / 255.0f, 154.0f / 255.0f);
            this["mediumturquoise"] = new Color(72.0f / 255.0f, 209.0f / 255.0f, 204.0f / 255.0f);
            this["mediumvioletred"] = new Color(199.0f / 255.0f, 21.0f / 255.0f, 133.0f / 255.0f);
            this["midnightblue"] = new Color(25.0f / 255.0f, 25.0f / 255.0f, 112.0f / 255.0f);
            this["mintcream"] = new Color(245.0f / 255.0f, 255.0f / 255.0f, 250.0f / 255.0f);
            this["mistyrose"] = new Color(255.0f / 255.0f, 228.0f / 255.0f, 225.0f / 255.0f);
            this["moccasin"] = new Color(255.0f / 255.0f, 228.0f / 255.0f, 181.0f / 255.0f);
            this["navajowhite"] = new Color(255.0f / 255.0f, 222.0f / 255.0f, 173.0f / 255.0f);
            this["navy"] = new Color(0.0f / 255.0f, 0.0f / 255.0f, 128.0f / 255.0f);
            this["oldlace"] = new Color(253.0f / 255.0f, 245.0f / 255.0f, 230.0f / 255.0f);
            this["olive"] = new Color(128.0f / 255.0f, 128.0f / 255.0f, 0.0f / 255.0f);
            this["olivedrab"] = new Color(107.0f / 255.0f, 142.0f / 255.0f, 35.0f / 255.0f);
            this["orange"] = new Color(255.0f / 255.0f, 165.0f / 255.0f, 0.0f / 255.0f);
            this["orangered"] = new Color(255.0f / 255.0f, 69.0f / 255.0f, 0.0f / 255.0f);
            this["orchid"] = new Color(218.0f / 255.0f, 112.0f / 255.0f, 214.0f / 255.0f);
            this["palegoldenrod"] = new Color(238.0f / 255.0f, 232.0f / 255.0f, 170.0f / 255.0f);
            this["palegreen"] = new Color(152.0f / 255.0f, 251.0f / 255.0f, 152.0f / 255.0f);
            this["paleturquoise"] = new Color(175.0f / 255.0f, 238.0f / 255.0f, 238.0f / 255.0f);
            this["palevioletred"] = new Color(219.0f / 255.0f, 112.0f / 255.0f, 147.0f / 255.0f);
            this["papayawhip"] = new Color(255.0f / 255.0f, 239.0f / 255.0f, 213.0f / 255.0f);
            this["peachpuff"] = new Color(255.0f / 255.0f, 218.0f / 255.0f, 185.0f / 255.0f);
            this["peru"] = new Color(205.0f / 255.0f, 133.0f / 255.0f, 63.0f / 255.0f);
            this["pink"] = new Color(255.0f / 255.0f, 192.0f / 255.0f, 203.0f / 255.0f);
            this["plum"] = new Color(221.0f / 255.0f, 160.0f / 255.0f, 221.0f / 255.0f);
            this["powderblue"] = new Color(176.0f / 255.0f, 224.0f / 255.0f, 230.0f / 255.0f);
            this["purple"] = new Color(128.0f / 255.0f, 0.0f / 255.0f, 128.0f / 255.0f);
            this["rebeccapurple"] = new Color(102.0f / 255.0f, 51.0f / 255.0f, 153.0f / 255.0f);
            this["red"] = new Color(255.0f / 255.0f, 0.0f / 255.0f, 0.0f / 255.0f);
            this["rosybrown"] = new Color(188.0f / 255.0f, 143.0f / 255.0f, 143.0f / 255.0f);
            this["royalblue"] = new Color(65.0f / 255.0f, 105.0f / 255.0f, 225.0f / 255.0f);
            this["saddlebrown"] = new Color(139.0f / 255.0f, 69.0f / 255.0f, 19.0f / 255.0f);
            this["salmon"] = new Color(250.0f / 255.0f, 128.0f / 255.0f, 114.0f / 255.0f);
            this["sandybrown"] = new Color(244.0f / 255.0f, 164.0f / 255.0f, 96.0f / 255.0f);
            this["seagreen"] = new Color(46.0f / 255.0f, 139.0f / 255.0f, 87.0f / 255.0f);
            this["seashell"] = new Color(255.0f / 255.0f, 245.0f / 255.0f, 238.0f / 255.0f);
            this["sienna"] = new Color(160.0f / 255.0f, 82.0f / 255.0f, 45.0f / 255.0f);
            this["silver"] = new Color(192.0f / 255.0f, 192.0f / 255.0f, 192.0f / 255.0f);
            this["skyblue"] = new Color(135.0f / 255.0f, 206.0f / 255.0f, 235.0f / 255.0f);
            this["slateblue"] = new Color(106.0f / 255.0f, 90.0f / 255.0f, 205.0f / 255.0f);
            this["slategray"] = new Color(112.0f / 255.0f, 128.0f / 255.0f, 144.0f / 255.0f);
            this["slategrey"] = new Color(112.0f / 255.0f, 128.0f / 255.0f, 144.0f / 255.0f);
            this["snow"] = new Color(255.0f / 255.0f, 250.0f / 255.0f, 250.0f / 255.0f);
            this["springgreen"] = new Color(0.0f / 255.0f, 255.0f / 255.0f, 127.0f / 255.0f);
            this["steelblue"] = new Color(70.0f / 255.0f, 130.0f / 255.0f, 180.0f / 255.0f);
            this["tan"] = new Color(210.0f / 255.0f, 180.0f / 255.0f, 140.0f / 255.0f);
            this["teal"] = new Color(0.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f);
            this["thistle"] = new Color(216.0f / 255.0f, 191.0f / 255.0f, 216.0f / 255.0f);
            this["tomato"] = new Color(255.0f / 255.0f, 99.0f / 255.0f, 71.0f / 255.0f);
            this["turquoise"] = new Color(64.0f / 255.0f, 224.0f / 255.0f, 208.0f / 255.0f);
            this["violet"] = new Color(238.0f / 255.0f, 130.0f / 255.0f, 238.0f / 255.0f);
            this["wheat"] = new Color(245.0f / 255.0f, 222.0f / 255.0f, 179.0f / 255.0f);
            this["white"] = new Color(255.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f);
            this["whitesmoke"] = new Color(245.0f / 255.0f, 245.0f / 255.0f, 245.0f / 255.0f);
            this["yellow"] = new Color(255.0f / 255.0f, 255.0f / 255.0f, 0.0f / 255.0f);
            this["yellowgreen"] = new Color(154.0f / 255.0f, 205.0f / 255.0f, 50.0f / 255.0f);
        }
    } // The boring NamedWebColorDictionary class
} // namespace
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/SVGParser.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/SVGStyleSheet.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ad42887d8ca6e094093524d976e32104
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Linq;
using UnityEngine;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    internal class SVGPropertySheet : Dictionary<string, string> { }

    internal class SVGStyleSheet
    {
        private List<KeyValuePair<string, SVGPropertySheet>> m_Selectors = new List<KeyValuePair<string, SVGPropertySheet>>();

        public SVGPropertySheet this[string key]
        {
            get
            {
                int i = m_Selectors.FindIndex(x => x.Key == key);
                if (i != -1)
                    return m_Selectors[i].Value;
                return null;
            }
            set
            {
                var v = new KeyValuePair<string, SVGPropertySheet>(key, value);
                int i = m_Selectors.FindIndex(x => x.Key == key);
                if (i != -1)
                    m_Selectors[i] = v;
                m_Selectors.Add(v);
            }
        }

        public IEnumerable<string> selectors
        {
            get { return m_Selectors.Select(x => x.Key); }
        }

        public int Count
        {
            get { return m_Selectors.Count; }
        }

        public void Clear()
        {
            m_Selectors.Clear();
        }
    };

    internal static class SVGStyleSheetUtils
    {
        public static SVGStyleSheet Parse(string cssText)
        {
            var result = new SVGStyleSheet();
            var tokens = Tokenize(cssText);

            var sheet = new SVGStyleSheet();
            while (ParseSelector(tokens, sheet))
            {
                foreach (var sel in sheet.selectors)
                {
                    if (result.selectors.Contains(sel))
                        CombineProperties(result[sel], sheet[sel]);
                    else
                        result[sel] = sheet[sel];
                }
                sheet.Clear();
            }

            return result;
        }

        public static SVGPropertySheet ParseInline(string cssText)
        {
            var tokens = Tokenize(cssText);
            var props = new SVGPropertySheet();
            ParseProperties(tokens, props);
            return props;
        }

        private static bool ParseSelector(List<string> tokens, SVGStyleSheet sheet)
        {
            if (tokens.Count == 0)
                return false;

            var newSheet = new SVGStyleSheet();
            while (true)
            {
                var selectorName = PopToken(tokens);
                newSheet[selectorName] = new SVGPropertySheet();

                while (PeekToken(tokens) == ",")
                    PopToken(tokens);
                
                if (PeekToken(tokens) == "" || PeekToken(tokens) == "{")
                    break;
            }

            var sep = PopToken(tokens);
            if (sep != "{")
            {
                Debug.LogError("Invalid CSS selector opening bracket: \"" + sep + "\"");
                return false;
            }

            var props = new SVGPropertySheet();
            ParseProperties(tokens, props);

            // Transfer properties to the new selectors
            foreach (var key in newSheet.selectors)
                sheet[key] = CopyProperties(props);
            
            sep = PopToken(tokens);
            if (sep != "}")
            {
                Debug.LogError("Invalid CSS selector closing bracket: \"" + sep + "\"");
                return false;
            }
            
            return true;
        }

        private static void CombineProperties(SVGPropertySheet first, SVGPropertySheet second)
        {
            foreach (var key in second.Keys)
                first[key] = second[key];
        }

        private static SVGPropertySheet CopyProperties(SVGPropertySheet props)
        {
            var newProps = new SVGPropertySheet();
            foreach (var v in props)
                newProps[v.Key] = v.Value;
            return newProps;
        }

        private static bool ParseProperties(List<string> tokens, SVGPropertySheet props)
        {
            string name;
            string value;
            while (ParseProperty(tokens, out name, out value))
            {
                props[name] = value;
                while (PeekToken(tokens) == ";")
                    PopToken(tokens);
            }
            return true;
        }

        private static bool ParseProperty(List<string> tokens, out string name, out string value)
        {
            name = null;
            value = null;

            if (PeekToken(tokens) == "" || PeekToken(tokens) == "}")
                return false;

            name = PopToken(tokens);

            var sep = PopToken(tokens);
            if (sep != ":")
            {
                Debug.LogError("Invalid CSS property separator: \"" + sep + "\"");
                return false;
            }

            value = "";
            while (PeekToken(tokens) != "" && PeekToken(tokens) != ";" && PeekToken(tokens) != "}")
            {
                value = (value == "") ? PopToken(tokens) : value + " " + PopToken(tokens);
                if (PeekToken(tokens) == "(")
                    value += ParseParenValue(tokens);
            }

            return true;
        }

        private static string ParseParenValue(List<string> tokens)
        {
            var opening = PopToken(tokens);
            if (opening != "(")
            {
                Debug.LogError("Invaid CSS value opening");
                return "";
            }

            var value = opening;
            while (PeekToken(tokens) != "" && PeekToken(tokens) != ")")
                value += PopToken(tokens);
            
            if (PeekToken(tokens) != ")")
            {
                Debug.LogError("Invaid CSS value closing");
                return "";
            }

            value += PopToken(tokens);
            return value;
        }

        /// <summary>Breaks a CSS input into tokens</summary>
        /// <param name="cssText">The CSS text</param>
        /// <returns>A list of tokens</returns>
        public static List<string> Tokenize(string cssText)
        {
            var tokens = new List<string>();

            cssText = cssText.Replace(System.Environment.NewLine, ""); // Remove newlines
            cssText = Regex.Replace(cssText, @"/\*.*?\*/", ""); // Remove CSS comments
            cssText = Regex.Replace(cssText, @"<!--.*?-->", ""); // Remove XML comments

            int from = 0;
            int to = 0;

            while (from < cssText.Length)
            {
                while (from < cssText.Length && IsWhitespace(cssText[from]))
                    ++from;

                to = from;

                while (to < cssText.Length && !IsSeparator(cssText[to]))
                    ++to;

                if (from == to)
                {
                    if (from < cssText.Length)
                        tokens.Add(cssText[from].ToString());
                    ++to;
                }
                else
                {
                    tokens.Add(cssText.Substring(from, to-from));
                }

                from = to;
            }
            
            return tokens;
        }

        private static string PeekToken(List<string> tokens)
        {
            if (tokens.Count == 0)
                return "";
            return tokens[0];
        }

        private static string PopToken(List<string> tokens)
        {
            if (tokens.Count == 0)
                return "";
            var tok = tokens[0];
            tokens.RemoveAt(0);
            return tok;
        }

        private static bool IsSeparator(char ch)
        {
            return IsWhitespace(ch) || ch == ';' || ch == ':' || ch == '{' || ch == '}' || ch == '(' || ch == ')' || ch == ',';
        }

        private static bool IsWhitespace(char ch)
        {
            return ch == ' ' || ch == '\n' || ch == '\t';
        }
    }
} // namespace
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/SVGStyleSheet.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorEllipse.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e5c16ccd991535447911bd905325bbc0
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    public partial class VectorUtils
    {
        internal static BezierPathSegment[] BuildEllipsePath(Vector2 p0, Vector2 p1, float rotation, float rx, float ry, bool largeArc, bool sweep)
        {
            if ((p1-p0).magnitude < VectorUtils.Epsilon)
                return new BezierPathSegment[0];

            Vector2 c;
            float theta1;
            float sweepTheta;
            float adjustedRx;
            float adjustedRy;
            ComputeEllipseParameters(p0, p1, rotation, rx, ry, largeArc, sweep, out c, out theta1, out sweepTheta, out adjustedRx, out adjustedRy);

            BezierPathSegment[] path;
            if (Mathf.Abs(sweepTheta) <= Mathf.Epsilon)
            {
                // Use a straight line if the sweep angle is tiny
                path = VectorUtils.BezierSegmentToPath(VectorUtils.MakeLine(p0, p1));
            }
            else
            {
                path = VectorUtils.MakeArc(Vector2.zero, theta1, sweepTheta, 1.0f);

                var scaling = new Vector2(adjustedRx, adjustedRy);
                path = VectorUtils.TransformBezierPath(path, c, rotation, scaling);                
            }


            return path;
        }

        private static void ComputeEllipseParameters(Vector2 p0, Vector2 p1, float phi, float rx, float ry, bool fa, bool fs, out Vector2 c, out float theta1, out float sweepTheta, out float adjustedRx, out float adjustedRy)
        {
            // See https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
            var cosPhi = Mathf.Cos(phi);
            var sinPhi = Mathf.Sin(phi);

            var m0 = Matrix2D.identity;
            m0.m00 = cosPhi;
            m0.m01 = -sinPhi;
            m0.m10 = sinPhi;
            m0.m11 = cosPhi;

            var m1 = m0;
            m1.m01 = -m1.m01;
            m1.m10 = -m1.m10;

            var pp = m0 * new Vector2((p0.x - p1.x) / 2.0f, (p0.y - p1.y) / 2.0f);

            rx = Mathf.Abs(rx);
            ry = Mathf.Abs(ry);
            EnsureRadiiAreLargeEnough(pp, ref rx, ref ry);
            adjustedRx = rx;
            adjustedRy = ry;

            var ppx2 = pp.x * pp.x;
            var ppy2 = pp.y * pp.y;
            var rx2 = rx * rx;
            var ry2 = ry * ry;
            var cp = new Vector2((rx * pp.y) / ry, -(ry * pp.x) / rx);
            cp *= Mathf.Sqrt(Mathf.Abs((rx2 * ry2 - rx2 * ppy2 - ry2 * ppx2) / (rx2 * ppy2 + ry2 * ppx2)));
            if (fa == fs)
                cp = -cp;

            c = (m1 * cp) + new Vector2((p0.x + p1.x) / 2.0f, (p0.y + p1.y) / 2.0f);

            theta1 = Vector2.SignedAngle(new Vector2(1, 0), new Vector2((pp.x - cp.x) / rx, (pp.y - cp.y) / ry)) % 360.0f;
            sweepTheta = Vector2.SignedAngle(new Vector2((pp.x - cp.x) / rx, (pp.y - cp.y) / ry), new Vector2((-pp.x - cp.x) / rx, (-pp.y - cp.y) / ry));

            if (!fs && sweepTheta > 0)
                sweepTheta -= 360;
            if (fs && sweepTheta < 0)
                sweepTheta += 360;

            theta1 *= Mathf.Deg2Rad;
            sweepTheta *= Mathf.Deg2Rad;
        }

        private static void EnsureRadiiAreLargeEnough(Vector2 p, ref float rx, ref float ry)
        {
            var d = (p.x * p.x) / (rx * rx) + (p.y * p.y) / (ry * ry);
            if (d > 1.0f)
            {
                var sqrtD = Mathf.Sqrt(d);
                rx *= sqrtD;
                ry *= sqrtD;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorEllipse.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorRectangle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5ab9bcde9af121f45a0d120f28f80d7c
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    public partial class VectorUtils
    {
        /// <summary>Builds a BezierContour from a Rectangle.</summary>
        /// <param name="rect">The rectangle to build the contour from</param>
        /// <param name="radiusTL">The top-left radius of the rectangle</param>
        /// <param name="radiusTR">The top-right radius of the rectangle</param>
        /// <param name="radiusBR">The bottom-right radius of the rectangle</param>
        /// <param name="radiusBL">The bottom-left radius of the rectangle</param>
        /// <returns>A BezierContour that follows the rectangle contour</returns>
        public static BezierContour BuildRectangleContour(Rect rect, Vector2 radiusTL, Vector2 radiusTR, Vector2 radiusBR, Vector2 radiusBL)
        {
            var width = rect.size.x;
            var height = rect.size.y;

            var halfSize = new Vector2(width / 2.0f, height / 2.0f);
            radiusTL = Vector2.Max(Vector2.Min(radiusTL, halfSize), Vector2.zero);
            radiusTR = Vector2.Max(Vector2.Min(radiusTR, halfSize), Vector2.zero);
            radiusBR = Vector2.Max(Vector2.Min(radiusBR, halfSize), Vector2.zero);
            radiusBL = Vector2.Max(Vector2.Min(radiusBL, halfSize), Vector2.zero);

            var leftSegmentSize = height - (radiusBL.y + radiusTL.y);
            var topSegmentSize = width - (radiusTL.x + radiusTR.x);
            var rightSegmentSize = height - (radiusBR.y + radiusTR.y);
            var bottomSegmentSize = width - (radiusBL.x + radiusBR.x);

            var segments = new List<BezierPathSegment>(8);
            BezierPathSegment seg;

            if (leftSegmentSize > VectorUtils.Epsilon)
            {
                seg = MakePathLine(new Vector2(0.0f, radiusTL.y + leftSegmentSize), new Vector2(0.0f, radiusTL.y))[0];
                segments.Add(seg);
            }

            if (radiusTL.magnitude > VectorUtils.Epsilon)
            {
                var circleArc = VectorUtils.MakeArc(Vector2.zero, -Mathf.PI, Mathf.PI / 2.0f, 1.0f);
                circleArc = VectorUtils.TransformBezierPath(circleArc, radiusTL, 0.0f, radiusTL);
                segments.Add(circleArc[0]);
            }

            if (topSegmentSize > VectorUtils.Epsilon)
            {
                seg = MakePathLine(new Vector2(radiusTL.x, 0.0f), new Vector2(radiusTL.x + topSegmentSize, 0.0f))[0];
                segments.Add(seg);
            }

            if (radiusTR.magnitude > VectorUtils.Epsilon)
            {
                var topRight = new Vector2(width - radiusTR.x, radiusTR.y);
                var circleArc = VectorUtils.MakeArc(Vector2.zero, -Mathf.PI / 2.0f, Mathf.PI / 2.0f, 1.0f);
                circleArc = VectorUtils.TransformBezierPath(circleArc, topRight, 0.0f, radiusTR);
                segments.Add(circleArc[0]);
            }

            if (rightSegmentSize > VectorUtils.Epsilon)
            {
                seg = MakePathLine(new Vector2(width, radiusTR.y), new Vector2(width, radiusTR.y + rightSegmentSize))[0];
                segments.Add(seg);
            }

            if (radiusBR.magnitude > VectorUtils.Epsilon)
            {
                var bottomRight = new Vector2(width - radiusBR.x, height - radiusBR.y);
                var circleArc = VectorUtils.MakeArc(Vector2.zero, 0.0f, Mathf.PI / 2.0f, 1.0f);
                circleArc = VectorUtils.TransformBezierPath(circleArc, bottomRight, 0.0f, radiusBR);
                segments.Add(circleArc[0]);
            }

            if (bottomSegmentSize > VectorUtils.Epsilon)
            {
                seg = MakePathLine(new Vector2(width - radiusBR.x, height), new Vector2(width - (radiusBR.x + bottomSegmentSize), height))[0];
                segments.Add(seg);
            }

            if (radiusBL.magnitude > VectorUtils.Epsilon)
            {
                var bottomLeft = new Vector2(radiusBL.x, height - radiusBL.y);
                var circleArc = VectorUtils.MakeArc(Vector2.zero, Mathf.PI / 2.0f, Mathf.PI / 2.0f, 1.0f);
                circleArc = VectorUtils.TransformBezierPath(circleArc, bottomLeft, 0.0f, radiusBL);
                segments.Add(circleArc[0]);
            }

            // Offset segments to position
            for (int i = 0; i < segments.Count; ++i)
            {
                var s = segments[i];
                s.P0 += rect.position;
                s.P1 += rect.position;
                s.P2 += rect.position;
                segments[i] = s;
            }

            return new BezierContour() { Segments = segments.ToArray(), Closed = true };
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorRectangle.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorScene.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6317336283684d540b187222a9055e78
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    /// <summary>The gradient fill types.</summary>
    public enum GradientFillType
    {
        /// <summary>A linear gradient.</summary>
        Linear,

        /// <summary>A radial gradient, centered at the radial focus of the gradient fill.</summary>
        Radial
    }

    /// <summary>The path corner types, for joining path segments together.</summary>
    public enum PathCorner
    {
        /// <summary>A tipped corner with a sharp edge.</summary>
        Tipped,

        /// <summary>A rounded corner.</summary>
        Round,

        /// <summary>A beveled corner.</summary>
        Beveled
    }

    /// <summary>The path ending types.</summary>
    public enum PathEnding
    {
        /// <summary>A square path ending.</summary>
        Chop,

        /// <summary>A square path ending with a small extrusion.</summary>
        Square,

        /// <summary>A rounded path ending.</summary>
        Round
    }

    /// <summary>The fill mode types.</summary>
    public enum FillMode
    {
        /// <summary>Determines the "insideness" of the shape by evaluating the direction of the edges crossed.</summary>
        NonZero,

        /// <summary>Determines the "insideness" of the shape by counting the number of edges crossed.</summary>
        OddEven
    }

    /// <summary>The addressing mode, defining how textures or gradients behave when being addressed outside their unit range.</summary>
    public enum AddressMode
    {
        /// <summary>Textures/gradients are wrapping around with a repeating pattern.</summary>
        Wrap,

        /// <summary>Textures/gradients are clamped on the borders.</summary>
        Clamp,

        /// <summary>Textures/gradients are repeated with a mirroring pattern.</summary>
        Mirror
    }

    /// <summary>The gradient stops used for gradient fills.</summary>
    public struct GradientStop
    {
        /// <summary>The color of the stop.</summary>
        public Color Color { get; set; }

        /// <summary>At which percentage this stop applies. Should be between 0 and 1, inclusively.</summary>
        public float StopPercentage { get; set; }
    }

    /// <summary>A bezier segment.</summary>
    /// <remarks>
    /// Cubic Bezier segment starts from P0, flies in tangent to direction from P0 to P1,
    /// then lands in direction from P2 to P3, to finally end exactly at P3.
    /// </remarks>
    public struct BezierSegment
    {
        /// <summary>Origin point of the segment.</summary>
        public Vector2 P0;

        /// <summary>First control point of the segment.</summary>
        public Vector2 P1;

        /// <summary>Second control point of the segment.</summary>
        public Vector2 P2;

        /// <summary>Ending point of the segment.</summary>
        public Vector2 P3;
    }

    /// <summary>A bezier path segment.</summary>
    /// <remarks>
    /// Like BezierSegment but implies connectivity of segments, where segments[0].P3 is actually segments[1].P0
    /// </remarks>
    public struct BezierPathSegment
    {
        /// <summary>Origin point of the segment.</summary>
        public Vector2 P0;

        /// <summary>First control point of the segment.</summary>
        public Vector2 P1;

        /// <summary>Second control point of the segment.</summary>
        public Vector2 P2;
    }

    /// <summary>A chain of bezier paths, optionnally closed.</summary>
    public struct BezierContour
    {
        /// <summary>An array of every path segments on the contour.</summary>
        /// <remarks>Closed paths should not add a dedicated closing segment. It is implied by the 'closed' property.</remarks>
        public BezierPathSegment[] Segments { get; set; }

        /// <summary>A boolean indicating if the contour should be closed.</summary>
        /// <remarks>
        ///  When set to true, closed path will connect the last path segment to the first path segment, by using the
        ///  last path segment's P1 and P2 as control points.
        /// </remarks>
        public bool Closed { get; set; }
    }

    /// <summary>The IFill interface is implemented by filling techniques (solid, texture or gradient).</summary>
    public interface IFill
    {
        /// <summary>The filling method (non-zero or even-odd) of the fill.</summary>
        FillMode Mode { get; set; }

        /// <summary>The opacity of the fill.</summary>
        float Opacity { get; set; }
    }

    /// <summary>Fills a shape with a single color.</summary>
    public class SolidFill : IFill
    {
        /// <summary>The color of the fill.</summary>
        public Color Color { get; set; }

        /// <summary>The opacity of the fill.</summary>
        public float Opacity { get { return m_Opacity; } set { m_Opacity = value; } }
        private float m_Opacity = 1.0f;

        /// <summary>The filling method (non-zero or even-odd) of the fill.</summary>
        public FillMode Mode { get; set; }
    }

    /// <summary>Fills a shape with a gradient.</summary>
    /// <remarks>
    /// Size of the fill is always assumed to cover the entire element's bounding box.
    /// Radial fills are centered in the element's bounding box. Its radii are half the bounding box dimensions in each direction.
    /// Linear fills start from the left edge to the right edge of the element's bounding box.
    /// </remarks>
    public class GradientFill : IFill
    {
        /// <summary>The fill type (linear or gradient).</summary>
        public GradientFillType Type { get; set; }

        /// <summary>An array of stops defining the gradient colors.</summary>
        public GradientStop[] Stops { get; set; }

        /// <summary>The filling method (non-zero or even-odd) of the fill.</summary>
        public FillMode Mode { get; set; }

        /// <summary>The opacity of the fill.</summary>
        public float Opacity { get { return m_Opacity; } set { m_Opacity = value; } }
        private float m_Opacity = 1.0f;

        /// <summary>The adressing mode (wrap, clamp or mirror) of this fill.</summary>
        public AddressMode Addressing { get; set; }

        /// <summary>A position within the unit circle (-1,1) where 0 falls in the middle of the fill.</summary>
        public Vector2 RadialFocus { get; set; }
    }

    /// <summary>Fills a shape with a texture.</summary>
    public class TextureFill : IFill 
    {
        /// <summary>The texture to fill the shape with.</summary>
        public Texture2D Texture { get; set; }

        /// <summary>The filling method (non-zero or even-odd) of the fill.</summary>
        public FillMode Mode { get; set; }

        /// <summary>The opacity of the fill.</summary>
        public float Opacity { get { return m_Opacity; } set { m_Opacity = value; } }
        private float m_Opacity = 1.0f;

        /// <summary>The adressing mode (wrap, clamp or mirror) of this fill.</summary>
        public AddressMode Addressing { get; set; }
    }

    /// <summary>Fills a shape with a pattern.</summary>
    public class PatternFill : IFill
    {
        /// <summary>The filling method (non-zero or even-odd) of the fill.</summary>
        public FillMode Mode { get; set; }

        /// <summary>The opacity of the fill.</summary>
        public float Opacity { get { return m_Opacity; } set { m_Opacity = value; } }
        private float m_Opacity = 1.0f;

        /// <summary>The root node of the pattern</summary>
        public SceneNode Pattern { get; set; }

        /// <summary>The rectangle that is repeated</summary>
        public Rect Rect { get; set; }
    }

    /// <summary>Defines how strokes should be rendered.</summary>
    public class Stroke
    {
        /// <summary>The stroke color.</summary>
        public Color Color {
            get {
                var solidFill = Fill as SolidFill;
                if (solidFill == null) return new Color();
                return solidFill.Color;
            }
            set {
                Fill = new SolidFill() { Color = value };
            }
        }

        /// <summary>The stroke fill.</summary>
        public IFill Fill { get; set; }

        /// <summary>A transformation specific to the fill.</summary>
        public Matrix2D FillTransform { get { return m_FillTransform; } set { m_FillTransform = value; } }
        private Matrix2D m_FillTransform = Matrix2D.identity;

        /// <summary>The stroke half-thickness.</summary>
        public float HalfThickness { get; set; }

        /// <summary>The stroke pattern (dashes).</summary>
        /// <remarks>Even entries mark a fill and odd entries mark void</remarks>
        public float[] Pattern { get; set; }

        /// <summary>An offset to where the pattern should start.</summary>
        public float PatternOffset { get; set; }

        /// <summary>How far the tipped corners may extrude.</summary>
        public float TippedCornerLimit { get; set; }
    }

    /// <summary>Defines properties of paths.</summary>
    public struct PathProperties
    {
        /// <summary>The stroke used to render the path.</summary>
        public Stroke Stroke { get; set; }

        /// <summary>How the beginning of the path should be displayed.</summary>
        public PathEnding Head { get; set; }

        /// <summary>How the end of the path should be displayed.</summary>
        public PathEnding Tail { get; set; }

        /// <summary>How the corners of the path should be displayed.</summary>
        public PathCorner Corners { get; set; }
    }

    /// <summary>A generic filled shape.</summary>
    public class Shape
    {
        /// <summary>All the contours defining the shape.</summary>
        /// <remarks>
        /// Some of these coutours may be holes in the shape, depending on the fill mode used <see cref="FillMode"/>.
        /// </remarks>
        public BezierContour[] Contours { get; set; }

        /// <summary>The fill used on the shape.</summary>
        public IFill Fill { get; set; }

        /// <summary>A transformation specific to the fill.</summary>
        public Matrix2D FillTransform { get { return m_FillTransform; } set { m_FillTransform = value; } }
        private Matrix2D m_FillTransform = Matrix2D.identity;

        /// <summary>The path properties.</summary>
        public PathProperties PathProps { get; set; }

        /// <summary>Whether the specified contours are convex or not</summary>
        /// <remarks>
        /// Set this to true when you know the shape contours are convex.
        /// This will allow for a faster tessellation process in some circumstances.
        /// </remarks>
        public bool IsConvex { get; set; }
    }

    /// <summary>A node inside a hierarchy.</summary>
    public class SceneNode
    {
        /// <summary>The list of children nodes.</summary>
        public List<SceneNode> Children { get; set; }

        /// <summary>The list of shapes inside this node.</summary>
        public List<Shape> Shapes { get; set; }

        /// <summary>The transform of the node.</summary>
        public Matrix2D Transform { get { return m_Transform; } set { m_Transform = value; } }
        private Matrix2D m_Transform = Matrix2D.identity;

        /// <summary>A clipper hierarchy that will clip this node.</summary>
        public SceneNode Clipper { get; set; }
    }

    /// <summary>A scene contains the whole node hierarchy.</summary>
    public class Scene
    {
        /// <summary>The root of the node hierarchy.</summary>
        public SceneNode Root { get; set; }
    }
} // namespace
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorScene.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorSprite.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c138b02f3c416c146aa000916ae2f816
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.U2D;
#if !(UNITY_2019_3_OR_NEWER)
using UnityEngine.Experimental.U2D;
#endif
using UnityEngine.Experimental.Rendering;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    public static partial class VectorUtils
    {
        /// <summary>The alignement of the sprite, to determine the location of the pivot.</summary>
        public enum Alignment
        {
            /// <summary>Center alignment.</summary>
            Center = 0,

            /// <summary>Top-left alignment.</summary>
            TopLeft = 1,

            /// <summary>Top-center alignment.</summary>
            TopCenter = 2,

            /// <summary>Top-right alignment.</summary>
            TopRight = 3,

            /// <summary>Left-center alignment.</summary>
            LeftCenter = 4,

            /// <summary>Right-center alignment.</summary>
            RightCenter = 5,

            /// <summary>Bottom-left alignment.</summary>
            BottomLeft = 6,

            /// <summary>Bottom-center alignment.</summary>
            BottomCenter = 7,

            /// <summary>Bottom-right alignment.</summary>
            BottomRight = 8,

            /// <summary>Custom alignment.</summary>
            /// <remarks>
            /// Uses a custom alignment that will be used when building the sprite using the <see cref="BuildSprite"/> method.
            /// </remarks>
            Custom = 9,

            /// <summary>SVG origin alignment.</summary>
            /// <remarks>
            /// This will use the origin of the SVG document as the origin of the sprite.
            /// </remarks>
            SVGOrigin = 10
        }

        private static void FlipYAxis(IList<Vector2> vertices)
        {
            var bbox = Bounds(vertices);
            var h = bbox.height;
            for (int i = 0; i < vertices.Count; ++i)
            {
                var v = vertices[i];
                v.y -= bbox.position.y;
                v.y = h - v.y;
                v.y += bbox.position.y;
                vertices[i] = v;
            }
        }
   
        internal enum WindingDir
        {
            CW,
            CCW
        }

        internal static void AdjustWinding(Vector2[] vertices, UInt16[] indices, WindingDir dir)
        {
            bool shouldFlip = false;
            var length = indices.Length;
            for (int i = 0; i < (length - 2); i += 3)
            {
                var v0 = (Vector3)vertices[indices[i]];
                var v1 = (Vector3)vertices[indices[i+1]];
                var v2 = (Vector3)vertices[indices[i+2]];
                var s = (v1 - v0).normalized;
                var t = (v2 - v0).normalized;
                float dot = Vector3.Dot(s, t);
                if (s == Vector3.zero || t == Vector3.zero || dot > 0.9999f || dot < -0.9999f)
                    continue;
                var n = Vector3.Cross(s, t);
                if (n.sqrMagnitude < 0.0001f)
                    continue;
                shouldFlip = dir == WindingDir.CCW ? n.z < 0.0f : n.z > 0.0f;
                break;
            }
            if (shouldFlip)
            {
                for (int i = 0; i < (length - 2); i += 3)
                {
                    var tmp = indices[i];
                    indices[i] = indices[i+1];
                    indices[i+1] = tmp;
                }
            }
        }

        private static void FlipRangeIfNecessary(List<Vector2> vertices, List<UInt16> indices, int indexStart, int indexEnd, bool flipYAxis)
        {
            // For the range, find the first valid triangle and check its winding order. If that triangle needs flipping, then flip the whole range.
            bool shouldFlip = false;
            for (int i = indexStart; i < (indexEnd - 2); i += 3)
            {
                var v0 = (Vector3)vertices[indices[i]];
                var v1 = (Vector3)vertices[indices[i + 1]];
                var v2 = (Vector3)vertices[indices[i + 2]];
                var s = (v1 - v0).normalized;
                var t = (v2 - v0).normalized;
                float dot = Vector3.Dot(s, t);
                if (s == Vector3.zero || t == Vector3.zero || dot > 0.99f || dot < -0.99f)
                    continue;
                var n = Vector3.Cross(s, t);
                if (n.sqrMagnitude < 0.001f)
                    continue;
                shouldFlip = flipYAxis ? n.z < 0.0f : n.z > 0.0f;
                break;
            }
            if (shouldFlip)
            {
                for (int i = indexStart; i < (indexEnd - 2); i += 3)
                {
                    var tmp = indices[i + 1];
                    indices[i + 1] = indices[i + 2];
                    indices[i + 2] = tmp;
                }
            }
        }

        internal static void RenderFromArrays(Vector2[] vertices, UInt16[] indices, Vector2[] uvs, Color[] colors, Vector2[] settings, Texture2D texture, Material mat, bool clear = true)
        {
            mat.SetTexture("_MainTex", texture);
            mat.SetPass(0);

            if (clear)
                GL.Clear(true, true, Color.clear);

            GL.PushMatrix();
            GL.LoadOrtho();
            GL.Color(new Color(1, 1, 1, 1));
            GL.Begin(GL.TRIANGLES);
            for (int i = 0; i < indices.Length; ++i)
            {
                ushort index = indices[i];
                Vector2 vertex = vertices[index];
                Vector2 uv = uvs[index];
                GL.TexCoord2(uv.x, uv.y);
                if (settings != null)
                {
                    var setting = settings[index];
                    GL.MultiTexCoord2(2, setting.x, setting.y);
                }
                if (colors != null)
                    GL.Color(colors[index]);
                GL.Vertex3(vertex.x, vertex.y, 0);
            }
            GL.End();
            GL.PopMatrix();

            mat.SetTexture("_MainTex", null);
        }

        /// <summary>Draws a vector sprite using the provided material.</summary>
        /// <param name="sprite">The sprite to render</param>
        /// <param name="mat">The material used for rendering</param>
        /// <param name="clear">If true, clear the render target before rendering</param>
        public static void RenderSprite(Sprite sprite, Material mat, bool clear = true) 
        {
            float spriteWidth = sprite.rect.width;
            float spriteHeight = sprite.rect.height;
            float pixelsToUnits = sprite.rect.width / sprite.bounds.size.x;

            var uvs = sprite.uv;
            var triangles = sprite.triangles;
            var pivot = sprite.pivot;

            var vertices = sprite.vertices.Select(v => 
                new Vector2((v.x * pixelsToUnits + pivot.x)/spriteWidth,
                            (v.y * pixelsToUnits + pivot.y)/spriteHeight)
            ).ToArray();

            Color[] colors = null;
            if (sprite.HasVertexAttribute(VertexAttribute.Color))
                colors = sprite.GetVertexAttribute<Color32>(VertexAttribute.Color).Select(c => (Color)c).ToArray();

            Vector2[] settings = null;
            if (sprite.HasVertexAttribute(VertexAttribute.TexCoord2))
                settings = sprite.GetVertexAttribute<Vector2>(VertexAttribute.TexCoord2).ToArray();

            RenderFromArrays(vertices, sprite.triangles, sprite.uv, colors, settings, sprite.texture, mat, clear);
        }

        private static Material s_ExpandEdgesMat;

        /// <summary>Renders a vector sprite to Texture2D.</summary>
        /// <param name="sprite">The sprite to render</param>
        /// <param name="width">The desired width of the resulting texture</param>
        /// <param name="height">The desired height of the resulting texture</param>
        /// <param name="mat">The material used to render the sprite</param>
        /// <param name="antiAliasing">The number of samples per pixel for anti-aliasing</param>
        /// <param name="expandEdges">When true, expand the edges to avoid a dark banding effect caused by filtering. This is slower to render and uses more graphics memory.</param>
        /// <returns>A Texture2D object containing the rendered vector sprite</returns>
        public static Texture2D RenderSpriteToTexture2D(Sprite sprite, int width, int height, Material mat, int antiAliasing = 1, bool expandEdges = false)
        {
            if (width <= 0 || height <= 0)
                return null;

            RenderTexture tex = null;
            var oldActive = RenderTexture.active;

            var desc = new RenderTextureDescriptor(width, height, RenderTextureFormat.ARGB32, 0) {
                msaaSamples = 1,
                sRGB = QualitySettings.activeColorSpace == ColorSpace.Linear
            };

            if (expandEdges)
            {
                // Draw the sprite normally to be used as a background, no-antialiasing
                var normalTex = RenderTexture.GetTemporary(desc);
                RenderTexture.active = normalTex;
                RenderSprite(sprite, mat);

                // Expand the edges and make completely transparent
                if (s_ExpandEdgesMat == null)
                {
                    var shader = Shader.Find("Hidden/VectorExpandEdges");
                    if (shader == null)
                    {
#if UNITY_EDITOR
                        // Workaround for case 1167309.
                        // Shader.Find() seems to fail on the package shader when doing a fresh import with a clean Library folder,
                        // but AssetDatabase.LoadAssetAtPath() works fine though.
                        shader = UnityEditor.AssetDatabase.LoadAssetAtPath<Shader>("Packages/com.unity.vectorgraphics/Runtime/Shaders/VectorExpandEdges.shader");
#else
                        return null;
#endif
                    }
                    s_ExpandEdgesMat = new Material(shader);
                }

                var expandTex = RenderTexture.GetTemporary(desc);
                RenderTexture.active = expandTex;
                GL.Clear(false, true, Color.clear);
                Graphics.Blit(normalTex, expandTex, s_ExpandEdgesMat, 0);
                RenderTexture.ReleaseTemporary(normalTex);

                // Draw the sprite again, but clear with the texture rendered in the previous step,
                // this will make the bilinear filter to interpolate the colors with values different
                // than "transparent black", which causes black-ish outlines around the shape.
                desc.msaaSamples = antiAliasing;
                tex = RenderTexture.GetTemporary(desc);
                RenderTexture.active = tex;
                Graphics.Blit(expandTex, tex);
                RenderTexture.ReleaseTemporary(expandTex); // Use the expanded texture to clear the buffer

                RenderTexture.active = tex;
                RenderSprite(sprite, mat, false);
            }
            else
            {
                desc.msaaSamples = antiAliasing;
                tex = RenderTexture.GetTemporary(desc);
                RenderTexture.active = tex;
                RenderSprite(sprite, mat);
            }

            Texture2D copy = new Texture2D(width, height, TextureFormat.RGBA32, false);
            copy.hideFlags = HideFlags.HideAndDontSave;
            copy.ReadPixels(new Rect(0, 0, width, height), 0, 0);
            copy.Apply();

            RenderTexture.active = oldActive;
            RenderTexture.ReleaseTemporary(tex);

            return copy;
        }

        internal static Vector2 GetPivot(Alignment alignment, Vector2 customPivot, Rect bbox, bool flipYAxis)
        {
            switch (alignment)
            {
                case Alignment.Center: return new Vector2(0.5f, 0.5f);
                case Alignment.TopLeft: return new Vector2(0.0f, 1.0f);
                case Alignment.TopCenter: return new Vector2(0.5f, 1.0f);
                case Alignment.TopRight: return new Vector2(1.0f, 1.0f);
                case Alignment.LeftCenter: return new Vector2(0.0f, 0.5f);
                case Alignment.RightCenter: return new Vector2(1.0f, 0.5f);
                case Alignment.BottomLeft: return new Vector2(0.0f, 0.0f);
                case Alignment.BottomCenter: return new Vector2(0.5f, 0.0f);
                case Alignment.BottomRight: return new Vector2(1.0f, 0.0f);
                case Alignment.SVGOrigin: 
                {
                     var p = -bbox.position / bbox.size;
                     if (flipYAxis)
                        p.y = 1.0f - p.y;
                    return p;
                }
                case Alignment.Custom: return customPivot;
            }
            return Vector2.zero;
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorSprite.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorTessellation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7946c79a48c418944bb4ac48df97c4be
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    public static partial class VectorUtils
    {
        /// <summary>
        /// Structure to store the tessellation options.
        /// </summary>
        public struct TessellationOptions
        {
            private float m_MaxCordDev, m_MaxCordDevSq, m_MaxTanAngleDev, m_MaxTanAngleDevCosine, m_StepSize;

            /// <summary>
            /// The uniform tessellation step distance.
            /// </summary>
            public float StepDistance { get; set; } // A split to happen uniformly at fixed distances

            /// <summary>
            /// The maximum distance on the cord to a straight line between to points after which more tessellation will be generated.
            /// To disable, specify float.MaxValue.
            /// </summary>
            public float MaxCordDeviation  // Maximum distance allowed between a cord and its line projection
            {
                get { return m_MaxCordDev; }
                set
                {
                    m_MaxCordDev = Mathf.Max(value, 0.0f);
                    m_MaxCordDevSq = (m_MaxCordDev == float.MaxValue) ? float.MaxValue : m_MaxCordDev * m_MaxCordDev;
                }
            }
            internal float MaxCordDeviationSquared { get { return m_MaxCordDevSq; } }

            /// <summary>
            /// The maximum angle (in degrees) between the curve tangent and the next point after which more tessellation will be generated.
            /// To disable, specify float.MaxValue.
            /// </summary>
            public float MaxTanAngleDeviation // The maximum angle allowed (in radians) between tangents before a split happens
            {
                get { return m_MaxTanAngleDev; }
                set
                {
                    m_MaxTanAngleDev = Mathf.Clamp(value, VectorUtils.Epsilon, Mathf.PI * 0.5f);
                    m_MaxTanAngleDevCosine = Mathf.Cos(m_MaxTanAngleDev);
                }
            }
            internal float MaxTanAngleDeviationCosine { get { return m_MaxTanAngleDevCosine; } } // Cosine of the maximum angle allowed between tangents before a split happens

            /// <summary>
            /// The number of samples used internally to evaluate the curves. More samples = higher quality.
            /// Should be between 0 and 1 (inclusive).
            /// </summary>
            public float SamplingStepSize
            {
                get { return m_StepSize; }
                set { m_StepSize = Mathf.Clamp(value, Epsilon, 1.0f); }
            }
        }

        /// <summary>
        /// Tessellates a path.
        /// </summary>
        /// <param name="contour">The path to tessellate</param>
        /// <param name="pathProps">The path properties</param>
        /// <param name="tessellateOptions">The tessellation options</param>
        /// <param name="vertices">The resulting vertices</param>
        /// <param name="indices">The resulting triangles</param>
        /// <remarks>
        /// The individual line segments generated during tessellation are made out of a set of ordered vertices. It is important
        /// to honor this ordering so joining and and capping connect properly with the existing vertices without generating dupes.
        /// The ordering assumed is as follows:
        /// The last two vertices of a piece must be such that the first is generated at the end with a positive half-thickness
        /// while the second vertex is at the end too but at a negative half-thickness.
        /// No assumptions are enforced for other vertices before the two last vertices.
        /// </remarks>
        public static void TessellatePath(BezierContour contour, PathProperties pathProps, TessellationOptions tessellateOptions, out Vector2[] vertices, out UInt16[] indices)
        {
            if (tessellateOptions.StepDistance < Epsilon)
                throw new Exception("stepDistance too small");

            if (contour.Segments.Length < 2)
            {
                vertices = new Vector2[0];
                indices = new UInt16[0];
                return;
            }

            tessellateOptions.MaxCordDeviation = Mathf.Max(0.0001f, tessellateOptions.MaxCordDeviation);
            tessellateOptions.MaxTanAngleDeviation = Mathf.Max(0.0001f, tessellateOptions.MaxTanAngleDeviation);

            UnityEngine.Profiling.Profiler.BeginSample("TessellatePath");

            float[] segmentLengths = VectorUtils.SegmentsLengths(contour.Segments, contour.Closed);

            // Approximate the number of vertices/indices we need to store the results so we reduce memory reallocations during work
            float approxTotalLength = 0.0f;
            foreach (var s in segmentLengths)
                approxTotalLength += s;

            int approxStepCount = Math.Max((int)(approxTotalLength / tessellateOptions.StepDistance + 0.5f), 2);
            if (pathProps.Stroke.Pattern != null)
                approxStepCount += pathProps.Stroke.Pattern.Length * 2;

            List<Vector2> verts = new List<Vector2>(approxStepCount * 2 + 32); // A little bit possibly for the endings
            List<UInt16> inds = new List<UInt16>((int)(verts.Capacity * 1.5f)); // Usually every 4 verts represent a quad that uses 6 indices

            var patternIt = new PathPatternIterator(pathProps.Stroke.Pattern, pathProps.Stroke.PatternOffset);
            var pathIt = new PathDistanceForwardIterator(contour.Segments, contour.Closed, tessellateOptions.MaxCordDeviationSquared, tessellateOptions.MaxTanAngleDeviationCosine, tessellateOptions.SamplingStepSize);

            JoiningInfo[] joiningInfo = new JoiningInfo[2];
            HandleNewSegmentJoining(pathIt, patternIt, joiningInfo, pathProps.Stroke.HalfThickness, segmentLengths);

            int rangeIndex = 0;
            while (!pathIt.Ended)
            {
                if (patternIt.IsSolid)
                    TessellateRange(patternIt.SegmentLength, pathIt, patternIt, pathProps, tessellateOptions, joiningInfo, segmentLengths, approxTotalLength, rangeIndex++, verts, inds);
                else
                    SkipRange(patternIt.SegmentLength, pathIt, patternIt, pathProps, joiningInfo, segmentLengths);
                patternIt.Advance();
            }

            vertices = verts.ToArray();
            indices = inds.ToArray();

            UnityEngine.Profiling.Profiler.EndSample();
        }

        static Vector2[] TraceShape(BezierContour contour, Stroke stroke, TessellationOptions tessellateOptions)
        {
            if (tessellateOptions.StepDistance < Epsilon)
                throw new Exception("stepDistance too small");

            if (contour.Segments.Length < 2)
                return new Vector2[0];

            float[] segmentLengths = VectorUtils.SegmentsLengths(contour.Segments, contour.Closed);

            // Approximate the number of vertices/indices we need to store the results so we reduce memory reallocations during work
            float approxTotalLength = 0.0f;
            foreach (var s in segmentLengths)
                approxTotalLength += s;

            int approxStepCount = Math.Max((int)(approxTotalLength / tessellateOptions.StepDistance + 0.5f), 2);
            var strokePattern = stroke != null ? stroke.Pattern : null;
            var strokePatternOffset = stroke != null ? stroke.PatternOffset : 0.0f;
            if (strokePattern != null)
                approxStepCount += strokePattern.Length * 2;

            List<Vector2> verts = new List<Vector2>(approxStepCount); // A little bit possibly for the endings

            var patternIt = new PathPatternIterator(strokePattern, strokePatternOffset);
            var pathIt = new PathDistanceForwardIterator(contour.Segments, true, tessellateOptions.MaxCordDeviationSquared, tessellateOptions.MaxTanAngleDeviationCosine, tessellateOptions.SamplingStepSize);
            verts.Add(pathIt.EvalCurrent());

            while (!pathIt.Ended)
            {
                float distance = patternIt.SegmentLength;
                float startingLength = pathIt.LengthSoFar;
                float unitsRemaining = Mathf.Min(tessellateOptions.StepDistance, distance);
                bool endedEntirePath = false;
                for (;;)
                {
                    var result = pathIt.AdvanceBy(unitsRemaining, out unitsRemaining);
                    if (result == PathDistanceForwardIterator.Result.Ended)
                    {
                        endedEntirePath = true;
                        break;
                    }
                    else if (result == PathDistanceForwardIterator.Result.NewSegment)
                        verts.Add(pathIt.EvalCurrent());

                    if ((unitsRemaining <= Epsilon) &&
                        !TryGetMoreRemainingUnits(ref unitsRemaining, pathIt, startingLength, distance, tessellateOptions.StepDistance))
                    {
                        break;
                    }

                    if (result == PathDistanceForwardIterator.Result.Stepped)
                        verts.Add(pathIt.EvalCurrent());
                }

                // Ending
                if (endedEntirePath)
                    break;
                else verts.Add(pathIt.EvalCurrent());
                patternIt.Advance();
            }

            if ((verts[0] - verts[verts.Count - 1]).sqrMagnitude < Epsilon)
                verts.RemoveAt(verts.Count - 1);
            return verts.ToArray(); // Why not return verts itself?
        }

        static bool TryGetMoreRemainingUnits(ref float unitsRemaining, PathDistanceForwardIterator pathIt, float startingLength, float distance, float stepDistance)
        {
            float distanceCrossedSoFar = pathIt.LengthSoFar - startingLength;
            float epsilon = Math.Max(Epsilon, distance * Epsilon * 100.0f);
            if ((distance - distanceCrossedSoFar) <= epsilon)
                return false;
            if (distanceCrossedSoFar + stepDistance > distance)
                unitsRemaining = distance - distanceCrossedSoFar;
            else unitsRemaining = stepDistance;
            return true;
        }

        static void HandleNewSegmentJoining(PathDistanceForwardIterator pathIt, PathPatternIterator patternIt, JoiningInfo[] joiningInfo, float halfThickness, float[] segmentLengths)
        {
            joiningInfo[0] = joiningInfo[1];
            joiningInfo[1] = null;

            if (!patternIt.IsSolidAt(pathIt.LengthSoFar + segmentLengths[pathIt.CurrentSegment]))
                return; // The joining center falls outside the pattern, so don't join... period

            if (pathIt.Closed && pathIt.Segments.Count <= 2)
                return; // Not enough segments to do proper closing

            if (pathIt.Closed)
            {
                JoiningInfo closing;
                if ((pathIt.CurrentSegment == 0) || (pathIt.CurrentSegment == pathIt.Segments.Count - 2))
                {
                    closing = ForeseeJoining(
                            VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.Segments.Count - 2),
                            VectorUtils.PathSegmentAtIndex(pathIt.Segments, 0),
                            halfThickness, segmentLengths[pathIt.Segments.Count - 2]);

                    if (pathIt.CurrentSegment == 0)
                        joiningInfo[0] = closing;
                    else
                    {
                        joiningInfo[1] = closing;
                        return;
                    }
                }
                else if (pathIt.CurrentSegment > pathIt.Segments.Count - 2)
                    return;
            }
            else if (pathIt.CurrentSegment >= pathIt.Segments.Count - 2)
                return;

            joiningInfo[1] = ForeseeJoining(
                    VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.CurrentSegment),
                    VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.CurrentSegment + 1),
                    halfThickness, segmentLengths[pathIt.CurrentSegment]);
        }

        static void SkipRange(
            float distance, PathDistanceForwardIterator pathIt, PathPatternIterator patternIt,
            PathProperties pathProps, JoiningInfo[] joiningInfo, float[] segmentLengths)
        {
            float unitsRemaining = distance;
            while (unitsRemaining > Epsilon)
            {
                var result = pathIt.AdvanceBy(unitsRemaining, out unitsRemaining);
                switch (result)
                {
                    case PathDistanceForwardIterator.Result.Ended:
                        return;
                    case PathDistanceForwardIterator.Result.Stepped:
                        if (unitsRemaining < Epsilon)
                            return;
                        break;
                    case PathDistanceForwardIterator.Result.NewSegment:
                        HandleNewSegmentJoining(pathIt, patternIt, joiningInfo, pathProps.Stroke.HalfThickness, segmentLengths);
                        break;
                }
            }
        }

        static void TessellateRange(
            float distance, PathDistanceForwardIterator pathIt, PathPatternIterator patternIt, PathProperties pathProps,
            TessellationOptions tessellateOptions, JoiningInfo[] joiningInfo, float[] segmentLengths, float totalLength, int rangeIndex, List<Vector2> verts, List<UInt16> inds)
        {
            bool startOfLoop = pathIt.Closed && (pathIt.CurrentSegment == 0) && (pathIt.CurrentT == 0.0f);
            if (startOfLoop && (joiningInfo[0] != null))
            {
                GenerateJoining(joiningInfo[0], pathProps.Corners, pathProps.Stroke.HalfThickness, pathProps.Stroke.TippedCornerLimit, tessellateOptions, verts, inds);
            }
            else
            {
                var pathEnding = pathProps.Head;

                // If pattern at the end will overlap with beginning, use a chopped ending to allow merging
                if (pathIt.Closed && rangeIndex == 0 && patternIt.IsSolidAt(pathIt.CurrentT) && patternIt.IsSolidAt(totalLength))
                    pathEnding = PathEnding.Chop;

                GenerateTip(VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.CurrentSegment), true, pathIt.CurrentT, pathEnding, pathProps.Stroke.HalfThickness, tessellateOptions, verts, inds);
            }

            float startingLength = pathIt.LengthSoFar;
            float unitsRemaining = Mathf.Min(tessellateOptions.StepDistance, distance);
            bool endedEntirePath = false;
            for (;;)
            {
                var result = pathIt.AdvanceBy(unitsRemaining, out unitsRemaining);
                if (result == PathDistanceForwardIterator.Result.Ended)
                {
                    endedEntirePath = true;
                    break;
                }
                else if (result == PathDistanceForwardIterator.Result.NewSegment)
                {
                    if (joiningInfo[1] != null)
                        GenerateJoining(joiningInfo[1], pathProps.Corners, pathProps.Stroke.HalfThickness, pathProps.Stroke.TippedCornerLimit, tessellateOptions, verts, inds);
                    else AddSegment(VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.CurrentSegment), pathIt.CurrentT, pathProps.Stroke.HalfThickness, null, pathIt.SegmentLengthSoFar, verts, inds);
                    HandleNewSegmentJoining(pathIt, patternIt, joiningInfo, pathProps.Stroke.HalfThickness, segmentLengths);
                }

                if ((unitsRemaining <= Epsilon) &&
                    !TryGetMoreRemainingUnits(ref unitsRemaining, pathIt, startingLength, distance, tessellateOptions.StepDistance))
                {
                    break;
                }

                if (result == PathDistanceForwardIterator.Result.Stepped)
                    AddSegment(VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.CurrentSegment), pathIt.CurrentT, pathProps.Stroke.HalfThickness, joiningInfo, pathIt.SegmentLengthSoFar, verts, inds);
            }

            // Ending
            if (endedEntirePath && pathIt.Closed)
            {
                // No joining needed, the start and end of the path should just connect
                inds.Add(0);
                inds.Add(1);
                inds.Add((UInt16)(verts.Count - 2));
                inds.Add((UInt16)(verts.Count - 1));
                inds.Add((UInt16)(verts.Count - 2));
                inds.Add(1);
            }
            else
            {
                AddSegment(VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.CurrentSegment), pathIt.CurrentT, pathProps.Stroke.HalfThickness, joiningInfo, pathIt.SegmentLengthSoFar, verts, inds);
                GenerateTip(VectorUtils.PathSegmentAtIndex(pathIt.Segments, pathIt.CurrentSegment), false, pathIt.CurrentT, pathProps.Tail, pathProps.Stroke.HalfThickness, tessellateOptions, verts, inds);
            }
        }

        static void AddSegment(BezierSegment segment, float toT, float halfThickness, JoiningInfo[] joinInfo, float segmentLengthSoFar, List<Vector2> verts, List<UInt16> inds)
        {
            Vector2 tanTo, normTo;
            Vector2 posTo = VectorUtils.EvalFull(segment, toT, out tanTo, out normTo);

            Vector2 posThickness = posTo + normTo * halfThickness;
            Vector2 negThickness = posTo + normTo * -halfThickness;

            if (joinInfo != null)
            {
                if ((joinInfo[0] != null) && (segmentLengthSoFar < joinInfo[0].InnerCornerDistFromStart))
                {
                    if (joinInfo[0].RoundPosThickness)
                        negThickness = joinInfo[0].InnerCornerVertex;
                    else posThickness = joinInfo[0].InnerCornerVertex;
                }

                if ((joinInfo[1] != null) && (segmentLengthSoFar > joinInfo[1].InnerCornerDistToEnd))
                {
                    if (joinInfo[1].RoundPosThickness)
                        negThickness = joinInfo[1].InnerCornerVertex;
                    else posThickness = joinInfo[1].InnerCornerVertex;
                }
            }

            System.Diagnostics.Debug.Assert(verts.Count >= 2);
            int indexStart = verts.Count - 2;
            verts.Add(posThickness);
            verts.Add(negThickness);
            inds.Add((UInt16)(indexStart + 0));
            inds.Add((UInt16)(indexStart + 3));
            inds.Add((UInt16)(indexStart + 1));
            inds.Add((UInt16)(indexStart + 0));
            inds.Add((UInt16)(indexStart + 2));
            inds.Add((UInt16)(indexStart + 3));
        }

        class JoiningInfo
        {
            public Vector2 JoinPos;
            public Vector2 TanAtEnd, TanAtStart;
            public Vector2 NormAtEnd, NormAtStart;
            public Vector2 PosThicknessStart, NegThicknessStart;
            public Vector2 PosThicknessEnd, NegThicknessEnd;
            public Vector2 PosThicknessClosingPoint, NegThicknessClosingPoint;
            public bool RoundPosThickness;
            public bool SimpleJoin;
            public Vector2 InnerCornerVertex;
            public float InnerCornerDistToEnd, InnerCornerDistFromStart;
        }

        static JoiningInfo ForeseeJoining(BezierSegment end, BezierSegment start, float halfThickness, float endSegmentLength)
        {
            JoiningInfo joinInfo = new JoiningInfo();

            // The joining generates the vertices at both ends as well as the joining itself
            joinInfo.JoinPos = end.P3;
            joinInfo.TanAtEnd = VectorUtils.EvalTangent(end, 1.0f);
            joinInfo.NormAtEnd = Vector2.Perpendicular(joinInfo.TanAtEnd);
            joinInfo.TanAtStart = VectorUtils.EvalTangent(start, 0.0f);
            joinInfo.NormAtStart = Vector2.Perpendicular(joinInfo.TanAtStart);

            // If the tangents are continuous at the join location, we don't have
            // to generate a corner, we do a "simple" join by just connecting the vertices
            // from the two segments directly
            float cosAngleBetweenTans = Vector2.Dot(joinInfo.TanAtEnd, joinInfo.TanAtStart);
            joinInfo.SimpleJoin = Mathf.Approximately(Mathf.Abs(cosAngleBetweenTans), 1.0f);
            if (joinInfo.SimpleJoin)
                return null;

            joinInfo.PosThicknessEnd = joinInfo.JoinPos + joinInfo.NormAtEnd * halfThickness;
            joinInfo.NegThicknessEnd = joinInfo.JoinPos - joinInfo.NormAtEnd * halfThickness;
            joinInfo.PosThicknessStart = joinInfo.JoinPos + joinInfo.NormAtStart * halfThickness;
            joinInfo.NegThicknessStart = joinInfo.JoinPos - joinInfo.NormAtStart * halfThickness;

            if (joinInfo.SimpleJoin)
            {
                joinInfo.PosThicknessClosingPoint = Vector2.LerpUnclamped(joinInfo.PosThicknessEnd, joinInfo.PosThicknessStart, 0.5f);
                joinInfo.NegThicknessClosingPoint = Vector2.LerpUnclamped(joinInfo.NegThicknessEnd, joinInfo.NegThicknessStart, 0.5f);
            }
            else
            {
                joinInfo.PosThicknessClosingPoint = VectorUtils.IntersectLines(joinInfo.PosThicknessEnd, joinInfo.PosThicknessEnd + joinInfo.TanAtEnd, joinInfo.PosThicknessStart, joinInfo.PosThicknessStart + joinInfo.TanAtStart);
                joinInfo.NegThicknessClosingPoint = VectorUtils.IntersectLines(joinInfo.NegThicknessEnd, joinInfo.NegThicknessEnd + joinInfo.TanAtEnd, joinInfo.NegThicknessStart, joinInfo.NegThicknessStart + joinInfo.TanAtStart);

                if (float.IsInfinity(joinInfo.PosThicknessClosingPoint.x) || float.IsInfinity(joinInfo.PosThicknessClosingPoint.y))
                    joinInfo.PosThicknessClosingPoint = joinInfo.JoinPos;
                if (float.IsInfinity(joinInfo.NegThicknessClosingPoint.x) || float.IsInfinity(joinInfo.NegThicknessClosingPoint.y))
                    joinInfo.NegThicknessClosingPoint = joinInfo.JoinPos;
            }

            // Should we round the positive thickness side or the negative thickness side?
            joinInfo.RoundPosThickness = PointOnTheLeftOfLine(Vector2.zero, joinInfo.TanAtEnd, joinInfo.TanAtStart);

            // Inner corner vertex should be calculated by intersection of the inner segments
            Vector2[] startTrail = null, endTrail = null;
            Vector2 intersectionOnStart = Vector2.zero, intersectionOnEnd = Vector2.zero;
            if (!joinInfo.SimpleJoin)
            {
                BezierSegment endFlipped = VectorUtils.FlipSegment(end);
                Vector2 thicknessClosingPoint = joinInfo.RoundPosThickness ? joinInfo.PosThicknessClosingPoint : joinInfo.NegThicknessClosingPoint;
                Vector2 meetingPoint = end.P3;
                Vector2 thicknessDiagonalEnd = meetingPoint + (thicknessClosingPoint - meetingPoint) * 10.0f;
                startTrail = LineBezierThicknessIntersect(
                        start, joinInfo.RoundPosThickness ? -halfThickness : halfThickness, meetingPoint, thicknessDiagonalEnd,
                        out joinInfo.InnerCornerDistFromStart, out intersectionOnStart);
                endTrail = LineBezierThicknessIntersect(
                        endFlipped, joinInfo.RoundPosThickness ? halfThickness : -halfThickness, meetingPoint, thicknessDiagonalEnd,
                        out joinInfo.InnerCornerDistToEnd, out intersectionOnEnd);
            }

            bool intersectionFound = false;
            if ((startTrail != null) && (endTrail != null))
            {
                var intersect = VectorUtils.IntersectLines(startTrail[0], startTrail[1], endTrail[0], endTrail[1]);
                var isOnStartTrail = PointOnLineIsWithinSegment(startTrail[0], startTrail[1], intersect);
                var isOnEndTrail = PointOnLineIsWithinSegment(endTrail[0], endTrail[1], intersect);
                if (!float.IsInfinity(intersect.x) && isOnStartTrail && isOnEndTrail)
                {
                    var vStart = intersectionOnStart - intersect;
                    var vEnd = intersectionOnEnd - intersect;
                    joinInfo.InnerCornerDistFromStart += (vStart == Vector2.zero) ? 0.0f : vStart.magnitude;
                    joinInfo.InnerCornerDistToEnd += (vEnd == Vector2.zero) ? 0.0f : vEnd.magnitude;
                    joinInfo.InnerCornerDistToEnd = endSegmentLength - joinInfo.InnerCornerDistToEnd;
                    joinInfo.InnerCornerVertex = intersect; // Found it!
                    intersectionFound = true;
                }
            }

            if (!intersectionFound)
            {
                joinInfo.InnerCornerVertex = joinInfo.JoinPos + ((joinInfo.TanAtStart - joinInfo.TanAtEnd) / 2.0f).normalized * halfThickness;
                joinInfo.InnerCornerDistFromStart = 0;
                joinInfo.InnerCornerDistToEnd = endSegmentLength;
            }
            return joinInfo;
        }

        static Vector2[] LineBezierThicknessIntersect(BezierSegment seg, float thickness, Vector2 lineFrom, Vector2 lineTo, out float distanceToIntersection, out Vector2 intersection)
        {
            Vector2 tan = VectorUtils.EvalTangent(seg, 0.0f);
            Vector2 nrm = Vector2.Perpendicular(tan);
            Vector2 lastPoint = seg.P0 + nrm * thickness;
            distanceToIntersection = 0.0f;
            intersection = new Vector2(float.PositiveInfinity, float.PositiveInfinity);
            float stepT = 0.01f;
            float t = 0;
            while (t < 1.0f)
            {
                t += stepT;
                var point = VectorUtils.EvalFull(seg, t, out tan, out nrm) + nrm * thickness;
                intersection = VectorUtils.IntersectLines(lineFrom, lineTo, lastPoint, point);
                if (PointOnLineIsWithinSegment(lastPoint, point, intersection))
                {
                    distanceToIntersection += (lastPoint - intersection).magnitude;
                    return new Vector2[] { lastPoint, point };
                }
                distanceToIntersection += (lastPoint - point).magnitude;
                lastPoint = point;
            }
            return null;
        }

        static bool PointOnLineIsWithinSegment(Vector2 lineFrom, Vector2 lineTo, Vector2 point)
        {
            // Point is assumed to be already on the line, but we would like to know if it is within the segment specified
            var v = (lineTo - lineFrom).normalized;
            if (Vector2.Dot(point - lineFrom,  v) < -Epsilon)
                return false;
            if (Vector2.Dot(point - lineTo, v) > Epsilon)
                return false;
            return true;
        }

        static void GenerateJoining(JoiningInfo joinInfo, PathCorner corner, float halfThickness, float tippedCornerLimit, TessellationOptions tessellateOptions, List<Vector2> verts, List<UInt16> inds)
        {
            // The joining generates the vertices at both ends as well as the joining itself
            if (verts.Count == 0)
            {
                // Starting a path with a joining (meaning a loop)
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.PosThicknessEnd : joinInfo.InnerCornerVertex);
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.InnerCornerVertex : joinInfo.NegThicknessEnd);
            }

            System.Diagnostics.Debug.Assert(verts.Count >= 2);
            int indexStart = verts.Count - 2; // Using the last two vertices

            // Convert a tipped corner to a beveled one if tippedCornerLimit ratio is reached
            if (corner == PathCorner.Tipped && tippedCornerLimit >= 1.0f)
            {
                var theta = Vector2.Angle(-joinInfo.TanAtEnd, joinInfo.TanAtStart) * Mathf.Deg2Rad;
                var ratio = 1.0f / Mathf.Sin(theta / 2.0f);
                if (ratio > tippedCornerLimit)
                    corner = PathCorner.Beveled;
            }

            if (joinInfo.SimpleJoin)
            {
                // TODO
            }
            else if (corner == PathCorner.Tipped)
            {
                verts.Add(joinInfo.PosThicknessClosingPoint);
                verts.Add(joinInfo.NegThicknessClosingPoint);
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.PosThicknessStart : joinInfo.InnerCornerVertex);
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.InnerCornerVertex : joinInfo.NegThicknessStart);

                // Ending to tip
                inds.Add((UInt16)(indexStart + 0));
                inds.Add((UInt16)(indexStart + 3));
                inds.Add((UInt16)(indexStart + 1));
                inds.Add((UInt16)(indexStart + 0));
                inds.Add((UInt16)(indexStart + 2));
                inds.Add((UInt16)(indexStart + 3));

                // Tip to starting
                inds.Add((UInt16)(indexStart + 4));
                inds.Add((UInt16)(indexStart + 3));
                inds.Add((UInt16)(indexStart + 2));
                inds.Add((UInt16)(indexStart + 4));
                inds.Add((UInt16)(indexStart + 5));
                inds.Add((UInt16)(indexStart + 3));

                return;
            }
            else if (corner == PathCorner.Beveled)
            {
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.PosThicknessEnd : joinInfo.InnerCornerVertex); // 2
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.InnerCornerVertex : joinInfo.NegThicknessEnd); // 3
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.PosThicknessStart : joinInfo.InnerCornerVertex); // 4
                verts.Add(joinInfo.RoundPosThickness ? joinInfo.InnerCornerVertex : joinInfo.NegThicknessStart); // 5

                // Ending to tip
                inds.Add((UInt16)(indexStart + 0));
                inds.Add((UInt16)(indexStart + 2));
                inds.Add((UInt16)(indexStart + 1));
                inds.Add((UInt16)(indexStart + 1));
                inds.Add((UInt16)(indexStart + 2));
                inds.Add((UInt16)(indexStart + 3));

                // Bevel
                if (joinInfo.RoundPosThickness)
                {
                    inds.Add((UInt16)(indexStart + 2));
                    inds.Add((UInt16)(indexStart + 4));
                    inds.Add((UInt16)(indexStart + 3));
                }
                else
                {
                    inds.Add((UInt16)(indexStart + 3));
                    inds.Add((UInt16)(indexStart + 2));
                    inds.Add((UInt16)(indexStart + 5));
                }

                return;
            }

            if (corner == PathCorner.Round)
            {
                float sweepAngle = Mathf.Acos(Vector2.Dot(joinInfo.NormAtEnd, joinInfo.NormAtStart));
                bool flipArc = false;
                if (!PointOnTheLeftOfLine(Vector2.zero, joinInfo.NormAtEnd, joinInfo.NormAtStart))
                {
                    sweepAngle = -sweepAngle;
                    flipArc = true;
                }

                UInt16 innerCornerVertexIndex = (UInt16)verts.Count;
                verts.Add(joinInfo.InnerCornerVertex);

                int arcSegments = CalculateArcSteps(halfThickness, 0, sweepAngle, tessellateOptions);
                for (int i = 0; i <= arcSegments; i++)
                {
                    float angle = sweepAngle * (i / (float)arcSegments);
                    Vector2 nrm = Matrix2D.RotateLH(angle) * joinInfo.NormAtEnd;
                    if (flipArc) nrm = -nrm;
                    verts.Add(nrm * halfThickness + joinInfo.JoinPos);

                    if (i == 0)
                    {
                        inds.Add((UInt16)(indexStart + 0));
                        inds.Add((UInt16)(indexStart + 3));
                        inds.Add((UInt16)(indexStart + (joinInfo.RoundPosThickness ? 2 : 1)));

                        inds.Add((UInt16)(indexStart + 0));
                        inds.Add((UInt16)(indexStart + 2));
                        inds.Add((UInt16)(indexStart + (joinInfo.RoundPosThickness ? 1 : 3)));
                    }
                    else
                    {
                        if (joinInfo.RoundPosThickness)
                        {
                            inds.Add((UInt16)(indexStart + i + (flipArc ? 3 : 2)));
                            inds.Add((UInt16)(indexStart + i + (flipArc ? 2 : 3)));
                            inds.Add(innerCornerVertexIndex);
                        }
                        else
                        {
                            inds.Add((UInt16)(indexStart + i + (flipArc ? 3 : 2)));
                            inds.Add((UInt16)(indexStart + i + (flipArc ? 2 : 3)));
                            inds.Add(innerCornerVertexIndex);
                        }
                    }
                }

                // Manually add the last segment, maintain the expected vertex positioning
                int endingVerticesIndex = verts.Count;
                if (joinInfo.RoundPosThickness)
                {
                    verts.Add(joinInfo.PosThicknessStart);
                    verts.Add(joinInfo.InnerCornerVertex);
                }
                else
                {
                    verts.Add(joinInfo.InnerCornerVertex);
                    verts.Add(joinInfo.NegThicknessStart);
                }
                inds.Add((UInt16)(endingVerticesIndex - 1));
                inds.Add((UInt16)(endingVerticesIndex + 0));
                inds.Add(innerCornerVertexIndex);
            }
        }

        static void GenerateTip(BezierSegment segment, bool atStart, float t, PathEnding ending, float halfThickness, TessellationOptions tessellateOptions, List<Vector2> verts, List<UInt16> inds)
        {
            // The tip includes the vertices at the end itself
            Vector2 tan, nrm;
            var pos = VectorUtils.EvalFull(segment, t, out tan, out nrm);
            int indexStart = verts.Count;

            switch (ending)
            {
                case PathEnding.Chop:
                    if (atStart)
                    {
                        verts.Add(pos + nrm * halfThickness);
                        verts.Add(pos - nrm * halfThickness);
                    }
                    else
                    {
                        // Not much, path segments are always expected to be generated perpendicular to the path
                        // at the segment point location, so we don't have to do anything for the ending
                    }
                    break;

                case PathEnding.Square:
                    if (atStart)
                    {
                        verts.Add(pos + nrm * halfThickness - tan * halfThickness);
                        verts.Add(pos - nrm * halfThickness - tan * halfThickness);
                        verts.Add(pos + nrm * halfThickness);
                        verts.Add(pos - nrm * halfThickness);

                        inds.Add((UInt16)(indexStart + 0));
                        inds.Add((UInt16)(indexStart + 3));
                        inds.Add((UInt16)(indexStart + 1));
                        inds.Add((UInt16)(indexStart + 0));
                        inds.Add((UInt16)(indexStart + 2));
                        inds.Add((UInt16)(indexStart + 3));
                    }
                    else
                    {
                        // Relying on the last two vertices, and just adding two of our own here
                        verts.Add(pos + nrm * halfThickness + tan * halfThickness);
                        verts.Add(pos - nrm * halfThickness + tan * halfThickness);

                        inds.Add((UInt16)(indexStart + 0 - 2));
                        inds.Add((UInt16)(indexStart + 3 - 2));
                        inds.Add((UInt16)(indexStart + 1 - 2));
                        inds.Add((UInt16)(indexStart + 0 - 2));
                        inds.Add((UInt16)(indexStart + 2 - 2));
                        inds.Add((UInt16)(indexStart + 3 - 2));
                    }
                    break;

                case PathEnding.Round:
                    float arcSign = atStart ? -1 : 1;
                    int arcSegments = CalculateArcSteps(halfThickness, 0, Mathf.PI, tessellateOptions);
                    for (int i = 1; i < arcSegments; i++)
                    {
                        float angle = Mathf.PI * (i / (float)arcSegments);
                        verts.Add(pos + Matrix2D.RotateLH(angle) * nrm * halfThickness * arcSign);
                    }

                    if (atStart)
                    {
                        // Note how we maintain the last two vertices being setup for connection by the rest of the path vertices
                        int indexTipStart = verts.Count;
                        verts.Add(pos + nrm * halfThickness);
                        verts.Add(pos - nrm * halfThickness);

                        for (int i = 1; i < arcSegments; i++)
                        {
                            inds.Add((UInt16)(indexTipStart + 1));
                            inds.Add((UInt16)(indexStart + i - 1));
                            inds.Add((UInt16)(indexStart + i));
                        }
                    }
                    else
                    {
                        inds.Add((UInt16)(indexStart - 1));
                        inds.Add((UInt16)(indexStart - 2));
                        inds.Add((UInt16)(indexStart + 0));
                        for (int i = 1; i < arcSegments - 1; i++)
                        {
                            inds.Add((UInt16)(indexStart - 1));
                            inds.Add((UInt16)(indexStart + i - 1));
                            inds.Add((UInt16)(indexStart + i));
                        }
                    }
                    break;

                default:
                    System.Diagnostics.Debug.Assert(false); // Joining has its own function
                    break;
            }
        }

        static int CalculateArcSteps(float radius, float fromAngle, float toAngle, TessellationOptions tessellateOptions)
        {
            float stepDivisor = float.MaxValue;

            if (tessellateOptions.StepDistance != float.MaxValue)
                stepDivisor = tessellateOptions.StepDistance / radius;

            if (tessellateOptions.MaxCordDeviation != float.MaxValue)
            {
                float y = radius - tessellateOptions.MaxCordDeviation;
                float cordHalfLength = Mathf.Sqrt(radius * radius - y * y);
                float div = Mathf.Min(stepDivisor, Mathf.Asin(cordHalfLength / radius));
                if (div > VectorUtils.Epsilon)
                    stepDivisor = div;
            }

            if (tessellateOptions.MaxTanAngleDeviation < Mathf.PI * 0.5f)
                stepDivisor = Mathf.Min(stepDivisor, tessellateOptions.MaxTanAngleDeviation * 2.0f);

            float stepsInFullCircle = (Mathf.PI * 2.0f) / stepDivisor;
            float arcPercentage = Mathf.Abs(fromAngle - toAngle) / (Mathf.PI * 2.0f);
            return (int)Mathf.Max(stepsInFullCircle * arcPercentage + 0.5f, 3); // Never less than 3 segments
        }

        /// <summary>Tessellates a rectangle.</summary>
        /// <param name="rect">Rectangle to tessellate</param>
        /// <param name="vertices">The output vertices</param>
        /// <param name="indices">The output triangles</param>
        public static void TessellateRect(Rect rect, out Vector2[] vertices, out UInt16[] indices)
        {
            vertices = new Vector2[] {
                new Vector2(rect.xMin, rect.yMin),
                new Vector2(rect.xMax, rect.yMin),
                new Vector2(rect.xMax, rect.yMax),
                new Vector2(rect.xMin, rect.yMax)
            };
            indices = new UInt16[] {
                1, 0, 2, 2, 0, 3
            };
        }

        /// <summary>Tessellates a rectangle border.</summary>
        /// <param name="rect">Rectangle to tessellate</param>
        /// <param name="halfThickness">The half-thickness of the border</param>
        /// <param name="vertices">The output vertices</param>
        /// <param name="indices">The output triangles</param>
        public static void TessellateRectBorder(Rect rect, float halfThickness, out Vector2[] vertices, out UInt16[] indices)
        {
            var verts = new List<Vector2>(16);
            var inds = new List<UInt16>(24);

            // Left edge
            var p0 = new Vector2(rect.x, rect.y + rect.height);
            var p1 = new Vector2(rect.x, rect.y);

            var q0 = p0 + new Vector2(-halfThickness, halfThickness);
            var q1 = p1 + new Vector2(-halfThickness, -halfThickness);
            var q2 = p1 + new Vector2(halfThickness, halfThickness);
            var q3 = p0 + new Vector2(halfThickness, -halfThickness);

            verts.Add(q0); verts.Add(q1); verts.Add(q2); verts.Add(q3);
            inds.Add(0); inds.Add(3); inds.Add(2); inds.Add(2); inds.Add(1); inds.Add(0);

            // Top edge
            p0 = new Vector2(rect.x, rect.y);
            p1 = new Vector2(rect.x + rect.width, rect.y);

            q0 = p0 + new Vector2(-halfThickness, -halfThickness);
            q1 = p1 + new Vector2(halfThickness, -halfThickness);
            q2 = p1 + new Vector2(-halfThickness, halfThickness);
            q3 = p0 + new Vector2(halfThickness, halfThickness);

            verts.Add(q0); verts.Add(q1); verts.Add(q2); verts.Add(q3);
            inds.Add(4); inds.Add(7); inds.Add(6); inds.Add(6); inds.Add(5); inds.Add(4);

            // Right edge
            p0 = new Vector2(rect.x + rect.width, rect.y);
            p1 = new Vector2(rect.x + rect.width, rect.y + rect.height);

            q0 = p0 + new Vector2(halfThickness, -halfThickness);
            q1 = p1 + new Vector2(halfThickness, halfThickness);
            q2 = p1 + new Vector2(-halfThickness, -halfThickness);
            q3 = p0 + new Vector2(-halfThickness, halfThickness);

            verts.Add(q0); verts.Add(q1); verts.Add(q2); verts.Add(q3);
            inds.Add(8); inds.Add(11); inds.Add(10); inds.Add(10); inds.Add(9); inds.Add(8);

            // Bottom edge
            p0 = new Vector2(rect.x + rect.width, rect.y + rect.height);
            p1 = new Vector2(rect.x, rect.y + rect.height);

            q0 = p0 + new Vector2(halfThickness, halfThickness);
            q1 = p1 + new Vector2(-halfThickness, halfThickness);
            q2 = p1 + new Vector2(halfThickness, -halfThickness);
            q3 = p0 + new Vector2(-halfThickness, -halfThickness);

            verts.Add(q0); verts.Add(q1); verts.Add(q2); verts.Add(q3);
            inds.Add(12); inds.Add(15); inds.Add(14); inds.Add(14); inds.Add(13); inds.Add(12);

            vertices = verts.ToArray();
            indices = inds.ToArray();
        }
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorTessellation.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorUtils.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bc6ce72ebfec4b24faaee0fa9df6a984
# ASMDEF: ToolBuddy.Curvy.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace ToolBuddy.ThirdParty.VectorGraphics
{
    /// <summary>
    /// Provides various tools to work with vector graphics.
    /// </summary>
    public static partial class VectorUtils
    {
        /// <summary>A small value used everywhere by the vector graphics package.</summary>
        public static readonly float Epsilon = 0.000001f;

        /// <summary>Convert a segments into a path.</summary>
        /// <param name="segment">The BezierSegment</param>
        /// <returns>An array of two path segments</returns>
        /// <remarks>The second path segment will hold the ending position of the curve.</remarks>
        public static BezierPathSegment[] BezierSegmentToPath(BezierSegment segment)
        {
            return new BezierPathSegment[] {
                new BezierPathSegment() { P0 = segment.P0, P1 = segment.P1, P2 = segment.P2 },
                new BezierPathSegment() { P0 = segment.P3 }
            };
        }

        /// <summary>Converts an array of BezierSegments into a connected path.</summary>
        /// <param name="segments">An array of BezierSegment</param>
        /// <returns>An array of path segments</returns>
        /// <remarks>If two consecutive segments are disconnected, a straight line will be added between the two endpoints.</remarks>
        public static BezierPathSegment[] BezierSegmentsToPath(BezierSegment[] segments)
        {
            if (segments.Count() == 0)
                return new BezierPathSegment[0];

            int segmentCount = segments.Length;
            var path = new List<BezierPathSegment>(segments.Length*2 + 1);
            for (int i = 0; i < segmentCount; ++i)
            {
                var seg = segments[i];
                path.Add(new BezierPathSegment() { P0 = seg.P0, P1 = seg.P1, P2 = seg.P2 });

                if (i == (segmentCount-1))
                {
                    // Last segment, close the path
                    path.Add(new BezierPathSegment() { P0 = seg.P3 });
                }
                else
                {
                    // Check for connectivity, insert path to connect the endpoints when needed
                    var nextSeg = segments[i+1];
                    if (seg.P3 != nextSeg.P0)
                    {
                        var line = VectorUtils.MakeLine(seg.P3, nextSeg.P0);
                        path.Add(new BezierPathSegment() { P0 = line.P0, P1 = line.P1, P2 = line.P2 });
                    }
                }
            }

            return path.ToArray();
        }

        /// <summary>
        /// Computes the BezierSegment at a given index from a list of BezierPathSegments.
        /// </summary>
        /// <param name="path">The chain of BezierPathSegments</param>
        /// <param name="index">The segment index</param>
        /// <returns>The BezierSegment at the given index</returns>
        public static BezierSegment PathSegmentAtIndex(IList<BezierPathSegment> path, int index)
        {
            if (index < 0 || index >= (path.Count-1))
                throw new IndexOutOfRangeException("Invalid index passed to PathSegmentAtIndex");

            return new BezierSegment() { P0 = path[index].P0, P1 = path[index].P1, P2 = path[index].P2, P3 = path[index + 1].P0 };
        }

        /// <summary>
        /// Checks if the two ends of a BezierPathSegment chain are at the same location.
        /// </summary>
        /// <param name="path">The chain of BezierPathSegments</param>
        /// <returns>True if the two ends of the chain are at the same location, false otherwise</returns>
        public static bool PathEndsPerfectlyMatch(IList<BezierPathSegment> path)
        {
            if (path.Count < 2)
                return false;

            if ((path[0].P0 - path[path.Count - 1].P0).sqrMagnitude > Epsilon)
                return false;

            return true;
        }

        /// <summary>Builds a rectangle shape.</summary>
        /// <param name="rectShape">The shape object that will be filled with a rectangle.</param>
        /// <param name="rect">The position and dimensions of the rectangle.</param>
        public static void MakeRectangleShape(Shape rectShape, Rect rect)
        {
            MakeRectangleShape(rectShape, rect, Vector2.zero, Vector2.zero, Vector2.zero, Vector2.zero);
        }

        /// <summary>Builds a rectangle shape.</summary>
        /// <param name="rectShape">The shape object that will be filled with a rectangle.</param>
        /// <param name="rect">The position and dimensions of the rectangle.</param>
        /// <param name="radiusTL">The top-left radius of the rectangle</param>
        /// <param name="radiusTR">The top-right radius of the rectangle</param>
        /// <param name="radiusBR">The bottom-right radius of the rectangle</param>
        /// <param name="radiusBL">The bottom-left radius of the rectangle</param>
        public static void MakeRectangleShape(Shape rectShape, Rect rect, Vector2 radiusTL, Vector2 radiusTR, Vector2 radiusBR, Vector2 radiusBL)
        {
            var contour = BuildRectangleContour(rect, radiusTL, radiusTR, radiusBR, radiusBL);
            if (rectShape.Contours == null || rectShape.Contours.Length != 1)
                rectShape.Contours = new BezierContour[1];
            rectShape.Contours[0] = contour;
            rectShape.IsConvex = true;
        }

        /// <summary>Builds an ellipse shape.</summary>
        /// <param name="ellipseShape">The shape object that will be filled with an ellipse.</param>
        /// <param name="pos">The position of the circle, relative to its center.</param>
        /// <param name="radiusX">The x component of the radius of the circle.</param>
        /// <param name="radiusY">The y component of the radius of the circle.</param>
        public static void MakeEllipseShape(Shape ellipseShape, Vector2 pos, float radiusX, float radiusY)
        {
            var rect = new Rect(pos.x-radiusX, pos.y-radiusY, radiusX+radiusX, radiusY+radiusY);
            var rad = new Vector2(radiusX, radiusY);
            MakeRectangleShape(ellipseShape, rect, rad, rad, rad, rad);
        }

        /// <summary>Builds a circle shape.</summary>
        /// <param name="circleShape">The shape object that will be filled with a circle.</param>
        /// <param name="pos">The position of the circle, relative to its center.</param>
        /// <param name="radius">The radius of the circle.</param>
        public static void MakeCircleShape(Shape circleShape, Vector2 pos, float radius)
        {
            MakeEllipseShape(circleShape, pos, radius, radius);
        }

        /// <summary>Computes the bounds of a bezier path.</summary>
        /// <param name="path">The path to compute the bounds from</param>
        /// <returns>A Rect containing the axis-aligned bounding-box of the contour</returns>
        public static Rect Bounds(BezierPathSegment[] path)
        {
            var min = new Vector2(float.MaxValue, float.MaxValue);
            var max = new Vector2(-float.MaxValue, -float.MaxValue);
            foreach (var s in VectorUtils.SegmentsInPath(path))
            {
                Vector2 segMin, segMax;
                Bounds(s, out segMin, out segMax);
                min = Vector2.Min(min, segMin);
                max = Vector2.Max(max, segMax);
            }
            return (min.x != float.MaxValue) ? new Rect(min, max - min) : Rect.zero;
        }

        /// <summary>Computes the bounds of a list of vertices.</summary>
        /// <param name="vertices">The list of vertices to compute the bounds from</param>
        /// <returns>A Rect containing the axis-aligned bounding-box of the vertices</returns>
        public static Rect Bounds(IEnumerable<Vector2> vertices)
        {
            var min = new Vector2(float.MaxValue, float.MaxValue);
            var max = new Vector2(-float.MaxValue, -float.MaxValue);
            foreach (var v in vertices)
            {
                min = Vector2.Min(min, v);
                max = Vector2.Max(max, v);
            }
            return (min.x != float.MaxValue) ? new Rect(min, max - min) : Rect.zero;
        }

        /// <summary>Builds a line segment.</summary>
        /// <param name="from">The starting position of the line segment</param>
        /// <param name="to">The ending position of the line segment</param>
        /// <returns>A straight line BezierSegment</returns>
        /// <remarks>The control points are spaced out equally to maintain a constant speed on t</remarks>
        public static BezierSegment MakeLine(Vector2 from, Vector2 to)
        {
            return new BezierSegment()
            {
                P0 = from,
                P1 = (to - from) / 3.0f + from,
                P2 = (to - from) * 2.0f / 3.0f + from,
                P3 = to
            };
        }

        /// <summary>Converts a quadratic bezier to a cubic bezier</summary>
        /// <param name="p0">The starting position of the quadratic segment</param>
        /// <param name="p1">The control position of the quadratic segment</param>
        /// <param name="p2">The ending position of the quadratic segment</param>
        /// <returns>The resulting BezierSegment</returns>
        public static BezierSegment QuadraticToCubic(Vector2 p0, Vector2 p1, Vector2 p2)
        {
            var p = p1;
            var t = 2.0f / 3.0f;
            return new BezierSegment() {
                P0 = p0,
                P1 = p0 + t * (p - p0),
                P2 = p2 + t * (p - p2),
                P3 = p2,
            };
        }

        /// <summary>Builds a line path segment.</summary>
        /// <param name="from">The starting position of the line segment</param>
        /// <param name="to">The ending position of the line segment</param>
        /// <returns>A BezierPathSegment array of two elements, configured in a straight line</returns>
        /// <remarks>The control points are spaced out equally to maintain a constant speed on t</remarks>
        public static BezierPathSegment[] MakePathLine(Vector2 from, Vector2 to)
        {
            return new BezierPathSegment[] {
                new BezierPathSegment() { P0 = from, P1 = (to - from) / 3.0f + from, P2 = (to - from) * 2.0f / 3.0f + from },
                new BezierPathSegment() { P0 = to }
            };
        }

        internal static BezierSegment MakeArcQuarter(Vector2 center, float startAngleRads, float sweepAngleRads)
        {
            // Approximation adapted from http://spencermortensen.com/articles/bezier-circle/
            float s = Mathf.Sin(sweepAngleRads);
            float c = Mathf.Cos(sweepAngleRads);
            Matrix2D m = Matrix2D.RotateLH(startAngleRads);
            m.m02 = center.x;
            m.m12 = center.y;
            float f = 0.551915024494f;
            return new BezierSegment()
            {
                P0 = m * new Vector2(1, 0),
                P1 = m * new Vector2(1, f),
                P2 = m * new Vector2(c + f * s, s),
                P3 = m * new Vector2(c, s)
            };
        }

        /// <summary>Approximates a circle arc with up to 4 segments.</summary>
        /// <param name="center">The center of the arc</param>
        /// <param name="startAngleRads">The starting angle of the arc, in radians</param>
        /// <param name="sweepAngleRads">The "length" of the arc, in radians</param>
        /// <param name="radius">The radius of the arc</param>
        /// <returns>An array of up to four BezierSegments holding the arc</returns>
        public static BezierPathSegment[] MakeArc(Vector2 center, float startAngleRads, float sweepAngleRads, float radius)
        {
            bool shouldFlip = false;
            if (sweepAngleRads < 0.0f)
            {
                startAngleRads += sweepAngleRads;
                sweepAngleRads = -sweepAngleRads;
                shouldFlip = true;
            }

            sweepAngleRads = Mathf.Min(sweepAngleRads, Mathf.PI * 2);

            BezierSegment subSeg1;
            BezierSegment subSeg2;

            var segments = new List<BezierSegment>();
            int endQuadrant = QuadrantAtAngle(sweepAngleRads);

            for (int quadrant = 0; quadrant <= endQuadrant; ++quadrant)
            {
                var seg = ArcSegmentForQuadrant(quadrant);

                // Check if we need to split the segment
                var p0 = Vector2.zero;
                var p1 = new Vector2(2.0f, 0.0f);
                var intersects = FindBezierLineIntersections(seg, p0, p1);
                if (quadrant != 3 && intersects.Length > 0)
                {
                    VectorUtils.SplitSegment(seg, intersects[0], out subSeg1, out subSeg2);
                    seg = subSeg2;
                }

                p1 = new Vector2(Mathf.Cos(sweepAngleRads), Mathf.Sin(sweepAngleRads)) * 2.0f;
                intersects = FindBezierLineIntersections(seg, p0, p1);
                if (intersects.Length > 0)
                {
                    VectorUtils.SplitSegment(seg, intersects[0], out subSeg1, out subSeg2);
                    seg = subSeg1;
                }

                if (!VectorUtils.IsEmptySegment(seg))
                    segments.Add(seg);
            }

            for (int i = 0; i < segments.Count; ++i)
                segments[i] = TransformSegment(segments[i], center, -startAngleRads, Vector2.one * radius);

            if (shouldFlip)
            {
                // Path is reversed, so we should flip it now
                for (int i = 0; i < segments.Count / 2; ++i)
                {
                    int j = segments.Count - i - 1;
                    var seg0 = VectorUtils.FlipSegment(segments[i]);
                    var seg1 = VectorUtils.FlipSegment(segments[j]);
                    segments[i] = seg1;
                    segments[j] = seg0;
                }
                if ((segments.Count % 2) == 1)
                {
                    int i = segments.Count / 2;
                    segments[i] = VectorUtils.FlipSegment(segments[i]);
                }
            }

            return VectorUtils.BezierSegmentsToPath(segments.ToArray());
        }

        internal static int QuadrantAtAngle(float angle)
        {
            angle = angle % (Mathf.PI * 2);
            if (angle < 0.0f)
                angle = Mathf.PI * 2 + angle;
            if (angle <= Mathf.PI / 2.0f)
                return 0;
            else if (angle <= Mathf.PI)
                return 1;
            else if (angle <= Mathf.PI / 2.0f * 3.0f)
                return 2;
            else
                return 3;
        }

        internal static BezierSegment ArcSegmentForQuadrant(int quadrant)
        {
            switch (quadrant)
            {
                case 0: return VectorUtils.MakeArcQuarter(Vector2.zero, 0.0f, Mathf.PI / 2.0f);
                case 1: return VectorUtils.MakeArcQuarter(Vector2.zero, -Mathf.PI / 2.0f, Mathf.PI / 2.0f);
                case 2: return VectorUtils.MakeArcQuarter(Vector2.zero, -Mathf.PI, Mathf.PI / 2.0f);
                case 3: return VectorUtils.MakeArcQuarter(Vector2.zero, -Mathf.PI / 2.0f * 3.0f, Mathf.PI / 2.0f);
                default: return new BezierSegment();
            }
        }

        /// <summary>Flips a segment direction.</summary>
        /// <param name="segment">The segment to flip</param>
        /// <returns>The flipped segment</returns>
        public static BezierSegment FlipSegment(BezierSegment segment)
        {
            var s = segment;

            var tmp = s.P0;
            s.P0 = s.P3;
            s.P3 = tmp;

            tmp = s.P1;
            s.P1 = s.P2;
            s.P2 = tmp;

            return s;
        }

        /// <summary>Computes the bounds of a segment.</summary>
        /// <param name="segment">The segment to flip</param>
        /// <param name="min">The output min value of the segment</param>
        /// <param name="max">The output max value of the segment</param>
        public static void Bounds(BezierSegment segment, out Vector2 min, out Vector2 max)
        {
            min = Vector2.Min(segment.P0, segment.P3);
            max = Vector2.Max(segment.P0, segment.P3);

            Vector2 a = 3.0f * segment.P3 - 9.0f * segment.P2 + 9.0f * segment.P1 - 3.0f * segment.P0;
            Vector2 b = 6.0f * segment.P2 - 12.0f * segment.P1 + 6.0f * segment.P0;
            Vector2 c = 3.0f * segment.P1 - 3.0f * segment.P0;

            float[] solutions = new float[4];
            SolveQuadratic(a.x, b.x, c.x, out solutions[0], out solutions[1]);
            SolveQuadratic(a.y, b.y, c.y, out solutions[2], out solutions[3]);
            foreach (var s in solutions)
            {
                if (float.IsNaN(s) || (s < 0.0f) || (s > 1.0f))
                    continue;
                Vector2 v = Eval(segment, s);
                min = Vector2.Min(min, v);
                max = Vector2.Max(max, v);
            }
        }

        /// <summary>Evaluates the position on a curve segment.</summary>
        /// <param name="segment">The curve segment on which to evaluate the position</param>
        /// <param name="t">The parametric location on the curve</param>
        /// <returns>The position on the curve at parametric location "t"</returns>
        public static Vector2 Eval(BezierSegment segment, float t)
        {
            float t2 = t * t;
            float t3 = t2 * t;
            return
                (segment.P3 - 3.0f * segment.P2 + 3.0f * segment.P1 - segment.P0) * t3
                + (3.0f * segment.P2 - 6.0f * segment.P1 + 3.0f * segment.P0) * t2
                + (3.0f * segment.P1 - 3.0f * segment.P0) * t
                + segment.P0;
        }

        /// <summary>Evaluates the tangent on a curve segment.</summary>
        /// <param name="segment">The curve segment on which to evaluate the tangent</param>
        /// <param name="t">The parametric location on the curve</param>
        /// <returns>The tangent of the curve at parametric location "t"</returns>
        public static Vector2 EvalTangent(BezierSegment segment, float t)
        {
            var tan = (segment.P3 - 3.0f * segment.P2 + 3.0f * segment.P1 - segment.P0) * 3.0f * t * t
                + (3.0f * segment.P2 - 6.0f * segment.P1 + 3.0f * segment.P0) * 2.0f * t
                + (3.0f * segment.P1 - 3.0f * segment.P0);

            // If the result is a zero vector (happens at coincident p0 and p1 or p2 and p3) try again by manual stepping
            if (tan.sqrMagnitude < Epsilon)
            {
                if (t > 0.5f)
                    tan = Eval(segment, t) - Eval(segment, t - 0.01f);
                else tan = Eval(segment, t + 0.01f) - Eval(segment, t);
            }
            return tan.normalized;
        }

        /// <summary>Evalutes the normal on a curve segment.</summary>
        /// <param name="segment">The curve segment on which to evaluate the normal</param>
        /// <param name="t">The parametric location on the curve</param>
        /// <returns>The normal of the curve at parametric location "t"</returns>
        /// <remarks>
        /// A positive normal at a point on the bezier curve is always on the
        /// right side of the forward direction (tangent) of the curve at that point.
        /// </remarks>
        public static Vector2 EvalNormal(BezierSegment segment, float t)
        {
            return Vector2.Perpendicular(EvalTangent(segment, t));
        }

        /// <summary>Evalutes both the position and tangent on a curve segment.</summary>
        /// <param name="segment">The curve segment on which to evaluate the normal</param>
        /// <param name="t">The parametric location on the curve</param>
        /// <param name="tangent">The output tangent at parametric location "t"</param>
        /// <returns>The position on the curve at parametric location "t"</returns>
        /// <remarks>
        /// This is more efficient than calling "Eval" and "EvalTangent" successively.
        /// </remarks>
        public static Vector2 EvalFull(BezierSegment segment, float t, out Vector2 tangent)
        {
            float t2 = t * t;
            float t3 = t2 * t;
            Vector2 C1 = segment.P3 - 3.0f * segment.P2 + 3.0f * segment.P1 - segment.P0;
            Vector2 C2 = 3.0f * segment.P2 - 6.0f * segment.P1 + 3.0f * segment.P0;
            Vector2 C3 = 3.0f * segment.P1 - 3.0f * segment.P0;
            Vector2 C4 = segment.P0;

            var pos = C1 * t3 + C2 * t2 + C3 * t + C4;
            tangent = ((3.0f * C1 * t2) + (2.0f * C2 * t) + C3);

            // If the result is a zero vector (happens at coincident p0 and p1 or p2 and p3) try again by manual stepping
            if (tangent.sqrMagnitude < Epsilon)
            {
                if (t > 0.5f)
                    tangent = pos - Eval(segment, t - 0.01f);
                else tangent = Eval(segment, t + 0.01f) - pos;
            }

            tangent = tangent.normalized;
            return pos;
        }

        /// <summary>Evalutes the position, tangent and normal on a curve segment.</summary>
        /// <param name="segment">The curve segment on which to evaluate the normal</param>
        /// <param name="t">The parametric location on the curve</param>
        /// <param name="tangent">The output tangent at parametric location "t"</param>
        /// <param name="normal">The output normal at parametric location "t"</param>
        /// <returns>The position on the curve at parametric location "t"</returns>
        /// <remarks>
        /// This is more efficient than calling "Eval", "EvalTangent" and "EvalNormal" successively.
        /// </remarks>
        public static Vector2 EvalFull(BezierSegment segment, float t, out Vector2 tangent, out Vector2 normal)
        {
            Vector2 pos = EvalFull(segment, t, out tangent);
            normal = Vector2.Perpendicular(tangent);
            return pos;
        }

        /// <summary>Computes the individual lengths of a segment chain.</summary>
        /// <param name="segments">The segments on which to compute the lengths</param>
        /// <param name="closed">A boolean indicating if the length of the segment joining the first and last points should be computed</param>
        /// <param name="precision">The precision of the lengths computation</param>
        /// <returns>An array containing the lenghts of the segments</returns>
        public static float[] SegmentsLengths(IList<BezierPathSegment> segments, bool closed, float precision = 0.001f)
        {
            float[] segmentLengths = new float[segments.Count - 1 + (closed ? 1 : 0)];
            int i = 0;
            foreach (var segment in SegmentsInPath(segments, closed))
                segmentLengths[i++] = SegmentLength(segment, precision);
            return segmentLengths;
        }

        /// <summary>Computes the combined length of a segment chain.</summary>
        /// <param name="segments">The curve segments on which to evaluate the length</param>
        /// <param name="closed">A boolean indicating if the length of the segment joining the first and last points should be computed</param>
        /// <param name="precision">The precision of the length computation</param>
        /// <returns>The combined length of the segment chain</returns>
        public static float SegmentsLength(IList<BezierPathSegment> segments, bool closed, float precision = 0.001f)
        {
            if (segments.Count < 2)
                return 0.0f;

            float length = 0.0f;
            foreach (var segment in SegmentsInPath(segments))
                length += SegmentLength(segment, precision);
            if (closed)
                length += (segments[segments.Count - 1].P0 - segments[0].P0).magnitude;
            return length;
        }

        /// <summary>Computes the length of a single curve segment.</summary>
        /// <param name="segment">The curve segment on which to evaluate the length</param>
        /// <param name="precision">The precision of the length computation</param>
        /// <returns>The length of the segment</returns>
        public static float SegmentLength(BezierSegment segment, float precision = 0.001f)
        {
            // This adaptive algorithm doesn't behave well at the limit of float precision,
            // so we revert to a dummy iterative approach in this case
            if (VectorUtils.HasLargeCoordinates(segment))
            {
                int steps = Math.Min(100, (int)(1.0f/precision));
                return SegmentLengthIterative(segment, steps);
            }

            float tmax = 0.0f;
            float length = 0.0f;
            while ((tmax = AdaptiveQuadraticApproxSplitPoint(segment, precision)) < 1.0f)
            {
                BezierSegment b1, b2;
                SplitSegment(segment, tmax, out b1, out b2);
                float midPointLength = MidPointQuadraticApproxLength(b1);
                if (float.IsNaN(midPointLength)) // Could happen because of float precision issues
                    midPointLength = SegmentLengthIterative(b1);
                length += midPointLength;
                segment = b2;
            }
            length += MidPointQuadraticApproxLength(segment);
            return length;
        }

        internal static float SegmentLengthIterative(BezierSegment segment, int steps = 10)
        {
            if (steps <= 2)
                return (segment.P3 - segment.P0).magnitude;

            float length = 0.0f;
            var p = segment.P0;
            for (int i = 1; i <= steps; ++i)
            {
                float t = (float)i/steps;
                var q = VectorUtils.Eval(segment, t);
                length += (q-p).magnitude;
                p = q;
            }
            return length;
        }

        internal static bool HasLargeCoordinates(BezierSegment segment)
        {
            const float kMaxCoord = 10000.0f;
            return
                segment.P0.x > kMaxCoord || segment.P0.y > kMaxCoord ||
                segment.P1.x > kMaxCoord || segment.P1.y > kMaxCoord ||
                segment.P2.x > kMaxCoord || segment.P2.y > kMaxCoord ||
                segment.P3.x > kMaxCoord || segment.P3.y > kMaxCoord;
        }

        static float AdaptiveQuadraticApproxSplitPoint(BezierSegment segment, float precision)
        {
            float quadraticApproxDist = (segment.P3 - 3.0f * segment.P2 + 3.0f * segment.P1 - segment.P0).magnitude * 0.5f;
            return Mathf.Pow((18.0f / Mathf.Sqrt(3.0f)) * precision / quadraticApproxDist, 1.0f / 3.0f);
        }

        static float MidPointQuadraticApproxLength(BezierSegment segment)
        {
            var A = segment.P0;
            var B = (3.0f * segment.P2 - segment.P3 + 3.0f * segment.P1 - segment.P0) / 4.0f;
            var C = segment.P3;

            if (A == C)
                return (A == B) ? 0.0f : (A - B).magnitude;

            if (B == A || B == C)
                return (A - C).magnitude;

            var A0 = B - A;
            var A1 = A - 2.0f * B + C;

            if (A1 != Vector2.zero)
            {
                double c = 4.0f * Vector2.Dot(A1, A1);
                double b = 8.0f * Vector2.Dot(A0, A1);
                double a = 4.0f * Vector2.Dot(A0, A0);
                double q = 4.0f * a * c - b * b;

                double twoCpB = 2.0f * c + b;
                double sumCBA = c + b + a;

                var l0 = (0.25f / c) * (twoCpB * Math.Sqrt(sumCBA) - b * Math.Sqrt(a));
                if (Math.Abs(q) <= VectorUtils.Epsilon)
                    return (float)l0;

                var l1 = (q / (8.0f * Math.Pow(c, 1.5f))) * (Math.Log(2.0f * Math.Sqrt(c * sumCBA) + twoCpB) - Math.Log(2.0f * Math.Sqrt(c * a) + b));
                return (float)(l0 + l1);
            }
            else return 2.0f * A0.magnitude;
        }

        /// <summary>Splits a curve segment at a given parametric location.</summary>
        /// <param name="segment">The curve segment to split</param>
        /// <param name="t">The parametric location at which the segment will be split</param>
        /// <param name="b1">The output of the first segment</param>
        /// <param name="b2">The output of the second segment</param>
        public static void SplitSegment(BezierSegment segment, float t, out BezierSegment b1, out BezierSegment b2)
        {
            var a = Vector2.LerpUnclamped(segment.P0, segment.P1, t);
            var b = Vector2.LerpUnclamped(segment.P1, segment.P2, t);
            var c = Vector2.LerpUnclamped(segment.P2, segment.P3, t);
            var m = Vector2.LerpUnclamped(a, b, t);
            var n = Vector2.LerpUnclamped(b, c, t);
            var p = Eval(segment, t);

            b1 = new BezierSegment() { P0 = segment.P0, P1 = a, P2 = m, P3 = p };
            b2 = new BezierSegment() { P0 = p, P1 = n, P2 = c, P3 = segment.P3 };
        }

        /// <summary>Transforms a curve segment by a translation, rotation and scaling.</summary>
        /// <param name="segment">The curve segment to transform</param>
        /// <param name="translation">The translation to apply on the curve segment</param>
        /// <param name="rotation">The rotation to apply on the curve segment</param>
        /// <param name="scaling">The scaling to apply on the curve segment</param>
        /// <returns>The transformed curve segment</returns>
        public static BezierSegment TransformSegment(BezierSegment segment, Vector2 translation, float rotation, Vector2 scaling)
        {
            var m = Matrix2D.RotateLH(rotation);
            var newSeg = new BezierSegment() {
                P0 = m * Vector2.Scale(segment.P0, scaling) + translation,
                P1 = m * Vector2.Scale(segment.P1, scaling) + translation,
                P2 = m * Vector2.Scale(segment.P2, scaling) + translation,
                P3 = m * Vector2.Scale(segment.P3, scaling) + translation
            };
            return newSeg;
        }

        /// <summary>Transforms a curve segment by a transformation matrix.</summary>
        /// <param name="segment">The curve segment to transform</param>
        /// <param name="matrix">The transformation matrix to apply on the curve segment</param>
        /// <returns>The transformed curve segment</returns>
        public static BezierSegment TransformSegment(BezierSegment segment, Matrix2D matrix)
        {
            var newSeg = new BezierSegment() {
                P0 = matrix * segment.P0,
                P1 = matrix * segment.P1,
                P2 = matrix * segment.P2,
                P3 = matrix * segment.P3
            };
            return newSeg;
        }

        /// <summary>Transforms a path by a transformation matrix.</summary>
        /// <param name="path">The path to transform</param>
        /// <param name="translation">The translation to apply</param>
        /// <param name="rotation">The rotation to apply, in radians</param>
        /// <param name="scaling">The scaling to apply</param>
        /// <returns>The transformed path</returns>
        public static BezierPathSegment[] TransformBezierPath(BezierPathSegment[] path, Vector2 translation, float rotation, Vector2 scaling)
        {
            var m = Matrix2D.RotateLH(rotation);
            var newPath = new BezierPathSegment[path.Length];
            for (int i = 0; i < newPath.Length; ++i)
            {
                var seg = path[i];
                newPath[i] = new BezierPathSegment()
                {
                    P0 = m * Vector2.Scale(seg.P0, scaling) + translation,
                    P1 = m * Vector2.Scale(seg.P1, scaling) + translation,
                    P2 = m * Vector2.Scale(seg.P2, scaling) + translation
                };
            }
            return newPath;
        }

        /// <summary>Transforms a path by a transformation matrix.</summary>
        /// <param name="path">The path to transform</param>
        /// <param name="matrix">The transformation matrix to apply on the curve segment</param>
        /// <returns>The transformed path</returns>
        public static BezierPathSegment[] TransformBezierPath(BezierPathSegment[] path, Matrix2D matrix)
        {
            var newPath = new BezierPathSegment[path.Length];
            for (int i = 0; i < newPath.Length; ++i)
            {
                var seg = path[i];
                newPath[i] = new BezierPathSegment() {
                    P0 = matrix * seg.P0,
                    P1 = matrix * seg.P1,
                    P2 = matrix * seg.P2
                };
            }
            return newPath;
        }

        /// <summary>Lists every nodes under a root node.</summary>
        /// <param name="root">The root node</param>
        /// <returns>The enumerable listing every nodes under "root", including the root itself.</returns>
        public static IEnumerable<SceneNode> SceneNodes(SceneNode root)
        {
            yield return root;
            if (root.Children != null)
            {
                foreach (var c in root.Children)
                {
                    foreach (var n in SceneNodes(c))
                        yield return n;
                }
            }
        }

        /// <summary>Structure holding the SceneNode computed transforms, opacities and enumeration path.</summary>
        /// <remarks>This helper structure is used by the WorldTransformedSceneNodes method.</remarks>
        public struct SceneNodeWorldTransform
        {
            /// <summary>The node we are currently visiting.</summary>
            public SceneNode Node;

            /// <summary>The parent of the node we are currently visiting.</summary>
            public SceneNode Parent;

            /// <summary>The accumulated world transform of this node.</summary>
            public Matrix2D WorldTransform;

            /// <summary>The accumulated world opacity of this node.</summary>
            public float WorldOpacity;
        }

        static IEnumerable<SceneNodeWorldTransform> WorldTransformedSceneNodes(SceneNode child, Dictionary<SceneNode, float> nodeOpacities, SceneNodeWorldTransform parent)
        {
            var childOpacity = 1.0f;
            if (nodeOpacities == null || !nodeOpacities.TryGetValue(child, out childOpacity))
                childOpacity = 1.0f;

            var childWorldTransform = new SceneNodeWorldTransform()
            {
                Node = child,
                WorldTransform = parent.WorldTransform * child.Transform,
                WorldOpacity = parent.WorldOpacity * childOpacity,
                Parent = parent.Node
            };

            yield return childWorldTransform;

            if (child.Children != null)
            {
                foreach (var c in child.Children)
                {
                    foreach (var n in WorldTransformedSceneNodes(c, nodeOpacities, childWorldTransform))
                        yield return n;
                }
            }
        }

        /// <summary>Iterates through every nodes under a root with computed transform and opacities.</summary>
        /// <param name="root">The starting node of the hierarchy</param>
        /// <param name="nodeOpacities">Storage for the resulting node opacities, may be null</param>
        /// <returns>An enumeration of every node with their pre-computed world transforms, opacities and paths.</returns>
        public static IEnumerable<SceneNodeWorldTransform> WorldTransformedSceneNodes(SceneNode root, Dictionary<SceneNode, float> nodeOpacities)
        {
            var rootNodeWorldTransform = new SceneNodeWorldTransform() {
                Node = root,
                WorldTransform = Matrix2D.identity,
                WorldOpacity = 1,
                Parent = null
            };
            return WorldTransformedSceneNodes(root, nodeOpacities, rootNodeWorldTransform);
        }

        /// <summary>Realigns the vertices (in-place) inside their axis-aligned bounding-box.</summary>
        /// <param name="vertices">The vertices to realign</param>
        /// <param name="bounds">The bounds into which the vertices will be realigned</param>
        /// <param name="flip">A boolean indicating whether to flip the coordinates on the Y axis</param>
        public static void RealignVerticesInBounds(IList<Vector2> vertices, Rect bounds, bool flip)
        {
            var p = bounds.position;
            var h = bounds.height;
            for (int i = 0; i < vertices.Count; ++i)
            {
                var v = vertices[i];
                v -= p;
                if (flip)
                    v.y = h - v.y;
                vertices[i] = v;
            }
        }

        /// <summary>Flip the vertices (in-place) inside their axis-aligned bounding-box.</summary>
        /// <param name="vertices">The vertices to realign</param>
        /// <param name="bounds">The bounds into which the vertices will be realigned</param>
        public static void FlipVerticesInBounds(IList<Vector2> vertices, Rect bounds)
        {
            var h = bounds.height;
            for (int i = 0; i < vertices.Count; ++i)
            {
                var v = vertices[i];
                v.y = h - v.y;
                vertices[i] = v;
            }
        }

        internal static void ClampVerticesInBounds(IList<Vector2> vertices, Rect bounds)
        {
            for (int i = 0; i < vertices.Count; ++i)
                vertices[i] = Vector2.Max(bounds.min, Vector2.Min(bounds.max, vertices[i]));
        }

        /// <summary>Iterates through every segment in a list of path segments.</summary>
        /// <param name="segments">The path segments to iterate from</param>
        /// <param name="closed">Whether to return the segment connecting the last point to the beginning of the path</param>
        /// <returns>An enumerable of every segments in the path</returns>
        public static IEnumerable<BezierSegment> SegmentsInPath(IEnumerable<BezierPathSegment> segments, bool closed = false)
        {
            var e = segments.GetEnumerator();
            if (!e.MoveNext())
                yield break;

            var s1 = e.Current;
            if (!e.MoveNext())
                yield break;

            do
            {
                var s2 = e.Current;
                yield return new BezierSegment { P0 = s1.P0, P1 = s1.P1, P2 = s1.P2, P3 = s2.P0 };
                s1 = s2;
            }
            while (e.MoveNext());

            if (closed)
                yield return new BezierSegment { P0 = s1.P0, P1 = s1.P1, P2 = s1.P2, P3 = segments.First().P0 };
        }

        static void SolveQuadratic(float a, float b, float c, out float s1, out float s2)
        {
            float det = b * b - 4.0f * a * c;
            if (det < 0.0f)
            {
                s1 = s2 = float.NaN;
                return;
            }

            float detSqrt = Mathf.Sqrt(det);
            s1 = (-b + detSqrt) / 2.0f * a;
            if (Mathf.Abs(a) > float.Epsilon)
                s2 = (-b - detSqrt) / 2.0f * a;
            else s2 = float.NaN;
        }

        /// <summary>Finds the intersection between two infinite lines</summary>
        /// <param name="line1Pt1">The first point of the first line</param>
        /// <param name="line1Pt2">The second point of the first line</param>
        /// <param name="line2Pt1">The first point of the second line</param>
        /// <param name="line2Pt2">The second point of the second line</param>
        /// <returns>The intersection point, or (float.PositiveInfinity, float.PositiveInfinity) if the lines are parallel</returns>
        public static Vector2 IntersectLines(Vector2 line1Pt1, Vector2 line1Pt2, Vector2 line2Pt1, Vector2 line2Pt2)
        {
            var a1 = line1Pt2.y - line1Pt1.y;
            var b1 = line1Pt1.x - line1Pt2.x;

            var a2 = line2Pt2.y - line2Pt1.y;
            var b2 = line2Pt1.x - line2Pt2.x;

            var det = a1 * b2 - a2 * b1;
            if (Mathf.Abs(det) <= Epsilon)
                return new Vector2(float.PositiveInfinity, float.PositiveInfinity); // Parallel, no intersection

            var c1 = a1 * line1Pt1.x + b1 * line1Pt1.y;
            var c2 = a2 * line2Pt1.x + b2 * line2Pt1.y;
            var detInv = 1.0f / det;
            return new Vector2((b2 * c1 - b1 * c2) * detInv, (a1 * c2 - a2 * c1) * detInv);
        }

        /// <summary>Finds the intersection between two line segments</summary>
        /// <param name="line1Pt1">The first point of the first line</param>
        /// <param name="line1Pt2">The second point of the first line</param>
        /// <param name="line2Pt1">The first point of the second line</param>
        /// <param name="line2Pt2">The second point of the second line</param>
        /// <returns>The intersection point, or (float.PositiveInfinity, float.PositiveInfinity) if the lines are parallel</returns>
        public static Vector2 IntersectLineSegments(Vector2 line1Pt1, Vector2 line1Pt2, Vector2 line2Pt1, Vector2 line2Pt2)
        {
            var a1 = (line1Pt1.x - line2Pt2.x) * (line1Pt2.y - line2Pt2.y) - (line1Pt1.y - line2Pt2.y) * (line1Pt2.x - line2Pt2.x);
            var a2 = (line1Pt1.x - line2Pt1.x) * (line1Pt2.y - line2Pt1.y) - (line1Pt1.y - line2Pt1.y) * (line1Pt2.x - line2Pt1.x);
            if (a1 * a2 <= 0.0f)
            {
                var a3 = (line2Pt1.x - line1Pt1.x) * (line2Pt2.y - line1Pt1.y) - (line2Pt1.y - line1Pt1.y) * (line2Pt2.x - line1Pt1.x);
                var a4 = a3 + a2 - a1;
                if (a3 * a4 <= 0.0f)
                {
                    float t = a3 / (a3 - a4);
                    var p = line1Pt1 + t * (line1Pt2 - line1Pt1);
                    return p;
                }
            }
            return new Vector2(float.PositiveInfinity, float.PositiveInfinity);
        }

        static bool PointOnTheLeftOfLine(Vector2 lineFrom, Vector2 lineTo, Vector2 point)
        {
            return ((lineFrom.x - lineTo.x) * (point.y - lineTo.y) - (lineFrom.y - lineTo.y) * (point.x - lineTo.x)) > 0;
        }

        /// <summary>Find the intersections (up to three) between a line and a curve segment.</summary>
        /// <param name="segment">The curve segment</param>
        /// <param name="p0">The first point</param>
        /// <param name="p1">The second point</param>
        /// <returns>Returns the Bezier's 't' parametric values where the line p0-p1 intersects the segment, up to 3 values</returns>
        public static float[] FindBezierLineIntersections(BezierSegment segment, Vector2 p0, Vector2 p1)
        {
            var A = p1.y - p0.y;
            var B = p0.x - p1.x;
            var C = p0.x * (p0.y - p1.y) + p0.y * (p1.x - p0.x);
            var coeffs = BezierCoefficients(segment);

            var P = new float[4];
            P[0] = A * coeffs[0].x + B * coeffs[0].y;
            P[1] = A * coeffs[1].x + B * coeffs[1].y;
            P[2] = A * coeffs[2].x + B * coeffs[2].y;
            P[3] = A * coeffs[3].x + B * coeffs[3].y + C;

            var roots = CubicRoots(P[0], P[1], P[2], P[3]);
            var validRoots = new List<float>(roots.Length);

            foreach (var t in roots)
            {
                var t2 = t * t;
                var t3 = t2 * t;
                var p = coeffs[0] * t3 + coeffs[1] * t2 + coeffs[2] * t + coeffs[3];

                var s = 0.0f;
                if (Mathf.Abs(p1.x - p0.x) > VectorUtils.Epsilon)
                    s = (p.x - p0.x) / (p1.x - p0.x);
                else
                    s = (p.y - p0.y) / (p1.y - p0.y);

                if (t >= 0.0f && t <= 1.0f && s >= 0.0f && s <= 1.0f)
                    validRoots.Add(t);
            }

            return validRoots.ToArray();
        }

        private static float[] CubicRoots(double a, double b, double c, double d)
        {
            var A = b / a;
            var B = c / a;
            var C = d / a;
            var Q = (3 * B - Math.Pow(A, 2)) / 9;
            var R = (9 * A * B - 27 * C - 2 * Math.Pow(A, 3)) / 54;
            var D = Math.Pow(Q, 3) + Math.Pow(R, 2);
            var Im = 0.0;
            var t = new List<double>(3);
            t.AddRange(new double[] { -1.0, -1.0, -1.0 });

            if (D >= 0)
            {
                var sqrtD = Math.Sqrt(D);
                var S = Math.Sign(R + sqrtD) * Math.Pow(Math.Abs(R + sqrtD), 1.0 / 3.0);
                var T = Math.Sign(R - sqrtD) * Math.Pow(Math.Abs(R - sqrtD), 1.0 / 3.0);

                t[0] = -A / 3 + (S + T);
                t[1] = -A / 3 - (S + T) / 2;
                t[2] = t[1];
                Im = Math.Abs(Math.Sqrt(3.0) * (S - T) / 2);

                if (Math.Abs(Im) > VectorUtils.Epsilon)
                {
                    t[1] = -1;
                    t[2] = -1;
                }
            }
            else
            {
                var th = Math.Acos(R / Math.Sqrt(-Math.Pow(Q, 3)));
                var sqrtMinusQ = Math.Sqrt(-Q);
                t[0] = 2 * sqrtMinusQ * Math.Cos(th / 3) - A / 3;
                t[1] = 2 * sqrtMinusQ * Math.Cos((th + 2 * Math.PI) / 3) - A / 3;
                t[2] = 2 * sqrtMinusQ * Math.Cos((th + 4 * Math.PI) / 3) - A / 3;
            }

            for (int i = 0; i < 3; ++i)
            {
                if (t[i] < 0.0 || t[i] > 1.0)
                    t[i] = -1;
            }

            // Remove -1 values which means no root was found
            t.RemoveAll(x => Math.Abs(x + 1.0) < (double)Epsilon);

            return t.Select(x => (float)x).ToArray();
        }

        private static Vector2[] BezierCoefficients(BezierSegment segment)
        {
            var coeffs = new Vector2[4];
            coeffs[0] = -segment.P0 + 3 * segment.P1 + -3 * segment.P2 + segment.P3;
            coeffs[1] = 3 * segment.P0 - 6 * segment.P1 + 3 * segment.P2;
            coeffs[2] = -3 * segment.P0 + 3 * segment.P1;
            coeffs[3] = segment.P0;
            return coeffs;
        }

        /// <summary>Computes a pretty accurate approximation of the scene bounds.</summary>
        /// <param name="root">The root node of the hierarchy to computes the bounds from</param>
        /// <returns>An approximation of the node hierarchy axis-aligned bounding-box</returns>
        /// <remarks>
        /// This will properly evaluate the bounds of the paths and shapes, but will ignore the paths stroke widths.
        /// </remarks>
        #pragma warning disable 612, 618 // Silence use of deprecated IDrawable
        public static Rect SceneNodeBounds(SceneNode root)
        {
            var min = new Vector2(float.MaxValue, float.MaxValue);
            var max = new Vector2(-float.MaxValue, -float.MaxValue);
            foreach (var tnode in WorldTransformedSceneNodes(root, null))
            {
                var shapeMin = new Vector2(float.MaxValue, float.MaxValue);
                var shapeMax = new Vector2(-float.MaxValue, -float.MaxValue);

                if (tnode.Node.Shapes != null)
                {
                    foreach (var shape in tnode.Node.Shapes)
                    {
                        foreach (var contour in shape.Contours)
                        {
                            var bbox = Bounds(TransformBezierPath(contour.Segments, tnode.WorldTransform));
                            shapeMin = Vector2.Min(shapeMin, bbox.min);
                            shapeMax = Vector2.Max(shapeMax, bbox.max);
                        }
                    }
                }

                if (shapeMin.x != float.MaxValue)
                {
                    min = Vector2.Min(min, shapeMin);
                    max = Vector2.Max(max, shapeMax);
                }
            }
            return (min.x != float.MaxValue) ? new Rect(min, max - min) : Rect.zero;
        }

        /// <summary>Computes a rough approximation of the node hierarchy bounds.</summary>
        /// <param name="root">The root node of the hierarchy to computes the bounds from</param>
        /// <returns>An approximation of the root hierarchy axis-aligned bounding-box</returns>
        /// <remarks>
        /// This will use the control point positions as a rough estimate of the bounds for the paths and shapes.
        /// </remarks>
        public static Rect ApproximateSceneNodeBounds(SceneNode root)
        {
            var vertices = new List<Vector2>(100);

            foreach (var tnode in WorldTransformedSceneNodes(root, null))
            {
                if (tnode.Node.Shapes != null)
                {
                    foreach (var shape in tnode.Node.Shapes)
                    {
                        foreach (var contour in shape.Contours)
                        {
                            foreach (var seg in TransformBezierPath(contour.Segments, tnode.WorldTransform))
                            {
                                vertices.Add(seg.P0);
                                vertices.Add(seg.P1);
                                vertices.Add(seg.P2);
                            }
                        }
                    }
                }
            }

            return Bounds(vertices);
        }
        #pragma warning restore 612, 618

        internal static bool IsEmptySegment(BezierSegment bs)
        {
            return (bs.P0 - bs.P1).sqrMagnitude <= Epsilon && (bs.P0 - bs.P2).sqrMagnitude <= Epsilon && (bs.P0 - bs.P3).sqrMagnitude <= Epsilon;
        }
    } // VectorUtils class

    internal class PathDistanceForwardIterator
    {
        class BezierLoop : IList<BezierPathSegment>
        {
            IList<BezierPathSegment> OpenPath;

            public BezierLoop(IList<BezierPathSegment> openPath)
            {
                this.OpenPath = openPath;
            }

            public BezierPathSegment this[int index]
            {
                get
                {
                    if (index == OpenPath.Count)
                        return OpenPath[0];
                    return OpenPath[index];
                }
                set { throw new NotSupportedException(); }
            }

            public int Count { get { return OpenPath.Count + 1; } }
            public bool IsReadOnly { get { return true; } }
            public void Add(BezierPathSegment item) { throw new NotSupportedException(); }
            public void Clear() {}
            public bool Contains(BezierPathSegment item) { throw new NotImplementedException(); }
            public void CopyTo(BezierPathSegment[] array, int arrayIndex) { throw new NotImplementedException(); }
            public IEnumerator<BezierPathSegment> GetEnumerator() { throw new NotImplementedException(); }
            public int IndexOf(BezierPathSegment item) { throw new NotImplementedException(); }
            public void Insert(int index, BezierPathSegment item) { throw new NotSupportedException(); }
            public bool Remove(BezierPathSegment item) { throw new NotSupportedException(); }
            public void RemoveAt(int index) { throw new NotSupportedException(); }
            IEnumerator IEnumerable.GetEnumerator() { throw new NotImplementedException(); }
        }

        public enum Result { Stepped, NewSegment, Ended };
        public PathDistanceForwardIterator(IList<BezierPathSegment> pathSegments, bool closed, float maxCordDeviationSq, float maxTanAngleDevCosine, float stepSizeT)
        {
            if (pathSegments.Count < 2)
                throw new Exception("Cannot iterate a path with no segments in it");

            Segments = closed && !VectorUtils.PathEndsPerfectlyMatch(pathSegments) ? new BezierLoop(pathSegments) : pathSegments;
            this.closed = closed;
            this.needTangentsDuringEval = maxTanAngleDevCosine < 1.0f;
            this.maxCordDeviationSq = maxCordDeviationSq;
            this.maxTanAngleDevCosine = maxTanAngleDevCosine;
            this.stepSizeT = stepSizeT;
            currentBezSeg = new BezierSegment() { P0 = pathSegments[0].P0, P1 = pathSegments[0].P1, P2 = pathSegments[0].P2, P3 = pathSegments[1].P0 };
            lastPointEval = pathSegments[0].P0;
            currentTTangent = needTangentsDuringEval ? VectorUtils.EvalTangent(currentBezSeg, 0.0f) : Vector2.zero;
        }

        float PointToLineDistanceSq(Vector2 point, Vector2 lineStart, Vector2 lineEnd)
        {
            float lineMagSq = (lineEnd - lineStart).sqrMagnitude;
            if (lineMagSq < VectorUtils.Epsilon)
                return (point - lineStart).sqrMagnitude;
            float num = (lineEnd.y - lineStart.y) * point.x - (lineEnd.x - lineStart.x) * point.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x;
            return (num * num) / lineMagSq;
        }

        public Result AdvanceBy(float units, out float unitsRemaining)
        {
            unitsRemaining = units;
            if (Ended)
                return Result.Ended; // Reached the end

            float t = currentT;
            Vector2 currentTPosition = lastPointEval;
            for (;;)
            {
                float nextT = Mathf.Min(t + stepSizeT, 1.0f);
                Vector2 tangent = Vector2.zero;
                Vector2 point = needTangentsDuringEval ? VectorUtils.EvalFull(currentBezSeg, nextT, out tangent) : VectorUtils.Eval(currentBezSeg, nextT);

                bool generateStepHere = false;
                if (needTangentsDuringEval)
                {
                    float tangentDiffCosAngle = Vector2.Dot(tangent, currentTTangent);
                    generateStepHere = tangentDiffCosAngle < this.maxTanAngleDevCosine;
                }

                if (!generateStepHere && (maxCordDeviationSq != float.MaxValue))
                {
                    Vector2 firstPoint = currentTPosition;
                    float distPtToFirstSq = (point - firstPoint).sqrMagnitude;
                    if (distPtToFirstSq > VectorUtils.Epsilon)
                    {
                        Vector2 secondPoint = VectorUtils.Eval(currentBezSeg, Mathf.Min((nextT - currentT) * 2.0f + currentT, 1.0f));
                        float midPointDistSq = PointToLineDistanceSq(point, firstPoint, secondPoint);
                        generateStepHere = midPointDistSq >= maxCordDeviationSq;
                    }
                }

                float dist = (point - lastPointEval).magnitude;
                if (dist > unitsRemaining)
                {
                    nextT = t + stepSizeT * (unitsRemaining / dist); // A linear approximation, not too bad for small step sizes
                    dist = unitsRemaining;
                    point = VectorUtils.Eval(currentBezSeg, nextT);
                }

                segmentLengthSoFar += dist;
                lengthSoFar += dist;
                unitsRemaining -= dist;
                lastPointEval = point;
                t = nextT;

                if (nextT < 1.0f)
                {
                    if ((unitsRemaining > 0) && !generateStepHere)
                        continue;

                    currentT = nextT;
                    currentTTangent = tangent;

                    return Result.Stepped;
                }

                // Crossing to a new segment
                if (currentSegment + 1 == Segments.Count - 1)
                {
                    currentT = 1.0f;
                    return Result.Ended; // Reached the end
                }

                currentSegment++;
                currentBezSeg = new BezierSegment()
                {
                    P0 = Segments[currentSegment].P0,
                    P1 = Segments[currentSegment].P1,
                    P2 = Segments[currentSegment].P2,
                    P3 = Segments[currentSegment + 1].P0
                };
                segmentLengthSoFar = 0.0f;
                currentT = 0.0f;
                currentTTangent = tangent;
                lastPointEval = currentBezSeg.P0;

                return Result.NewSegment;
            }
        }

        public IList<BezierPathSegment> Segments { get; }
        public bool Closed { get { return closed; } }
        public int CurrentSegment { get { return currentSegment; } }
        public float CurrentT { get { return currentT; } }
        public float LengthSoFar { get { return lengthSoFar; } }
        public float SegmentLengthSoFar { get { return segmentLengthSoFar; } }
        public bool Ended { get { return (currentT == 1.0f) && (currentSegment + 1 == Segments.Count - 1); } }
        public Vector2 EvalCurrent() { return VectorUtils.Eval(currentBezSeg, currentT); }

        // Path data and settings
        readonly bool closed, needTangentsDuringEval;
        readonly float maxCordDeviationSq, maxTanAngleDevCosine, stepSizeT; // Quality control variables

        // State
        int currentSegment;
        float currentT;
        float segmentLengthSoFar; // For user's tracking purposes, not really used in our calculations
        float lengthSoFar; // For user's tracking purposes, not really used in our calculations
        Vector2 lastPointEval, currentTTangent;
        BezierSegment currentBezSeg;
    }

    internal class PathPatternIterator
    {
        public PathPatternIterator(float[] pattern, float patternOffset = 0.0f)
        {
            if (pattern != null)
            {
                foreach (var l in pattern)
                    patternLength += l;
            }

            if (patternLength < VectorUtils.Epsilon)
            {
                segmentLength = float.MaxValue;
                return;
            }

            this.pattern = pattern;
            this.patternOffset = patternOffset;
            if (patternOffset == 0.0f)
                segmentLength = pattern[0];
            else this.solid = IsSolidAt(0.0f, out currentSegment, out segmentLength);
        }

        public void Advance()
        {
            if (pattern == null)
                return;

            currentSegment++;
            if (currentSegment >= pattern.Length)
                currentSegment = 0;

            solid = !solid;
            segmentLength = pattern[currentSegment];
        }

        public bool IsSolidAt(float unitsFromPathStart)
        {
            int patternSegmentIndex;
            float patternSegmentLength;
            return IsSolidAt(unitsFromPathStart, out patternSegmentIndex, out patternSegmentLength);
        }

        public bool IsSolidAt(float unitsFromPathStart, out int patternSegmentIndex, out float patternSegmentLength)
        {
            patternSegmentIndex = 0;
            patternSegmentLength = 0;
            if (pattern == null)
                return true;

            bool isSolid = true;
            unitsFromPathStart += patternOffset;
            int hops = (int)(Mathf.Abs(unitsFromPathStart) / patternLength);
            if (unitsFromPathStart < 0.0f)
            {
                unitsFromPathStart = patternLength - ((-unitsFromPathStart) % patternLength);
                if ((pattern.Length & 1) == 1)
                    isSolid = (hops & 1) == 0;
            }
            else
            {
                unitsFromPathStart = unitsFromPathStart % patternLength;
                if ((pattern.Length & 1) == 1)
                    isSolid = (hops & 1) == 1;
            }

            while (unitsFromPathStart > pattern[patternSegmentIndex])
            {
                unitsFromPathStart -= pattern[patternSegmentIndex++];
                isSolid = !isSolid;
            }
            patternSegmentLength = pattern[patternSegmentIndex] - unitsFromPathStart;
            return isSolid;
        }

        public float SegmentLength { get { return segmentLength; } }
        public bool IsSolid { get { return solid; } }

        float[] pattern;

        int currentSegment;
        bool solid = true;
        float segmentLength;
        float patternLength;
        float patternOffset;
    }
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/ToolBuddy/Dependencies/Vector Graphics/Runtime/VectorUtils.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/DestroyHelper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 374d389d769fe864c8aa8eccfa70b0b2
# ASMDEF: Nobi.UiRoundedCorners.dll
# ---
using UnityEngine;

namespace Nobi.UiRoundedCorners {
	internal static class DestroyHelper {
		internal static void Destroy(Object @object) {
#if UNITY_EDITOR
		if (Application.isPlaying) {
			Object.Destroy(@object);
		} else {
			Object.DestroyImmediate(@object);
		}
#else
			Object.Destroy(@object);
#endif
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/DestroyHelper.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/ImageWithIndependentRoundedCorners.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 109c41f08973846429af681aea0a30c4
# ASMDEF: Nobi.UiRoundedCorners.dll
# ---
using UnityEngine;
using UnityEngine.UI;

namespace Nobi.UiRoundedCorners {
	[RequireComponent(typeof(RectTransform))]
	public class ImageWithIndependentRoundedCorners : MonoBehaviour {
		private static readonly int prop_halfSize = Shader.PropertyToID("_halfSize");
		private static readonly int prop_radiuses = Shader.PropertyToID("_r");
		private static readonly int prop_rect2props = Shader.PropertyToID("_rect2props");

		// Vector2.right rotated clockwise by 45 degrees
		private static readonly Vector2 wNorm = new Vector2(.7071068f, -.7071068f);
		// Vector2.right rotated counter-clockwise by 45 degrees
		private static readonly Vector2 hNorm = new Vector2(.7071068f, .7071068f);

		public Vector4 r;
		private Material material;

		// xy - position,
		// zw - halfSize
		[HideInInspector, SerializeField] private Vector4 rect2props;
		[HideInInspector, SerializeField] private MaskableGraphic image;

		private void OnValidate() {
			Validate();
			Refresh();
		}

		private void OnEnable() {
			Validate();
			Refresh();
		}

		private void OnRectTransformDimensionsChange() {
			if (enabled && material != null) {
				Refresh();
			}
		}

		private void OnDestroy() {
			DestroyHelper.Destroy(material);
			image = null;
			material = null;
		}

		public void Validate() {
			if (material == null) {
				material = new Material(Shader.Find("UI/RoundedCorners/IndependentRoundedCorners"));
			}

			if (image == null) {
				TryGetComponent(out image);
			}

			if (image != null) {
				image.material = material;
			}
		}

		public void Refresh() {
			var rect = ((RectTransform)transform).rect;
			RecalculateProps(rect.size);
			material.SetVector(prop_rect2props, rect2props);
			material.SetVector(prop_halfSize, rect.size * .5f);
			material.SetVector(prop_radiuses, r);
		}

		private void RecalculateProps(Vector2 size) {
			// Vector that goes from left to right sides of rect2
			var aVec = new Vector2(size.x, -size.y + r.x + r.z);

			// Project vector aVec to wNorm to get magnitude of rect2 width vector
			var halfWidth = Vector2.Dot(aVec, wNorm) * .5f;
			rect2props.z = halfWidth;


			// Vector that goes from bottom to top sides of rect2
			var bVec = new Vector2(size.x, size.y - r.w - r.y);

			// Project vector bVec to hNorm to get magnitude of rect2 height vector
			var halfHeight = Vector2.Dot(bVec, hNorm) * .5f;
			rect2props.w = halfHeight;


			// Vector that goes from left to top sides of rect2
			var efVec = new Vector2(size.x - r.x - r.y, 0);

			// Vector that goes from point E to point G, which is top-left of rect2
			var egVec = hNorm * Vector2.Dot(efVec, hNorm);

			// Position of point E relative to center of coord system
			var ePoint = new Vector2(r.x - (size.x / 2), size.y / 2);

			// Origin of rect2 relative to center of coord system
			// ePoint + egVec == vector to top-left corner of rect2
			// wNorm * halfWidth + hNorm * -halfHeight == vector from top-left corner to center
			var origin = ePoint + egVec + wNorm * halfWidth + hNorm * -halfHeight;
			rect2props.x = origin.x;
			rect2props.y = origin.y;
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/ImageWithIndependentRoundedCorners.cs

# FILE: Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/ImageWithRoundedCorners.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: adb30198aa32dd140b5750692dd48104
# ASMDEF: Nobi.UiRoundedCorners.dll
# ---
using UnityEngine;
using UnityEngine.UI;

namespace Nobi.UiRoundedCorners {
	[RequireComponent(typeof(RectTransform))]
	public class ImageWithRoundedCorners : MonoBehaviour {
		private static readonly int Props = Shader.PropertyToID("_WidthHeightRadius");

		public float radius;
		private Material material;

		[HideInInspector, SerializeField] private MaskableGraphic image;

		private void OnValidate() {
			Validate();
			Refresh();
		}

		private void OnDestroy() {
			DestroyHelper.Destroy(material);
			image = null;
			material = null;
		}

		private void OnEnable() {
			Validate();
			Refresh();
		}

		private void OnRectTransformDimensionsChange() {
			if (enabled && material != null) {
				Refresh();
			}
		}

		public void Validate() {
			if (material == null) {
				material = new Material(Shader.Find("UI/RoundedCorners/RoundedCorners"));
			}

			if (image == null) {
				TryGetComponent(out image);
			}

			if (image != null) {
				image.material = material;
			}
		}

		public void Refresh() {
			var rect = ((RectTransform)transform).rect;
			material.SetVector(Props, new Vector4(rect.width, rect.height, radius, 0));
		}
	}
}
# --- end Packages/com_ldx_framework/Runtime/Third Party/UiRoundedCorners/ImageWithRoundedCorners.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn13dShaderDemoController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 412bc66d707f9c54e9f47717d21f77ae
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.SceneManagement;
#endif

using UnityEngine;
using UnityEngine.EventSystems;

namespace AllIn13DShader
{
    public class AllIn13dShaderDemoController : MonoBehaviour
    {
		public DemoExpositor CurrentExpositor
		{
			get
			{
				return demoExpositors[currentExpositorIndex];
			}
		}

		public DemoElement CurrentDemoElement
		{
			get
			{
				return CurrentExpositor.CurrentDemoElement;
			}
		}


		public DemoSceneConfiguration demoSceneConfig;
		public DemoUI demoUI;
		public Transform initPosition;

		[SerializeField] private SkyController skyController;
		[SerializeField] private AllIn1MainLightController mainLightController;

		[SerializeField] private DemoExpositor[] demoExpositors;
		[SerializeField] private GameObject expositorNameGo;

		[SerializeField] private DemoCameraController cameraController;

		[SerializeField] private GameObject environmentsParentGo;


		//private DemoElement currentDemoElement;
		private DemoElement previousDemoElement;

        [Space, Header("Start Index")]
        [SerializeField] private int startExpositorIndex;
        [SerializeField] private int startDemoIndex;

        [Space, Header("Event Systems")]
        [SerializeField] private EventSystem oldInputEventSystem;
        [SerializeField] private EventSystem newInputEventSystem;

        [Space, Header("Input Handlers")]
		[SerializeField] private InputHandler showDemoInfoHandler;
		
		[Space, Header("Scale Tweens")]
		[SerializeField] private AllIn1DemoScaleTween demoLabelScaleTween;
		[SerializeField] private AllIn1DemoScaleTween expositorLabelScaleTween;
		[SerializeField] private AllIn1DemoScaleTween infoPanelScaleTween;
		
		private int currentExpositorIndex;
        private Vector3 targetCameraPosition;

		private EnvironmentController currentEnvironmentController;
		private bool moveCurrentEnvironment;

        private void Start()
        {
			for(int i = 0; i < demoExpositors.Length; i++)
			{
				demoExpositors[i].Init(demoSceneConfig);
			}
			
			int childCount = environmentsParentGo.transform.childCount;
			for(int i = childCount - 1; i >= 0; i--) Destroy(environmentsParentGo.transform.GetChild(i).gameObject);

            EnableCorrectInputSystem();
            demoExpositors[startExpositorIndex].SetDemoExpositor(startDemoIndex);

			demoUI.Refresh(CurrentExpositor);

			previousDemoElement = null;

			skyController.Init();

			cameraController.Init(demoSceneConfig);
			
			DemoChanged();

			CurrentDemoElement.Show();

			expositorNameGo.SetActive(demoExpositors.Length > 1);
        }
        
        private void Update()
        {
			if (showDemoInfoHandler.IsKeyPressed())
			{
				demoUI.ShowOrHideDemoInfo();
			}
		}
        
        public void NavigateToNextExpositor()
        {
	        previousDemoElement = CurrentDemoElement;
	        Vector3 nextDemoPos = previousDemoElement.transform.position + cameraController.cam.transform.up * demoSceneConfig.distanceBetweenDemos;

	        CurrentDemoElement.Hide();
	        ChangeExpositor(1);

	        moveCurrentEnvironment = false;

	        CurrentDemoElement.transform.position = nextDemoPos;
	        CurrentDemoElement.Show();

	        expositorLabelScaleTween.ScaleDownTween();
	        infoPanelScaleTween.ScaleUpTween();
	        DemoChanged();
        }

        public void NavigateToPreviousExpositor()
        {
	        previousDemoElement = CurrentDemoElement;
	        Vector3 nextDemoPos = previousDemoElement.transform.position - cameraController.cam.transform.up * demoSceneConfig.distanceBetweenDemos;

	        CurrentDemoElement.Hide();
	        ChangeExpositor(-1);

	        moveCurrentEnvironment = false;

	        CurrentDemoElement.transform.position = nextDemoPos;
	        CurrentDemoElement.Show();

	        expositorLabelScaleTween.ScaleDownTween();
	        infoPanelScaleTween.ScaleUpTween();
	        DemoChanged();
        }
        
        public void NavigateToPreviousDemo()
        {
	        previousDemoElement = CurrentDemoElement;

	        DemoElement nextDemoElement = demoExpositors[currentExpositorIndex].GetPreviousDemoElement();
	        Vector3 nextDemoPos = GetNextDemoPos(previousDemoElement, nextDemoElement, -cameraController.cam.transform.right);

	        moveCurrentEnvironment = previousDemoElement.demoElementData.environment == nextDemoElement.demoElementData.environment;

	        demoExpositors[currentExpositorIndex].PreviousDemoElement(nextDemoPos);
	        demoLabelScaleTween.ScaleDownTween();
	        infoPanelScaleTween.ScaleUpTween();
	        DemoChanged();
        }

        public void NavigateToNextDemo()
        {
	        previousDemoElement = CurrentDemoElement;

	        DemoElement nextDemoElement = demoExpositors[currentExpositorIndex].GetNextDemoElement();
	        Vector3 nextDemoPos = GetNextDemoPos(previousDemoElement, nextDemoElement, cameraController.cam.transform.right);

	        moveCurrentEnvironment = previousDemoElement.demoElementData.environment == nextDemoElement.demoElementData.environment;

	        demoExpositors[currentExpositorIndex].NextDemoElement(nextDemoPos);
	        demoLabelScaleTween.ScaleDownTween();
	        infoPanelScaleTween.ScaleUpTween();
	        DemoChanged();
        }
        

		private void LateUpdate()
		{
			if (moveCurrentEnvironment && currentEnvironmentController != null)
			{
				currentEnvironmentController.transform.position += cameraController.GetDeltaMovement();
			}
		}

		private void DemoChanged()
		{
			demoUI.Refresh(CurrentExpositor);

			mainLightController.DemoChanged(CurrentDemoElement.demoElementData);
			skyController.DemoChanged(CurrentDemoElement.demoElementData);

			cameraController.DemoChanged(CurrentDemoElement);

			CheckCurrentEnvironment();
		}

		private Vector3 GetNextDemoPos(DemoElement previousDemo, DemoElement nextDemo, Vector3 dir)
		{
			//Vector3 res = previousDemo.transform.position;

			//if(previousDemo.demoElementData.environment != nextDemo.demoElementData.environment)
			//{
			//	res += dir * demoSceneConfig.distanceBetweenDemos;
			//}

			Vector3 res = previousDemo.transform.position + dir * demoSceneConfig.distanceBetweenDemos;
			return res;
		}

		private void CheckCurrentEnvironment()
		{
			DemoEnvironment currentEnvironment = CurrentDemoElement.demoElementData.environment;

			DemoEnvironment previousEnvironment = previousDemoElement?.demoElementData.environment;

			if(currentEnvironment != previousEnvironment)
			{
				if (currentEnvironmentController != null)
				{
					currentEnvironmentController.Hide();
				}

				if(currentEnvironment != null)
				{
					ChangeEnvironment(currentEnvironment);
				}

				moveCurrentEnvironment = false;
			}
			else
			{
				moveCurrentEnvironment = true;
			}
		}

		private void ChangeEnvironment(DemoEnvironment environment)
		{
			GameObject newEnvironmentGo = Instantiate(environment.prefab);
			newEnvironmentGo.transform.parent = environmentsParentGo.transform;
			newEnvironmentGo.transform.position = CurrentDemoElement.transform.position;
			newEnvironmentGo.transform.rotation = Quaternion.identity;
			newEnvironmentGo.transform.localScale = Vector3.zero;


			currentEnvironmentController = newEnvironmentGo.GetComponent<EnvironmentController>();
			currentEnvironmentController.Init(demoSceneConfig);

			currentEnvironmentController.Show(CurrentDemoElement);
		}

#if UNITY_EDITOR
		[ContextMenu("Setup Demo Scene")]
		public void Setup()
		{
			RemoveOldElements();

			for(int i = 0; i < demoSceneConfig.expositors.Length; i++)
			{
				DemoExpositorData expositorData = demoSceneConfig.expositors[i];

				GameObject goExpositor = new GameObject($"Expositor {i + 1}");
				goExpositor.transform.parent = transform;
				goExpositor.transform.localPosition = new Vector3(0f, i * -25f, 0f);
				goExpositor.transform.localRotation = Quaternion.identity;

				DemoExpositor expositor = goExpositor.AddComponent<DemoExpositor>();
				expositor.Setup(expositorData, demoSceneConfig);

				ArrayUtility.Add(ref demoExpositors, expositor);
			}

			currentExpositorIndex = 0;

			EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
		}

		private void RemoveOldElements()
		{
			DemoExpositor[] expositorsToDestroy = transform.GetComponentsInChildren<DemoExpositor>();
			for(int i = 0; i < expositorsToDestroy.Length; i++)
			{
				DestroyImmediate(expositorsToDestroy[i].gameObject);
			}

			ArrayUtility.Clear(ref demoExpositors);
		}
#endif

		private void ChangeExpositor(int changeAmount)
        {
			currentExpositorIndex += changeAmount;
            if(currentExpositorIndex >= demoExpositors.Length) currentExpositorIndex = 0;
            if(currentExpositorIndex < 0) currentExpositorIndex = demoExpositors.Length - 1;
		}
		
		public int GetCurrentExpositorIndex() => currentExpositorIndex;
        
        private void EnableCorrectInputSystem()
        {
            bool newInputSystemEnabled = false;
#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
            newInputSystemEnabled = true;
#endif
            oldInputEventSystem.gameObject.SetActive(!newInputSystemEnabled);
            newInputEventSystem.gameObject.SetActive(newInputSystemEnabled);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn13dShaderDemoController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn13DShaderShaderPropertyCurveAnim.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a847b867911545f42a402db444415b1f
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;
using System.Collections.Generic;

namespace AllIn13DShader
{
    public class AllIn13DShaderShaderPropertyCurveAnim : MonoBehaviour
    {
        [SerializeField] private string numericPropertyName = "_HsvShift";
        
        [SerializeField] private AnimationCurve animationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);
        [SerializeField] private float animationDuration = 1f;
        [SerializeField] private float waitDuration = 0.5f;
        [SerializeField] private float minValue = 0f;
        [SerializeField] private float maxValue = 1f;
        
        [Space, SerializeField, Header("If empty uses instances of currently used Materials")]
        private Material[] materials;
        private Material[] originalMaterials;
        private bool restoreMaterialsOnDisable = false;

        private int propertyShaderID;
        private float timer = 0f;
        private bool isAnimating = true;
        private bool isValid = true;

        private void Start()
        {
            if(materials == null || materials.Length == 0)
            {
                Renderer renderer = GetComponent<Renderer>();
                if(renderer != null) materials = renderer.materials;
            }
            else
            {
                originalMaterials = new Material[materials.Length];
                for(int i = 0; i < materials.Length; i++)
                    if(materials[i] != null) originalMaterials[i] = new Material(materials[i]);
                restoreMaterialsOnDisable = true;
            }

            if(materials == null || materials.Length == 0) DestroyComponentAndLogError(gameObject.name + " has no valid Materials, deleting AllIn1VfxScrollShaderProperty component");
            else
            {
                bool allValid = true;
                for(int i = 0; i < materials.Length; i++)
                {
                    if(materials[i] == null || !materials[i].HasProperty(numericPropertyName))
                    {
                        allValid = false;
                        break;
                    }
                }
                
                if(allValid) 
                    propertyShaderID = Shader.PropertyToID(numericPropertyName);
                else 
                    DestroyComponentAndLogError(gameObject.name + "'s Material(s) don't all have a " + numericPropertyName + " property");
            }
        }

        private void Update()
        {
            if(materials == null || materials.Length == 0)
            {
                if(isValid)
                {
                    Debug.LogError("The object " + gameObject.name + " has no Materials and you are trying to access them. Please take a look");
                    isValid = false;   
                }
                return;
            }
            
            timer += Time.deltaTime;
            
            if(isAnimating)
            {
                if(timer < animationDuration)
                {
                    float normalizedTime = timer / animationDuration;
                    float curveValue = animationCurve.Evaluate(normalizedTime);
                    float remappedValue = Mathf.Lerp(minValue, maxValue, curveValue);
                    
                    for(int i = 0; i < materials.Length; i++)
                        if(materials[i] != null) materials[i].SetFloat(propertyShaderID, remappedValue);
                }
                else
                {
                    isAnimating = false;
                    timer = 0f;
                }
            }
            else
            {
                if(timer >= waitDuration)
                {
                    isAnimating = true;
                    timer = 0f;
                }
            }
        }

        private void DestroyComponentAndLogError(string logError)
        {
            Debug.LogError(logError);
            Destroy(this);
        }

        private void OnDisable()
        {
            if(restoreMaterialsOnDisable && materials != null && originalMaterials != null)
            {
                for(int i = 0; i < materials.Length; i++)
                    if(materials[i] != null && originalMaterials[i] != null)
                        materials[i].CopyPropertiesFromMaterial(originalMaterials[i]);
            }
        }

        private void OnDestroy()
        {
            if(originalMaterials != null)
                for(int i = 0; i < originalMaterials.Length; i++)
                    if(originalMaterials[i] != null) Destroy(originalMaterials[i]);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn13DShaderShaderPropertyCurveAnim.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1AutoRotate.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c87fcb4b45b61be46bdb72dcaa09c6f2
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
    public class AllIn1AutoRotate : MonoBehaviour
    {
        [SerializeField] private float rotationSpeed = 30f;
        [SerializeField] private Vector3 rotationAxis = Vector3.up;

        private void Update()
        {
            transform.Rotate(rotationAxis * (rotationSpeed * Time.deltaTime), Space.Self);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1AutoRotate.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1CanvasFader.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 82afebb9958e7ff4b817915f67b326af
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
    public class AllIn1CanvasFader : MonoBehaviour
    {
        [SerializeField] private KeyCode fadeToggleKey = KeyCode.U;
        [SerializeField] private float tweenSpeed = 1f;
        [SerializeField] private AllIn1DemoScaleTween hideUiButtonTween;
        
        private bool isTweening = false;
        private float currentAlpha = 1f;
        private float targetAlpha = 1f;
        private CanvasGroup canvasGroup;
        private bool hideUiButtonTweenNotNull;

        private void Start()
        {
            canvasGroup = GetComponent<CanvasGroup>();
            canvasGroup.alpha = 1f;
            hideUiButtonTweenNotNull = hideUiButtonTween != null;
        }

        private void Update()
        {
            if(Input.GetKeyDown(fadeToggleKey)) HideUiButtonPressed();
            
            if(!isTweening) return;
            currentAlpha = Mathf.MoveTowards(currentAlpha, targetAlpha, Time.unscaledDeltaTime * tweenSpeed);
            canvasGroup.alpha = currentAlpha;
            if(targetAlpha == currentAlpha) isTweening = false;
        }

        public void HideUiButtonPressed()
        {
            if(currentAlpha < 0.01f) MakeCanvasVisibleTween();
            else MakeCanvasInvisibleTween();
            if(hideUiButtonTweenNotNull) hideUiButtonTween.ScaleUpTween();
        }

        private void MakeCanvasVisibleTween()
        {
            isTweening = true;
            targetAlpha = 1f;
        }

        private void MakeCanvasInvisibleTween()
        {
            isTweening = true;
            targetAlpha = 0f;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1CanvasFader.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1DemoButtonPress.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b0e6b5525608b2546bdd773ea2bdc6b8
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using TMPro;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

namespace AllIn13DShader
{
    [RequireComponent(typeof(InputHandler))]
    public class AllIn1DemoButtonPress : MonoBehaviour
    {
        [SerializeField] private InputHandler inputHandler;
        [SerializeField] private AllIn1DemoScaleTween scaleTween;
        [SerializeField] private Button button;

        [Space, Header("Label Settings")]
        [SerializeField] private bool completelyIgnoreLabel;
        [SerializeField] private bool showKeyLabel = true;
        [SerializeField] private TextMeshProUGUI keyLabel;
        
        private Coroutine resetButtonColorCr;

        private void Start()
        {
            if(!completelyIgnoreLabel)
            {
                if(!showKeyLabel)
                {
                    keyLabel.enabled = false;
                    enabled = false;
                }
                else
                {
                    keyLabel.text = $"(Key {inputHandler.GetTargetKey().ToString()})";
                }
            }
        }

        private void Update()
        {
            if(inputHandler.IsKeyPressed())
            {
                SimulateClick();
            }
        }

        private void SimulateClick()
        {
            if(button != null)
            {
                ColorBlock colors = button.colors;
                button.targetGraphic.color = colors.pressedColor;
                button.onClick.Invoke();
        
                if(resetButtonColorCr != null) StopCoroutine(resetButtonColorCr);
                resetButtonColorCr = StartCoroutine(ResetButtonColor());
            }
        }

        private IEnumerator ResetButtonColor()
        {
            yield return new WaitForSeconds(0.1f);
            button.targetGraphic.color = button.colors.normalColor;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1DemoButtonPress.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1DemoScaleTween.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3d8639573e99fb143ab0f4e90c44e1e7
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
    public class AllIn1DemoScaleTween : MonoBehaviour
    {
        [SerializeField] private float maxTweenScale = 1.25f;
        [SerializeField] private float minTweenScale = 0.5f;
        [SerializeField] private float tweenSpeed = 15f;
        
        private bool isTweening = false;
        private float currentScale = 1f;
        private Vector3 scaleToApply = Vector3.one;

        private void Update()
        {
            if(!isTweening) return;
            currentScale = Mathf.Lerp(currentScale, 1f, Time.unscaledDeltaTime * tweenSpeed);
            UpdateScaleToApply();
            ApplyScale();
            if(Mathf.Abs(currentScale - 1f) < 0.02f) isTweening = false;
        }

        private void UpdateScaleToApply()
        {
            scaleToApply.x = currentScale;
            scaleToApply.y = currentScale;
        }
        
        private void ApplyScale()
        {
            transform.localScale = scaleToApply;
        }

        public void ScaleUpTween()
        {
            isTweening = true;
            currentScale = maxTweenScale;
            UpdateScaleToApply();
        }
        
        public void ScaleDownTween()
        {
            isTweening = true;
            currentScale = minTweenScale;
            UpdateScaleToApply();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1DemoScaleTween.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1FadeLight.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 558b99d21ed97e74b91d33cbf6d03183
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
    [RequireComponent(typeof(Light))]
    public class AllIn1FadeLight : MonoBehaviour
    {
        [SerializeField] private float fadeDuration = 0.1f;
        [SerializeField] private bool destroyWhenFaded = true;
        private Light targetLight;
        private float animationRatioRemaining = 1f;
        private float iniLightIntensity;

        private void Start()
        {
            targetLight = GetComponent<Light>();
            iniLightIntensity = targetLight.intensity;
        }

        private void Update()
        {
            targetLight.intensity = Mathf.Lerp(0f, iniLightIntensity, animationRatioRemaining);
            animationRatioRemaining -= Time.deltaTime / fadeDuration;
            if(destroyWhenFaded && animationRatioRemaining <= 0f) Destroy(gameObject);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1FadeLight.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1MainLightController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 706d6c9c96c757141aab2f13eaf4c90f
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class AllIn1MainLightController : MonoBehaviour
	{
		public Light mainDirectionalLight;
		
		public void DemoChanged(DemoElementData demoElementData)
		{
			mainDirectionalLight.enabled = demoElementData.directionalLightEnabled;
			mainDirectionalLight.intensity = demoElementData.mainLightIntensity;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1MainLightController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1MouseTransformRotator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b9e8e28469a910c418e1840fabdaab78
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;
#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
using UnityEngine.InputSystem;
#endif

namespace AllIn13DShader
{
    public class AllIn1MouseTransformRotator : MonoBehaviour
    {
        [SerializeField] private float rotationSpeedHorizontal = 10f;
        [SerializeField] private float verticalSpeed = 5f;
        [SerializeField] private bool rightClickRequired = true;
        
        [Header("Movement Constraints")]
        [SerializeField] private float maxVerticalAngle = 80f;
        [SerializeField] private float minVerticalAngle = -60f;

        [Space, Header("Zoom")]
        [SerializeField] private bool enableZoom = true;
        [SerializeField] private float zoomSpeed = 5f;
        [SerializeField] private float maxZoomDistance = 20f;
        [SerializeField] private float minZoomDistance = 2f;

        private Transform zoomTargetTransform;
        private float currentVerticalRotation = 0f;
        private float currentHorizontalRotation = 0f;
        private float currentZoomDistance = 10f;
        private float dt;

#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
        private Mouse mouse;
        
        private void Awake()
        {
            mouse = Mouse.current;
            Initialize();
        }
#else
        private void Awake()
        {
            Initialize();
        }
#endif

        private void Initialize()
        {
            Vector3 currentRotation = transform.eulerAngles;
            currentHorizontalRotation = currentRotation.y;
            currentVerticalRotation = currentRotation.x;
            zoomTargetTransform = transform.GetChild(0);
            currentZoomDistance = zoomTargetTransform.localPosition.z;
        }

        private void Update()
        {
            dt = Time.deltaTime;
            HandleRotation();
            if(enableZoom) HandleZoom();
        }
    
        private void HandleRotation()
        {
#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
            if(mouse == null) return;
            float mouseX = mouse.delta.ReadValue().x * dt * rotationSpeedHorizontal;
            float mouseY = mouse.delta.ReadValue().y * dt * verticalSpeed;
            bool isRightMousePressed = mouse.rightButton.isPressed;
#else
            float mouseX = Input.GetAxis("Mouse X") * dt * rotationSpeedHorizontal;
            float mouseY = Input.GetAxis("Mouse Y") * dt * verticalSpeed;
            bool isRightMousePressed = Input.GetMouseButton(1);
#endif
            if((!rightClickRequired && !isRightMousePressed) || (rightClickRequired && isRightMousePressed))
            {
                // Update rotations
                currentHorizontalRotation += mouseX;
                currentVerticalRotation += mouseY;
                
                // Clamp vertical rotation
                currentVerticalRotation = Mathf.Clamp(currentVerticalRotation, minVerticalAngle, maxVerticalAngle);
                
                // Apply rotations
                transform.rotation = Quaternion.Euler(currentVerticalRotation, currentHorizontalRotation, 0f);
            }
        }

        private void HandleZoom()
        {
#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
            if(mouse == null) return;
            float scrollDelta = mouse.scroll.ReadValue().y * dt * zoomSpeed;
#else
            float scrollDelta = Input.GetAxis("Mouse ScrollWheel") * dt * zoomSpeed * 100f;
#endif
            // Update zoom distance
            currentZoomDistance = Mathf.Clamp(currentZoomDistance + scrollDelta, minZoomDistance, maxZoomDistance);
            
            // Apply new position
            Vector3 localPos = zoomTargetTransform.localPosition;
            localPos.z = currentZoomDistance;
            zoomTargetTransform.localPosition = localPos;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1MouseTransformRotator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1TimeControl.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 55cb4f27152d94a4890b9107d0da14f2
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;
using UnityEngine.UI;

namespace AllIn13DShader
{
    public class AllIn1TimeControl : MonoBehaviour
    {
        [SerializeField] private KeyCode increaseTimeScale = KeyCode.UpArrow;
        [SerializeField] private KeyCode increaseTimeScaleAlt = KeyCode.W;
        [SerializeField] private KeyCode decreaseTimeScale = KeyCode.DownArrow;
        [SerializeField] private KeyCode decreaseTimeScaleAlt = KeyCode.S;
        [SerializeField] private KeyCode pauseKey = KeyCode.P;
        [SerializeField, Range(0f, 1f)] private float timeScaleInterval = 0.05f;
        [SerializeField] private Slider timeScaleSlider;
        [SerializeField] private Image pausedButtonImage;
        [SerializeField] private Color pausedButtonColor;
        private bool timeScaleSliderNotNull;
        private float lastChangeTime;
        private AllIn1DemoScaleTween pausedButtonTween;
        private Text pausedButtonText;

        private void Start()
        {
            timeScaleSliderNotNull = timeScaleSlider != null;
            pausedButtonTween = pausedButtonImage.GetComponent<AllIn1DemoScaleTween>();
            pausedButtonText = pausedButtonImage.GetComponentInChildren<Text>();
            UpdateTimeScaleUI();
            if(timeScaleSliderNotNull) timeScaleSlider.onValueChanged.AddListener(delegate { ChangeTimeScale(timeScaleSlider.value - Time.timeScale); });
        }

        private void Update()
        {
            if(Input.GetKeyDown(increaseTimeScale) || Input.GetKeyDown(increaseTimeScaleAlt)) ChangeTimeScale(timeScaleInterval);
            if(Input.GetKeyDown(decreaseTimeScale) || Input.GetKeyDown(decreaseTimeScaleAlt)) ChangeTimeScale(-timeScaleInterval);
            if(Input.GetKeyDown(pauseKey))
            {
                if(Time.timeScale < 0.01f) ChangeTimeScale(1f - Time.timeScale);
                else ChangeTimeScale(-Time.timeScale);
                pausedButtonTween.ScaleUpTween();
            }

            float timeScaleChangeInterval = 0.1f;
            if(!(Time.unscaledTime - lastChangeTime > timeScaleChangeInterval)) return;
            if(Input.GetKey(increaseTimeScale) || Input.GetKey(increaseTimeScaleAlt)) ChangeTimeScale(timeScaleInterval);
            if(Input.GetKey(decreaseTimeScale) || Input.GetKey(decreaseTimeScaleAlt)) ChangeTimeScale(-timeScaleInterval);
        }

        private void ChangeTimeScale(float changeAmount)
        {
            Time.timeScale = Mathf.Clamp(Time.timeScale + changeAmount, 0.0f, 1f);
            lastChangeTime = Time.unscaledTime;
            UpdateTimeScaleUI();
        }

        private void UpdateTimeScaleUI()
        {
            if(timeScaleSliderNotNull) timeScaleSlider.value = Time.timeScale;
            if(Time.timeScale < 0.01f)
            {
                pausedButtonText.text = "Unpause";
                pausedButtonImage.color = pausedButtonColor;
            }
            else
            {
                pausedButtonText.text = "Pause";
                pausedButtonImage.color = Color.white;
            }
        }

        public void PauseUiButton()
        {
            if(Time.timeScale < 0.01f) Time.timeScale = 1f;
            else Time.timeScale = 0f;

            UpdateTimeScaleUI();
        }

        public void CurrentEffectChanged()
        {
            if(Time.timeScale < 0.01f)
            {
                Time.timeScale = 0.1f;
                UpdateTimeScaleUI();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/AllIn1TimeControl.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Billboard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7ed080149842b6b44bb6eec1735711ba
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEditor;
using UnityEngine;

namespace AllIn13DShader
{
    /// <summary>
    /// Handles billboard behavior to face camera either on Y-axis only or all axes
    /// Can follow either editor scene view camera or main camera with cached reference
    /// </summary>
    [ExecuteAlways]
    public class Billboard : MonoBehaviour
    {
        [SerializeField] 
        private bool yAxisOnly = true;
    
        [SerializeField, Tooltip("If true, will update rotation every frame. If false, only on camera movement")]
        private bool continuousUpdate = true;

        [SerializeField, Tooltip("If true, follows editor scene view camera. If false, follows main camera")]
        private bool useEditorCamera = false;

        private Transform targetCameraTransform;
        private Vector3 previousCameraPosition;
        private Quaternion initialRotation;
        private bool wasUsingEditorCamera;
    
        // Static cached reference to main camera
        private static Camera mainCameraCache;
        private static bool mainCameraSearched = false;

        private void OnEnable()
        {
            // Reset camera search if re-enabled
            if (!useEditorCamera && !mainCameraSearched)
            {
                UpdateCameraReference();
            }
        }

        private void Update()
        {
            bool shouldUpdateCamera = targetCameraTransform == null || wasUsingEditorCamera != useEditorCamera;
        
            if(shouldUpdateCamera)
            {
                UpdateCameraReference();
            }

            if(targetCameraTransform == null) return;

            if(!continuousUpdate && previousCameraPosition == targetCameraTransform.position)
            {
                return;
            }

            if(yAxisOnly)
            {
                // Only rotate around Y axis
                Vector3 directionToCamera = targetCameraTransform.position - transform.position;
                directionToCamera.y = 0;

                if(directionToCamera != Vector3.zero)
                {
                    transform.rotation = Quaternion.LookRotation(directionToCamera) * initialRotation;
                }
            }
            else
            {
                // Full billboard - face camera completely
                transform.LookAt(transform.position + targetCameraTransform.rotation * Vector3.forward,
                    targetCameraTransform.rotation * Vector3.up);
            }

            previousCameraPosition = targetCameraTransform.position;
        }

        private void UpdateCameraReference()
        {
#if UNITY_EDITOR
            if(useEditorCamera)
            {
                SceneView sceneView = SceneView.lastActiveSceneView;
                if(sceneView == null || sceneView.camera == null) return;
                
                targetCameraTransform = sceneView.camera.transform;
                wasUsingEditorCamera = true;
            }
            else
#endif
            {
                // Use cached camera reference if available
                if (mainCameraCache == null || !mainCameraCache.isActiveAndEnabled)
                {
                    mainCameraCache = Camera.main;
                    mainCameraSearched = true;
                }
            
                if(mainCameraCache == null) return;
                targetCameraTransform = mainCameraCache.transform;
                wasUsingEditorCamera = false;
            }

            initialRotation = Quaternion.identity;
        }

        // Handle scene changes or camera destruction
        private void OnValidate()
        {
            // Force update of camera reference when properties change in inspector
            targetCameraTransform = null;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Billboard.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoCameraController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 559c47b838b33484d9e24d155c754de2
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

#if ALLIN13DSHADER_BIRP && UNITY_POST_PROCESSING_STACK_V2
using UnityEngine.Rendering.PostProcessing;
#endif

namespace AllIn13DShader
{
	public class DemoCameraController : MonoBehaviour
	{
		public enum TransitionState
		{
			NONE = 0,
			MOVING = 1,
		}

		private Vector3 srcPosition;
		private Quaternion srcRotation;

		private Vector3 dstPosition;
		private Quaternion dstRotation;

		private AnimationCurve cameraCurve;

		private TransitionState transitionState;
		private float timer;
		private float transitionDuration;

		private Vector3 deltaMovement;

		public Transform target;
		public float lerpSpeed;

		[Header("Camera")]
		public Camera cam;

#if ALLIN13DSHADER_BIRP && UNITY_POST_PROCESSING_STACK_V2
		[Header("Postprocess")]
		public PostProcessLayer postProcessLayer;
		public PostProcessVolume postProcessVolume;
#endif

		public void Init(DemoSceneConfiguration demoSceneConfig)
		{
			this.cameraCurve = demoSceneConfig.cameraCurve;
			this.transitionState = TransitionState.NONE;
			this.transitionDuration = demoSceneConfig.cameraTransitionDuration;
		}

		public void DemoChanged(DemoElement demoElement)
		{
			transitionState = TransitionState.MOVING; 

			srcPosition = target.position;
			srcRotation = target.rotation;

			dstPosition = demoElement.transform.position;
			dstRotation = Quaternion.identity;

#if ALLIN13DSHADER_BIRP && UNITY_POST_PROCESSING_STACK_V2
			if (postProcessLayer != null)
			{
				postProcessLayer.enabled = demoElement.demoElementData.postProcessEnabled;
			}
			
			if(postProcessVolume != null)
			{
				postProcessVolume.enabled = demoElement.demoElementData.postProcessEnabled;
			}
#endif
		}

		public void GoTo(Transform tr)
		{
			transitionState = TransitionState.MOVING;

			dstPosition = tr.position;
			dstRotation = tr.rotation;

			srcPosition = target.position;
			srcRotation = target.rotation;
		}

		public Vector3 GetDeltaMovement()
		{
			return deltaMovement;
		}

		private void Update()
		{
			if(transitionState == TransitionState.MOVING)
			{
				Update_Moving();
			}
			else
			{
				deltaMovement = Vector3.zero;
			}
		}

		private void Update_Moving()
		{
			timer += Time.deltaTime;
			float t = timer / transitionDuration;
			float curveT = cameraCurve.Evaluate(t);

			Vector3 newPosition = Vector3.LerpUnclamped(srcPosition, dstPosition, curveT);
			deltaMovement = newPosition - target.transform.position;

			target.transform.position = newPosition;
			target.transform.rotation = Quaternion.SlerpUnclamped(srcRotation, dstRotation, curveT);

			if(t >= 1f)
			{
				transitionState = TransitionState.NONE;
				timer = 0f;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoCameraController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElement.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1698d847b7bb109498dbc7867667a6f6
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using System;
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoElement : MonoBehaviour
	{
		public MeshRenderer[] renderers;

		public DemoElementData demoElementData;

		public TransformScaler transformScaler;

		public PropertyTweenCollection tweenCollection;

		public int demoIndex { get; private set; }


		public virtual void Init(DemoSceneConfiguration demoSceneConfig, int demoIndex)
		{
			transform.localScale = Vector3.zero;
			gameObject.SetActive(false);

			transformScaler.Init(demoSceneConfig, ScaleFinishedCallback);

			tweenCollection.Init();

			this.demoIndex = demoIndex;
		}

		public virtual void Update()
		{
			tweenCollection.Update(Time.deltaTime);
		}

		public void Show()
		{
			gameObject.SetActive(true);
			transformScaler.ScaleUp();
		}

		public void Hide()
		{
			transformScaler.ScaleDown();
		}

		public void ScaleFinishedCallback(TransformScaler.ScalingType scalingOperation)
		{
			if(scalingOperation == TransformScaler.ScalingType.SCALING_DOWN)
			{
				gameObject.SetActive(false);
			}
		}

		public bool IsScaling()
		{
			bool res = transformScaler.IsScaling();
			return res;
		}
		
		// #if UNITY_EDITOR
		// private void OnValidate()
		// {
		// 	if(demoElementData == null)
		// 	{
		// 		string goName = gameObject.name;
		// 		if(goName.StartsWith("P_Demo_")) goName = goName.Substring(7);
		// 		
		// 		string[] guids = UnityEditor.AssetDatabase.FindAssets("t:DemoElementData");
		// 		foreach(string guid in guids)
		// 		{
		// 			string path = UnityEditor.AssetDatabase.GUIDToAssetPath(guid);
		// 			DemoElementData data = UnityEditor.AssetDatabase.LoadAssetAtPath<DemoElementData>(path);
		// 			if(data != null && data.prefab != null && data.prefab.name.Contains(goName))
		// 			{
		// 				demoElementData = data;
		// 				UnityEditor.EditorUtility.SetDirty(this);
		// 				break;
		// 			}
		// 		}
		// 	}
		// }
		// #endif
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElement.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementColorRamp.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0453bc847f79848469a4203b1ce8b7cf
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoElementColorRamp : DemoElement
	{
		private static int COLOR_RAMP_MATPROP_ID = Shader.PropertyToID("_ColorRampTex"); 

		private float timer;
		private int currentTextureIndex;

		public Texture[] colorRamps;
		public float timeBetweenTextures;

		public Material mat;

		public override void Update()
		{
			base.Update();

			timer += Time.deltaTime;

			if(timer >= timeBetweenTextures)
			{
				timer = 0f;
				currentTextureIndex = currentTextureIndex < colorRamps.Length - 1 ? currentTextureIndex + 1 : 0;

				mat.SetTexture(COLOR_RAMP_MATPROP_ID, colorRamps[currentTextureIndex]);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementColorRamp.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 94ddca8ef013926408780e6e292bad16
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using System;
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoElementData : ScriptableObject
	{
		public string demoName;
		public GameObject prefab;
		public DemoEnvironment environment;

		[Header("Info")]
		[TextArea] public string info;

		[Header("Min Directional Light")]
		public bool directionalLightEnabled = true;
		public float mainLightIntensity = 1.0f;

		[Header("Skybox")]
		public bool skyboxEnabled = true;

		[Header("Postprocess")]
		public bool postProcessEnabled = false;

		// private void OnValidate()
		// {
		// 	if(string.IsNullOrEmpty(demoName)) demoName = GetFormattedName();
		// }
		//
		// private string GetFormattedName()
		// {
		// 	if(prefab == null) return string.Empty;
  //   
		// 	string prefabName = prefab.name;
		// 	if(prefabName.StartsWith("P_Demo_")) prefabName = prefabName.Substring(7);
  //   
		// 	if(prefabName.Length > 1)
		// 	{
		// 		int i = 1;
		// 		while(i < prefabName.Length)
		// 		{
		// 			if(char.IsUpper(prefabName[i]) && !char.IsWhiteSpace(prefabName[i-1]))
		// 			{
		// 				prefabName = prefabName.Insert(i, " ");
		// 				i++;
		// 			}
		// 			i++;
		// 		}
		// 	}
  //   
		// 	return prefabName;
		// }
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementData.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementIntersectionGlow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3bdcc7aefbba4b1428221d91f5435083
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoElementIntersectionGlow : DemoElement
	{
		private float timer;

		public float speed;
		public float minY;
		public float maxY;

		public Transform target;

		private void OnEnable()
		{
			timer = 0f;
		}

		private void OnDisable()
		{
			timer = 0f;
		}

		public override void Update()
		{
			base.Update();

			timer += Time.deltaTime;

			float sin01 = (Mathf.Sin(timer * speed) + 1f) * 0.5f;
			Vector3 localPos = target.localPosition;
			localPos.y = Mathf.Lerp(minY, maxY, sin01);

			target.localPosition = localPos;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoElementIntersectionGlow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoEnvironment.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c4205413819227748acd4e41a3ce684e
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoEnvironment : ScriptableObject
	{
		public GameObject prefab;
		public int sceneIndex;
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoEnvironment.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoExpositor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 684c2ea481da2714ea0aed60ea54c2fe
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
#if UNITY_EDITOR
using UnityEditor;
#endif

using UnityEngine;

namespace AllIn13DShader
{
    public class DemoExpositor : MonoBehaviour
    {
		public DemoExpositorData expositorData;
        [SerializeField] private DemoElement[] demoElements;
        
        private int currentDemoIndex;

		public DemoElement CurrentDemoElement => demoElements[currentDemoIndex];
		public int CurrentDemoElementIndex => currentDemoIndex;

		public void Init(DemoSceneConfiguration demoSceneConfig)
		{
			for (int i = 0; i < demoElements.Length; i++)
			{
				demoElements[i].Init(demoSceneConfig, i);
			}
		}

        public void SetDemoExpositor(int newIndex)
        {
            currentDemoIndex = newIndex;
        }

		public DemoElement GetNextDemoElement()
		{
			int nextIndex = currentDemoIndex + 1;
			if (nextIndex >= demoElements.Length)
			{
				nextIndex = 0;
			}

			DemoElement res = demoElements[nextIndex];
			return res;
		}

		public DemoElement GetPreviousDemoElement()
		{
			int nextIndex = currentDemoIndex - 1;
			if (nextIndex < 0)
			{
				nextIndex = demoElements.Length - 1;
			}

			DemoElement res = demoElements[nextIndex];
			return res;
		}

		public void NextDemoElement(Vector3 demoPos)
        {
			CurrentDemoElement.Hide();

			currentDemoIndex++;
			if (currentDemoIndex >= demoElements.Length)
			{
				currentDemoIndex = 0;
			}

			CurrentDemoElement.transform.position = demoPos;
			CurrentDemoElement.Show();
        }
        
        public void PreviousDemoElement(Vector3 demoPos)
        {
			CurrentDemoElement.Hide();

			currentDemoIndex--;
			if (currentDemoIndex < 0)
			{
				currentDemoIndex = demoElements.Length - 1;
			}

			CurrentDemoElement.transform.position = demoPos;
			CurrentDemoElement.Show();
		}
        
		public void SetElementDemoIndex(int demoIndex)
		{
			currentDemoIndex = Mathf.Min(demoIndex, demoElements.Length - 1);
		}

		public DemoElement FindNearestElement(Vector3 referencePosition, out int demoIndex)
		{
			DemoElement res = null;

			float minSqrDistance = float.MaxValue;
			demoIndex = 0;

			Vector3 referencePositionWithoutY = referencePosition;
			referencePositionWithoutY.y = 0f;


			for (int i = 0; i < demoElements.Length; i++)
			{
				Vector3 demoElementWithoutY = demoElements[i].transform.position;
				demoElementWithoutY.y = 0f;

				float sqrDistance = (referencePositionWithoutY - demoElementWithoutY).sqrMagnitude;
				if (sqrDistance <= minSqrDistance)
				{
					minSqrDistance = sqrDistance;
					res = demoElements[i];
					demoIndex = i;
				}
			}

			if(CurrentDemoElement.demoElementData.environment == res.demoElementData.environment &&
				res.demoElementData.environment != null)
			{
				res = CurrentDemoElement;
				demoIndex = CurrentDemoElement.demoIndex;
			}

			return res;
		}


#if UNITY_EDITOR
		public void Setup(DemoExpositorData expositorData, DemoSceneConfiguration demoSceneConfig)
		{
			this.expositorData = expositorData;

			if (demoElements != null)
			{
				ArrayUtility.Clear(ref demoElements);
			}
			else
			{
				demoElements = new DemoElement[0];
			}

			DemoEnvironment lastEnvironment = null;
			Vector3 lastLocalPosition = new Vector3(-demoSceneConfig.distanceBetweenDemos, 0f, 0f);
			for (int i = 0; i < expositorData.demos.Length; i++)
			{
				DemoElementData demoElementData = expositorData.demos[i];
				GameObject demoElementGo = (GameObject)PrefabUtility.InstantiatePrefab(demoElementData.prefab, transform);

				lastLocalPosition.x += demoSceneConfig.distanceBetweenDemos;
				lastEnvironment = demoElementData.environment;

				demoElementGo.transform.localPosition = lastLocalPosition;
				demoElementGo.transform.localRotation = Quaternion.identity;
				Debug.LogError($"{gameObject.name} - {demoElementGo.name} at {demoElementGo.transform.localPosition} -t:{Time.time}", demoElementGo);

				DemoElement demoElement = demoElementGo.GetComponent<DemoElement>();

				ArrayUtility.Add(ref demoElements, demoElement);
			}

			currentDemoIndex = 0;
		}
#endif
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoExpositor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoExpositorData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e717b5696b9da764094cc1b224cb9b72
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoExpositorData : ScriptableObject
	{
		public string expositorName;
		public DemoElementData[] demos;
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoExpositorData.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoInfoUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 43bb1bdec3d56ff44ab3d28f90bfbf76
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using System;
using TMPro;
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoInfoUI : MonoBehaviour
	{
		[SerializeField] private RectTransform offScreenT, initialT;
		[SerializeField] private float smoothingAmount;
		[SerializeField] private TMP_Text txtDemoInfo;
		
		private RectTransform myT, currentTargetT;
		private bool isClosed;

		private void Start()
		{
			myT = transform as RectTransform;
			CopyRectTransform(myT, initialT);
			currentTargetT = offScreenT;
			myT.position = currentTargetT.position;
			isClosed = true;
		}

		private void Update()
		{
			if(currentTargetT == null) return;
			myT.position = Vector3.Lerp(myT.position, currentTargetT.position, smoothingAmount * Time.deltaTime);
		}

		public void DemoChanged(DemoElementData demoElementdata)
		{
			txtDemoInfo.text = demoElementdata.info;
		}
		
		public void ShowHideToggle()
		{
			isClosed = !isClosed;
			currentTargetT = isClosed ? offScreenT : initialT;
		}

		private void CopyRectTransform(RectTransform source, RectTransform target)
		{
			if(source == null || target == null)
			{
				Debug.LogError("Source or target RectTransform is null");
				return;
			}
    
			// Copy anchoring
			target.anchorMin = source.anchorMin;
			target.anchorMax = source.anchorMax;
			target.pivot = source.pivot;
    
			// Copy positioning
			target.anchoredPosition = source.anchoredPosition;
			target.anchoredPosition3D = source.anchoredPosition3D;
			target.sizeDelta = source.sizeDelta;
    
			// Copy rotation and scale
			target.rotation = source.rotation;
			target.localRotation = source.localRotation;
			target.localScale = source.localScale;
    
			// Copy offset values
			target.offsetMin = source.offsetMin;
			target.offsetMax = source.offsetMax;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoInfoUI.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoLightUrpIntensity.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: afc39b4cbc1e00449b2ff0c95caeba62
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
    public class DemoLightUrpIntensity : MonoBehaviour
    {
        [SerializeField] private Light thisLight;
        [SerializeField] private float urpIntensityMultiplier = 5f;

#if ALLIN13DSHADER_URP
        private void Start()
        {
            thisLight.intensity *= urpIntensityMultiplier;
        }
#endif

        private void Reset()
        {
            if(thisLight == null) 
            {
                thisLight = GetComponent<Light>();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoLightUrpIntensity.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoSceneConfiguration.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ff5f3343548edfb4687065aa80ba2a44
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoSceneConfiguration : ScriptableObject
	{
		public float scaleDuration = 0.4f;
		public float distanceBetweenDemos = 25f;
		public float cameraTransitionDuration = 1f;
		public float alphaDuration = 0.25f;

		[Header("Curves")]
		public AnimationCurve scalingCurve;
		public AnimationCurve cameraCurve;
		public AnimationCurve alphaCurve;

		[Header("Expositors")]
		public DemoExpositorData[] expositors;
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoSceneConfiguration.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoUI.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 192a33b5e551b1a4bad83252c99ec644
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using TMPro;
using UnityEngine;

namespace AllIn13DShader
{
	public class DemoUI : MonoBehaviour
	{
		public AllIn13dShaderDemoController demoController;
		public TMP_Text txtExpositorName, txtDemoName, txtDemoViewing;
		public AllIn1DemoScaleTween viewingTween;

		public DemoInfoUI demoInfoUI;

		public void Refresh(DemoExpositor currentExpositor)
		{
			Refresh(currentExpositor.expositorData, currentExpositor.CurrentDemoElement.demoElementData);
		}

		private void Refresh(DemoExpositorData expositorData, DemoElementData demoElementData)
		{
			int currentExpositorIndex = demoController.GetCurrentExpositorIndex() + 1;
			int currentDemoElementIndex = demoController.CurrentExpositor.CurrentDemoElementIndex + 1;
			txtExpositorName.text = $"{currentExpositorIndex}. {expositorData.expositorName}";
			txtDemoName.text = $"{currentDemoElementIndex}. {demoElementData.demoName}";

			demoInfoUI.DemoChanged(demoElementData);
			
			txtDemoViewing.text = $"Viewing: {currentExpositorIndex} - {currentDemoElementIndex}";
			viewingTween.ScaleUpTween();
		}

		public void ShowOrHideDemoInfo()
		{
			demoInfoUI.ShowHideToggle();
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoUI.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoUtils.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 96ac2215b217c5c42994dd053daf7e27
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public static class DemoUtils
	{
		public static float EaseOutBack(float progress)
		{
			const float overshootBase = 2.7f;
			float overshootModifier = overshootBase + 1f;

			float res = 1f + overshootModifier * Mathf.Pow(progress - 1f, 3f) + overshootBase * Mathf.Pow(progress - 1f, 2f);
			return res;
		}

		public static void SetMaterialTransparent(Material mat)
		{
			mat.renderQueue = 3000;
			mat.SetFloat("_BlendSrc", (float)UnityEngine.Rendering.BlendMode.SrcAlpha);
			mat.SetFloat("_BlendDst", (float)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
		}

		public static void SetMaterialOpaque(Material mat)
		{
			mat.renderQueue = 2000;
			mat.SetFloat("_BlendSrc", (float)UnityEngine.Rendering.BlendMode.One);
			mat.SetFloat("_BlendDst", (float)UnityEngine.Rendering.BlendMode.Zero);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/DemoUtils.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/EnvironmentController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1cc14354005b97848bd03e676e4e2f75
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
#if UNITY_EDITOR
using UnityEditor.SceneManagement;
#endif

using UnityEngine;

namespace AllIn13DShader
{
	public class EnvironmentController : MonoBehaviour
	{
		public DemoElement linkedDemoElement;
		public TransformScaler transformScaler;
		public AlphaTween alphaTween;

		public MeshRenderer[] renderers;

		public void Init(DemoSceneConfiguration demoSceneConfig)
		{
			transformScaler.Init(demoSceneConfig, ScaleFinishedCallback);
			alphaTween.Init(demoSceneConfig, renderers);
		}

		private void ScaleFinishedCallback(TransformScaler.ScalingType scalingOperation)
		{
			if(scalingOperation == TransformScaler.ScalingType.SCALING_DOWN)
			{
				Destroy(gameObject);
			}
		}
		public void Show(DemoElement linkedDemoElement)
		{
			gameObject.SetActive(true);
			this.linkedDemoElement = linkedDemoElement;

			transformScaler.ScaleUp();
			alphaTween.FadeIn();
		}

		public void Hide()
		{
			for(int i = 0; i < renderers.Length; i++)
			{
				Material mat = renderers[i].material;
				DemoUtils.SetMaterialTransparent(mat);
			}

			transformScaler.ScaleDown();
			alphaTween.FadeOut();
		}

		protected virtual void Update()
		{

		}

#if UNITY_EDITOR
		[ContextMenu("Setup Renderers")]
		public void SetupRenderers()
		{

			PrefabStage prefabStage = PrefabStageUtility.GetPrefabStage(gameObject);

			if(prefabStage != null)
			{
				this.renderers = transform.GetComponentsInChildren<MeshRenderer>(true);
				EditorSceneManager.MarkSceneDirty(prefabStage.scene);
			}
		}
#endif
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/EnvironmentController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/EnvironmentSpotlightController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d3a1024b9f4c6f140b730bdc467420cc
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class EnvironmentSpotlightController : EnvironmentController
	{
		public Transform lightsParent;
		public float rotationSpeed;

		protected override void Update()
		{
			base.Update();

			Quaternion quat = lightsParent.rotation;
			lightsParent.rotation = quat * Quaternion.AngleAxis(rotationSpeed * Time.deltaTime, lightsParent.up);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/EnvironmentSpotlightController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/InputHandler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8d1c3e379bdb46340b44363dd6b8800a
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;
#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
using UnityEngine.InputSystem;
#endif

namespace AllIn13DShader
{
    public class InputHandler : MonoBehaviour
    {
        [SerializeField] private KeyCode targetKey = KeyCode.A;
        [SerializeField] private KeyCode altKey = KeyCode.None;

#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
        private Key targetNewInputKey;
        private Key altNewInputKey;
        
        private void Awake()
        {
            targetNewInputKey = ConvertKeyCodeToKey(targetKey);
            altNewInputKey = ConvertKeyCodeToKey(altKey);
        }
#endif

        public bool IsKeyPressed()
        {
#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
            if(altKey == KeyCode.None)
            {
                return Keyboard.current != null && Keyboard.current[targetNewInputKey].wasPressedThisFrame;
            }
            return Keyboard.current != null && (Keyboard.current[targetNewInputKey].wasPressedThisFrame || 
                                              Keyboard.current[altNewInputKey].wasPressedThisFrame);
#else
            if(altKey == KeyCode.None)
            {
                return Input.GetKeyDown(targetKey);
            }
            return Input.GetKeyDown(targetKey) || Input.GetKeyDown(altKey);
#endif
        }

        public KeyCode GetTargetKey() => targetKey;
        public KeyCode GetAltKey() => altKey;

#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
        private Key ConvertKeyCodeToKey(KeyCode keyCode)
        {
            switch(keyCode)
            {
                case KeyCode.None: return Key.None;
                case KeyCode.Return: return Key.Enter;
                case KeyCode.KeypadEnter: return Key.NumpadEnter;
            }
            
            if(System.Enum.TryParse(keyCode.ToString(), true, out Key key))
            {
                return key;
            }

            Debug.LogWarning($"Failed to convert KeyCode {keyCode} to Key. Using default Key.None.");
            return Key.None;
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/InputHandler.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/MaterialPrewarmer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e4e063f035a58d54ab72254372789149
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using System.Collections;
using UnityEngine;

namespace AllIn13DShader
{
    public class MaterialPrewarmer : MonoBehaviour
    {
        [SerializeField] private Material[] materialsToPrewarm;
        [SerializeField] private Renderer rendererPrefab;
        [SerializeField] private GameObject[] objectsToPrewarm;
    
        private void Start()
        {
            StartCoroutine(PrewarmMaterials());
        }
    
        private IEnumerator PrewarmMaterials()
        {
            if(materialsToPrewarm == null || materialsToPrewarm.Length == 0)
            {
                Debug.LogWarning("No materials assigned for prewarming.");
                Destroy(gameObject);
                yield break;
            }
        
            if(rendererPrefab == null)
            {
                Debug.LogError("Renderer prefab is not assigned for prewarming.");
                Destroy(gameObject);
                yield break;
            }
            
            Vector3 spawnPos = Vector3.down * 1000f;
        
            // Spawn renderers and assign materials
            for(int i = 0; i < materialsToPrewarm.Length; i++)
            {
                if(materialsToPrewarm[i] == null) continue;
            
                Renderer instance = Instantiate(rendererPrefab, spawnPos, Quaternion.identity, transform);
                instance.material = materialsToPrewarm[i];
            }
            
            for(int i = 0; i < objectsToPrewarm.Length; i++)
            {
                Instantiate(objectsToPrewarm[i], spawnPos, Quaternion.identity, transform);
            }
        
            // Give the GPU a frame to process everything
            yield return new WaitForEndOfFrame();
            yield return null;
        
            Destroy(gameObject);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/MaterialPrewarmer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/OptionsDemo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6388e133eaa564a4ebfa90fcbd40c6f1
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace AllIn13DShader
{
    public class OptionsDemo : MonoBehaviour
    {
        [SerializeField] private Color lockedColor = Color.red;

        [Space, Header("Lock Camera")]
        [SerializeField] private AllIn1MouseTransformRotator allIn1MouseRotate;
        [SerializeField] private TextMeshProUGUI lockCamText;
        [SerializeField] private Image lockCamButtonImage;
        
        [Space, Header("Lock Cursor")]
        [SerializeField] private bool lockCursor = true;
        [SerializeField] private TextMeshProUGUI lockCursorText;
        [SerializeField] private Image lockCursorButtonImage;
        
        [Space, Header("Hide Ui")]
        [SerializeField] private CanvasGroup uiCanvasGroup;
        [SerializeField] private float uiCanvasSmoothing = 5f;

		[Space, Header("Demo Info")]
		[SerializeField] private bool showingDemoInfo = false;
		[SerializeField] private Image showDemoInfoButtonImage;

		private bool cursorIsLocked, camIsLocked, uiIsHidden;
        private float uiCanvasAlpha;

        private void Start()
        {
            cursorIsLocked = lockCursor;
            SetCursorLock();
            
            camIsLocked = false;
            SetCamLock();
        }

        private void Update()
        {
            uiCanvasGroup.alpha = Mathf.Lerp(uiCanvasGroup.alpha, uiIsHidden ? 0f : 1f, Time.unscaledDeltaTime * uiCanvasSmoothing);
        }
        
        public void ToggleCursorButtonPress()
        {
            cursorIsLocked = !cursorIsLocked;
            SetCursorLock();
		}

		public void ToggleShowInfo()
		{
			showingDemoInfo = !showingDemoInfo;
			showDemoInfoButtonImage.color = showingDemoInfo ? lockedColor : Color.clear;
		}

        private void SetCursorLock()
        {
            if(cursorIsLocked)
            {
                Cursor.lockState = CursorLockMode.Locked;
                Cursor.visible = false;
                lockCursorText.text = "Unlock Cursor";
                lockCursorButtonImage.color = lockedColor;
            }
            else
            {
                Cursor.lockState = CursorLockMode.None;
                Cursor.visible = true;
                lockCursorText.text = "Lock Cursor";
                lockCursorButtonImage.color = Color.clear;
            }
        }
        
        public void CamLockButtonPress()
        {
            camIsLocked = !camIsLocked;
            SetCamLock();
        }
        
        
        private void SetCamLock()
        {
            allIn1MouseRotate.enabled = !camIsLocked;
            if(camIsLocked)
            {
                lockCamText.text = "Unlock Camera";
                lockCamButtonImage.color = lockedColor;
            }
            else
            {
                lockCamText.text = "Lock Camera";
                lockCamButtonImage.color = Color.clear;
            }
        }
        
        public void HideUiButtonPress()
        {
            uiIsHidden = !uiIsHidden;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/OptionsDemo.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/PostProcessConfigurator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cb8522dc440232841aa60648309c8fd7
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.SceneManagement;
#endif

using System.IO;
using UnityEngine;

#if ALLIN13DSHADER_BIRP && UNITY_POST_PROCESSING_STACK_V2
using UnityEngine.Rendering.PostProcessing;
#elif ALLIN13DSHADER_URP
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
#endif

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	public class PostProcessConfigurator : MonoBehaviour
	{
		private Camera cam;

#if ALLIN13DSHADER_BIRP && UNITY_POST_PROCESSING_STACK_V2
		public PostProcessProfile postProcessProfileBIRP;
#elif ALLIN13DSHADER_URP
		public VolumeProfile postProcessProfileURP;
#endif

		private void Awake()
		{
			cam = GetComponent<Camera>();

			if(cam == null)
			{
				Debug.LogError("Camera not found in this object!", gameObject);
				return;
			}

#if UNITY_EDITOR
			if (!Application.isPlaying)
			{
				GameObjectUtility.RemoveMonoBehavioursWithMissingScript(gameObject);
#if ALLIN13DSHADER_BIRP && UNITY_POST_PROCESSING_STACK_V2
			ConfigurePostprocessBIRP();
#elif ALLIN13DSHADER_URP
				ConfigurePostprocessURP();
#endif
			}
#endif
		}

#if UNITY_EDITOR
	#if ALLIN13DSHADER_BIRP && UNITY_POST_PROCESSING_STACK_V2
		private void ConfigurePostprocessBIRP()
		{
			PostProcessLayer postProcessLayer;
			if (!cam.gameObject.TryGetComponent<PostProcessLayer>(out postProcessLayer))
			{
				postProcessLayer = cam.gameObject.AddComponent<PostProcessLayer>();
			}

			PostProcessVolume volume;
			if(!cam.gameObject.TryGetComponent<PostProcessVolume>(out volume))
			{
				volume = cam.gameObject.AddComponent<PostProcessVolume>();
			}
			
			postProcessLayer.volumeTrigger = cam.transform;

			if(postProcessProfileBIRP == null)
			{
				string rootFolder = EditorPrefs.GetString("AllIn13DShader_RootPluginFolder", "Assets/AllIn13DShader");
				string profilePath = Path.Combine(rootFolder, "Demo/PostProcessingProfile/3DShaderPP.asset");
				postProcessProfileBIRP = AssetDatabase.LoadAssetAtPath<PostProcessProfile>(profilePath);
			}

			postProcessLayer.volumeLayer = ~0;
			volume.profile = postProcessProfileBIRP;
			volume.isGlobal = true;

			EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
		}
#endif

#if ALLIN13DSHADER_URP
		private void ConfigurePostprocessURP()
		{
			Volume volume;
			if (!cam.gameObject.TryGetComponent<Volume>(out volume))
			{
				volume = cam.gameObject.AddComponent<Volume>();
			}

			if(postProcessProfileURP == null)
			{
				string rootFolder = EditorPrefs.GetString("AllIn13DShader_RootPluginFolder", "Assets/AllIn13DShader");
				string profilePath = Path.Combine(rootFolder, "Demo/PostProcessingProfile/3DShaderPP_URP.asset");
				postProcessProfileURP = AssetDatabase.LoadAssetAtPath<VolumeProfile>(profilePath);
			}

			volume.sharedProfile = (VolumeProfile)postProcessProfileURP;
			EditorUtility.SetDirty(volume);

			UniversalAdditionalCameraData cameraData;
			if(!cam.gameObject.TryGetComponent<UniversalAdditionalCameraData>(out cameraData))
			{
				cameraData = cam.gameObject.AddComponent<UniversalAdditionalCameraData>();
			}
			cameraData.renderPostProcessing = true;

			EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
		}
#endif
#endif
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/PostProcessConfigurator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/SkyController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: cc976fd2f3a5382418cd80faae769e86
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
    public class SkyController : MonoBehaviour
    {
        [SerializeField] private Material[] skyMaterials;
        [SerializeField] private int firstSkyIndex = 0;
        [SerializeField] private InputHandler skyChangeInputHandler;

        private int currentSkyIndex;

        public void Init()
        {
            currentSkyIndex = firstSkyIndex;
            
            RenderSettings.defaultReflectionMode = UnityEngine.Rendering.DefaultReflectionMode.Skybox;
            RenderSettings.skybox = skyMaterials[currentSkyIndex];
        }

        public void NextSky()
        {
            currentSkyIndex++;
            if(currentSkyIndex >= skyMaterials.Length)
            {
                currentSkyIndex = 0;
            }

            // Directly set the skybox to the new material
            RenderSettings.skybox = skyMaterials[currentSkyIndex];
            DynamicGI.UpdateEnvironment();
        }

        public void DemoChanged(DemoElementData demoElementData)
        {
            if(demoElementData.skyboxEnabled)
            {
                RenderSettings.skybox = skyMaterials[currentSkyIndex];
            }
            else
            {
                RenderSettings.skybox = null;
            }

            DynamicGI.UpdateEnvironment();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/SkyController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/AlphaTween.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9808fa4c0fb72f24992e04c8617c3cf6
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class AlphaTween : MonoBehaviour
	{
		private static int MATPROP_ID_GENERAL_ALPHA = Shader.PropertyToID("_GeneralAlpha");

		public enum State
		{
			NONE = 0,
			FADE_IN = 1,
			FADE_OUT = 2,
		}

		private MeshRenderer[] meshRenderers;

		private bool IsTweening
		{
			get
			{
				bool res = state != State.NONE;
				return res;
			}
		}

		private AnimationCurve alphaCurve;
		private float duration;
		private float timer;

		private State state;

		private float alphaSrc;
		private float alphaDst;

		public void Init(DemoSceneConfiguration demoSceneConfig, MeshRenderer[] meshRenderers)
		{
			alphaCurve = demoSceneConfig.alphaCurve;
			duration = demoSceneConfig.alphaDuration;
			timer = 0f;

			this.meshRenderers = meshRenderers;

			state = State.NONE;
		}

		public void FadeIn()
		{
			timer = 0f;
			state = State.FADE_IN;

			alphaSrc = 0f;
			alphaDst = 1f;
		}

		public void FadeOut()
		{
			timer = 0f;
			state = State.FADE_OUT;

			alphaSrc = 1f;
			alphaDst = 0f;
		}

		public void Update()
		{
			if (IsTweening)
			{
				UpdateTweening();
			}
		}

		private void UpdateTweening()
		{
			timer += Time.deltaTime;
			float t = timer / duration;
			float curveT = alphaCurve.Evaluate(t);

			float alpha = Mathf.Lerp(alphaSrc, alphaDst, curveT);

			for(int i = 0; i < meshRenderers.Length; i++)
			{
				meshRenderers[i].sharedMaterial.SetFloat(MATPROP_ID_GENERAL_ALPHA, alpha);
			}

			if(t >= 1f)
			{
				state = State.NONE;
				timer = 0f;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/AlphaTween.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PositionTween.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 55365ba5f8752694da63758c0d7d993f
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace AllIn13DShader
{
	public class PositionTween : MonoBehaviour
	{
		// Start is called before the first frame update
		void Start()
		{

		}

		// Update is called once per frame
		void Update()
		{

		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PositionTween.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTween.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c901b6122eaa4db44878b49f5d994634
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	public class PropertyTween
	{
		protected int propID;
		protected Material mat;
		protected float currentValue;

		[SerializeField] protected string propertyName;

		public virtual void Init(Material mat)
		{
			this.mat = mat;
			propID = Shader.PropertyToID(propertyName);
		}

		public virtual void Update(float deltaTime)
		{
			Tween(deltaTime);
			UpdateMaterial();
		}

		protected virtual void Tween(float deltaTime)
		{

		}

		private void UpdateMaterial()
		{
			mat.SetFloat(propID, currentValue);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTween.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenCollection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eab8b01b4c9522440b3c4c308e49ae16
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[System.Serializable]
	public class PropertyTweenCollection
	{
		public Material mat;

		public PropertyTweenFader[] faderTweens;
		public PropertyTweenSinWave[] sinWaveTweens;

		public void Init()
		{
			if(mat == null) return;
			
			for (int i = 0; i < faderTweens.Length; i++)
			{
				faderTweens[i].Init(mat);
			}

			for (int i = 0; i < sinWaveTweens.Length; i++)
			{
				sinWaveTweens[i].Init(mat);
			}
		}

		public void Update(float deltaTime)
		{
			if(mat == null) return;
			
			for(int i = 0; i < faderTweens.Length; i++)
			{
				faderTweens[i].Update(deltaTime);
			}

			for (int i = 0; i < sinWaveTweens.Length; i++)
			{
				sinWaveTweens[i].Update(deltaTime);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenCollection.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenFader.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 977c8373a22e2be4b8f17402a41cf8e0
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[System.Serializable]
	public class PropertyTweenFader : PropertyTween
	{
		public enum State
		{
			WAITING_FOR_FADE_IN = 0,
			FADING_IN = 1,
			WAITING_FOR_FADE_OUT = 2,
			FADING_OUT = 3,
		}

		private float timer;
		private State state;
		
		[Header("Config")]
		public float waitingForFadeInTime;
		public float fadeInDuration;
		public float waitingForFadeOutTime;
		public float fadeOutDuration;

		public override void Init(Material mat)
		{
			base.Init(mat);

			state = State.WAITING_FOR_FADE_IN;
			timer = 0f;
		}

		protected override void Tween(float deltaTime)
		{
			switch (state)
			{
				case State.WAITING_FOR_FADE_IN:
					UpdateWaitingForFadeIn();
					break;
				case State.FADING_IN:
					UpdateFadingIn();
					break;
				case State.WAITING_FOR_FADE_OUT:
					UpdateWaitingForFadeOut();
					break;
				case State.FADING_OUT:
					UpdateFadingOut();
					break;
			}
		}

		private void UpdateWaitingForFadeIn()
		{
			timer += Time.deltaTime;

			if (timer >= waitingForFadeInTime)
			{
				state = State.FADING_IN;
				timer = 0f;
			}
		}

		private void UpdateFadingIn()
		{
			timer += Time.deltaTime;

			float t = timer / fadeInDuration;
			currentValue = t;

			if (timer >= fadeInDuration)
			{
				state = State.WAITING_FOR_FADE_OUT;
				timer = 0f;
			}
		}

		private void UpdateWaitingForFadeOut()
		{
			timer += Time.deltaTime;

			if (timer >= waitingForFadeOutTime)
			{
				state = State.FADING_OUT;
				timer = 0f;
			}
		}

		private void UpdateFadingOut()
		{
			timer += Time.deltaTime;

			float t = timer / fadeOutDuration;
			currentValue = 1 - t;

			if (timer >= fadeOutDuration)
			{
				state = State.WAITING_FOR_FADE_IN;
				timer = 0f;
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenFader.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenSinWave.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 109d7bd9dbc4170448a098f3590a932c
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[System.Serializable]
	public class PropertyTweenSinWave : PropertyTween
	{
		[Header("Configuration")]
		public float minValue;
		public float maxValue;
		public float speed;

		protected override void Tween(float deltaTime)
		{
			float sin01 = (Mathf.Sin(Time.time * speed) + 1f) * 0.5f;

			currentValue = Mathf.Lerp(minValue, maxValue, sin01);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/PropertyTweenSinWave.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/SinVerticalPositionTween.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bfd62d9a148e2cf47ad5cddb1f76c278
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using System;
using UnityEngine;

namespace AllIn13DShader
{
	public class SinVerticalPositionTween : MonoBehaviour
	{
		private float timer;

		public float speed = 5;
		public float minY = -1;
		public float maxY = 1;

		public Transform target;

		private void OnEnable()
		{
			timer = 0f;
		}

		private void OnDisable()
		{
			timer = 0f;
		}

		public void Update()
		{
			timer += Time.deltaTime;

			float sin01 = (Mathf.Sin(timer * speed) + 1f) * 0.5f;
			Vector3 localPos = target.localPosition;
			localPos.y = Mathf.Lerp(minY, maxY, sin01);

			target.localPosition = localPos;
		}

		private void Reset()
		{
			if(target == null) target = transform;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/SinVerticalPositionTween.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/TransformScaler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 71c6c2d242f3c2243bf1fcaa88c90071
# ASMDEF: AllIn13DShaderDemoScriptsAssembly.dll
# ---
using System;
using UnityEngine;

namespace AllIn13DShader
{
	public class TransformScaler : MonoBehaviour
	{
		public enum ScalingType
		{
			NONE,
			SCALING_UP,
			SCALING_DOWN,
		}

		private float scaleDuration;
		private AnimationCurve scaleCurve;

		private Vector3 localScaleSrc;
		private Vector3 localScaleDst;

		private float timer;
		private ScalingType scalingType;

		private Action<ScalingType> scaleFinishedCallback;

		public void Init(DemoSceneConfiguration demoSceneConfig)
		{
			Init(demoSceneConfig, null);
		}

		public void Init(DemoSceneConfiguration demoSceneConfig, Action<ScalingType> scaleFinishedCallback)
		{
			scaleDuration = demoSceneConfig.scaleDuration;
			scaleCurve = demoSceneConfig.scalingCurve;

			this.scaleFinishedCallback = scaleFinishedCallback;
		}

		public void ScaleUp()
		{
			transform.localScale = Vector3.zero;
			timer = 0f;
			scalingType = ScalingType.SCALING_UP;

			localScaleSrc = Vector3.zero;
			localScaleDst = Vector3.one;
		}

		public void ScaleDown()
		{
			transform.localScale = Vector3.one;
			timer = 0f;
			scalingType = ScalingType.SCALING_DOWN;

			localScaleSrc = Vector3.one;
			localScaleDst = Vector3.zero;
		}

		private void Update()
		{
			if (IsScaling())
			{
				UpdateScaling();
			}
		}

		private void UpdateScaling()
		{
			timer += Time.deltaTime;
			float t = timer / scaleDuration;
			float curveT = t;

			if (scalingType == ScalingType.SCALING_UP)
			{
				curveT = scaleCurve.Evaluate(t);
			}
			else if (scalingType == ScalingType.SCALING_DOWN)
			{
				curveT = 1 - scaleCurve.Evaluate(1 - t);
			}

			float scale = Mathf.LerpUnclamped(localScaleSrc.x, localScaleDst.x, curveT);
			scale = Mathf.Max(0f, scale);

			transform.localScale = Vector3.one * scale;

			if (t >= 1f)
			{
				timer = 0f;

				if (scalingType == ScalingType.SCALING_DOWN)
				{
					gameObject.SetActive(false);
				}

				if(scaleFinishedCallback != null)
				{
					scaleFinishedCallback(scalingType);
				}

				scalingType = ScalingType.NONE;
			}
		}

		public bool IsScaling()
		{
			return scalingType != ScalingType.NONE;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Demo/Scripts/Tweens/TransformScaler.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn13DShaderComponent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 09fb2c5f145047846ac8e94ce0994dbb
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
#if UNITY_EDITOR
using UnityEditor;
#endif

using UnityEngine;

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	[AddComponentMenu("AllIn13DShader/AddAllIn13DShader")]
	public class AllIn13DShaderComponent : MonoBehaviour
	{
		public Renderer currRenderer;
		public Material currMaterial
		{
			get
			{
				return currRenderer.sharedMaterial;
			}
			set
			{
				currRenderer.sharedMaterial = value;
			}
		}

#if UNITY_EDITOR
		public void NewCleanMaterial(Shader shader, Material matPreset)
		{
			Material previousMat = currMaterial;

			currMaterial = new Material(shader);
			currMaterial.CopyMatchingPropertiesFromMaterial(matPreset);

			string materialName = currMaterial.name;
			int nameStartIndex = materialName.LastIndexOf("/");
			if(nameStartIndex >= 0)
			{
				materialName = materialName.Substring(nameStartIndex + 1);
			}

			currMaterial.name = $"MAT_{materialName}";
		}

		public void CleanMaterial()
		{
			currMaterial = new Material(Shader.Find(ConstantsRuntime.STANDARD_SHADER_NAME));
		}
		 
		public bool CheckValidComponent()
		{
			bool res = true;

			bool dirty = false;
			if (currRenderer == null || currMaterial == null)
			{
				res = res && TryGetComponent<Renderer>(out currRenderer);
				dirty = true;
			}

			if (dirty && res)
			{
				currRenderer = GetComponent<Renderer>();
				
				EditorUtility.SetDirty(this);

				if(currMaterial != null)
				{
					EditorUtility.SetDirty(currMaterial);
				}
			}

			return res;
		}

		public void ApplyMaterialToChildren()
		{
			ApplyMaterialRecursively(transform, currMaterial);
		}

		public Material DuplicateCurrentMaterial()
		{
			currMaterial = new Material(currMaterial);
			return currMaterial;
		}

		private void ApplyMaterialRecursively(Transform tr, Material mat)
		{
			bool existsMeshRenderer = tr.TryGetComponent<Renderer>(out currRenderer);

			if (existsMeshRenderer)
			{
				currRenderer.sharedMaterial = mat;
			}

			int childCount = tr.childCount;
			for(int i = 0; i < childCount; i++)
			{
				ApplyMaterialRecursively(tr.GetChild(i), mat);
			}
		}
#endif
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn13DShaderComponent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn13DShaderRandomTimeSeed.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8302f7da0ee1d6848bcadb44b88c6626
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	public class AllIn13DShaderRandomTimeSeed : MonoBehaviour
	{
		[SerializeField] private float minSeedValue = 0;
		[SerializeField] private float maxSeedValue = 100f;

		private void Start()
		{
			RefreshTimingSeed();
		}

		[ContextMenu("Refresh Timing Seed")]
		private void RefreshTimingSeed()
		{
			MaterialPropertyBlock properties = new MaterialPropertyBlock();
			properties.SetFloat("_TimingSeed", Random.Range(minSeedValue, maxSeedValue));
			GetComponent<Renderer>().SetPropertyBlock(properties);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn13DShaderRandomTimeSeed.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn1DepthColoringProperties.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 550a4f83cc82e43499a5efe7e94a4f5a
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[CreateAssetMenu(menuName = "AllIn13DShader/Others/Depth Coloring Properties", fileName = "DepthColoringProperties.asset")]
	public class AllIn1DepthColoringProperties : ScriptableObject
	{
		public float depthColoringMinDepth;
		public float depthZoneLength;
		public float fallOff;
		public Texture2D depthColoringGradientTex;
		
		private readonly int globalMinDepth = Shader.PropertyToID("global_MinDepth");
		private readonly int globalDepthZoneLength = Shader.PropertyToID("global_DepthZoneLength");
		private readonly int globalDepthGradient = Shader.PropertyToID("global_DepthGradient");
		private readonly int globalDepthGradientFallOff = Shader.PropertyToID("global_DepthGradientFallOff");

		private void OnEnable()
		{
			ApplyValues();
		}

		public void ApplyValues()
		{
			ApplyValues(depthColoringGradientTex);
		}

		public void ApplyValues(Texture gradientTex)
		{
			Shader.SetGlobalFloat(globalMinDepth, depthColoringMinDepth);
			Shader.SetGlobalFloat(globalDepthZoneLength, depthZoneLength);
			Shader.SetGlobalFloat(globalDepthGradientFallOff, fallOff);
			Shader.SetGlobalTexture(globalDepthGradient, gradientTex);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/AllIn1DepthColoringProperties.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ConstantsRuntime.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3ea460bdd0e63b64e8d01c3ed5f2d97e
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
namespace AllIn13DShader
{
	public static class ConstantsRuntime
	{
		//Special Properties
		public const string GLOBAL_PROPERTY_GLOBAL_TIME = "allIn13DShader_globalTime";

#if UNITY_EDITOR
		//Standard Shader
#if ALLIN13DSHADER_BIRP
		public const string STANDARD_SHADER_NAME = "Standard";
#elif ALLIN13DSHADER_URP
		public const string STANDARD_SHADER_NAME = "Universal Render Pipeline/Lit";
#else
		public const string STANDARD_SHADER_NAME = "Standard";
#endif

#endif 
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ConstantsRuntime.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/DepthColoringCamera.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bb429cb35d67af14c998db9b8ff58396
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	public class DepthColoringCamera : MonoBehaviour
	{
		[SerializeField] private Camera cam;
		[SerializeField] private AllIn1DepthColoringProperties allIn1DepthColoringProperties;

		[ContextMenu("Enable Depth Texture")]
		public void EnableDepthTexture()
		{
			cam.depthTextureMode = DepthTextureMode.Depth;
		}

#if UNITY_EDITOR
		private void Update()
		{
			Update_Editor();
		}

		private void Reset()
		{
			cam = GetComponent<Camera>();
		}

		private void Update_Editor()
		{
			if(cam != null)
			{
				cam.depthTextureMode = DepthTextureMode.Depth;
			}
		}

		private void OnDrawGizmosSelected()
		{
			if(cam == null || allIn1DepthColoringProperties == null) { return; }

			Vector3 position = Vector3.zero;
			position.z = cam.nearClipPlane + allIn1DepthColoringProperties.depthColoringMinDepth;

			float size = allIn1DepthColoringProperties.depthZoneLength;
			position.z += size * 0.5f;

			Color gizmosColor = Color.blue;
			gizmosColor.a = 0.25f;

			Gizmos.matrix = cam.transform.localToWorldMatrix;
			Gizmos.color = gizmosColor;

			float height = Mathf.Tan(0.5f * cam.fieldOfView * Mathf.Deg2Rad) * cam.farClipPlane * 2f;
			float width = height * cam.aspect;
			Gizmos.DrawCube(position, new Vector3(width, height, size));
		}
#endif
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/DepthColoringCamera.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/FakeLightConfigurator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f2320e0acfff0d641b0ab90e09eef23c
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
using System;
using UnityEngine;

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	public class FakeLightConfigurator : MonoBehaviour
	{
		private readonly int global_lightDirection = Shader.PropertyToID("global_lightDirection");
		private readonly int global_lightColor = Shader.PropertyToID("global_lightColor");

		public Color lightColor = Color.white;

		private void Update()
		{
			Shader.SetGlobalVector(global_lightDirection, -transform.forward);
			Shader.SetGlobalColor(global_lightColor, lightColor);
		}

		private void OnDrawGizmosSelected()
		{
			Vector3 initPos = transform.position;
			Vector3 endPos = initPos + transform.forward * 5f;

			Gizmos.DrawLine(initPos, endPos);
			Gizmos.DrawSphere(endPos, 0.5f);
		}

		private void Reset()
		{
			Light thisLight = GetComponent<Light>();
			if(thisLight != null) lightColor = thisLight.color;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/FakeLightConfigurator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/FastLightingConfigurator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1353b4ef6dd0a1b42968af0266f3e789
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	public class FastLightingConfigurator : MonoBehaviour
	{
		private int globalLightDirectionPropID = Shader.PropertyToID("global_lightDirection");

		public Vector3 globalLightDirection;

		private void Update()
		{
			Shader.SetGlobalVector(globalLightDirectionPropID, globalLightDirection.normalized);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/FastLightingConfigurator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ShaderGlobalTimeController.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 736e2efc20149b14183cb7af7a304732
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	public class ShaderGlobalTimeController : MonoBehaviour
	{
		private readonly int globalTimePropertyID = Shader.PropertyToID(ConstantsRuntime.GLOBAL_PROPERTY_GLOBAL_TIME);
		private Vector4 timeVector;

		private void Update()
		{
			timeVector.x = Time.unscaledTime / 20f;
			timeVector.y = Time.unscaledTime;
			timeVector.z = Time.unscaledTime * 2f;
			timeVector.w = Time.unscaledTime * 3f;
			Shader.SetGlobalVector(globalTimePropertyID, timeVector);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ShaderGlobalTimeController.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ShadowsConfigurator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 74c2a9bafe054594dba7f6110a0e0fa3
# ASMDEF: AllIn13DShaderAssemebly.dll
# ---
using UnityEngine;

namespace AllIn13DShader
{
	[ExecuteInEditMode]
	public class ShadowsConfigurator : MonoBehaviour
	{
		public Color shadowColor;

		private readonly int shadowColorPropID = Shader.PropertyToID("global_shadowColor");

#if UNITY_EDITOR
		public void Update()
		{
			SetupShadowColor();
		}
#endif

		public void SetupShadowColor()
		{
			Shader.SetGlobalColor(shadowColorPropID, shadowColor);
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AllIn13DShader/Scripts/ShadowsConfigurator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/Desktop/HandDesktopControllerLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f64a1c82ed6e468468d3396fc8f0ecae
# ASMDEF: NONE
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {

    public class HandDesktopControllerLink : MonoBehaviour {
        [Header("Input References")]
        public Hand handRight;
        public Transform handRightFollow;
        public BoxCollider handRightBound;
        [Space]
        public Hand handLeft;
        public Transform handLeftFollow;
        public BoxCollider handLeftBound;
        [Space]
        public Camera headCamera;
        public Transform trackingContainer;
        [Space]
        public AutoHandPlayer player;

        [Header("Input Settings")]
        public float mouseHandMovementSpeed = 0.5f;
        public float mouseHandRotationSpeed = 10;
        public float mouseLookRotationSpeed = 15;
        public float handReturnSpeed = 1f;

        public KeyCode grabKey = KeyCode.Space;
        public KeyCode rightHandSelection = KeyCode.Mouse1;
        public KeyCode leftHandSelection = KeyCode.Mouse0;
        public KeyCode rotationKeycode = KeyCode.Mouse2;

        bool headRoationActive = false;
        bool rightHandSelected = false;
        bool leftHandSelected = false;
        bool rotationSelected = false;

        Vector3 handRightStartPosition;
        Vector3 handLeftStartPosition;

        private void Awake() {
            if(handRight != null) {
                handRight.follow = handRightFollow;
                handRightStartPosition = handRightFollow.localPosition;
            }

            if(handLeft != null) {
                handLeft.follow = handLeftFollow;
                handLeftStartPosition = handLeftFollow.localPosition;
            }
        }

        void Update() {
            CheckSelectionInput();
            CheckMovementInput();
        }

        void OnGUI() {
            ShowInputStates();
        }

        void ShowInputStates() {
            int x = Screen.width - 300;
            int y = 10;
            int width = 280;
            int height = 44;

            GUIStyle redStyle = new GUIStyle(GUI.skin.label);
            redStyle.normal.textColor = Color.red;
            redStyle.fontSize = 16;

            GUIStyle greenStyle = new GUIStyle(GUI.skin.label);
            greenStyle.normal.textColor = Color.green;
            greenStyle.fontSize = 16;

            GUI.Label(new Rect(x, y, width, height), $"Head Rotation Active (Default Selected)", headRoationActive ? greenStyle : redStyle);
            y += height + 5;
            GUI.Label(new Rect(x, y, width, height), $"Right Hand Selected (Press {rightHandSelection})", rightHandSelected ? greenStyle : redStyle);
            y += height + 5;
            GUI.Label(new Rect(x, y, width, height), $"Left Hand Selected (Press {leftHandSelection})", leftHandSelected ? greenStyle : redStyle);
            y += height + 5;
            GUI.Label(new Rect(x, y, width, height), $"Grab (Press {grabKey})", Input.GetKey(grabKey) ? greenStyle : redStyle);
            y += height + 5;
            GUI.Label(new Rect(x, y, width, height), $"Rotation Selected (Press {rotationKeycode})", rotationSelected ? greenStyle : redStyle);
        }

        void CheckSelectionInput() {
            if(handRight != null) {
                rightHandSelected = Input.GetKey(rightHandSelection);
            }

            if(handLeft != null) {
                leftHandSelected = Input.GetKey(leftHandSelection);
            }

            rotationSelected = Input.GetKey(rotationKeycode);
            headRoationActive = !rightHandSelected && !leftHandSelected;

        }
        float xRotation = 0f;
        void CheckMovementInput() {
            Vector2 mousePositionDelta = new Vector2(Input.GetAxis("Mouse X"), Input.GetAxis("Mouse Y")) * Time.deltaTime * 4;

            if(Input.GetKeyDown(KeyCode.LeftControl))
                UnityEngine.Cursor.lockState = UnityEngine.Cursor.lockState == CursorLockMode.Locked ? CursorLockMode.None : CursorLockMode.Locked;

            if(rightHandSelected) {
                if(rotationSelected) {
                    handRightFollow.Rotate(handRightFollow.forward, -mousePositionDelta.x * mouseHandRotationSpeed);
                    handRightFollow.Rotate(handRightFollow.right, mousePositionDelta.y * mouseHandRotationSpeed);
                    handRightBound.transform.Rotate(handRightFollow.forward, -mousePositionDelta.x * mouseHandRotationSpeed);
                    handRightBound.transform.Rotate(handRightFollow.right, mousePositionDelta.y * mouseHandRotationSpeed);

                }
                else {
                    handRightFollow.position += handRightFollow.right * mousePositionDelta.x * mouseHandMovementSpeed;
                    handRightFollow.position += handRightFollow.forward * mousePositionDelta.y * mouseHandMovementSpeed;
                }

                if(handRightBound != null) {
                    handRightFollow.position = handRightBound.ClosestPoint(handRightFollow.position);
                }
            }
            else {
                var handReturnSpeed = this.handReturnSpeed * Time.deltaTime * 60;
                handReturnSpeed = handReturnSpeed * Vector3.Distance(handRightFollow.localPosition, handRightStartPosition) > 0.001f ? handReturnSpeed : 0;
                if(handReturnSpeed > 0)
                    handRightFollow.localPosition = Vector3.MoveTowards(handRightFollow.localPosition, handRightStartPosition, handReturnSpeed + 0.001f);
            }

            if(leftHandSelected) {
                if(rotationSelected) {
                    handLeftFollow.Rotate(handLeftFollow.forward, mousePositionDelta.x * mouseHandRotationSpeed);
                    handLeftFollow.Rotate(handLeftFollow.right, mousePositionDelta.y * mouseHandRotationSpeed);
                    handLeftBound.transform.Rotate(handLeftFollow.forward, mousePositionDelta.x * mouseHandRotationSpeed);
                    handLeftBound.transform.Rotate(handLeftFollow.right, mousePositionDelta.y * mouseHandRotationSpeed);
                }
                else {
                    handLeftFollow.position += handLeftFollow.right * mousePositionDelta.x * mouseHandMovementSpeed;
                    handLeftFollow.position += handLeftFollow.forward * mousePositionDelta.y * mouseHandMovementSpeed;
                }

                if(handLeftBound != null) {
                    handLeftFollow.position = handLeftBound.ClosestPoint(handLeftFollow.position);
                }
            }
            else {
                var handReturnSpeed = this.handReturnSpeed * Time.deltaTime * 60;
                handReturnSpeed = handReturnSpeed * Vector3.Distance(handLeftFollow.localPosition, handLeftStartPosition) > 0.001f ? handReturnSpeed : 0;
                if(handReturnSpeed > 0)
                    handLeftFollow.localPosition = Vector3.MoveTowards(handLeftFollow.localPosition, handLeftStartPosition, handReturnSpeed + 0.001f);
            }

            if(headRoationActive) {
                if(rotationSelected) {
                    xRotation -= mouseLookRotationSpeed * 3 * mousePositionDelta.y;
                    xRotation = Mathf.Clamp(xRotation, -15f, 45f);
                    headCamera.transform.localRotation = Quaternion.Euler(xRotation, 0f, 0f);
                }

                trackingContainer.transform.Rotate(Vector3.up * mouseLookRotationSpeed * 10 * mousePositionDelta.x);
            }

            if(Input.GetKeyDown(grabKey)) {
                if(rightHandSelected) {
                    if(handRight.IsHolding())
                        handRight.Release();
                    else
                        handRight.Grab();
                }

                if(leftHandSelected) {
                    if(handLeft.IsHolding())
                        handLeft.Release();
                    else
                        handLeft.Grab();
                }
            }

            var fowardAxis = Input.GetAxis("Vertical");
            var rightAxis = Input.GetAxis("Horizontal");
            player.Move(new Vector2(rightAxis, fowardAxis));
        }

        void KeepPointWithinBox(Transform point, BoxCollider box) {
            if(box == null) return;

            Vector3 localPos = box.transform.InverseTransformPoint(transform.position);
            Vector3 halfExtents = box.size * 0.5f;

            localPos.x = Mathf.Clamp(localPos.x, -halfExtents.x, halfExtents.x);
            localPos.y = Mathf.Clamp(localPos.y, -halfExtents.y, halfExtents.y);
            localPos.z = Mathf.Clamp(localPos.z, -halfExtents.z, halfExtents.z);

            point.position = box.transform.TransformPoint(localPos);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/Desktop/HandDesktopControllerLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandFingerGestureEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ec8d79f2013f4354eaa4caec5e959e57
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand {
    public class HandFingerGestureEvent : MonoBehaviour {
        public HandFingerGestureTracker handFingerGestureTracker;
        public FingerEnum finger1;
        public FingerEnum[] finger2;

        public UnityEvent<HandFingerGestureTracker, FingerEnum, FingerEnum> OnFingerTouchStartEvent;
        public UnityEvent<HandFingerGestureTracker, FingerEnum, FingerEnum> OnFingerTouchStopEvent;

            void OnEnable() {
            handFingerGestureTracker.OnFingerTouchStart += OnFingerTouchStart;
            handFingerGestureTracker.OnFingerTouchStop += OnFingerTouchStop;
        }

        void OnDisable() {
            handFingerGestureTracker.OnFingerTouchStart -= OnFingerTouchStart;
            handFingerGestureTracker.OnFingerTouchStop -= OnFingerTouchStop;
        }

        void OnFingerTouchStart(OpenXRAutoHandTracking hand, HandFingerGestureTracker gestureTracker, FingerTouchEventArgs e) {
            if (e.finger1 == finger1 && finger2.Contains(e.finger2)) {
                OnFingerTouchStartEvent?.Invoke(gestureTracker, e.finger1, e.finger2);
            }
        }

        void OnFingerTouchStop(OpenXRAutoHandTracking hand, HandFingerGestureTracker gestureTracker, FingerTouchEventArgs e) {
            if (e.finger1 == finger1 && finger2.Contains(e.finger2)) {
                OnFingerTouchStopEvent?.Invoke(handFingerGestureTracker, e.finger1, e.finger2);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandFingerGestureEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandFingerGestureTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 611bae9934a88e64f963d2d0a46d97b2
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {

    public struct FingerTouchEventArgs {
        public FingerEnum finger1;
        public FingerEnum finger2;
    }

    public delegate void FingerTouchStartEvent(OpenXRAutoHandTracking hand, HandFingerGestureTracker gestureTracker, FingerTouchEventArgs e);
    public delegate void FingerTouchStopEvent(OpenXRAutoHandTracking hand, HandFingerGestureTracker gestureTracker, FingerTouchEventArgs e);

    public class HandFingerGestureTracker : MonoBehaviour {
        public OpenXRAutoHandTracking handTracking;
        public float fingerTipScale = 1.5f;
        public float fingerTouchEventDelay = 0.1f;

        bool[][] fingerTouchState;
        bool[][] lastFingerTouchState;
        float[][] lastFingerTouchStateChangeTime;



        public event FingerTouchStartEvent OnFingerTouchStart;
        public event FingerTouchStopEvent OnFingerTouchStop;

        void OnEnable() {
            fingerTouchState = new bool[handTracking.hand.fingers.Length][];
            lastFingerTouchState = new bool[handTracking.hand.fingers.Length][];
            lastFingerTouchStateChangeTime = new float[handTracking.hand.fingers.Length][];

            foreach(var finger in handTracking.hand.fingers) {
                var fingerIndex = (int)finger.fingerType;
                fingerTouchState[fingerIndex] = new bool[handTracking.hand.fingers.Length];
                lastFingerTouchState[fingerIndex] = new bool[handTracking.hand.fingers.Length];
                lastFingerTouchStateChangeTime[fingerIndex] = new float[handTracking.hand.fingers.Length];
            }
        }

        private void FixedUpdate() {
            for (int i = 0; i < handTracking.hand.fingers.Length; i++) {
                for (int j = 0; j < handTracking.hand.fingers.Length; j++) {
                    var finger1 = handTracking.hand.fingers[i];
                    var finger2 = handTracking.hand.fingers[j];

                    var finger1Index = (int)finger1.fingerType;
                    var finger2Index = (int)finger2.fingerType;

                    var distance = Vector3.Distance(finger1.tip.position, finger2.tip.position);
                    var radius = finger1.tipRadius * fingerTipScale + finger2.tipRadius * fingerTipScale;

                    fingerTouchState[finger1Index][finger2Index] = distance < radius;

                    if(fingerTouchState[finger1Index][finger2Index] != lastFingerTouchState[finger1Index][finger2Index] ) {
                        if(Time.fixedTime - lastFingerTouchStateChangeTime[finger1Index][finger2Index] < fingerTouchEventDelay) {
                            continue;
                        }

                        if(fingerTouchState[finger1Index][finger2Index]) {
                            OnFingerTouchStart?.Invoke(handTracking, this, new FingerTouchEventArgs { finger1 = finger1.fingerType, finger2 = finger2.fingerType });
                        }
                        else {
                            OnFingerTouchStop?.Invoke(handTracking, this, new FingerTouchEventArgs { finger1 = finger1.fingerType, finger2 = finger2.fingerType });
                        }

                        lastFingerTouchState[finger1Index][finger2Index] = fingerTouchState[finger1Index][finger2Index];
                        lastFingerTouchStateChangeTime[finger1Index][finger2Index] = Time.fixedTime;
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandFingerGestureTracker.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandGestureEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 01e00988dd614a0408eff7ba7d686db4
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Animations;
using UnityEngine.Events;

namespace Autohand {
    public class HandPoseGestureData {
        public float currentPoseDifference;
        public float[] fingerPoseDifference = new float[5];
        public bool currentPoseState;
        public bool currentActivatedPoseState;
        public bool validPoseDirection;
        public float validDirectionAngleDistance;
        public float gestureStartTime;
        public float gestureStopTime;

        public void UpdatePoseDifferenceValues(Hand hand, ref HandPoseData poseData, FingerMask[] fingerMasks) {
            if(hand == null || hand.handAnimator.currentHandPose.fingerPoses == null)
                return;

            currentPoseDifference = 0f;
            int fingerCount = 0;
            for(int i = 0; i < hand.fingers.Length; i++) {
                var finger = hand.fingers[i];
                var fingerIndex = (int)finger.fingerType;

                float fingerWeight = 1f;
                if(fingerMasks != null) {
                    for(int j = 0; j < fingerMasks.Length; j++) { 
                        if(fingerMasks[j].finger == finger.fingerType) {
                            fingerWeight = fingerMasks[j].weight;
                            break;
                        }
                    }
                }

                fingerPoseDifference[fingerIndex] = Mathf.Clamp(hand.handAnimator.currentHandPose.fingerPoses[fingerIndex].GetPoseDifferenceByAngle(ref poseData.fingerPoses[fingerIndex]) / 90f, 0, 3) * fingerWeight;
                currentPoseDifference += fingerPoseDifference[fingerIndex] ;

                if(fingerWeight > 0)
                    fingerCount++;
            }

            currentPoseDifference /= fingerCount;
        }

        internal void SetInvalidData() {
            if(currentPoseState)
                gestureStopTime = Time.time;
            currentPoseState = false;
            currentActivatedPoseState = false;
            validPoseDirection = false;
        }
    }



    public class HandGestureEvent : HandPoseDataContainer {
        [Header("Gesture Event Settings")]
        public List<OpenXRAutoHandTracking> trackingHands;
        public float minimumPoseDistance = 0.85f;
        public float requiredPoseHoldActivationTime = 0.1f;
        public float requiredPoseStopActivationTime = 0.2f;

        [Header("(Optional) Finger Mask Settings")]
        public FingerMask[] fingerMasks = new FingerMask[0];

        [Header("(Optional) Directional Requirements")]
        [Tooltip("The angle distance required to ACTIVATE the pose, relative to the given axis and relative transform settings")]
        public float requiredActivationAngle = 25f;
        [Tooltip("The angle distance required to MAINTAIN the pose, relative to the given axis and relative transform settings")]
        public float requiredMaintainActivationAngle = 80f;
        public Axis palmAxis = Axis.None;
        public Axis targetAxis = Axis.None;
        public Transform relativeTransform;

        [Header("Gesture Events")]
        public UnityEvent<Hand, HandPoseGestureData> OnGestureStartEvent;
        public UnityEvent<Hand, HandPoseGestureData> OnGestureStopEvent;


        Dictionary<Hand, HandPoseGestureData> currentHandGestureData = new Dictionary<Hand, HandPoseGestureData>();
        int lastHandCount = 0;



        protected virtual void Start() {
            if(requiredActivationAngle > requiredMaintainActivationAngle)
                requiredActivationAngle = requiredMaintainActivationAngle;
        }

        protected virtual void LateUpdate() {
            if (trackingHands == null || trackingHands.Count == 0)
                return;

            CheckForHandListChanges();
            UpdatePoseDifferenceValues();
            CheckGestureEventState();
        }

        public bool IsTrackingActive() {
            foreach(OpenXRAutoHandTracking hand in trackingHands) {
                if(hand.hand == null)
                    return false;
                if(hand.handTrackingActive)
                    return true;
            }

            return false;
        }

        public HandPoseGestureData GetCurrentGestureData(Hand hand) {
            if (currentHandGestureData.ContainsKey(hand))
                return currentHandGestureData[hand];
            return null;
        }

        public bool IsGestureActive(Hand hand) {
            if(currentHandGestureData.ContainsKey(hand))
                return currentHandGestureData[hand].currentPoseState;
            return false;
        }

        public float GetCurrentGestureActivationAmount(Hand hand) {
            if(currentHandGestureData.ContainsKey(hand)) {
                var handGestureData = currentHandGestureData[hand];
                if(!handGestureData.currentPoseState)
                    return Mathf.Clamp01((Time.time - handGestureData.gestureStartTime)/requiredPoseHoldActivationTime);
                else
                    return Mathf.Clamp01(1f-(Time.time - handGestureData.gestureStopTime)/requiredPoseStopActivationTime);
            }
            return 0;
        }

        protected void CheckForHandListChanges() {
            if (trackingHands.Count != lastHandCount) {
                lastHandCount = trackingHands.Count;
                currentHandGestureData.Clear();
                foreach(OpenXRAutoHandTracking hand in trackingHands) {
                    currentHandGestureData.Add(hand.hand, new HandPoseGestureData());
                }
            }
        }

        protected virtual void UpdatePoseDifferenceValues() {

            foreach (OpenXRAutoHandTracking handTracking in trackingHands) {
                var hand = handTracking.hand;
                if (hand == null || (hand.left && !leftPose.isSet) || (!hand.left && !rightPose.isSet)) 
                    continue;

                HandPoseGestureData gestureData = currentHandGestureData[hand];

                if(hand.left)
                    gestureData.UpdatePoseDifferenceValues(hand, ref leftPose, fingerMasks);
                else
                    gestureData.UpdatePoseDifferenceValues(hand, ref rightPose, fingerMasks);

                if(IsGestureActive(handTracking.hand))
                    gestureData.validPoseDirection = IsValidPoseDirection(hand, ref gestureData);
                else
                    gestureData.validPoseDirection = IsValidActivationPoseDirection(hand, ref gestureData);

            }

        }
        protected bool IsValidPoseState(Hand hand, ref HandPoseGestureData gestureData) {
            return gestureData.currentPoseDifference < minimumPoseDistance && gestureData.validPoseDirection && hand.holdingObj == null;
        }

        protected void CheckGestureEventState() {
            foreach (OpenXRAutoHandTracking handTracking in trackingHands) {
                var hand = handTracking.hand;
                var gestureData = currentHandGestureData[hand];
                if(IsValidPoseState(hand, ref gestureData)) 
                    OnGestureStart(hand, ref gestureData);
                else 
                    OnGestureStop(hand, ref gestureData);
            }
        }

        protected virtual void OnGestureStart(Hand hand, ref HandPoseGestureData gestureData) {
            if(!gestureData.currentPoseState) {
                gestureData.currentPoseState = true;
                gestureData.gestureStartTime = Time.time;
            }
            if((Time.time - gestureData.gestureStartTime < requiredPoseHoldActivationTime))
                return;

            if(!gestureData.currentActivatedPoseState) { 
                gestureData.currentActivatedPoseState = true;
                OnGestureStartEvent.Invoke(hand, gestureData);
            }
        }

        protected virtual void OnGestureStop(Hand hand, ref HandPoseGestureData gestureData) {
            if(gestureData.currentPoseState) {
                gestureData.currentPoseState = false;
                gestureData.gestureStopTime = Time.time;
            }

            if(Time.time - gestureData.gestureStopTime < requiredPoseStopActivationTime)
                return;

            if(gestureData.currentActivatedPoseState) {
                gestureData.currentActivatedPoseState = false;
                OnGestureStopEvent.Invoke(hand, gestureData);
            }
        }

        protected virtual bool IsValidActivationPoseDirection(Hand hand, ref HandPoseGestureData data) {
            if(!IsTrackingActive())
                return false;

            if(palmAxis == Axis.None || targetAxis == Axis.None) {
                data.validDirectionAngleDistance = 0;
                return true;
            }

            var angle = Vector3.Angle(GetPalmAxis(hand), GetTargetAxis());
            var angleDistance = angle - requiredActivationAngle;
            angleDistance = Mathf.Clamp(angleDistance, 0, angleDistance);
            data.validDirectionAngleDistance = angleDistance;
            return angleDistance == 0;
        }

        protected virtual bool IsValidPoseDirection(Hand hand, ref HandPoseGestureData data) {
            if(!IsTrackingActive())
                return false;

            if(palmAxis == Axis.None || targetAxis == Axis.None) {
                data.validDirectionAngleDistance = 0;
                return true;
            }

            var angle = Vector3.Angle(GetPalmAxis(hand), GetTargetAxis());
            var angleDistance = angle - requiredMaintainActivationAngle;
            angleDistance = Mathf.Clamp(angleDistance, 0, angleDistance);
            data.validDirectionAngleDistance = angleDistance;
            return angleDistance == 0;
        }



        Vector3 GetPalmAxis(Hand hand) {
            if(palmAxis == Axis.X)
                return hand.palmTransform.right;
            else if(palmAxis == Axis.Y)
                return hand.palmTransform.up;
            else if(palmAxis == Axis.Z)
                return hand.palmTransform.forward;
            return Vector3.zero;
        }

        Vector3 GetTargetAxis() {
            if(relativeTransform == null) {
                if(targetAxis == Axis.X)
                    return Vector3.right;
                else if(targetAxis == Axis.Y)
                    return Vector3.up;
                else if(targetAxis == Axis.Z)
                    return Vector3.forward;
            }
            
            if(targetAxis == Axis.X)
                return relativeTransform.right;
            else if(targetAxis == Axis.Y)
                return relativeTransform.up;
            else if(targetAxis == Axis.Z)
                return relativeTransform.forward;

            return Vector3.zero;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandGestureEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandGestureEventTextWriter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5a295687ecd9b8d49a6cdb452de1f48e
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HandGestureEventTextWriter : MonoBehaviour {
        public HandGestureEvent handGestureEvent;
        public TMPro.TextMeshPro currentPoseDistance;
        public TMPro.TextMeshPro currentPoseRequiredActivation;
        public TMPro.TextMeshPro currentPoseActivation;
        public string materialColorName = "_Color";
        public Renderer[] colorMaterials;
        public Gradient colorGradient;
        

        private void OnEnable() {
            handGestureEvent.OnGestureStartEvent.AddListener(OnGestureStart);
            handGestureEvent.OnGestureStopEvent.AddListener(OnGestureStop);
        }

        private void OnDisable() {
            handGestureEvent.OnGestureStartEvent.RemoveListener(OnGestureStart);
            handGestureEvent.OnGestureStopEvent.RemoveListener(OnGestureStop);
        }

        void OnGestureStart(Hand hand, HandPoseGestureData data) {
            currentPoseDistance.color = Color.green;
        }

        void OnGestureStop(Hand hand, HandPoseGestureData data) {
            currentPoseDistance.color = Color.red;
        }

        private void Update() {
            if(handGestureEvent != null) {
                var gesture = handGestureEvent.GetCurrentGestureData(handGestureEvent.trackingHands[0].hand);
                if(gesture == null)
                    return;

                float currentPoseDistanceValue = gesture.currentPoseDifference + gesture.validDirectionAngleDistance;

                if(currentPoseDistance != null)
                    currentPoseDistance.text = (currentPoseDistanceValue).ToString();
                if(currentPoseRequiredActivation != null)
                    currentPoseRequiredActivation.text = handGestureEvent.minimumPoseDistance.ToString();
                if(currentPoseActivation != null)
                    currentPoseActivation.text = handGestureEvent.GetCurrentGestureActivationAmount(handGestureEvent.trackingHands[0].hand).ToString();

                foreach(var rend in colorMaterials) {
                    if(rend != null && rend.material != null && colorGradient != null)
                        rend.material.SetColor(materialColorName, colorGradient.Evaluate(1f - (currentPoseDistanceValue - handGestureEvent.minimumPoseDistance)));
                }
            }
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/HandGestureEventTextWriter.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandMapper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: aa16e59d5c8dfd24e9403fac14ea42f3
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using System.Net.NetworkInformation;
using UnityEngine;
using UnityEngine.XR.Hands;

public class OpenXRAutoHandMapper : MonoBehaviour
{
    public Transform wrist;
    public Transform index;
    public Transform thumb;
    public Transform middle;
    public Transform ring;
    public Transform pinky;


    bool handTrackingSkeletonInitialized = false;
    Dictionary<XRHandJointID, Quaternion> _skeletonMap;
    public Dictionary<XRHandJointID, Quaternion> openHandReference {
        get {
            if(!handTrackingSkeletonInitialized) {
                _skeletonMap = new Dictionary<XRHandJointID, Quaternion>();
                var wrist = this.wrist;

                var indexProximal = index;
                var indexIntermediate = index.GetChild(0);
                var indexDistal = indexIntermediate.GetChild(0);
                var indexTip = indexDistal.GetChild(0);

                var middleProximal = middle;
                var middleIntermediate = middle.GetChild(0);
                var middleDistal = middleIntermediate.GetChild(0);
                var middleTip = middleDistal.GetChild(0);

                var ringProximal = ring;
                var ringIntermediate = ring.GetChild(0);
                var ringDistal = ringIntermediate.GetChild(0);
                var ringTip = ringDistal.GetChild(0);

                var littleProximal = pinky;
                var littleIntermediate = pinky.GetChild(0);
                var littleDistal = ringIntermediate.GetChild(0);
                var littleTip = ringDistal.GetChild(0);

                var thumbMetacarpal = thumb;
                var thumbProximal = thumb.GetChild(0);
                var thumbDistal = thumbProximal.GetChild(0);
                var thumbTip = thumbDistal.GetChild(0);

                _skeletonMap.Add(XRHandJointID.Wrist, wrist.rotation);
                _skeletonMap.Add(XRHandJointID.IndexProximal, indexProximal.rotation);
                _skeletonMap.Add(XRHandJointID.IndexIntermediate, indexIntermediate.rotation);
                _skeletonMap.Add(XRHandJointID.IndexDistal, indexDistal.rotation);
                _skeletonMap.Add(XRHandJointID.IndexTip, indexTip.rotation);

                _skeletonMap.Add(XRHandJointID.MiddleProximal, middleProximal.rotation);
                _skeletonMap.Add(XRHandJointID.MiddleIntermediate, middleIntermediate.rotation);
                _skeletonMap.Add(XRHandJointID.MiddleDistal, middleDistal.rotation);
                _skeletonMap.Add(XRHandJointID.MiddleTip, middleTip.rotation);

                _skeletonMap.Add(XRHandJointID.RingProximal, ringProximal.rotation);
                _skeletonMap.Add(XRHandJointID.RingIntermediate, ringIntermediate.rotation);
                _skeletonMap.Add(XRHandJointID.RingDistal, ringDistal.rotation);
                _skeletonMap.Add(XRHandJointID.RingTip, ringTip.rotation);

                _skeletonMap.Add(XRHandJointID.LittleProximal, littleProximal.rotation);
                _skeletonMap.Add(XRHandJointID.LittleIntermediate, littleIntermediate.rotation);
                _skeletonMap.Add(XRHandJointID.LittleDistal, littleDistal.rotation);
                _skeletonMap.Add(XRHandJointID.LittleTip, littleTip.rotation);

                _skeletonMap.Add(XRHandJointID.ThumbMetacarpal, thumbMetacarpal.rotation);
                _skeletonMap.Add(XRHandJointID.ThumbProximal, thumbProximal.rotation);
                _skeletonMap.Add(XRHandJointID.ThumbDistal, thumbDistal.rotation);
                _skeletonMap.Add(XRHandJointID.ThumbTip, thumbTip.rotation);
            }

            return _skeletonMap;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandMapper.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandTracking.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e9d4e856f5462c441b3f79b930e89638
# ASMDEF: Autohand.OpenXR.dll
# ---
using Autohand.Demo;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;
using UnityEngine.XR.Hands;
using UnityEngine.XR.Management;

namespace Autohand {
    public enum AxisEnum {
        right,
        up,
        forward,
        left,
        down,
        back
    }

    [System.Serializable]
    public struct HandPoseOffset {
        public XRHandJointID jointID;
        public Vector3 localPositionOffset;
        public Vector3 localEularRotationOffset;
    }

    [RequireComponent(typeof(XRHandTrackingEvents))]
    public class OpenXRAutoHandTracking : MonoBehaviour {
        [Header("Hand Settings")]
        public Hand hand;
        public OpenXRHandControllerLink controllerLink;
        public AxisEnum upAxis = AxisEnum.up;
        public AxisEnum forwardAxis = AxisEnum.right;
        public Vector3 handOffset = Vector3.zero;
        public Vector3 handRotationOffset = Vector3.zero;
        public float handPoseSmoothingSpeed = 0.5f;
        public List<HandPoseOffset> handPoseOffsets = new List<HandPoseOffset>();

        [Header("Follow Settings")]
        public float followPositionSmoothing = 1f;
        public float followRotationSmoothing = 1f;

        [Header("Gizmos")]
        public bool drawGizmos = true;
        public Color gizmoColor = Color.white;

        FingerPoseData[] _currentHandTrackingPose = new FingerPoseData[5];
        public FingerPoseData[] currentHandTrackingPose { get { return _currentHandTrackingPose; } }

        FingerPoseData[] _currentTargetPose = new FingerPoseData[5];
        public FingerPoseData[] currentTargetPose { get { return _currentTargetPose; } }

        public bool handTrackingActive { get; private set; }
        public bool controllerTrackingActive { get; private set; }

        XRHandTrackingEvents xrHandTrackingEvents;

        bool jointMapInitialized = false;
        XRHandJointID[] _jointIDMap;
        XRHandJointID[] jointIDMap {
            get {
                if(!jointMapInitialized) {
                    _jointIDMap = new XRHandJointID[20];
                    _jointIDMap[(int)FingerEnum.index * 4 + (int)FingerJointEnum.tip] = XRHandJointID.IndexTip;
                    _jointIDMap[(int)FingerEnum.index * 4 + (int)FingerJointEnum.distal] = XRHandJointID.IndexDistal;
                    _jointIDMap[(int)FingerEnum.index * 4 + (int)FingerJointEnum.middle] = XRHandJointID.IndexIntermediate;
                    _jointIDMap[(int)FingerEnum.index * 4 + (int)FingerJointEnum.knuckle] = XRHandJointID.IndexProximal;

                    _jointIDMap[(int)FingerEnum.middle * 4 + (int)FingerJointEnum.tip] = XRHandJointID.MiddleTip;
                    _jointIDMap[(int)FingerEnum.middle * 4 + (int)FingerJointEnum.distal] = XRHandJointID.MiddleDistal;
                    _jointIDMap[(int)FingerEnum.middle * 4 + (int)FingerJointEnum.middle] = XRHandJointID.MiddleIntermediate;
                    _jointIDMap[(int)FingerEnum.middle * 4 + (int)FingerJointEnum.knuckle] = XRHandJointID.MiddleProximal;

                    _jointIDMap[(int)FingerEnum.ring * 4 + (int)FingerJointEnum.tip] = XRHandJointID.RingTip;
                    _jointIDMap[(int)FingerEnum.ring * 4 + (int)FingerJointEnum.distal] = XRHandJointID.RingDistal;
                    _jointIDMap[(int)FingerEnum.ring * 4 + (int)FingerJointEnum.middle] = XRHandJointID.RingIntermediate;
                    _jointIDMap[(int)FingerEnum.ring * 4 + (int)FingerJointEnum.knuckle] = XRHandJointID.RingProximal;

                    _jointIDMap[(int)FingerEnum.pinky * 4 + (int)FingerJointEnum.tip] = XRHandJointID.LittleTip;
                    _jointIDMap[(int)FingerEnum.pinky * 4 + (int)FingerJointEnum.distal] = XRHandJointID.LittleDistal;
                    _jointIDMap[(int)FingerEnum.pinky * 4 + (int)FingerJointEnum.middle] = XRHandJointID.LittleIntermediate;
                    _jointIDMap[(int)FingerEnum.pinky * 4 + (int)FingerJointEnum.knuckle] = XRHandJointID.LittleProximal;

                    _jointIDMap[(int)FingerEnum.thumb * 4 + (int)FingerJointEnum.tip] = XRHandJointID.ThumbTip;
                    _jointIDMap[(int)FingerEnum.thumb * 4 + (int)FingerJointEnum.distal] = XRHandJointID.ThumbDistal;
                    _jointIDMap[(int)FingerEnum.thumb * 4 + (int)FingerJointEnum.middle] = XRHandJointID.ThumbProximal;
                    _jointIDMap[(int)FingerEnum.thumb * 4 + (int)FingerJointEnum.knuckle] = XRHandJointID.ThumbMetacarpal;

                    jointMapInitialized = true;
                }
                return _jointIDMap;
            }
        }

        bool handTrackingSkeletonInitialized = false;
        Dictionary<XRHandJointID, Transform> _skeletonMap;
        Dictionary<XRHandJointID, Transform> skeletonMap {
            get {
                if(!handTrackingSkeletonInitialized) {
                    _skeletonMap = new Dictionary<XRHandJointID, Transform>();
                    var wrist = new GameObject("Wrist").transform;
                    var indexProximal = new GameObject("IndexProximal").transform;
                    var indexIntermediate = new GameObject("IndexIntermediate").transform;
                    var indexDistal = new GameObject("IndexDistal").transform;
                    var indexTip = new GameObject("IndexTip").transform;

                    var middleProximal = new GameObject("MiddleProximal").transform;
                    var middleIntermediate = new GameObject("MiddleIntermediate").transform;
                    var middleDistal = new GameObject("MiddleDistal").transform;
                    var middleTip = new GameObject("MiddleTip").transform;

                    var ringProximal = new GameObject("RingProximal").transform;
                    var ringIntermediate = new GameObject("RingIntermediate").transform;
                    var ringDistal = new GameObject("RingDistal").transform;
                    var ringTip = new GameObject("RingTip").transform;

                    var littleProximal = new GameObject("LittleProximal").transform;
                    var littleIntermediate = new GameObject("LittleIntermediate").transform;
                    var littleDistal = new GameObject("LittleDistal").transform;
                    var littleTip = new GameObject("LittleTip").transform;

                    var thumbMetacarpal = new GameObject("ThumbMetacarpal").transform;
                    var thumbProximal = new GameObject("ThumbProximal").transform;
                    var thumbDistal = new GameObject("ThumbDistal").transform;
                    var thumbTip = new GameObject("ThumbTip").transform;
                    
                    wrist.SetParent(transform);

                    indexProximal.SetParent(wrist);
                    indexIntermediate.SetParent(indexProximal);
                    indexDistal.SetParent(indexIntermediate);
                    indexTip.SetParent(indexDistal);

                    middleProximal.SetParent(wrist);
                    middleIntermediate.SetParent(middleProximal);
                    middleDistal.SetParent(middleIntermediate);
                    middleTip.SetParent(middleDistal);

                    ringProximal.SetParent(wrist);
                    ringIntermediate.SetParent(ringProximal);
                    ringDistal.SetParent(ringIntermediate);
                    ringTip.SetParent(ringDistal);

                    littleProximal.SetParent(wrist);
                    littleIntermediate.SetParent(littleProximal);
                    littleDistal.SetParent(littleIntermediate);
                    littleTip.SetParent(littleDistal);

                    thumbMetacarpal.SetParent(wrist);
                    thumbProximal.SetParent(thumbMetacarpal);
                    thumbDistal.SetParent(thumbProximal);
                    thumbTip.SetParent(thumbDistal);

                    _skeletonMap.Add(XRHandJointID.Wrist, wrist);
                    _skeletonMap.Add(XRHandJointID.IndexProximal, indexProximal);
                    _skeletonMap.Add(XRHandJointID.IndexIntermediate, indexIntermediate);
                    _skeletonMap.Add(XRHandJointID.IndexDistal, indexDistal);
                    _skeletonMap.Add(XRHandJointID.IndexTip, indexTip);

                    _skeletonMap.Add(XRHandJointID.MiddleProximal, middleProximal);
                    _skeletonMap.Add(XRHandJointID.MiddleIntermediate, middleIntermediate);
                    _skeletonMap.Add(XRHandJointID.MiddleDistal, middleDistal);
                    _skeletonMap.Add(XRHandJointID.MiddleTip, middleTip);

                    _skeletonMap.Add(XRHandJointID.RingProximal, ringProximal);
                    _skeletonMap.Add(XRHandJointID.RingIntermediate, ringIntermediate);
                    _skeletonMap.Add(XRHandJointID.RingDistal, ringDistal);
                    _skeletonMap.Add(XRHandJointID.RingTip, ringTip);

                    _skeletonMap.Add(XRHandJointID.LittleProximal, littleProximal);
                    _skeletonMap.Add(XRHandJointID.LittleIntermediate, littleIntermediate);
                    _skeletonMap.Add(XRHandJointID.LittleDistal, littleDistal);
                    _skeletonMap.Add(XRHandJointID.LittleTip, littleTip);

                    _skeletonMap.Add(XRHandJointID.ThumbMetacarpal, thumbMetacarpal);
                    _skeletonMap.Add(XRHandJointID.ThumbProximal, thumbProximal);
                    _skeletonMap.Add(XRHandJointID.ThumbDistal, thumbDistal);
                    _skeletonMap.Add(XRHandJointID.ThumbTip, thumbTip);

                    handTrackingSkeletonInitialized = true;
                }
                return _skeletonMap;
            }
        }

        Transform handControllerFollow = null;

        Transform _handTrackingFollowOffset = null;
        public Transform handTrackingFollowOffset {
            get {
                if(_handTrackingFollowOffset == null) {
                    _handTrackingFollowOffset = new GameObject("HandFollowTrackingOffset").transform;
                    _handTrackingFollowOffset.parent = handTrackingFollow;
                    _handTrackingFollowOffset.localPosition = Vector3.zero;
                    _handTrackingFollowOffset.localRotation = Quaternion.identity;
                }
                return _handTrackingFollowOffset;
            }
        }

        Transform _handTrackingFollow = null;
        public Transform handTrackingFollow {
            get {
                if(_handTrackingFollow == null) {
                    _handTrackingFollow = new GameObject("HandFollowTracking").transform;
                    _handTrackingFollow.parent = hand.transform.parent;
                    _handTrackingFollow.localPosition = Vector3.zero;
                    _handTrackingFollow.localRotation = Quaternion.identity;
                    if(handControllerFollow == null) {
                        if(hand.follow != null)
                            handControllerFollow = hand.follow;
                        else
                            handControllerFollow = handTrackingFollowOffset;
                    }
                    hand.follow = handTrackingFollowOffset;
                }
                return _handTrackingFollow;
            }
        }

        public XRHandJointID GetHandJointID(FingerEnum fingerType, FingerJointEnum fingerJoint) => jointIDMap[(int)fingerType * 4 + (int)fingerJoint];

        public Transform GetHandTransform(XRHandJointID jointID) {
            switch(jointID) {
                case XRHandJointID.IndexProximal: return GetFinger(FingerEnum.index).knuckleJoint;
                case XRHandJointID.IndexIntermediate: return GetFinger(FingerEnum.index).middleJoint;
                case XRHandJointID.IndexDistal: return GetFinger(FingerEnum.index).distalJoint;
                case XRHandJointID.IndexTip: return GetFinger(FingerEnum.index).tip;
                case XRHandJointID.MiddleProximal: return GetFinger(FingerEnum.middle).knuckleJoint;
                case XRHandJointID.MiddleIntermediate: return GetFinger(FingerEnum.middle).middleJoint;
                case XRHandJointID.MiddleDistal: return GetFinger(FingerEnum.middle).distalJoint;
                case XRHandJointID.MiddleTip: return GetFinger(FingerEnum.middle).tip;
                case XRHandJointID.RingProximal: return GetFinger(FingerEnum.ring).knuckleJoint;
                case XRHandJointID.RingIntermediate: return GetFinger(FingerEnum.ring).middleJoint;
                case XRHandJointID.RingDistal: return GetFinger(FingerEnum.ring).distalJoint;
                case XRHandJointID.RingTip: return GetFinger(FingerEnum.ring).tip;
                case XRHandJointID.LittleProximal: return GetFinger(FingerEnum.pinky).knuckleJoint;
                case XRHandJointID.LittleIntermediate: return GetFinger(FingerEnum.pinky).middleJoint;
                case XRHandJointID.LittleDistal: return GetFinger(FingerEnum.pinky).distalJoint;
                case XRHandJointID.LittleTip: return GetFinger(FingerEnum.pinky).tip;
                case XRHandJointID.ThumbMetacarpal: return GetFinger(FingerEnum.thumb).knuckleJoint;
                case XRHandJointID.ThumbProximal: return GetFinger(FingerEnum.thumb).middleJoint;
                case XRHandJointID.ThumbDistal: return GetFinger(FingerEnum.thumb).distalJoint;
                case XRHandJointID.ThumbTip: return GetFinger(FingerEnum.thumb).tip;
            }
            return null;
        }

        Finger GetFinger(FingerEnum fingerType) {
            for(int i = 0; i < hand.fingers.Length; i++) {
                if(hand.fingers[i].fingerType == fingerType)
                    return hand.fingers[i];
            }
            return null;
        }

        Dictionary<XRHandJointID, Pose> handPoseOffsetDictionary;

        protected virtual void OnEnable() {
            xrHandTrackingEvents = GetComponent<XRHandTrackingEvents>();
            if(hand != null)
                xrHandTrackingEvents.handedness = hand.left ? Handedness.Left : Handedness.Right;

            hand.follow = handTrackingFollowOffset;

            for(int i = 0; i < _currentHandTrackingPose.Length; i++)
                _currentHandTrackingPose[i] = new FingerPoseData(hand, hand.fingers[i]);

            for(int i = 0; i < _currentTargetPose.Length; i++)
                _currentTargetPose[i] = new FingerPoseData(hand, hand.fingers[i]);

            if(controllerLink == null) {
                if(!hand.CanGetComponent(out controllerLink))
                    controllerLink = hand.gameObject.GetComponentInChildren<OpenXRHandControllerLink>();
            }

            handPoseOffsetDictionary = new Dictionary<XRHandJointID, Pose>();
            foreach(var poseOffset in handPoseOffsets) {
                var jointTransform = GetHandTransform(poseOffset.jointID);
                if(jointTransform != null) {
                    var basePos = jointTransform.localPosition;
                    var offset = new Pose(
                        basePos + poseOffset.localPositionOffset,
                        Quaternion.Euler(poseOffset.localEularRotationOffset)
                    );
                    handPoseOffsetDictionary.Add(poseOffset.jointID, offset);
                }
            }

            xrHandTrackingEvents.jointsUpdated.AddListener(UpdateSkeletonTransform);
        }

        protected virtual void OnDisable() {
            Debug.Log("OpenXRAutoHandTracking OnDisable");
            handPoseOffsetDictionary.Clear(); 
            xrHandTrackingEvents.jointsUpdated.RemoveListener(UpdateSkeletonTransform);

            hand.enableIK = true;
            hand.follow = handControllerFollow;
            if(controllerLink != null)
                controllerLink.enabled = true;
        }

        protected virtual void Update() {

            hand.enableIK = !xrHandTrackingEvents.handIsTracked;
            hand.follow = xrHandTrackingEvents.handIsTracked ? handTrackingFollowOffset : handControllerFollow;
            if(controllerLink != null) {
                controllerLink.enabled = !xrHandTrackingEvents.handIsTracked;
                controllerTrackingActive = controllerLink.enabled;
            }

            handTrackingActive = xrHandTrackingEvents.handIsTracked;
        }

        protected virtual void UpdateSkeletonTransform(XRHandJointsUpdatedEventArgs args) {
            if(controllerTrackingActive || !handTrackingActive)
                return;

            var xrHand = args.hand;
            if(xrHand == null)
                return;
            var map = skeletonMap;
            foreach(var bone in map) {
                var poseValue = xrHand.GetJoint(bone.Key);
                if(poseValue.TryGetPose(out var pose)) {
                    bone.Value.position = pose.position;
                    bone.Value.rotation = pose.rotation;
                }
            }

            var wristTransform = map[XRHandJointID.Wrist];
            var dist = Vector3.Distance(handTrackingFollow.position, wristTransform.position);
            var angleFrac = Quaternion.Angle(handTrackingFollow.rotation, wristTransform.rotation) / 180f;

            var movePos = dist * 60f * Time.deltaTime;
            movePos += 1f - (Time.deltaTime * 30f * followPositionSmoothing);

            var moveRot = angleFrac * 60f * Time.deltaTime;
            moveRot += 1f - (Time.deltaTime * 30f * followRotationSmoothing);

            handTrackingFollow.localPosition = Vector3.Lerp(handTrackingFollow.localPosition, wristTransform.position, movePos);
            handTrackingFollow.localRotation = Quaternion.Lerp(handTrackingFollow.localRotation, wristTransform.rotation, moveRot);
            handTrackingFollowOffset.localPosition = handOffset;
            handTrackingFollowOffset.localRotation = Quaternion.Euler(handRotationOffset);

            wristTransform.position = hand.transform.TransformPoint(-handOffset);
            wristTransform.rotation = hand.transform.rotation * Quaternion.Inverse(Quaternion.Euler(handRotationOffset));

            foreach(var finger in hand.fingers) {
                var fingerIndex = (int)finger.fingerType;
                if(hand.IsGrabbing() || hand.IsHolding())
                    _currentTargetPose[fingerIndex].SetPoseData(hand, finger);

                for(int i = 0; i < (int)FingerJointEnum.tip; i++) {
                    var jointID = GetHandJointID(finger.fingerType, (FingerJointEnum)i);
                    var skeletonJoint = map[jointID];
                    var fingerTransform = finger.FingerJoints[i];
                    var forward = GetTransformAxis(skeletonJoint, forwardAxis);
                    var up = GetTransformAxis(skeletonJoint, upAxis);
                    var targetRotation = Quaternion.LookRotation(forward, up);
                    var angleDiff = Quaternion.Angle(fingerTransform.rotation, targetRotation) / 180f;

                    var lerpPoint = angleDiff * 60f * Time.deltaTime;
                    lerpPoint += 1f - (Time.deltaTime * 30f * handPoseSmoothingSpeed);
                    fingerTransform.rotation = Quaternion.Lerp(fingerTransform.rotation, targetRotation, lerpPoint);

                    if(handPoseOffsetDictionary.TryGetValue(jointID, out var poseOffset)) {
                        fingerTransform.localPosition = poseOffset.position;
                        fingerTransform.localRotation *= poseOffset.rotation;
                    }
                }
                _currentHandTrackingPose[fingerIndex].SetPoseData(hand, finger);
                if(hand.IsGrabbing() || hand.IsHolding())
                    _currentTargetPose[fingerIndex].SetFingerPose(finger);
            }
        }




        public Vector3 GetTransformAxis(Transform t, AxisEnum axis) {
            switch(axis) {
                case AxisEnum.right: return t.right;
                case AxisEnum.up: return t.up;
                case AxisEnum.forward: return t.forward;
                case AxisEnum.down: return -t.up;
                case AxisEnum.left: return -t.right;
                case AxisEnum.back: return -t.forward;
            }
            return Vector3.zero;
        }

        protected virtual void OnDrawGizmos() {
            if(!Application.isPlaying) return;
            if(drawGizmos && skeletonMap != null) {
                Gizmos.color = gizmoColor;
                foreach(var bone in skeletonMap) {
                    if(bone.Key != XRHandJointID.Wrist) {
                        Gizmos.DrawLine(bone.Value.position, bone.Value.parent.position);
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandTracking.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandTrackingGrabber.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 36fbd61cbe0704849869518b8d6f40b7
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;

namespace Autohand {
    [DefaultExecutionOrder(10002)]
    public class OpenXRAutoHandTrackingGrabber : MonoBehaviour {
        [Tooltip("Reference to the hand tracker responsible for tracking hand movements and poses")]
        public OpenXRAutoHandTracking handTracker;
        [Header("Holding Settings")]
        public bool allowHeldFingerMovement = true;
        [Space]
        [Header("Touch Grab Settings")]
        [Tooltip("The delay in seconds before a grab is released after the grab condition is no longer met")]
        [Min(0)]
        public float releaseGrabDelay = 0.35f;
        [Tooltip("Multiplier for the radius of the finger tip detection spheres used in touch grabbing")]
        [Min(0)]
        public float fingerTipRadiusMultiplier = 2f;
        [Tooltip("Enables or disables grabbing objects by touching them with fingers")]
        public bool useFingerTouchGrabbing = true;
        [Tooltip("Enables or disables releasing objects by touching them with fingers")]
        public bool useFingerTouchReleasing = true;
        [Tooltip("Enables or disables maintaining a held pose while holding an object with finger touch grabbing")]
        public bool useTouchHoldingWithHeldPose = false;


        [Header("Pose Grab Settings")]
        [Tooltip("Enables or disables grabbing objects using predefined hand poses")]
        public bool usePoseGrabbing = true;
        [Tooltip("The minimum closeness required for the hand pose to initiate a grab - closeness is near 0 with open hand pose, near 1 with closed fist pose")]
        [Min(0)]
        public float minPoseGrabCloseness = 0.35f;
        [Tooltip("The maximum closeness allowed for the hand pose to initiate a grab - closeness is near 0 with open hand pose, near 1 with closed fist pose")]
        [Min(0)]
        public float maxPoseGrabCloseness = 0.9f;
        [Space]
        [Tooltip("The delta in the OpenCloseness value required to trigger any grab type. This happens when the hand is moving from open to closed pose, and helps prevent grabbing from triggering by just touching an object. Recommended value range of 0.03f-0.005f")]
        [Min(0)]
        public float minDeltaPoseActivation = 0.01f;

        [Tooltip("The required change in open to closed pose state to guarentee trigger a grab - this allows you to grab objects by quickly making a fist from an open state - this value will become harder to activated when a higher value")]
        [Min(0)]
        public float maxDeltaPoseActivation = 0.035f;


        [Header("Pose Release Settings")]
        [Tooltip("Enables or disables releasing objects using predefined hand poses")]
        public bool usePoseRelease = true; 
        [Tooltip("The minimum openness required for the hand pose to initiate a release")]
        [Min(0)]
        public float minPoseReleaseOpenness = 0f;
        [Tooltip("The maximum openness allowed for the hand pose to initiate a release")]
        [Min(0)]
        public float maxPoseReleaseOpenness = 0.5f;
        [Tooltip("The required change in openness to trigger a release - this allows you to release objects just by quickly making an open hand pose even if the other release condititions aren't met. Helps prevent hand from getting stuck holding something")]
        [Min(0)]
        public float requiredDeltaPoseReleaseOpenness = 0.07f;

        [Header("Pose Squeeze Settings")]
        [Tooltip("Enables or disables squeezing objects using predefined hand poses")]
        public bool usePoseSqueezing = true;
        [Tooltip("The delay in seconds before a squeeze is unsqueezed after the squeeze condition is no longer met")]
        [Min(0)]
        public float squeezeUnsqueezeDelay = 0.5f;
        [Tooltip("Multiplier for the sensitivity of the squeezing pose detection")]
        [Min(0)]
        public float squeezePoseSensitvityMultiplier = 1.5f;



        FingerPoseData[] startOpenPose = new FingerPoseData[5];
        FingerPoseData[] startClosedPose = new FingerPoseData[5];
        FingerPoseData[] currentFingerPoses = new FingerPoseData[5];
        FingerPoseData[] currentSmoothFingerPoses = new FingerPoseData[5];
        FingerPoseData[] grabPoseTarget = new FingerPoseData[5];


        float currentHandOpenCloseState = 0f;
        float[] fingerOpenDifferences = new float[5];
        float[] fingerCloseDifferences = new float[5];
        float[] fingerCurrentOpenClose = new float[5];
        float[] fingerCurrentOpenCloseLastFrame = new float[5];


        float currentHeldOpenState = 0f;
        float currentHeldCloseState = 0f;
        float[] fingerHeldDifferences = new float[5];
        float[] fingerCurrentHeldOpen = new float[5];
        float[] fingerCurrentHeldClose = new float[5];

        
        float currentHeldAnimationFromToState = 0f;
        float[] fingerHeldAnimationFromDifferences = new float[5];
        float[] fingerHeldAnimationToDifferences = new float[5];
        float[] fingerCurrentHeldAnimationFromTo = new float[5];

        
        float deltaCurrentHandOpenClosedState = 0f;


        Grabbable[] currentFingerTouch = new Grabbable[5];
        Collider[] overlapSphereResults = new Collider[128];
        int[] lastColliderLayer = new int[128];

        bool usingHeldPose;
        GrabbablePoseAnimaion heldPoseAnimation;

        float releaseTime;
        float grabTime;



        protected virtual void OnEnable() {
            for(int i = 0; i < currentFingerTouch.Length; i++) {
                currentFingerTouch[i] = null;
            }

            var hand = handTracker.hand;
            for(int i = 0; i < startOpenPose.Length; i++) {
                var finger = hand.fingers[i];
                var fingerIndex = (int)finger.fingerType;
                startOpenPose[fingerIndex] = new FingerPoseData(finger.poseData[(int)FingerPoseEnum.Open]);
                startClosedPose[fingerIndex] = new FingerPoseData(finger.poseData[(int)FingerPoseEnum.Closed]);
                currentFingerPoses[fingerIndex] = new FingerPoseData(finger.poseData[(int)FingerPoseEnum.Closed]);
                currentSmoothFingerPoses[fingerIndex] = new FingerPoseData(finger.poseData[(int)FingerPoseEnum.Closed]);
                grabPoseTarget[fingerIndex] = new FingerPoseData(finger.poseData[(int)FingerPoseEnum.Closed]);
            }

            hand.OnBeforeGrabbed += OnBeforeGrab;
            hand.OnGrabbed += OnGrab;
            hand.OnReleased += OnRelease;
            InputTracking.trackingAcquired += OnControllerTrackingAquired;
        }


        protected virtual void OnDisable() {
            var hand = handTracker.hand;
            hand.OnBeforeGrabbed -= OnBeforeGrab;
            hand.OnGrabbed -= OnGrab;
            hand.OnReleased -= OnRelease;
            InputTracking.trackingAcquired -= OnControllerTrackingAquired;
        }
        


        void OnControllerTrackingAquired(XRNodeState node) {
            var hand = handTracker.hand;
            if((node.nodeType == XRNode.LeftHand && hand.left) || (node.nodeType == XRNode.RightHand && !hand.left)) {
                ResetHandPoseData(hand);
            }
        }

        void ResetHandPoseData(Hand hand) {
            foreach(var finger in hand.fingers) {
                var fingerIndex = (int)finger.fingerType;
                finger.poseData[(int)FingerPoseEnum.Open].CopyFromData(ref startOpenPose[fingerIndex]);
                finger.poseData[(int)FingerPoseEnum.Closed].CopyFromData(ref startClosedPose[fingerIndex]);
            }
        }

        void OnBeforeGrab(Hand hand, Grabbable grab) {
            if(handTracker.controllerTrackingActive)
                return;

            //Physics.SyncTransforms();
            if(!handTracker.hand.usingHighlight || hand.highlighter.currentHighlightTarget == null || !hand.highlighter.currentHighlightTarget.Equals(grab)) {
                handTracker.hand.highlighter.UpdateHighlight(true, true);
                Debug.Log("Backup Highlight");
            }

            ResetHandPoseData(hand);
            for(int i = 0; i < hand.fingers.Length; i++) {
                var finger = hand.fingers[i];
                var fingerIndex = (int)finger.fingerType;
                currentSmoothFingerPoses[fingerIndex].CopyFromData(ref handTracker.currentHandTrackingPose[fingerIndex]);
            }
        }

        void OnGrab(Hand hand, Grabbable grab) {
            if(handTracker.controllerTrackingActive)
                return;

            if(!handTracker.hand.usingHighlight || hand.highlighter.currentHighlightTarget == null || !hand.highlighter.currentHighlightTarget.Equals(grab)) {
                handTracker.hand.highlighter.UpdateHighlight(true, true);
                Debug.Log("Backup Highlight");
            }

            if(grab.GetGrabPose(hand, out var grabPose)) {
                usingHeldPose = true;

                if(grabPose.CanGetComponent<GrabbablePoseAnimaion>(out var poseAnimation))
                    heldPoseAnimation = poseAnimation;
            }

            for(int i = 0; i < hand.fingers.Length; i++) {
                var finger = hand.fingers[i];
                var fingerIndex = (int)finger.fingerType;

                grabPoseTarget[fingerIndex].CopyFromData(ref hand.handAnimator.targetGrabPose.fingerPoses[fingerIndex]);
                currentSmoothFingerPoses[fingerIndex].CopyFromData(ref grabPoseTarget[fingerIndex]);
            }

            grabTime = Time.time;
        }


        void OnRelease(Hand hand, Grabbable grab) {
            if(handTracker.controllerTrackingActive)
                return;

            releaseTime = Time.time;
            usingHeldPose = false; 
            heldPoseAnimation = null;
        }







        public void FixedUpdate() {
            if(handTracker.controllerTrackingActive || !handTracker.enabled)
                return;

            CalculateHandPoseState();
            CheckSqueezeState();
            if(usingHeldPose)
                CalculateHeldPoseState();
        }


        public void LateUpdate() {
            if(handTracker.controllerTrackingActive)
                return;

            CheckSqueezeState();
            UpdateHandHeldPose();
            CheckCurrentFingerTouch();
            CheckForValidGrab();
            CheckForValidRelease();

            if(!handTracker.hand.IsGrabbing() && !handTracker.hand.holdingObj)
                handTracker.hand.handAnimator.currentHandPose.SavePose(handTracker.hand);
        }




        private void UpdateHandHeldPose() {

            var hand = handTracker.hand;
            if(hand.holdingObj != null && !hand.IsGrabbing()) {
                if(allowHeldFingerMovement) {
                    var grabbingLayer = LayerMask.NameToLayer(Hand.grabbingLayerName);
                    var grabbingMask = LayerMask.GetMask(Hand.grabbingLayerName);


                    for(int i = 0; i < hand.highlighter.highlightColliderNonAllocCount; i++) {
                        var collider = hand.highlighter.highlightCollidersNonAlloc[i];
                        if(collider == null)
                            continue;
                        lastColliderLayer[i] = collider.gameObject.layer;
                        collider.gameObject.layer = grabbingLayer;
                    }

                    for(int i = 0; i < hand.fingers.Length; i++) {
                        var finger = hand.fingers[i];
                        var fingerIndex = (int)finger.fingerType;

                        if(usingHeldPose) {
                            if(heldPoseAnimation != null) {
                                grabPoseTarget[fingerIndex].CopyFromData(ref heldPoseAnimation.currentAnimationPose.fingerPoses[fingerIndex]);
                            }

                            currentFingerPoses[fingerIndex].CopyFromData(ref grabPoseTarget[fingerIndex]);
                            if(fingerCurrentHeldOpen[fingerIndex] > fingerCurrentHeldClose[fingerIndex])
                                currentFingerPoses[fingerIndex].LerpDataTo(ref handTracker.currentHandTrackingPose[fingerIndex], (fingerCurrentHeldOpen[fingerIndex] - fingerCurrentHeldClose[fingerIndex])*2f);
                        }
                        else {
                            if(currentFingerTouch[fingerIndex] != null) {
                                currentFingerPoses[fingerIndex].CopyFromData(ref currentSmoothFingerPoses[fingerIndex]);

                                currentFingerPoses[fingerIndex].LerpDataTo(ref handTracker.currentHandTrackingPose[fingerIndex], (Mathf.Clamp01(1f-fingerCurrentOpenClose[fingerIndex])));
                                finger.BendFingerUntilNoHit(hand.fingerBendSteps, grabbingMask, ref currentFingerPoses[fingerIndex], ref startOpenPose[fingerIndex]);
                                currentFingerPoses[fingerIndex].SetPoseData(hand, finger);
                            }
                            else {
                                currentFingerPoses[fingerIndex].CopyFromData(ref handTracker.currentHandTrackingPose[fingerIndex]);
                                //currentFingerPoses[fingerIndex].SetPoseData(hand, finger);
                            }
                        }

                        var angleDiff = Mathf.Sqrt(currentSmoothFingerPoses[fingerIndex].GetPoseDifferenceByAngle(ref currentFingerPoses[fingerIndex]));
                        currentSmoothFingerPoses[fingerIndex].LerpDataTo(ref currentFingerPoses[fingerIndex], Time.deltaTime * angleDiff * 6f);
                        currentSmoothFingerPoses[fingerIndex].SetFingerPose(finger);
                    }

                    for(int i = 0; i < hand.highlighter.highlightColliderNonAllocCount; i++) {
                        if(hand.highlighter.highlightCollidersNonAlloc[i] != null)
                        hand.highlighter.highlightCollidersNonAlloc[i].gameObject.layer = lastColliderLayer[i];
                    }
                }
                else if(!hand.IsGrabbing()){

                    for(int i = 0; i < hand.fingers.Length; i++) {
                        var finger = hand.fingers[i];
                        var fingerIndex = (int)finger.fingerType;

                        if(heldPoseAnimation != null) {
                            grabPoseTarget[fingerIndex].CopyFromData(ref heldPoseAnimation.currentAnimationPose.fingerPoses[fingerIndex]);
                        }

                        currentFingerPoses[fingerIndex].CopyFromData(ref grabPoseTarget[fingerIndex]);
                        currentFingerPoses[fingerIndex].SetFingerPose(finger);
                    }
                }
            }
        }




        void CalculateHandPoseState() {
            var hand = handTracker.hand;

            var fingerCount = hand.fingers.Length;
            currentHandOpenCloseState = 0f;
            deltaCurrentHandOpenClosedState = 0f;

            for(int i = 0; i < fingerCount; i++) {
                var finger = hand.fingers[i];
                var fingerIndex = (int)finger.fingerType;
                fingerCurrentOpenCloseLastFrame[fingerIndex] = fingerCurrentOpenClose[fingerIndex];

                fingerOpenDifferences[fingerIndex] = handTracker.currentHandTrackingPose[fingerIndex].GetPoseDifferenceByAngle(ref startOpenPose[fingerIndex]);
                fingerCloseDifferences[fingerIndex] = handTracker.currentHandTrackingPose[fingerIndex].GetPoseDifferenceByAngle(ref startClosedPose[fingerIndex]);
                fingerCurrentOpenClose[fingerIndex] = CalculatePoseMatch(fingerOpenDifferences[fingerIndex], fingerCloseDifferences[fingerIndex]);

                if(!hand.IsGrabbing())
                    finger.poseData[(int)FingerPoseEnum.Open].CopyFromData(ref handTracker.currentHandTrackingPose[fingerIndex]);
            }

            for(int i = 0; i < fingerCurrentOpenClose.Length; i++) {
                currentHandOpenCloseState += fingerCurrentOpenClose[i];
                deltaCurrentHandOpenClosedState += fingerCurrentOpenClose[i] - fingerCurrentOpenCloseLastFrame[i];
            }
            currentHandOpenCloseState /= fingerCurrentOpenClose.Length;
            deltaCurrentHandOpenClosedState /= fingerCurrentOpenClose.Length;



            float CalculatePoseMatch(float openStateDistance, float closeStateDistance) {
                float openWeight = 1f / (openStateDistance + 1f);
                float closeWeight = 1f / (closeStateDistance + 1f);
                float normalizedValue = closeWeight / (openWeight + closeWeight);

                return normalizedValue;
            }
        }


        void CalculateHeldPoseState() {
            var hand = handTracker.hand;

            var fingerCount = hand.fingers.Length;
            currentHeldOpenState = 0f;
            currentHeldCloseState = 0f;

            for(int i = 0; i < fingerCount; i++) {
                var finger = hand.fingers[i];
                var fingerIndex = (int)finger.fingerType;
                fingerHeldDifferences[fingerIndex] = handTracker.currentHandTrackingPose[fingerIndex].GetPoseDifferenceByAngle(ref grabPoseTarget[fingerIndex]);
                fingerCurrentHeldOpen[fingerIndex] = CalculatePoseMatch(fingerHeldDifferences[fingerIndex], fingerOpenDifferences[fingerIndex]);
                fingerCurrentHeldClose[fingerIndex] = CalculatePoseMatch(fingerHeldDifferences[fingerIndex], fingerCloseDifferences[fingerIndex]);
            }

            for(int i = 0; i < fingerCurrentOpenClose.Length; i++) {
                currentHeldOpenState += fingerCurrentHeldOpen[i];
                currentHeldCloseState += fingerCurrentHeldClose[i];
            }
            currentHeldOpenState /= fingerCurrentHeldOpen.Length;
            currentHeldCloseState /= fingerCurrentHeldClose.Length;

            float CalculatePoseMatch(float openStateDistance, float closeStateDistance) {
                float openWeight = 1f / (openStateDistance + 1f);
                float closeWeight = 1f / (closeStateDistance + 1f);
                float normalizedValue = closeWeight / (openWeight + closeWeight);

                return normalizedValue;
            }
        }


        public void CheckSqueezeState() {
            if(usePoseSqueezing) {
                var hand = handTracker.hand;
                float squeezeState = 0f;
                if(usingHeldPose) {
                    if(heldPoseAnimation != null) {

                        var fingerCount = hand.fingers.Length;
                        currentHeldAnimationFromToState = 0f;

                        for(int i = 0; i < fingerCount; i++) {
                            var finger = hand.fingers[i];
                            var fingerIndex = (int)finger.fingerType;
                            fingerHeldAnimationFromDifferences[fingerIndex] = handTracker.currentHandTrackingPose[fingerIndex].GetPoseDifferenceByAngle(ref heldPoseAnimation.fromPose.GetHandPoseData(hand).fingerPoses[fingerIndex]);
                            fingerHeldAnimationToDifferences[fingerIndex] = handTracker.currentHandTrackingPose[fingerIndex].GetPoseDifferenceByAngle(ref heldPoseAnimation.toPose.GetHandPoseData(hand).fingerPoses[fingerIndex]);
                            fingerCurrentHeldAnimationFromTo[fingerIndex] = CalculatePoseMatch(fingerHeldAnimationFromDifferences[fingerIndex], fingerHeldAnimationToDifferences[fingerIndex]);
                        }

                        int addCount = 0;
                        for(int i = 0; i < fingerCurrentHeldAnimationFromTo.Length; i++) {
                            //If the value is 0.5f it means the fingers on each pose are in the same position
                            //so the squeeze state shouldn't be checking these fingers for the final squeeze amount
                            if(fingerCurrentHeldAnimationFromTo[i] != 0.5f) {
                                currentHeldAnimationFromToState += fingerCurrentHeldAnimationFromTo[i];
                                addCount++;
                            }

                        }
                        currentHeldAnimationFromToState /= addCount;

                        float CalculatePoseMatch(float openStateDistance, float closeStateDistance) {
                            float openWeight = 1 / (openStateDistance + 1);
                            float closeWeight = 1 / (closeStateDistance + 1);
                            float normalizedValue = closeWeight / (openWeight + closeWeight);

                            return normalizedValue;
                        }

                        squeezeState = currentHeldAnimationFromToState * squeezePoseSensitvityMultiplier * 1.25f;
                        hand.SetGrip(squeezeState, squeezeState);

                    }
                    else {
                        squeezeState = Mathf.Clamp01(currentHeldCloseState) * squeezePoseSensitvityMultiplier;
                        hand.SetGrip(squeezeState, squeezeState);
                    }
                }
                else {
                    squeezeState = currentHandOpenCloseState * squeezePoseSensitvityMultiplier;
                    hand.SetGrip(squeezeState, squeezeState);
                }

                if(squeezeState >= 1f && !hand.squeezing)
                    hand.Squeeze();
                else if(squeezeState < 1f && hand.squeezing)
                    hand.Unsqueeze();
            }
        }




        public void CheckCurrentFingerTouch() {
            if(!(useFingerTouchGrabbing && useFingerTouchReleasing))
                return;

            var hand = handTracker.hand;

            var grabbingLayer = LayerMask.NameToLayer(Hand.grabbingLayerName);
            var grabbingMask = LayerMask.GetMask(Hand.grabbingLayerName);
            for (int i = 0; i < hand.highlighter.highlightColliderNonAllocCount; i++) {
                if(hand.highlighter.highlightCollidersNonAlloc[i] == null)
                    continue;
                var collider = hand.highlighter.highlightCollidersNonAlloc[i].gameObject;
                lastColliderLayer[i] = collider.layer;
                collider.layer = grabbingLayer;
            }

            foreach (var finger in hand.fingers) {
                int fingerIndex = (int)finger.fingerType;
                var fingerTip = finger.tip;
                for (int i = 0; i < hand.highlighter.highlightColliderNonAllocCount; i++) {
                    var resultCount = Physics.OverlapSphereNonAlloc(fingerTip.position, finger.tipRadius*fingerTipRadiusMultiplier, overlapSphereResults, grabbingMask);
                    if (resultCount > 0) {
                        //Checks all the overlaps until it finds a grabbable object
                        int index = -1;
                        do {
                            index++;
                            if(index >= resultCount) break;
                        }
                        while(!AutoHandExtensions.HasGrabbable(overlapSphereResults[index], out currentFingerTouch[fingerIndex]) || (currentFingerTouch[fingerIndex] == null || !(currentFingerTouch[fingerIndex] is Grabbable)));
                    }
                    else {
                        currentFingerTouch[fingerIndex] = null;
                    }
                }
            }

            for (int i = 0; i < hand.highlighter.highlightColliderNonAllocCount; i++) {
                if(hand.highlighter.highlightCollidersNonAlloc[i] == null)
                    continue;
                hand.highlighter.highlightCollidersNonAlloc[i].gameObject.layer = lastColliderLayer[i];
            }
        }



        public void CheckForValidGrab() {
            var hand = handTracker.hand;
            if(hand.holdingObj != null || hand.IsGrabbing() || deltaCurrentHandOpenClosedState < minDeltaPoseActivation || Time.time - releaseTime < releaseGrabDelay)
                return;

            if(useFingerTouchGrabbing && GetValidFingerGrabState(out var touchingGrabbable)) {
                if(touchingGrabbable.GetGrabPose(hand, out _)) {
                    hand.Grab(GrabType.InstantGrab);
                }
                else if(touchingGrabbable.CanGrab(hand)) {
                    hand.CreateGrabConnection(touchingGrabbable, true);
                }
            }
            else if(usePoseRelease && currentHandOpenCloseState > minPoseGrabCloseness && currentHandOpenCloseState < maxPoseGrabCloseness && deltaCurrentHandOpenClosedState > maxDeltaPoseActivation) {
                hand.Grab();
            }
        }




        public void CheckForValidRelease() {
            var hand = handTracker.hand;
            if(hand.holdingObj == null || hand.IsGrabbing() || Time.time - grabTime < releaseGrabDelay)
                return;

            if(useFingerTouchReleasing && allowHeldFingerMovement) { 
                if(usingHeldPose && !GetValidFingerPoseHoldState()) {
                    hand.Release();
                }
                else if(!usingHeldPose && !GetValidFingerGrabState(out _)) {
                    hand.Release();
                }
            }
            
            if(usePoseGrabbing && (currentHandOpenCloseState > minPoseReleaseOpenness && currentHandOpenCloseState < maxPoseReleaseOpenness && deltaCurrentHandOpenClosedState < -requiredDeltaPoseReleaseOpenness)) {
                hand.Release();
            }
        }


        bool GetValidFingerGrabState(out Grabbable currentTouchingGrabbable) {
            //Making sure that all the fingers are touching the same object
            Grabbable firstFound = null;
            if(handTracker.hand.holdingObj != null)
                firstFound = handTracker.hand.holdingObj;
            else {
                for(int i = 0; i < currentFingerTouch.Length; i++) {
                    if(currentFingerTouch[i] == null)
                        continue;
                    if(firstFound == null)
                        firstFound = currentFingerTouch[i];
                }
            }

            bool thumbTouching = currentFingerTouch[(int)FingerEnum.thumb] != null;
            bool indexTouching = currentFingerTouch[(int)FingerEnum.index] != null && currentFingerTouch[(int)FingerEnum.index] == firstFound;
            bool middleTouching = currentFingerTouch[(int)FingerEnum.middle] != null && currentFingerTouch[(int)FingerEnum.middle] == firstFound;
            bool ringTouching = currentFingerTouch[(int)FingerEnum.ring] != null && currentFingerTouch[(int)FingerEnum.ring] == firstFound;
            bool pinkyTouching = currentFingerTouch[(int)FingerEnum.pinky] != null && currentFingerTouch[(int)FingerEnum.pinky] == firstFound;

            bool[] fingerTouchs = new bool[5];
            fingerTouchs[(int)FingerEnum.thumb] = thumbTouching;
            fingerTouchs[(int)FingerEnum.index] = indexTouching;
            fingerTouchs[(int)FingerEnum.middle] = middleTouching;
            fingerTouchs[(int)FingerEnum.ring] = ringTouching;
            fingerTouchs[(int)FingerEnum.pinky] = pinkyTouching;

            bool[] validGrabs = {
                thumbTouching && (indexTouching || middleTouching || ringTouching || pinkyTouching),
                (indexTouching || pinkyTouching) && middleTouching && ringTouching,
                (indexTouching && middleTouching),
                (middleTouching && ringTouching),
            };

            //This is an advanced requirement for grabbing,
            //It didn't feel right to grab objects with an almost fully open hand without using a thumb,
            //but it should be possible to hold an object without using the thumb when the fingers are more bent
            //This is a requirement for how much the fingers should be closed when grabbing for each of the above conditions
            float[][] validGrabClosedFingerRequirements = new float[validGrabs.Length][];
            validGrabClosedFingerRequirements[0] = new float[5];
            validGrabClosedFingerRequirements[0][(int)FingerEnum.thumb] = 0.1f;
            validGrabClosedFingerRequirements[0][(int)FingerEnum.index] = 0.1f;
            validGrabClosedFingerRequirements[0][(int)FingerEnum.middle] = 0.1f;
            validGrabClosedFingerRequirements[0][(int)FingerEnum.ring] = 0.1f;
            validGrabClosedFingerRequirements[0][(int)FingerEnum.pinky] = 0.1f;

            validGrabClosedFingerRequirements[1] = new float[5];
            validGrabClosedFingerRequirements[1][(int)FingerEnum.index] = 0.15f;
            validGrabClosedFingerRequirements[1][(int)FingerEnum.middle] = 0.15f;
            validGrabClosedFingerRequirements[1][(int)FingerEnum.ring] = 0.15f;
            validGrabClosedFingerRequirements[1][(int)FingerEnum.pinky] = 0.15f;

            validGrabClosedFingerRequirements[2] = new float[5];
            validGrabClosedFingerRequirements[2][(int)FingerEnum.index] = 0.3f;
            validGrabClosedFingerRequirements[2][(int)FingerEnum.middle] = 0.3f;

            validGrabClosedFingerRequirements[3] = new float[5];
            validGrabClosedFingerRequirements[3][(int)FingerEnum.middle] = 0.3f;
            validGrabClosedFingerRequirements[3][(int)FingerEnum.ring] = 0.3f;

            //As a part of checking the previous validGrabClosedFingerRequirements we need to know which finger bend values matter
            int[][] fingerIndecies = new int[][] {
                new int[] { (int)FingerEnum.thumb, (int)FingerEnum.index, (int)FingerEnum.middle, (int)FingerEnum.ring, (int)FingerEnum.pinky },
                new int[] { (int)FingerEnum.index, (int)FingerEnum.middle, (int)FingerEnum.ring, (int)FingerEnum.pinky },
                new int[] { (int)FingerEnum.index, (int)FingerEnum.middle },
                new int[] { (int)FingerEnum.middle, (int)FingerEnum.ring },
            };

            bool validGrabFound = false;
            int resultIndex = -1;
            for(int i = 0; i < validGrabs.Length; i++) {
                //Checking if the fingers are touching the same object
                if(validGrabs[i]) {
                    validGrabFound = true;
                    //Checking if the fingers are bent enough to hold the object
                    for(int j = 0; j < fingerIndecies[i].Length; j++) {
                        int fingerIndex = fingerIndecies[i][j];
                        if(fingerTouchs[fingerIndex] && fingerCurrentOpenClose[fingerIndex] < validGrabClosedFingerRequirements[i][fingerIndex]) {
                            validGrabFound = false;
                            break;
                        }
                    }

                    if(validGrabFound) {
                        resultIndex = i;
                        break;
                    }
                }
            }

            if(resultIndex != -1)
                currentTouchingGrabbable = firstFound;
            else
                currentTouchingGrabbable = null;

            var validFingerState = validGrabFound && (currentTouchingGrabbable != null);

            return validFingerState;
        }


        bool[] fingerTouchs = new bool[5];
        bool GetValidFingerPoseHoldState() {

            bool thumbTouching = fingerCurrentHeldOpen[(int)FingerEnum.thumb] < (fingerCurrentHeldClose[(int)FingerEnum.thumb] + 0.025f);
            bool indexTouching = fingerCurrentHeldOpen[(int)FingerEnum.index] < (fingerCurrentHeldClose[(int)FingerEnum.index] + 0.025f);
            bool middleTouching = fingerCurrentHeldOpen[(int)FingerEnum.middle] < (fingerCurrentHeldClose[(int)FingerEnum.middle] + 0.025f);
            bool ringTouching = fingerCurrentHeldOpen[(int)FingerEnum.ring] < (fingerCurrentHeldClose[(int)FingerEnum.ring] + 0.025f);
            bool pinkyTouching = fingerCurrentHeldOpen[(int)FingerEnum.pinky] < (fingerCurrentHeldClose[(int)FingerEnum.pinky] + 0.025f);

            fingerTouchs[(int)FingerEnum.thumb] = thumbTouching;
            fingerTouchs[(int)FingerEnum.index] = indexTouching;
            fingerTouchs[(int)FingerEnum.middle] = middleTouching;
            fingerTouchs[(int)FingerEnum.ring] = ringTouching;
            fingerTouchs[(int)FingerEnum.pinky] = pinkyTouching;

            bool[] validGrabs = {
                thumbTouching && (indexTouching || middleTouching || ringTouching || pinkyTouching),
                (indexTouching || pinkyTouching) && middleTouching && ringTouching,
                (indexTouching && middleTouching),
                (middleTouching && ringTouching)
            };

            bool validGrabFound = false;
            for(int i = 0; i < validGrabs.Length; i++)
                if(validGrabs[i]) {
                    validGrabFound = true;
                    break;
                }

            return validGrabFound;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/Hand Tracking/OpenXRAutoHandTrackingGrabber.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/InputActionEnabler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2fdbfe0f72b1c19428bfe6794d5b84bb
# ASMDEF: Autohand.OpenXR.dll
# ---
using UnityEngine;
using UnityEngine.InputSystem;

public class InputActionEnabler : MonoBehaviour
{
    [SerializeField]
    InputActionAsset m_ActionAsset;
    public InputActionAsset actionAsset
    {
        get => m_ActionAsset;
        set => m_ActionAsset = value;
    }

    private void OnEnable()
    {
        if (m_ActionAsset != null)
        {
            m_ActionAsset.Enable();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/InputActionEnabler.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRAutoHandAxisFingerBender.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ae318a94acdfcfc48a42e1a95918afbb
# ASMDEF: Autohand.OpenXR.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

public class OpenXRAutoHandAxisFingerBender : MonoBehaviour{
    public Hand hand;
    public InputActionProperty bendAction;

    [HideInInspector]
    public float[] bendOffsets;
    float lastAxis;

    public void OnEnable() {
        if(bendAction.action != null) bendAction.action.Enable();
    }

    void LateUpdate()
    {
        var currAxis = bendAction.action.ReadValue<float>();
        for (int i = 0; i < bendOffsets.Length; i++)
        {
            hand.fingers[i].bendOffset += (currAxis - lastAxis) * bendOffsets[i];
        }
        lastAxis = currAxis;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRAutoHandAxisFingerBender.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRAutoHandFingerBender.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 390319e4c7788aa4b830a191e6251b9e
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

namespace Autohand.Demo{
    public class OpenXRAutoHandFingerBender : MonoBehaviour{
        public Hand hand;
        public InputActionProperty bendAction;
        public InputActionProperty unbendAction;
        
        [HideInInspector]
        public float[] bendOffsets;

        bool pressed;

        private void OnEnable() {
            if (bendAction.action != null) bendAction.action.Enable();
            if (bendAction.action != null) bendAction.action.performed += BendAction;
            if (unbendAction.action != null) unbendAction.action.Enable();
            if (unbendAction.action != null) unbendAction.action.performed += UnbendAction;
        }
        private void OnDisable(){
            if (bendAction.action != null) bendAction.action.performed -= BendAction;
            if (unbendAction.action != null) unbendAction.action.performed -= UnbendAction;
        }

        void BendAction(InputAction.CallbackContext a) {
            if (!pressed) {
                pressed = true;
                for(int i = 0; i < hand.fingers.Length; i++) {
                    hand.fingers[i].bendOffset += bendOffsets[i];
                }
            }
        }

        void UnbendAction(InputAction.CallbackContext a) {
            if (pressed) {
                pressed = false;
                for(int i = 0; i < hand.fingers.Length; i++) {
                    hand.fingers[i].bendOffset -= bendOffsets[i];
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRAutoHandFingerBender.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRControllerEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 077b3010e24b7254cb82521764590177
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using UnityEngine.InputSystem;
using UnityEngine.Events;


public class OpenXRControllerEvent : MonoBehaviour{
    public InputActionProperty action;
    public UnityEvent inputEvent;

    protected virtual void OnEnable(){
        action.action.Enable();
        action.action.performed += OnInputEvent;
    }

    protected virtual void OnDisable(){
        action.action.performed -= OnInputEvent;
    }

    protected virtual void OnInputEvent(InputAction.CallbackContext context) {
        inputEvent?.Invoke();
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRControllerEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRGrabbableInput.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 47d70464fd5da414db30a6f057338aa3
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    //Coupled with the OpenXRHeldGrabbableInput script
    public class OpenXRGrabbableInput : MonoBehaviour {
        Grabbable grabbable;
        public bool inputReleaseOnHandRelease = true;
        public int inputLayer = 0;
        public UnityHandGrabEvent inputPressed;
        public UnityHandGrabEvent inputReleased;

        public bool inputActive { get; set; }

        private void OnEnable() {
            grabbable = GetComponent<Grabbable>();
            grabbable.onRelease.AddListener(OnRelease);
        }

        private void OnDisable() {
            grabbable.onRelease.RemoveListener(OnRelease);
        }

        public void OnRelease(Hand hand, Grabbable grab) {
            if(inputReleaseOnHandRelease)
                ReleaseInput(hand);
        }

        public void PressInput(Hand hand) {
            if(!inputActive)
                inputPressed.Invoke(hand, grabbable);
            inputActive = true;
        }

        public void ReleaseInput(Hand hand) {
            if(inputActive)
                inputReleased.Invoke(hand, grabbable);
            inputActive = false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRGrabbableInput.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandControllerLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e0a0b8441c4cca543a7a89c0403302ee
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections.Generic;
using System.Data;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.XR;
using InputDevice = UnityEngine.XR.InputDevice;
//using UnityEngine.XR.OpenXR.Input;

namespace Autohand.Demo {
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/controller-input")]
    public class OpenXRHandControllerLink : HandControllerLink {
        public InputActionProperty grabAxis;
        public InputActionProperty squeezeAxis;
        public InputActionProperty grabAction;
        public InputActionProperty releaseAction;
        public InputActionProperty squeezeAction;
        public InputActionProperty stopSqueezeAction;
        public InputActionProperty hapticAction;

        XRNode role;
        InputDevice device;
        List<InputDevice> devices = new List<InputDevice>();

        private bool squeezing;
        private bool grabbing;
        private void Start() {
            if(hand.left)
                handLeft = this;
            else
                handRight = this;
        }
            

        public void OnEnable(){
            if (grabAction == squeezeAction){
                Debug.LogError("AUTOHAND: You are using the same button for grab and squeeze on HAND CONTROLLER LINK, this will create conflict or errors", this);
            }

            if(grabAxis.action != null) grabAxis.action.Enable();
            if(squeezeAxis.action != null) squeezeAxis.action.Enable();
            if(hapticAction.action != null) hapticAction.action.Enable();
            if(grabAction.action != null) grabAction.action.performed += Grab;
            if (grabAction.action != null) grabAction.action.Enable();
            if (grabAction.action != null) grabAction.action.performed += Grab;
            if (releaseAction.action != null) releaseAction.action.Enable();
            if (releaseAction.action != null) releaseAction.action.performed += Release;
            if (squeezeAction.action != null) squeezeAction.action.Enable();
            if (squeezeAction.action != null) squeezeAction.action.performed += Squeeze;
            if (stopSqueezeAction.action != null) stopSqueezeAction.action.Enable();
            if (stopSqueezeAction.action != null) stopSqueezeAction.action.performed += StopSqueeze;


            if(hand.left)
                role = XRNode.LeftHand;
            else
                role = XRNode.RightHand;

        }


        void OnDisable() {
            if(grabAction.action != null) grabAction.action.performed -= Grab;
            if(releaseAction.action != null) releaseAction.action.performed -= Release;
            if(squeezeAction.action != null) squeezeAction.action.performed -= Squeeze;
            if(stopSqueezeAction.action != null) stopSqueezeAction.action.performed -= StopSqueeze;

        }




        private void Update() {
            hand.SetGrip(grabAxis.action.ReadValue<float>(), squeezeAxis.action.ReadValue<float>());
        }

        private void Grab(InputAction.CallbackContext grab){
            if (!grabbing){
                hand.Grab();
                grabbing = true;
            }
        }
        
        private void Release(InputAction.CallbackContext grab){
            if (grabbing){
                hand.Release();
                grabbing = false;
            }
        }

        private void Squeeze(InputAction.CallbackContext grab){
            if (!squeezing){
                hand.Squeeze();
                squeezing = true;
            }
        }
        
        private void StopSqueeze(InputAction.CallbackContext grab){
            if (squeezing){
                hand.Unsqueeze();
                squeezing = false;
            }
        }

        public override void TryHapticImpulse(float duration, float amp, float freq = 10) {

            InputDevices.GetDevicesAtXRNode(role, devices);
            //OpenXRInput.SendHapticImpulse(hapticAction.action, amp, duration, hand.left ? UnityEngine.InputSystem.XR.XRController.leftHand : UnityEngine.InputSystem.XR.XRController.rightHand);
            foreach(var device in devices) {
                if(device.TryGetHapticCapabilities(out var capabilities) && capabilities.supportsImpulse) {
                    device.SendHapticImpulse(0u, amp, duration);
                }
            }

            base.TryHapticImpulse(duration, amp, freq);
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandControllerLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandPlayerControllerLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3c2299af165ef2148b128cb7c00383bf
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Autohand.Demo;
using UnityEngine.InputSystem;

namespace Autohand.Demo {
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/controller-input")]
    public class OpenXRHandPlayerControllerLink : MonoBehaviour{
        public AutoHandPlayer player;

        [Header("Input")]
        public InputActionProperty moveAxis;
        public InputActionProperty turnAxis;
        
        private void OnEnable() {
            if (moveAxis.action != null) moveAxis.action.Enable();
            if (moveAxis.action != null) moveAxis.action.performed += MoveAction;
            if (turnAxis.action != null) turnAxis.action.Enable();
            if (turnAxis.action != null) turnAxis.action.performed += TurnAction;
        }

        private void OnDisable() {
            if (moveAxis.action != null) moveAxis.action.performed -= MoveAction;
            if (turnAxis.action != null) turnAxis.action.performed -= TurnAction;
        }

        private void FixedUpdate() {
            player.Move(moveAxis.action.ReadValue<Vector2>());
            player.Turn(turnAxis.action.ReadValue<Vector2>().x);
        }

        private void Update(){
            player.Move(moveAxis.action.ReadValue<Vector2>());
            player.Turn(turnAxis.action.ReadValue<Vector2>().x);
        }

        void MoveAction(InputAction.CallbackContext a) {
            var axis = a.ReadValue<Vector2>();
            player.Move(axis);
        }

        void TurnAction(InputAction.CallbackContext a) {
            var axis = a.ReadValue<Vector2>();
            player.Turn(axis.x);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandPlayerControllerLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandPointGrabLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 98115e9b7ea4ff3418caca71996011a4
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

namespace Autohand.Demo{
    public class OpenXRHandPointGrabLink : MonoBehaviour{
        public HandDistanceGrabber pointGrab;
        public InputActionProperty pointAction;
        public InputActionProperty stopPointAction;
        public InputActionProperty selectAction;
        public InputActionProperty stopSelectAction;

        void OnEnable(){
            if(pointAction.action != null) pointAction.action.Enable();
            if (pointAction.action != null) pointAction.action.performed += OnPoint;
            if (stopPointAction.action != null) stopPointAction.action.Enable();
            if (stopPointAction.action != null) stopPointAction.action.performed += OnStopPoint;

            if (selectAction.action != null) selectAction.action.Enable();
            if (selectAction.action != null) selectAction.action.performed += OnSelect;
            if (stopSelectAction.action != null) stopSelectAction.action.Enable();
            if (stopSelectAction.action != null) stopSelectAction.action.performed += OnDeselect;
        }
        
        private void OnDisable() {
            if (pointAction.action != null) pointAction.action.performed -= OnPoint;
            if (stopPointAction.action != null) stopPointAction.action.performed -= OnStopPoint;

            if (selectAction.action != null) selectAction.action.performed -= OnSelect;
            if (stopSelectAction.action != null) stopSelectAction.action.performed -= OnDeselect;
            
        }

        void OnPoint(InputAction.CallbackContext e) {
            pointGrab.StartPointing();
        }

        void OnStopPoint(InputAction.CallbackContext e) {
            pointGrab.StopPointing();
        }

        private void OnSelect(InputAction.CallbackContext e) {
            pointGrab.SelectTarget();
        }

        void OnDeselect(InputAction.CallbackContext e) {
            pointGrab.CancelSelect();
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHandPointGrabLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHeldGrabbableInput.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 49804ac981381904fb9e99d1c6798795
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

namespace Autohand {
    //Coupled with the OpenXRGrabbableInput script
    public class OpenXRHeldGrabbableInput : MonoBehaviour {
        public Hand hand;
        public InputActionProperty startAction;
        public InputActionProperty stopAction;
        [Tooltip("Must match the input layer of the GrabbableInput layer value")]
        public int inputLayer = 0;

        [Space]
        [Tooltip("If false, the events will only trigger if the hand is holding a grabbable with a GrabbableInput script of the same input layer")]
        public bool alwaysTriggerEvents = false;
        public UnityHandGrabEvent startInput;
        public UnityHandGrabEvent stopInput;

        public bool inputActive { get; set; }


        public void OnEnable() {
            if(hand == null && !gameObject.CanGetComponent(out hand))
                Debug.LogError("AUTOHAND: Hand not found on OpenXRHeldGrabbableInput", this);

            if(startAction.action != null) startAction.action.Enable();
            if(stopAction.action != null) stopAction.action.Enable();
            if(startAction.action != null) startAction.action.performed += StartInput;
            if(stopAction.action != null) stopAction.action.performed += StopInput;
        }


        private void OnDisable() {
            if(startAction.action != null) startAction.action.performed -= StartInput;
            if(stopAction.action != null) stopAction.action.performed -= StopInput;
        }


        private void StartInput(InputAction.CallbackContext grab) {
            if(!inputActive) {
                if(alwaysTriggerEvents)
                    startInput.Invoke(hand, hand.holdingObj);
                
                if(hand.holdingObj != null) {
                    if(hand.holdingObj.CanGetComponent<OpenXRGrabbableInput>(out var grabbableInput) && grabbableInput.inputLayer == inputLayer) {
                        grabbableInput.PressInput(hand);
                        if(!alwaysTriggerEvents)
                            startInput.Invoke(hand, hand.holdingObj);
                    }
                }


                inputActive = true;
            }
        }

        private void StopInput(InputAction.CallbackContext grab) {
            if(inputActive) {
                if(alwaysTriggerEvents)
                    stopInput.Invoke(hand, hand.holdingObj);

                if(hand.holdingObj != null) {
                    if(hand.holdingObj.CanGetComponent<OpenXRGrabbableInput>(out var grabbableInput) && grabbableInput.inputLayer == inputLayer) {
                        grabbableInput.ReleaseInput(hand);
                        if(!alwaysTriggerEvents)
                            stopInput.Invoke(hand, hand.holdingObj);
                    }
                }
                inputActive = false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRHeldGrabbableInput.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRMover.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dc47bd4a32ee65841818116665dacc30
# ASMDEF: Autohand.OpenXR.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

namespace Autohand.Demo
{
    public class OpenXRMover : MonoBehaviour
    {
        [Header("Input Actions")]
        public InputActionProperty moveAction;
        public InputActionProperty turnAction;

        [Header("Body")]
        public GameObject cam;
        private CharacterController controller;

        [Header("Settings")]
        public bool snapTurning;
        public float turnAngle;
        public float heightStep;
        public float minHeight, maxHeight;
        public float speed = 5;
        public float gravity = 1;

        private float currentGravity = 0;

        private bool turningReset = true, heightReset = true;

        private void Start(){
            controller = GetComponent<CharacterController>();
            gameObject.layer = LayerMask.NameToLayer("HandPlayer");

            moveAction.action.Enable();
            moveAction.action.performed += Move;
            turnAction.action.Enable();
            turnAction.action.performed += TurnAndHeight;
        }

        private void Move(InputAction.CallbackContext move){
            Vector3 headRotation = new Vector3(0, cam.transform.eulerAngles.y, 0);

            Vector2 moveAxis = move.ReadValue<Vector2>();

            if(Mathf.Abs(moveAxis.x) < 0.1f)
                moveAxis.x = 0;
            if(Mathf.Abs(moveAxis.y) < 0.1f)
                moveAxis.y = 0;

            Vector3 direction = new Vector3(moveAxis.x, 0, moveAxis.y);

            direction = Quaternion.Euler(headRotation) * direction;

            if (controller.isGrounded)
                currentGravity = 0;
            else
                currentGravity = Physics.gravity.y * gravity;

            controller.Move(new Vector3(direction.x * speed, currentGravity, direction.z * speed) * Time.deltaTime);
        }


        private void TurnAndHeight(InputAction.CallbackContext turn){
            Vector2 turningAxis = turn.ReadValue<Vector2>();

            //Snap turning
            if (snapTurning){
                if (turningAxis.x > 0.7f && turningReset){
                    transform.rotation *= Quaternion.Euler(0, turnAngle, 0);
                    turningReset = false;
                }
                else if (turningAxis.x < -0.7f && turningReset){
                    transform.rotation *= Quaternion.Euler(0, -turnAngle, 0);
                    turningReset = false;
                }
                else if (turningAxis.y > 0.7f && heightReset){
                    if (transform.position.y >= maxHeight){
                        transform.position = new Vector3(transform.position.x, maxHeight, transform.position.z);
                        SetControllerHeight(maxHeight);
                    }
                    else{
                        transform.position += new Vector3(0, heightStep, 0);
                        AddControllerHeight(heightStep);
                    }

                    heightReset = false;
                }
                else if (turningAxis.y < -0.7f && heightReset){
                    if (transform.position.y <= minHeight){
                        SetControllerHeight(maxHeight);
                        transform.position = new Vector3(transform.position.x, minHeight, transform.position.z);
                    }
                    else{
                        AddControllerHeight(-heightStep);
                        transform.position += new Vector3(0, -heightStep, 0);
                    }

                    heightReset = false;
                }

                if (Mathf.Abs(turningAxis.x) < 0.4f)
                    turningReset = true;
                if (Mathf.Abs(turningAxis.y) < 0.4f)
                    heightReset = true;
            }

            //Smooth turning
            else{
                transform.rotation *= Quaternion.Euler(0, Time.deltaTime * turnAngle * turningAxis.x, 0);
                transform.position += new Vector3(0, Time.deltaTime * heightStep * turningAxis.y, 0);

                AddControllerHeight(Time.deltaTime * heightStep * turningAxis.y);

                if (transform.position.y <= minHeight)
                    transform.position = new Vector3(transform.position.x, minHeight, transform.position.z);
                else if (transform.position.y >= maxHeight)
                    transform.position = new Vector3(transform.position.x, maxHeight, transform.position.z);
            }
        }

        private void AddControllerHeight(float height){
            controller.height += height;
            controller.center = new Vector3(0, controller.height / 2f, 0);
        }

        private void SetControllerHeight(float height){
            controller.height = height;
            controller.center = new Vector3(0, height / 2f, 0);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRMover.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRTeleporterLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3e61a6c754b32184fa0fac4b86d9ff14
# ASMDEF: Autohand.OpenXR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.XR;

namespace Autohand.Demo{
    public class OpenXRTeleporterLink : MonoBehaviour{
        public Teleporter hand;
        public InputActionProperty startTeleportAction;
        public InputActionProperty finishTeleportAction;
        
        bool teleporting = false;

        void OnEnable() {
            if(startTeleportAction.action != null) startTeleportAction.action.Enable();
            if (startTeleportAction.action != null) startTeleportAction.action.performed += StartTeleportAction;
            if (finishTeleportAction.action != null) finishTeleportAction.action.Enable();
            if (finishTeleportAction.action != null) finishTeleportAction.action.performed += FinishTeleportAction;
        }

        void OnDisable() { 
            if (startTeleportAction.action != null) startTeleportAction.action.performed -= StartTeleportAction;
            if (finishTeleportAction.action != null) finishTeleportAction.action.performed -= FinishTeleportAction;
        }


        void StartTeleportAction(InputAction.CallbackContext a) {
            if(!teleporting){
                hand.StartTeleport();
                teleporting = true;
            }
        }

        void FinishTeleportAction(InputAction.CallbackContext a) {
            if(teleporting){
                hand.Teleport();
                teleporting = false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/OpenXRTeleporterLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/XRProviderPicker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: be0d1b15235da3647ae676669899705c
# ASMDEF: Autohand.OpenXR.dll
# ---
using UnityEngine;
using UnityEngine.XR.Management;

[DefaultExecutionOrder(-10000)]
public class XRProviderPicker : MonoBehaviour
{
    //This will disable this script unless the given loader name matches the loader
    //(XRGeneralSettings.Instance.Manager.activeLoaders) in the XR Plugin Management window.
    //This is because different providers give different tracked positions.
    //Shouldn't matter for distribution of build, but does matter for distribution of this asset
    public string providerName = "";
    public XRHandOffset enableMe;
    public XRHandOffset disableMe;

    bool hasProvider = false;

    // Start is called before the first frame update
    void OnEnable() {
        var loaders = XRGeneralSettings.Instance.Manager.activeLoaders;
        foreach(var loader in loaders) {
            Debug.Log(loader.name);
            if(providerName == "" || providerName == loader.name)
                hasProvider = true;
        }

        if (hasProvider)
        { 
           // enableMe.AdjustPositions(disableMe);
            enableMe.enabled = true;
            disableMe.enabled = false;
        }
        else
        {

            disableMe.AdjustPositions(enableMe);
            enableMe.enabled = false;
            disableMe.enabled = true;
        }
    }


}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/OpenXR/Scripts/XRProviderPicker.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRAutoHandAxisFingerBender.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 855e1c3bb96607b46842d2505034e037
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class XRAutoHandAxisFingerBender : MonoBehaviour{
        public XRHandControllerLink controller;
        public CommonAxis axis;
        
        [HideInInspector]
        public float[] bendOffsets;
        float lastAxis;

        void LateUpdate(){
            var currAxis = controller.GetAxis(axis);
            for(int i = 0; i < controller.hand.fingers.Length; i++) {
                controller.hand.fingers[i].bendOffset += (currAxis-lastAxis)*bendOffsets[i];
            }
            lastAxis = currAxis;
        }
        
        
        private void OnDrawGizmosSelected() {
            if(controller == null && GetComponent<XRHandControllerLink>()){
                controller = GetComponent<XRHandControllerLink>();
                bendOffsets = new float[controller.hand.fingers.Length];
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRAutoHandAxisFingerBender.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRAutoHandFingerBender.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 782cb9720318e0c4ab7353bfc2181ad6
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class XRAutoHandFingerBender : MonoBehaviour{
        public XRHandControllerLink controller;
        public CommonButton button;
        
        [HideInInspector]
        public float[] bendOffsets;

        bool pressed;
        
        void Update(){
            if(!pressed && controller.ButtonPressed(button)) {
                pressed = true;
                for(int i = 0; i < controller.hand.fingers.Length; i++) {
                    controller.hand.fingers[i].bendOffset += bendOffsets[i];
                }
            }
            else if(pressed && !controller.ButtonPressed(button)) {
                pressed = false;
                for(int i = 0; i < controller.hand.fingers.Length; i++) {
                    controller.hand.fingers[i].bendOffset -= bendOffsets[i];
                }
            }
        }


        private void OnDrawGizmosSelected() {
            if(controller == null && GetComponent<XRHandControllerLink>()){
                controller = GetComponent<XRHandControllerLink>();
                bendOffsets = new float[controller.hand.fingers.Length];
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRAutoHandFingerBender.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRControllerEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7fbab967b03b78f4093d38ef2637575f
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand.Demo {
    public class XRControllerEvent : MonoBehaviour
    {
        public XRHandControllerLink link;
        public CommonButton button;
        public UnityEvent Pressed;
        public UnityEvent Released;
        bool pressed = false;

        protected virtual void Start() {
            if (link == null) {
                link = GetComponentInParent<XRHandControllerLink>();
                if (link == null)
                    Debug.LogError("No XRHandControllerLink connected - input will not work", this);
            }
        }

        protected virtual void Update()
        {
            if (link == null)
                return;

            if (link.ButtonPressed(button) && !pressed)
            {
                Pressed?.Invoke();
                pressed = true;
            }
            else if (!link.ButtonPressed(button) && pressed)
            {
                Released?.Invoke();
                pressed = false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRControllerEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandControllerLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 245bee9b113e7144cb3549484bae2a0c
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;

namespace Autohand.Demo{
    public enum CommonButton {
        gripButton,
        menuButton,
        primaryButton,
        secondaryButton,
        triggerButton,
        primary2DAxisClick,
        primary2DAxisTouch,
#if UNITY_2019_2_OR_NEWER
        secondary2DAxisClick,
        secondary2DAxisTouch,
#endif
        primaryTouch,
        secondaryTouch,
        none
    }
    
    public enum CommonAxis {
        trigger,
        grip,
        none
    }

    public enum Common2DAxis {
        primaryAxis,
        secondaryAxis,
        none
    }

    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/controller-input")]
    public class XRHandControllerLink : HandControllerLink {
        public CommonButton grabButton = CommonButton.triggerButton;
        [Tooltip("This axis will bend all the fingers on the hand -> replaced with finger bender scripts")]
        public CommonAxis grabAxis = CommonAxis.trigger;
        public CommonAxis squeezeAxis = CommonAxis.grip;
        public CommonButton squeezeButton = CommonButton.gripButton;

        bool squeezing;
        bool grabbing;

        XRNode role;
        InputDevice device;
        List<InputDevice> devices = new List<InputDevice>();

        private void Start(){
            if(grabButton == squeezeButton) {
                Debug.LogError("AUTOHAND: You are using the same button for grab and squeeze on HAND CONTROLLER LINK, this may create conflict or errors", this);
            }

            if(hand.left)
                role = XRNode.LeftHand;
            else
                role = XRNode.RightHand;

            if(hand.left)
                handLeft = this;
            else
                handRight = this;
        }

        void Update(){

            InputDevices.GetDevicesAtXRNode(role, devices);
            if(devices.Count > 0)
                device = devices[0];

            if(device != null && device.isValid){
                //Sets hand fingers wrap
                hand.SetGrip(GetAxis(grabAxis), GetAxis(squeezeAxis));

                //Grab input
                if(device.TryGetFeatureValue(GetCommonButton(grabButton), out bool grip)) {
                    if(grabbing && !grip){
                        hand.Release();
                        grabbing = false;
                    }
                    else if(!grabbing && grip){
                        hand.Grab();
                        grabbing = true;
                    }
                }
                //Squeeze input
                if(device.TryGetFeatureValue(GetCommonButton(squeezeButton), out bool squeeze)) {
                    if(squeezing && !squeeze){
                        hand.Unsqueeze();
                        squeezing = false;
                    }
                    else if(!squeezing && squeeze){
                        hand.Squeeze();
                        squeezing = true;
                    }
                }
            }
        }

        public List<InputDevice> Devices() { return devices; }


        public bool ButtonPressed(CommonButton button) {
            if (button == CommonButton.none)
                return false;

            if(device.TryGetFeatureValue(GetCommonButton(button), out bool pressed)) {
                return pressed;
            }

            return false;
        }


        public float GetAxis(CommonAxis axis){
            if (axis == CommonAxis.none)
                return 0;

            if(device.TryGetFeatureValue(GetCommonAxis(axis), out float axisValue)) {
                return axisValue;
            }
            return 0;
        }


        public Vector2 GetAxis2D(Common2DAxis axis) {
            if (axis == Common2DAxis.none)
                return Vector2.zero;

            if(device.TryGetFeatureValue(GetCommon2DAxis(axis), out Vector2 axisValue)) {
                return axisValue;
            }
            return Vector2.zero;
        }

        /// <param name="freq">not supported on XR?</param>
        public override void TryHapticImpulse(float duration, float amp, float freq = 0) {
            foreach(var device in Devices()) {
                if(device.TryGetHapticCapabilities(out var capabilities) && capabilities.supportsImpulse) {
                    device.SendHapticImpulse(0u, amp, duration);
                }
            }
        }


        public static InputFeatureUsage<bool> GetCommonButton(CommonButton button) {
            if(button == CommonButton.gripButton)
                return CommonUsages.gripButton;
            if(button == CommonButton.menuButton)
                return CommonUsages.menuButton;
            if(button == CommonButton.primary2DAxisClick)
                return CommonUsages.primary2DAxisClick;
            if(button == CommonButton.primary2DAxisTouch)
                return CommonUsages.primary2DAxisTouch;
            if(button == CommonButton.primaryButton)
                return CommonUsages.primaryButton;
            if(button == CommonButton.primaryTouch)
                return CommonUsages.primaryTouch;
#if UNITY_2019_2_OR_NEWER
            if (button == CommonButton.secondary2DAxisClick)
                return CommonUsages.secondary2DAxisClick;
            if(button == CommonButton.secondary2DAxisTouch)
                return CommonUsages.secondary2DAxisTouch;
#endif
            if(button == CommonButton.secondaryButton)
                return CommonUsages.secondaryButton;
            if(button == CommonButton.secondaryTouch)
                return CommonUsages.secondaryTouch;
            
            return CommonUsages.triggerButton;
        }

        public static InputFeatureUsage<float> GetCommonAxis(CommonAxis axis) {
            if(axis == CommonAxis.grip)
                return CommonUsages.grip;
            else
                return CommonUsages.trigger;
        }

        public static InputFeatureUsage<Vector2> GetCommon2DAxis(Common2DAxis axis) {
            if(axis == Common2DAxis.primaryAxis)
                return CommonUsages.primary2DAxis;
            else
                return CommonUsages.secondary2DAxis;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandControllerLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandOffset.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b661ef26e3b3e0c4ba5d9ecd8097bf6b
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;

[System.Serializable]
public struct DeviceData{
    public string[] deviceNames;
    public Vector3 position;
    public Vector3 rotation;

    public DeviceData(string name, Vector3 pos, Vector3 rot)
    {
        deviceNames = new string[] { name };
        position = pos;
        rotation = rot;
    }
    public DeviceData(string[] names, Vector3 pos, Vector3 rot)
    {
        deviceNames = names;
        position = pos;
        rotation = rot;
    }
};


public class XRHandOffset : MonoBehaviour {
    [Tooltip("DO NOT CHANGE THIS UNLESS YOU ARE REDOING THE RELATIVE POSITIONS. This is the device that you are using to setup the innital proper orientation of the hand, all offsets are relative to this device")]
    public string defaultDevice = "Oculus";


    [SerializeField]
    public Transform[] rightOffsets, leftOffsets;

    [SerializeField]
    public DeviceData[] devices = new DeviceData[] {
        new DeviceData("Oculus", new Vector3(0.005f, -0.016f, 0.014f), new Vector3(48, 0, 15)),
        new DeviceData("Windows MR", new Vector3(0.003f, -0.005f, -0.078f), new Vector3(36, -12, 2)),
        new DeviceData(new string[]{"Vive", "HTC", "Index", "Cosmos", "Elite" }, new Vector3(0.015f, 0, 0.0412f), new Vector3(30, -17, 0))
    };

    bool offsetDone = false;
    bool hasProvider = false;
    AutoHandSettings settings;

    void OnEnable(){
        settings = Resources.Load<AutoHandSettings>("AutoHandSettings");
        if(!settings.useAutomaticControllerOffset)
            return;

        InputDevices.deviceConnected += DeviceConnected;
        List<InputDevice> devices = new List<InputDevice>();
        InputDevices.GetDevices(devices);

        foreach(var device in devices) {
            DeviceConnected(device);
        }
    }

    void OnDisable() {
        if(hasProvider) {
            InputDevices.deviceConnected -= DeviceConnected;
        }
    }


    public void AdjustPositions(XRHandOffset otherOffset) {
        var defaultPos = GetDefaultPositionOffset() - otherOffset.GetDefaultPositionOffset();
        var defaultRot = GetDefaultRotationOffset() - otherOffset.GetDefaultRotationOffset();

        foreach(var leftOffset in leftOffsets) {
            leftOffset.localPosition += new Vector3(-defaultPos.x, defaultPos.y, defaultPos.z);
            leftOffset.localEulerAngles += new Vector3(defaultRot.x, -defaultRot.y, -defaultRot.z);
        }

        foreach(var rightOffset in rightOffsets) {
            rightOffset.localPosition += defaultPos;
            rightOffset.localEulerAngles += defaultRot;
        }
    }

    void DeviceConnected(InputDevice inputDevice) {
        if (inputDevice.characteristics != 0){
            foreach (var device in devices){
                if (offsetDone)
                    break;

                for (int i = 0; i < device.deviceNames.Length; i++){
                    Debug.Log(inputDevice.name, this);
                    if (inputDevice.name.Contains(device.deviceNames[i])){
                        var offsetPos = GetPositionOffset(defaultDevice, device.deviceNames[i]);
                        var offsetRot = GetRotationOffset(defaultDevice, device.deviceNames[i]);

                        foreach (var leftOffset in leftOffsets){
                            leftOffset.localPosition += new Vector3(-offsetPos.x, offsetPos.y, offsetPos.z);
                            leftOffset.localEulerAngles += new Vector3(offsetRot.x, -offsetRot.y, -offsetRot.z);
                        }

                        foreach (var rightOffset in rightOffsets){
                            rightOffset.localPosition += offsetPos;
                            rightOffset.localEulerAngles += offsetRot;
                        }

                        OnDisable();

                        offsetDone = true;
                        break;
                    }
                }
            }
        }
    }


    Vector3 GetPositionOffset(string from, string to) {
        if(from == to)
            return Vector3.zero;

        Vector3 fromPos, toPos = fromPos = Vector3.zero;
        foreach(var device in devices) {
            foreach(var deviceName in device.deviceNames) {
                if(deviceName == from)
                    fromPos = device.position;
                if(deviceName == to)
                    toPos = device.position;
            }
        }

        return (toPos - fromPos);
    }


    Vector3 GetRotationOffset(string from, string to) {
        if(from == to)
            return Vector3.zero;

        Vector3 fromPos, toPos = fromPos = Vector3.zero;
        foreach(var device in devices) {
            foreach(var deviceName in device.deviceNames) {
                if(deviceName == from)
                    fromPos = device.rotation;
                if(deviceName == to)
                    toPos = device.rotation;
            }
        }

        return (toPos - fromPos);
    }

    protected Vector3 GetDefaultPositionOffset() {

        Vector3 fromPos = Vector3.zero;
        foreach(var device in devices) {
            foreach(var deviceName in device.deviceNames) {
                if(deviceName == defaultDevice)
                    fromPos = device.position;
            }
        }

        return fromPos;
    }


    protected Vector3 GetDefaultRotationOffset() {
        Vector3 fromPos = Vector3.zero;
        foreach(var device in devices) {
            foreach(var deviceName in device.deviceNames) {
                if(deviceName == defaultDevice)
                    fromPos = device.rotation;
            }
        }

        return fromPos;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandOffset.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandPlayerControllerLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 09b6737f8be736a4ea7bb40614525174
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {

    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/controller-input")]
    public class XRHandPlayerControllerLink : MonoBehaviour{
        public XRHandControllerLink moveController;
        public XRHandControllerLink turnController;
        public AutoHandPlayer player;

        [Header("Input")]
        public Common2DAxis moveAxis;
        public Common2DAxis turnAxis;

        
        void Update(){
            player.Move(moveController.GetAxis2D(moveAxis));
            player.Turn(turnController.GetAxis2D(turnAxis).x);
        }
        void FixedUpdate(){
            player.Move(moveController.GetAxis2D(moveAxis));
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandPlayerControllerLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandPointGrabLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 347efddb19627c941bbe201c025bc04e
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class XRHandPointGrabLink : MonoBehaviour{
        public HandDistanceGrabber pointGrab;
        public XRHandControllerLink link;

        [Header("Input")]
        public CommonButton pointInput;
        public CommonButton selectInput;

        bool pointing;
        bool selecting;

        private void Start() {
            if(link == null) {
                link = GetComponentInParent<XRHandControllerLink>();
                if(link == null)
                    Debug.LogError("No XRHandControllerLink connected - input will not work", this);
            }

            if(pointGrab == null) {
                pointGrab = GetComponentInParent<HandDistanceGrabber>();
                if(pointGrab == null)
                    Debug.LogError("No HandDistanceGrabber connected - input will not work", this);
            }
        }

        void Update(){
            if(link == null || pointGrab == null)
                return;

            if (link.ButtonPressed(pointInput) && !pointing) {
                pointing = true;
                pointGrab.StartPointing();
            }

            if (!link.ButtonPressed(pointInput) && pointing){
                pointing = false;
                pointGrab.StopPointing();
            }

            
            if (link.ButtonPressed(selectInput) && !selecting) {
                selecting = true;
                pointGrab.SelectTarget();
            }
            
            if (!link.ButtonPressed(selectInput) && selecting){
                selecting = false;
                pointGrab.CancelSelect();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHandPointGrabLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHeadTracking.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6d6e19972d8984547b7008d21841fe57
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;

namespace Autohand.Demo{
public class XRHeadTracking : MonoBehaviour{
#if UNITY_2020_3_OR_NEWER
        public TrackingOriginModeFlags mode = TrackingOriginModeFlags.TrackingReference;

    void Start(){
        List<XRInputSubsystem> subsystems = new List<XRInputSubsystem>();
        SubsystemManager.GetSubsystems(subsystems);
        for(int i = 0;  i < subsystems.Count; i++){
            subsystems[i].TrySetTrackingOriginMode(mode);
        }
    }
#endif
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRHeadTracking.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRMover.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2e91c98879de4e040b0906bfe19ef7c5
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Autohand.Demo;

namespace Autohand{
    //THIS SCRIPT IS A TEMPORARY DEMO SCRIPT
    //BETTER MOVEMENT OPTIONS COMING SOON
    public class XRMover : MonoBehaviour{
        [Header("TEMP DEMO SCRIPT - Advanced script coming soon")]
        [Header("Controllers")]
        public XRHandControllerLink moverController;
        public XRHandControllerLink turningController;
        public Common2DAxis moverAxis;

        [Header("Body")]
        public GameObject cam;
        private CharacterController controller;
        private CapsuleCollider collisionCapsule;

        [Header("Settings")]
        public bool snapTurning;
        public float turnAngle;
        public float speed = 5;
        public float gravity = 1;

        private float currentGravity = 0;

        private bool axisReset = true;

        Vector3 moveAxis;
        Vector2 turningAxis;

        //Driver
        public void LateUpdate(){
            turningAxis = turningController.GetAxis2D(moverAxis);
            moveAxis = moverController.GetAxis2D(moverAxis);

            Move(moveAxis.x, moveAxis.z, moveAxis.y);
            Turning();
        }


        private void Awake(){
            gameObject.layer = LayerMask.NameToLayer("HandPlayer");
            controller = GetComponent<CharacterController>();
        }


        public void Move(float x, float y, float z){

            Vector3 direction = new Vector3(x, y, z);
            Vector3 headRotation = new Vector3(0, cam.transform.eulerAngles.y, 0);

            direction = Quaternion.Euler(headRotation) * direction;

            currentGravity = Physics.gravity.y * gravity;

            if (controller.isGrounded)
                currentGravity = 0;

            controller.Move(new Vector3(direction.x * speed, direction.y * speed + currentGravity, direction.z * speed) * Time.deltaTime);
        }


        void Turning(){
            //Snap turning
            if (snapTurning){
                if (turningAxis.x > 0.7f && axisReset){
                    transform.rotation *= Quaternion.Euler(0, turnAngle, 0);
                    axisReset = false;
                }
                else if (turningAxis.x < -0.7f && axisReset){
                    transform.rotation *= Quaternion.Euler(0, -turnAngle, 0);
                    axisReset = false;
                }

                if (Mathf.Abs(turningAxis.x) < 0.4f)
                    axisReset = true;
            }

            //Smooth turning
            else{
                transform.rotation *= Quaternion.Euler(0, Time.deltaTime * turnAngle * turningAxis.x, 0);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRMover.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRTeleporterLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c3bafe5313773b549b22ed738a6223b2
# ASMDEF: Autohand.XR.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;

namespace Autohand.Demo{
    public class XRTeleporterLink : MonoBehaviour{
        public Teleporter hand;
        public XRNode role;
        public CommonButton button;
        
        bool teleporting = false;
        InputDevice device;
        List<InputDevice> devices;

        void Start(){
            devices = new List<InputDevice>();
        }

        void FixedUpdate(){
            InputDevices.GetDevicesAtXRNode(role, devices);
            if(devices.Count > 0)
                device = devices[0];

            if(device != null && device.isValid){
                //Sets hand fingers wrap
                if(device.TryGetFeatureValue(XRHandControllerLink.GetCommonButton(button), out bool teleportButton)) {
                    if(teleporting && !teleportButton){
                        hand.Teleport();
                        teleporting = false;
                    }
                    else if(!teleporting && teleportButton){
                        hand.StartTeleport();
                        teleporting = true;
                    }
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Examples/Scenes/XR/Scripts/XRTeleporterLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/InteractionAnimation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f927734ec0a8dac44aae9f4e7ec65bba
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand {

    [System.Serializable]
    public struct AnimationTarget {
        public MeshRenderer renderer;
        public SpriteRenderer spriteRenderer;

        public bool ignoreColor;
        public bool ignorePosition;
        public bool ignoreScale;
        public bool ignoreRotation;

        public float colorDampener;
        public float positionDampener;
        public float scaleDampener;
        public float rotationDampener;
        public float waveOffset;

        private Vector3 startPosition;
        private Vector3 startRotation;
        private Vector3 startScale;
        [HideInInspector]
        public Transform transform;

        public Vector3 StartPosition => startPosition;
        public Vector3 StartRotation => startRotation;
        public Vector3 StartScale => startScale;

        public void SetStartValues() {
            if(renderer != null) {
                startPosition = renderer.transform.localPosition;
                startScale = renderer.transform.localScale;
                startRotation = renderer.transform.localEulerAngles;
                transform = renderer.transform;
            }
            else if(spriteRenderer != null) {
                startPosition = spriteRenderer.transform.localPosition;
                startScale = spriteRenderer.transform.localScale;
                startRotation = spriteRenderer.transform.localEulerAngles;
                transform = spriteRenderer.transform;
            }

        }

        public void SetColor(Color color) {
            if(renderer != null) {
                renderer.material.color = color;
            }
            else if(spriteRenderer != null) {
                spriteRenderer.color = color;
            }
        }
    }



    public class InteractionAnimations : MonoBehaviour {
        public AnimationTarget[] animationTargets;

        [Header("On Enable")]
        public bool onEnableTransition = false;
        public float onEnableTransitionTime = 0.15f;
        public AnimationCurve onEnableTransitionCurve = AnimationCurve.Linear(0, 0, 1, 1);

        [Header("Color")]
        public bool updateColor = true;
        public float highlightAnimationColorTime = 0.5f;
        public float unhighlightAnimationColorTime = 0.5f;
        public Color unhighlightColor = Color.grey;
        public Color highlightColor = Color.white;
        public Color activateColor = Color.white;
        public AnimationCurve highlightColorCurve = AnimationCurve.Linear(0, 0, 1, 1);
        public float colorWaveFrequency = 1;
        public float colorWaveAmplitude = 0f;
        public float colorWaveOffset = 0.5f;

        [Header("Position")]
        public bool updatePosition = true;
        public float highlightAnimationPositionTime = 0.5f;
        public float unhighlightAnimationPositionTime = 0.5f;
        public Vector3 highlightPosition;
        public Vector3 activatePosition;
        public AnimationCurve positionAnimationCurve = AnimationCurve.Linear(0, 0, 1, 1);
        public float positionWaveFrequency = 1;
        public float positionWaveAmplitude = 0f;
        public float positionWaveOffset = 0.5f;

        [Header("Scale")]
        public bool updateScale = true;
        public float highlightAnimationScaleTime = 0.5f;
        public float unhighlightAnimationScaleTime = 0.5f;
        public float highlightScaleOffset = 0.1f;
        public float activateScaleOffset = 0.1f;
        public AnimationCurve scaleAnimationCurve = AnimationCurve.Linear(0, 0, 1, 1);
        public float scaleWaveFrequency = 1;
        public float scaleWaveAmplitude = 0f;
        public float scaleWaveOffset = 0.5f;

        [Header("Rotation")]
        public bool updateRotation = true;
        public float highlightAnimationRotationTime = 0.5f;
        public float unhighlightAnimationRotationTime = 0.5f;
        public Vector3 highlightRotationOffset = Vector3.zero;
        public Vector3 activateRotationOffset = Vector3.zero;
        public AnimationCurve rotationAnimationCurve = AnimationCurve.Linear(0, 0, 1, 1);
        public float rotationWaveFrequency = 1;
        public float rotationWaveAmplitude = 0f;
        public float rotationWaveOffset = 0.5f;

        protected float enableState;

        protected bool highlighting;
        protected float highlightStartTime;
        protected float highlightStopTime;
        protected float highlightColorState;
        protected float highlightPositionState;
        protected float highlightRotationState;
        protected float highlightScaleState;

        protected bool activating;
        protected float activateStartTime;
        protected float activateStopTime;
        protected float activateColorState;
        protected float activatePositionState;
        protected float activateRotationState;
        protected float activateScaleState;

        Color currentHighlightColor;
        Color currentUnhighlightColor;
        Color currentActivateColor;

        bool finishedAnimation;
        bool useWave;
        bool startedValueSet = false;

        Coroutine enableAnimationRountine;

        protected virtual void OnEnable() {
            if(!startedValueSet) {
                for(int i = 0; i < animationTargets.Length; i++)
                    animationTargets[i].SetStartValues();
                startedValueSet = true;
            }

            useWave = colorWaveAmplitude > 0 || positionWaveAmplitude > 0 || scaleWaveAmplitude > 0 || rotationWaveAmplitude > 0;

            if(!onEnableTransition) {
                currentActivateColor = activateColor;
                currentHighlightColor = highlightColor;
                currentUnhighlightColor = unhighlightColor;
            }

            SetAnimation();
        }

        protected virtual void OnDisable() {
            enableState = 0;
            highlightColorState = 0;
            highlightPositionState = 0;
            highlightScaleState = 0;
            highlightRotationState = 0;
            activateColorState = 0;
            activatePositionState = 0;
            activateScaleState = 0;
            activateRotationState = 0;
            activateScaleState = 0;
            highlighting = false;
            activating = false;
            SetAnimation();
        }


        protected virtual void LateUpdate() {
            if(!enabled)
                return;

            UpdateAnimationState();

            if(!finishedAnimation)
                SetAnimation();

            finishedAnimation = !highlighting && !activating &&
                (highlightPositionState == 0) &&
                (highlightColorState == 0) &&
                (highlightRotationState == 0) &&
                (highlightScaleState == 0) &&
                (activatePositionState == 0) &&
                (activateColorState == 0) &&
                (activateRotationState == 0) &&
                (activateScaleState == 0);

            if(onEnableTransition)
                finishedAnimation = finishedAnimation && enableState == 1;
        }


        [ContextMenu("HIGHLIGHT")]
        public void Highlight() {
            highlighting = true;
            highlightStartTime = Time.time;
        }

        [ContextMenu("UNHIGHLIGHT")]
        public void Unhighlight() {
            highlighting = false;
            highlightStopTime = Time.time;
        }

        [ContextMenu("ACTIVATE")]
        public void Activate() {
            activating = true;
            activateStartTime = Time.time;
        }

        [ContextMenu("DEACTIVATE")]
        public void Deactivate() {
            activating = false;
            activateStopTime = Time.time;
        }


        protected virtual void UpdateAnimationState() {
            var deltaTime = Time.deltaTime;
            var time = Time.time;
            var offseTime = time - deltaTime;


            //ENABLED TRANSITION
            if(onEnableTransition && enableState < 1) {
                enableState += deltaTime / onEnableTransitionTime;
                enableState = Mathf.Clamp01(enableState);
            }

            if(updatePosition) {
                //UPDATE POSITON STATES
                if(highlighting && highlightStartTime + highlightAnimationPositionTime > offseTime) {
                    highlightPositionState += deltaTime / highlightAnimationPositionTime;
                    highlightPositionState = Mathf.Clamp01(highlightPositionState);
                }
                else if(!highlighting && highlightStopTime + unhighlightAnimationPositionTime > offseTime) {
                    highlightPositionState -= deltaTime / unhighlightAnimationPositionTime;
                    highlightPositionState = Mathf.Clamp01(highlightPositionState);
                }

                if(activating && activateStartTime + highlightAnimationPositionTime > offseTime) {
                    activatePositionState += deltaTime/ highlightAnimationPositionTime;
                    activatePositionState = Mathf.Clamp01(activatePositionState);
                }
                else if(!activating && activateStopTime + unhighlightAnimationPositionTime > offseTime) {
                    activatePositionState -= deltaTime / unhighlightAnimationPositionTime;
                    activatePositionState = Mathf.Clamp01(activatePositionState);
                }
            }

            //UPDATE COLOR STATES
            if(updateColor) {
                if(highlighting && highlightStartTime + highlightAnimationColorTime > offseTime) {
                    highlightColorState += deltaTime / highlightAnimationColorTime;
                    highlightColorState = Mathf.Clamp01(highlightColorState);
                }
                else if(!highlighting && highlightStopTime + unhighlightAnimationColorTime > offseTime) {
                    highlightColorState -= deltaTime / unhighlightAnimationColorTime;
                    highlightColorState = Mathf.Clamp01(highlightColorState);
                }

                if(activating && activateStartTime + highlightAnimationColorTime > offseTime) {
                    activateColorState += deltaTime / highlightAnimationColorTime;
                    activateColorState = Mathf.Clamp01(activateColorState);
                }
                else if(!activating && activateStopTime + unhighlightAnimationColorTime > offseTime) {
                    activateColorState -= deltaTime / unhighlightAnimationColorTime;
                    activateColorState = Mathf.Clamp01(activateColorState);
                }
            }


            //UPDATE SCALE STATES
            if(updateScale) {
                if(highlighting && highlightStartTime + highlightAnimationScaleTime > offseTime) {
                    highlightScaleState += deltaTime / highlightAnimationScaleTime;
                    highlightScaleState = Mathf.Clamp01(highlightScaleState);
                }
                else if(!highlighting && highlightStopTime + unhighlightAnimationScaleTime > offseTime) {
                    highlightScaleState -= deltaTime / unhighlightAnimationScaleTime;
                    highlightScaleState = Mathf.Clamp01(highlightScaleState);
                }

                if(activating && activateStartTime + highlightAnimationScaleTime > offseTime) {
                    activateScaleState += deltaTime / highlightAnimationScaleTime;
                    activateScaleState = Mathf.Clamp01(activateScaleState);
                }
                else if(!activating && activateStopTime + unhighlightAnimationScaleTime > offseTime) {
                    activateScaleState -= deltaTime / unhighlightAnimationScaleTime;
                    activateScaleState = Mathf.Clamp01(activateScaleState);
                }
            }


            //UPDATE ROTATION STATES
            if(updateRotation) {
                if(highlighting && highlightStartTime + highlightAnimationRotationTime > offseTime) {
                    highlightRotationState += deltaTime / highlightAnimationRotationTime;
                    highlightRotationState = Mathf.Clamp01(highlightRotationState);
                }
                else if(!highlighting && highlightStopTime + unhighlightAnimationRotationTime > offseTime) {
                    highlightRotationState -= deltaTime / unhighlightAnimationRotationTime;
                    highlightRotationState = Mathf.Clamp01(highlightRotationState);
                }

                if(activating && activateStartTime + highlightAnimationRotationTime > offseTime) {
                    activateRotationState += deltaTime / highlightAnimationRotationTime;
                    activateRotationState = Mathf.Clamp01(activateRotationState);
                }
                else if(!activating && activateStopTime + unhighlightAnimationRotationTime > offseTime) {
                    activateRotationState -= deltaTime / unhighlightAnimationRotationTime;
                    activateRotationState = Mathf.Clamp01(activateRotationState);
                }
            }
        }


        protected virtual void SetAnimation() {
            if(onEnableTransition) {
                var transparentUnhighlight = unhighlightColor;
                transparentUnhighlight.a = 0;
                var state = onEnableTransitionCurve.Evaluate(enableState);
                currentUnhighlightColor = Color.Lerp(transparentUnhighlight, unhighlightColor, state);

                var transparentHighlight = highlightColor;
                transparentHighlight.a = 0;
                currentHighlightColor = Color.Lerp(transparentHighlight, highlightColor, state);

                var transparentActivate = activateColor;
                transparentActivate.a = 0;
                currentActivateColor = Color.Lerp(transparentActivate, activateColor, state);
            }

            for(int i = 0; i < animationTargets.Length; i++) {
                var animationTarget = animationTargets[i];
                if(animationTarget.transform == null)
                    continue;

                var waveTime = Time.time - highlightStartTime;
                //var animationOffset = useWave && !animationTarget.ignoreWave ? ((Mathf.Sin(waveTime*Mathf.PI * waveFrequency + index*waveOffset*Mathf.PI)) + 1)/2f * waveAmplitude : 0;

                //UPDATE COLOR
                if(!animationTarget.ignoreColor) {
                    float waveOffset = 0;
                    if(!(colorWaveFrequency == 0) && !(colorWaveAmplitude == 0))
                        waveOffset = ((Mathf.Sin(waveTime*Mathf.PI * colorWaveFrequency + Mathf.PI*colorWaveOffset + animationTarget.waveOffset*Mathf.PI)) + 1)/2f * colorWaveAmplitude;

                    var targetColor = Color.Lerp(currentUnhighlightColor, currentHighlightColor, highlightColorCurve.Evaluate(highlightColorState * Mathf.Clamp01(1-animationTarget.colorDampener - waveOffset)));
                    targetColor = Color.Lerp(targetColor, currentActivateColor, highlightColorCurve.Evaluate(activateColorState * Mathf.Clamp01(1-animationTarget.colorDampener - waveOffset)));
                    animationTarget.SetColor(targetColor);
                }

                //UPDATE POSITIONS
                if(!animationTarget.ignorePosition) {
                    float waveOffset = 0;
                    if(!(positionWaveFrequency == 0) && !(positionWaveAmplitude == 0))
                        waveOffset = ((Mathf.Sin(waveTime*Mathf.PI * positionWaveFrequency + Mathf.PI*positionWaveOffset + animationTarget.waveOffset*Mathf.PI)) + 1)/2f * positionWaveAmplitude;

                    var targetPos = Vector3.Lerp(animationTarget.StartPosition, animationTarget.StartPosition + highlightPosition, positionAnimationCurve.Evaluate(highlightPositionState * Mathf.Clamp01(1 - animationTarget.positionDampener - waveOffset)));
                    targetPos = Vector3.Lerp(targetPos, activatePosition, positionAnimationCurve.Evaluate(activatePositionState* Mathf.Clamp01(1 - animationTarget.positionDampener - waveOffset)));
                    animationTarget.transform.localPosition = targetPos;
                }

                //UPDATE ROTATION
                if(!animationTarget.ignoreRotation) {
                    float waveOffset = 0;
                    if(!(rotationWaveFrequency == 0) && !(rotationWaveAmplitude == 0))
                        waveOffset = ((Mathf.Sin(waveTime*Mathf.PI * rotationWaveFrequency + Mathf.PI*rotationWaveOffset + animationTarget.waveOffset*Mathf.PI)) + 1)/2f * rotationWaveAmplitude;

                    var targetRotation = Vector3.Lerp(animationTarget.StartRotation, animationTarget.StartRotation + highlightRotationOffset, rotationAnimationCurve.Evaluate(highlightRotationState*Mathf.Clamp01(1-animationTarget.rotationDampener - waveOffset)));
                    targetRotation = Vector3.Lerp(targetRotation, activateRotationOffset, rotationAnimationCurve.Evaluate(activateRotationState * Mathf.Clamp01(1 - animationTarget.rotationDampener - waveOffset)));
                    animationTarget.transform.localEulerAngles =  targetRotation;
                }

                //UPDATE SCALE
                if(!animationTarget.ignoreScale) {
                    float waveOffset = 0;
                    if(!(scaleWaveFrequency == 0) && !(scaleWaveAmplitude == 0) && !activating)
                        waveOffset = ((Mathf.Sin(waveTime*Mathf.PI * scaleWaveFrequency + Mathf.PI*scaleWaveOffset + animationTarget.waveOffset*Mathf.PI)) + 1)/2f * scaleWaveAmplitude;

                    var targetScale = Vector3.Lerp(animationTarget.StartScale, animationTarget.StartScale * (1 + highlightScaleOffset), scaleAnimationCurve.Evaluate(highlightScaleState)*Mathf.Clamp01(1-animationTarget.scaleDampener - waveOffset));
                    targetScale = Vector3.Lerp(targetScale, animationTarget.StartScale * (1 + activateScaleOffset), scaleAnimationCurve.Evaluate(activateScaleState * Mathf.Clamp01(1 - animationTarget.scaleDampener - waveOffset)));
                    animationTarget.transform.localScale = targetScale;
                }
            }

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/InteractionAnimation.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/LineAnimation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0d0cb31f61727554fbdb16f3d7cb8aa8
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand
{
    public class LineAnimation : MonoBehaviour
    {
        public LineRenderer lineRenderer;
        public GameObject lineReticle;
        public float activateTime = 0.5f;
        public bool useColorCurve = true;
        public AnimationCurve colorCurve = AnimationCurve.Linear(0, 0, 1, 1);
        public AnimationCurve widthCurve = AnimationCurve.Linear(0, 0, 1, 1); 

        float startWidth;
        float currentWidth;
        bool activated;
        float state;
        bool wasLineEnabled;

        Vector3 startReticleScale;
        Vector3 lastPosition;


        GradientAlphaKey[] startAlphaKeys;
        Coroutine animationCoroutine;

        private void Start() {
            startWidth = lineRenderer.widthMultiplier;
            lineRenderer.widthMultiplier = 0;

            wasLineEnabled = lineRenderer.enabled;
            if(lineReticle != null) {
                startReticleScale = lineReticle.transform.localScale;
                lineReticle.transform.localScale = Vector3.zero;
            }
        }

        private void OnDisable() {
            if(animationCoroutine != null)
                StopCoroutine(animationCoroutine);
            animationCoroutine = null;
            state = 0;
        }

        private void LateUpdate() {
            if(!lineRenderer.enabled && wasLineEnabled) {
                lineRenderer.enabled = true;
                wasLineEnabled = false;
                Deactivate();
            }

            else if(lineRenderer.enabled && !wasLineEnabled && lineRenderer.positionCount > 0) {
                //Need to do additional check to see if the line has moved just in case someone enables the line while its being disabled
                if(animationCoroutine != null && lastPosition != lineRenderer.GetPosition(lineRenderer.positionCount-1)) {
                    StopCoroutine(animationCoroutine);
                    animationCoroutine = null;
                }

                if(animationCoroutine == null) {
                    //Initializing this here instead of start because it needs to fill when the line is enabled
                    if(state == 0 && startAlphaKeys == null) {
                        startAlphaKeys = new GradientAlphaKey[lineRenderer.colorGradient.alphaKeys.Length];
                        lineRenderer.colorGradient.alphaKeys.CopyTo(startAlphaKeys, 0);
                    }
                    wasLineEnabled = true;
                    Activate();

                }
            }
            if(lineRenderer.positionCount > 0)
                lastPosition = lineRenderer.GetPosition(lineRenderer.positionCount - 1);
            else
                lastPosition = Vector3.zero;
        }

        public void Activate() {
            activated = true;
            if(animationCoroutine == null)
                animationCoroutine = StartCoroutine(Animate());
        }

        public void Deactivate() {
            activated = false;
            if(animationCoroutine == null)
                animationCoroutine = StartCoroutine(Animate());
        }

         
        IEnumerator Animate() {
            while ((activated && state < 1) || (!activated && state > 0)) {
                state += Time.deltaTime / activateTime * (activated ? 1 : -1);
                state = Mathf.Clamp01(state);
                if(lineReticle != null)
                    lineReticle.transform.localScale = Vector3.Lerp(Vector3.zero, startReticleScale, state);
                lineRenderer.widthMultiplier = Mathf.Lerp(0, startWidth, state);

                if(useColorCurve)
                    for(int i = 0; i < startAlphaKeys.Length; i++) {
                        lineRenderer.colorGradient.alphaKeys[i] = new GradientAlphaKey(Mathf.Lerp(0, startAlphaKeys[i].alpha, colorCurve.Evaluate(state)), startAlphaKeys[i].time);
                    }
                yield return null;
            }

            lineRenderer.enabled = wasLineEnabled;
            animationCoroutine = null;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/LineAnimation.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/PlacePointAnimation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 313e47353b0f88446a5cd49c2c41577b
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class PlacePointAnimations : InteractionAnimations {
        [Header("Place Point")]
        public PlacePoint placePoint;

        protected override void OnEnable() {
            base.OnEnable();
            if(placePoint == null)
                placePoint = GetComponent<PlacePoint>();
            if(placePoint == null)
                placePoint = GetComponentInParent<PlacePoint>();

            placePoint.OnHighlight.AddListener(StartHighlight);
            placePoint.OnStopHighlight.AddListener(StopHighlight);
            placePoint.OnPlace.AddListener(OnPlace);
            placePoint.OnRemove.AddListener(OnRemove);
        }

        protected override void OnDisable() {
            base.OnDisable();
            placePoint.OnHighlight.RemoveListener(StartHighlight);
            placePoint.OnStopHighlight.RemoveListener(StopHighlight);
            placePoint.OnPlace.RemoveListener(OnPlace);
            placePoint.OnRemove.RemoveListener(OnRemove);
        }

        protected override void LateUpdate() {
            if(!placePoint.enabled)
                return;

            base.LateUpdate();
        }

        void StartHighlight(PlacePoint placePoint, Grabbable grabbable) {
            Highlight();
        }

        void StopHighlight(PlacePoint placePoint, Grabbable grabbable) {
            Unhighlight();
        }

        void OnPlace(PlacePoint placePoint, Grabbable grabbable) {
            Activate();
        }

        void OnRemove(PlacePoint placePoint, Grabbable grabbable) {
            Deactivate();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Animations/PlacePointAnimation.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoHeaderAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 349372eb6797f054f99d44a16f633eaf
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using UnityEngine;
using System.Reflection;
using System.IO;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Autohand {
    public class AutoHeaderAttribute : PropertyAttribute {
        public int count;
        public int depth;

        public string label;
        public string tooltip;
        public string toggleBool;

        public System.Type type;

        /// <summary>
        /// Add a header above a field
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoHeaderAttribute(string label, int count = default, int depth = default) {
            this.count = count;
            this.depth = depth;
            this.label = label;
        }

        /// <summary>
        /// Add a header above a field with a tooltip
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="tooltip">A note or instruction shown when hovering over the header</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoHeaderAttribute(string label, string tooltip, string toggleName, System.Type classType, int count = default, int depth = default) {
            this.count = count;
            this.depth = depth;
            this.label = label;
            this.tooltip = tooltip;
        }
    }


#if UNITY_EDITOR
    [CustomPropertyDrawer(typeof(AutoHeaderAttribute))]
    public class AutoHeaderDrawer : PropertyDrawer {
        const float padding = 2f;
        const float margin = -20f;

        static Texture autohandlogo = null;
        static Font _labelFont = null;
        static Font labelFont {
            get {
                if(_labelFont == null)
                    _labelFont = Resources.Load<Font>("Righteous-Big");
                return _labelFont;
            }
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {

            position.yMax += position.height;

            var attr = (attribute as AutoHeaderAttribute);

            var newRect = position;
            newRect.position = new Vector2(newRect.x+newRect.width-18, newRect.y);


            // draw header background and label
            var headerRect = new Rect(position.x + margin, position.y, (position.width - margin) + (padding * 2), position.height);
            EditorGUI.DrawRect(headerRect, Constants.BackgroundColor);

            var labelStyle = Constants.HeaderStyle;
            labelStyle.font = labelFont;

            if(autohandlogo == null) {
                var assets = AssetDatabase.FindAssets("AutohandLogo");
                if(assets.Length > 0)
                    autohandlogo = AssetDatabase.LoadAssetAtPath<Texture>(AssetDatabase.GUIDToAssetPath(assets[0]));
            }

            EditorGUI.LabelField(headerRect, new GUIContent(" " + attr.label, autohandlogo, attr.tooltip), labelStyle);


            EditorGUILayout.Space();
            EditorGUILayout.Space();
            position.y += 2f;
        }
    }


    public static class Constants{
        private static readonly Color[] _barColors = new Color[5] {
            new Color(0.3411765f, 0.6039216f, 0.7803922f),
            new Color(0.145098f, 0.6f, 0.509804f),
            new Color(0.9215686f, 0.6431373f, 0.282353f),
            new Color(0.8823529f, 0.3529412f, 0.4039216f),
            new Color(0.9529412f, 0.9294118f, 0.682353f)
        };

        public static Color ColorForDepth(int depth) => _barColors[depth % _barColors.Length];

        public static Color BackgroundColor { get; } = EditorGUIUtility.isProSkin ? new Color(0.18f, 0.18f, 0.18f, 0.75f) : new Color(0.7f, 0.7f, 0.7f, 0.75f);
        
        public static GUIStyle LabelStyle { get; } = new GUIStyle(GUI.skin.label){
            alignment = TextAnchor.MiddleLeft,
            fontSize = 15
        };
        public static GUIStyle HeaderStyle { get; } = new GUIStyle(GUI.skin.label){
            alignment = TextAnchor.MiddleCenter,
            fontSize = 26
        };
    }
#endif
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoHeaderAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoLineAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 00c5387a69321f84aa2e86947b613fa3
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using UnityEngine;
using System.Reflection;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Autohand {
    public class AutoLineAttribute : PropertyAttribute {
        public int count;
        public int depth;

        public string tooltip;
        public string toggleBool;

        public System.Type type;

        /// <summary>
        /// Add a header above a field
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoLineAttribute(int count = default, int depth = default) {
            this.count = count;
            this.depth = depth;
        }

        /// <summary>
        /// Add a header above a field with a tooltip
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="tooltip">A note or instruction shown when hovering over the header</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoLineAttribute(string tooltip, string toggleName, System.Type classType, int count = default, int depth = default) {
            this.count = count;
            this.depth = depth;
            this.tooltip = tooltip;
        }
    }
#if UNITY_EDITOR
    [CustomPropertyDrawer(typeof(AutoLineAttribute))]
    public class AutoLineDrawer : PropertyDrawer {
        const float padding = 2f;
        const float margin = -20f;

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {



            // draw header background and label
            var headerRect = new Rect(position.x + margin, position.y+ 4, (position.width - margin) + (padding * 2), position.height);
            EditorGUI.DrawRect(headerRect, Constants.BackgroundColor);


            EditorGUILayout.Space();
        }

    }

#endif
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoLineAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoSmallHeaderAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2b0e1b365abb96f448b7dff928408fee
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using UnityEngine;
using System.Reflection;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Autohand
{
    public class AutoSmallHeaderAttribute : PropertyAttribute
    {
        public int count;
        public int depth;

        public string label;
        public string tooltip;
        public string toggleBool;

        public System.Type type;

        /// <summary>
        /// Add a header above a field
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoSmallHeaderAttribute(string label, int count = default, int depth = default)
        {
            this.count = count;
            this.depth = depth;
            this.label = label;
        }

        /// <summary>
        /// Add a header above a field with a tooltip
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="tooltip">A note or instruction shown when hovering over the header</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoSmallHeaderAttribute(string label, string tooltip, string toggleName, System.Type classType, int count = default, int depth = default)
        {
            this.count = count;
            this.depth = depth;
            this.label = label;
            this.tooltip = tooltip;
        }
    }

#if UNITY_EDITOR
    [CustomPropertyDrawer(typeof(AutoSmallHeaderAttribute))]
    public class AutoSmallHeaderDrawer : PropertyDrawer
    {
        const float padding = 2f;
        const float margin = -20f;

        static Font _labelFont = null;
        static Font labelFont
        {
            get {
                if(_labelFont == null)
                    _labelFont = Resources.Load<Font>("Righteous-Regular");
                return _labelFont;
            }
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {

            EditorGUILayout.Space();
            position.y += 14f;
            position.yMax += position.height/1.8f;

            var attr = (attribute as AutoSmallHeaderAttribute);

            var newRect = position;
            newRect.position = new Vector2(newRect.x+newRect.width-18, newRect.y);
            

            // draw header background and label
            var headerRect = new Rect(position.x + margin, position.y, (position.width - margin) + (padding * 2), position.height);
            EditorGUI.DrawRect(headerRect, Constants.BackgroundColor);


            var labelStyle = Constants.LabelStyle;
            labelStyle.font = labelFont;


            EditorGUI.LabelField(headerRect, new GUIContent(" " + attr.label, attr.tooltip), labelStyle);


            //var oldColor = GUI.color;
            //GUI.color = property.boolValue ? new Color(0.7f, 1f, 0.7f) : new Color(1f, 0.7f, 0.7f);

            //property.boolValue = EditorGUI.Toggle(newRect, property.boolValue);

            //GUI.color = oldColor;

            EditorGUILayout.Space();
            EditorGUILayout.Space();
            EditorGUILayout.Space();
            position.y += 2f;
        }

    }

#endif
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoSmallHeaderAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoToggleHeaderAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 89744b25182d72744b87abdce43cd5d3
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using UnityEngine;
using System.Reflection;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Autohand
{
    public class AutoToggleHeaderAttribute : PropertyAttribute
    {
        public int count;
        public int depth;

        public string label;
        public string tooltip;
        public string toggleBool;

        public System.Type type;

        /// <summary>
        /// Add a header above a field
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoToggleHeaderAttribute(string label, int count = default, int depth = default)
        {
            this.count = count;
            this.depth = depth;
            this.label = label;
        }

        /// <summary>
        /// Add a header above a field with a tooltip
        /// </summary>
        /// <param name="label">A title for the header label</param>
        /// <param name="tooltip">A note or instruction shown when hovering over the header</param>
        /// <param name="count">the number of child elements under this header</param>
        /// <param name="depth">the depth of this header element in the inspector foldout</param>
        public AutoToggleHeaderAttribute(string label, string tooltip, string toggleName, System.Type classType, int count = default, int depth = default)
        {
            this.count = count;
            this.depth = depth;
            this.label = label;
            this.tooltip = tooltip;
        }
    }
#if UNITY_EDITOR
    [CustomPropertyDrawer(typeof(AutoToggleHeaderAttribute))]
    public class AutoToggleHeaderDrawer : PropertyDrawer
    {
        const float padding = 2f;
        const float margin = -20f;

        static Font _labelFont = null;
        static Font labelFont
        {
            get {
                if(_labelFont == null)
                    _labelFont = Resources.Load<Font>("Righteous-Regular");
                return _labelFont;
            }
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {

            EditorGUILayout.Space();
            position.y += 14f;
            position.yMax += position.height/1.8f;

            var attr = (attribute as AutoToggleHeaderAttribute);

            var newRect = position;
            newRect.position = new Vector2(newRect.x+newRect.width-18, newRect.y);
            

            // draw header background and label
            var headerRect = new Rect(position.x + margin, position.y, (position.width - margin) + (padding * 2), position.height);
            EditorGUI.DrawRect(headerRect, Constants.BackgroundColor);


            var oldColor1 = GUI.color;
            if (!property.boolValue)
            {
                var newColor = new Color(0.65f, 0.65f, 0.65f, 1f);
                newColor.a = 1;
                GUI.contentColor = newColor;
            }

            var labelStyle = Constants.LabelStyle;
            labelStyle.font = labelFont;


            EditorGUI.LabelField(headerRect, new GUIContent(" " + attr.label, attr.tooltip), labelStyle);

            GUI.contentColor = oldColor1;

            var oldColor = GUI.color;
            GUI.color = property.boolValue ? new Color(0.7f, 1f, 0.7f) : new Color(1f, 0.7f, 0.7f);

            property.boolValue = EditorGUI.Toggle(newRect, property.boolValue);

            GUI.color = oldColor;

            EditorGUILayout.Space();
            EditorGUILayout.Space();
            EditorGUILayout.Space();
            position.y += 2f;
        }

    }

#endif
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/AutoToggleHeaderAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/AllowNestingAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 95b49d3abe880c044adbe7faf6b7b4ec
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class AllowNestingAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/AllowNestingAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/AnimatorParamAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7373332cb77b42744a415d6b4add445d
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;
using UnityEngine;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class AnimatorParamAttribute : DrawerAttribute
	{
		public string AnimatorName { get; private set; }
		public AnimatorControllerParameterType? AnimatorParamType { get; private set; }

		public AnimatorParamAttribute(string animatorName)
		{
			AnimatorName = animatorName;
			AnimatorParamType = null;
		}

		public AnimatorParamAttribute(string animatorName, AnimatorControllerParameterType animatorParamType)
		{
			AnimatorName = animatorName;
			AnimatorParamType = animatorParamType;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/AnimatorParamAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/CurveRangeAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bbdf3fb8882c7514c9a01108122cda7e
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;
using UnityEngine;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class CurveRangeAttribute : DrawerAttribute
	{
		public Vector2 Min { get; private set; }
		public Vector2 Max { get; private set; }
		public EColor Color { get; private set; }

		public CurveRangeAttribute(Vector2 min, Vector2 max, EColor color = EColor.Clear)
		{
			Min = min;
			Max = max;
			Color = color;
		}

		public CurveRangeAttribute(EColor color)
			: this(Vector2.zero, Vector2.one, color)
		{
		}

		public CurveRangeAttribute(float minX, float minY, float maxX, float maxY, EColor color = EColor.Clear)
			: this(new Vector2(minX, minY), new Vector2(maxX, maxY), color)
		{
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/CurveRangeAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/DrawerAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9df37fdebccf65c4da5b0a14f6dad5f5
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using UnityEngine;

namespace NaughtyAttributes
{
	/// <summary>
	/// Base class for all drawer attributes
	/// </summary>
	public class DrawerAttribute : PropertyAttribute, INaughtyAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/DrawerAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/DropdownAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2cb864a1092cec04f8a4dbb556e8ed31
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System.Collections;
using System;
using System.Collections.Generic;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class DropdownAttribute : DrawerAttribute
	{
		public string ValuesName { get; private set; }

		public DropdownAttribute(string valuesName)
		{
			ValuesName = valuesName;
		}
	}

	public interface IDropdownList : IEnumerable<KeyValuePair<string, object>>
	{
	}

	public class DropdownList<T> : IDropdownList
	{
		private List<KeyValuePair<string, object>> _values;

		public DropdownList()
		{
			_values = new List<KeyValuePair<string, object>>();
		}

		public void Add(string displayName, T value)
		{
			_values.Add(new KeyValuePair<string, object>(displayName, value));
		}

		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			return _values.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public static explicit operator DropdownList<object>(DropdownList<T> target)
		{
			DropdownList<object> result = new DropdownList<object>();
			foreach (var kvp in target)
			{
				result.Add(kvp.Key, kvp.Value);
			}

			return result;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/DropdownAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/EnumFlagsAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e8b31eb6d7299e54d89dcabc4cad0e6a
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class EnumFlagsAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/EnumFlagsAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/Expandable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 60926d6ca7f9ced469e9248ff1192da6
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ExpandableAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/Expandable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/HorizontalLineAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 2fdd6f99acca2fd42a4f3162d585ce95
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = true)]
	public class HorizontalLineAttribute : DrawerAttribute
	{
		public const float DefaultHeight = 2.0f;
		public const EColor DefaultColor = EColor.Gray;

		public float Height { get; private set; }
		public EColor Color { get; private set; }

		public HorizontalLineAttribute(float height = DefaultHeight, EColor color = DefaultColor)
		{
			Height = height;
			Color = color;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/HorizontalLineAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/InfoBoxAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: afd1d6323740c734893fa8397c53113b
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public enum EInfoBoxType
	{
		Normal,
		Warning,
		Error
	}

	[AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = true)]
	public class InfoBoxAttribute : DrawerAttribute
	{
		public string Text { get; private set; }
		public EInfoBoxType Type { get; private set; }

		public InfoBoxAttribute(string text, EInfoBoxType type = EInfoBoxType.Normal)
		{
			Text = text;
			Type = type;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/InfoBoxAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/InputAxisAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 85033978c18810f46af271bbe94cf4aa
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class InputAxisAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/InputAxisAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/LayerAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 668d19ebe071176448d1af816a9a0ce0
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class LayerAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/LayerAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/MinMaxSliderAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4aaa73f574deaa54187cb54aae571b24
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class MinMaxSliderAttribute : DrawerAttribute
	{
		public float MinValue { get; private set; }
		public float MaxValue { get; private set; }

		public MinMaxSliderAttribute(float minValue, float maxValue)
		{
			MinValue = minValue;
			MaxValue = maxValue;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/MinMaxSliderAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ProgressBarAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e19e4db6f4d08f849aa8ea8155cd2760
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ProgressBarAttribute : DrawerAttribute
	{
		public string Name { get; private set; }
		public float MaxValue { get; set; }
		public string MaxValueName { get; private set; }
		public EColor Color { get; private set; }

		public ProgressBarAttribute(string name, float maxValue, EColor color = EColor.Blue)
		{
			Name = name;
			MaxValue = maxValue;
			Color = color;
		}

		public ProgressBarAttribute(string name, string maxValueName, EColor color = EColor.Blue)
		{
			Name = name;
			MaxValueName = maxValueName;
			Color = color;
		}

		public ProgressBarAttribute(float maxValue, EColor color = EColor.Blue)
			: this("", maxValue, color)
		{
		}

		public ProgressBarAttribute(string maxValueName, EColor color = EColor.Blue)
			: this("", maxValueName, color)
		{
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ProgressBarAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ResizableTextAreaAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 56d9a4b795ef4a94d86b94e55fb81240
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ResizableTextAreaAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ResizableTextAreaAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/SceneAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e054de18423364f4688b72a0f2a472b6
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class SceneAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/SceneAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ShowAssetPreviewAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4b7dd9b44abc0054cb5cd68d74be2c1a
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ShowAssetPreviewAttribute : DrawerAttribute
	{
		public const int DefaultWidth = 64;
		public const int DefaultHeight = 64;

		public int Width { get; private set; }
		public int Height { get; private set; }

		public ShowAssetPreviewAttribute(int width = DefaultWidth, int height = DefaultHeight)
		{
			Width = width;
			Height = height;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/ShowAssetPreviewAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/TagAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8903399bbd7c9d745a7b9188ab6c8320
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class TagAttribute : DrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes/TagAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ButtonAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e8fe363a25ec5e24a9dd510bb0b4a0d4
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public enum EButtonEnableMode
	{
		/// <summary>
		/// Button should be active always
		/// </summary>
		Always,
		/// <summary>
		/// Button should be active only in editor
		/// </summary>
		Editor,
		/// <summary>
		/// Button should be active only in playmode
		/// </summary>
		Playmode
	}

	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
	public class ButtonAttribute : SpecialCaseDrawerAttribute
	{
		public string Text { get; private set; }
		public EButtonEnableMode SelectedEnableMode { get; private set; }		

		public ButtonAttribute(string text = null, EButtonEnableMode enabledMode = EButtonEnableMode.Always)
		{
			this.Text = text;
			this.SelectedEnableMode = enabledMode;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ButtonAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ReorderableListAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6189b48f4055e6c47aa132632d898fa6
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ReorderableListAttribute : SpecialCaseDrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ReorderableListAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ShowNativePropertyAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a8e9b7b71c94a1f459336a24cfe04b1b
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
	public class ShowNativePropertyAttribute : SpecialCaseDrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ShowNativePropertyAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ShowNonSerializedFieldAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8ea09f60df536734184a8920ff8bda6f
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ShowNonSerializedFieldAttribute : SpecialCaseDrawerAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/ShowNonSerializedFieldAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/SpecialCaseDrawerAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 95a59093f8ed1af48a8be75fa3050a3c
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public class SpecialCaseDrawerAttribute : Attribute, INaughtyAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/DrawerAttributes_SpecialCase/SpecialCaseDrawerAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/INaughtyAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: edda855906d15e541b46efd812fd70f3
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public interface INaughtyAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/INaughtyAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/BoxGroupAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 07da8af1e3be52c4789678bf4138ae11
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class BoxGroupAttribute : MetaAttribute, IGroupAttribute
	{
		public string Name { get; private set; }

		public BoxGroupAttribute(string name = "")
		{
			Name = name;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/BoxGroupAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/DisableIfAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 52a0d5c249ac8fd42a4fb4d61bc2f797
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field | AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
	public class DisableIfAttribute : EnableIfAttributeBase
	{
		public DisableIfAttribute(string condition)
			: base(condition)
		{
			Inverted = true;
		}

		public DisableIfAttribute(EConditionOperator conditionOperator, params string[] conditions)
			: base(conditionOperator, conditions)
		{
			Inverted = true;
		}

		public DisableIfAttribute(string enumName, object enumValue)
			: base(enumName, enumValue as Enum)
		{
			Inverted = true;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/DisableIfAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/EnableIfAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a616ae826c8ebae45a89d6a8cb68a843
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field | AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
	public class EnableIfAttribute : EnableIfAttributeBase
	{
		public EnableIfAttribute(string condition)
			: base(condition)
		{
			Inverted = false;
		}

		public EnableIfAttribute(EConditionOperator conditionOperator, params string[] conditions)
			: base(conditionOperator, conditions)
		{
			Inverted = false;
		}

		public EnableIfAttribute(string enumName, object enumValue)
			: base(enumName, enumValue as Enum)
		{
			Inverted = false;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/EnableIfAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/EnableIfAttributeBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8ba6385cd022e164b89ead1937173ddc
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public abstract class EnableIfAttributeBase : MetaAttribute
	{
		public string[] Conditions { get; private set; }
		public EConditionOperator ConditionOperator { get; private set; }
		public bool Inverted { get; protected set; }

		/// <summary>
		///		If this not null, <see cref="Conditions"/>[0] is name of an enum variable.
		/// </summary>
		public Enum EnumValue { get; private set; }

		public EnableIfAttributeBase(string condition)
		{
			ConditionOperator = EConditionOperator.And;
			Conditions = new string[1] { condition };
		}

		public EnableIfAttributeBase(EConditionOperator conditionOperator, params string[] conditions)
		{
			ConditionOperator = conditionOperator;
			Conditions = conditions;
		}

		public EnableIfAttributeBase(string enumName, Enum enumValue)
			: this(enumName)
		{
			if (enumValue == null)
			{
				throw new ArgumentNullException(nameof(enumValue), "This parameter must be an enum value.");
			}

			EnumValue = enumValue;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/EnableIfAttributeBase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/FoldoutAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 95f184555d5079243b2d25b35a641a74
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class FoldoutAttribute : MetaAttribute, IGroupAttribute
	{
		public string Name { get; private set; }

		public FoldoutAttribute(string name)
		{
			Name = name;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/FoldoutAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/HideIfAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9ab2d0fcfb13a214ea6ef7629c96a761
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field | AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
	public class HideIfAttribute : ShowIfAttributeBase
	{
		public HideIfAttribute(string condition)
			: base(condition)
		{
			Inverted = true;
		}

		public HideIfAttribute(EConditionOperator conditionOperator, params string[] conditions)
			: base(conditionOperator, conditions)
		{
			Inverted = true;
		}

		public HideIfAttribute(string enumName, object enumValue)
			: base(enumName, enumValue as Enum)
		{
			Inverted = true;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/HideIfAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/IGroupAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7c437b9ac50575347a7b12520f37f9a2
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using UnityEngine;

namespace NaughtyAttributes
{
	public interface IGroupAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/IGroupAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/LabelAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 79e0e0c0a7c25ea4fbe8eecaa4d559a0
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class LabelAttribute : MetaAttribute
	{
		public string Label { get; private set; }

		public LabelAttribute(string label)
		{
			Label = label;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/LabelAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/MetaAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a482b4e0fbf0f4547a5d522182a68d24
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public class MetaAttribute : Attribute, INaughtyAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/MetaAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/OnValueChangedAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e16a27c5576022b4bbe997c7db9051f0
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = true)]
	public class OnValueChangedAttribute : MetaAttribute
	{
		public string CallbackName { get; private set; }

		public OnValueChangedAttribute(string callbackName)
		{
			CallbackName = callbackName;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/OnValueChangedAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ReadOnlyAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e57264747ba93b94fbff12733de29499
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ReadOnlyAttribute : MetaAttribute
	{

	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ReadOnlyAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ShowIfAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1ada427cfd2c9b04989d6d18dea27985
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field | AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
	public class ShowIfAttribute : ShowIfAttributeBase
	{
		public ShowIfAttribute(string condition)
			: base(condition)
		{
			Inverted = false;
		}

		public ShowIfAttribute(EConditionOperator conditionOperator, params string[] conditions)
			: base(conditionOperator, conditions)
		{
			Inverted = false;
		}

		public ShowIfAttribute(string enumName, object enumValue)
			: base(enumName, enumValue as Enum)
		{
			Inverted = false;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ShowIfAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ShowIfAttributeBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0532b1c4d8a9ccf4b9f98f0bbe4a6747
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public class ShowIfAttributeBase : MetaAttribute
	{
		public string[] Conditions { get; private set; }
		public EConditionOperator ConditionOperator { get; private set; }
		public bool Inverted { get; protected set; }

		/// <summary>
		///		If this not null, <see cref="Conditions"/>[0] is name of an enum variable.
		/// </summary>
		public Enum EnumValue { get; private set; }

		public ShowIfAttributeBase(string condition)
		{
			ConditionOperator = EConditionOperator.And;
			Conditions = new string[1] { condition };
		}

		public ShowIfAttributeBase(EConditionOperator conditionOperator, params string[] conditions)
		{
			ConditionOperator = conditionOperator;
			Conditions = conditions;
		}

		public ShowIfAttributeBase(string enumName, Enum enumValue)
			: this(enumName)
		{
			if (enumValue == null)
			{
				throw new ArgumentNullException(nameof(enumValue), "This parameter must be an enum value.");
			}

			EnumValue = enumValue;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/MetaAttributes/ShowIfAttributeBase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/Utility/EColor.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 059f8674a8065924ea9c678298b5cd63
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using UnityEngine;

namespace NaughtyAttributes
{
	public enum EColor
	{
		Clear,
		White,
		Black,
		Gray,
		Red,
		Pink,
		Orange,
		Yellow,
		Green,
		Blue,
		Indigo,
		Violet
	}

	public static class EColorExtensions
	{
		public static Color GetColor(this EColor color)
		{
			switch (color)
			{
				case EColor.Clear:
					return new Color32(0, 0, 0, 0);
				case EColor.White:
					return new Color32(255, 255, 255, 255);
				case EColor.Black:
					return new Color32(0, 0, 0, 255);
				case EColor.Gray:
					return new Color32(128, 128, 128, 255);
				case EColor.Red:
					return new Color32(255, 0, 63, 255);
				case EColor.Pink:
					return new Color32(255, 152, 203, 255);
				case EColor.Orange:
					return new Color32(255, 128, 0, 255);
				case EColor.Yellow:
					return new Color32(255, 211, 0, 255);
				case EColor.Green:
					return new Color32(98, 200, 79, 255);
				case EColor.Blue:
					return new Color32(0, 135, 189, 255);
				case EColor.Indigo:
					return new Color32(75, 0, 130, 255);
				case EColor.Violet:
					return new Color32(128, 0, 255, 255);
				default:
					return new Color32(0, 0, 0, 255);
			}
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/Utility/EColor.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/Utility/EConditionOperator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3c227b6c19fc67b46ad294d95818f85a
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public enum EConditionOperator
	{
		And,
		Or
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/Utility/EConditionOperator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/MaxValueAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a748250af5ccfd7499cfb444aafb8a03
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class MaxValueAttribute : ValidatorAttribute
	{
		public float MaxValue { get; private set; }

		public MaxValueAttribute(float maxValue)
		{
			MaxValue = maxValue;
		}

		public MaxValueAttribute(int maxValue)
		{
			MaxValue = maxValue;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/MaxValueAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/MinValueAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 40133bac7c8d42b4d837138430a503e0
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class MinValueAttribute : ValidatorAttribute
	{
		public float MinValue { get; private set; }

		public MinValueAttribute(float minValue)
		{
			MinValue = minValue;
		}

		public MinValueAttribute(int minValue)
		{
			MinValue = minValue;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/MinValueAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/RequiredAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b0cdf49d1687849458b1a8d4786553d4
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class RequiredAttribute : ValidatorAttribute
	{
		public string Message { get; private set; }

		public RequiredAttribute(string message = null)
		{
			Message = message;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/RequiredAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/ValidateInputAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6c4171d68fb5bc0448d3ac298973e82c
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ValidateInputAttribute : ValidatorAttribute
	{
		public string CallbackName { get; private set; }
		public string Message { get; private set; }

		public ValidateInputAttribute(string callbackName, string message = null)
		{
			CallbackName = callbackName;
			Message = message;
		}
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/ValidateInputAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/ValidatorAttribute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0f3c43bed2dbc5249b6c6ec7859c2020
# ASMDEF: NaughtyAttributes.Core.dll
# ---
using System;

namespace NaughtyAttributes
{
	public class ValidatorAttribute : Attribute, INaughtyAttribute
	{
	}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Attributes/NaughtyAttributes/Core/ValidatorAttributes/ValidatorAttribute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/AutoHandExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 25c5f6ae064fd274d9b8dea1c18335bb
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

namespace Autohand
{
    public static class AutoHandExtensions
    {
        
        static Transform _transformRuler = null;
        //This is a "ruler" tool used to help calculate parent child calculations without doing parenting/childing
        public static Transform transformRuler
        {
            get {
                if(_transformRuler == null)
                    _transformRuler = new GameObject() { name = "Ruler" }.transform;

                if (_transformRuler.parent != transformParent)
                    _transformRuler.parent = transformParent;

                if (_transformRuler.localScale != Vector3.one)
                    _transformRuler.localScale = Vector3.one;

                if (IsPositionNan(_transformRuler.position))
                    _transformRuler.position = Vector3.zero;
                if (IsRotationNan(_transformRuler.rotation))
                    _transformRuler.rotation = Quaternion.identity;



                return _transformRuler;
            }
        }

        static Transform _transformRulerChild = null;
        //This is a "ruler" tool used to help calculate parent child calculations without doing parenting/childing
        public static Transform transformRulerChild
        {
            get {
                if (_transformRulerChild == null)
                {
                    _transformRulerChild = new GameObject() { name = "RulerChild" }.transform;
                    _transformRulerChild.parent = _transformRuler;
                }

                if (_transformRulerChild.parent != _transformRuler)
                    _transformRulerChild.parent = _transformRuler;

                if (_transformRulerChild.localScale != Vector3.one)
                    _transformRulerChild.localScale = Vector3.one;

                if (IsPositionNan(_transformRulerChild.position))
                    _transformRulerChild.position = Vector3.zero;
                if (IsRotationNan(_transformRulerChild.rotation))
                    _transformRulerChild.rotation = Quaternion.identity;

                return _transformRulerChild;
            }
        }

        static bool IsPositionNan(Vector3 pos)
        {
            return float.IsNaN(pos.x) || float.IsNaN(pos.y) || float.IsNaN(pos.z);
        }
        
        static bool IsRotationNan(Quaternion rot)
        {
            return float.IsNaN(rot.x) || float.IsNaN(rot.y) || float.IsNaN(rot.z) || float.IsNaN(rot.w);
        }

        static Transform _transformParent = null;

        // Holds all the Auto Hand Generated GameObjects
        public static Transform transformParent {
            get {
                if(Application.isEditor)
                    return null;

                if(_transformParent == null)
                    _transformParent = new GameObject() { name="Auto Hand Generated" }.transform;

                return _transformParent;
            }
        }

        public static void RotateAround(this Transform target, Transform center, Quaternion deltaRotation) {
            transformRuler.SetPositionAndRotation(center.position, center.rotation);
            transformRulerChild.SetPositionAndRotation(target.position, target.rotation);
            transformRuler.rotation *= deltaRotation;
            target.SetPositionAndRotation(transformRulerChild.position, transformRulerChild.rotation);
        }

        public static float Round(this float value, int digits)
        {
            float mult = Mathf.Pow(10.0f, (float)digits);
            return Mathf.Round(value * mult) / mult;
        }

        /// <summary>Returns true if there is a grabbable or link, out null if there is none</summary>
        public static bool HasGrabbable(this Hand hand, GameObject obj, out Grabbable grabbable) {
            return HasGrabbable(obj, out grabbable);
        }

        /// <summary>Returns true if there is a grabbable or link, out null if there is none</summary>
        public static bool HasGrabbable(this Hand hand, UnityEngine.Component obj, out Grabbable grabbable) {
            return HasGrabbable(obj, out grabbable);
        }

        /// <summary>Returns true if there is a grabbable or link, out null if there is none</summary>
        public static bool HasGrabbable(this GameObject obj, out Grabbable grabbable, bool includeDisabled = false) {
            if(obj == null) {
                grabbable = null;
                return false;
            }


            if(obj.CanGetComponent(out IGrabbableEvents grabbableEvents)) {
                if(grabbableEvents.GetGrabbable() != null && (includeDisabled || grabbableEvents.GetGrabbable().enabled)) {
                    grabbable = grabbableEvents.GetGrabbable();
                    return true;
                }
            }

            if(obj.CanGetComponent(out grabbable) && (includeDisabled || grabbable.enabled)) {
                return true;
            }

            GrabbableChild grabChild;
            if(obj.CanGetComponent(out grabChild) && (includeDisabled || grabChild.grabParent.enabled)) {
                grabbable = grabChild.grabParent;
                return true;
            }

            grabbable = null;
            return false;
        }

        /// <summary>Returns true if there is a grabbable or link, out null if there is none</summary>
        public static bool HasGrabbable(this Component obj, out Grabbable grabbable, bool includeDisabled = false) {
            if(obj == null) {
                grabbable = null;
                return false;
            }


            if(obj.CanGetComponent(out IGrabbableEvents grabbableEvents)) {
                if(grabbableEvents.GetGrabbable() != null && (includeDisabled || grabbableEvents.GetGrabbable().enabled)) {
                    grabbable = grabbableEvents.GetGrabbable();
                    return true;
                }
            }

            if(obj.CanGetComponent(out grabbable) && (includeDisabled || grabbable.enabled)) {
                return true;
            }

            GrabbableChild grabChild;
            if(obj.CanGetComponent(out grabChild) && (includeDisabled || grabChild.grabParent.enabled)) {
                grabbable = grabChild.grabParent;
                return true;
            }

            grabbable = null;
            return false;
        }









        public static T GetCopyOf<T>(this Component comp, T other) where T : Component{
            Type type = comp.GetType();
            if (type != other.GetType()) return null; // type mis-match
            BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Default | BindingFlags.DeclaredOnly;
            PropertyInfo[] pinfos = type.GetProperties(flags);
            foreach (var pinfo in pinfos)
            {
                if (pinfo.CanWrite)
                {
                    try
                    {
                        pinfo.SetValue(comp, pinfo.GetValue(other, null), null);
                    }
                    catch { } // In case of NotImplementedException being thrown. For some reason specifying that exception didn't seem to catch it, so I didn't catch anything specific.
                }
            }
            FieldInfo[] finfos = type.GetFields(flags);
            foreach (var finfo in finfos)
            {
                finfo.SetValue(comp, finfo.GetValue(other));
            }
            return comp as T;
        }



        /// <summary>Autohand extension method, used so I can use TryGetComponent for newer versions and GetComponent for older versions</summary>
        public static bool CanGetComponent<T>(this Component componentClass, out T component)
        {
#if UNITY_2019_1 || UNITY_2018 || UNITY_2017
       var tempComponent = componentClass.GetComponent<T>();
        if(tempComponent != null){
            component = tempComponent;
            return true;
        }
        else {
            component = tempComponent;
            return false;
        }
#else
            var value = componentClass.TryGetComponent(out component);
            return value;
#endif
        }

        /// <summary>Autohand extension method, used so I can use TryGetComponent for newer versions and GetComponent for older versions</summary>
        public static bool CanGetComponent<T>(this GameObject componentClass, out T component) {
#if UNITY_2019_1 || UNITY_2018 || UNITY_2017
       var tempComponent = componentClass.GetComponent<T>();
        if(tempComponent != null){
            component = tempComponent;
            return true;
        }
        else {
            component = tempComponent;
            return false;
        }
#else
            var value = componentClass.TryGetComponent(out component);
            return value;
#endif
        }

        /// <summary>Autohand extension method, used so I can use TryGetComponent for newer versions and GetComponent for older versions</summary>
        public static T CanFindObjectOfType<T>(bool includeInactive = false) where T : Component {
#if UNITY_2023_1_OR_NEWER
            return GameObject.FindFirstObjectByType<T>((includeInactive ? FindObjectsInactive.Include : FindObjectsInactive.Exclude));
#elif (UNITY_2020_3_OR_NEWER)
            return GameObject.FindObjectOfType<T>(includeInactive);
#else
            return GameObject.FindObjectOfType<T>();
#endif
        }
        /// <summary>Autohand extension method, used so I can use TryGetComponent for newer versions and GetComponent for older versions</summary>
        public static T[] CanFindObjectsOfType<T>(bool includeInactive = false) where T : Component {
#if UNITY_2023
            return GameObject.FindObjectsByType<T>((includeInactive ? FindObjectsInactive.Include : FindObjectsInactive.Exclude), FindObjectsSortMode.None);
#elif (UNITY_6000_0_OR_NEWER)
            return GameObject.FindObjectsByType<T>((includeInactive ? FindObjectsInactive.Include : FindObjectsInactive.Exclude), FindObjectsSortMode.None);
#elif (UNITY_2020_3_OR_NEWER)                        
            return GameObject.FindObjectsOfType<T>(includeInactive);
#else
            return GameObject.FindObjectsOfType<T>();
#endif
        }




#if UNITY_EDITOR

        public static void TextDebug(this Vector3 vector3, string name = "") {
            Debug.Log(name + ": " + vector3.x + ", " + vector3.y + ", " + vector3.z);
        }

        public static GUIStyle LabelStyle(TextAnchor textAnchor = TextAnchor.MiddleLeft, FontStyle fontStyle = FontStyle.Normal, int fontSize = 13) {
            var style = new GUIStyle(GUI.skin.label);
            style.font = (Font)Resources.Load("Righteous-Regular", typeof(Font));
            style.fontSize = fontSize;
            style.alignment = textAnchor;
            style.fontStyle = fontStyle;
            return style;
        }
        public static GUIStyle LabelStyle(Color textColor, TextAnchor textAnchor = TextAnchor.MiddleLeft, FontStyle fontStyle = FontStyle.Normal, int fontSize = 13) {
            var style = new GUIStyle(GUI.skin.label);
            style.font = (Font)Resources.Load("Righteous-Regular", typeof(Font));
            style.fontSize = fontSize;
            style.alignment = textAnchor;
            style.fontStyle = fontStyle;
            style.normal.textColor = textColor;
            return style;
        }

        public static GUIStyle LabelStyleB(Color textColor, TextAnchor textAnchor = TextAnchor.MiddleLeft, FontStyle fontStyle = FontStyle.Normal, int fontSize = 13) {
            var style = new GUIStyle(GUI.skin.toggle);
            style.font = (Font)Resources.Load("Righteous-Regular", typeof(Font));
            style.fontSize = fontSize;
            style.alignment = textAnchor;
            style.fontStyle = fontStyle;
            style.normal.textColor = textColor;
            return style;
        }
#endif

        public static LayerMask GetPhysicsLayerMask(int currentLayer) {
            int finalMask = 0;
            for (int i=0; i<32; i++) {
                if (!Physics.GetIgnoreLayerCollision(currentLayer, i)) finalMask = finalMask | (1 << i);
            }
            return finalMask;
        }

        public static void AddTorqueAtPoint(this Rigidbody rigidbody, Vector3 torque, Vector3 point) {
            // Apply the torque
            rigidbody.AddTorque(torque, ForceMode.VelocityChange);

            // Calculate the force direction (perpendicular to the torque and line from center of mass to point)
            Vector3 forceDir = Vector3.Cross(torque, point - rigidbody.worldCenterOfMass).normalized;

            // Calculate the magnitude of the force
            Vector3 pointVelocity = rigidbody.GetPointVelocity(point);
            Vector3 angularVelocityContribution = Vector3.Cross(rigidbody.angularVelocity, point - rigidbody.worldCenterOfMass);
            float forceMagnitude = (pointVelocity - angularVelocityContribution).magnitude;

            // Apply the force at the point
            rigidbody.AddForceAtPosition(forceDir * forceMagnitude, point, ForceMode.VelocityChange);
        }


        public static Matrix4x4 Lerp(ref Matrix4x4 from, Matrix4x4 to, float t) {
            var fromPosition = ExtractPosition(ref from);
            var fromRotation = ExtractRotation(ref from);
            var fromScale = ExtractScale(ref from);

            var toPosition = ExtractPosition(ref to);
            var toRotation = ExtractRotation(ref to);
            var toScale = ExtractScale(ref to);

            return Matrix4x4.TRS(Vector3.Lerp(fromPosition, toPosition, t), Quaternion.Slerp(fromRotation, toRotation, t), Vector3.Lerp(fromScale, toScale, t));
        }

        public static Vector3 ExtractPosition(ref Matrix4x4 matrix) => matrix.GetColumn(3);
        public static Quaternion ExtractRotation(ref Matrix4x4 matrix) => Quaternion.LookRotation(matrix.GetColumn(2), matrix.GetColumn(1));
        public static Vector3 ExtractScale(ref Matrix4x4 matrix) => matrix.lossyScale;

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/AutoHandExtensions.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoAmmo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6bdeab21deb0d4b4093a6d63537c25cc
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [RequireComponent(typeof(Grabbable))]
    public class AutoAmmo : MonoBehaviour {
        public int currentAmmo = 16;
        public TMPro.TextMeshPro ammoText;

        private void Start() {
            SetAmmo(currentAmmo);
        }

        public bool RemoveAmmo() {
            if(currentAmmo > 0) {
                SetAmmo(--currentAmmo);
                return true;
            }
            return false;
        }

        public void SetAmmo(int amount) {
            currentAmmo = amount;
            if(ammoText != null)
                ammoText.text = currentAmmo.ToString();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoAmmo.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoAnimation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3ce88833e24f32946b52520c576f041f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand
{
    public enum AnimationPoint
    {
        start,
        end
    }

    public class AutoAnimation : MonoBehaviour
    {
        [Tooltip("This each transform that will be animated")]
        public AnimationCurve animationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);
        public bool recordChildTransforms = true;
        public bool setPositions = true;
        public bool setRotations = true;
        public bool setScale = false;

        [SerializeField,HideInInspector]
        private Transform[] transformReferences;
        [SerializeField, HideInInspector]
        private Vector3[] maxValuePositions;
        [SerializeField, HideInInspector]
        private Quaternion[] maxValueRotations;
        [SerializeField, HideInInspector]
        private Vector3[] maxValueScales;

        [SerializeField, HideInInspector]
        private Vector3[] minValuePositions;
        [SerializeField, HideInInspector]
        private Quaternion[] minValueRotations;
        [SerializeField, HideInInspector]
        private Vector3[] minValueScales;

        Transform transformRoot;

        public void SetAnimation(float point)
        {
            if (setPositions)
                for (int i = 0; i < transformReferences.Length; i++)
                    transformReferences[i].localPosition = Vector3.Lerp(minValuePositions[i], maxValuePositions[i], animationCurve.Evaluate(point));

            if (setRotations)
                for (int i = 0; i < transformReferences.Length; i++)
                    transformReferences[i].localRotation = Quaternion.Lerp(minValueRotations[i], maxValueRotations[i], animationCurve.Evaluate(point));

            if (setScale)
                for (int i = 0; i < transformReferences.Length; i++)
                    transformReferences[i].localScale = Vector3.Lerp(minValueScales[i], maxValueScales[i], animationCurve.Evaluate(point));
        }

        internal Vector3 GetTransformPositionAtPoint(int index, float point)
        {
            return Vector3.Lerp(minValuePositions[index], maxValuePositions[index], animationCurve.Evaluate(point));
        }

        internal int GetTransformIndex(Transform transform)
        {
            for (int i = 0; i < transformReferences.Length; i++)
            {
                if (transformReferences[i].Equals(transform))
                    return i;
            }

            return -1;
        }

        [NaughtyAttributes.Button("Save Start"), ContextMenu("Save Start")]
        public void SaveAnimationStart()
        {
            Debug.Log("Saved Start Pose");
            SaveAnimation(AnimationPoint.start);
        }

        [NaughtyAttributes.Button("Save End"), ContextMenu("Save End")]
        public void SaveAnimationEnd() {
            Debug.Log("Saved End Pose");
            SaveAnimation(AnimationPoint.end);
        }

        [Range(0, 1)]
        public float setTestValue = 0;
        [NaughtyAttributes.Button("Set")]
        public void SetAnimation()
        {
            SetAnimation(setTestValue);
        }

        public void SaveAnimation(AnimationPoint animationPoint)
        {
            if(transformRoot == null)
                transformRoot = transform;

            int count = 0;
            void GetRecursiveChildCount(Transform obj){
                count++;
                if (recordChildTransforms)
                    for (int k = 0; k < obj.childCount; k++)
                        GetRecursiveChildCount(obj.GetChild(k));
            }

            GetRecursiveChildCount(transformRoot);

            transformReferences = new Transform[count];
            if (animationPoint == AnimationPoint.end)
            {
                maxValuePositions = new Vector3[count];
                maxValueRotations = new Quaternion[count];
                maxValueScales = new Vector3[count];
            }
            else if(animationPoint == AnimationPoint.start)
            {
                minValuePositions = new Vector3[count];
                minValueRotations = new Quaternion[count];
                minValueScales = new Vector3[count];
            }


            int currIndex = 0;
            AssignChildrenPose(transformRoot);


            void AssignChildrenPose(Transform obj) {

                AssignPoint(currIndex, obj.localPosition, obj.localRotation, obj.localScale, obj);
                currIndex++;

                if (recordChildTransforms)
                    for (int j = 0; j < obj.childCount; j++)
                        AssignChildrenPose(obj.GetChild(j));
            }


            void AssignPoint(int point, Vector3 pos, Quaternion rot, Vector3 scale, Transform joint)
            {
                transformReferences[point] = joint;
                if (animationPoint == AnimationPoint.end)
                {
                    maxValuePositions[point] = pos;
                    maxValueRotations[point] = rot;
                    maxValueScales[point] = scale;
                }
                else if (animationPoint == AnimationPoint.start)
                {
                    minValuePositions[point] = pos;
                    minValueRotations[point] = rot;
                    minValueScales[point] = scale;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoAnimation.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoArrow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3034800f363546d40a653770a8c3207e
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo
{
    public class AutoArrow : MonoBehaviour
    {
        public float minPenetrationVelocity = 4f;
        public float maxPenetrationVelocity = 20f;
        public float minPenetrationDistance = 0.1f;
        public float maxPenetrationDistance = 0.2f;
        public float impactForceMultiplier = 1f;
        public Grabbable grabbable;
        Grabbable hitGrabbable;

        public AutoBow firedBow { get; internal set; }

        Vector3 direction;
        float currforce;

        public void FireArrow(float force, Grabbable arrowGrab, AutoBow firedBow)
        {
            grabbable = arrowGrab;
            this.firedBow = firedBow;
            impactForceMultiplier = firedBow.arrowImpactForceMultiplier;

            currforce = force;
            direction = transform.TransformDirection(firedBow.arrowForceDirection);
        }

        private void OnEnable() {
            if(grabbable == null)
                grabbable = GetComponent<Grabbable>();

            grabbable.OnGrabEvent += OnGrabbed;
        }

        private void OnDisable() {
            grabbable.OnGrabEvent -= OnGrabbed;
        }
        void OnGrabbed(Hand hand, Grabbable grab) {
            grabbable.ActivateRigidbody();
            hitGrabbable?.RemoveChildGrabbable(grab);
            hitGrabbable = null;
            firedBow = null;
        }

        public void FixedUpdate()
        {
            if (firedBow != null)
            {
                var currVel = direction * currforce;
                currVel += Physics.gravity * Time.fixedDeltaTime;
                direction = currVel.normalized;
                grabbable.rootTransform.position += direction * Time.fixedDeltaTime * currforce;
                grabbable.rootTransform.rotation = Quaternion.FromToRotation(firedBow.arrowForceDirection, direction);
                grabbable.body.linearVelocity = Vector3.zero;
                grabbable.body.angularVelocity = Vector3.zero;
            }
        }




        public void OnCollisionEnter(Collision collision)
        {
            if (firedBow != null)
            {
                if (collision.rigidbody == null || collision.rigidbody != firedBow.bowHandleGrabbable.body)
                {
                    if (currforce > minPenetrationVelocity)
                    {
                        GrabbableChild hitGrabbableChild;
                        if(collision.collider.CanGetComponent<Grabbable>(out hitGrabbable)) {
                            hitGrabbable.AddChildGrabbable(grabbable);

                        }
                        if (collision.collider.CanGetComponent<GrabbableChild>(out hitGrabbableChild)) {

                            hitGrabbable = hitGrabbableChild.grabParent;
                            hitGrabbable.AddChildGrabbable(grabbable);

                        }

                        grabbable.rootTransform.position += grabbable.body.linearVelocity * 1 / 50f;
                        grabbable.rootTransform.parent = collision.collider.transform;
                        grabbable.DeactivateRigidbody();
                        
                    }

                    //grabbable.body.isKinematic = false;
                    firedBow = null;

                    if (collision.rigidbody != null)
                        collision.rigidbody.AddForceAtPosition(impactForceMultiplier * direction * currforce, collision.contacts[0].point, ForceMode.Impulse);
                }

            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoArrow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoBow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 752961632a0d3c449954753f1750e488
# ASMDEF: AutoHandAssembly.dll
# ---
using NaughtyAttributes;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using Autohand;

namespace Autohand.Demo {
    public class AutoBow : MonoBehaviour
    {
        public AutoAnimation bowAnimation;
        public Grabbable bowHandleGrabbable;
        public HeldPlaceJoint arrowPoint;
        [Space]
        public float drawbackRange = 0.3f;
        public float drawbackSpring = 100f;
        public float drawbackDamper = 10f;
        public float tolerance = 0.005f;
        [Space]
        public Vector3 arrowForceDirection = Vector3.forward;
        public float arrowForce = 1f;
        public float arrowImpactForceMultiplier = 1f;
        public AnimationCurve arrowForceCurve = AnimationCurve.Linear(0, 0, 1, 1);

        protected Grabbable arrow;
        protected SpringJoint arrowJoint;

        int placePointIndex = 0;

        public void Start()
        {
            placePointIndex = bowAnimation.GetTransformIndex(arrowPoint.transform);
            arrowPoint.enabled = false;
            arrowPoint.OnPlaceEvent += OnArrowPlace;
            bowHandleGrabbable.OnGrabEvent += OnBowHandleGrab;
            bowHandleGrabbable.OnReleaseEvent += OnBowHandleRelease;

        }

        public void Update()
        {
            BowStringAnimation();
        }

        float arrowPointValue = 0.5f;
        public void BowStringAnimation()
        {

            if (arrowPoint.placedObject != null)
            {
                var arrowHand = arrowPoint.placedObject.GetHeldBy()[0];
                arrowPointValue = 0.5f;
                float closestPoint = 0.5f;
                for (int i = 0; i < 20; i++) {
                    var postitionA = bowAnimation.GetTransformPositionAtPoint(placePointIndex, closestPoint + arrowPointValue / 2f);
                    var postitionB = bowAnimation.GetTransformPositionAtPoint(placePointIndex, closestPoint - arrowPointValue / 2f);
                    var postitionC = bowAnimation.GetTransformPositionAtPoint(placePointIndex, closestPoint);
                    var distanceA = Vector3.Distance(postitionA, arrowPoint.placedObject.transform.position);
                    var distanceB = Vector3.Distance(postitionB, arrowPoint.placedObject.transform.position);
                    var distanceC = Vector3.Distance(postitionC, arrowPoint.placedObject.transform.position);

                    if(distanceC < distanceA && distanceC < distanceB) { }
                    else if(distanceA < distanceB)
                        closestPoint += arrowPointValue / 2f;
                    else
                        closestPoint -= arrowPointValue / 2f;

                    arrowPointValue /= 2f;
                }

                bowAnimation.SetAnimation(closestPoint);
            }
            else if(arrowPointValue != 0) {
                arrowPointValue = 0;
                bowAnimation.SetAnimation(arrowPointValue);
            }
        }

        public void OnBowHandleGrab(Hand hand, Grabbable grab)
        {
            arrowPoint.enabled = true;
        }

        public void OnBowHandleRelease(Hand hand, Grabbable grab)
        {
            arrowPoint.enabled = false;
        }



        public void OnArrowPlace(PlacePoint point, Grabbable grab)
        {
            point.placedObject.OnReleaseEvent += OnArrowRelease;
            if(bowHandleGrabbable.HeldCount() > 0)
                point.placedObject.IgnoreHand(bowHandleGrabbable.GetHeldBy()[0], true);
            point.placedObject.ignoreReleaseTime = 1f;
        }


        public void OnArrowRelease(Hand hand, Grabbable grab)
        {
            if (arrowPoint.placedObject != null)
            {
                //arrowPoint.Destroyjoint();
                arrowPoint.Remove(arrowPoint.placedObject);
                if (bowHandleGrabbable.HeldCount() > 0){
                    bowAnimation.SetAnimation(0);
                    var bowHand = bowHandleGrabbable.GetHeldBy()[0];
                    EnableCollisionDelay(3f, grab, bowHandleGrabbable.GetHeldBy()[0], arrowPoint);
                }

                AutoArrow arrow;
                if (grab.body.TryGetComponent<AutoArrow>(out arrow))
                {
                    arrow.FireArrow(arrowForceCurve.Evaluate(arrowPointValue)*arrowForce, grab, this);
                }
                else
                {
                    arrow = grab.body.gameObject.AddComponent<AutoArrow>();
                    arrow.FireArrow(arrowForceCurve.Evaluate(arrowPointValue) * arrowForce, grab, this);
                }

            }
        }

        IEnumerator EnableCollisionDelay(float delay, Grabbable grab, Hand hand, PlacePoint placePoint)
        {
            var preDrag = grab.body.angularDamping;
            bowHandleGrabbable.IgnoreGrabbableCollisionUntilNone(grab);
            placePoint.dontAllows.Add(grab);
            yield return new WaitForSeconds(delay);
            grab.IgnoreHand(hand, false);
            placePoint.dontAllows.Remove(grab);

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoBow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGun.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 11f7286f437aec34c8a4a6f841c921ef
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand {
    public enum SlideLoadType {
        HandLoaded,
        ShotLoaded
    }

    [Serializable] public class UnityGunHitEvent : UnityEvent<AutoGun, RaycastHit> { }
    [Serializable] public class UnityGunEvent : UnityEvent<AutoGun> { }
    [Serializable] public class UnityGunSlideEvent : UnityEvent<AutoGun, SlideLoadType> { }
    [Serializable] public class UnityAmmoEvent : UnityEvent<AutoGun, AutoAmmo> { }



    [RequireComponent(typeof(Grabbable))]
    public class AutoGun : MonoBehaviour {

        [AutoHeader("Auto Gun")]
        public bool ignoreMe1;
        [Tooltip("The local forward of this transform is where the bullet raycast will come from")]
        public Transform shootForward;
        [Tooltip("(Optional) GrabbableHeldJoint recommended for triggering the LoadSlide event, if connected this will trigger the slide movement when shooting ")]
        public GrabbableHeldJoint slideJoint;
        [Tooltip("The place point for the ammo")]
        public PlacePoint magazinePoint;

        [AutoSmallHeader("Gun Settings")]
        public bool ignoreMe2;
        [Tooltip("The automatic fire rate while holding the trigger, 0 is semi-automatic")]
        public float automaticFireRate = 0;
        [Tooltip("The force applied to the target's rigidbody when hit")]
        public float hitForce = 2500f;
        [Tooltip("The force applied to the gun when shooting")]
        public float recoilForce = 500f;
        [Tooltip("The maximum distance a target can be hit")]
        public float maxHitDistance = 1000f;
        [Tooltip("If true the gun will hit every target until it hits a static collider")]
        public bool useBulletPenetration = false;
        [Tooltip("Whether or not the LoadSlide function needs to be called externally or if it is automatically called when the ammo is loaded")]
        public bool requireSlideLoading = true;
        [Tooltip("Whether or not the ammo clip should automatically be removed from the place point when it's empty")]
        public bool autoEjectEmptyClip = false;


        [AutoSmallHeader("Events")]
        public bool ignoreMe5;
        public UnityGunEvent OnShoot;
        public UnityGunEvent OnEmptyShoot;
        public UnityGunHitEvent OnHitEvent;
        public UnityAmmoEvent OnAmmoPlaceEvent;
        public UnityAmmoEvent OnAmmoRemoveEvent;
        public UnityGunSlideEvent OnSlideEvent;

        protected AutoAmmo loadedAmmo;
        internal Grabbable grabbable;
        protected bool slideLoaded = false;

        float lastFireTime;
        bool squeezingTrigger;
        bool lastSqueezingTrigger;

        private void Start() {
            grabbable = GetComponent<Grabbable>();
            if(magazinePoint != null)
                magazinePoint.dontAllows.Add(grabbable);

        }

        private void OnEnable() {
            if(magazinePoint != null) {
                magazinePoint.OnPlaceEvent += OnMagPlace;
                magazinePoint.OnRemoveEvent += OnMagRemove;
            }
        }
        private void OnDisable() {
            if(magazinePoint != null) {
                magazinePoint.OnPlaceEvent -= OnMagPlace;
                magazinePoint.OnRemoveEvent -= OnMagRemove;
            }
        }

        private void FixedUpdate() {
            if(squeezingTrigger && automaticFireRate > 0 && slideLoaded && Time.fixedTime-lastFireTime > automaticFireRate)
                Shoot();
            else if(squeezingTrigger && !lastSqueezingTrigger && automaticFireRate <= 0)
                Shoot();
            else if(squeezingTrigger && !lastSqueezingTrigger && automaticFireRate > 0)
                Shoot();

            lastSqueezingTrigger = squeezingTrigger;
        }


        public void PressTrigger() {
            squeezingTrigger = true;
        }


        public void ReleaseTrigger() {
            squeezingTrigger = false;
        }


        public void Shoot() {
            if(slideLoaded) {
                grabbable.body.AddForceAtPosition(-shootForward.forward * recoilForce / 10f, shootForward.position);
                grabbable.body.AddForceAtPosition(shootForward.up * recoilForce, shootForward.position);
                OnShoot?.Invoke(this);

                if(useBulletPenetration){
                    var raycasthits = Physics.RaycastAll(shootForward.position, shootForward.forward, maxHitDistance, ~0, QueryTriggerInteraction.Ignore);
                    if(raycasthits.Length > 0) {
                        foreach(var hit in raycasthits) {
                            if(hit.rigidbody != grabbable.body)
                                OnHit(hit);
                            if(hit.rigidbody == null)
                                break;
                        }
                    }
                }
                else if(Physics.Raycast(shootForward.position, shootForward.forward, out var hit, maxHitDistance, ~0, QueryTriggerInteraction.Ignore)){
                    if(hit.rigidbody != grabbable.body)
                        OnHit(hit);
                    else
                        Debug.LogError("Gun is shooting itself, make sure the shootforward transform is not inside a collider", this);
                }

                lastFireTime = Time.fixedTime;
                FireLoadSlide();
            }
            else
                OnEmptyShoot?.Invoke(this);

            if(autoEjectEmptyClip && loadedAmmo != null && loadedAmmo.currentAmmo == 0 && !slideLoaded)
                magazinePoint?.Remove();
        }





        public void LoadSlide() {
            OnSlideEvent?.Invoke(this, SlideLoadType.HandLoaded);
            slideLoaded = loadedAmmo != null && loadedAmmo.currentAmmo > 0;
            if(slideLoaded)
                loadedAmmo.RemoveAmmo();

        }


        public void FireLoadSlide() {
            OnSlideEvent?.Invoke(this, SlideLoadType.ShotLoaded);
            slideLoaded = loadedAmmo != null && loadedAmmo.currentAmmo > 0;
            if(slideLoaded)
                loadedAmmo.RemoveAmmo();

        }


        public void UnloadSlide() {
            slideLoaded = false;
        }


        public bool IsSlideLoaded() {
            return slideLoaded;
        }


        /// <summary>Returns ammo in count in current clip plus slide</summary>
        public int GetAmmo() {
            int ammo = slideLoaded ? 1 : 0;
            if(loadedAmmo != null)
                ammo += loadedAmmo.currentAmmo;
            return magazinePoint == null ? 1 : ammo;
        }


        void OnMagPlace(PlacePoint point, Grabbable mag) {
            if(mag.TryGetComponent<AutoAmmo>(out var ammo)) {
                this.loadedAmmo = ammo;
                OnAmmoPlaceEvent?.Invoke(this, loadedAmmo);
            }
            if(!slideLoaded && !requireSlideLoading)
                LoadSlide();
        }

        void OnMagRemove(PlacePoint point, Grabbable mag) {
            OnAmmoRemoveEvent?.Invoke(this, loadedAmmo);
            loadedAmmo = null;
        }

        protected virtual void OnHit(RaycastHit hit) {
            if(hit.rigidbody) {
                hit.rigidbody.AddForceAtPosition(shootForward.forward * recoilForce, hit.point);
                OnHitEvent?.Invoke(this, hit);
                if(hit.rigidbody.TryGetComponent<AutoGunTarget>(out var target))
                    target.OnShot(this, hit);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGun.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGunEffects.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d1d6fe45f7f6aed49bac268508f3a78d
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [RequireComponent(typeof(AutoGun))]
    public class AutoGunEffects : MonoBehaviour {


        [AutoSmallHeader("Visual Effects")]
        public bool ignoreMe3;
        [Tooltip("Whether or not racking the slide with a bullet already in the chamber ejects that bullet or not")]
        public bool ejectUnfiredBullet = true;
        [Tooltip("This is the unfired bullet prefab that will be instantiated and ejected if the 'ejectUnfiredBullet' value is true and the slide is racked while full")]
        public GameObject bullet;
        [Tooltip("This is the fired bullet shell prefab that will be instantiated and ejected if the when the gun is shot")]
        public GameObject bulletShell;
        [Tooltip("Particle effect that plays from the gun aim transform on shoot")]
        public ParticleSystem shootParticle;
        [Tooltip("The lifetime of the ejected bullets before they are added to the pool")]
        public float ejectedBulletLifetime = 3f;
        [Tooltip("The position and rotation where the bullets are instantiated")]
        public Transform shellEjectionSpawnPoint;
        [Tooltip("The forward direction of this point represents the direction the shells should be ejected")]
        public Transform shellEjectionDirection;
        [Tooltip("The amount of force to add to the ejected bullet")]
        public float shellEjectionForce = 50;

        [AutoSmallHeader("Sound Effects")]
        public bool ignoreMe4;
        [Tooltip("This sound will play when a bullet is fired")]
        public AudioSource shootSound;
        [Tooltip("This sound will play when a the trigger is pressed and there is nothing to shoot")]
        public AudioSource emptyShootSound;

        Dictionary<GameObject, float> bulletLifetimeTracker = new Dictionary<GameObject, float>();
        Dictionary<GameObject, float> shellLifetimeTracker = new Dictionary<GameObject, float>();
        List<GameObject> bulletPool = new List<GameObject>();
        List<GameObject> bulletShellPool = new List<GameObject>();

        List<ParticleSystem> activeParticlePool = new List<ParticleSystem>();
        List<ParticleSystem> inactiveParticlePool = new List<ParticleSystem>();
        AutoGun gun;


        private void OnEnable(){
            gun = GetComponent<AutoGun>();
            gun.OnShoot.AddListener(OnShoot);
            gun.OnEmptyShoot.AddListener(OnEmptyShoot);
            gun.OnSlideEvent.AddListener(OnSlideLoaded);
        }

        private void OnDisable(){
            gun.OnShoot.RemoveListener(OnShoot);
            gun.OnEmptyShoot.RemoveListener(OnEmptyShoot);
            gun.OnSlideEvent.RemoveListener(OnSlideLoaded);
        }

        private void FixedUpdate() {
            CheckBulletLifetime();
            CheckParticlPlaying();

        }

        void CreateShootParticle() {
            if(shootParticle != null) {
                var newShootParticle = GameObject.Instantiate(shootParticle);
                newShootParticle.transform.position = gun.shootForward.position;
                newShootParticle.transform.forward = gun.shootForward.forward;
                activeParticlePool.Add(newShootParticle);
            }
        }

        void OnShoot(AutoGun gun){
            shootSound?.PlayOneShot(shootSound.clip);
            CreateShootParticle();
        }

        void OnEmptyShoot(AutoGun gun){
            emptyShootSound?.PlayOneShot(emptyShootSound.clip);
        }

        void OnSlideLoaded(AutoGun gun, SlideLoadType loadType) {

            if(loadType == SlideLoadType.ShotLoaded){
                if(gun.slideJoint != null) {
                    if(Mathf.Abs(gun.slideJoint.xMinLimit) >= gun.slideJoint.xMaxLimit &&
                        Mathf.Abs(gun.slideJoint.yMinLimit) >= gun.slideJoint.yMaxLimit &&
                        Mathf.Abs(gun.slideJoint.zMinLimit) >= gun.slideJoint.zMaxLimit)
                        gun.slideJoint.SetJointMin();
                    else
                        gun.slideJoint.SetJointMax();
                }

                EjectShell();
            }
            else if(gun.IsSlideLoaded()) {
                EjectBullet();
            }

        }

        public void EjectBullet() {
            if(bullet != null) {
                GameObject newBullet;
                if(bulletPool.Count > 0) {
                    newBullet = bulletPool[0];
                    bulletPool.RemoveAt(0);
                    newBullet.transform.position = shellEjectionSpawnPoint.position;
                    newBullet.transform.rotation = shellEjectionSpawnPoint.rotation;
                    newBullet.SetActive(true);
                }
                else {
                    newBullet = Instantiate(bullet, shellEjectionSpawnPoint.position, shellEjectionSpawnPoint.rotation);
                }

                if(newBullet.CanGetComponent<Rigidbody>(out var body)) {
                    if(AutoHandPlayer.Instance.IsHolding(gun.grabbable))
                        body.linearVelocity = AutoHandPlayer.Instance.body.linearVelocity;
                    body.linearVelocity += gun.grabbable.body.linearVelocity;
                    body.AddForce(shellEjectionDirection.forward * shellEjectionForce, ForceMode.Force);
                }
                bulletLifetimeTracker.Add(newBullet, ejectedBulletLifetime);
            }
        }

        public void EjectShell() {
            if(bulletShell != null) {
                GameObject newShell;
                if(bulletShellPool.Count > 0) {
                    newShell = bulletShellPool[0];
                    bulletShellPool.RemoveAt(0);
                    newShell.transform.position = shellEjectionSpawnPoint.position;
                    newShell.transform.rotation = shellEjectionSpawnPoint.rotation;
                    newShell.SetActive(true);
                }
                else {
                    newShell = Instantiate(bulletShell, shellEjectionSpawnPoint.position, shellEjectionSpawnPoint.rotation);
                }

                if(newShell.CanGetComponent<Rigidbody>(out var body)) {
                    if(AutoHandPlayer.Instance.IsHolding(gun.grabbable))
                        body.linearVelocity = AutoHandPlayer.Instance.body.linearVelocity;
                    body.linearVelocity += gun.grabbable.body.linearVelocity;
                    body.AddForce(shellEjectionDirection.forward * shellEjectionForce, ForceMode.Force);

                }
                shellLifetimeTracker.Add(newShell, ejectedBulletLifetime);
            }

        }



        void CheckBulletLifetime() {
            if(bulletLifetimeTracker.Count > 0) {
                var bulletKeys = new GameObject[bulletLifetimeTracker.Count];
                bulletLifetimeTracker.Keys.CopyTo(bulletKeys, 0);
                foreach(var bullet in bulletKeys) {
                    bulletLifetimeTracker[bullet] -= Time.deltaTime;
                    if(bulletLifetimeTracker[bullet] <= 0) {
                        bullet.SetActive(false);
                        bulletPool.Add(bullet);
                        bulletLifetimeTracker.Remove(bullet);
                    }
                }
            }

            if(shellLifetimeTracker.Count > 0) {
                var shellKeys = new GameObject[shellLifetimeTracker.Count];
                shellLifetimeTracker.Keys.CopyTo(shellKeys, 0);
                foreach(var shell in shellKeys) {
                    shellLifetimeTracker[shell] -= Time.deltaTime;
                    if(shellLifetimeTracker[shell] <= 0) {
                        shell.SetActive(false);
                        bulletShellPool.Add(shell);
                        shellLifetimeTracker.Remove(shell);
                    }
                }
            }
        }



        void CheckParticlPlaying() {
            if(inactiveParticlePool.Count > 0) {
                var playingKeys = new ParticleSystem[activeParticlePool.Count];
                activeParticlePool.CopyTo(playingKeys, 0);
                foreach(var particle in playingKeys) {
                    if(!particle.isPlaying)
                        particle.gameObject.SetActive(false);
                    inactiveParticlePool.Add(particle);
                    activeParticlePool.Remove(particle);
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGunEffects.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGunTarget.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 98c232a2f70ebaf46952b97e503b6e07
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class AutoGunTarget : MonoBehaviour {
        public GameObject hitDecal;
        public ParticleSystem hitParticle;
        public float hitDecalLifetime;
        public UnityGunHitEvent OnShotEvent;


        Dictionary<GameObject, float> decalLifetimeTracker = new Dictionary<GameObject, float>();
        List<GameObject> decalPool = new List<GameObject>();
        List<ParticleSystem> inactiveParticlePool = new List<ParticleSystem>();
        List<ParticleSystem> activeParticlePool = new List<ParticleSystem>();

        public virtual void OnShot(AutoGun gun, RaycastHit hit){
            OnShotEvent?.Invoke(gun, hit);
             CreateHitParticle(hit);
            CreateHitDecal(hit);
        }

        private void FixedUpdate() {
            CheckDecalLifetime();
            CheckParticlPlaying();

        }

        void CreateHitParticle(RaycastHit hit) {
            if(hitParticle != null) { 
                var newHitParticle = GameObject.Instantiate(hitParticle);
                newHitParticle.transform.position = hit.point;
                newHitParticle.transform.forward = hit.normal;
                activeParticlePool.Add(newHitParticle);
            }
        }
        void CreateHitDecal(RaycastHit hit) {
            if(hitDecal != null) {
                var newHitDecal = GameObject.Instantiate(hitDecal);
                newHitDecal.transform.position = hit.point;
                newHitDecal.transform.forward = hit.normal;
                decalLifetimeTracker.Add(hitDecal, hitDecalLifetime);
            }
        }

        void CheckDecalLifetime() {
            if(decalLifetimeTracker.Count > 0) {
                var decalKeys = new GameObject[decalLifetimeTracker.Count];
                decalLifetimeTracker.Keys.CopyTo(decalKeys, 0);
                foreach(var decal in decalKeys) {
                    decalLifetimeTracker[decal] -= Time.deltaTime;
                    if(decalLifetimeTracker[decal] <= 0) {
                        decal.SetActive(false);
                        decalPool.Add(decal);
                        decalLifetimeTracker.Remove(decal);
                    }
                }
            }
        }


        void CheckParticlPlaying() {
            if(inactiveParticlePool.Count > 0) {
                var playingKeys = new ParticleSystem[activeParticlePool.Count];
                activeParticlePool.CopyTo(playingKeys, 0);
                foreach(var particle in playingKeys) {
                    if(!particle.isPlaying)
                        particle.gameObject.SetActive(false);
                    inactiveParticlePool.Add(particle);
                    activeParticlePool.Remove(particle);
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/AutoGunTarget.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/GrabbableHeldJoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e4313c8dbf9d16545a3263ec0411b031
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand
{
    [RequireComponent(typeof(Grabbable)), DefaultExecutionOrder(10)]
    public class GrabbableHeldJoint : MonoBehaviour
    {
        [Tooltip("The grabbable that this grabbable is connected to")]
        public Grabbable connectedGrabbable;
        [Tooltip("Offsets the center of this joint")]
        public Vector3 pivotOffset;
        [Tooltip("This will multiply the hands strength while holding this grabbable to give it more or less positional priority while holding this joint as a second hand (good to reduce when you dont want this joint having movement priority while being held)")]
        [Min(0.1f)]
        public float heldMassScale = 1f;
        [Space]
        [Tooltip("The maximum distance this joint is allowed to move in the local positive x-axis")]
        public float xMaxLimit = 0f;
        [Tooltip("The maximum distance this joint is allowed to move in the local negative x-axis")]
        public float xMinLimit = 0f;
        [Tooltip("This will force the joint back into its center position based on the given spring strength while not being held along this axis")]
        public float xSpring = 0f;
        [Space]
        [Tooltip("The maximum distance this joint is allowed to move in the local positive y-axis")]
        public float yMaxLimit = 0f;
        [Tooltip("The maximum distance this joint is allowed to move in the local negative y-axis")]
        public float yMinLimit = 0f;
        [Tooltip("This will force the joint back into its center position based on the given spring strength while not being held along this axis")]
        public float ySpring = 0f;
        [Space]
        [Tooltip("The maximum distance this joint is allowed to move in the local positive z-axis")]
        public float zMaxLimit = 0f;
        [Tooltip("The maximum distance this joint is allowed to move in the local negative z-axis")]
        public float zMinLimit = 0f;
        [Tooltip("This will force the joint back into its center position based on the given spring strength while not being held along this axis")]
        public float zSpring = 0f;

        [Space]
        [Range(0, 1), Tooltip("The percentage from the min/max distance needed to trigger the event, good for creating a buffer for the event to trigger slightly before the max range to help prevent missed event")]
        public float eventOffset = 0.05f;

        public UnityHandGrabEvent OnMinDistanceEvent;
        public UnityHandGrabEvent OnMaxDistanceEvent;

        bool triggeredMaxEvent;
        bool triggeredMinEvent;

        Vector3 handLocalPosition;
        Vector3 localPosition;
        Vector3 localTargetPosition;
        Vector3 localStartPosition;

        Grabbable grabbable;
        Vector3 localOrigin;
        Vector3 localStartOrigin;
        Hand jointHand;
        bool grabFrame;
        bool started = false;
        public void Start()
        {
            if(started)
                return;

            ResetOrigin();

            if(grabbable == null) {
                grabbable = GetComponent<Grabbable>();
                grabbable.OnGrabEvent += OnGrabbed;
                grabbable.OnReleaseEvent += OnReleased;
            }
            grabbable.singleHandOnly = true;

            if(xMinLimit == 0 && yMinLimit == 0 && zMinLimit == 0)
                triggeredMinEvent = true;
            started = true;
        }

        public void ResetOrigin()
        {
            localOrigin = connectedGrabbable.rootTransform.InverseTransformPoint(transform.position) + pivotOffset;
            localStartOrigin = localOrigin;
        }

        internal void OnGrabbed(Hand hand, Grabbable grab)
        {
            jointHand = hand;
            hand.handFollow.minMass *= heldMassScale;
            hand.handFollow.maxMass *= heldMassScale;

            localOrigin = hand.heldJoint.connectedAnchor + pivotOffset;
            localTargetPosition = new Vector3(
                Mathf.Clamp(handLocalPosition.x, localOrigin.x + xMinLimit, localOrigin.x + xMaxLimit),
                Mathf.Clamp(handLocalPosition.y, localOrigin.y + yMinLimit, localOrigin.y + yMaxLimit),
                Mathf.Clamp(handLocalPosition.z, localOrigin.z + zMinLimit, localOrigin.z + zMaxLimit)
            );

            localTargetPosition += pivotOffset;
            grabFrame = true;
        }

        void OnReleased(Hand hand, Grabbable grab)
        {
            jointHand = null;
            hand.handFollow.minMass /= heldMassScale;
            hand.handFollow.maxMass /= heldMassScale;

            localOrigin = localStartOrigin;
        }

        private void FixedUpdate()
        {
            if(grabFrame) {
                grabFrame = false;
                return;
            }

            UpdateJoint();
        }

        public void SetJointMax() {
            transform.position = connectedGrabbable.rootTransform.TransformPoint(localOrigin + pivotOffset + new Vector3(xMaxLimit, yMaxLimit, zMaxLimit));
        }

        public void SetJointMin() {
            transform.position = connectedGrabbable.rootTransform.TransformPoint(localOrigin + pivotOffset + new Vector3(xMinLimit, yMinLimit, zMinLimit));
        }

        public void UpdateJoint()
        {
            if (connectedGrabbable.HeldCount() > 0 && grabbable.HeldCount(false, false, true) > 0 && jointHand != null)
            {
                handLocalPosition = jointHand.heldJoint.connectedBody.transform.InverseTransformPoint(jointHand.moveTo.position) + pivotOffset;
                localPosition = jointHand.heldJoint.connectedAnchor + pivotOffset;
                localTargetPosition = new Vector3(
                    Mathf.MoveTowards(localPosition.x, Mathf.Clamp(handLocalPosition.x, localOrigin.x + xMinLimit, localOrigin.x + xMaxLimit), 1f),
                    Mathf.MoveTowards(localPosition.y, Mathf.Clamp(handLocalPosition.y, localOrigin.y + yMinLimit, localOrigin.y + yMaxLimit), 1f),
                    Mathf.MoveTowards(localPosition.z, Mathf.Clamp(handLocalPosition.z, localOrigin.z + zMinLimit, localOrigin.z + zMaxLimit), 1f)
                );

                if(localPosition != localTargetPosition) {
                    //Vector3 globalTargetPosition = connectedGrabbable.rootTransform.TransformPoint(localTargetPosition - jointHand.handGrabPoint.localPosition);
                    transform.localPosition += (localTargetPosition - localPosition); // Adjusting position with pivot offset
                    transform.localPosition = new Vector3(
                        Mathf.Clamp(transform.localPosition.x, localStartOrigin.x + xMinLimit, localStartOrigin.x + xMaxLimit),
                        Mathf.Clamp(transform.localPosition.y, localStartOrigin.y + yMinLimit, localStartOrigin.y + yMaxLimit),
                        Mathf.Clamp(transform.localPosition.z, localStartOrigin.z + zMinLimit, localStartOrigin.z + zMaxLimit)
                    );
                    jointHand.heldJoint.connectedAnchor += (localTargetPosition - localPosition);
                    jointHand.handGrabPoint.localPosition += (localTargetPosition - localPosition);
                }
            }
            else
            {
                Vector3 localPosition = connectedGrabbable.transform.InverseTransformPoint(transform.position) + pivotOffset;
                Vector3 localTargetPosition = new Vector3(
                    Mathf.MoveTowards(localPosition.x, localOrigin.x, Time.fixedDeltaTime * xSpring),
                    Mathf.MoveTowards(localPosition.y, localOrigin.y, Time.fixedDeltaTime * ySpring),
                    Mathf.MoveTowards(localPosition.z, localOrigin.z, Time.fixedDeltaTime * zSpring)
                );

                if(transform.localPosition != localOrigin)
                    transform.position = connectedGrabbable.rootTransform.TransformPoint(localTargetPosition);
            }
                    
            if(OnMaxDistanceEvent != null) {
                var localPos = connectedGrabbable.rootTransform.InverseTransformPoint(transform.position);
                bool greaterOrEqual =
                    localPos.x >= localStartOrigin.x + xMaxLimit - xMaxLimit * eventOffset - 0.001f &&
                    localPos.y >= localStartOrigin.y + yMaxLimit - yMaxLimit * eventOffset - 0.001f &&
                    localPos.z >= localStartOrigin.z + zMaxLimit - zMaxLimit * eventOffset - 0.001f; 

                if(greaterOrEqual && !triggeredMaxEvent) {
                    OnMaxDistanceEvent.Invoke(jointHand, connectedGrabbable);
                    triggeredMaxEvent = true;
                    triggeredMinEvent = false;
                }
            }

            if(OnMinDistanceEvent != null) {
                var localPos = connectedGrabbable.rootTransform.InverseTransformPoint(transform.position);
                bool lessOrEqual =
                    localPos.x <= localStartOrigin.x + xMinLimit - xMinLimit * eventOffset + 0.001f &&
                    localPos.y <= localStartOrigin.y + yMinLimit - yMinLimit * eventOffset + 0.001f &&
                    localPos.z <= localStartOrigin.z + zMinLimit - zMinLimit * eventOffset + 0.001f;

                if(lessOrEqual && !triggeredMinEvent) {
                    OnMinDistanceEvent.Invoke(jointHand, connectedGrabbable);
                    triggeredMinEvent = true;
                    triggeredMaxEvent = false;
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/GrabbableHeldJoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/GrabbablePoseAnimaion.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5e0938fd494e5f74da83d0fe188a5ac1
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public enum HeldAnimationDriver {
        squeeze,
        grip,
        custom
    }

    [DefaultExecutionOrder(100000)]
    public class GrabbablePoseAnimaion : MonoBehaviour {
        public AnimationCurve animationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);
        [Tooltip("Determines the default hand value to activate this pose while it's being held")]
        public HeldAnimationDriver animationDriver = HeldAnimationDriver.squeeze;

        [NaughtyAttributes.ShowIf("animationDriver", HeldAnimationDriver.custom)]
        public float customValue;
        [Space]
        [Tooltip("The pose the hand will have by default")]
        public GrabbablePose fromPose;
        [Tooltip("The pose the hand will move to match given the animation driver value")]
        public GrabbablePose toPose;
        [Tooltip("Additional animations to run alongside the given driver value (good for things like a gun trigger that is separate from the hand but still needs to move with the hand during the animation)")]
        public AutoAnimation[] additionalAnimations;
        [Space]
        [Tooltip("The weight of the index finger in the animation - 0 means the finger will not animate, 1 means it will animate fully")]
        public float indexWeight = 1;
        [Tooltip("The weight of the middle finger in the animation - 0 means the finger will not animate, 1 means it will animate fully")]
        public float middleWeight = 1;
        [Tooltip("The weight of the ring finger in the animation - 0 means the finger will not animate, 1 means it will animate fully")]
        public float ringWeight = 1;
        [Tooltip("The weight of the pinky finger in the animation - 0 means the finger will not animate, 1 means it will animate fully")]
        public float pinkyWeight = 1;
        [Tooltip("The weight of the thumb finger in the animation - 0 means the finger will not animate, 1 means it will animate fully")]
        public float thumbWeight = 1;
        [Space]
        [Tooltip("The strength of the hand position lerping between the two poses")]
        public float handPositionWeight = 0;
        [Tooltip("The strength of the hand rotation lerping between the two poses")]
        public float handRotationWeight = 0;

        [Space]

        HandPoseData fromPoseData, toPoseData;
        HandPoseData _currentAnimationPose;

        float[] fingerWeights;

        public ref HandPoseData currentAnimationPose { get { return ref _currentAnimationPose; } }
        int lastPosingHandsCount;

        Dictionary<Hand, bool> trackWasIKEnabled = new Dictionary<Hand, bool>();

        private void OnEnable() {
            fingerWeights = new float[5];
            fingerWeights[(int)FingerEnum.index] = indexWeight;
            fingerWeights[(int)FingerEnum.middle] = middleWeight;
            fingerWeights[(int)FingerEnum.ring] = ringWeight;
            fingerWeights[(int)FingerEnum.pinky] = pinkyWeight;
            fingerWeights[(int)FingerEnum.thumb] = thumbWeight;

            if(fromPose.rightPoseSet)
                currentAnimationPose = new HandPoseData(ref fromPose.rightPose);
            else if(fromPose.leftPoseSet)
                currentAnimationPose = new HandPoseData(ref fromPose.leftPose);

            trackWasIKEnabled = new Dictionary<Hand, bool>();

        }



        public void LateUpdate() {
            var posingHandCount = fromPose.posingHands.Count + toPose.posingHands.Count;
            if(posingHandCount == 0)
                return;

            foreach(var hand in fromPose.posingHands) {
                if(hand.IsGrabbing())
                    continue;
                Animate(hand);
            }
            foreach(var hand in toPose.posingHands) {
                if(hand.IsGrabbing())
                    continue;
                Animate(hand);
            }

            if(lastPosingHandsCount != 0 && posingHandCount == 0)
                foreach(var autoAnim in additionalAnimations)
                    autoAnim.SetAnimation(0);

            lastPosingHandsCount = posingHandCount;

        }   

        public void Animate(Hand hand) {
            fromPoseData = fromPose.GetHandPoseData(hand);
            toPoseData = toPose.GetHandPoseData(hand);
            var animationValue = GetAnimationValue(hand);

            foreach(var finger in hand.fingers) {
                var fingerIndex = (int)finger.fingerType;
                if(fingerWeights[fingerIndex] == 0)
                    continue;

                currentAnimationPose.fingerPoses[fingerIndex].LerpData(ref fromPoseData.fingerPoses[fingerIndex], ref toPoseData.fingerPoses[fingerIndex], fingerWeights[fingerIndex] * animationValue);
                currentAnimationPose.fingerPoses[fingerIndex].SetFingerPose(finger);
            }

            if(handPositionWeight != 0 || handRotationWeight != 0) {
                currentAnimationPose.handOffset = Vector3.Lerp(fromPoseData.handOffset, toPoseData.handOffset, animationValue * handPositionWeight);
                currentAnimationPose.localQuaternionOffset = Quaternion.Lerp(fromPoseData.localQuaternionOffset, toPoseData.localQuaternionOffset, animationValue * handRotationWeight);
                hand.handGrabPoint.localRotation = currentAnimationPose.localQuaternionOffset;
                hand.handGrabPoint.localPosition = currentAnimationPose.handOffset;
            }

            foreach(var autoAnim in additionalAnimations)
                autoAnim.SetAnimation(animationCurve.Evaluate(animationValue));

            float GetAnimationValue(Hand hand1) {
                if(animationDriver == HeldAnimationDriver.squeeze)
                    return hand1.GetSqueezeAxis();
                else if(animationDriver == HeldAnimationDriver.grip)
                    return hand1.GetGripAxis();
                else if(animationDriver == HeldAnimationDriver.custom)
                    return customValue;

                return 0;
            }

        }



        public void Animate(Hand hand, float value) {
            HandPoseData.LerpPose(ref currentAnimationPose, ref fromPose.GetHandPoseData(hand), ref toPose.GetHandPoseData(hand), value);
            currentAnimationPose.handOffset = Vector3.Lerp(fromPoseData.handOffset, toPoseData.handOffset, value);
            currentAnimationPose.localQuaternionOffset = Quaternion.Lerp(fromPoseData.localQuaternionOffset, toPoseData.localQuaternionOffset, value);
            currentAnimationPose.SetPose(hand);
        }
    }

}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/GrabbablePoseAnimaion.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/HeldPlaceJoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 37ad27b092cab5640be450a446fb23b8
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HeldPlaceJoint : PlacePoint {

        [AutoHeader("Held Place Joint")]
        public bool ignoreMe1;
        public Grabbable connectedGrabbable;
        public Vector3 pivotOffset;
        public float heldMassScale = 1f;
        [Space]
        public float xMaxLimit = 0f;
        public float xMinLimit = 0f;
        public float xSpring = 0f;
        [Space]
        public float yMaxLimit = 0f;
        public float yMinLimit = 0f;
        public float ySpring = 0f;
        [Space]
        public float zMaxLimit = 0f;
        public float zMinLimit = 0f;
        public float zSpring = 0f;

        [Space]
        [Range(0, 1), Tooltip("The percentage from the min/max distance needed to trigger the event, good for creating a buffer for the event to trigger slightly before the max range to help prevent missed event")]
        public float eventOffset = 0.05f;
        public UnityHandGrabEvent OnMinDistanceEvent;
        public UnityHandGrabEvent OnMaxDistanceEvent;

        GrabbableHeldJoint heldJoint = null;


        protected  void Start() {
            //base.Start();
            //heldPlaceOnly = true;
            disableRigidbodyOnPlace = false;
            parentOnPlace = true;
            forceHandRelease = false;
            makePlacedKinematic = false;
            forcePlace = true;
            
        }

        public override bool CanPlace(Grabbable placeObj, bool checkRoot = true) {
            if(placeObj.body == connectedGrabbable.body)
                return false;

            return base.CanPlace(placeObj);
        }


        public override void Place(Grabbable placeObj) {

            Debug.Log("Place");
            Dictionary<Hand, Transform> grabPoint = new Dictionary<Hand, Transform>();
            var hands = new Hand[(placeObj.GetHeldBy().Count)];
            placeObj.GetHeldBy().CopyTo(hands, 0);

            placeObj.transform.position = placedOffset.position;
            placeObj.transform.rotation = placedOffset.rotation;

            foreach(var hand in hands) {
                grabPoint.Add(hand, hand.handGrabPoint);
            }

            base.Place(placeObj);

            foreach(var hand in hands) {
                //hand.BreakGrabConnection();
                //hand.CreateGrabConnection(placeObj, grabPoint[hand].position, grabPoint[hand].rotation, placeObj.transform.position, placeObj.transform.rotation, true);
                hand.heldJoint.connectedBody = connectedGrabbable.body;
                hand.heldJoint.connectedAnchor = connectedGrabbable.body.transform.InverseTransformPoint(hand.handGrabPoint.position);
            }

            placeObj.DeactivateRigidbody();
            placeObj.transform.parent = connectedGrabbable.body.transform;
            placeObj.body = connectedGrabbable.body;

            if(heldJoint == null) {
                heldJoint = placeObj.gameObject.AddComponent<GrabbableHeldJoint>();
                heldJoint.connectedGrabbable = connectedGrabbable;
                heldJoint.xMaxLimit = xMaxLimit;
                heldJoint.xMinLimit = xMinLimit;
                heldJoint.xSpring = xSpring;

                heldJoint.yMaxLimit = yMaxLimit;
                heldJoint.yMinLimit = yMinLimit;
                heldJoint.ySpring = ySpring;

                heldJoint.zMaxLimit = zMaxLimit;
                heldJoint.zMinLimit = zMinLimit;
                heldJoint.zSpring = zSpring;

                heldJoint.eventOffset = eventOffset;
                heldJoint.OnMaxDistanceEvent = OnMaxDistanceEvent;
                heldJoint.OnMinDistanceEvent = OnMinDistanceEvent;
                heldJoint.Start();
                if(hands.Length > 0)
                    heldJoint.OnGrabbed(hands[0], placeObj);

                heldJoint.UpdateJoint();
            }
        }

        public override void Remove(Grabbable placeObj) {
            Debug.Log("Remove");
            if(heldJoint != null) {
                Destroy(heldJoint);
                heldJoint = null;
            }

            base.Remove(placeObj);

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/HeldPlaceJoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/PlaceJoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b38d62fde75c6ff4ba1f4742da2c3d3a
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class PlaceJoint : PlacePoint {
        [Tooltip("This is for connecting grabbables together, leave empty if using a static")]
        public Grabbable localGrabbable;
        public Rigidbody localRigidbody;
        public Vector3 anchor;
        public Vector3 axis = Vector3.right;
        public bool autoConfigureConnection = true;
        public Vector3 connectedAnchor;
        public Vector3 secondaryAxis = Vector3.up;
        public ConfigurableJointMotion xMotion, yMotion, zMotion;
        public ConfigurableJointMotion angularXMotion, angularYMotion, angularZMotion;
        [SerializeField]
        public SerializedSoftJointLimitSpring linearLimitSpring;
        [SerializeField]
        public SerializedSoftJointLimit linearLimit;
        [SerializeField]
        public SerializedSoftJointLimitSpring angularXLimitSpring;
        public SerializedSoftJointLimit lowAngularXLimit;
        public SerializedSoftJointLimit highAngularXLimit;
        public SerializedSoftJointLimitSpring angularYZLimitSpring;
        public SerializedSoftJointLimit angularYLimit;
        public SerializedSoftJointLimit angularZLimit;
        public Vector3 targetPosition;
        public Vector3 targetVelocity;
        public SerializedJointDrive xDrive;
        public SerializedJointDrive yDrive;
        public SerializedJointDrive zDrive;
        public Vector3 targetAngularVelocity;
        public RotationDriveMode rotationDriveMode;
        public SerializedJointDrive angularXDrive;
        public SerializedJointDrive angularYZDrive;
        public SerializedJointDrive slerpDrive;
        public JointProjectionMode projectionMode = JointProjectionMode.PositionAndRotation;
        public float projectionDistance = 0f;
        public float projectionAngle = 0;
        public bool configuredInWorldSpace;
        public bool swapBodies;


        public bool enableCollision = false;
        public bool enablePreprocessing = true;
        public float breakForce = float.PositiveInfinity;
        public float breakTorque = float.PositiveInfinity;
        public float massScale = 1;
        public float connectedMassScale = 1;
        [Range(1, 255), Tooltip("The solver iterations to use while a placeJoint is connected, higher is higher quality joint stability but more expensive 1-255")]
        public int solverIterations = 100;
        [Range(1, 255), Tooltip("The velocity solver iterations to use while a placeJoint is connected, higher is higher quality joint stability but more expensive 1-255")]
        public int velocitySolverIterations = 100;

        Quaternion targetRotation = Quaternion.identity;
        ConfigurableJoint connectionJoint = null;

        Vector3 prePlacedPos;
        Quaternion prePlacedRot;


        protected void Start() {
            //base.Start();
            base.makePlacedKinematic = false;
            base.placedJointLink = null;
        }
        public override void Highlight(Grabbable placeObj) {
            base.Highlight(placeObj);
        }

        public override bool CanPlace(Grabbable placeObj, bool checkRoot = true) {
            return base.CanPlace(placeObj) && placeObj.body != localRigidbody;
        }

        //protected override void OnEnable() {
        //    base.OnEnable();
        //    if(localGrabbable != null)
        //        localGrabbable.OnReleaseEvent += OnReleased;
        //}

        //protected override void OnDisable() {
        //    base.OnDisable();
        //    if(localGrabbable != null)
        //        localGrabbable.OnReleaseEvent -= OnReleased;
        //}
        //void OnReleased(Hand hand, Grabbable grab) {
        //    if(localGrabbable != null) {
        //        Remove();
        //    }
        //}

        public override void Place(Grabbable placeObj) {
            prePlacedPos = placeObj.transform.position;
            prePlacedRot = placeObj.transform.rotation;

            base.Place(placeObj);
            if(connectionJoint == null && placedObject != null) {
                CreateConnection(placeObj);
            }

            if(localGrabbable) {
                if (localGrabbable.body != null)
                {
                    localGrabbable.body.linearVelocity = Vector3.zero;
                    localGrabbable.body.angularVelocity = Vector3.zero;
                }
                for(int i = 0; i < localGrabbable.jointedBodies.Count; i++) {
                    localGrabbable.jointedBodies[i].linearVelocity = Vector3.zero;
                    localGrabbable.jointedBodies[i].angularVelocity = Vector3.zero;
                }
            }

        }

        private void FixedUpdate() {
            if(placedObject != null) {
                if(connectionJoint == null)
                    Remove(placedObject);
            }
        }


        
        public override void Remove(Grabbable placeObj) {
            if(localGrabbable != null && localGrabbable.body != null)
                localGrabbable.RemoveJointedBody(placeObj.body);
            placeObj.RemoveJointedBody(localRigidbody);

            if(connectionJoint != null) {
                Destroy(connectionJoint);
                connectionJoint = null;
            }

            localRigidbody.solverIterations = Physics.defaultSolverIterations;
            localRigidbody.solverVelocityIterations = Physics.defaultSolverVelocityIterations;
            base.Remove(placeObj);

        }

        Vector3 pregrabPos;
        Quaternion pregrabRot;
        public void CreateConnection(Grabbable connection) {
            if(localRigidbody != null) {
                connection.AddJointedBody(localRigidbody);
                if(localGrabbable != null && localGrabbable.body != null)
                    localGrabbable.AddJointedBody(connection.body);
            }

            localRigidbody.solverIterations = solverIterations;
            localRigidbody.solverVelocityIterations = velocitySolverIterations;
            connectionJoint = connection.gameObject.AddComponent<ConfigurableJoint>();
            connectionJoint.connectedBody = localRigidbody;
            connectionJoint.anchor = anchor;
            connectionJoint.axis = axis;
            connectionJoint.autoConfigureConnectedAnchor = false;
            connectionJoint.connectedAnchor = Vector3.zero;
            connectionJoint.secondaryAxis = secondaryAxis;
            connectionJoint.xMotion = xMotion;
            connectionJoint.yMotion = yMotion;
            connectionJoint.zMotion = zMotion;
            connectionJoint.angularXMotion = angularXMotion;
            connectionJoint.angularYMotion = angularYMotion;
            connectionJoint.angularZMotion = angularZMotion;
            connectionJoint.linearLimitSpring = linearLimitSpring;
            connectionJoint.linearLimit = linearLimit;
            connectionJoint.angularXLimitSpring = angularXLimitSpring;
            connectionJoint.lowAngularXLimit = lowAngularXLimit;
            connectionJoint.highAngularXLimit = highAngularXLimit;
            connectionJoint.angularYZLimitSpring = angularYZLimitSpring;
            connectionJoint.angularYLimit = angularYLimit;
            connectionJoint.angularZLimit = angularZLimit;
            connectionJoint.targetPosition = targetPosition;
            connectionJoint.targetVelocity = targetVelocity;
            connectionJoint.xDrive = xDrive;
            connectionJoint.yDrive = yDrive;
            connectionJoint.zDrive = zDrive;
            connectionJoint.targetAngularVelocity = targetAngularVelocity;
            connectionJoint.rotationDriveMode = rotationDriveMode;
            connectionJoint.angularXDrive = angularXDrive;
            connectionJoint.angularYZDrive = angularYZDrive;
            connectionJoint.slerpDrive = slerpDrive;
            connectionJoint.projectionMode = projectionMode;
            connectionJoint.projectionDistance = projectionDistance;
            connectionJoint.projectionAngle = projectionAngle;
            connectionJoint.configuredInWorldSpace = configuredInWorldSpace;
            connectionJoint.swapBodies = swapBodies;
            connectionJoint.enableCollision = enableCollision;
            connectionJoint.enablePreprocessing = enablePreprocessing;
            connectionJoint.breakForce = breakForce;
            connectionJoint.breakTorque = breakTorque;
            connectionJoint.massScale = massScale;
            connectionJoint.connectedMassScale = connectedMassScale;
        }


        public void Destroyjoint()
        {
            if (connectionJoint != null)
            {
                Destroy(connectionJoint);
                if (localGrabbable != null)
                    localGrabbable.RemoveJointedBody(placedObject.body);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/BETA/PlaceJoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/BowlingManager.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d7e43f3b6c658e442868b907c090b2de
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BowlingManager : MonoBehaviour
{
    [Header("Bowling Ball Settings")]
    public GameObject bowlingBall;

    [Header("Bowling Pin Settings")]
    public Vector3 pinCenter;
    public float pinSpaceX;
    public float pinSpaceZ;

    public List<GameObject> pins = new List<GameObject>();

    public Vector3 ballPosition;
    private void Start()
    {
        ballPosition = bowlingBall.transform.position;
        ResetPins();
    }

    public void ResetBall()
    {
        bowlingBall.GetComponent<Rigidbody>().isKinematic = true;
        bowlingBall.transform.position = ballPosition;
        bowlingBall.GetComponent<Rigidbody>().isKinematic = false;
    }

    public void ResetPins()
    {
        int max = (pins.Count / 2) - 2;
        int topRow = (pins.Count / 2) - 2; ;
        int row = 0;

        float currentX = pinCenter.x;
        float currentZ = pinCenter.z;

        for (int i = 0; i < pins.Count; i++)
        {
            pins[i].GetComponent<Rigidbody>().isKinematic = true;

            pins[i].transform.rotation = Quaternion.Euler(0, 0, 0);
            pins[i].transform.position = new Vector3(currentX, pinCenter.y, currentZ);

            pins[i].GetComponent<Rigidbody>().isKinematic = false;

            currentZ += pinSpaceZ;

            if (row == topRow)
            {
                topRow--;
                row = 0;

                currentZ = pinCenter.z + ((pinSpaceZ / 2) * (max - topRow));
                currentX = pinCenter.x + (pinSpaceX * (max - topRow));
            }
            else
            {
                row++;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/BowlingManager.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/BoxingGlove.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7c3f28cbd7ab11d44be4bb0f35e485c3
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {
    public class BoxingGlove : MonoBehaviour {
        public Rigidbody body;
        public float power = 2f;

        float lastHitTime;
        float delay = 1f;

        public void OnCollisionEnter(Collision collision) {
            if(lastHitTime + delay < Time.fixedTime) {
                collision.rigidbody?.AddForce(body.linearVelocity * power);
                lastHitTime = Time.fixedTime;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/BoxingGlove.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Briefcase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bcba248aa04eb1e46ac301e7773478b6
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Briefcase : MonoBehaviour
{
    public Grabbable grabbable;
    public Transform openCloseTransform;

    public float openCloseSpeed = 1;
    public AnimationCurve openCloseCurve;

    public float openAngle = 110;
    public float closeAngle = -10;

    bool isOpen = true;
    float openCloseState = 1;

    Vector3 targetOpenRotation;
    Vector3 targetCloseRotation;


    private void OnEnable() {
        targetOpenRotation = new Vector3(openAngle, 0, 0);
        targetCloseRotation = new Vector3(closeAngle, 0, 0);
        openCloseState = isOpen ? 1 : 0;
        openCloseTransform.localRotation = Quaternion.Euler(Vector3.Lerp(targetCloseRotation, targetOpenRotation, openCloseCurve.Evaluate(openCloseState)));
    }

    public void Open() {
        isOpen = true;
    }

    public void Close() {
        isOpen = false;
    }


    void Update() {
        if(isOpen && openCloseState < 1) {
            openCloseState += Time.deltaTime * openCloseSpeed;
            openCloseState = Mathf.Clamp01(openCloseState);
            openCloseTransform.localRotation = Quaternion.Euler(Vector3.Lerp(targetCloseRotation, targetOpenRotation, openCloseCurve.Evaluate(openCloseState)));
            if(openCloseState >= 1) {
                OnOpen();
            }
        }
        else if(!isOpen && openCloseState > 0) {
            openCloseState -= Time.deltaTime * openCloseSpeed;
            openCloseState = Mathf.Clamp01(openCloseState);
            openCloseTransform.localRotation = Quaternion.Euler(Vector3.Lerp(targetCloseRotation, targetOpenRotation, openCloseCurve.Evaluate(openCloseState)));
            if(openCloseState <= 0) {
                OnClose();
            }
        }
    }


    public void OnOpen() {
        foreach(var placepoint in grabbable.childPlacePoints) {
            placepoint.enabled = true;
        }
    }


    public void OnClose() {
        foreach(var placepoint in grabbable.childPlacePoints) {
            placepoint.enabled = false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Briefcase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/CubeBreak.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a929b8a9aed45794ca106c9d0498b3b2
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;

namespace Autohand.Demo{
    public class CubeBreak : MonoBehaviour{
        public float force = 10f;
        Vector3[] offsets = { new Vector3(0.25f, 0.25f, 0.25f), new Vector3(-0.25f, 0.25f, 0.25f), new Vector3(0.25f, 0.25f, -0.25f), new Vector3(-0.25f, 0.25f, -0.25f),
                            new Vector3(0.25f, -0.25f, 0.25f), new Vector3(-0.25f, -0.25f, 0.25f), new Vector3(0.25f, -0.25f, -0.25f), new Vector3(-0.25f, -0.25f, -0.25f),};
        [ContextMenu("Break")]
        public void Break() {
            for(int i = 0; i < 8; i++) {
                var smallerCopy = Instantiate(gameObject, transform.position, transform.rotation);
                foreach(var joint in smallerCopy.GetComponents<FixedJoint>()) {
                    Destroy(joint);
                }
                try{
                    smallerCopy.transform.parent = transform;
                }
                catch { }
                smallerCopy.transform.localPosition += offsets[i];
                smallerCopy.transform.parent = null;
                smallerCopy.transform.localScale = transform.localScale/2f;
                smallerCopy.layer = LayerMask.NameToLayer(Hand.grabbableLayerNameDefault);
                var body = smallerCopy.GetComponent<Rigidbody>();
                body.ResetCenterOfMass();
                body.ResetInertiaTensor();
                body.linearVelocity = GetComponent<Rigidbody>().linearVelocity;
                body.AddRelativeForce(transform.rotation*(offsets[i]*force), ForceMode.Impulse);
                body.AddRelativeTorque(transform.rotation*(offsets[i]*force + Vector3.one*(Random.value/3f)), ForceMode.Impulse);
                body.mass /= 2;
                smallerCopy.GetComponent<Grabbable>().jointBreakForce /= 2;
                if(smallerCopy.transform.localScale.x < 0.03f)
                    smallerCopy.GetComponent<Grabbable>().singleHandOnly = true;
            }
            Destroy(gameObject);
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/CubeBreak.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/DemoExitCondition.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5b27bab7ee6c6804abfd2d9685544d01
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class DemoExitCondition : MonoBehaviour
{
    void Update(){
        if (Input.GetKeyDown(KeyCode.Space)){
            SceneManager.LoadScene(SceneManager.GetActiveScene().name);
        }
        if (Input.GetKeyDown(KeyCode.Escape)){
            Application.Quit();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/DemoExitCondition.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/DemoFlyingToggle.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c012a21fdec3be0429e787f0e12bebd5
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {
    public class DemoFlyingToggle : MonoBehaviour {
        public void ToggleFlying() {
            AutoHandPlayer.Instance.ToggleFlying();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/DemoFlyingToggle.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Door.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a9e9c10705da8584586d2507228a934e
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand.Demo{
    public class Door : PhysicsGadgetHingeAngleReader
    {
        [Header("Door should start closed")]
        public Rigidbody body;
        Vector3 closedPosition;
        Quaternion closedRotation;
        
        [Tooltip("The door needs to reach this level of open before it can be reset")]
        public float minThreshold = 0.05f;
        public float midThreshold = 0.05f;
        [Tooltip("The door needs to reach this level of open before it can be reset")]
        public float maxThreshold = 0.05f;
        [Space]
        public UnityEvent OnMax;
        public UnityEvent OnMid;
        public UnityEvent OnMin;
        
        bool min = false;
        bool max = false;
        bool mid = true;

        private void Awake(){
            if(!body && GetComponent<Rigidbody>())
                body = GetComponent<Rigidbody>();
            
            closedPosition = transform.position;
            closedRotation = transform.rotation;
        }

        protected void FixedUpdate(){
            if(!max && mid && GetValue()+maxThreshold >= 1) {
                Max();
            }

            if(!min && mid && GetValue()-minThreshold <= -1){
                Min();
            }
        
            if (GetValue() <= midThreshold && max && !mid) {
                Mid();
            }

            if (GetValue() >= -midThreshold && min && !mid) {
                Mid();
            }
        }


        void Max(){
            mid = false;
            max = true;
            OnMax?.Invoke();
        }

        void Mid(){
            min = false;
            max = false;
            mid = true;
            OnMid?.Invoke();
        }

        void Min() {
            min = true;
            mid = false;
            OnMin?.Invoke();
        }

        public void ClosedDoor() {
            transform.position = closedPosition;
            transform.rotation = closedRotation;
            if(body.collisionDetectionMode == CollisionDetectionMode.ContinuousDynamic)
                body.collisionDetectionMode = CollisionDetectionMode.Continuous;
            body.isKinematic = true;
        }

        private void OnDrawGizmosSelected() {
            if(!body && GetComponent<Rigidbody>())
                body = GetComponent<Rigidbody>();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Door.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ExplosionSource.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4757631d9b63da44ba986db68e9cd6d5
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;

namespace Autohand.Demo{
    public class ExplosionSource : MonoBehaviour{
        public float radius = 1;
        public float force = 10;

        public void Explode(bool destroy) {
            var hits = Physics.OverlapSphere(transform.position, radius);
            foreach(var hit in hits) {
                var rb = hit.GetComponent<Rigidbody>();
                if(rb != null)
                    rb.AddExplosionForce(force, transform.position, radius);
            }
            if(destroy)
                Destroy(gameObject);
        }

        private void OnDrawGizmosSelected() {
            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(transform.position, radius);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ExplosionSource.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Grenade.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4249cc9f1f9401b48af7156044fcd45d
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand.Demo {
    public class Grenade : MonoBehaviour {
        public Grabbable grenade;
        public Grabbable pin;
        public ConfigurableJoint pinJoint;
        public float explosionDelay = 2;
        public bool startDelayOnRelease = false;
        public float explosionForce = 100;
        public float explosionRadius = 10;
        public float pinJointStrength = 750f;
        public GameObject explosionEffect;
        public UnityEvent pinBreakEvent;
        public UnityEvent explosionEvent;

        private void OnEnable() {
            pin.isGrabbable = false;
            grenade.OnGrabEvent += OnGrenadeGrab;
            grenade.OnReleaseEvent += OnGrenadeRelease;
            pin.OnGrabEvent += OnPinGrab;
            pin.OnReleaseEvent += OnPinRelease;
            if(!grenade.jointedBodies.Contains(pin.body))
                grenade.jointedBodies.Add(pin.body);
            if(!pin.jointedBodies.Contains(grenade.body))
                pin.jointedBodies.Add(grenade.body);
        }

        private void OnDisable() {
            grenade.OnGrabEvent -= OnGrenadeGrab;
            grenade.OnReleaseEvent -= OnGrenadeRelease;
            pin.OnGrabEvent -= OnPinGrab;
            pin.OnReleaseEvent -= OnPinRelease;
        }

        void OnGrenadeGrab(Hand hand, Grabbable grab) {
            if(pinJoint != null) {
                pin.isGrabbable = true;
            }
        }

        void OnGrenadeRelease(Hand hand, Grabbable grab) {
            if(pinJoint != null) {
                pin.isGrabbable = false;
            }
            if(grenade != null && startDelayOnRelease)
                Invoke("CheckJointBreak", explosionDelay + Time.fixedDeltaTime * 3);

        }
        void OnPinGrab(Hand hand, Grabbable grab) {
            if(pinJoint != null) {
                pinJoint.breakForce = pinJointStrength;
            }
        }

        void OnPinRelease(Hand hand, Grabbable grab) {
            if(pinJoint != null) {
                pinJoint.breakForce = 100000;
            }

        }

        private void OnJointBreak(float breakForce) {
            Invoke("CheckJointBreak", Time.fixedDeltaTime*2);
        }

        void CheckJointBreak() {
            if(pinJoint == null) {
                pin.maintainGrabOffset = false;
                pin.RemoveJointedBody(grenade.body);
                grenade.RemoveJointedBody(pin.body);
                if(!startDelayOnRelease)
                    Invoke("Explode", explosionDelay);
            }

        }
        
        void Explode() {
            var hits = Physics.OverlapSphere(grenade.transform.position, explosionRadius);
            foreach(var hit in hits) {
                if(AutoHandPlayer.Instance.body == hit.attachedRigidbody) {
                    AutoHandPlayer.Instance.DisableGrounding(0.05f);
                    var dist = Vector3.Distance(hit.attachedRigidbody.position, grenade.transform.position);
                    explosionForce *= 2;
                    hit.attachedRigidbody.AddExplosionForce(explosionForce - explosionForce * (dist / explosionRadius), grenade.transform.position, explosionRadius);
                    explosionForce /= 2;
                }
                if(hit.attachedRigidbody != null) {
                    var dist = Vector3.Distance(hit.attachedRigidbody.position, grenade.transform.position);
                    hit.attachedRigidbody.AddExplosionForce(explosionForce - explosionForce * (dist / explosionRadius), grenade.transform.position, explosionRadius);
                }
            }
            explosionEvent?.Invoke();
            GameObject.Instantiate(explosionEffect, grenade.transform.position, grenade.transform.rotation);
            GameObject.Destroy(grenade.gameObject);

        }

        private void OnDrawGizmosSelected() {
            Gizmos.color = Color.red;
            if(grenade != null)
            Gizmos.DrawWireSphere(grenade.transform.position, explosionRadius);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Grenade.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/HandPoseCopier.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 20185548f02bd944aad89f2d1dc25e8c
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand
{
    public class HandPoseCopier : MonoBehaviour
    {
        public HandPoseDataContainer handPose;
        public Hand hand;

        [ContextMenu("Copy Pose To Hand")]
        public void CopyPoseToHand() {
              if(handPose == null || hand == null)
                return;

              handPose.SetHandPose(hand);
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/HandPoseCopier.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/HandSwapper.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6872f4b57dc44634aaf0c10b5453d1d8
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {
public class HandSwapper : MonoBehaviour{
        public AutoHandPlayer player;
        public Hand fromHand;
        public Hand toHand;
        public GameObject fromModel;
        public GameObject toModel;

        bool swapped;
        public void Swap() {
            if(!swapped){
                if (toHand.left)
                    player.handLeft = toHand;
                else
                    player.handRight = toHand;

                fromHand.gameObject.SetActive(false);
                fromModel.gameObject.SetActive(true);
                toHand.gameObject.SetActive(true);
                toModel.gameObject.SetActive(false);
            }
            else { 
                if (fromHand.left)
                    player.handLeft = fromHand;
                else
                    player.handRight = fromHand;

                fromHand.gameObject.SetActive(true); 
                fromModel.gameObject.SetActive(false);
                toHand.gameObject.SetActive(false);
                toModel.gameObject.SetActive(true);

            }
            swapped = !swapped;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/HandSwapper.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/JointBreakStopForce1.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8086b3ff476e1fb46be04ba055c7a906
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class JointBreakStopForce1 : MonoBehaviour
    {

        void OnJointBreak(float breakForce) {
            if(gameObject.CanGetComponent(out Rigidbody body)) {
                body.linearVelocity = Vector3.zero;
                body.angularVelocity = Vector3.zero;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/JointBreakStopForce1.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/OpenLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f8536c35c369f2f4cadf9c7299e8e16c
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class OpenLink : MonoBehaviour
{
    public string URL;
    public void OpenLinkURL() {
        Application.OpenURL(URL);
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/OpenLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Pistol.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d5aa5c06028015b45918ad5dbbefc548
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class Pistol : MonoBehaviour
    {
        public Rigidbody body;

        public Transform barrelTip;
        public float hitPower = 1;
        public float recoilPower = 1;
        public float range = 100;
        public LayerMask layer;

        public AudioClip shootSound;
        public float shootVolume = 1f;

        private void Start() {
            if(body == null && GetComponent<Rigidbody>() != null)
                body = GetComponent<Rigidbody>();
        }

        public void Shoot() {
            //Play the audio sound
            if(shootSound)
                AudioSource.PlayClipAtPoint(shootSound, transform.position, shootVolume);

            RaycastHit hit;
            if(Physics.Raycast(barrelTip.position, barrelTip.forward, out hit, range, layer)){
                var hitBody = hit.transform.GetComponent<Rigidbody>();
                if(hitBody != null) {
                    Debug.DrawRay(barrelTip.position, (hit.point - barrelTip.position), Color.green, 5);
                    hitBody.GetComponent<Smash>()?.DoSmash();
                    hitBody.AddForceAtPosition((hit.point - barrelTip.position).normalized*hitPower*10, hit.point, ForceMode.Impulse);
                }
            }
            else
                Debug.DrawRay(barrelTip.position, barrelTip.forward*range, Color.red, 1);

            body.AddForce(barrelTip.transform.up*recoilPower*5, ForceMode.Impulse);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Pistol.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/PlatformMover.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c683db686df4f834bb6ad25857a3b7de
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlatformMover : MonoBehaviour
{
    public Vector3 toRange;
    public float time = 1;

    Vector3 startPos;
    // Start is called before the first frame update
    void Start() {
        startPos = transform.position;
        StartCoroutine(Move());
    }

    IEnumerator Move() {
        while (true) {
            var timePassed = 0f;
            while(timePassed < time){
                timePassed += Time.fixedDeltaTime;
                transform.position = Vector3.Lerp(startPos, startPos+toRange, timePassed/time);
                yield return new WaitForEndOfFrame();
            }
            transform.position = toRange;

            timePassed = 0f;
            while(timePassed < time){
                timePassed += Time.fixedDeltaTime;
                transform.position = Vector3.Lerp(startPos + toRange, startPos, timePassed/time);
                yield return new WaitForEndOfFrame();
            }
            transform.position = toRange;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/PlatformMover.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/PlayerFallCatcher.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 573626c2803a9f04aa9674af69754045
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Autohand.Demo{
    public class PlayerFallCatcher : MonoBehaviour{
        Vector3 startPos;

        void Start(){
            if(AutoHandPlayer.Instance != null) {
                startPos = AutoHandPlayer.Instance.transform.position;
                if(!SceneManager.GetActiveScene().name.ToLower().Contains("demo"))
                    enabled = false;
            }
        }
        
        void FixedUpdate() {
            if(AutoHandPlayer.Instance != null) {
                if(AutoHandPlayer.Instance.transform.position.y < -10f) {
                    AutoHandPlayer.Instance.SetPosition(startPos);
                }
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/PlayerFallCatcher.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ReloadSceneByName.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8b3f69fa09888e34a8f0c5bb6f2fd3dc
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class ReloadSceneByName : MonoBehaviour
{
    public string sceneName;

    public void ReloadScene()
    {
        SceneManager.LoadScene(sceneName);
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ReloadSceneByName.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ScaleHighlight.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 33617aa892a81454485697364fce6613
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class ScaleHighlight : MonoBehaviour{
        public Vector3 highlighScale;
        public Vector3 normalScale;

        public void Highlight() {
            transform.localScale = highlighScale;
        }

        public void HighlightStop() {
            transform.localScale = normalScale;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ScaleHighlight.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Spinner.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e0ac23cfaa9b1534d9d5af4b6fe6a38f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class Spinner : MonoBehaviour{
        public Vector3 rotationSpeed;

        void FixedUpdate()
        {
            transform.Rotate(rotationSpeed * Time.fixedDeltaTime/2f);
        }

        void Update()
        {
            transform.Rotate(rotationSpeed * Time.deltaTime/2f);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/Spinner.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ToggleAutoMoveFlying.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b5e2349f27d04b74c8c691ab00cbcd1a
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo {
    public class ToggleAutoMoveFlying : MonoBehaviour {
        public void ToggleFlying() {
            var player = AutoHandExtensions.CanFindObjectOfType<AutoHandPlayer>();
            player.useGrounding = !player.useGrounding;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ToggleAutoMoveFlying.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ToggleHandProjection.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 33d078add29c26a4099661b6e0fc25d9
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo
{
    public class ToggleHandProjection : MonoBehaviour
    {
        public void DisableGripProjection()
        {
            var projections = AutoHandExtensions.CanFindObjectsOfType<HandProjector>(true);

            foreach (var projection in projections)
            {
                projection.gameObject.SetActive(false);
                if (projection.useGrabTransition)
                    projection.enabled = false;
            }
        }

        public void EnableGripProjection()
        {
            var projections = AutoHandExtensions.CanFindObjectsOfType<HandProjector>(true);
            foreach (var projection in projections)
            {
                projection.gameObject.SetActive(true);
                if (projection.useGrabTransition)
                    projection.enabled = true;
            }
        }

        public void DisableHighlightProjection()
        {
            var projections = AutoHandExtensions.CanFindObjectsOfType<HandProjector>(true);
            foreach (var projection in projections)
            {
                projection.gameObject.SetActive(false);
                if (!projection.useGrabTransition)
                    projection.enabled = false;
            }
        }

        public void EnableHighlightProjection()
        {
            var projections = AutoHandExtensions.CanFindObjectsOfType<HandProjector>(true);

            foreach (var projection in projections)
            {
                projection.gameObject.SetActive(true);
                if (!projection.useGrabTransition)
                    projection.enabled = true;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/ToggleHandProjection.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/TomatoSpawner.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: a2088b237456a2c43a11e0ba06470e50
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
public class TomatoSpawner : MonoBehaviour{
    public GameObject[] tomatoes;
    List<GameObject> copies;

    void Start(){
        copies = new List<GameObject>();
        foreach(var tomato in tomatoes) {
            var newTomato = Instantiate(tomato, tomato.transform.position, tomato.transform.rotation);
            newTomato.transform.position += new Vector3(0, 0.2f, 0);
            newTomato.SetActive(false);
            copies.Add(newTomato);
            
        }
    }

    public void SpawnTomato() {
        int i = Random.Range(0, copies.Count-1);
        Instantiate(copies[i], copies[i].transform.position, copies[i].transform.rotation).SetActive(true);
    }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/TomatoSpawner.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/UnlockChest.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 060a595b650563245bdcfab5935ba6a3
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo
{
    public class UnlockChest : MonoBehaviour
    {
        public PlacePoint placePoint;

        public HingeJoint joint;

        public void Start()
        {
            placePoint.OnPlaceEvent += (PlacePoint point, Grabbable grab) => {
                Unlock();
                grab.body.detectCollisions = false;
            };
        }

        public void Unlock()
        {
            joint.limits = new JointLimits
            {
                bounceMinVelocity = joint.limits.bounceMinVelocity,
                bounciness = joint.limits.bounciness,
                contactDistance = joint.limits.contactDistance,
                min = 0,
                max = 160
            };
            joint.spring = new JointSpring() { spring = 5, targetPosition = 160 };
        }

        public void Lock()
        {
            joint.limits = new JointLimits
            {
                bounceMinVelocity = joint.limits.bounceMinVelocity,
                bounciness = joint.limits.bounciness,
                contactDistance = joint.limits.contactDistance,
                min = -2,
                max = 2
            };
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Demo Scene/UnlockChest.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/ButtonDemoRespawn.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0c3308b24daf7e746813f1558f8d877c
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Autohand.Demo{
    public class ButtonDemoRespawn : MonoBehaviour{
        public Transform root;

        List<Transform> respawns = new List<Transform>();

        List<Vector3> startPos;
        List<Quaternion> startRot;


        void Start(){

            startPos = new List<Vector3>();
            startRot = new List<Quaternion>();

            for (int i = 0; i < root.childCount; i++){
                respawns.Add(root.GetChild(i));
                startPos.Add(root.GetChild(i).transform.position);
                startRot.Add(root.GetChild(i).transform.rotation);
                for (int j = 0; j < root.GetChild(i).childCount; j++){
                    respawns.Add(root.GetChild(i).GetChild(j));
                    startPos.Add(root.GetChild(i).GetChild(j).transform.position);
                    startRot.Add(root.GetChild(i).GetChild(j).transform.rotation);
                }
            }
        }

        public void Respawn() {
            for(int i = 0; i < respawns.Count; i++) {
                try {
                    if (respawns[i].CanGetComponent(out Rigidbody body)){
                        body.linearVelocity = Vector3.zero;
                        body.angularVelocity = Vector3.zero;
                        body.ResetInertiaTensor();
                    }
                    respawns[i].transform.position = startPos[i];
                    respawns[i].transform.rotation = startRot[i];
                }
                catch { }
            }
        }

        public void ReloadScene() {
            SceneManager.LoadScene(SceneManager.GetActiveScene().name);
        }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/ButtonDemoRespawn.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/DialHandScaler.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1f4b70a8134140646914d4825d4a6617
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class DialHandScaler : PhysicsGadgetHingeAngleReader{
        public Hand hand;
        public Vector3 minScale;
        public Vector3 maxScale;

        float startReach;
        Vector3 startScale;
        float[] fingersStartScale;
        Vector3 lastHandScale;

        new protected void Start() {
            base.Start();
            startScale = hand.transform.localScale;
            startReach = hand.reachDistance;
            fingersStartScale = new float[hand.fingers.Length];
            for(int i = 0; i < hand.fingers.Length; i++) {
                fingersStartScale[i] = hand.fingers[i].tipRadius;
            }
            lastHandScale = hand.transform.localScale;
        }

        void Update(){ 
            var value = GetValue();
            var scaleDiff = hand.transform.localScale.magnitude/startScale.magnitude;

            if(value >= 0)
                hand.transform.localScale = Vector3.Lerp(startScale, maxScale, value);
            else if(value < 0)
                hand.transform.localScale = Vector3.Lerp(startScale, minScale, -value);

            //The hands reach distance, and the fingers tip radius all need to be set based on the scale
            hand.reachDistance = startReach*scaleDiff;
            for(int i = 0; i < hand.fingers.Length; i++)
                hand.fingers[i].tipRadius = fingersStartScale[i]*scaleDiff;

            if(hand.transform.localScale != lastHandScale)
                hand.ForceReleaseGrab();

            lastHandScale = hand.transform.localScale;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/DialHandScaler.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/JoystickObjectMover.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 271c5f0aab7c79c4baf763651deb6b8c
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class JoystickObjectMover : PhysicsGadgetJoystick{
        public Transform move;
        public float speed = 2;
        
        void Update(){
            var axis = GetValue();
            var moveAxis = new Vector3(axis.x*Time.deltaTime*speed, 0, axis.y*Time.deltaTime*speed);
            move.transform.localPosition += moveAxis;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/JoystickObjectMover.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/MoverLever.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0fa576b4d758c154c9f822f75e47e220
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using Autohand;

namespace Autohand.Demo{
    public class MoverLever : PhysicsGadgetHingeAngleReader{
        public Transform move;
        public Vector3 axis;
        public float speed = 1;
    
        void Update(){
            if(Mathf.Abs(GetValue()) > 0.1f)
                move.position = Vector3.MoveTowards(move.position, move.position-axis, Time.deltaTime*speed*(GetValue()));
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/MoverLever.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/PhysicsSliderPositionMover.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: eea6f209c3501824eac00e1f5626ded0
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class PhysicsSliderPositionMover : PhysicsGadgetConfigurableLimitReader{

        [Header("Movement")]
        public Transform move;
        [Tooltip("Acts as speed")]
        public Vector3 axis = Vector3.up;
        [Header("Range")]
        public bool useRange = false;
        public Vector3 minRange = -Vector3.up;
        public Vector3 maxRange = Vector3.up;
        
        Vector3 startPos;

        protected new void Start(){
            base.Start();
            startPos = move.position;
        }

        public void FixedUpdate(){
            if(useRange){
                var value = GetValue();

                if(value >= 0)
                    move.position = Vector3.Lerp(startPos, startPos+minRange, value);
                else if(value < 0)
                    move.position = Vector3.Lerp(startPos, startPos+maxRange, -value);
            }
            else
                move.position += axis*GetValue()*Time.fixedDeltaTime;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/PhysicsSliderPositionMover.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/WheelRotator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9bcaa22d55bd51e41aff35e61ffe7535
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Autohand;

namespace Autohand.Demo{
    public class WheelRotator : PhysicsGadgetHingeAngleReader{
        public Transform move;
        public Vector3 angle;
        public bool useLocal = false;
        

        void Update(){

            if(useLocal)
                move.localRotation *= Quaternion.Euler(angle*Time.deltaTime*GetValue());
            else
                move.rotation *= Quaternion.Euler(angle*Time.deltaTime*GetValue());
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Gadget Demo/WheelRotator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/LeverTextChanger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 611b8567faa503a49ae0f3e982d21b3a
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class LeverTextChanger : MonoBehaviour{
        public TMPro.TextMeshPro text;
        public PhysicsGadgetHingeAngleReader sliderReader;

        float lastValue = 0;
        void Update(){
            var value = sliderReader.GetValue();
            if(value != lastValue) {
                lastValue = value;
                text.text = Math.Round(value, 2).ToString();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/LeverTextChanger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/SliderTextChanger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0049c988a2ee3424d948efba0d6c4524
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class SliderTextChanger : MonoBehaviour{
        public TMPro.TextMeshPro text;
        public PhysicsGadgetConfigurableLimitReader sliderReader;

        float lastValue = 0;

        void Update(){
            var value = sliderReader.GetValue();
            if(value != lastValue) {
                lastValue = value;
                text.text = Math.Round(value, 2).ToString();
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/SliderTextChanger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextChanger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5a0de1c68fdad6a4c8ba6a07c4c708e5
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Autohand;

namespace Autohand.Demo{
    public class TextChanger : MonoBehaviour{
        public TMPro.TextMeshPro text;
        Coroutine changing;
        Coroutine hide;
        
        public void UpdateText(string newText, float upTime) {

        }

        public void UpdateText(string newText) {

        }

        IEnumerator ChangeText(float seconds, string newText) {
            //float totalTime = 1f;
            //var timePassed = 0f;
            //text.text = newText;
            //text.alpha = 0;

            //while(timePassed <= totalTime) {
            //    text.alpha = (timePassed/totalTime);
            //    timePassed += Time.deltaTime;
            //    if(totalTime >= timePassed)
            //        text.alpha = 1;
            //    yield return new WaitForFixedUpdate();
            //}

            //yield return new WaitForSeconds(seconds);

            //totalTime = 2f;
            //timePassed = 0f;
            //while(timePassed <= totalTime) {
            //    text.alpha = 1-(timePassed/totalTime);
            //    timePassed += Time.deltaTime;
            //    if(totalTime >= timePassed)
            //        text.alpha = 0;
            //    yield return new WaitForFixedUpdate();
            //}

            yield return new WaitForFixedUpdate();
            //text.text = "";
        }

        private void OnDestroy() {
            text.text = "";
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextChanger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextFieldInspector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 61eb7df20390f15409feba60c95784dd
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TextFieldInspector : MonoBehaviour
{
    [TextArea]
    public string text;
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextFieldInspector.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextGrabEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b2aea2de75c7aac428a4c2cc43c65b46
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Autohand;

namespace Autohand.Demo{
    public class TextGrabEvent : MonoBehaviour{
        public TextChanger changer;
        public Grabbable grab;
        [TextArea]
        public string message;

        private void Start() {
            if(grab == null && GetComponent<Grabbable>() != null)
                grab = GetComponent<Grabbable>();

            if(grab == null || changer == null)
                Destroy(this);

            grab.OnGrabEvent += OnGrab;
        }
        
        void OnGrab(Hand hand, Grabbable grab) {
            changer?.UpdateText(message);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextGrabEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextInformation.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9d18906787894d14894103caf956f8cf
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TextInformation : MonoBehaviour{
    public GameObject activateImage;
    public GameObject deactivateImage;
    public GameObject[] texts;


    bool active;
    
    public void ActivateText() {
        active = true;
        foreach(var text in texts) {
            text.SetActive(active);
        }
        
        activateImage.SetActive(true);
        deactivateImage.SetActive(false);
    }


    public void DeactivateText() {
        active = false;
        foreach(var text in texts) {
            text.SetActive(active);
        }
        
        activateImage.SetActive(false);
        deactivateImage.SetActive(true);
    }

    public void ToggleText() {
        if(active)
            DeactivateText();
        else
            ActivateText();
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextInformation.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextPlacePointEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 519fd41fb2f35384ab9142bf2f7c6153
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Autohand;

namespace Autohand.Demo{
    public class TextPlacePointEvent : MonoBehaviour{
        public TextChanger changer;
        public PlacePoint point;
        public float fadeTime = 5;
        [TextArea]
        public string placeMessage;
        [TextArea]
        public string highlightMessage;

        private void Start() {
            if(point == null && GetComponent<PlacePoint>() != null)
                point = GetComponent<PlacePoint>();
            point.OnPlaceEvent += OnGrab;
            point.OnHighlightEvent += OnHighlight;
        }
        
        void OnGrab(PlacePoint hand, Grabbable grab) {
            changer?.UpdateText(placeMessage);
        }

        void OnHighlight(PlacePoint hand, Grabbable grab) {
            changer?.UpdateText(highlightMessage);
        }
        

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TextPlacePointEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TMPSizeProtector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0d48f091a3199d14084f6e23151ace29
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//This is a script applied to tmp demo text because of a bug where the letters scales are not saved because tmp is not imported
public class TMPSizeProtector : MonoBehaviour{
    public float size;

    void Start(){
#if UNITY_EDITOR
        if(GetComponent<TMPro.TextMeshPro>() != null)
            GetComponent<TMPro.TextMeshPro>().fontSize = size;
#endif
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Demo/Text Demo/TMPSizeProtector.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/HandTouchButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 766578289e5886149944336e79b79c4a
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HandTouchButton : MonoBehaviour {
        [NaughtyAttributes.HideIf("startUnpress")]
        public bool startPress = false;
        [NaughtyAttributes.HideIf("startPress")]
        public bool startUnpress = false;
        public HandTouchEvent touchEvent;
        public Transform button;
        public Vector3 pressOffset;
        public Color unpressColor = Color.white;
        public Color pressColor = Color.white;

        public bool toggle = true;

        [Space]
        public UnityHandEvent OnPressed;
        public UnityHandEvent OnUnpressed;

        bool pressed = false;
        MeshRenderer buttonRenderer;

        private void Start() {
            if(startPress)
                PressButton(null);
            else if(startUnpress)
                ReleaseButton(null);

            buttonRenderer = button.GetComponent<MeshRenderer>();
        }

        void OnEnable() {
            touchEvent.HandStartTouchEvent += OnTouch;
            touchEvent.HandStopTouchEvent += OnUntouch;
        }
        void OnDisable() {
            touchEvent.HandStartTouchEvent -= OnTouch;
            touchEvent.HandStopTouchEvent -= OnUntouch;
        }

        void OnTouch(Hand hand) {
            if(toggle) {
                if(!pressed)
                    PressButton(hand);
                else if(pressed)
                    ReleaseButton(hand);
            }
            else if(!pressed)
                PressButton(hand);
        }
        void OnUntouch(Hand hand) {
            if(pressed && !toggle)
                ReleaseButton(hand);
        }

        void PressButton(Hand hand) {
            if(!pressed)
                button.localPosition += pressOffset;
            pressed = true;
            OnPressed?.Invoke(hand); 
            if(buttonRenderer != null && buttonRenderer.material != null)
                buttonRenderer.material.color = pressColor;
        }

        void ReleaseButton(Hand hand) {
            if(pressed)
                button.localPosition -= pressOffset;
            pressed = false; 
            OnUnpressed?.Invoke(hand);
            if(buttonRenderer != null && buttonRenderer.material != null)
                buttonRenderer.material.color = unpressColor;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/HandTouchButton.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/JointExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6896bbcb23a89e64a9efcd8458fd9630
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public static class JointExtensions{
    public static Vector3 Angles(this ConfigurableJoint joint){
        float to180(float v) {
            if (v > 180) {
                v = v - 360;
            }
            return v;
        }

        Quaternion jointBasis = Quaternion.LookRotation(joint.secondaryAxis, Vector3.Cross(joint.axis, joint.secondaryAxis));
        Quaternion jointBasisInverse = Quaternion.Inverse(jointBasis);
        Vector3 rotation;
        if(joint.connectedBody != null) rotation = (jointBasisInverse * Quaternion.Inverse(joint.connectedBody.rotation) * joint.GetComponent<Rigidbody>().transform.rotation * jointBasis).eulerAngles;
        else rotation =  (jointBasisInverse * joint.GetComponent<Rigidbody>().transform.rotation * jointBasis).eulerAngles;
        return new Vector3(to180(rotation.x), to180(rotation.z),to180(rotation.y));
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/JointExtensions.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetButton.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1c95fc8dc8ac7aa4c867fe21c24639c0
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    //THIS MAY NOT WORK AS A GRABBABLE AT THIS TIME - Try PhysicsGadgetSlider instead
    public class PhysicsGadgetButton : PhysicsGadgetConfigurableLimitReader{
        bool pressed = false;

        [Tooltip("The percentage (0-1) from the required value needed to call the event, if threshold is 0.1 OnPressed will be called at 0.9, and OnUnpressed at 0.1"), Min(0.01f)]
        public float threshold = 0.1f;
        public bool lockOnPressed = false;
        [Space]
        public UnityEvent OnPressed;
        public UnityEvent OnUnpressed;

        Vector3 startPos;
        Vector3 pressedPos;
        float pressedValue;

        Rigidbody body;

        new protected void Start(){
            base.Start();
            startPos = transform.localPosition;
            body = joint.GetComponent<Rigidbody>();
        }


        protected void FixedUpdate(){
            var value = GetValue();
            if(!pressed && value+threshold >= 1) 
                Pressed();
            else if(!lockOnPressed && pressed && value-threshold <= 0)
                Unpressed();
        }


        public void Pressed() {
            pressed = true;
            pressedValue = GetValue();
            pressedPos = transform.localPosition;
            OnPressed?.Invoke();
            if(lockOnPressed)
                body.isKinematic = true;
        }

        public void Unpressed(){
            pressed = false;
            OnUnpressed?.Invoke();
        }

        public void Unlock() {
            lockOnPressed = false;
            body.isKinematic = false;
            body.WakeUp();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetButton.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetConfigurableLimitReader.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 18d9c58a36556874fad9e6f1666c394f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    [RequireComponent(typeof(ConfigurableJoint))]
    public class PhysicsGadgetConfigurableLimitReader : MonoBehaviour{
        public bool invertValue = false;
        [Tooltip("The minimum abs value required to return a value nonzero value\n " +
            "- if playRange is 0.1, you have to move the gadget 10% to get a result")]
        public float playRange = 0.025f;
        protected ConfigurableJoint joint;

        protected Vector3 axisPos;
        float value;
        Vector3 limitAxis;

        protected virtual void Start(){
            joint = GetComponent<ConfigurableJoint>();
            limitAxis = new Vector3(joint.xMotion == ConfigurableJointMotion.Locked ? 0 : 1, joint.yMotion == ConfigurableJointMotion.Locked ? 0 : 1, joint.zMotion == ConfigurableJointMotion.Locked ? 0 : 1);
            axisPos = Vector3.Scale(transform.localPosition, limitAxis);
        }


        /// <summary>Returns a -1 to 1 value that represents the point of the slider</summary>
        public float GetValue() {
            bool positive = true;
            var currPos = Vector3.Scale(transform.localPosition, limitAxis);
            if(axisPos.x < currPos.x || axisPos.y < currPos.y || axisPos.z < currPos.z)
                positive = false;

            if(invertValue)
                positive = !positive;

            value = Vector3.Distance(axisPos, currPos)/joint.linearLimit.limit;

            if(!positive) value *= -1;

            if(float.IsNaN(value))
                value = 0;

            if (Mathf.Abs(value) < playRange)
                value = 0;
            return Mathf.Clamp(value, -1f, 1f);
        }

        public ConfigurableJoint GetJoint() => joint;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetConfigurableLimitReader.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetHingeAngleReader.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3f2580c2349119b46b7b6be979d1ad61
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    [RequireComponent(typeof(HingeJoint))]
    public class PhysicsGadgetHingeAngleReader : MonoBehaviour{
        public bool invertValue = false;
        [Tooltip("For objects slightly off center. " +
            "\nThe minimum abs value required to return a value nonzero value\n " +
            "- if playRange is 0.1, you have to move the gadget 10% to get a result")]
        public float playRange = 0.05f; 
        HingeJoint joint;
        protected float value = 0;
        Quaternion startRot;
        Quaternion deltaParentRotation;

        protected virtual void Start(){
            joint = GetComponent<HingeJoint>(); 
            startRot = transform.localRotation;
        }

        /// <summary>Returns a -1 to 1 value representing the hinges angle from min-max</summary>
        public float GetValue() {
            float limitRange = joint.limits.max - joint.limits.min;
            if(limitRange == 0f) {
                value = 0f;
            }
            else {
                value = joint.angle / limitRange * 2f;
            }

            value = invertValue ? -value : value;

            if(float.IsNaN(value))
                value = 0f;

            if(Mathf.Abs(value) < playRange)
                value = 0f;

            return Mathf.Clamp(value, -1f, 1f);
        }


        public HingeJoint GetJoint() => joint;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetHingeAngleReader.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetJoystick.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 75b68df54cd03f242849b082c2373599
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    [RequireComponent(typeof(ConfigurableJoint))]
    public class PhysicsGadgetJoystick : MonoBehaviour{
        ConfigurableJoint joint;
        public bool invertX;
        public bool invertY;
        [Tooltip("For objects slightly off center. " +
            "\nThe minimum abs value required to return a value nonzero value\n " +
            "- if playRange is 0.1, you have to move the gadget 10% to get a result")]
        public float playRange = 0.05f; 
        Vector2 xRange, zRange;
        Vector2 value;
        Vector3 jointRotation;
        Rigidbody body;

        void Start(){
            joint = GetComponent<ConfigurableJoint>();  
            body = GetComponent<Rigidbody>();
        }

        public void FixedUpdate(){
            xRange = new Vector2(joint.lowAngularXLimit.limit, joint.highAngularXLimit.limit);
            zRange = new Vector2(-joint.angularZLimit.limit, joint.angularZLimit.limit);
            jointRotation = joint.Angles();
            value = new Vector2(jointRotation.z/(zRange.x - zRange.y), jointRotation.x/(xRange.x - xRange.y))*2;
        }

        public Vector2 GetValue() {
            if (Mathf.Abs(value.x) < playRange)
                value.x = 0;
            if (Mathf.Abs(value.y) < playRange)
                value.y = 0;
            
            value.x = invertX ? -value.x : value.x;
            value.y = invertY ? -value.y : value.y;
            return new Vector2(Mathf.Clamp(value.x, -1, 1), Mathf.Clamp(value.y, -1, 1));
        }
        
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetJoystick.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetLever.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ca4a171938232714ea376c9d195c0c73
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{

[System.Serializable]
public struct StepEvent {
    public int step;
    public UnityEvent OnStepEnter;
    public UnityEvent OnStepExit;
}

public class PhysicsGadgetLever : PhysicsGadgetHingeAngleReader{
    [Min(0.01f), Tooltip("The percentage (0-1) from the required value needed to call the event, if threshold is 0.1 OnMax will be called at 0.9, OnMin at -0.9, and OnMiddle at -0.1 or 0.1")]
    public float threshold = 0.05f;

    [Min(0)]
    public int stepCount = 0;
    public int startStep = 0;
    private int prevStepCount = -1;

    public UnityEvent OnMax;
    public UnityEvent OnMid;
    public UnityEvent OnMin;
    public StepEvent[] stepEvents;
        
    bool min = false;
    bool max = false;
    bool mid = true;

    private int currStep = -1;
    private int prevStep = -1;
    
    private float minimum;
    private float maximum;
    float[] stepMarkers;

    protected void FixedUpdate(){
        var value = GetValue();

        if(!max && mid && value+threshold >= 1) {
            Max();
        }

        if(!min && mid && value-threshold <= -1){
            Min();
        }
        
        if (value <= threshold && max && !mid) {
            Mid();
        }

        if (value >= -threshold && min && !mid) {
            Mid();
        }
    }

    protected override void Start() {
        base.Start();
        if(startStep <= 0) return;

        FindSteps();
        SetSpring(startStep - 1);
    }

    void Update() {
        AdjustStep();
    }

    void AdjustStep() {
        if(stepCount <= 0) return;

        FindSteps();
        SetSpring(FindCurrentStep()); 
    }

    bool FindSteps() {
        if(prevStepCount == stepCount) return false;

        prevStepCount = stepCount;

        stepMarkers = new float[stepCount];

        minimum = GetJoint().limits.min;
        maximum = GetJoint().limits.max;
        
        float step = GetStep();

        for(int i = 0; i < stepCount; i++) {
            stepMarkers[stepCount - i - 1] = minimum + (i * step);
        }

        return true;
    }

    public void SetSpring(int step)
    {
        GetJoint().transform.localRotation *= Quaternion.Euler(GetJoint().axis  * stepMarkers[step]);

        currStep = step;
        JointSpring jointSpring = GetJoint().spring;
        jointSpring.targetPosition = stepMarkers[step]; 
        GetJoint().spring = jointSpring;
    }

    public void SetSpring(float stepRotation)
    {
        JointSpring jointSpring = GetJoint().spring;
        jointSpring.targetPosition = stepRotation; 
        GetJoint().spring = jointSpring;
    }

    float FindCurrentStep() {
        float checkValue = GetValue() * GetRange();
        for(int i = 0; i < stepCount; i++) {
            if(checkValue >= GetMinimumStep(i) && checkValue <= GetMaximumStep(i)) {
                currStep = i;
                if(currStep != prevStep) {
                    Step();
                    prevStep = currStep;
                }

                return stepMarkers[i];
            }
        }

        return 0;
    }

    float GetStep() => (Mathf.Abs(minimum) + Mathf.Abs(maximum)) / (stepCount - 1);
    float GetRange() => (Mathf.Abs(minimum) + Mathf.Abs(maximum)) / 2;
    float GetMinimumStep(int index) => stepMarkers[index] - (GetStep() / 2);
    float GetMaximumStep(int index) => stepMarkers[index] + (GetStep() / 2);

    void Max() {
        mid = false;
        max = true;
        OnMax?.Invoke();
    }

    void Mid() {
        min = false;
        max = false;
        mid = true;
        OnMid?.Invoke();
    }

    void Min() {
        min = true;
        mid = false;
        OnMin?.Invoke();
    }

    void Step() {
        for(int i = 0; i < stepEvents.Length; i++) {
            if(stepEvents[i].step == currStep + 1) {
                stepEvents[i].OnStepEnter?.Invoke();
            }
            else if(stepEvents[i].step == prevStep + 1) {
                stepEvents[i].OnStepExit?.Invoke();
            }
        }
    }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetLever.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetSlider.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 18f6faf550e7518449699c9a49dc7298
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
public class PhysicsGadgetSlider : PhysicsGadgetConfigurableLimitReader{
    [Min(0.01f), Tooltip("The percentage (0-1) from the required value needed to call the event, if threshold is 0.1 OnMax will be called at 0.9, OnMin at -0.9, and OnMiddle at -0.1 or 0.1")]
    public float threshold = 0.05f;

    [Min(0)]
    public int stepCount = 0;
    public int startStep = 0;
    private int prevStepCount = -1;

    public UnityEvent OnMax;
    public UnityEvent OnMid;
    public UnityEvent OnMin;
    public StepEvent[] stepEvents;
        
    bool min = false;
    bool max = false;
    bool mid = true;

    private int currStep = -1;
    private int prevStep = -1;
    
    private float minimum;
    private float maximum;
    float[] stepMarkers;

    protected void FixedUpdate(){
            var value = GetValue();
        if(!max && mid && value+threshold >= 1) {
            Max();
        }

        if(!min && mid && value-threshold <= -1){
            Min();
        }
        
        if (value <= threshold && max && !mid) {
            Mid();
        }

        if (value >= -threshold && min && !mid) {
            Mid();
        }
    }

    protected override void Start() {
        base.Start();
        if(startStep <= 0) return;

        FindSteps();
        SetSpring(startStep - 1);
    }

    void Update() {
        AdjustStep();
    }
    
    void AdjustStep() {
        if(stepCount <= 0) return;
        
        FindSteps();
        SetSpring(FindCurrentStep());

    }

    bool FindSteps() {
        if(prevStepCount == stepCount) return false;

        prevStepCount = stepCount;

        stepMarkers = new float[stepCount];

        minimum = -(GetJoint().linearLimit.limit);
        maximum = (GetJoint().linearLimit.limit);
        
        float step = GetStep();

        for(int i = 0; i < stepCount; i++) {
            stepMarkers[i] = minimum + (i * step);
        }
        return true;
    }

    public void SetSpring(int step)
    {
        currStep = step;
        Vector3 limitAxis = new Vector3(joint.xMotion == ConfigurableJointMotion.Locked ? 0 : stepMarkers[step], 
                                        joint.yMotion == ConfigurableJointMotion.Locked ? 0 : stepMarkers[step], 
                                        joint.zMotion == ConfigurableJointMotion.Locked ? 0 : stepMarkers[step]);
        
        GetJoint().transform.localPosition = limitAxis;
        GetJoint().targetPosition = limitAxis;
    }

    public void SetSpring(float stepRotation)
    {
        Vector3 limitAxis = new Vector3(joint.xMotion == ConfigurableJointMotion.Locked ? 0 : stepRotation, 
                                        joint.yMotion == ConfigurableJointMotion.Locked ? 0 : stepRotation, 
                                        joint.zMotion == ConfigurableJointMotion.Locked ? 0 : stepRotation);
        
        GetJoint().targetPosition = limitAxis;
    }

    float FindCurrentStep() {
        float checkValue = GetValue() / GetScalar();
        for(int i = 0; i < stepCount; i++)
            if(checkValue >= GetMinimumStep(i) && checkValue <= GetMaximumStep(i)) {
                currStep = i;
                if(currStep != prevStep) {
                    Step();
                    prevStep = currStep;
                }

                return stepMarkers[i];
            }

        return 0;
    }

    float GetStep() => (Mathf.Abs(minimum) + Mathf.Abs(maximum)) / (stepCount - 1);
    float GetScalar() => (1 / Mathf.Abs(minimum));
    float GetMinimumStep(int index) => stepMarkers[index] - (GetStep() / 2);
    float GetMaximumStep(int index) => stepMarkers[index] + (GetStep() / 2);

    void Max() {
        mid = false;
        max = true;
        OnMax?.Invoke();
    }

    void Mid() {
        min = false;
        max = false;
        mid = true;
        OnMid?.Invoke();
    }

    void Min() {
        min = true;
        mid = false;
        OnMin?.Invoke();
    }
    void Step() {
        for(int i = 0; i < stepEvents.Length; i++) {
            if(stepEvents[i].step == currStep + 1) {
                stepEvents[i].OnStepEnter?.Invoke();
            }
            else if(stepEvents[i].step == prevStep + 1) {
                stepEvents[i].OnStepExit?.Invoke();
            }
        }
    }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Gadgets/PhysicsGadgetSlider.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/DispenserPoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8e06fa0b8c2a3b047ab22fa2c4dcbaa4
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

namespace Autohand {
    [Serializable, DefaultExecutionOrder(100)] 
    public class UnityDispenserEvent : UnityEvent<DispenserPoint, Grabbable> { }
    public class DispenserPoint : MonoBehaviour {
        [AutoHeader("Dispenser Point")]
        public bool ignoreMe;

        [AutoSmallHeader("Dispenser Settings")]
        public bool showeSettings = true;
        [Tooltip("The object to be copied and dispensed")]
        public Grabbable dispenseObject;
        [Tooltip("The maximum copies allowed to exist from this dispenser before they are destroyed or reset")]
        public int maxCopies = 3;
        [Tooltip("The delay in seconds before the next dispense appears after the current dispense is taken")]
        public float resetDelay = 0f;
        [Tooltip("Whether or not objects placed in the dispense point should be set to kinematic on placed or not")]
        public bool disableBody = false;
        [NaughtyAttributes.HideIf("disableBody"), Tooltip("Whether or not objects placed in the dispense point should be set to kinematic on placed or not")]
        public bool isKinematic = true;
        [Tooltip("If true the object will not just reset its position on reset it will be destroyed and a new copy will be placed. Less performant but important for things like ammo that should always respawn as new clips full")]
        public bool destroyOnReset = false;
        [Tooltip("The maximum distance a dispensed object can move from the point before the next object is dispensed")]
        public float maxDistance = 1f;

        [Space]
        public UnityDispenserEvent OnGrabDispenseEvent;
        public UnityDispenserEvent OnDispenseEvent;

        Grabbable currentDispense;
        Grabbable lastDispense;
        GameObject[] dispensePool;
        int poolCount;
        Coroutine dispenseRoutine;

        protected virtual void Start() {
            GameObject instanceObject;
            dispenseObject.body.gameObject.SetActive(false);

            instanceObject = Instantiate(dispenseObject.body.gameObject);


            instanceObject.transform.position = transform.position;
            instanceObject.transform.rotation = transform.rotation;
            instanceObject.SetActive(true);


            dispensePool = new GameObject[maxCopies];
            dispensePool[0] = instanceObject;


            if(dispensePool[0].HasGrabbable(out var grab)) {
                if(!disableBody && isKinematic && grab.body != null)
                    grab.body.isKinematic = true;

                grab.OnGrabEvent += OnGrab;
                grab.OnPlacePointAddEvent += OnPlaced;
                currentDispense = grab;

                if(disableBody)
                    grab.DeactivateRigidbody();
            }

            poolCount++;
        }

        protected virtual void OnDisable() {
            if(dispenseRoutine != null)
                StopCoroutine(dispenseRoutine);
            dispenseRoutine = null;
        }

        protected virtual void FixedUpdate() { 
            if(maxDistance > 0 && currentDispense.gameObject.activeInHierarchy && Vector3.Distance(transform.position, currentDispense.rootTransform.position) > maxDistance)
                Dispense();
        }

        public virtual Grabbable Dispense() {
            if(dispenseRoutine == null) {
                var poolIndex = (poolCount) % maxCopies;
                if(destroyOnReset) {
                    Destroy(dispensePool[poolIndex]);
                    dispensePool[poolIndex] = null;
                }

                if(poolCount < maxCopies || dispensePool[poolIndex] == null || dispensePool[poolIndex].activeInHierarchy == false)
                    dispensePool[poolIndex] = Instantiate(dispenseObject.body.gameObject);

                dispensePool[poolIndex].transform.position = transform.position;
                dispensePool[poolIndex].transform.rotation = transform.rotation;

                if(dispensePool[poolIndex].HasGrabbable(out var grab)) {
                    grab.ForceHandsRelease();
                    if(grab.placePoint != null)
                        grab.placePoint.Remove();
                    if(grab.body == null)
                        grab.ActivateRigidbody();

                    if(!disableBody && isKinematic)
                        grab.body.isKinematic = true;

                    if(!grab.body.isKinematic) {
                        grab.body.linearVelocity = Vector3.zero;
                        grab.body.angularVelocity = Vector3.zero;
                    }

                    grab.OnGrabEvent += OnGrab;
                    grab.OnPlacePointAddEvent += OnPlaced;

                    dispenseRoutine = StartCoroutine(DispenseResetDelay(grab));


                    lastDispense = currentDispense;
                    lastDispense.OnGrabEvent -= OnGrab;
                    lastDispense.OnPlacePointAddEvent -= OnPlaced;
                    currentDispense = grab;

                    poolCount++;
                    return grab;
                }


                poolCount++;
            }
            return null;
        }

        public virtual void OnGrab(Hand hand, Grabbable grab) {
            if(grab != null && isKinematic && grab.body != null)
                grab.body.isKinematic = false;

            OnGrabDispenseEvent?.Invoke(this, grab);
            Dispense();
        }

        public virtual void OnPlaced(PlacePoint point, Grabbable grab) {
            if(grab != null && isKinematic && grab.body != null)
                grab.body.isKinematic = false;

            Debug.Log("Placed: " + grab.body.isKinematic);

            Dispense();
        }

        IEnumerator DispenseResetDelay(Grabbable dispenseObject) {
            dispenseObject.body.gameObject.SetActive(false);
            yield return new WaitForSeconds(resetDelay);
            dispenseObject.body.gameObject.SetActive(true);
            dispenseObject.IgnoreGrabbableCollisionUntilNone(lastDispense);
            foreach(var hand in lastDispense.GetHeldBy())
                dispenseObject.IgnoreHandCollisionUntilNone(hand);
            OnDispenseEvent?.Invoke(this, dispenseObject);
            if(disableBody)
                dispenseObject.DeactivateRigidbody();
            dispenseRoutine = null;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/DispenserPoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/DistanceGrabbable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 935aaf7da50abf94697c8d70a7a71efe
# ASMDEF: AutoHandAssembly.dll
# ---
using NaughtyAttributes;
using UnityEngine;

namespace Autohand{
    public enum DistanceGrabType {
        Velocity,
        Linear
    }

    [RequireComponent(typeof(Grabbable))]
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/grabbable/distance-grabbinghttps://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/grabbable/distance-grabbing")]
    public class DistanceGrabbable : MonoBehaviour{
        [AutoHeader("Distance Grabbable")]
        public bool ignoreMe;
        
        [Header("Pull")]
        public bool instantPull = true;


        public DistanceGrabType grabType;

        [Range(0.4f, 1.1f)]
        [Tooltip("Use this to adjust the angle of the arch that the gameobject follows while shooting towards your hand.")]
        [ShowIf("grabType", DistanceGrabType.Velocity)]
        public float archMultiplier = .6f;
        [Tooltip("Slow down or speed up gravitation to your liking.")]
        [ShowIf("grabType", DistanceGrabType.Velocity)]
        public float gravitationVelocity = 1f;



        [Header("Rotation")]
        [Tooltip("This enables rotation which makes the gameobject orient to the rotation of you hand as it moves through the air. All below rotation variables have no use when this is false.")]
        [ShowIf("grabType", DistanceGrabType.Velocity)]
        public bool rotate = true;

        [Tooltip("Speed that the object orients to the rotation of your hand.")]
        [ShowIf("grabType", DistanceGrabType.Velocity)]
        public float rotationSpeed = 1;
        
        [AutoToggleHeader("Enable Highlighting")]
        [Tooltip("Whether or not to ignore all highlights including default highlights on HandPointGrab")]
        public bool ignoreHighlights = true;
        [EnableIf("ignoreHighlights"), Tooltip("Highlight targeted material to use - defaults to HandPointGrab materials if none")]
        public Material targetedMaterial;
        [EnableIf("ignoreHighlights"), Tooltip("Highlight selected material to use - defaults to HandPointGrab materials if none")]
        public Material selectedMaterial;

        [AutoToggleHeader("Show Events")]
        public bool showEvents = true;
        [ShowIf("showEvents")]
        public UnityHandGrabEvent OnPull;
        [Space]
        [Tooltip("Called when the object has been targeted/aimed at by the pointer")]
        [ShowIf("showEvents")]
        public UnityHandGrabEvent StartTargeting;
        [ShowIf("showEvents")]
        public UnityHandGrabEvent StopTargeting;
        [Space]
        [Tooltip("Called when the object has been selected before being pulled or flicked")]
        [ShowIf("showEvents")]
        public UnityHandGrabEvent StartSelecting;
        [ShowIf("showEvents")]
        public UnityHandGrabEvent StopSelecting;

        public HandGrabEvent OnPullCanceled;

        internal Grabbable grabbable;
    

        private Transform target = null;
        private Vector3 calculatedNecessaryVelocity;
        private bool gravitationEnabled;
        private bool gravitationMethodBegun;
        private bool pullStarted;
        private Rigidbody body;
        float timePassedSincePull;

        private void Start() {
            grabbable = GetComponent<Grabbable>();
            grabbable.OnGrabEvent += (Hand hand, Grabbable grab) => { gravitationEnabled = false; };
            body = grabbable.body;
        }
    
        void FixedUpdate(){
            if(!instantPull && grabType == DistanceGrabType.Velocity) {
                if (target == null)
                    return;

                InitialVelocityPushToHand();
                if(rotate)
                    FollowHandRotation();
                if (gravitationEnabled)
                    GravitateTowardsHand();
                timePassedSincePull += Time.fixedDeltaTime;
            }
        }


        private void FollowHandRotation(){
            transform.rotation = Quaternion.Slerp(transform.rotation, target.rotation, rotationSpeed * Time.fixedDeltaTime); 
        }

        Vector3 lastGravitationVelocity;
        private void GravitateTowardsHand(){
            if (gravitationEnabled){

                if (!gravitationMethodBegun){
                    gravitationMethodBegun = true;
                }
                    
                lastGravitationVelocity = (target.position- transform.position).normalized*Time.fixedDeltaTime*gravitationVelocity;
                body.linearVelocity += lastGravitationVelocity*10;
            }
            else{
                gravitationMethodBegun = false;
            }
        }


        private void InitialVelocityPushToHand(){
            //This way I can ensure that the initial shot with velocity is only shot once
            if (pullStarted){
                if(archMultiplier > 0)
                    calculatedNecessaryVelocity = CalculateTrajectoryVelocity(transform.position, target.transform.position, archMultiplier);

                timePassedSincePull = 0;
                body.linearVelocity = calculatedNecessaryVelocity;
                gravitationEnabled = true;
                pullStarted = false;
            }
        }

        private void OnCollisionEnter(Collision collision){
            if (timePassedSincePull > 0.2f)
            {
                pullStarted = false;
                gravitationEnabled = false;
                CancelTarget();
            }
        }


        Vector3 CalculateTrajectoryVelocity(Vector3 origin, Vector3 target, float t){
            float vx = (target.x - origin.x) / t;
            float vz = (target.z - origin.z) / t;
            float vy = ((target.y - origin.y) - 0.5f * Physics.gravity.y * t * t) / t;
            return new Vector3(vx, vy, vz);
        }

        public void SetTarget(Transform theObject) { target = theObject; pullStarted = true; }
        public void CancelTarget() { target = null; pullStarted = false; }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/DistanceGrabbable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/Grabbable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 822bc9090447b9c40833509c4a32e597
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;
using NaughtyAttributes;
using UnityEditor;
using UnityEngine.Serialization;
using UnityEngine.XR;


namespace Autohand {
    public enum HandGrabType {
        Default,
        HandToGrabbable,
        GrabbableToHand
    }

    public enum HandGrabPoseType {
        Grab,
        Pinch
    }

    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/grabbable"), DefaultExecutionOrder(-100)]
    public class Grabbable : GrabbableBase, IGrabbableEvents {


        [Tooltip("This will copy the given grabbables settings to this grabbable when applied"), OnValueChanged("EditorCopyGrabbable")]
        public Grabbable CopySettings;

        [Header("Grab Settings")]
        [Tooltip("Which hand this can be held by")]
        public HandGrabType grabType = HandGrabType.Default;

        [Tooltip("Which hand pose this will grab with")]
        public HandGrabPoseType grabPoseType = HandGrabPoseType.Grab;

        [Tooltip("Which hand this can be held by")]
        public HandType handType = HandType.both;

        [Tooltip("Whether or not this can be grabbed with more than one hand")]
        public bool singleHandOnly = false;

        [Space]
        [Tooltip("Will the item automatically return the hand on grab - good for saved poses, bad for heavy things")]
        public bool instantGrab = false;

        [DisableIf("instantGrab"), Tooltip("If true (and using HandToGrabbable) the hand will only return to the follow while moving. Good for picking up objects without disrupting the things around them - you can change the speed of the hand return on the hand through the gentleGrabSpeed value")]
        public bool useGentleGrab = false;

        [Tooltip("Creates an offset an grab so the hand will not return to the hand on grab - Good for statically jointed grabbable objects")]
        public bool maintainGrabOffset = false;

        [Tooltip("This will NOT parent the object under the hands on grab. This will parent the object to the parents of the hand, which allow you to move the hand parent object smoothly while holding an item, but will also allow you to move items that are very heavy - recommended for all objects that aren't very heavy or jointed to other rigidbodies")]
        public bool parentOnGrab = true;


        [Header("Held Settings")]

        [Tooltip("Replaces the physics material with the resources NoFriction material while held")]
        public bool heldNoFriction = true;

        [Tooltip("Experimental - ignores weight of held object while held")]
        public bool ignoreWeight = false;

        [ShowIf("singleHandOnly")]
        [Tooltip("if false single handed items cannot be passes back and forth on grab")]
        public bool allowHeldSwapping = true;

        [Header("Release Settings")]
        [Tooltip("How much to multiply throw by for this grabbable when releasing - 0-1 for no or reduced throw strength")]
        [FormerlySerializedAs("throwMultiplyer")]
        public float throwPower = 1;

        [Tooltip("The required force to break the fixedJoint\n " +
                 "Turn this to \"infinity\" to disable (Might cause jitter)\n" +
                "Ideal value depends on hand mass and velocity settings")]
        public float jointBreakForce = 3500;



        [AutoSmallHeader("Advanced Settings")]
        public bool showAdvancedSettings = true;

        [Tooltip("Adds and links a GrabbableChild to each child with a collider on start - So the hand can grab them")]
        public bool makeChildrenGrabbable = true;

        [Min(0), Tooltip("I.E. Grab Prioirty - BIGGER IS BETTER - divides highlight distance by this when calculating which object to grab. Hands always grab closest object to palm")]
        public float grabPriorityWeight = 1;

        [Tooltip("The number of seconds that the hand collision should ignore the released object\n (Good for increased placement precision and resolves clipping errors)"), Min(0)]
        public float ignoreReleaseTime = 0.5f;


        [Tooltip("The minimum allow drag a held objects rigidbody can have, this can help prevent dramatic wobbling on held objects"), Min(0)]
        public float minHeldDrag = 1.5f;
        [Tooltip("The minimum allow drag a held objects rigidbody can have, this can help prevent dramatic wobbling on held objects"), Min(0)]
        public float minHeldAngleDrag = 3f;
        [Tooltip("The minimum allow drag a held objects rigidbody can have, this can help prevent dramatic wobbling on held objects"), Min(0)]
        public float minHeldMass = 0.1f;

        [Tooltip("Lowing this value will help allow for more stable joint interactions and make objects seems heavier if lowered enough"), Min(0)]
        public float maxHeldVelocity = 10f;
        [Space]

        [Tooltip("Offsets the grabbable by this much when being held")]
        public Vector3 heldPositionOffset;

        [Tooltip("Offsets the grabbable by this many degrees when being held")]
        public Vector3 heldRotationOffset;

        [Space]

        [Min(0), Tooltip("The joint that connects the hand and the grabbable. Defaults to the joint in AutoHand/Resources/DefaultJoint.prefab if empty")]
        public ConfigurableJoint customGrabJoint;

        [Space]

        [Tooltip("For the special use case of having grabbable objects with physics jointed peices move properly while being held")]
        public List<Rigidbody> jointedBodies = new List<Rigidbody>();

        [Tooltip("For the special use case of having things connected to the grabbable that the hand should ignore while being held (good for doors and drawers) -> for always active use the [GrabbableIgnoreHands] Component")]
        public List<Collider> heldIgnoreColliders = new List<Collider>();

        [Space]

        [Tooltip("Whether or not the break call made only when holding with multiple hands - if this is false the break event can be called by forcing an object into a static collider"), HideInInspector]
        public bool pullApartBreakOnly = true;

        [AutoToggleHeader("Show Events")]
        public bool showEvents = true;
        [Space]
        [ShowIf("showEvents")]
        public UnityHandGrabEvent onGrab = new UnityHandGrabEvent();
        [ShowIf("showEvents")]
        public UnityHandGrabEvent onRelease = new UnityHandGrabEvent();

        [ShowIf("showEvents")]
        [Space, Space]
        public UnityHandGrabEvent onSqueeze = new UnityHandGrabEvent();
        [ShowIf("showEvents")]
        public UnityHandGrabEvent onUnsqueeze = new UnityHandGrabEvent();

        [Space, Space]
        [ShowIf("showEvents")]
        public UnityHandGrabEvent onHighlight = new UnityHandGrabEvent();
        [ShowIf("showEvents")]
        public UnityHandGrabEvent onUnhighlight = new UnityHandGrabEvent();
        [Space, Space]

        [ShowIf("showEvents")]
        public UnityHandGrabEvent OnJointBreak = new UnityHandGrabEvent();


        //Advanced Hidden Settings
        [HideInInspector, Tooltip("Lock hand in place on grab (This is a legacy setting, set hand kinematic on grab/release instead)")]
        public bool lockHandOnGrab = false;



        //For programmers <3
        public HandGrabEvent OnBeforeGrabEvent;
        public HandGrabEvent OnGrabEvent;

        public HandGrabEvent OnBeforeReleaseEvent;
        public HandGrabEvent OnReleaseEvent;
        public HandGrabEvent OnJointBreakEvent;

        public HandGrabEvent OnSqueezeEvent;
        public HandGrabEvent OnUnsqueezeEvent;

        public HandGrabEvent OnHighlightEvent;
        public HandGrabEvent OnUnhighlightEvent;

        public PlacePointEvent OnPlacePointHighlightEvent;
        public PlacePointEvent OnPlacePointUnhighlightEvent;
        public PlacePointEvent OnPlacePointAddEvent;
        public PlacePointEvent OnPlacePointRemoveEvent;


        /// <summary>Whether or not this object was force released (dropped) when last released (as opposed to being intentionally released)</summary>
        public bool wasForceReleased { get; protected internal set; } = false;
        public Hand lastHeldBy { get; protected set; } = null;


#if UNITY_EDITOR
        void EditorCopyGrabbable() {
            if(CopySettings != null)
                EditorUtility.CopySerialized(CopySettings, this);
        }
#endif


        public void Start()
        {
#if UNITY_EDITOR
            if (Selection.activeGameObject == gameObject)
            {
                Selection.activeGameObject = null;
                Debug.Log("Auto Hand: highlighting grabbables and rigidbodies in the inspector can cause lag and quality reduction at runtime in VR. (Automatically deselecting at runtime) Remove this code at any time.", this);
                editorSelected = true;
            }
            Application.quitting += () => { if (editorSelected && Selection.activeGameObject == null) Selection.activeGameObject = gameObject; };
#endif
        }

        public override void Awake() {
            base.Awake();

            if(makeChildrenGrabbable)
                MakeChildrenGrabbable();

            if(body.transform != transform && !body.gameObject.HasGrabbable(out Grabbable grab)) {
                var grabChild = body.gameObject.AddComponent<GrabbableChild>();
                grabChild.grabParent = this;
            }


            for(int i = 0; i < jointedBodies.Count; i++) {
                jointedParents.Add(jointedBodies[i].transform.parent != null ? jointedBodies[i].transform.parent : null);
                if(jointedBodies[i].gameObject.HasGrabbable(out var grabbable) && !jointedGrabbables.Contains(grabbable))
                    jointedGrabbables.Add(grabbable);
            }

            for(int i = 0; i < transform.childCount; i++) {
                ConnectGrabbablesRecursive(transform.GetChild(i));
            }

            void ConnectGrabbablesRecursive(Transform obj) {
                Grabbable grab1;
                for(int i = 0; i < obj.childCount; i++) {
                    if(obj.CanGetComponent<Grabbable>(out grab1)) {
                        if(!grabbableChildren.Contains(grab1))
                            grabbableChildren.Add(grab1);

                        if(!grab1.grabbableParents.Contains(this))
                            grab1.grabbableParents.Add(this);
                    }

                    ConnectGrabbablesRecursive(obj.GetChild(i));
                }
            }
            grabbableChildren = new List<Grabbable>(GetComponentsInChildren<Grabbable>(true));
            if(grabbableChildren.Contains(this))
                grabbableChildren.Remove(this);


            grabbableParents = new List<Grabbable>(GetComponentsInParent<Grabbable>(true));
            if(grabbableParents.Contains(this))
                grabbableParents.Remove(this);


            //This will automatically prevent grabbables from being placed into any place points that are children of this grabbable
            var placePointChildren = GetComponentsInChildren<PlacePoint>(true);
            for(int i = 0; i < placePointChildren.Length; i++) {

                if(placePointChildren[i].dontAllows == null)
                    placePointChildren[i].dontAllows = new List<Grabbable>();
                placePointChildren[i].dontAllows.Add(this);

                if(!childPlacePoints.Contains(placePointChildren[i]))
                    childPlacePoints.Add(placePointChildren[i]);

                if(grabbableParents.Count == 0)
                    placePointChildren[i].parentGrabbable = this;

                foreach(var grabbable in grabbableChildren) {
                    if(grabbable != this && !placePointChildren[i].dontAllows.Contains(grabbable))
                        placePointChildren[i].dontAllows.Add(grabbable);
                }

                foreach(var grabbable in grabbableParents) {
                    if(grabbable != this && !placePointChildren[i].dontAllows.Contains(grabbable))
                        placePointChildren[i].dontAllows.Add(grabbable);
                }
            }

            if(grabbableParents.Count == 0) {
                foreach(var grabbable in grabbableChildren) {
                    grabbable.rootGrabbable = this;
                }
                rootGrabbable = this;
            }
        }

        protected override void OnDisable() {
            base.OnDisable();
            if(heldBy.Count != 0)
                ForceHandsRelease();
        }

        protected virtual void OnDestroy()
        {
            beingDestroyed = true;

            if (heldBy.Count != 0)
                ForceHandsRelease();

            foreach(var routine in resetLayerRoutine) {
                if(routine.Value != null)
                    StopCoroutine(routine.Value);

                IgnoreHand(routine.Key, false);
            }
            resetLayerRoutine.Clear();

            MakeChildrenUngrabbable();
            if (placePoint != null && !placePoint.disablePlacePointOnPlace)
                placePoint.Remove(this);

            Destroy(poseCombiner);
        }

        public override void HeldFixedUpdate() {
            base.HeldFixedUpdate();

            if(wasIsGrabbable && !(isGrabbable || enabled))
                ForceHandsRelease();

            wasIsGrabbable = isGrabbable || enabled;
            lastUpdateTime = Time.fixedTime;
        }



        public void IgnoreColliders(Collider collider, bool ignore = true) {
            foreach(var col in grabColliders)
                Physics.IgnoreCollision(collider, col, ignore);
        }

        public void IgnoreColliders(Collider[] colliders, bool ignore = true)
        {
            foreach (var col in grabColliders)
                foreach (var col1 in colliders)
                    Physics.IgnoreCollision(col1, col, ignore);
        }
        public void IgnoreColliders(List<Collider> colliders, bool ignore = true)
        {
            foreach (var col in grabColliders)
                foreach (var col1 in colliders)
                    Physics.IgnoreCollision(col1, col, ignore);
        }


        void TryCreateHighlight(Material customMat, Hand hand)
        {

            var highlightMat = customMat != null ? customMat : hightlightMaterial;
            highlightMat = highlightMat != null ? highlightMat : hand.defaultHighlight;
            if (highlightMat != null && !highlightObjs.ContainsKey(highlightMat))
            {
                highlightObjs.Add(highlightMat, new List<GameObject>());
                AddHighlightObject(transform);


                bool AddHighlightObject(Transform obj)
                {

                    //This will stop the highlighting subsearch if there is another grabbable so that grabbable can create its own highlight settings/section
                    if (obj.CanGetComponent<Grabbable>(out var grab) && grab != this)
                        return false;
                    if((highlightObjs[highlightMat].Contains(obj.gameObject)))
                        return true;

                    for (int i = 0; i < obj.childCount; i++)
                    {
                        if (!AddHighlightObject(obj.GetChild(i)))
                            break;
                    }

                    MeshRenderer meshRenderer;
                    if (obj.CanGetComponent(out meshRenderer))
                    {
                        //Creates a slightly larger copy of the mesh and sets its material to highlight material
                        var highlightObj = new GameObject();
                        highlightObj.transform.parent = obj;
                        highlightObj.transform.localPosition = Vector3.zero;
                        highlightObj.transform.localRotation = Quaternion.identity;
                        highlightObj.transform.localScale = Vector3.one * 1.001f;
                        highlightObj.AddComponent<MeshFilter>().sharedMesh = obj.GetComponent<MeshFilter>().sharedMesh;
                        var highlightRenderer = highlightObj.AddComponent<MeshRenderer>();
                        var mats = new Material[meshRenderer.materials.Length];
                        for (int i = 0; i < mats.Length; i++)
                            mats[i] = highlightMat;
                        highlightRenderer.materials = mats;
                        highlightObjs[highlightMat].Add(highlightObj);
                    }

                    return true;
                }
            }

        }

        void ToggleHighlight(Hand hand, Material customMat, bool enableHighlight)
        {
            var highlightMat = customMat != null ? customMat : hightlightMaterial;
            highlightMat = highlightMat != null ? highlightMat : hand.defaultHighlight;
            if (highlightMat != null && highlightObjs.ContainsKey(highlightMat))
                for (int i = 0; i < highlightObjs[highlightMat].Count; i++)
                    highlightObjs[highlightMat][i].SetActive(enableHighlight);
        }

        /// <summary>Called when the hand starts aiming at this item for pickup</summary>
        protected internal virtual void Highlight(Hand hand, Material customMat = null, bool ignoreHighlightEvents = false) {
            if(!hightlighting) {
                hightlighting = true;
                if(!ignoreHighlightEvents && onHighlight != null)
                    onHighlight.Invoke(hand, this);
                if(!ignoreHighlightEvents && OnHighlightEvent != null)
                    OnHighlightEvent.Invoke(hand, this);
                TryCreateHighlight(customMat, hand);
                ToggleHighlight(hand, customMat, true);
            }
        }

        /// <summary>Called when the hand stops aiming at this item</summary>
        protected internal virtual void Unhighlight(Hand hand, Material customMat = null, bool ignoreHighlightEvents = false) {
            if(hightlighting) {
                if(!ignoreHighlightEvents && onUnhighlight != null)
                    onUnhighlight.Invoke(hand, this);
                if(!ignoreHighlightEvents && OnUnhighlightEvent != null)
                    OnUnhighlightEvent.Invoke(hand, this);
                hightlighting = false;
                ToggleHighlight(hand, customMat, false);
            }
        }





        /// <summary>Called by the hands Squeeze() function is called and this item is being held</summary>
        protected internal virtual void OnSqueeze(Hand hand) {
            OnSqueezeEvent?.Invoke(hand, this);
            onSqueeze?.Invoke(hand, this);
        }

        /// <summary>Called by the hands Unsqueeze() function is called and this item is being held</summary>
        protected internal virtual void OnUnsqueeze(Hand hand) {
            OnUnsqueezeEvent?.Invoke(hand, this);
            onUnsqueeze?.Invoke(hand, this);
        }

        /// <summary>Called by the hand when this item is started being grabbed</summary>
        protected internal virtual void OnBeforeGrab(Hand hand) {

            foreach(var collider in heldIgnoreColliders)
                hand.HandIgnoreCollider(collider, true);

            beingGrabbedBy.Add(hand);
            OnBeforeGrabEvent?.Invoke(hand, this);
            Unhighlight(hand, null);
            beingGrabbed = true;

            StartIgnoreRoutine(hand, false);
        }

        public bool IsOnlyBeingGrabbedBy(Hand hand) {
            return beingGrabbedBy.Contains(hand) && beingGrabbedBy.Count == 1;
        }


        protected void StartIgnoreRoutine(Hand hand, bool untilNone) {
            foreach(var grabbable in grabbableParents)
                if(grabbable.resetLayerRoutine.ContainsKey(hand)) {
                    if(grabbable.resetLayerRoutine[hand] != null)
                        grabbable.StopIgnoreRoutine(hand);
                    grabbable.resetLayerRoutine.Remove(hand);
                }

            foreach(var grabbable in grabbableChildren)
                if(grabbable.resetLayerRoutine.ContainsKey(hand)) {
                    if(grabbable.resetLayerRoutine[hand] != null)
                        grabbable.StopIgnoreRoutine(hand);
                    grabbable.resetLayerRoutine.Remove(hand);
                }

            if(resetLayerRoutine.ContainsKey(hand)) {
                if(resetLayerRoutine[hand] != null)
                    StopCoroutine(resetLayerRoutine[hand]);
                resetLayerRoutine.Remove(hand);
            }

            if(gameObject.activeInHierarchy) {
                if(untilNone)
                    resetLayerRoutine.Add(hand, StartCoroutine(IgnoreHandCollisionUntilNoneRoutine(hand, hand.maxGrabTime)));
                else
                    resetLayerRoutine.Add(hand, StartCoroutine(IgnoreHandCollision(hand, hand.maxGrabTime)));
            }

        }

        protected void StopIgnoreRoutine(Hand hand) {
            StopCoroutine(resetLayerRoutine[hand]);
        }

        /// <summary>Whether or not the hand can grab this grabbable</summary>
        public virtual bool CanGrab(HandBase hand) {
            return enabled && isGrabbable && (handType == HandType.both || (handType == HandType.left && hand.left) || (handType == HandType.right && !hand.left));
        }

        /// <summary>Called by the hand whenever this item is grabbed</summary>
        protected internal virtual void OnGrab(Hand hand) {

            if(beingGrabbedBy.Contains(hand))
                beingGrabbedBy.Remove(hand);

            if (rigidbodyDeactivated)
                ActivateRigidbody();

            if (lockHandOnGrab)
                hand.body.isKinematic = true;

            SetGrabbedRigidbodySettings();

            if(parentOnGrab) {
                rootTransform.parent = hand.transform.parent;
                foreach(var jointedBody in jointedBodies) {
                    jointedBody.transform.parent = hand.transform.parent;
                }
            }


            if(ignoreWeight) {
                if(!body.gameObject.CanGetComponent(out WeightlessFollower heldFollower))
                    heldFollower = body.gameObject.AddComponent<WeightlessFollower>();
                heldFollower?.Set(hand, this);
            }

            collisionTracker.enabled = true;

            heldBy?.Add(hand);
            placePoint?.Remove(this);
            onGrab?.Invoke(hand, this);
            OnGrabEvent?.Invoke(hand, this);

            wasForceReleased = false;
            beingGrabbed = false;
        }


        /// <summary>Called by the hand whenever this item is release</summary>
        protected internal virtual void OnRelease(Hand hand){

            if (heldBy.Contains(hand)) {
                bool canPlace = placePoint != null && placePoint.CanPlace(this);


                BreakHandConnection(hand);

                SetThrowVelocity(hand.ThrowVelocity(), hand.ThrowAngularVelocity());

                if(placePoint != null && canPlace)
                    placePoint.Place(this);



                OnReleaseEvent?.Invoke(hand, this);
                onRelease?.Invoke(hand, this);

                Unhighlight(hand, null);

            }
            else if(beingGrabbedBy.Contains(hand))
                hand.BreakGrabConnection();
        }

        /// <summary>Usually called through the release function. This function will release the connection to the hand and grabbable without calling the release events or applying throw force</summary>
        protected internal virtual void BreakHandConnection(Hand hand)
        {
            if(beingGrabbedBy.Contains(hand))
                beingGrabbedBy.Remove(hand);

            if (!heldBy.Remove(hand))
                return;

            ResetGrabbableAfterRlease();

            foreach(var collider in heldIgnoreColliders)
                hand.HandIgnoreCollider(collider, false);

            if (lockHandOnGrab)
                hand.body.isKinematic = false;

            if(ignoringHand.ContainsKey(hand))
                IgnoreHand(hand, false);

            if(gameObject.activeInHierarchy && !beingDestroyed)
                StartIgnoreRoutine(hand, true);

            if(beingGrabbedBy.Count == 0 && waitingToGrabHands.Count == 0)
                beingGrabbed = false;

            lastHeldBy = hand;
        }

        /// <summary>Tells each hand holding this object to release</summary>
        public virtual void HandsRelease() {
            for(int i = heldBy.Count - 1; i >= 0; i--)
                heldBy[i].Release();
        }

        /// <summary>Tells each hand holding this object to release</summary>
        public virtual void HandRelease(Hand hand) {
            if(heldBy.Contains(hand))
                hand.Release();
        }

        /// <summary>Forces all the hands on this object to relese without applying throw force or calling OnRelease event</summary>
        public virtual void ForceHandsRelease() {
            for(int i = waitingToGrabHands.Count - 1; i >= 0; i--) {
                waitingToGrabHands[i].BreakGrabConnection();
                waitingToGrabHands.RemoveAt(i);
            }

            for(int i = beingGrabbedBy.Count - 1; i >= 0; i--) {
                beingGrabbedBy[i].BreakGrabConnection();
            }

            for(int i = heldBy.Count - 1; i >= 0; i--) {
                wasForceReleased = true;
                ForceHandRelease(heldBy[i]);
            }
        }

        /// <summary>Forces all the hands on this object to relese without applying throw force</summary>
        public virtual void ForceHandRelease(Hand hand) {

            if(heldBy.Contains(hand)) {
                var throwMult = throwPower;
                throwPower = 0;
                wasForceReleased = true;
                hand.Release();
                throwPower = throwMult;
                if(body != null && !body.isKinematic)
                    body.linearVelocity = body.linearVelocity.normalized * Mathf.Clamp(body.linearVelocity.magnitude, 0, 1);
            }
            else if(beingGrabbedBy.Contains(hand))
                hand.BreakGrabConnection();
        }


        /// <summary>Called when the joint between the hand and this item is broken\n - Works to simulate pulling item apart event</summary>
        public virtual void OnHandJointBreak(Hand hand) {
            if(heldBy.Contains(hand)) {
                if (body != null){
                    body.WakeUp();
                    body.linearVelocity *= 0;
                    body.angularVelocity *= 0;
                }

                if(!pullApartBreakOnly) {
                    OnJointBreakEvent?.Invoke(hand, this);
                    OnJointBreak?.Invoke(hand, this);
                }
                if(pullApartBreakOnly && HeldCount() > 1) {
                    OnJointBreakEvent?.Invoke(hand, this);
                    OnJointBreak?.Invoke(hand, this);
                }

                ForceHandRelease(hand);

                if(heldBy.Count > 0)
                    heldBy[0].handFollow.SetHandLocation(heldBy[0].moveTo.position, heldBy[0].transform.rotation);
            }
        }

        //============================ GETTERS ============================
        //=================================================================
        //=================================================================


        /// <summary>Returns the list of hands that are currently holding this grabbables</summary>
        public List<Hand> GetHeldBy() {
            return heldBy;
        }

        /// <summary>Returns the list of hands that are currently holding this grabbables</summary>
        public List<Hand> GetHeldBy(bool includeChildGrabbables, bool includeParentrabbables) {
            List<Hand> hands = new List<Hand>();
            for(int i = 0; i < heldBy.Count; i++) {
                hands.Add(heldBy[i]);
            }

            if(includeChildGrabbables)
                for(int i = 0; i < grabbableChildren.Count; i++)
                    for(int j = 0; j < grabbableChildren[i].heldBy.Count; j++) 
                        hands.Add(grabbableChildren[i].heldBy[j]);

            if(includeParentrabbables)
                for(int i = 0; i < grabbableParents.Count; i++)
                    for(int j = 0; j < grabbableParents[i].heldBy.Count; j++)
                        hands.Add(grabbableParents[i].heldBy[j]);

            return hands;
        }

        /// <summary>Returns the hands local and held by jointed grabbables</summary>
        public List<Hand> GetJointedHeldBy()
        {
            List<Hand> hands = new List<Hand>();
            for (int i = 0; i < heldBy.Count; i++)
            {
                hands.Add(heldBy[i]);
            }
            for(int i = 0; i < jointedGrabbables.Count; i++) {
                for(int j = 0; j < jointedGrabbables[i].heldBy.Count; j++) {
                    hands.Add(jointedGrabbables[i].heldBy[j]);
                }
            }
            return hands;
        }


        /// <summary>Returns the number of hands currently holding this object [Call GetHeldBy() to get a list of the hand references]</summary>
        /// <param name="includedJointedCount">Whether or not to return the held count of only this grabbable, or the total of this grabbable and any jointed bodies with a grabbable attached</param>
        public virtual int HeldCount(bool includedJointedCount = true, bool includeChildGrabbables = true, bool includeParentrabbables = true) {
            var count = heldBy.Count;
            if(includedJointedCount)
                for(int i = 0; i < jointedGrabbables.Count; i++)
                    count += jointedGrabbables[i].HeldCount(false, true, true);

            if(includeChildGrabbables)
                for(int i = 0; i < grabbableChildren.Count; i++) 
                    count += grabbableChildren[i].HeldCount(false, false, false);

            if(includeParentrabbables)
                for(int i = 0; i < grabbableParents.Count; i++) 
                    count += grabbableParents[i].HeldCount(false, false, false);

            return count;
        }





        /// <summary>Returns true if this grabbable is currently being held</summary>
        public bool IsHeld() {
            return heldBy.Count > 0;
        }

        /// <summary>Returns true during hand grabbing coroutine</summary>
        public bool BeingGrabbed() {
            return beingGrabbed;
        }



        /// <summary>Plays haptic on each hand holding this grabbable</summary>
        public void PlayHapticVibration() {
            foreach(var hand in heldBy) {
                hand.PlayHapticVibration();
            }
        }

        /// <summary>Plays haptic on each hand holding this grabbable</summary>
        public void PlayHapticVibration(float duration = 0.025f) {
            foreach(var hand in heldBy) {
                hand.PlayHapticVibration(duration);
            }
        }

        /// <summary>Plays haptic on each hand holding this grabbable</summary>
        public void PlayHapticVibration(float duration, float amp = 0.5f) {
            foreach(var hand in heldBy) {
                hand.PlayHapticVibration(duration, amp);
            }
        }



        protected internal void SetThrowVelocity(Vector3 throwVel, Vector3 throwAngularVel) {
            if(body != null && !body.isKinematic && heldBy.Count == 0) {
                body.linearVelocity = throwVel * throwPower;
                if(!float.IsNaN(throwAngularVel.x) && !float.IsNaN(throwAngularVel.y) && !float.IsNaN(throwAngularVel.z))
                    body.angularVelocity = throwAngularVel;
            }
        }


        /// <summary>Returns the velocity of the grabbable, old function, recommend using body.velocity instead</summary>
        public Vector3 GetVelocity() {
            if (body == null)
                return Vector3.zero;
            return lastCenterOfMassPos - body.position;
        }


        /// <summary>Returns the angular velocity of the grabbable, old function, recommend using body.velocity instead</summary>
        public Vector3 GetAngularVelocity() {
            Quaternion deltaRotation = body.rotation * Quaternion.Inverse(lastCenterOfMassRot);
            deltaRotation.ToAngleAxis(out var angle, out var axis);
            angle *= Mathf.Deg2Rad;
            return (1.0f / Time.fixedDeltaTime) * angle / 1.2f * axis;
        }


        /// <summary>
        /// Adds a grabbable as a child to this one.
        /// A grabbable child is usually applied automatically when a grabbable parented below this another grabbable. 
        /// This connects the grabbable and allows events to be called and settings to be changed
        /// </summary>
        public void AddChildGrabbable(Grabbable grab) {
            if(!grabbableChildren.Contains(grab))
                grabbableChildren.Add(grab);
        }

        /// <summary>
        /// Removes a grabbable as a child to this one.
        /// </summary>
        public void RemoveChildGrabbable(Grabbable grab) {
            if(grabbableChildren.Contains(grab))
                grabbableChildren.Remove(grab);
        }

        /// <summary>Add a jointed rigidbody to this grabbable, important for continuity between a held object and it's jointed bodies</summary>
        public void AddJointedBody(Rigidbody body)
        {
            if (!jointedBodies.Contains(body))
            {
                if(body.gameObject.HasGrabbable(out Grabbable otherGrabbable)) {
                    if (otherGrabbable.parentOnGrab && HeldCount() > 0 && otherGrabbable.HeldCount() == 0 && rootTransform.parent != originalParent) { 
                        otherGrabbable.rootTransform.parent = rootTransform.parent;
                    }

                    jointedParents.Add(otherGrabbable.originalParent);
                    if(!jointedGrabbables.Contains(otherGrabbable))
                        jointedGrabbables.Add(otherGrabbable);

                }
                else
                    jointedParents.Add(body.transform.parent);

                jointedBodies.Add(body);

            }
        }

        /// <summary>Remove a jointed rigidbody in the jointedBodies list</summary>
        public void RemoveJointedBody(Rigidbody body) {
            if (jointedBodies.Contains(body))
            {
                var i = jointedBodies.IndexOf(body);

                jointedBodies.RemoveAt(i);

                if (body.gameObject.HasGrabbable(out var otherGrabbable)) {
                    if(jointedGrabbables.Contains(otherGrabbable)) {
                        jointedGrabbables.Remove(otherGrabbable);
                        if(otherGrabbable.HeldCount(false, true, true) == 0) {
                            otherGrabbable.rootTransform.parent = otherGrabbable.originalParent;
                            otherGrabbable.ResetGrabbedRigidbodySettings();
                        }
                    }

                }
                else
                    body.transform.parent = jointedParents[i];

                if(HeldCount() == 0 && rootTransform.parent != originalParent && parentOnGrab) {
                    ResetGrabbableAfterRlease();
                }

                jointedParents.RemoveAt(i);
            }
        }

        public void DoDestroy() {
            Destroy(gameObject);
        }

        /// <summary>Returns the total collision count of all this grabbable</summary>
        public int CollisionCount() {
            return collisionTracker.collisionObjects.Count;
        }

        /// <summary>Returns the total collision count of all the "jointed grabbables"</summary>
        public int JointedCollisionCount() {
            int count = 0;
            for(int i = 0; i < jointedGrabbables.Count; i++)
                count += jointedGrabbables[i].HeldCount();

            return count;
        }


        /// <summary>Sets the given place point to ignore this grabbables and all it's children</summary>
        public void PlacePointIgnore(PlacePoint point) {
            point.dontAllows.Add(rootGrabbable);
            foreach(var grabbable in rootGrabbable.grabbableChildren) {
                if(grabbable != this)
                    point.dontAllows.Add(grabbable);
            }
        }


        /// <summary>Sets the given place point to allow this grabbables and all it's children</summary>
        public void PlacePointAllow(PlacePoint point) {
            if(point.dontAllows.Contains(rootGrabbable))
                point.dontAllows.Remove(rootGrabbable);
            foreach(var grabbable in rootGrabbable.grabbableChildren) {
                if(grabbable != this && point.dontAllows.Contains(grabbable))
                    point.dontAllows.Remove(grabbable);
            }
        }


        //Adds a reference script to child colliders so they can be grabbed
        void MakeChildrenGrabbable() {
            for(int i = 0; i < transform.childCount; i++) {
                AddChildGrabbableRecursive(transform.GetChild(i));
            }

            void AddChildGrabbableRecursive(Transform obj) {
                if(obj.CanGetComponent(out Collider col) && col.isTrigger == false && !obj.CanGetComponent<IGrabbableEvents>(out _) && !obj.CanGetComponent<GrabbableChild>(out _) && !obj.CanGetComponent<PlacePoint>(out _)) {
                    var child = obj.gameObject.AddComponent<GrabbableChild>();
                    child.grabParent = this;
                }
                for(int i = 0; i < obj.childCount; i++) {
                    if(!obj.CanGetComponent<Grabbable>(out _))
                        AddChildGrabbableRecursive(obj.GetChild(i));
                }
            }
        }


        //Adds a reference script to child colliders so they can be grabbed
        void MakeChildrenUngrabbable() {
            for(int i = 0; i < transform.childCount; i++) {
                RemoveChildGrabbableRecursive(transform.GetChild(i));
            }

            void RemoveChildGrabbableRecursive(Transform obj) {
                if(obj.GetComponent<GrabbableChild>() && obj.GetComponent<GrabbableChild>().grabParent == this) {
                    Destroy(obj.gameObject.GetComponent<GrabbableChild>());
                }
                for(int i = 0; i < obj.childCount; i++) {
                    RemoveChildGrabbableRecursive(obj.GetChild(i));
                }
            }
        }


        bool rigidbodyGrabbedState;
        internal void SetGrabbedRigidbodySettings() {
            if(rigidbodyGrabbedState == false) {
                rigidbodyGrabbedState = true;

                if(body != null) {
                    body.collisionDetectionMode = body.isKinematic ? CollisionDetectionMode.ContinuousSpeculative : CollisionDetectionMode.ContinuousDynamic;
                    body.interpolation = RigidbodyInterpolation.None;
                    body.solverIterations = 100;
                    body.solverVelocityIterations = 100;

                    if(targetDrag == 0 && body.linearDamping < minHeldDrag) {
                        body.linearDamping = minHeldDrag;
                    }
                    if(targetAngularDrag == 0 && body.angularDamping < minHeldAngleDrag) {
                        body.angularDamping = minHeldAngleDrag;
                    }

                    if(targetMass == 0 && body.mass < minHeldMass) {
                        body.mass = minHeldMass;
                    }


                    for(int i = 0; i < jointedBodies.Count; i++) {
                        if(jointedBodies[i] != null && jointedBodies[i].gameObject.HasGrabbable(out var grab) && grab != this) {
                            grab.SetGrabbedRigidbodySettings();
                        }
                    }

                    if(heldNoFriction) {
                        var colliderMat = Resources.Load<PhysicsMaterial>("NoFriction");
                        SetPhysicsMaterial(colliderMat);
                    }

                }
            }
        }


        //Resets to original collision dection
        protected void ResetGrabbedRigidbodySettings() {
            if(rigidbodyGrabbedState) {
                if(body != null) {
                    body.collisionDetectionMode = detectionMode;
                    body.interpolation = startInterpolation;
                    body.solverIterations = Physics.defaultSolverIterations;
                    body.solverVelocityIterations = Physics.defaultSolverVelocityIterations;
                    body.linearDamping = targetDrag;
                    body.angularDamping = targetAngularDrag;
                    body.mass = targetMass;

                    if(heldNoFriction) {
                        ResetPhysicsMateiral();
                    }
                }

                rigidbodyGrabbedState = false;
                collisionTracker.enabled = false;
            }
        }


        /// <summary>INTERNAL - Sets the grabbables original layers</summary>
        protected internal void ResetGrabbableAfterRlease() {
            if(!beingDestroyed) {

                if(HeldCount() == 0 && gameObject.activeInHierarchy && parentOnGrab && (placePoint == null || !(placePoint.placedObject == this && placePoint.parentOnPlace))) {
                    rootTransform.parent = originalParent;
                }

                if(HeldCount() == 0) {
                    ResetGrabbedRigidbodySettings();
                }

                for(int i = 0; i < jointedBodies.Count; i++) {
                    if(jointedBodies[i].gameObject.HasGrabbable(out var grab)) {
                        if(grab.HeldCount() == 0) {
                            grab.rootTransform.parent = grab.originalParent;
                            grab.ResetGrabbedRigidbodySettings();
                        }
                        else if(parentOnGrab && grab.rootTransform.parent != grab.originalParent) {
                            rootTransform.parent = grab.rootTransform.parent;
                        }
                    }
                    else
                        jointedBodies[i].transform.parent = jointedParents[i];
                }
            }
        }

        public bool IsHolding(Rigidbody body)
        {

            foreach (var holding in heldBy)
            {
                if (holding.body == body)
                    return true;
            }

            return false;
        }

        public bool IsHolding(Hand hand)
        {
            foreach (var held in heldBy)
            {
                if (held == hand)
                    return true;
            }

            return false;
        }

        public virtual void OnHighlight(Hand hand) {
            Highlight(hand);
        }

        public virtual void OnUnhighlight(Hand hand) {
            OnUnhighlight(hand);
        }

        void IGrabbableEvents.OnGrab(Hand hand) {
            OnGrab(hand);
        }

        void IGrabbableEvents.OnRelease(Hand hand) {
            OnRelease(hand);
        }

        public Grabbable GetGrabbable() {
            return this;
        }

        public bool CanGrab(Hand hand) {
            if (hand == null)
                return false;
            return CanGrab(hand as HandBase);
        }


        internal void AddWaitingForGrab(Hand hand) {
            waitingToGrabHands.Add(hand);
        }

        internal void RemoveWaitingForGrab(Hand hand) {
            waitingToGrabHands.Remove(hand);
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/Grabbable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableChild.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 88c6f05faa8c57b4c83638f7f36c7c8f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;


namespace Autohand{
    /// <summary>
    /// THIS SCRIPT CAN BE ATTACHED TO A COLLIDER OBJECT TO REFERENCE A GRABBABLE BODY
    /// </summary>
    [DefaultExecutionOrder(1)]
    public class GrabbableChild : MonoBehaviour{
        public Grabbable grabParent;

        private void Start() {
            grabParent.SetGrabbableChild(this);
            if(gameObject.layer == LayerMask.NameToLayer("Default") || LayerMask.LayerToName(gameObject.layer) == "")
                gameObject.layer = LayerMask.NameToLayer(Hand.grabbableLayerNameDefault);

            var colliders = GetComponents<Collider>();
            foreach(Collider col in colliders) {
                if(col.isTrigger)
                    continue;

                if(!grabParent.grabColliders.Contains(col)) {
                    grabParent.grabColliders.Add(col);
                }
                if(col.gameObject.layer == LayerMask.NameToLayer("Default") || LayerMask.LayerToName(col.gameObject.layer) == "")
                    col.gameObject.layer = LayerMask.NameToLayer(Hand.grabbableLayerNameDefault);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableChild.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableCollisionHaptics.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 40c473564bfd20d4d86e896752dee195
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [RequireComponent(typeof(Grabbable))]
    public class GrabbableCollisionHaptics : MonoBehaviour {
        [Tooltip("The layers that cause the sound to play")]
        public LayerMask collisionTriggers = ~0;
        public float hapticAmp = 0.8f;
        public float velocityAmp = 0.5f;
        public float repeatDelay = 0.2f;
        public float maxDuration = 0.5f;
        [Tooltip("Source to play sound from")]
        public AnimationCurve velocityAmpCurve = AnimationCurve.Linear(0, 0, 1, 1);
        [Tooltip("Source to play sound from")]
        public AnimationCurve velocityDurationCurve = AnimationCurve.Linear(0, 0, 1, 1);

        Grabbable grab;
        Rigidbody body;
        bool canPlay = true;
        Coroutine playRoutine;

        private void Start() {
            body = GetComponent<Rigidbody>();
            grab = GetComponent<Grabbable>();

            //So the sound doesn't play when falling in place on start
            StartCoroutine(HapticPlayBuffer(1f));
        }

        private void OnDisable() {
            if(playRoutine != null)
                StopCoroutine(playRoutine);
        }

        void OnCollisionEnter(Collision collision) {
            if(canPlay && collisionTriggers == (collisionTriggers | (1 << collision.gameObject.layer))) {
                if(body != null) {
                    if(collision.collider.attachedRigidbody == null || collision.collider.attachedRigidbody.mass > 0.0000001f) {
                        var magnitude = collision.relativeVelocity.magnitude;
                        grab.PlayHapticVibration(Mathf.Clamp(velocityDurationCurve.Evaluate(magnitude), 0, maxDuration), velocityAmpCurve.Evaluate(magnitude * velocityAmp) * hapticAmp);
                        if(playRoutine != null)
                            StopCoroutine(playRoutine);
                        playRoutine = StartCoroutine(PlayBuffer());
                    }
                }
            }
        }

        IEnumerator PlayBuffer() {
            canPlay = false;
            yield return new WaitForSeconds(repeatDelay);
            canPlay = true;
            playRoutine = null;
        }

        IEnumerator HapticPlayBuffer(float time) {
            canPlay = false;
            yield return new WaitForSeconds(time);
            canPlay = true;
            playRoutine = null;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableCollisionHaptics.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b87d93cca04293d4cb59fd2373cfa5d4
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public struct SaveRigidbodyData {
        GameObject origin;
        float mass;
        float angularDrag;
        float drag;
        bool useGravity;
        bool isKinematic;
        RigidbodyInterpolation interpolation;
        CollisionDetectionMode collisionDetectionMode;
        RigidbodyConstraints constraints;

        public SaveRigidbodyData(Rigidbody from, bool removeBody = true) {
            origin = from.gameObject;
            mass = from.mass;
            drag = from.linearDamping;
            angularDrag = from.angularDamping;
            useGravity = from.useGravity;
            isKinematic = from.isKinematic;
            interpolation = from.interpolation;
            collisionDetectionMode = from.collisionDetectionMode;
            constraints = from.constraints;
            if(removeBody)
                GameObject.Destroy(from);
        }
        public SaveRigidbodyData(SaveRigidbodyData from) {
            origin = from.origin;
            mass = from.mass;
            drag = from.drag;
            angularDrag = from.angularDrag;
            useGravity = from.useGravity;
            isKinematic = from.isKinematic;
            interpolation = from.interpolation;
            collisionDetectionMode = from.collisionDetectionMode;
            constraints = from.constraints;
        }

        public Transform GetOrigin() {
            return origin.transform;
        }

        public bool IsSet() {
            return origin != null;
        }

        public Rigidbody ReloadRigidbody() {
            if(origin != null) {
                if(origin.CanGetComponent<Rigidbody>(out var currBody))
                    return currBody;
                var from = origin.AddComponent<Rigidbody>();
                if(from != null) {
                    from.mass = mass;
                    from.linearDamping = drag;
                    from.angularDamping = angularDrag;
                    from.useGravity = useGravity;
                    from.isKinematic = isKinematic;
                    from.interpolation = interpolation;
                    from.collisionDetectionMode = collisionDetectionMode;
                    from.constraints = constraints;
                    origin = null;
                    return from;
                }
            }
            return null;
        }
    }


    public static class GrabbableExtensions {

        public static bool GetGrabPose(this Grabbable grabbable, Hand hand, out GrabbablePose grabPose) {
            grabPose = null;
            if (grabbable == null)
            {
                return false;
            }
            
            if(grabbable.GetSavedPose(out var poseCombiner) && poseCombiner.CanSetPose(hand, grabbable)) {
                grabPose = poseCombiner.GetClosestPose(hand, grabbable);
                return true;
            }

            return false;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableExtensions.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableExtraEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 35d8771252739254ea3bf5819ffad032
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [RequireComponent(typeof(Grabbable))]
    public class GrabbableExtraEvents : MonoBehaviour {
        public UnityHandGrabEvent OnFirstGrab;
        public UnityHandGrabEvent OnLastRelease;
        public UnityHandGrabEvent OnTwoHandedGrab;
        public UnityHandGrabEvent OnTwoHandedRelease;

        [Space]
        public UnityPlacePointEvent OnPlacePointAdd;
        public UnityPlacePointEvent OnPlacePointRemove;
        public UnityPlacePointEvent OnPlacePointHighlight;
        public UnityPlacePointEvent OnPlacePointUnhighlight;


        Grabbable grab;

        void OnEnable() {
            grab = GetComponent<Grabbable>();
            grab.OnGrabEvent += Grab;
            grab.OnReleaseEvent += Release;
            grab.OnPlacePointAddEvent += PlacePointAdd;
            grab.OnPlacePointRemoveEvent += PlacePointRemove;
            grab.OnPlacePointHighlightEvent += PlacePointHighlight;
            grab.OnPlacePointUnhighlightEvent += PlacePointUnhighlight;
        }

        void OnDisable() {
            grab = grab ?? GetComponent<Grabbable>();
            grab.OnGrabEvent -= Grab;
            grab.OnReleaseEvent -= Release;
            grab.OnPlacePointAddEvent -= PlacePointAdd;
            grab.OnPlacePointRemoveEvent -= PlacePointRemove;
            grab.OnPlacePointHighlightEvent -= PlacePointHighlight;
            grab.OnPlacePointUnhighlightEvent -= PlacePointUnhighlight;


        }

        public void PlacePointAdd(PlacePoint point, Grabbable grab) {
            OnPlacePointAdd?.Invoke(point, grab);
        }

        public void PlacePointRemove(PlacePoint point, Grabbable grab) {
            OnPlacePointRemove?.Invoke(point, grab);
        }

        public void PlacePointHighlight(PlacePoint point, Grabbable grab) {
            OnPlacePointHighlight?.Invoke(point, grab);
        }

        public void PlacePointUnhighlight(PlacePoint point, Grabbable grab) {
            OnPlacePointUnhighlight?.Invoke(point, grab);
        }

        public void Grab(Hand hand, Grabbable grab) {
            if(grab.HeldCount() == 1) {
                OnFirstGrab?.Invoke(hand, grab);
            }
            if(grab.HeldCount() == 2) {
                OnTwoHandedGrab?.Invoke(hand, grab);
            }
        }

        public void Release(Hand hand, Grabbable grab) {
            if(grab.HeldCount() == 0) {
                OnLastRelease?.Invoke(hand, grab);
            }
            if(grab.HeldCount() == 1) {
                OnTwoHandedRelease?.Invoke(hand, grab);
            }
        }
    }

}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableExtraEvents.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableOnlyJoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 87627214e167368439a3b48bdbc35bce
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    //This component will freeze an attached grabbable joint with a fixed joint while not being held 
    [RequireComponent(typeof(Grabbable))]
    public class GrabbableOnlyJoint : MonoBehaviour {
        public Grabbable jointedGrabbable;
        public bool resetOnRelease = true;

        Grabbable localGrabbable;

        Joint freezeJoint;
        Vector3 localStartPosition;
        Quaternion localStartRotation;

        void Start() {
            localGrabbable = GetComponent<Grabbable>();
            localGrabbable.OnGrabEvent += OnGrab;
            localGrabbable.OnReleaseEvent += OnRelease;
            localStartPosition = jointedGrabbable.transform.InverseTransformPoint(transform.position);
            localStartRotation = Quaternion.Inverse(jointedGrabbable.transform.rotation) * transform.rotation;

            freezeJoint = localGrabbable.gameObject.AddComponent<FixedJoint>().GetCopyOf(Resources.Load<FixedJoint>("DefaultJoint"));
            freezeJoint.anchor = Vector3.zero;
            freezeJoint.breakForce = float.PositiveInfinity;
            freezeJoint.breakTorque = float.PositiveInfinity;
            freezeJoint.connectedBody = jointedGrabbable.body;
        }

        void OnGrab(Hand hand, Grabbable grab) {
            if(grab.GetHeldBy().Count == 1) {
                Destroy(freezeJoint);
                freezeJoint = null;
            }
        }
        void OnRelease(Hand hand, Grabbable grab) {
            if(grab.GetHeldBy().Count == 0) {
                transform.position = jointedGrabbable.transform.TransformPoint(localStartPosition);
                transform.rotation = jointedGrabbable.transform.rotation * localStartRotation;
                localGrabbable.body.position = transform.position;
                localGrabbable.body.rotation = transform.rotation;

                Invoke("CreateJoint", Time.fixedDeltaTime + Time.deltaTime);
            }
        }

        private void LateUpdate() {
            if(freezeJoint != null) {
                transform.position = jointedGrabbable.transform.TransformPoint(localStartPosition);
                transform.rotation = jointedGrabbable.transform.rotation * localStartRotation;
            }
        }

        void CreateJoint() {
            freezeJoint = localGrabbable.gameObject.AddComponent<FixedJoint>().GetCopyOf(Resources.Load<FixedJoint>("DefaultJoint"));
            freezeJoint.anchor = Vector3.zero;
            freezeJoint.breakForce = float.PositiveInfinity;
            freezeJoint.breakTorque = float.PositiveInfinity;
            freezeJoint.connectedBody = jointedGrabbable.body;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableOnlyJoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePose.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5143e42808965614a9bb64f4880aaf33
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using NaughtyAttributes;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Autohand{


#if UNITY_EDITOR
    [CanEditMultipleObjects]
#endif
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/custom-poses"), DefaultExecutionOrder(1000)]
    public class GrabbablePose : HandPoseDataContainer{
        public bool poseEnabled = true;
        [Tooltip("Whether or not this pose can be used by both hands at once or only one hand at a time")]
        public bool singleHanded = false;


        [AutoSmallHeader("Advanced Settings")]
        public bool showAdvanced = true;
        public float positionWeight = 1;
        public float rotationWeight = 1;
        [Tooltip("These poses will only be enabled when this pose is active. Great for secondary poses like holding the front of a gun with your second hand, only while holding the trigger")]
        public GrabbablePose[] linkedPoses;


        protected HandPoseData poseDataNonAlloc;

        public Grabbable grabbable { get; internal set; }
        public List<Hand> posingHands { get; protected set; }



        protected virtual void Awake()  {
            posingHands = new List<Hand>();
            if (poseScriptable != null)
            {
                if (poseScriptable.leftSaved)
                    leftPoseSet = true;
                if (poseScriptable.rightSaved)
                    rightPoseSet = true;
            }

            for (int i = 0; i < linkedPoses.Length; i++)
                linkedPoses[i].poseEnabled = false;

            if(leftPoseSet)
                poseDataNonAlloc = new HandPoseData(ref leftPose);
            else if(rightPoseSet)
                poseDataNonAlloc = new HandPoseData(ref rightPose);
        }

        protected virtual void OnEnable() {
            grabbable.onRelease.AddListener(OnRelease);
        }

        protected virtual void OnDisable() {
            grabbable.onRelease.RemoveListener(OnRelease);
        }

        protected virtual void OnRelease(Hand hand, Grabbable grab) {
            if(posingHands.Contains(hand))
                posingHands.Remove(hand);
        }


        public bool CanSetPose(Hand hand, Grabbable grab) {
            if(singleHanded && posingHands.Count > 0 && !posingHands.Contains(hand) && !(grab.singleHandOnly && grab.allowHeldSwapping))
                return false;
            if(hand.poseIndex != poseIndex)
                return false;
            if(hand.left && !leftPoseSet)
                return false;
            if(!hand.left && !rightPoseSet)
                return false;

            return poseEnabled;
        }


        public virtual ref HandPoseData GetHandPoseData(Hand hand) {
            if(poseScriptable != null) {
                if(hand.left)
                    return ref poseScriptable.leftPose;
                else
                    return ref poseScriptable.rightPose;
            }
            
            if(hand.left)
                return ref leftPose;
            else                 
                return ref rightPose;
        }


        /// <summary>Sets the hand to this pose, make sure to check CanSetPose() flag for proper use</summary>
        /// <param name="isProjection">for pose projections, so they wont fill condition for single handed before grab</param>
        public virtual void SetHandPose(Hand hand, bool isProjection = false) {
            if(!isProjection) {
                if(!posingHands.Contains(hand))
                    posingHands.Add(hand);

                for(int i = 0; i < linkedPoses.Length; i++)
                    linkedPoses[i].poseEnabled = true;
            }

            GetHandPoseData(hand).SetPose(hand, transform);
        }


        public virtual void CancelHandPose(Hand hand) {
            if(posingHands.Contains(hand)) {
                posingHands.Remove(hand);
            }

            for(int i = 0; i < linkedPoses.Length; i++)
                linkedPoses[i].poseEnabled = false;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePose.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseAdvanced.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: c49b27d5a0e0d4dd8ab20e2bed42e835
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using NaughtyAttributes;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Autohand {
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/custom-poses#advanced-grabbable-pose")]
    public class GrabbablePoseAdvanced : GrabbablePose{
        [Tooltip("Usually this can be left empty, used to create a different center point if the objects transform isn't ceneterd for the prefered rotation/movement axis")]
        public Transform centerObject;
        [Space]
        [Tooltip("You want this set so the disc gizmo is around the axis you want the hand to rotate, or that the line is straight through the axis you want to move")]
        public Vector3 up = Vector3.up;
        [Space, Tooltip("Whether or not to automatically allow for the opposite direction pose to be automatically applied (I.E. Should I be able to grab my hammer only with the head facing up, or in both directions?)")]
        public bool useInvertPose = false;

        [Space]
        [Tooltip("The minimum angle rotation around the included directions")]
        public int minAngle = 0;
        [Tooltip("The maximum angle rotation around the included directions")]
        public int maxAngle = 360;
        [Space]
        [Tooltip("The minimum distance allowed from the saved posed along the included directions")]
        public float maxRange = 0;
        [Tooltip("The maximum distance allowed from the saved posed along the included directions")]
        public float minRange = 0;

        [Header("Requires Gizmos Enabled")]
        [Tooltip("Helps test pose by setting the angle of the editor hand, REQUIRES GIZMOS ENABLED")]
        public int testAngle = 0;
        [Tooltip("Helps test pose by setting the range position of the editor hand, REQUIRES GIZMOS ENABLED")]
        public float testRange = 0;


        int lastAngle = 0;
        float lastRange = 0;

        Vector3 pregrabPos;
        Quaternion pregrabRot;
        Transform tempContainer;
        Transform handMatch;
        Transform getTransform;


        protected override void Awake() {
            base.Awake();
            if (minAngle > maxAngle) {
                var tempAngle = minAngle;
                minAngle = maxAngle;
                maxAngle = tempAngle;
            }
            if (minRange > maxRange) {
                var temp = minRange;
                minRange = maxRange;
                maxRange = temp;
            }
        }

        public override ref HandPoseData GetHandPoseData(Hand hand) {
            pregrabPos = hand.transform.position;
            pregrabRot = hand.transform.rotation;

            var preGrabPose = new HandPoseData(hand, transform);
            base.GetHandPoseData(hand).SetPose(hand, transform);

            getTransform = GetTransform();

            tempContainer = AutoHandExtensions.transformRuler;
            tempContainer.rotation = Quaternion.identity;
            tempContainer.position = getTransform.position;
            tempContainer.localScale = getTransform.lossyScale;

            handMatch = AutoHandExtensions.transformRulerChild;
            handMatch.position = hand.transform.position;
            handMatch.rotation = hand.transform.rotation;

            tempContainer.rotation = getTransform.rotation;


            var closestRotation = GetClosestRotation(hand, up, useInvertPose);

            tempContainer.rotation = closestRotation;

            var closestPosition = GetClosestPosition(up);

            tempContainer.position = closestPosition;
            hand.transform.position = handMatch.position;
            hand.transform.rotation = handMatch.rotation;

            //var pose = new HandPoseData(hand, transform);
            poseDataNonAlloc.SavePose(hand, transform);
            preGrabPose.SetPose(hand);

#if UNITY_EDITOR
            if(Application.isEditor && !Application.isPlaying)
                DestroyImmediate(tempContainer.gameObject);
#endif

            return ref poseDataNonAlloc;
        }

        public Quaternion GetClosestRotation(Hand hand, Vector3 up, bool addInverse) {
            tempContainer = AutoHandExtensions.transformRuler;
            tempContainer.rotation = Quaternion.identity;
            tempContainer.position = getTransform.position;
            tempContainer.localScale = getTransform.lossyScale;

            handMatch = AutoHandExtensions.transformRulerChild;
            handMatch.position = hand.transform.position;
            handMatch.rotation = hand.transform.rotation;

            tempContainer.rotation = getTransform.rotation;
            Quaternion closestRotation = tempContainer.rotation;

            //if((minAngle != 0 || maxAngle != 0 || addInverse) && !(minAngle == maxAngle))
           // {
                float closestDistance = float.MaxValue;
                float closestIndex = 0;

                var iteration = (Mathf.Abs(minAngle) + Mathf.Abs(maxAngle))/10f;
                if(iteration == 0)
                    iteration = 1;
                var additionalDirection = Vector3.zero;
                if(up.x != 0)
                    additionalDirection = new Vector3(0, 1, 0);
                else if(up.y != 0)
                    additionalDirection = new Vector3(1, 0, 0);
                else if(up.z != 0)
                    additionalDirection = new Vector3(0, 0, 1);

                for (float i = minAngle; i <= maxAngle; i += iteration) {
                    tempContainer.eulerAngles = getTransform.rotation * up;
                    tempContainer.RotateAround(getTransform.position, getTransform.rotation * up, i);


                    var distance = Vector3.Distance(handMatch.position, pregrabPos);
                    distance += Quaternion.Angle(handMatch.rotation, pregrabRot)/180f;
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestRotation = tempContainer.rotation;
                        closestIndex = i;
                    }
                }

                for (float i = -iteration/2; i < iteration/2; i += iteration/10f) {
                    tempContainer.eulerAngles = getTransform.rotation * up;
                    tempContainer.RotateAround(getTransform.position, getTransform.rotation * up, closestIndex + i);

                    var distance = Vector3.Distance(handMatch.position, pregrabPos);
                    distance += Quaternion.Angle(handMatch.rotation, pregrabRot)/180f;
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestRotation = tempContainer.rotation;
                        closestIndex = i;
                    }
                }

                if(addInverse) {
                    var closestInverseDistance = float.MaxValue;
                    float closestInverseIndex = 0;
                    for(float i = minAngle; i <= maxAngle; i += iteration) {
                        tempContainer.eulerAngles = getTransform.rotation * up;
                        tempContainer.RotateAround(getTransform.position, getTransform.rotation * up, i);
                        tempContainer.RotateAround(getTransform.position, getTransform.rotation * additionalDirection, 180);


                        var distance = Vector3.Distance(handMatch.position, pregrabPos);
                        distance += Quaternion.Angle(handMatch.rotation, pregrabRot)/180f;
                        if(distance < closestInverseDistance) {
                            closestInverseDistance = distance; 
                            if(closestInverseDistance < closestDistance)
                                closestRotation = tempContainer.rotation;
                            closestInverseIndex = i;
                        }
                    }

                    for(float i = -iteration / 2; i < iteration / 2; i += iteration / 10f) {
                        tempContainer.eulerAngles = getTransform.rotation * up;
                        tempContainer.RotateAround(getTransform.position, getTransform.rotation * up, closestInverseIndex + i);
                        tempContainer.RotateAround(getTransform.position, getTransform.rotation * additionalDirection, 180);

                        var distance = Vector3.Distance(handMatch.position, pregrabPos);
                        distance += Quaternion.Angle(handMatch.rotation, pregrabRot) / 180f;
                        if(distance < closestInverseDistance) {
                            closestInverseDistance = distance;
                            if(closestInverseDistance < closestDistance)
                                closestRotation = tempContainer.rotation;
                            closestInverseIndex = i;
                        }
                    }
                }

            //}

            return closestRotation;
        }


        public Vector3 GetClosestPosition(Vector3 up)
        {

            Vector3 closestPosition = tempContainer.position;

            if (minRange != 0 || maxRange != 0)
            {
                float closestDistance = float.MaxValue;
                float closestIndex = 0;

                var minRangeVec = getTransform.position + getTransform.rotation * up * minRange;
                var maxRangeVec = getTransform.position + getTransform.rotation * up * maxRange;

                for (int i = 0; i < 10; i++)
                {
                    tempContainer.position = Vector3.Lerp(minRangeVec, maxRangeVec, i / 10f);

                    var distance = Vector3.Distance(handMatch.position, pregrabPos);
                    if (distance < closestDistance)
                    {
                        closestDistance = distance;
                        closestPosition = tempContainer.position;
                        closestIndex = i;
                    }
                }

                for (int i = -5; i < 5; i++)
                {
                    tempContainer.position = Vector3.Lerp(minRangeVec, maxRangeVec, closestIndex + i / 100f);

                    var distance = Vector3.Distance(handMatch.position, pregrabPos);
                    if (distance < closestDistance)
                    {
                        closestDistance = distance;
                        closestPosition = tempContainer.position;
                    }
                }
            }

            return closestPosition;
        }

        public HandPoseData GetHandPoseData(Hand hand, int angle, float range) {
            base.GetHandPoseData(hand).SetPosition(hand, transform);

            var getTransform = GetTransform();

            var tempContainer = AutoHandExtensions.transformRuler;
            tempContainer.rotation = Quaternion.identity;
            tempContainer.position = getTransform.position;
            tempContainer.localScale = getTransform.lossyScale;

            var handMatch = AutoHandExtensions.transformRulerChild;
            handMatch.position = hand.transform.position;
            handMatch.rotation = hand.transform.rotation;

            tempContainer.rotation = getTransform.rotation;

            tempContainer.eulerAngles = getTransform.rotation * up;
            tempContainer.RotateAround(tempContainer.transform.position, getTransform.rotation * up, angle);
            tempContainer.transform.position = getTransform.position +  getTransform.rotation * up * range;

            hand.transform.position = handMatch.position;
            hand.transform.rotation = handMatch.rotation;
            tempContainer.localScale = Vector3.one;

#if UNITY_EDITOR
            if(Application.isEditor)
                DestroyImmediate(tempContainer.gameObject);
#endif

            return base.GetHandPoseData(hand);
        }

        Transform GetTransform() {
            return centerObject != null ? centerObject : transform;
        }

#if UNITY_EDITOR
        protected override void OnDrawGizmosSelected() {
            if(Application.isPlaying)
                return;

            base.OnDrawGizmosSelected();

            var usingTransform = GetTransform();
            var radius = 0.1f;
            
            var pose = HasPose(false) ? rightPose : leftPose;

            var handDir = Quaternion.AngleAxis(minAngle, usingTransform.rotation * up) * pose.handOffset.normalized;
            Handles.DrawWireArc(usingTransform.position, usingTransform.rotation * up, handDir, maxAngle-minAngle, radius);
            
            var minRangeVec = usingTransform.position + usingTransform.rotation * up * minRange;
            var maxRangeVec = usingTransform.position + usingTransform.rotation * up * maxRange;
            Gizmos.DrawLine(usingTransform.position, minRangeVec);
            Gizmos.DrawLine(usingTransform.position, maxRangeVec);

            EditorTestValues(editorHand);
        }

        public void EditorTestValues(Hand editorHand) {

            if(grabbable == null)
                grabbable = GetComponentInParent<Grabbable>();

            if(editorHand != null && (testAngle != lastAngle || testRange != lastRange) && (lastAngle != 0 || lastRange != 0)) {
                testAngle = Mathf.Clamp(testAngle, minAngle, maxAngle);
                testRange = Mathf.Clamp(testRange, minRange, maxRange);

                if(minAngle > maxAngle) {
                    var temp = minAngle;
                    minAngle = maxAngle;
                    maxAngle = temp;
                }
                if(minRange > maxRange) {
                    var temp = minRange;
                    minRange = maxRange;
                    maxRange = temp;
                }

                GetHandPoseData(editorHand, testAngle, testRange);
            }

            lastAngle = testAngle;
            lastRange = testRange;
        }
#endif
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseAdvanced.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseCombiner.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ac82bc3766612f34da61b06da6008fa9
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    public class GrabbablePoseCombiner : MonoBehaviour{
        public List<GrabbablePose> poses = new List<GrabbablePose>();


        public bool CanSetPose(Hand hand, Grabbable grab) {
            foreach(var pose in poses) {
                if(pose != null && pose.CanSetPose(hand, grab))
                    return true;
            }
            return false;
        }

        public void AddPose(GrabbablePose pose) {
            if(!poses.Contains(pose))
                poses.Add(pose);
        }

        private void OnDestroy()
        {
            for (int i = poses.Count - 1; i >= 0; i--)
            {
                Destroy(poses[i]);
            }
        }

        public GrabbablePose GetClosestPose(Hand hand, Grabbable grab) {
            List<GrabbablePose> possiblePoses = new List<GrabbablePose>();
            foreach(var handPose in this.poses)
                if(handPose != null && handPose.CanSetPose(hand, grab))
                    possiblePoses.Add(handPose);
            
            float closestValue = float.MaxValue;
            int closestIndex = 0;

            var handPosition = hand.transform.position;
            var handRotation = hand.transform.rotation;


            for (int i = 0; i < possiblePoses.Count; i++){

                var pose = possiblePoses[i].GetHandPoseData(hand);
                var poseGlobalPosition = possiblePoses[i].transform.TransformPoint(pose.handOffset);
                var poseGlobalRotation = possiblePoses[i].transform.rotation * pose.localQuaternionOffset;

                var distance = Vector3.Distance(poseGlobalPosition, handPosition);
                var angleDistance = Quaternion.Angle(poseGlobalRotation, handRotation) / 270f;

                var closenessValue = distance / possiblePoses[i].positionWeight + angleDistance / possiblePoses[i].rotationWeight;
                if(closenessValue < closestValue) {
                    closestIndex = i;
                    closestValue = closenessValue;
                }
            }

            hand.transform.position = handPosition;
            hand.transform.rotation = handRotation;
            Physics.SyncTransforms();

            return possiblePoses[closestIndex];
        }

        internal int PoseCount() {
            return poses.Count;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseCombiner.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseGizmo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0c0eed604b5d993409380c03ea7c6408
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace Autohand {
    public class GrabbablePoseGizmo : MonoBehaviour {
        public GrabbablePose grabbablePose;
        public bool showRightPose = true;
        public bool showLeftPose = false;

        private void OnDrawGizmos() {
            if(grabbablePose == null)
                return;

            if(grabbablePose.rightPoseSet && showRightPose) {
                foreach(var fingerPose in grabbablePose.rightPose.fingerPoses) {
                    if(fingerPose.isSet) {
                        DrawFingerPoseExample(fingerPose, grabbablePose.rightPose.GetHandToWorldMatrix(grabbablePose.transform), Color.cyan);
                    }
                }

                DrawHandShapeExample(grabbablePose.rightPose, grabbablePose.transform.localToWorldMatrix, Color.cyan);
            }

            if(grabbablePose.leftPoseSet && showLeftPose) {
                foreach(var fingerPose in grabbablePose.leftPose.fingerPoses) {
                    if(fingerPose.isSet) {
                        DrawFingerPoseExample(fingerPose, grabbablePose.leftPose.GetHandToWorldMatrix(grabbablePose.transform), Color.cyan);
                    }
                }
            }
        }

        private void DrawFingerPoseRecursiveExample(FingerPoseData fingerPose, Matrix4x4 handToWorld, Color color) {
            Matrix4x4 parentMatrix = handToWorld;
            Matrix4x4 prevMatrix = parentMatrix;
            
            for(int i = 0; i < fingerPose.poseRelativeMatrix.Length; i++) {
                Matrix4x4 jointMatrix = prevMatrix * fingerPose.poseRelativeMatrix[i];
                Vector3 position = AutoHandExtensions.ExtractPosition(ref jointMatrix);
                var newColor = color * (i + 1f)/3f;
                newColor.a = 1f;
                Gizmos.color = newColor;
                Gizmos.DrawWireSphere(position, 0.004f);
                if(i > 0)
                    Gizmos.DrawLine(AutoHandExtensions.ExtractPosition(ref prevMatrix), position);

                prevMatrix = jointMatrix; 
            }
        }

        public static void DrawHandGizmo(HandPoseData pose, Transform relativeTo, Color color) {
            var handGlobalMatrix = pose.GetHandToWorldMatrix(relativeTo);
            foreach(var fingerPose in pose.fingerPoses)
                if(fingerPose.isSet)
                    DrawFingerPoseExample(fingerPose, handGlobalMatrix, color);
            DrawHandShapeExample(pose, handGlobalMatrix, color);

        }

        public static void DrawHandGizmo(HandPoseData pose, Matrix4x4 relativeTo, Color color) {
            var handGlobalMatrix = relativeTo;
            foreach(var fingerPose in pose.fingerPoses)
                if(fingerPose.isSet)
                    DrawFingerPoseExample(fingerPose, handGlobalMatrix, color);
            DrawHandShapeExample(pose, handGlobalMatrix, color);

        }


        public static void DebugDrawFingerPose(FingerPoseData fingerPose, Matrix4x4 handToWorld, Color color) {

            Matrix4x4 handGlobalMatrix = handToWorld;
            var kuckleToHandMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            var middleToKnuckleMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.middle];
            var distalToMiddleMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.distal];
            var tipToDistalMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.tip];

            var knuckleGlobalMatrix = handGlobalMatrix * kuckleToHandMatrix;
            var middleGlobalMatrix = knuckleGlobalMatrix * middleToKnuckleMatrix;
            var distalGlobalMatrix = middleGlobalMatrix * distalToMiddleMatrix;
            var tipGlobalMatrix = distalGlobalMatrix * tipToDistalMatrix;

            var handPosition = AutoHandExtensions.ExtractPosition(ref handGlobalMatrix);
            var knucklePosition = AutoHandExtensions.ExtractPosition(ref knuckleGlobalMatrix);
            var middlePosition = AutoHandExtensions.ExtractPosition(ref middleGlobalMatrix);
            var distalPosition = AutoHandExtensions.ExtractPosition(ref distalGlobalMatrix);
            var tipPosition = AutoHandExtensions.ExtractPosition(ref tipGlobalMatrix);

            Debug.DrawLine(handPosition, knucklePosition, color);
            Debug.DrawLine(knucklePosition, middlePosition, color);
            Debug.DrawLine(middlePosition, distalPosition, color);
            Debug.DrawLine(distalPosition, tipPosition, color);
        }

            public static void DrawFingerPoseExample(FingerPoseData fingerPose, Matrix4x4 handToWorld,  Color color) {
           // grabbableToWorld = Matrix4x4.TRS(grabbableToWorld.ExtractPosition(), grabbableToWorld.ExtractRotation(), Vector3.one);
           // handToGrabbable = Matrix4x4.TRS(handToGrabbable.ExtractPosition(), handToGrabbable.ExtractRotation(), Vector3.one);
           
            Matrix4x4 handGlobalMatrix = handToWorld;
            var kuckleToHandMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            var middleToKnuckleMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.middle];
            var distalToMiddleMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.distal];
            var tipToDistalMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.tip];

            var knuckleGlobalMatrix = handGlobalMatrix * kuckleToHandMatrix;
            var middleGlobalMatrix = knuckleGlobalMatrix * middleToKnuckleMatrix;
            var distalGlobalMatrix = middleGlobalMatrix * distalToMiddleMatrix;
            var tipGlobalMatrix = distalGlobalMatrix * tipToDistalMatrix;

            var handPosition = AutoHandExtensions.ExtractPosition(ref handGlobalMatrix);
            var knucklePosition = AutoHandExtensions.ExtractPosition(ref knuckleGlobalMatrix);
            var middlePosition = AutoHandExtensions.ExtractPosition(ref middleGlobalMatrix);
            var distalPosition = AutoHandExtensions.ExtractPosition(ref distalGlobalMatrix);
            var tipPosition = AutoHandExtensions.ExtractPosition(ref tipGlobalMatrix);


            Gizmos.color = color;
            Gizmos.DrawLine(handPosition, knucklePosition);
            Gizmos.DrawLine(knucklePosition, middlePosition);
            Gizmos.DrawLine(middlePosition, distalPosition);
            Gizmos.DrawLine(distalPosition, tipPosition);
        }

        public static void DrawHandShapeExample(HandPoseData pose, Matrix4x4 handGlobalMatrix, Color color) {
            var thumbKnuckleGlobalMatrix = handGlobalMatrix * pose.fingerPoses[(int)FingerEnum.thumb].poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            var indexKnuckleGlobalMatrix = handGlobalMatrix * pose.fingerPoses[(int)FingerEnum.index].poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            var middleKnuckleGlobalMatrix = handGlobalMatrix * pose.fingerPoses[(int)FingerEnum.middle].poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            var ringKnuckleGlobalMatrix = handGlobalMatrix * pose.fingerPoses[(int)FingerEnum.ring].poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            var pinkyKnuckleGlobalMatrix = handGlobalMatrix * pose.fingerPoses[(int)FingerEnum.pinky].poseRelativeMatrix[(int)FingerJointEnum.knuckle];        

            //Line from thumb to index
            Gizmos.color = color;
            Gizmos.DrawLine(AutoHandExtensions.ExtractPosition(ref thumbKnuckleGlobalMatrix), AutoHandExtensions.ExtractPosition(ref indexKnuckleGlobalMatrix));
            Gizmos.DrawLine(AutoHandExtensions.ExtractPosition(ref indexKnuckleGlobalMatrix), AutoHandExtensions.ExtractPosition(ref middleKnuckleGlobalMatrix));
            Gizmos.DrawLine(AutoHandExtensions.ExtractPosition(ref middleKnuckleGlobalMatrix), AutoHandExtensions.ExtractPosition(ref ringKnuckleGlobalMatrix));
            Gizmos.DrawLine(AutoHandExtensions.ExtractPosition(ref ringKnuckleGlobalMatrix), AutoHandExtensions.ExtractPosition(ref pinkyKnuckleGlobalMatrix));
            Gizmos.DrawLine(AutoHandExtensions.ExtractPosition(ref pinkyKnuckleGlobalMatrix), AutoHandExtensions.ExtractPosition(ref thumbKnuckleGlobalMatrix));
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbablePoseGizmo.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableSubstitute.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 3f1287143c1c3fa478149aeec0c569a2
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    /// <summary>Takes a reference for a disabled grabbable, and grabs that instead</summary>
    [RequireComponent(typeof(Grabbable))]
    public class GrabbableSubstitute : MonoBehaviour{
        [Tooltip("Whether or not to disable this gameobject on grab")]
        public bool disableOnGrab = true;
        [Tooltip("If true, the substitute will return to the this local location and turn off and the local grabbable will turn back on")]
        public bool returnOnRelease = false;
        public Grabbable grabbableSubstitute;

        Grabbable localGrabbable;

        private void Start() {
            localGrabbable = GetComponent<Grabbable>();
            localGrabbable.OnGrabEvent += OnGrabOriginal;
            grabbableSubstitute.OnReleaseEvent += OnReleaseSub;
        }

        void OnGrabOriginal(Hand hand, Grabbable grab) {
            hand.Release();

            grabbableSubstitute.gameObject.SetActive(true);
            hand.CreateGrabConnection(grabbableSubstitute, hand.transform.position, hand.transform.rotation, grab.transform.position, grab.transform.rotation, true);

            if(disableOnGrab)
                grab.gameObject.SetActive(false);
        }

        void OnReleaseSub(Hand hand, Grabbable grab) {
            if(returnOnRelease) {
                grabbableSubstitute.transform.position = localGrabbable.transform.position;
                grabbableSubstitute.transform.rotation = localGrabbable.transform.rotation;
                grabbableSubstitute.body.position = localGrabbable.body.position;
                grabbableSubstitute.body.rotation = localGrabbable.body.rotation;

                grabbableSubstitute.gameObject.SetActive(false);
                if(disableOnGrab)
                    grab.gameObject.SetActive(true);

            }
        }

        /// <summary>Disables the local grabbale (if enabled), enables the substitute at the local grabbables positoin)</summary>
        public void LocalSubstitute(Hand hand, Grabbable grab) {
            if(localGrabbable.gameObject.activeInHierarchy) {
                grabbableSubstitute.gameObject.SetActive(true);
                grabbableSubstitute.transform.position = localGrabbable.transform.position;
                grabbableSubstitute.transform.rotation = localGrabbable.transform.rotation;
                grabbableSubstitute.body.position = localGrabbable.body.position;
                grabbableSubstitute.body.rotation = localGrabbable.body.rotation;

                if(disableOnGrab)
                    localGrabbable.gameObject.SetActive(false);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableSubstitute.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableThrowEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 94010c3364a7d0a43a5e49e48d078a08
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;
using UnityEngine.Events;
using System.Collections;
using System.Collections.Generic;

namespace Autohand{
    [RequireComponent(typeof(Grabbable))]
    public class GrabbableThrowEvent : MonoBehaviour {
        public Rigidbody rb;
        [Tooltip("The velocity magnitude required on collision to cause the break event")]
        public float breakVelocity = 1;
        [Tooltip("The layers that will cause this grabbale to break")]
        public LayerMask collisionLayers = ~0;
        public UnityEvent OnBreak;
        Grabbable grab;
        bool thrown = false;
        Coroutine resetThrowing;
        float throwTime = 3;

        void Awake() {
            if(rb == null)
                rb = GetComponent<Rigidbody>();
            grab = GetComponent<Grabbable>();
        }

        private void OnEnable() {
            grab.OnReleaseEvent += OnReleased;
        }
        private void OnDisable() {
            grab.OnReleaseEvent -= OnReleased;
        }

        void OnReleased(Hand hand, Grabbable grab) {
            if(resetThrowing != null)
                StopCoroutine(resetThrowing);
            resetThrowing = StartCoroutine(ResetThrown());

            if(grab.body == null)
                return;

            if(grab.body.linearVelocity.magnitude >= breakVelocity) 
                thrown = true;

        }

        IEnumerator ResetThrown() {
            yield return new WaitForSeconds(throwTime);
            thrown = false;
            resetThrowing = null;
        }

        

        private void OnCollisionEnter(Collision collision) {
            if(!thrown || grab == null)
                return;

            if(((1 << collision.collider.gameObject.layer) & collisionLayers) == 0)
                return;
        
            if(rb.linearVelocity.magnitude >= breakVelocity) {
                Invoke("Break", Time.fixedDeltaTime);
            }
        }

        void Break() {
            OnBreak.Invoke();
        }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabbableThrowEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabLock.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 72ddecfd57951984cb3fe8b722d3f68b
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    [RequireComponent(typeof(Grabbable))]
    public class GrabLock : MonoBehaviour{
        [Header("Hand.Released() must be called elsewhere")]
        [Header("Use this script to prevent grabbable release")]
        
        //THIS SCRIPT ALLOWS YOU TO HOLD AN OBJECT AFTER TRIGGER RELEASE AND CALL THIS EVENT WITH TRIGGER PRESS
        public UnityHandGrabEvent OnGrabPressed;

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/GrabLock.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/PlacePoint.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7d9c288aa20513c4aafa0228d4cfd80e
# ASMDEF: AutoHandAssembly.dll
# ---
using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.UIElements;

namespace Autohand {
    public enum PlacePointNameType
    {
        name,
        tag
    }

    public enum PlacePointShape {
        Sphere,
        Box
    }

    public delegate void PlacePointEvent(PlacePoint point, Grabbable grabbable);
    [Serializable]
    public class UnityPlacePointEvent : UnityEvent<PlacePoint, Grabbable> { }
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/place-point")]
    //You can override this by turning the radius to zero, and using any other trigger collider
    [DefaultExecutionOrder(1000)]
    public class PlacePoint : MonoBehaviour, IGrabbableEvents{
        [AutoHeader("Place Point")]
        public bool ignoreMe;

        [AutoSmallHeader("Place Settings")]
        public bool showPlaceSettings = true;
        [Tooltip("Snaps an object to the point at start, leave empty for no target")]
        public Grabbable startPlaced;
        [Tooltip("This will offset where the object position is when placed")]
        public Transform placedOffset;

        [Space]
        public PlacePointShape shapeType = PlacePointShape.Sphere;
        [Tooltip("The radius of the place point (relative to scale)"), ShowIf("shapeType", PlacePointShape.Sphere)]
        public float placeRadius = 0.1f;
        [Tooltip("The radius of the place point (relative to scale)"), ShowIf("shapeType", PlacePointShape.Box)]
        public Vector3 placeSize = new Vector3(0.1f, 0.1f, 0.1f);
        [Tooltip("The local offset of the enter radius of the place point (not the offset of the placement)"), FormerlySerializedAs("radiusOffset")]
        public Vector3 shapeOffset;

        [Space]
        [Tooltip("This will make the place point itself targetable for grab istead of just the object inside. Functionally just makes the place point an easier grab target, also essential if turning off the colliders on the placed object")]
        public bool grabbablePlacePoint = true;
        [Tooltip("This will make the point place the object as soon as it enters the radius, instead of on release")]
        public bool forcePlace = false;
        [Tooltip("If true and will force hand to release on place when force place is called. If false the hand will attempt to keep the connection to the held object (but can still break due to max distances/break forces)")]
        [ShowIf("forcePlace")]
        public bool forceHandRelease = true;
        [Tooltip("This will make the object parent to be under this point when placed")]
        public bool parentOnPlace = true;

        [Space]
        [Tooltip("If disabled the place point will not set the placed object to match its position")]
        public bool matchPosition = true;
        [Tooltip("If disabled the place point will not set the placed object to match its rotation")]
        public bool matchRotation = true;
        [Tooltip("This will resize the object, depending on it's render bounds, to fit into the place point radius (- resizeOffset) on place")]

        [Space] 
        public bool resizeOnPlace = false;
        [ShowIf("resizeOnPlace")]
        public float resizeOffset = -0.02f;

        [Space]
        [Tooltip("Whether or not the placed object should have its rigidbody disabled on place, good for parenting placed objects under dynamic objects")]
        public bool disableRigidbodyOnPlace = false;
        [Tooltip("Whether or not the grabbable should be disabled on place")]
        public bool disableGrabOnPlace = false;
        [Tooltip("Whether or not this place point should be disabled on placement. It will maintain its connection and can no longer accept new items. Causes less overhead if true")]
        public bool disablePlacePointOnPlace = false;
        [Tooltip("Whether or not the placed object should be disabled on placement (this will hide the placed object and leave the place point active for a new object)")]
        public bool destroyObjectOnPlace = false;


        [Tooltip("If true and will force release on place")]
        [DisableIf("disableRigidbodyOnPlace")]
        public bool makePlacedKinematic = true;
        
        [DisableIf("disableRigidbodyOnPlace")]
        [Tooltip("The rigidbody to attach the placed grabbable to - leave empty means no joint")]
        public Rigidbody placedJointLink;
        [DisableIf("disableRigidbodyOnPlace")]
        public float jointBreakForce = 1000;

        [AutoSmallHeader("Place Requirements")]
        public bool showPlaceRequirements = true;

        [Tooltip("Whether or not to only allow placement of an object while it's being held (or released)")]
        public bool heldPlaceOnly = false;

        [Tooltip("Whether the placeNames should compare names or tags")]
        public PlacePointNameType nameCompareType;
        [Tooltip("Will allow placement for any grabbable with a name containing this array of strings, leave blank for any grabbable allowed")]
        public string[] placeNames;
        [Tooltip("Will prevent placement for any name containing this array of strings")]
        public string[] blacklistNames;

        [Tooltip("(Unless empty) Will only allow placement any object contained here")]
        public List<Grabbable> onlyAllows;
        [Tooltip("Will NOT allow placement any object contained here")]
        public List<Grabbable> dontAllows;
        [Tooltip("The layer that this place point will check for placeable objects, if none will default to Grabbable")]
        public LayerMask placeLayers;

        [Space]

        [AutoToggleHeader("Show Events")]
        public bool showEvents = true;
        [ShowIf("showEvents")]
        public UnityPlacePointEvent OnPlace;
        [ShowIf("showEvents")]
        public UnityPlacePointEvent OnRemove;
        [ShowIf("showEvents")]
        public UnityPlacePointEvent OnHighlight;
        [ShowIf("showEvents")]
        public UnityPlacePointEvent OnStopHighlight;
        
        //For the programmers
        public PlacePointEvent OnPlaceEvent;
        public PlacePointEvent OnRemoveEvent;
        public PlacePointEvent OnHighlightEvent;
        public PlacePointEvent OnStopHighlightEvent;

        public Grabbable highlightingObj { get; protected set; } = null;
        public Grabbable placedObject { get; protected set; } = null;
        public Grabbable lastPlacedObject { get; protected set; } = null;

        /// <summary>If this place point is set under a grabbable, this value will reference that grabbable</summary>
        internal Grabbable parentGrabbable;

        protected FixedJoint joint = null;
        protected float lastPlacedTime;
        protected CollisionDetectionMode placedObjDetectionMode;
        protected float tickRate = 0.05f;

        Coroutine checkRoutine;
        Collider[] collidersNonAlloc = new Collider[50];
        Vector3 lastPlacePosition = Vector3.zero;
        bool wasInstantGrab = false;
        Vector3 prefitScale;
        protected bool placingFrame;


        protected virtual void Awake(){
            if (placedOffset == null)
                placedOffset = transform;

            if(placeLayers == 0)
                placeLayers = LayerMask.GetMask(Hand.grabbableLayerNameDefault);

            //If the place point is set to be grabbable, make sure it's on the default layer
            if(grabbablePlacePoint) {
                var colliders = GetComponents<Collider>();
                foreach(Collider col in colliders) {
                    if(col.gameObject.layer == LayerMask.NameToLayer("Default") || LayerMask.LayerToName(col.gameObject.layer) == "")
                        col.gameObject.layer = LayerMask.NameToLayer(Hand.grabbableLayerNameDefault);
                }


                if(shapeType == PlacePointShape.Sphere && !gameObject.CanGetComponent<SphereCollider>(out var sphereCollider)) {
                    sphereCollider = gameObject.AddComponent<SphereCollider>();
                    sphereCollider.isTrigger = true;
                    sphereCollider.radius = placeRadius;
                    sphereCollider.center = shapeOffset;
                }
                if(shapeType == PlacePointShape.Box && !gameObject.CanGetComponent<BoxCollider>(out var boxCollider)) {
                    boxCollider = gameObject.AddComponent<BoxCollider>();
                    boxCollider.isTrigger = true;
                    boxCollider.size = placeSize;
                    boxCollider.center = shapeOffset;
                }
            }

            CheckInvalidSettings();

            if(startPlaced != null && startPlaced.childPlacePoints.Count == 0)
                SetStartPlaced();
            else if(startPlaced != null)
                StartCoroutine(LateStart());


        }

        protected virtual void CheckInvalidSettings() {
            if(parentGrabbable && !disableRigidbodyOnPlace && parentOnPlace) {
                Debug.LogWarning("Place Points placed under a grabbable cannot support parenting other rigidbody grabbables, disable rigibody on place is being enabled" , this);
                disableRigidbodyOnPlace = true;
                makePlacedKinematic = false;
            }
        }

        //This function helps solve the specific case where a place point is set to be placed into a different place point,
        //but the objects set to be placed in this place point are not yet placed, so we wait until they are placed before setting this place point to be placed
        IEnumerator LateStart() {
            bool waitForChildPointPlacement = false;
            int maxWaitFrames = 10;
            while(true) {
                yield return new WaitForFixedUpdate();

                foreach(var childPoint in startPlaced.childPlacePoints) {
                    if(childPoint.startPlaced != null && childPoint.placedObject == null) {
                        if(parentGrabbable == null || childPoint.startPlaced != parentGrabbable) {
                            waitForChildPointPlacement = true;
                            break;
                        }
                    }
                }

                if(waitForChildPointPlacement && maxWaitFrames > 0) {
                    maxWaitFrames--;
                    continue;
                }
                else {
                    if(startPlaced != null && startPlaced.childPlacePoints.Count > 0)
                        SetStartPlaced();

                    break;
                }

            }
        }



        protected virtual void OnEnable() {
            if(placedOffset == null)
                placedOffset = transform;

            if(checkRoutine == null)
                checkRoutine = StartCoroutine(CheckPlaceObjectLoop());

        }

        protected virtual void OnDisable() {
            if(checkRoutine != null) {
                StopCoroutine(checkRoutine);
                checkRoutine = null;
            }

            if(!parentOnPlace)
                Remove();

            StopHighlight();
        }

        ///<summary>Sets the placement of the object set in the start placed value</summary>
        protected virtual void SetStartPlaced() {
            if(startPlaced != null) {
                //Checks if the start placed object is already in the scene
                if(startPlaced.gameObject.scene.IsValid()) {
                    Highlight(startPlaced);
                    Place(startPlaced);
                }
                //or if it's a prefab that needs to be instantiated
                else {
                    var instance = GameObject.Instantiate(startPlaced);
                    instance.transform.position = placedOffset.position;
                    instance.transform.rotation = placedOffset.rotation;
                    Highlight(instance);
                    Place(instance);

                }
            }
        }

        /// <summary>Places the object current placed to this place point</summary>
        public Grabbable GetPlacedObject() {
            return placedObject;
        }

        

        /// <summary>Whether or not the place point can accept an object based on its settings</summary>
        public virtual bool CanPlace(Grabbable placeObj, bool checkRoot = true) {
            if(checkRoot && CanPlace(placeObj.rootGrabbable, false))
                return true;

            if(placedObject != null) {
                return false;
            }

            //This prevents place points from accepting objects that arent parent on grab
            if(!placeObj.parentOnGrab && parentGrabbable != null) {
                return false;
            }

            //This prevents place points from accepting objects that arent being held while heldPlaceOnly is true
            if(heldPlaceOnly && placeObj.HeldCount() == 0) {
                return false;
            }

            //This prevents place points from accepting objects that arent being held while heldPlaceOnly is true
            if(onlyAllows.Count > 0 && !onlyAllows.Contains(placeObj)) {
                return false;
            }

            //This prevents place points from accepting objects that are in the dontAllows list
            if(dontAllows.Count > 0 && dontAllows.Contains(placeObj)) {
                return false;
            }

            //If no place names are set, then any grabbable is allowed
            if(placeNames.Length == 0 && blacklistNames.Length == 0) {
                return true;
            }

            //This prevents place points from accepting objects that are in the blacklistNames list
            if (blacklistNames.Length > 0)
                foreach(var badName in blacklistNames)
                {
                    if (nameCompareType == PlacePointNameType.name && placeObj.name.Contains(badName))
                        return false;
                    if (nameCompareType == PlacePointNameType.tag && placeObj.CompareTag(badName))
                        return false;
                }

            //This prevents place points from accepting objects that arent in the placeNames list
            if (placeNames.Length > 0)
                foreach (var placeName in placeNames)
                {
                    if (nameCompareType == PlacePointNameType.name && placeObj.name.Contains(placeName))
                        return true;
                    if (nameCompareType == PlacePointNameType.tag && placeObj.CompareTag(placeName))
                        return true;
                }
            else
                return true;

            return false;
        }


        /// <summary>Places the given grabbable into this place point if the settings allow it</summary>
        public virtual void TryPlace(Grabbable placeObj) {
            if(CanPlace(placeObj))
                Place(placeObj);
        }


        /// <summary>Places the given grabbable into this place point</summary>
        public virtual void Place(Grabbable placeObj) {
            if (placedObject != null)
                return;

            placeObj = placeObj.rootGrabbable;
            placingFrame = true;

            //Remove from any other place points then initialize
            if(placeObj.placePoint != null && placeObj.placePoint != this)
                placeObj.placePoint.Remove(placeObj);

            placedObject = placeObj.rootGrabbable;
            placedObject.SetPlacePoint(this);


            //Release any hands holding the grabbable or its children
            if((forceHandRelease || disableRigidbodyOnPlace) && placeObj.HeldCount() > 0) {
                placeObj.ForceHandsRelease();
                foreach(var grab in placeObj.grabbableChildren)
                    grab.ForceHandsRelease();
            }



            //Placement, set position, create whatever joints based on settings
            if(matchPosition)
                placeObj.rootTransform.position = placedOffset.position;
            if(matchRotation)
                placeObj.rootTransform.rotation = placedOffset.rotation;

            if (placeObj.body != null){
                placeObj.body.linearVelocity = Vector3.zero;
                placeObj.body.angularVelocity = Vector3.zero;
                placedObjDetectionMode = placeObj.body.collisionDetectionMode;

                if (makePlacedKinematic && !disableRigidbodyOnPlace){
                    placeObj.body.collisionDetectionMode = CollisionDetectionMode.ContinuousSpeculative;
                    placeObj.body.isKinematic = makePlacedKinematic;
                }

                if (placedJointLink != null){
                    joint = placedJointLink.gameObject.AddComponent<FixedJoint>();
                    joint.connectedBody = placeObj.body;
                    joint.breakForce = jointBreakForce;
                    joint.breakTorque = jointBreakForce;
                
                    joint.connectedMassScale = 1;
                    joint.massScale = 1;
                    joint.enableCollision = false;
                    joint.enablePreprocessing = false;
                }
            }

            StopHighlight(placeObj);

            //If a child of the root grabbable is grabbed, this calls the remove function
            foreach(var grab in placeObj.grabbableChildren) 
                grab.OnGrabEvent += OnPlaceObjectChildGrabbed;

            //Call Events
            placeObj.OnPlacePointAddEvent?.Invoke(this, placeObj);
            foreach(var grabChild in placeObj.grabbableChildren)
                grabChild.OnPlacePointAddEvent?.Invoke(this, grabChild);

            OnPlaceEvent?.Invoke(this, placeObj);
            OnPlace?.Invoke(this, placeObj);
            lastPlacedTime = Time.time;

            //Apply place point settings
            if(destroyObjectOnPlace) {
                Destroy(placeObj.gameObject);
                return;
            }

            if(parentOnPlace) {
                placeObj.rootTransform.parent = transform;
            }

            if (disableRigidbodyOnPlace)
                placeObj.DeactivateRigidbody();

            if (disablePlacePointOnPlace)
                enabled = false;

            if (disableGrabOnPlace || disablePlacePointOnPlace)
                placeObj.isGrabbable = false;


            if(resizeOnPlace) {
                //It's important this happens in the before grab instead of on remove so the grab pose is calculated correctly
                placeObj.OnBeforeGrabEvent += ResizeBeforeGrab;
                foreach(var grabbable in placeObj.grabbableChildren)
                    grabbable.OnBeforeGrabEvent += ResizeBeforeGrab;

                //Ensures the pose looks correct after resizing
                placeObj.OnGrabEvent += RecacluatePoseAfterGrab;
                foreach(var grabChild in placeObj.rootGrabbable.grabbableChildren)
                    grabChild.OnGrabEvent += RecacluatePoseAfterGrab;

                //Save relevent values
                prefitScale = placeObj.rootTransform.localScale;
                wasInstantGrab = placeObj.instantGrab;
                placeObj.instantGrab = true;

                //Calculate and resize the object
                var scale = Mathf.Abs(transform.lossyScale.x < transform.lossyScale.y ? transform.lossyScale.x : transform.lossyScale.y);
                scale = Mathf.Abs(scale < transform.lossyScale.z ? scale : transform.lossyScale.z);
                if(shapeType == PlacePointShape.Sphere)
                    FitAndCenterToBounds(placeObj.rootTransform.gameObject, placeRadius*scale +  resizeOffset*scale);
                else if(shapeType == PlacePointShape.Box)
                    FitAndCenterToBounds(placeObj.rootTransform.gameObject, (placeSize + placeSize * resizeOffset)*scale);
            }


            //If the place point is grabbable add an event to recalculate the before grab event to ensure the pose is correct
            if(grabbablePlacePoint) {
                placeObj.OnBeforeGrabEvent += RecalculateBeforeGrab;
                foreach(var grabbable in placeObj.grabbableChildren)
                    grabbable.OnBeforeGrabEvent += RecalculateBeforeGrab;
            }

            //If the place point is found to be a child of a grabbable
            if(parentGrabbable != null) {
                //Disable the place points of the placed object from interacting with the parent grabbable
                foreach(var childPlacePoint in placeObj.childPlacePoints) {
                    parentGrabbable.PlacePointIgnore(childPlacePoint);
                    childPlacePoint.StopHighlight();
                    childPlacePoint.enabled = false;
                    if(childPlacePoint.placedObject != null)
                        childPlacePoint.placedObject.enabled = false;
                }
                //Combine the colliders of the placed object with the parent grabbable
                if(disableRigidbodyOnPlace && parentOnPlace)
                    parentGrabbable.AddGrabbableColliders(placeObj);
            }


        }


        /// <summary>Removes the object if it matches the given object</summary>
        public virtual void Remove(Grabbable placeObj) {
            placeObj = placeObj.rootGrabbable;

            if (placeObj == null || placeObj != placedObject || disablePlacePointOnPlace)
                return;

            //Remove Events
            foreach(var grab in placeObj.grabbableChildren)
                grab.OnGrabEvent -= OnPlaceObjectChildGrabbed;


            //Trigger highlight
            Highlight(placeObj);

            if(disableRigidbodyOnPlace)
                placeObj.ActivateRigidbody();


            //Reset rigidbody settings
            if (placeObj.body != null){
                if (makePlacedKinematic && !disableRigidbodyOnPlace)
                    placeObj.body.isKinematic = false;

                placeObj.body.collisionDetectionMode = placedObjDetectionMode;
            }


            //If the place point is a child of a grabbable
            if(parentGrabbable != null) {
                //Enable the place points of the placed object to interact with the parent grabbable
                if(placeObj.childPlacePoints.Count > 0) {
                    foreach(var childPlacePoint in placeObj.childPlacePoints) {
                        parentGrabbable.PlacePointAllow(childPlacePoint);
                        childPlacePoint.enabled = true;
                        if(childPlacePoint.placedObject != null)
                            childPlacePoint.placedObject.enabled = true;
                    }
                }

                //Remove the colliders of the placed object from the parent grabbable
                parentGrabbable.RemoveGrabbableColliders(placeObj);

                //Ignore the collisions between the placed object and the parent grabbable
                parentGrabbable.IgnoreGrabbableCollisionUntilNone(placeObj);
                //Ignore the collisions between the placed object and the hands holding the parent grabbable
                foreach(var hand in parentGrabbable.GetHeldBy()) 
                    placeObj.IgnoreHandCollisionUntilNone(hand);
                //Ignore the collisions between the placed object and the hands holding the placed object
                foreach(var hand in placeObj.GetHeldBy()) 
                    parentGrabbable.IgnoreHandCollisionUntilNone(hand);
            }

            //Reset size
            if(resizeOnPlace) {
                //Remove Events
                placedObject.OnBeforeGrabEvent -= ResizeBeforeGrab;
                foreach(var grabbable in placedObject.grabbableChildren)
                    grabbable.OnBeforeGrabEvent -= ResizeBeforeGrab;

                //If the remove function is called without grabbing
                if(placeObj.HeldCount() == 0)
                    placeObj.rootTransform.localScale = prefitScale;

                placeObj.instantGrab = wasInstantGrab;
            }
             
            if(grabbablePlacePoint) {
                //Remove Events
                placedObject.OnBeforeGrabEvent -= RecalculateBeforeGrab;
                foreach(var grabbable in placedObject.grabbableChildren)
                    grabbable.OnBeforeGrabEvent -= RecalculateBeforeGrab;
            }


            //Reset parent if the parenting isnt already being handled by a hand
            if((!placeObj.parentOnGrab || placeObj.HeldCount() == 0) && parentOnPlace && gameObject.activeInHierarchy) {
                placeObj.rootTransform.parent = placeObj.originalParent;
            }


            if(joint != null){
                Destroy(joint);
                joint = null;
            }

            //Call Events
            placedObject.OnPlacePointRemoveEvent?.Invoke(this, highlightingObj);
            foreach(var grabChild in placedObject.grabbableChildren)
                grabChild.OnPlacePointRemoveEvent?.Invoke(this, grabChild);
            OnRemoveEvent?.Invoke(this, placeObj);
            OnRemove?.Invoke(this, placeObj);


            lastPlacedObject = placedObject;
            placedObject = null;
        }


        /// <summary>Removes the object if it has one</summary>
        [ContextMenu("Remove Placed")]
        public void Remove() {
            if(placedObject != null)
                Remove(placedObject);
        }



        public virtual void Highlight(Grabbable from) {
            from = from.rootGrabbable;
            if(highlightingObj == null){
                highlightingObj = from;
                from.SetPlacePoint(this);

                highlightingObj.OnPlacePointHighlightEvent?.Invoke(this, highlightingObj);
                foreach(var grabChild in highlightingObj.grabbableChildren)
                    grabChild.OnPlacePointHighlightEvent?.Invoke(this, grabChild);

                OnHighlightEvent?.Invoke(this, from);
                OnHighlight?.Invoke(this, from);

                if(placedObject == null && (forcePlace || (!heldPlaceOnly && from.HeldCount() == 0)))
                    Place(from);
            }
        }

        public virtual void StopHighlight(Grabbable grab) {
            grab = grab.rootGrabbable;
            if(highlightingObj == grab) {
                StopHighlight();
            }
        }

        public virtual void StopHighlight() {
            if(highlightingObj != null) {
                highlightingObj.OnPlacePointUnhighlightEvent?.Invoke(this, highlightingObj);
                foreach(var grabChild in highlightingObj.grabbableChildren)
                    grabChild.OnPlacePointUnhighlightEvent?.Invoke(this, grabChild);

                OnStopHighlightEvent?.Invoke(this, highlightingObj);
                OnStopHighlight?.Invoke(this, highlightingObj);

                if (placedObject == null)
                    highlightingObj.SetPlacePoint(null);

                highlightingObj = null;
            }
        }




        //CHECK PLACEMENT FUNCTIONS
        int lastOverlapCount = 0;
        protected virtual IEnumerator CheckPlaceObjectLoop() {
            yield return new WaitForSeconds(0.2f);
            yield return new WaitForSeconds(UnityEngine.Random.Range(0f, tickRate));

            while(gameObject.activeInHierarchy) {
                var scale = Mathf.Abs(transform.lossyScale.x < transform.lossyScale.y ? transform.lossyScale.x : transform.lossyScale.y);
                scale = Mathf.Abs(scale < transform.lossyScale.z ? scale : transform.lossyScale.z);
                if(!disablePlacePointOnPlace && !disableRigidbodyOnPlace && placedObject != null &&
                    lastPlacePosition != placedObject.transform.position && !IsStillOverlapping(placedObject, scale) && !placingFrame) {
                    Remove(placedObject);
                }

                if(placedObject != null)
                    lastPlacePosition = placedObject.transform.position;

                CheckHighlight(scale);

                yield return new WaitForSeconds(tickRate);
                if(placedObject != null && placingFrame) {
                    if(matchPosition)
                        placedObject.rootTransform.position = placedOffset.position;
                    if(matchRotation)
                        placedObject.rootTransform.rotation = placedOffset.rotation;

                    lastPlacePosition = placedObject.transform.position;
                }

                placingFrame = false;
            }
        }

        protected virtual void CheckPlaceObject(float scale) {
            if(!disablePlacePointOnPlace && !disableRigidbodyOnPlace && placedObject != null &&
                lastPlacePosition != placedObject.transform.position && !IsStillOverlapping(placedObject, scale)) {
                Remove(placedObject);
            }

            if(placedObject != null)
                lastPlacePosition = placedObject.transform.position;

            CheckHighlight(scale);
        }

        protected virtual void CheckHighlight(float scale) {
            if(placedObject == null && highlightingObj == null) {
                var overlapCenterPos = placedOffset.position + transform.rotation * shapeOffset;
                int overlaps = 0;
                switch(shapeType) {
                    case PlacePointShape.Sphere:
                        overlaps = Physics.OverlapSphereNonAlloc(overlapCenterPos, placeRadius * scale, collidersNonAlloc, placeLayers);
                        break;
                    case PlacePointShape.Box:
                        overlaps = Physics.OverlapBoxNonAlloc(overlapCenterPos, placeSize/2f * scale, collidersNonAlloc, transform.rotation, placeLayers);
                        break;
                }

                if(overlaps != lastOverlapCount) {
                    var updateOverlaps = true;
                    for(int i = 0; i < overlaps; i++) {
                        if(AutoHandExtensions.HasGrabbable(collidersNonAlloc[i].gameObject, out var tempGrabbable)) {
                            tempGrabbable = tempGrabbable.rootGrabbable;
                            updateOverlaps = false;

                            if(CanPlace(tempGrabbable)) {
                                var existingPlacePoint = tempGrabbable.placePoint;
                                if(existingPlacePoint) {
                                    var grabbablePos = tempGrabbable.transform.position;
                                    var concurrentCenterPos = existingPlacePoint.placedOffset.position + existingPlacePoint.transform.rotation * existingPlacePoint.shapeOffset;
                                    var concurrentDist = Vector3.Distance(concurrentCenterPos, grabbablePos);
                                    var currentDist = Vector3.Distance(overlapCenterPos, grabbablePos);
                                    if(currentDist >= concurrentDist)
                                        continue;

                                    existingPlacePoint.StopHighlight(tempGrabbable);
                                }

                                Highlight(tempGrabbable);
                                break;
                            }
                        }
                    }

                    if(updateOverlaps) {
                        lastOverlapCount = overlaps;
                    }
                }
            }
            else if(highlightingObj != null) {
                if(!IsStillOverlapping(highlightingObj, scale)) {
                    StopHighlight(highlightingObj);
                }
            }
        }


        protected bool IsStillOverlapping(Grabbable from, float scale = 1) {
            var overlapCenterPos = placedOffset.position + transform.rotation * shapeOffset;
            int overlaps = 0;
            switch(shapeType) {
                case PlacePointShape.Sphere:
                    overlaps = Physics.OverlapSphereNonAlloc(overlapCenterPos, placeRadius * scale, collidersNonAlloc, placeLayers);
                    break;
                case PlacePointShape.Box:
                    overlaps = Physics.OverlapBoxNonAlloc(overlapCenterPos, placeSize/2f * scale, collidersNonAlloc, transform.rotation, placeLayers);
                    break;
            }

            for (int i = 0; i < overlaps; i++){
                if (collidersNonAlloc[i].attachedRigidbody == from.body) {
                    return true;
                }
            }
            
            return false;
        }


        protected virtual void OnPlaceObjectChildGrabbed(Hand pHand, Grabbable pGrabbable){
            Remove();
        }




        protected void ResizeBeforeGrab(Hand hand, Grabbable grab) {
            grab.rootTransform.localScale = prefitScale;
            Physics.SyncTransforms();
            if(grab.body != null) {
                grab.body.WakeUp();
                grab.body.detectCollisions = false;
                grab.body.detectCollisions = true;
            }

        }

        protected void RecalculateBeforeGrab(Hand hand, Grabbable grab) {
            hand.RecalculateBeforeGrab(grab);
        }

        protected void RecacluatePoseAfterGrab(Hand hand, Grabbable grab) {
            hand.RecaculateHeldAutoPose();
            grab.rootGrabbable.OnGrabEvent -= RecacluatePoseAfterGrab;
            foreach(var grabChild in grab.rootGrabbable.grabbableChildren) {
                grabChild.OnGrabEvent -= RecacluatePoseAfterGrab;
            }
        }

        protected void FitAndCenterToBounds(GameObject obj, float radius) {
            Bounds bounds = CalculateCombinedBounds(obj);
            var scaleOffset = ScaleToFitRadius(obj, bounds, radius);
            obj.transform.localScale *= scaleOffset;
            bounds.extents *= scaleOffset;
            bounds = CalculateCombinedBounds(obj);
            if(matchPosition)
                obj.transform.position = placedOffset.position + (obj.transform.position - bounds.center);
            if(matchRotation)
                obj.transform.rotation = placedOffset.rotation;
        }


        protected float ScaleToFitRadius(GameObject obj, Bounds bounds, float radius) {
            float maxExtent = bounds.extents.magnitude;
            float scale = radius / maxExtent;
            return scale;
        }
        protected void FitAndCenterToBounds(GameObject obj, Vector3 size) {
            Bounds bounds = CalculateCombinedBounds(obj);
            float scaleOffset = ScaleToFitSize(obj, bounds, size);
            obj.transform.localScale *= scaleOffset;
            bounds.extents *= scaleOffset;
            bounds = CalculateCombinedBounds(obj);
            if(matchPosition)
                obj.transform.position = placedOffset.position + (obj.transform.position - bounds.center);
            if(matchRotation)
                obj.transform.rotation = placedOffset.rotation;
        }

        protected float ScaleToFitSize(GameObject obj, Bounds bounds, Vector3 size) {
            Vector3 currentSize = bounds.size;
            float scaleX = size.x / currentSize.x;
            float scaleY = size.y / currentSize.y;
            float scaleZ = size.z / currentSize.z;
            float scale = Mathf.Min(scaleX, Mathf.Min(scaleY, scaleZ));
            return scale;
        }

        protected Bounds CalculateCombinedBounds(GameObject obj) {
            var meshRenderers = obj.GetComponentsInChildren<MeshRenderer>().OfType<Renderer>();
            var skinnedMeshRenderers = obj.GetComponentsInChildren<SkinnedMeshRenderer>().OfType<Renderer>();
            List<Renderer> renderers = new List<Renderer>();

            renderers.AddRange(meshRenderers);
            renderers.AddRange(skinnedMeshRenderers);
            Bounds combinedBounds = new Bounds(obj.transform.position, Vector3.zero);

            foreach(Renderer renderer in renderers)
                combinedBounds.Encapsulate(renderer.bounds);

            return combinedBounds;
        }





        protected virtual void OnJointBreak(float breakForce) {
            if(placedObject != null)
                Remove(placedObject);
        }




        void OnDrawGizmos() {
            if(placedOffset == null)
                placedOffset = transform;

            var scale = Mathf.Abs(transform.lossyScale.x < transform.lossyScale.y ? transform.lossyScale.x : transform.lossyScale.y);
            scale = Mathf.Abs(scale < transform.lossyScale.z ? scale : transform.lossyScale.z);

            Gizmos.color = Color.white; 
            Gizmos.matrix = transform.localToWorldMatrix;

            if(shapeType == PlacePointShape.Box) {
                Gizmos.DrawWireCube(shapeOffset, placeSize);
                
                if(resizeOffset != 0 && resizeOnPlace) {
                    Gizmos.color = Color.red;
                    Gizmos.DrawWireCube(shapeOffset, (placeSize + placeSize * resizeOffset));
                }
            }
            else if(shapeType == PlacePointShape.Sphere) {

                Gizmos.DrawWireSphere(shapeOffset, placeRadius);

                if(resizeOffset != 0 && resizeOnPlace) {
                    Gizmos.color = Color.red;
                    Gizmos.DrawWireSphere(shapeOffset, placeRadius + resizeOffset);
                }
            }
        }


        //INTERFACE FUNCTIONS FOR GRABBABLE PLACE POINT
        void IGrabbableEvents.OnHighlight(Hand hand) {
            if(!grabbablePlacePoint)
                return; 

            if(placedObject != null)
                placedObject.Highlight(hand);
        }

        public virtual void OnUnhighlight(Hand hand) {
            if(!grabbablePlacePoint)
                return;

            if(placedObject != null)
                placedObject.Unhighlight(hand);

        }

        public virtual void OnGrab(Hand hand) {
            if(!grabbablePlacePoint)
                return;

            hand.RecaculateHeldAutoPose();
        }

        public virtual void OnRelease(Hand hand) {
            if(!grabbablePlacePoint)
                return;
        }

        public virtual bool CanGrab(Hand hand) {
            if(!grabbablePlacePoint || placedObject == null)
                return false;

            return placedObject.CanGrab(hand);
        }

        public virtual Grabbable GetGrabbable() {
            if(!grabbablePlacePoint || placedObject == null || !enabled)
                return null;

            return placedObject;

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/PlacePoint.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/PlacePointSoundEffects.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: d9ec4dfc370076d4f8e478d26e0b407b
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class PlacePointSoundEffects : MonoBehaviour {
        public PlacePoint placePoint;
        public AudioSource audioSource;
        public AudioClip highlightSound;
        public AudioClip unhighlightSound;
        public AudioClip placeSound;
        public AudioClip removeSound;

        float startDelay = 1f;
        Coroutine waitToActivateRountine;

        void OnEnable() {
            if(audioSource == null)
                audioSource = GetComponent<AudioSource>();
            waitToActivateRountine = StartCoroutine(WaitToActivate());
        }

        void OnDisable() {
            if(waitToActivateRountine != null) {
                StopCoroutine(waitToActivateRountine);
            }
            else {
                placePoint.OnHighlight.RemoveListener(OnHighlight);
                placePoint.OnStopHighlight.RemoveListener(OnUnhighlight);
                placePoint.OnPlace.RemoveListener(OnPlace);
                placePoint.OnRemove.RemoveListener(OnRemove);
            }
        }

        IEnumerator WaitToActivate() {
            yield return new WaitForSeconds(startDelay);
            placePoint.OnHighlight.AddListener(OnHighlight);
            placePoint.OnStopHighlight.AddListener(OnUnhighlight);
            placePoint.OnPlace.AddListener(OnPlace);
            placePoint.OnRemove.AddListener(OnRemove);
        }

        void OnHighlight(PlacePoint placePoint, Grabbable grabbable) {
            if(highlightSound != null && audioSource.enabled && audioSource.gameObject.activeInHierarchy && placePoint.enabled)
                audioSource.PlayOneShot(highlightSound);
        }


        void OnUnhighlight(PlacePoint placePoint, Grabbable grabbable) {
            if(unhighlightSound != null && audioSource.enabled && audioSource.gameObject.activeInHierarchy && placePoint.enabled)
                audioSource.PlayOneShot(unhighlightSound);
        }

        void OnPlace(PlacePoint placePoint, Grabbable grabbable) {
            if(placeSound != null && audioSource.enabled && audioSource.gameObject.activeInHierarchy && placePoint.enabled)
                audioSource.PlayOneShot(placeSound);
        }

        void OnRemove(PlacePoint placePoint, Grabbable grabbable) {
            if(removeSound != null && audioSource.enabled && audioSource.gameObject.activeInHierarchy && placePoint.enabled)
                audioSource.PlayOneShot(removeSound);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/PlacePointSoundEffects.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/WeightlessFollower.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: faa064f2c7293d94294547ec24301cf2
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [DefaultExecutionOrder(999)]
    public class WeightlessFollower : MonoBehaviour {
        [HideInInspector]
        public Transform follow1 = null;
        [HideInInspector]
        public Transform follow2 = null;
        [HideInInspector]
        public Hand hand1 = null;
        [HideInInspector]
        public Hand hand2 = null;

        public Dictionary<Hand, Transform> heldMoveTo = new Dictionary<Hand, Transform>();

        [HideInInspector]
        public float followPositionStrength = 30;
        [HideInInspector]
        public float followRotationStrength = 30;

        [HideInInspector]
        public float maxVelocity = 5;

        [HideInInspector]
        public Grabbable grab;

        Transform _pivot = null;
        public Transform pivot {
            get {
                if(!gameObject.activeInHierarchy)
                    return null;

                if(_pivot == null) {
                    _pivot = new GameObject().transform;
                    _pivot.parent = transform.parent;
                    _pivot.name = "WEIGHTLESS PIVOT";
                }

                return _pivot;
            }
        }

        internal Rigidbody body;
        Transform moveTo = null;

        float startMass = 0;
        float startDrag;
        float startAngleDrag;
        float startHandMass;
        float startHandDrag;
        float startHandAngleDrag;
        bool useGravity;


        public void Start() {
            if(body == null)
                body = GetComponent<Rigidbody>();
        }


        public virtual void Set(Hand hand, Grabbable grab) {
            if (body == null)
                body = grab.body;

            if(moveTo == null) {
                moveTo = new GameObject().transform;
                moveTo.name = gameObject.name + " FOLLOW POINT";
                moveTo.parent = AutoHandExtensions.transformParent;
            }

            if(!heldMoveTo.ContainsKey(hand)) {
                heldMoveTo.Add(hand, new GameObject().transform);
                heldMoveTo[hand].name = "HELD FOLLOW POINT";
            }

            var tempTransform = AutoHandExtensions.transformRuler;
            tempTransform.position = hand.transform.position;
            tempTransform.rotation = hand.transform.rotation;

            var tempTransformChild = AutoHandExtensions.transformRulerChild;
            tempTransformChild.position = grab.rootTransform.position;
            tempTransformChild.rotation = grab.rootTransform.rotation;

            if(grab.maintainGrabOffset) {
                tempTransform.position = hand.moveTo.position + hand.grabPositionOffset;
                tempTransform.rotation = hand.moveTo.rotation * hand.grabRotationOffset;
            }
            else {
                tempTransform.position = hand.moveTo.position;
                tempTransform.rotation = hand.moveTo.rotation;
            }

            heldMoveTo[hand].parent = hand.moveTo;
            heldMoveTo[hand].position = tempTransformChild.position;
            heldMoveTo[hand].rotation = tempTransformChild.rotation;


            if(follow1 == null) {
                follow1 = heldMoveTo[hand];
                hand1 = hand;
            }
            else if(follow2 == null) {
                follow2 = heldMoveTo[hand];
                hand2 = hand;
                pivot.parent = body.transform;
                pivot.position = Vector3.Lerp(hand1.handGrabPoint.position, hand2.handGrabPoint.position, 0.5f);
                pivot.rotation = Quaternion.LookRotation((hand1.handGrabPoint.position - hand2.handGrabPoint.position).normalized, 
                                 Vector3.Lerp(hand1.handGrabPoint.up, hand2.handGrabPoint.up, 0.5f));
            }


            if (startMass == 0) {
                startMass = body.mass;
                startDrag = grab.targetDrag;
                startAngleDrag = grab.targetAngularDrag;
                useGravity = body.useGravity;
            }


            startHandMass = hand.body.mass;
            startHandDrag = hand.handFollow.startDrag;
            startHandAngleDrag = hand.handFollow.startAngularDrag;

            body.mass = startHandMass;
            body.linearDamping = startHandDrag;
            body.angularDamping = startHandAngleDrag;
            body.useGravity = false;

            followPositionStrength = hand.handFollow.followPositionStrength;
            followRotationStrength = hand.handFollow.followRotationStrength;


            maxVelocity = grab.maxHeldVelocity;
            this.grab = grab;

            hand.OnBeforeReleased += OnHandReleased;
        }


        void OnHandReleased(Hand hand, Grabbable grab){
            if(heldMoveTo.ContainsKey(hand))
                RemoveFollow(hand, heldMoveTo[hand]);
        }
        public virtual void FixedUpdate() {
            if(follow1 == null)
                return;

            if(follow2 != null) {
                pivot.position = Vector3.Lerp(hand1.handGrabPoint.position, hand2.handGrabPoint.position, 0.5f);
                pivot.rotation = Quaternion.LookRotation(
                    (hand1.handGrabPoint.position - hand2.handGrabPoint.position).normalized,
                    Vector3.Lerp(hand1.handGrabPoint.up, hand2.handGrabPoint.up, 0.5f)
                );
            }

            MoveTo();
            TorqueTo();

            if(grab.HeldCount() == 0)
                Destroy(this);
        }



        protected void SetMoveTo() {
            if(follow1 == null || moveTo == null)
                return;

            if(follow2 != null) {
                moveTo.position = Vector3.Lerp(hand1.moveTo.position, hand2.moveTo.position, 0.5f);
                moveTo.rotation = Quaternion.LookRotation((hand1.moveTo.position - hand2.moveTo.position).normalized,
                                 Vector3.Lerp(hand1.moveTo.up, hand2.moveTo.up, 0.5f));
                moveTo.position -= pivot.position - pivot.parent.transform.position;
                moveTo.rotation *= Quaternion.Inverse(pivot.localRotation);
            }
            else {
                moveTo.position = follow1.position;
                moveTo.rotation = follow1.rotation;
            }
        }



        /// <summary>Moves the hand to the controller position using physics movement</summary>
        protected virtual void MoveTo() {
            if(followPositionStrength <= 0 || moveTo == null)
                return;

            SetMoveTo();


            var movePos = moveTo.position;
            var distance = Vector3.Distance(movePos, transform.position);

            distance = Mathf.Clamp(distance, 0, 0.5f);

            SetVelocity(0.55f);


            void SetVelocity(float minVelocityChange) {
                var velocityClamp = grab.maxHeldVelocity;
                Vector3 vel = (movePos - transform.position).normalized * followPositionStrength * distance;

                vel.x = Mathf.Clamp(vel.x, -velocityClamp, velocityClamp);
                vel.y = Mathf.Clamp(vel.y, -velocityClamp, velocityClamp);
                vel.z = Mathf.Clamp(vel.z, -velocityClamp, velocityClamp);

                var deltaOffset = Time.fixedDeltaTime / 0.011111f;
                var inverseDeltaOffset = 0.011111f / Time.fixedDeltaTime;
                body.linearDamping = startDrag * inverseDeltaOffset;
                var maxDelta = deltaOffset;
                minVelocityChange *= deltaOffset;

                body.linearVelocity = new Vector3(
                    Mathf.MoveTowards(body.linearVelocity.x, vel.x, minVelocityChange + Mathf.Abs(body.linearVelocity.x) * maxDelta),
                    Mathf.MoveTowards(body.linearVelocity.y, vel.y, minVelocityChange + Mathf.Abs(body.linearVelocity.y) * maxDelta),
                    Mathf.MoveTowards(body.linearVelocity.z, vel.z, minVelocityChange + Mathf.Abs(body.linearVelocity.z) * maxDelta)
                );
            }
        }


        /// <summary>Rotates the hand to the controller rotation using physics movement</summary>
        protected virtual void TorqueTo() {
            var moveRot = moveTo.rotation;
            var delta = (moveRot * Quaternion.Inverse(body.rotation));
            delta.ToAngleAxis(out float angle, out Vector3 axis);

            if(float.IsInfinity(axis.x))
                return;

            if(angle > 180f)
                angle -= 360f;

            var multiLinear = Mathf.Deg2Rad * angle * followRotationStrength;
            Vector3 angular = multiLinear * axis.normalized;
            angle = Mathf.Abs(angle);

            var angleStrengthOffset = Mathf.Lerp(1f, 1.5f, angle/16f);
            var deltaOffset = Time.fixedDeltaTime / 0.011111f;
            var inverseDeltaOffset = 0.011111f / Time.fixedDeltaTime;
            body.angularDamping = Mathf.Lerp((startAngleDrag * 1.2f), startAngleDrag, angle/4f) * inverseDeltaOffset;
            var maxDelta = followRotationStrength * 50f * angleStrengthOffset;


            body.angularVelocity = new Vector3(
                Mathf.MoveTowards(body.angularVelocity.x, angular.x, maxDelta),
                Mathf.MoveTowards(body.angularVelocity.y, angular.y, maxDelta),
                Mathf.MoveTowards(body.angularVelocity.z, angular.z, maxDelta)
            );

        }


        int CollisionCount() {
            return grab.CollisionCount();
        }

        public void RemoveFollow(Hand hand, Transform follow) {
            hand.OnReleased -= OnHandReleased;

            if(this.follow1 == follow) {
                this.follow1 = null;
                hand1 = null;
            }
            if(follow2 == follow) {
                follow2 = null;
                hand2 = null;
            }

            if(this.follow1 == null && follow2 != null) {
                this.follow1 = follow2;
                this.hand1 = hand2;
                hand2 = null;
                follow2 = null;
            }

            if(this.follow1 == null && follow2 == null && !grab.beingGrabbed) {
                if(body != null) {
                    body.mass = startMass;
                    body.linearDamping = startDrag;
                    body.angularDamping = startAngleDrag;
                    body.useGravity = useGravity;
                }
                Destroy(this);
            }

            heldMoveTo.Remove(hand);
        }

        private void OnDestroy()
        {
            if(moveTo != null)
                Destroy(moveTo.gameObject);

            foreach(var transform in heldMoveTo)
                Destroy(transform.Value.gameObject);

            if (body != null)
            {
                body.mass = startMass;
                body.linearDamping = startDrag;
                body.angularDamping = startAngleDrag;
                body.useGravity = useGravity;
            }
        }


    }


}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Grabbable/WeightlessFollower.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/Finger.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 7efad4f49bdc399409aae0e128b0ad2b
# ASMDEF: AutoHandAssembly.dll
# ---

using System;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {

    public enum FingerEnum {
        none = -1,
        index,
        middle,
        ring,
        pinky,
        thumb
    }

    public enum FingerJointEnum {
        knuckle,
        middle,
        distal,
        tip
    }

    //You can add more poses here and they will automatically be added to the hands save pose button list
    //Dont change the order of the poses, only add new ones to the end
    public enum FingerPoseEnum {
        Open = 0,
        Closed = 1,
        PinchOpen = 2,
        PinchClosed = 3,
        TotalPoses
    }

    [System.Serializable]
    public struct FingerMask {
        public FingerEnum finger;
        public float weight;
    }



    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/hand/finger-component")]
    public class Finger : MonoBehaviour {
        [Header("Hand Reference")]
        public Hand hand;
        [Header("Finger Joints")]
        public FingerEnum fingerType = FingerEnum.none;
        [Tooltip("This is the first joint on the finger, the knuckle that rotates the whole finger, on the thumb this should be joint closer the wrist (The first joint on your actual thumb that moves)")]
        public Transform knuckleJoint;
        [Tooltip("The second joint that connect the primary finger bone to the middle finger bone")]
        public Transform middleJoint;
        [Tooltip("The third that attached the middle finger bone and the top bone")]
        public Transform distalJoint;
        [Space]
        [Header("Finger Tip")]
        [Tooltip("This transfrom will represent the tip/stopper of the finger")]
        public Transform tip;
        [Tooltip("This determines the radius of the spherecast check when bending fingers")]
        public float tipRadius = 0.01f;
        [Tooltip("This will offset the fingers bend (0 is no bend, 1 is full bend)")]
        [Range(0, 1f)]
        public float bendOffset;
        public float fingerSmoothSpeed = 1;

        [HideInInspector]
        public float secondaryOffset = 0;

        public Transform[] FingerJoints {
            get {
                if(fingerJoints == null || fingerJoints.Length == 0)
                    fingerJoints = new Transform[] { knuckleJoint, middleJoint, distalJoint, tip };

                return fingerJoints;
            }
        }

        [SerializeField, HideInInspector]
        Transform[] fingerJoints;

        [SerializeField, HideInInspector]
        public FingerPoseData[] poseData;



        FingerPoseData _poseDataNonAlloc;
        public FingerPoseData poseDataNonAlloc {
            get {
                if(!_poseDataNonAlloc.isSet) {
                    _poseDataNonAlloc = new FingerPoseData();
                    _poseDataNonAlloc.poseRelativeMatrix = new Matrix4x4[4];
                    _poseDataNonAlloc.localRotations = new Quaternion[4];
                }
                return _poseDataNonAlloc;
            }
        }

        float bend = 0;


        //DEPRICATED FINGER POSE DATA
        [SerializeField]
        [HideInInspector]
        internal Quaternion[] minGripRotPose;

        [SerializeField]
        [HideInInspector]
        internal Vector3[] minGripPosPose;

        [SerializeField]
        [HideInInspector]
        internal Quaternion[] maxGripRotPose;

        [SerializeField]
        [HideInInspector]
        internal Vector3[] maxGripPosPose;

        public bool isMissingReferences { get { return knuckleJoint == null || middleJoint == null || distalJoint == null || tip == null; } }

        public bool isDataDepricated {
            get {
                return poseData == null || poseData.Length == 0 || (minGripPosPose.Length > 0 && poseData[(int)FingerPoseEnum.Open].isSet == false) || (maxGripPosPose.Length > 0 && poseData[(int)FingerPoseEnum.Closed].isSet == false);
            }
        }

        float lastHitBend;
        Collider[] results = new Collider[4];


        protected virtual void Awake() {
            if(hand == null)
                hand = GetComponentInParent<Hand>();
            if(hand == null)
                Debug.LogError("AUTO HAND: Missing hand reference, please assign the hand reference to the finger component", this);

            if(isDataDepricated)
                UpdateDepricatedValues();

            for(int i = 0; i < poseData.Length; i++)
                if(poseData[i].isSet)
                    poseData[i].CalculateAdditionalValues(hand.transform.lossyScale);


            if((knuckleJoint == null || middleJoint == null || distalJoint == null || tip == null))
                Debug.LogError("AUTO HAND: Missing finger connections, please connect all the joint values of the finger component (If your finger has less than the required joints add the same joint to two inputs)", this);
            if(poseData == null || poseData.Length == 0)
                Debug.LogError("AUTO HAND: Missing finger pose data, please set the open and closed finger pose data (If you have not set this up please do so in the inspector or use the context menu to set the open and closed finger pose data)", this);

        }




        /// <summary>Forces the finger to a bend until it hits something on the given physics layer</summary>
        /// <param name="steps">The number of steps and physics checks it will make lerping from 0 to 1</param>
        public virtual bool BendFingerUntilNoHit(int steps, int layermask, FingerPoseEnum fromPose = FingerPoseEnum.Open, FingerPoseEnum toPose = FingerPoseEnum.Closed) {
            return BendFingerUntilNoHit(steps, layermask, ref poseData[(int)fromPose], ref poseData[(int)toPose]);
        }

        /// <summary>Forces the finger to a bend until it hits something on the given physics layer</summary>
        /// <param name="steps">The number of steps and physics checks it will make lerping from 0 to 1</param>
        public virtual bool BendFingerUntilNoHit(int steps, int layermask, ref FingerPoseData fromPose, ref FingerPoseData toPose) {
            lastHitBend = 0;
            var fingerTipTransform = tip.transform;
            var handTransform = hand.transform;
            var handPosition = handTransform.position;
            var handRotation = handTransform.rotation;

            Vector3 lastFingerPos = Vector3.zero;
            for(float i = 0; i <= steps / 5f; i++) {
                lastHitBend = i / (steps / 5f);
                int overlapCount = CheckFingerBlendOverlap(layermask, handRotation, fingerTipTransform, ref fromPose, ref toPose, lastHitBend);

                if(overlapCount == 0) {
                    lastHitBend = Mathf.Clamp01(lastHitBend);
                    if(i == 0) {
                        poseDataNonAlloc.SetFingerPose(this, handRotation, knuckleJoint, middleJoint, distalJoint);
                        bend = lastHitBend;
                        //currBendOffset = lastHitBend;
                        return true;
                    }
                    break;
                }

            }

            lastHitBend -= (5f / steps);
            for(int i = 0; i <= steps / 10f; i++) {
                lastHitBend += (1f / steps);
                lastHitBend = Mathf.Clamp01(lastHitBend);
                int overlapCount = CheckFingerBlendOverlap(layermask, handRotation, fingerTipTransform, ref fromPose, ref toPose, lastHitBend);

                if(overlapCount == 0 || lastHitBend >= 1) {
                    bend = lastHitBend;
                    //currBendOffset = lastHitBend;
                    return true;
                }
            }

            lastHitBend = 1f;
            toPose.SetFingerPose(this, handRotation, knuckleJoint, middleJoint, distalJoint);
            return false;
        }



        /// <summary>Forces the finger to a bend until it hits something on the given physics layer</summary>
        /// <param name="steps">The number of steps and physics checks it will make lerping from 0 to 1</param>
        public virtual bool BendFingerUntilHit(int steps, int layermask, FingerPoseEnum fromPose = FingerPoseEnum.Open, FingerPoseEnum toPose = FingerPoseEnum.Closed) {
            return BendFingerUntilHit(steps, layermask, ref poseData[(int)fromPose], ref poseData[(int)toPose]);
        }

        /// <summary>Forces the finger to a bend until it hits something on the given physics layer</summary>
        /// <param name="steps">The number of steps and physics checks it will make lerping from 0 to 1</param>
        public virtual bool BendFingerUntilHit(int steps, int layermask, ref FingerPoseData fromPose, ref FingerPoseData toPose) {
            lastHitBend = 0;
            var fingerTipTransform = tip.transform;
            var handRotation = hand.transform.rotation;
            for(float i = 0; i <= steps / 5f; i++) {
                lastHitBend = i / (steps / 5f);
                int overlapCount = CheckFingerBlendOverlap(layermask, handRotation, fingerTipTransform, ref fromPose, ref toPose, lastHitBend);

                if(overlapCount > 0) {
                    lastHitBend = Mathf.Clamp01(lastHitBend);
                    if(i == 0) {
                        poseDataNonAlloc.SetFingerPose(this, handRotation, knuckleJoint, middleJoint, distalJoint);
                        bend = lastHitBend;
                        return true;
                    }
                    break;
                }

            }

            lastHitBend -= (5f / steps);
            for(int i = 0; i <= steps / 10f; i++) {
                lastHitBend += (1f / steps);
                lastHitBend = Mathf.Clamp01(lastHitBend);
                int overlapCount = CheckFingerBlendOverlap(layermask, handRotation, fingerTipTransform, ref fromPose, ref toPose, lastHitBend);

                if(overlapCount > 0 || lastHitBend >= 1) {
                    bend = lastHitBend;
                    //currBendOffset = lastHitBend;
                    return true;
                }
            }

            lastHitBend = 1f;
            toPose.SetFingerPose(this, handRotation, knuckleJoint, middleJoint, distalJoint); ;
            return false;
        }

        public virtual int CheckFingerBlendOverlap(int layermask, Quaternion handRotation, Transform fingerTipTransform, ref FingerPoseData fromPose, ref FingerPoseData toPose, float point) {
            poseDataNonAlloc.LerpData(ref fromPose, ref toPose, point, false);
            poseDataNonAlloc.SetFingerPose(this, handRotation, knuckleJoint, middleJoint, distalJoint);
            return Physics.OverlapSphereNonAlloc(fingerTipTransform.position, tipRadius, results, layermask, QueryTriggerInteraction.Ignore);
        }






        public virtual void UpdateFingerPose(float bend, FingerPoseEnum fromPose = FingerPoseEnum.Open, FingerPoseEnum toPose = FingerPoseEnum.Closed) { 
            UpdateFingerPose(bend, ref poseData[(int)fromPose], ref poseData[(int)toPose]);
        }

        public virtual void UpdateFingerPose(float bend, ref FingerPoseData fromPose, ref FingerPoseData toPose) {
            this.bend = bend;

            poseDataNonAlloc.LerpData(ref fromPose, ref toPose, bend);
            poseDataNonAlloc.SetFingerPose(this);
        }



        public virtual void SetFingerBend(float bend, ref FingerPoseData fromPose, ref FingerPoseData toPose) {
            this.bend = bend;
            poseDataNonAlloc.LerpData(ref fromPose, ref toPose, bend);
            poseDataNonAlloc.SetFingerPose(this);
        }

        /// <summary>Forces the finger to a bend ignoring physics and offset</summary>
        /// <param name="bend">0 is no bend / 1 is full bend</param>
        public virtual void SetFingerBend(float bend, FingerPoseEnum fromPose = FingerPoseEnum.Open, FingerPoseEnum toPose = FingerPoseEnum.Closed) {
            this.bend = bend;
            SetFingerBend(bend, ref poseData[(int)fromPose], ref poseData[(int)toPose]);
        }




        /// <summary>Sets the current finger to a bend without interfering with the target</summary>
        /// <param name="bend">0 is no bend / 1 is full bend</param>
        //public void SetCurrentFingerBend(float bend, FingerPoseEnum fromPose = FingerPoseEnum.Open, FingerPoseEnum toPose = FingerPoseEnum.Closed) {
        //    currBendOffset = bend;

        //    var openPose = poseData[(int)fromPose];
        //    var closedPose = poseData[(int)toPose];

        //    poseDataNonAlloc.LerpData(ref openPose, ref closedPose, bend);
        //    poseDataNonAlloc.SetFingerPose(this);
        //}



        [ContextMenu("Open")]
        public virtual void ResetBend() {
            var openPose = poseData[(int)FingerPoseEnum.Open];
            openPose.SetFingerPose(this);
        }

        [ContextMenu("Close")]
        public virtual void Grip() {
            var closedPose = poseData[(int)FingerPoseEnum.Closed];
            closedPose.SetFingerPose(this);
        }


        /// <summary>Returns the bend the finger ended with from the last BendFingerUntilHit() call</summary>
        public float GetLastHitBend() {
            return lastHitBend;
        }

        /// <summary>Saves the current pose the finger is taking to the given pose type</summary>
        public virtual void SavePose(Hand hand, Finger finger, FingerPoseEnum poseType) {
            if(poseData == null)
                poseData = new FingerPoseData[(int)FingerPoseEnum.TotalPoses];

            if(poseData.Length != (int)FingerPoseEnum.TotalPoses) {
                var oldData = poseData;
                poseData = new FingerPoseData[(int)FingerPoseEnum.TotalPoses];
                for(int i = 0; i < oldData.Length; i++) {
                    poseData[i] = oldData[i];
                }
            }

            Debug.Log("Pose Type: " + poseType + " - " + (int)poseType + " - Length: " + poseData.Length);

            if(!poseData[(int)poseType].isSet)
                poseData[(int)poseType] = new FingerPoseData(hand, finger);
            else
                poseData[(int)poseType].SetPoseData(hand, finger);
        }

        public virtual void SavePose(ref FingerPoseData fingerPoseData, FingerPoseEnum poseType) {
            if(!poseData[(int)poseType].isSet)
                poseData[(int)poseType] = new FingerPoseData(ref fingerPoseData);
            else
                poseData[(int)poseType].CopyFromData(ref fingerPoseData);
        }

        [ContextMenu("SAVE - Open Pose")]
        public void SaveOpenPose() {
            SavePose(hand, this, FingerPoseEnum.Open);
        }

        [ContextMenu("SAVE - Closed Pose")]
        public void SaveClosedPose() {
            SavePose(hand, this, FingerPoseEnum.Closed);
        }

        [ContextMenu("SAVE - Pinch Open Pose")]
        public void SavePinchOpenPose() {
            SavePose(hand, this, FingerPoseEnum.PinchOpen);
        }

        [ContextMenu("SAVE - Pinch Closed Pose")]
        public void SavePinchClosedPose() {
            SavePose(hand, this, FingerPoseEnum.PinchClosed);
        }


        /// <summary>Copies the pose data from the given finger to this finger</summary>
        public virtual void CopyPoseData(Finger finger) {
            for(int i = 0; i < finger.poseData.Length; i++) {
                if(poseData[i].isSet)
                    poseData[i].CopyFromData(finger.poseData[i]);
                else
                    poseData[i] = new FingerPoseData(ref finger.poseData[i]);
            }

        }

        /// <summary>Checks if the given pose type has been saved</summary>
        public virtual bool IsPoseSaved(FingerPoseEnum poseType) {
            if((int)poseType >= poseData.Length)
                return false;

            return (poseData != null && poseData.Length != 0) && poseData[(int)poseType].poseRelativeMatrix != null && poseData[(int)poseType].poseRelativeMatrix.Length > 0;
        }

        public virtual float GetCurrentBend() {
            bendOffset = Mathf.Clamp(bendOffset, 0, 1);
            return bendOffset+secondaryOffset;
        }


        private void OnDrawGizmos() {
            if(tip == null)
                return;

            Gizmos.color = Color.cyan;
            Gizmos.DrawWireSphere(tip.transform.position, tipRadius);
        }


        public bool UpdateDepricatedValues() {

            try {
                if(hand == null)
                    hand = GetComponentInParent<Hand>();
                if(hand == null)
                    Debug.LogError("AUTO HAND: Missing hand reference, please assign the hand reference to the finger component", this);

                //Find enum type
                if(fingerType == FingerEnum.none) {
                    int fingerIndex = -1;
                    for(int i = 0; i < 5; i++) {
                        string enumFingerNames = Enum.GetName(typeof(FingerEnum), (FingerEnum)i).ToLower();
                        if(name.ToLower().Contains(enumFingerNames)) {
                            fingerIndex = i;
                            fingerType = (FingerEnum)fingerIndex;
                            break;
                        }
                    }

                    if(fingerIndex == -1) {
                        Debug.LogError("AUTO HAND: Could not find finger type in name, please set the finger type manually", this);
                        return false;
                    }
                }


                bool missingSetup = (knuckleJoint == null || middleJoint == null || distalJoint == null || tip == null);
                //Set up finger joints if none
                if(missingSetup && fingerType != FingerEnum.none) {
                    //If it has just 4 points we assume it's knuck->middle->distle->tip it doesn't have any additional joints
                    if(fingerJoints.Length == 3) {
                        if(knuckleJoint == null)
                            knuckleJoint = fingerJoints[0];
                        if(middleJoint == null)
                            middleJoint = fingerJoints[1];
                        if(distalJoint == null)
                            distalJoint = fingerJoints[2];
                    }
                    else {
                        Debug.LogError("AUTO HAND: Could not find correct finger joint, unsure about automatic setup, place connected finger values manually", this);
                        return false;
                    }
                }

                missingSetup = (knuckleJoint == null || middleJoint == null || distalJoint == null || tip == null);
                if(missingSetup) {
                    Debug.LogError("AUTO HAND: Missing finger connections, please connect all the joint values of the finger component (If your finger has less than the required joints add the same joint to two inputs)", this);
                    return false;
                }

                if(fingerJoints.Length > 0 && minGripPosPose.Length == fingerJoints.Length && maxGripPosPose.Length == fingerJoints.Length) {

                    var knuckleJointIndex = -1;
                    var middleJointIndex = -1;
                    var distalJointIndex = -1;

                    for(int i = 0; i < fingerJoints.Length; i++) {
                        if(fingerJoints[i] == knuckleJoint)
                            knuckleJointIndex = i;
                        if(fingerJoints[i] == middleJoint)
                            middleJointIndex = i;
                        if(fingerJoints[i] == distalJoint)
                            distalJointIndex = i;
                    }

                    var fingerPosesEnumCount = Enum.GetValues(typeof(FingerPoseEnum)).Length;
                    if(poseData == null || poseData.Length != fingerPosesEnumCount) {
                        poseData = new FingerPoseData[fingerPosesEnumCount];

                    }

                    var knuckleJointPosition = minGripPosPose[knuckleJointIndex];
                    var middleJointPosition = minGripPosPose[middleJointIndex];
                    var distalJointPosition = minGripPosPose[distalJointIndex];

                    var knuckleJointRotation = minGripRotPose[knuckleJointIndex];
                    var middleJointRotation = minGripRotPose[middleJointIndex];
                    var distalJointRotation = minGripRotPose[distalJointIndex];

                    var knuckleStartPosition = knuckleJoint.localPosition;
                    var middleStartPosition = middleJoint.localPosition;
                    var distalStartPosition = distalJoint.localPosition;

                    var knuckleStartRotation = knuckleJoint.localRotation;
                    var middleStartRotation = middleJoint.localRotation;
                    var distalStartRotation = distalJoint.localRotation;

                    knuckleJoint.localPosition = knuckleJointPosition;
                    middleJoint.localPosition = middleJointPosition;
                    distalJoint.localPosition = distalJointPosition;

                    knuckleJoint.localRotation = knuckleJointRotation;
                    middleJoint.localRotation = middleJointRotation;
                    distalJoint.localRotation = distalJointRotation;

                    poseData[(int)FingerPoseEnum.Open] = new FingerPoseData(hand, this);

                    knuckleJointPosition = maxGripPosPose[knuckleJointIndex];
                    middleJointPosition = maxGripPosPose[middleJointIndex];
                    distalJointPosition = maxGripPosPose[distalJointIndex];

                    knuckleJointRotation = maxGripRotPose[knuckleJointIndex];
                    middleJointRotation = maxGripRotPose[middleJointIndex];
                    distalJointRotation = maxGripRotPose[distalJointIndex];

                    knuckleJoint.localPosition = knuckleJointPosition;
                    middleJoint.localPosition = middleJointPosition;
                    distalJoint.localPosition = distalJointPosition;

                    knuckleJoint.localRotation = knuckleJointRotation;
                    middleJoint.localRotation = middleJointRotation;
                    distalJoint.localRotation = distalJointRotation;

                    poseData[(int)FingerPoseEnum.Closed] = new FingerPoseData(hand, this);

                    knuckleJoint.localPosition = knuckleStartPosition;
                    middleJoint.localPosition = middleStartPosition;
                    distalJoint.localPosition = distalStartPosition;

                    knuckleJoint.localRotation = knuckleStartRotation;
                    middleJoint.localRotation = middleStartRotation;
                    distalJoint.localRotation = distalStartRotation;

#if UNITY_EDITOR
                    UnityEditor.EditorUtility.SetDirty(this);
#endif

                    Debug.LogWarning("AUTO HAND: Automatically updating finger joint data, recommend doing this manually to ensure correct setup", this);
                }


                for(int i = 0; i < poseData.Length; i++) {
                    if(poseData[i].isSet)
                        poseData[i].CalculateAdditionalValues(hand.transform.lossyScale);
                }

                return true;
            }
            catch(System.Exception e) {
                Debug.LogWarning("AUTO HAND: Error updating finger values, please check the finger component for errors or manually redo the hand Open/Closed pose after setting all finger values", this);
                Debug.LogWarning(e);
                return false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/Finger.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerGizmo.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 48b44988d9ac3ad4d829d672b3d86020
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {

    public static class FingerGizmo {


        public static void DrawFingerPoseExample(FingerPoseData fingerPose, Matrix4x4 grabbableToWorld, Matrix4x4 handToGrabbable, Color color) {
            Matrix4x4 handGlobalMatrix = grabbableToWorld * handToGrabbable;
            var kuckleToHandMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            var middleToKnuckleMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.middle];
            var distalToMiddleMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.distal];
            var tipToDistalMatrix = fingerPose.poseRelativeMatrix[(int)FingerJointEnum.tip];

            var knuckleGlobalMatrix = handGlobalMatrix * kuckleToHandMatrix;
            var middleGlobalMatrix = knuckleGlobalMatrix * middleToKnuckleMatrix;
            var distalGlobalMatrix = middleGlobalMatrix * distalToMiddleMatrix;
            var tipGlobalMatrix = distalGlobalMatrix * tipToDistalMatrix;

            var handPosition = AutoHandExtensions.ExtractPosition(ref handGlobalMatrix);
            var knucklePosition = AutoHandExtensions.ExtractPosition(ref knuckleGlobalMatrix);
            var middlePosition = AutoHandExtensions.ExtractPosition(ref middleGlobalMatrix);
            var distalPosition = AutoHandExtensions.ExtractPosition(ref distalGlobalMatrix);
            var tipPosition = AutoHandExtensions.ExtractPosition(ref tipGlobalMatrix);

            Gizmos.color = color;
            Gizmos.DrawLine(handPosition, knucklePosition);
            Gizmos.DrawLine(knucklePosition, middlePosition);
            Gizmos.DrawLine(middlePosition, distalPosition);
            Gizmos.DrawLine(distalPosition, tipPosition);

            Gizmos.DrawWireSphere(knucklePosition, 0.004f);
            Gizmos.DrawWireSphere(middlePosition, 0.004f);
            Gizmos.DrawWireSphere(distalPosition, 0.004f);
            Gizmos.DrawWireSphere(tipPosition, 0.004f);
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerGizmo.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerTriggerAreaEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6a33e6ce4c2567a4e8dea64cbe24ebe6
# ASMDEF: AutoHandAssembly.dll
# ---
using Autohand;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class FingerTriggerAreaEvents : HandTriggerAreaEvents
{
    [Header("Finger Trigger Events")]
    public FingerEnum[] allowedFingers;
    [Space]
    public UnityEvent<Finger, FingerTriggerAreaEvents> FingerEnterEvent;
    public UnityEvent<Finger, FingerTriggerAreaEvents> FingerExitEvent;

    protected Collider[] triggerAreaColliders;
    protected GameObject[] triggerAreaObjects;
    protected int[] startingLayers;

    Collider[] colliderNonAlloc = new Collider[32];
    bool validState = false;
    bool lastValidState = false;
    Finger currentFinger;

    protected virtual void Awake() {
        triggerAreaColliders = GetComponentsInChildren<Collider>();
        startingLayers = new int[triggerAreaColliders.Length];
        triggerAreaObjects = new GameObject[triggerAreaColliders.Length];
        for(int i = 0; i < triggerAreaColliders.Length; i++) {
            startingLayers[i] = triggerAreaColliders[i].gameObject.layer;
            triggerAreaObjects[i] = triggerAreaColliders[i].gameObject;
        }
    }


    protected virtual void FixedUpdate() {
        CheckFingerOverlapEvents();
    }

    protected virtual void CheckFingerOverlapEvents() {
        validState = false;

        if(hands.Count > 0) {
            var layer = LayerMask.NameToLayer(Hand.grabbingLayerName);
            var layerMask = LayerMask.GetMask(Hand.grabbingLayerName);
            for(int i = 0; i < triggerAreaColliders.Length; i++)
                triggerAreaObjects[i].layer = layer;

            foreach(var hand in hands) {
                foreach(var finger in hand.fingers) {
                    for(int i = 0; i < allowedFingers.Length; i++) {
                        if(finger.fingerType == allowedFingers[i]) {
                            int overlapCount = Physics.OverlapSphereNonAlloc(finger.tip.position, finger.tipRadius, colliderNonAlloc, layerMask, QueryTriggerInteraction.Collide);
                            if(overlapCount > 0) {
                                validState = true;
                                currentFinger = finger;
                                if(validState != lastValidState)
                                    OnFingerEnter(finger);
                                break;
                            }
                        }
                    }
                }
            }

            for(int i = 0; i < startingLayers.Length; i++)
                triggerAreaObjects[i].layer = startingLayers[i];
        }

        if(validState != lastValidState) {
            if(validState == false)
                OnFingerExit(currentFinger);
        }

        if(validState == false)
            currentFinger = null;
        lastValidState = validState;
    }

    protected virtual void OnFingerEnter(Finger finger) {
        FingerEnterEvent?.Invoke(finger, this);
    }

    protected virtual void OnFingerExit(Finger finger) {
        FingerExitEvent?.Invoke(finger, this);
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerTriggerAreaEvents.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerTriggerAreaToggleEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 21e9ee66b17487c4e93f9d7b5fe26df5
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand
{
    [RequireComponent(typeof(FingerTriggerAreaEvents))]
    public class FingerTriggerAreaToggleEvents : MonoBehaviour
    {
        public UnityEvent<Finger, FingerTriggerAreaEvents> ToggleOn;
        public UnityEvent<Finger, FingerTriggerAreaEvents> ToggleOff;

        bool toggleState = false;

        void OnEnable() {
            GetComponent<FingerTriggerAreaEvents>().FingerEnterEvent.AddListener(Toggle);
        }

        void OnDisable() {
            GetComponent<FingerTriggerAreaEvents>().FingerEnterEvent.RemoveListener(Toggle);
        }

        void Toggle(Finger finger, FingerTriggerAreaEvents triggerArea) {
            toggleState = !toggleState;
            if(toggleState)
                ToggleOn.Invoke(finger, triggerArea);
            else
                ToggleOff.Invoke(finger, triggerArea);

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/FingerTriggerAreaToggleEvents.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/Hand.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9413d460e98076241a1f46c91201217d
# ASMDEF: AutoHandAssembly.dll
# ---
using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.XR;

namespace Autohand {


    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/hand"), DefaultExecutionOrder(10)]
    public class Hand : HandBase {


        [AutoToggleHeader("Enable Highlight", 0, 0, tooltip = "Raycasting for grabbables to highlight is expensive, you can disable it here if you aren't using it")]
        public bool usingHighlight = true;

        [EnableIf("usingHighlight")]
        [Tooltip("The layers to highlight and use look assist on --- Nothing will default on start")]
        public LayerMask highlightLayers;

        [EnableIf("usingHighlight")]
        [Tooltip("Leave empty for none - used as a default option for all grabbables with empty highlight material")]
        public Material defaultHighlight;


        [AutoSmallHeader("Advanced Settings")]
        public bool showAdvanced = false;

        [Tooltip("The hand will automatically apply a no friction physics material to each hand collider on start")]
        public bool noHandFriction = true;

        [Tooltip("Any layers in this mask will be removed from the spherecast checking if a grab is possible: " +
            "IMPORTANT!!! This does not only apply to grabbables, any layers included in  this mask will be completely ignored meaning the hand can grab and highlight objects through with these layers")]
        public LayerMask ignoreGrabCheckLayers;

        [Tooltip("Whether the hand should go to the object and come back on grab, or the object to float to the hand on grab. Will default to HandToGrabbable for objects that have \"parentOnGrab\" disabled")]
        public GrabType grabType = GrabType.HandToGrabbable;

        [Tooltip("The animation curve based on the grab time 0-1"), Min(0)]
        public AnimationCurve grabCurve;

        [Tooltip("Makes grab smoother; also based on range and reach distance - a very near grab is minGrabTime and a max distance grab is maxGrabTime"), Min(0)]
        public float minGrabTime = 0.04f;

        [Tooltip("Makes grab smoother; also based on range and reach distance - a very near grab is minGrabTime and a max distance grab is maxGrabTime"), Min(0)]
        public float maxGrabTime = 0.33f;


        [Tooltip("Increasing this value will make grabbing faster based on controller velocity during grab. Setting this value to 0 will disable this feature. When grabbing an object the speed it takes for the hand to reach the object is decreased based on the velocity of the controller while grabbing"), Min(0)]
        public float velocityGrabHandAmplifier = 600;

        [Tooltip("Increasing this value will make grabbing faster based on grab target velocity during grab. Setting this value to 0 will disable this feature. When grabbing an object the speed it takes for the hand to reach the object is decreased based on the velocity of the controller while grabbing"), Min(0)]
        public float velocityGrabObjectAmplifier = 100;

        [Tooltip("The point along the grab time 0-1 where the hand has been transitioned from whatever pose it was when grabbing to its open hand pose"), Range(0, 1)]
        public float grabOpenHandPoint = 0.5f;

        [Tooltip("This is used in conjunction with custom poses. For a custom pose to work it must has the same PoseIndex as the hand. Used for when your game has multiple hands")]
        public int poseIndex = 0;

        [AutoLine]
        public bool ignoreMe1;





#if UNITY_EDITOR
        bool editorSelected = false;
#endif


        public static string[] grabbableLayers = { "Grabbable", "Grabbing" };

        //The layer is used and applied to all grabbables in if the hands layer is set to default
        public static string grabbableLayerNameDefault = "Grabbable";
        //This helps the auto grab distinguish between what item is being grabbaed and the items around it
        public static string grabbingLayerName = "Grabbing";

        //This was added by request just in case you want to add different layers for left/right hand
        public static string rightHandLayerName = "Hand";
        public static string leftHandLayerName = "Hand";



        ///Events for all my programmers out there :)/// 
        /// <summary>Called when the grab event is triggered, event if nothing is being grabbed</summary>
        public event HandGrabEvent OnTriggerGrab;
        /// <summary>Called at the very start of a grab before anything else</summary>
        public event HandGrabEvent OnBeforeGrabbed;
        /// <summary>Called when the hand grab connection is made (the frame the hand touches the grabbable)</summary>
	    public event HandGrabEvent OnGrabbed;

        /// <summary>Called when the release event is triggered, event if nothing is being held</summary>
        public event HandGrabEvent OnTriggerRelease;
        public event HandGrabEvent OnBeforeReleased;
        /// <summary>Called at the end the release</summary>
        public event HandGrabEvent OnReleased;

        /// <summary>Called when the squeeze button is pressed, regardless of whether an object is held or not (grab returns null)</summary>
        public event HandGrabEvent OnSqueezed;
        /// <summary>Called when the squeeze button is released, regardless of whether an object is held or not (grab returns null)</summary>
        public event HandGrabEvent OnUnsqueezed;


        /// <summary>Called whenever joint breaks or force release event is called</summary>
        public event HandGrabEvent OnForcedRelease;
        /// <summary>Called when the physics joint between the hand and the grabbable is broken by force</summary>
        public event HandGrabEvent OnGrabJointBreak;

        /// <summary>Legacy Event - same as OnRelease</summary>
        public event HandGrabEvent OnHeldConnectionBreak;

        public event HandGameObjectEvent OnHandCollisionStart;
        public event HandGameObjectEvent OnHandCollisionStop;
        public event HandGameObjectEvent OnHandTriggerStart;
        public event HandGameObjectEvent OnHandTriggerStop;

        public Hand copyFromHand;

        public Grabbable lastHoldingObj { get; private set; }

        public Grabbable lookingAtObj { get { return highlighter.currentHighlightTarget; } }
        public Vector3 lastFollowPosition { get { return handFollow.lastFrameFollowPosition; }  }
        public Quaternion lastFollowRotation { get { return handFollow.lastFrameFollowRotation; } }



        List<HandTriggerAreaEvents> triggerEventAreas = new List<HandTriggerAreaEvents>();

        float startGrabDist;
        Vector3 startHandLocalGrabPosition;


        Coroutine _grabRoutine;
        Coroutine grabRoutine {
            get { return _grabRoutine; }
            set {
                if(value != null && _grabRoutine != null) {
                    StopCoroutine(_grabRoutine);
                    if(holdingObj != null) {
                        holdingObj.body.linearVelocity = Vector3.zero;
                        holdingObj.body.angularVelocity = Vector3.zero;
                        holdingObj.beingGrabbed = false;
                    }
                    BreakGrabConnection();
                }
                _grabRoutine = value;
            }
        }


        protected override void Awake() {
            this.SetLayerRecursive(transform, LayerMask.NameToLayer(left ? Hand.leftHandLayerName : Hand.rightHandLayerName));

            if(highlightLayers.value == 0 || highlightLayers == LayerMask.GetMask("")) {
                highlightLayers = LayerMask.GetMask(grabbableLayerNameDefault);
            }

            handLayers = LayerMask.GetMask(rightHandLayerName, leftHandLayerName, AutoHandPlayer.HandPlayerLayer);
            handIgnoreCollisionLayers = AutoHandExtensions.GetPhysicsLayerMask(LayerMask.NameToLayer(rightHandLayerName)) & AutoHandExtensions.GetPhysicsLayerMask(LayerMask.NameToLayer(leftHandLayerName));

            if(grabCurve == null || grabCurve.keys.Length == 0)
                grabCurve = AnimationCurve.Linear(0, 0, 1, 1);

            base.Awake();
        }


        protected virtual void Start()
        {
            if(noHandFriction) {
                var noFrictionMat = Resources.Load<PhysicsMaterial>("NoFriction");
                foreach(var collider in handColliders) {
                    collider.material = noFrictionMat;
                }
            }

#if UNITY_EDITOR
            if (Selection.activeGameObject == gameObject)
            {
                Selection.activeGameObject = null;
                Debug.Log("Auto Hand: highlighting hand component in the inspector can cause lag and quality reduction at runtime in VR. (Automatically deselecting at runtime) Remove this code at any time.", this);
                editorSelected = true;
            }

            Application.quitting += () => { if (editorSelected && Selection.activeGameObject == null) Selection.activeGameObject = gameObject; };
#endif
        }


        protected override void OnEnable() {
            base.OnEnable();
            collisionTracker.OnCollisionFirstEnter += OnCollisionFirstEnter;
            collisionTracker.OnCollisionLastExit += OnCollisionLastExit;
            collisionTracker.OnTriggerFirstEnter += OnTriggerFirstEnter;
            collisionTracker.OnTriggerLastExit += OnTriggerLastExit;

            collisionTracker.OnCollisionFirstEnter += OnCollisionFirstEnterEvent;
            collisionTracker.OnCollisionLastExit += OnCollisionLastExitEvent;
            collisionTracker.OnTriggerFirstEnter += OnTriggerFirstEnterEvent;
            collisionTracker.OnTriggerLastExit += OnTriggeLastExitEvent;

        }

        protected override void OnDisable() {
            foreach(var trigger in triggerEventAreas)
                trigger.Exit(this);

            base.OnDisable();
            collisionTracker.OnCollisionFirstEnter -= OnCollisionFirstEnter;
            collisionTracker.OnCollisionLastExit -= OnCollisionLastExit;
            collisionTracker.OnTriggerFirstEnter -= OnTriggerFirstEnter;
            collisionTracker.OnTriggerLastExit -= OnTriggerLastExit;

            collisionTracker.OnCollisionFirstEnter -= OnCollisionFirstEnterEvent;
            collisionTracker.OnCollisionLastExit -= OnCollisionLastExitEvent;
            collisionTracker.OnTriggerFirstEnter -= OnTriggerFirstEnterEvent;
            collisionTracker.OnTriggerLastExit -= OnTriggeLastExitEvent;
        }




        //================================================================
        //================== CORE INTERACTION FUNCTIONS ==================
        //================================================================


        /// <summary>Whether or not this hand can grab the grabbbale based on hand and grabbable settings</summary>
        public bool CanGrab(Grabbable grab) {
            if(grab == null)
                return false;

            var cantHandSwap = (grab.IsHeld() && grab.singleHandOnly && !grab.allowHeldSwapping);
            return (!IsGrabbing() && !cantHandSwap) && grab.CanGrab(this);
        }

        /// <summary>Function for controller trigger fully pressed -> Grabs whatever is directly in front of and closest to the hands palm (by default this is called by the hand controller link component)</summary>
        public virtual void Grab() {
            Grab(grabType);
        }

        /// <summary>Function for controller trigger fully pressed -> Grabs whatever is directly in front of and closest to the hands palm</summary>
        public virtual void Grab(GrabType grabType) {
            OnTriggerGrab?.Invoke(this, null);
            foreach(var triggerArea in triggerEventAreas) {
                triggerArea.Grab(this);
            }
            if(usingHighlight && !grabbing && holdingObj == null && highlighter.currentHighlightTarget != null) {
                
                grabType = GetGrabType(highlighter.currentHighlightTarget);
                grabRoutine = StartCoroutine(GrabObject(highlighter.GetHighlightHit(), highlighter.currentHighlightTarget, grabType));
            }
            else if(!grabbing && holdingObj == null) {
                highlighter.UpdateHighlight(true, true);
                if(highlighter.currentHighlightTarget != null) {

                    grabType = GetGrabType(highlighter.currentHighlightTarget);
                    grabRoutine = StartCoroutine(GrabObject(highlighter.GetHighlightHit(), highlighter.currentHighlightTarget, grabType));
                }

                highlighter.ClearHighlights();
            }

            else if(holdingObj != null && holdingObj.CanGetComponent(out GrabLock grabLock)) {
                grabLock.OnGrabPressed?.Invoke(this, holdingObj);
            }
        }

        /// <summary>Grabs based on raycast and grab input data</summary>
        public virtual void Grab(RaycastHit hit, Grabbable grab, GrabType grabType = GrabType.InstantGrab) {
            bool objectFree = grab.body.isKinematic != true && grab.body.constraints == RigidbodyConstraints.None;
            if(!grabbing && holdingObj == null && this.CanGrab(grab) && objectFree) {
                grabRoutine = StartCoroutine(GrabObject(hit, grab, grabType));
            }
        }

        GrabType GetGrabType(Grabbable grabbable) {
            GrabType grabType = this.grabType;
            if(grabbable.instantGrab)
                grabType = GrabType.InstantGrab;
            else if(grabbable.grabType != HandGrabType.Default) {
                switch(grabbable.grabType) {
                    case HandGrabType.HandToGrabbable:
                        grabType = GrabType.HandToGrabbable;
                        break;
                    case HandGrabType.GrabbableToHand:
                        grabType = GrabType.GrabbableToHand;
                        break;
                }
            }

            return grabType;
        }

        /// <summary>Grab a given grabbable</summary>
        public virtual void TryGrab(Grabbable grab) {
            ForceGrab(grab);
        }


        /// <summary>Alwyas grab a given grabbable, only works if grab is possible will automaticlly Instantiate a new copy of the given grabbable if using a prefab reference</summary>
        public virtual void ForceGrab(Grabbable grab, bool createCopy = false) {
            if(createCopy || !grab.gameObject.scene.IsValid())
                grab = Instantiate(grab);

            RaycastHit closestHit = new RaycastHit();
            closestHit.distance = float.MaxValue;
            if(!grabbing && holdingObj == null && this.CanGrab(grab)) {
                if(GetClosestGrabbableHit(grab, out closestHit))
                    Grab(closestHit, grab, GrabType.InstantGrab);
            }
        }

        /// <summary>Function for controller trigger unpressed (by default this is called by the hand controller link component)</summary>
        public virtual void Release() {
            OnTriggerRelease?.Invoke(this, null);

            foreach(var triggerArea in triggerEventAreas) {
                triggerArea.Release(this);
            }

            if(holdingObj && !holdingObj.wasForceReleased && holdingObj.CanGetComponent<GrabLock>(out GrabLock grablock) && grablock.enabled)
                return;

            if(holdingObj != null) {
                OnBeforeReleased?.Invoke(this, holdingObj);
                holdingObj.OnBeforeReleaseEvent?.Invoke(this, holdingObj);
                holdingObj.OnRelease(this);
                handFollow.ignoreMoveFrame = true;
            }

            BreakGrabConnection();
        }

        /// <summary>This will force release the hand without throwing or calling OnRelease\n like losing grip on something instead of throwing</summary>
        public virtual void ForceReleaseGrab() {
            if(holdingObj != null) {
                OnForcedRelease?.Invoke(this, holdingObj);
                holdingObj?.ForceHandRelease(this);
            }
        }

        /// <summary>Old function left for backward compatability -> Will release grablocks, recommend using ForceReleaseGrab() instead</summary>
        public virtual void ReleaseGrabLock() {
            ForceReleaseGrab();
        }

        /// <summary>Event for controller grip (by default this is called by the hand controller link component)</summary>
        public virtual void Squeeze() {
            OnSqueezed?.Invoke(this, holdingObj);
            holdingObj?.OnSqueeze(this);

            foreach(var triggerArea in triggerEventAreas)
                triggerArea.Squeeze(this);

            squeezing = true;
        }

        /// <summary>Returns the grab axis value from zero to one, (by default this is set by the hand controller link)</summary>
        public virtual float GetGripAxis() {
            return gripAxis;
        }

        /// <summary>Returns the squeeze value from zero to one, (by default this is set by the hand controller link)</summary>
        public float GetSqueezeAxis() {
            return squeezeAxis;
        }

        /// <summary>Event for controller ungrip</summary>
        public virtual void Unsqueeze() {
            squeezing = false;
            OnUnsqueezed?.Invoke(this, holdingObj);
            holdingObj?.OnUnsqueeze(this);

            foreach(var triggerArea in triggerEventAreas) {
                triggerArea.Unsqueeze(this);
            }
        }

        /// <summary>Breaks the grab event without calling the release functions and events</summary>
        public virtual void BreakGrabConnection(bool callEvent = true) {

            if(holdingObj != null) {
                if(squeezing)
                    holdingObj.OnUnsqueeze(this);

                if(grabbing) {
                    if (holdingObj.body != null && !holdingObj.body.isKinematic){
                        holdingObj.body.linearVelocity = Vector3.zero;
                        holdingObj.body.angularVelocity = Vector3.zero;
                    }
                }

                if(holdingObj.HeldCount() > 1)
                    ResetGrabOffset();

                if(holdingObj.ignoreReleaseTime == 0) {
                    transform.position = holdingObj.transform.InverseTransformPoint(startHandLocalGrabPosition);
                    body.position = transform.position;
                }

                holdingObj.BreakHandConnection(this);
                lastHoldingObj = holdingObj;
                lastReleaseTime = Time.time;
                holdingObj = null;
                OnHeldConnectionBreak?.Invoke(this, lastHoldingObj);
                OnReleased?.Invoke(this, lastHoldingObj);
            }
            else if(grabRoutine != null) {
                StopCoroutine(grabRoutine);
            }

            velocityTracker.Disable(throwVelocityExpireTime);
            currentHeldPose = null;
            grabRoutine = null;

            handAnimator.CancelPose(0.05f);

            if(heldJoint != null) {
                Destroy(heldJoint);
                heldJoint = null;
            }
        }



        /// <summary>Creates the grab connection at the current position of the hand and given grabbable</summary>
        public virtual void CreateGrabConnection(Grabbable grab, bool executeGrabEvents = false) {
            CreateGrabConnection(grab, transform.position, transform.rotation, grab.transform.position, grab.transform.rotation, executeGrabEvents);
        }

        /// <summary>Creates the grab connection</summary>
        public virtual void CreateGrabConnection(Grabbable grab, Vector3 handPos, Quaternion handRot, Vector3 grabPos, Quaternion grabRot, bool executeGrabEvents = false, bool ignorePoses = false) {

            if(executeGrabEvents) {
                OnBeforeGrabbed?.Invoke(this, grab);
                grab.OnBeforeGrab(this);
            }

            transform.position = handPos;
            body.position = handPos;
            transform.rotation = handRot;
            body.rotation = handRot;

            if(grab.body == null)
                grab.ActivateRigidbody();

            grab.transform.position = grabPos;
            grab.body.position = grabPos;
            grab.transform.rotation = grabRot;
            grab.body.rotation = grabRot;

            handGrabPoint.parent = grab.transform;
            handGrabPoint.position = handPos;
            handGrabPoint.rotation = handRot;


            startGrabDist = Vector3.Distance(palmTransform.position, handGrabPoint.position);
            startHandLocalGrabPosition = grab.transform.InverseTransformPoint(transform.position);

            holdingObj = grab;

            localGrabbablePoint.transform.position = holdingObj.rootTransform.position;
            localGrabbablePoint.transform.rotation = holdingObj.rootTransform.rotation;

            if(!(holdingObj.grabType == HandGrabType.GrabbableToHand) && !(grabType == GrabType.GrabbableToHand)) {
                ResetGrabOffset();
            }

            //If it's a predetermined Pose
            if(!ignorePoses && holdingObj.GetSavedPose(out var poseCombiner)) {
                if(poseCombiner.CanSetPose(this, holdingObj)) {
                    currentHeldPose = poseCombiner.GetClosestPose(this, holdingObj);
                    currentHeldPose.SetHandPose(this);
                }
            }


            //Hand Swap - One Handed Items
            if(holdingObj.singleHandOnly && holdingObj.HeldCount(false, false, false) > 0) {
                holdingObj.ForceHandRelease(holdingObj.GetHeldBy()[0]);
                if(holdingObj.body != null) {
                    holdingObj.body.linearVelocity = Vector3.zero;
                    holdingObj.body.angularVelocity = Vector3.zero;
                }
            }

            handAnimator.targetGrabPose.SavePose(this, holdingObj.transform);

            if(executeGrabEvents) {
                OnGrabbed?.Invoke(this, holdingObj);
                holdingObj.OnGrab(this);
            }

            grabbing = false;
            grabRoutine = null;

            CreateJoint(holdingObj, holdingObj.jointBreakForce, float.PositiveInfinity);
        }


        /// <summary>Creates Joints between hand and grabbable, does not call grab events</summary>
        public virtual void CreateJoint(Grabbable grab) {
            CreateJoint(grab, grab.jointBreakForce, float.PositiveInfinity);
        }

        /// <summary>Creates Joints between hand and grabbable, does not call grab events</summary>
        public virtual void CreateJoint(Grabbable grab, float breakForce, float breakTorque) {
            if(grab.customGrabJoint == null) {
                var jointCopy = (Resources.Load<ConfigurableJoint>("DefaultJoint"));
                var newJoint = gameObject.AddComponent<ConfigurableJoint>().GetCopyOf(jointCopy);
                newJoint.anchor = Vector3.zero;
                newJoint.breakForce = breakForce;
                if(grab.HeldCount() == 1)
                    newJoint.breakForce += 500;
                newJoint.breakTorque = breakTorque;
                newJoint.connectedBody = grab.body;
                newJoint.enablePreprocessing = jointCopy.enablePreprocessing;
                newJoint.autoConfigureConnectedAnchor = false;
                newJoint.connectedAnchor = grab.body.transform.InverseTransformPoint(handGrabPoint.position);
                newJoint.angularXMotion = jointCopy.angularXMotion;
                newJoint.angularYMotion = jointCopy.angularYMotion;
                newJoint.angularZMotion = jointCopy.angularZMotion;

                heldJoint = newJoint;
            }
            else {
                var newJoint = grab.body.gameObject.AddComponent<ConfigurableJoint>().GetCopyOf(grab.customGrabJoint);
                newJoint.anchor = Vector3.zero;
                if(grab.HeldCount() == 1)
                    newJoint.breakForce += 500;
                newJoint.breakForce = breakForce;
                newJoint.breakTorque = breakTorque;
                newJoint.connectedBody = body;
                newJoint.enablePreprocessing = grab.customGrabJoint.enablePreprocessing;
                newJoint.autoConfigureConnectedAnchor = false;
                newJoint.connectedAnchor = grab.body.transform.InverseTransformPoint(handGrabPoint.position);
                newJoint.angularXMotion = grab.customGrabJoint.angularXMotion;
                newJoint.angularYMotion = grab.customGrabJoint.angularYMotion;
                newJoint.angularZMotion = grab.customGrabJoint.angularZMotion;
                heldJoint = newJoint;
            }
        }


        public virtual void OnJointBreak(float breakForce) {
            if(heldJoint != null) {
                Destroy(heldJoint);
                heldJoint = null;
            }
            if(holdingObj != null) {
                holdingObj.body.linearVelocity /= 100f;
                holdingObj.body.angularVelocity /= 100f;
                OnGrabJointBreak?.Invoke(this, holdingObj);
                holdingObj?.OnHandJointBreak(this);
            }
        }




        //=================================================================
        //======================== GETTERS AND SETTERS ====================
        //=================================================================

        /// <summary>Takes a raycasthit and grabbable and automatically poses the hand</summary>
        public void AutoPose(RaycastHit hit, Grabbable grabbable) {
            var grabbingLayer = LayerMask.NameToLayer(Hand.grabbingLayerName);
            grabbable.SetLayerRecursive(grabbingLayer);

            Transform palmTransform = this.palmTransform;

            if(grabbable.grabPoseType == HandGrabPoseType.Pinch) {
                palmTransform = pinchPointTransform;
            }

            Vector3 palmLocalPos = palmTransform.localPosition;
            Quaternion palmLocalRot = palmTransform.localRotation;

            Vector3 hitColliderPosition = hit.collider.transform.position;
            Quaternion hitColliderRotation = hit.collider.transform.rotation;

            var palmColliderTransform = palmCollider.transform;

            var handTransform = transform;

            palmCollider.enabled = true;
            for(int i = 0; i < 12; i++)
                Calculate();
            palmCollider.enabled = false;

            void Calculate() {
                Align();

                var grabDir = hit.point - palmTransform.position;
                handTransform.position += grabDir;
                body.position = handTransform.position;

                if(Physics.ComputePenetration(hit.collider, hitColliderPosition, hitColliderRotation,
                    palmCollider, palmColliderTransform.position, palmColliderTransform.rotation, 
                    out var dir, out var dist)) {
                        handTransform.position -= dir * dist / 2f;
                        body.position = handTransform.position;
                }

                handTransform.position -= palmTransform.forward * grabDir.magnitude / 3f;
                body.position = handTransform.position;
            }

            void Align() {
                palmChild.position = handTransform.position;
                palmChild.rotation = handTransform.rotation;

                palmTransform.LookAt(hit.point, palmTransform.up);

                handTransform.position = palmChild.position;
                handTransform.rotation = palmChild.rotation;

                palmTransform.localPosition = palmLocalPos;
                palmTransform.localRotation = palmLocalRot;
            }

            var mask = LayerMask.GetMask(Hand.grabbingLayerName);
            if(grabbable.grabPoseType == HandGrabPoseType.Grab)
                foreach(var finger in fingers)
                    finger.BendFingerUntilHit(fingerBendSteps, mask);
            else
                foreach(var finger in fingers) {
                    if(!finger.BendFingerUntilHit(fingerBendSteps, mask, FingerPoseEnum.PinchOpen, FingerPoseEnum.PinchClosed))
                        finger.BendFingerUntilHit(fingerBendSteps, mask);
                }

            grabbable.ResetOriginalLayers();
        }


        public void BendFingersUntilHit(Grabbable grabbable) {
            var grabbingLayer = LayerMask.NameToLayer(Hand.grabbingLayerName);
            grabbable.SetLayerRecursive(grabbingLayer);

            var mask = LayerMask.GetMask(Hand.grabbingLayerName);
            if(grabbable.grabPoseType == HandGrabPoseType.Grab) {
                foreach(var finger in fingers)
                    finger.BendFingerUntilHit(fingerBendSteps, mask);
            }
            else {
                foreach(var finger in fingers) {
                    if(!finger.BendFingerUntilHit(fingerBendSteps, mask, FingerPoseEnum.PinchOpen, FingerPoseEnum.PinchClosed))
                        finger.BendFingerUntilHit(fingerBendSteps, mask);
                }
            }

            grabbable.ResetOriginalLayers();
        }

        /// <summary>Recalculates the grab point for the grabbing pose - should only be called in an OnBeforeGrab event</summary>
        public void RecalculateBeforeGrab(Grabbable grab) {
            if(GetClosestGrabbableHit(grab, out var closestHit)) {
                grabbingHit = closestHit;
            }
        }

        /// <summary>Recalulate Held Auto Pose - should only be called while holding an object</summary>
        public void RecaculateHeldAutoPose() {
            if(holdingObj != null && currentHeldPose == null) {
                transform.position -= palmTransform.forward * reachDistance;
                body.position = transform.position;
                var didHit = GetClosestGrabbableHit(holdingObj, out var closestHit);

                if(didHit) {
                    AutoPose(closestHit, holdingObj);
                    handGrabPoint.position = transform.position;
                    handGrabPoint.rotation = transform.rotation;
                    localGrabbablePoint.position = holdingObj.rootTransform.position;
                    localGrabbablePoint.rotation = holdingObj.rootTransform.rotation;
                    heldJoint.connectedAnchor = holdingObj.body.transform.InverseTransformPoint(handGrabPoint.position);
                    handAnimator.targetGrabPose.SavePose(this, holdingObj.transform);
                }
                else {
                    transform.position += palmTransform.forward * reachDistance;
                    body.position = transform.position;
                }
            }
        }


        /// <summary>Returns the current held object - null if empty (Same as GetHeld())</summary>
        public Grabbable GetHeldGrabbable() {
            return holdingObj;
        }

        /// <summary>Returns the current held object - null if empty (Same as GetHeldGrabbable())</summary>
        public Grabbable GetHeld() {
            return holdingObj;
        }

        /// <summary>Returns true if squeezing has been triggered</summary>
        public bool IsSqueezing() {
            return squeezing;
        }



        //=================================================================
        //========================= HELPER FUNCTIONS ======================
        //=================================================================



        /// <summary>Resets the grab offset created on grab for a smoother hand return</summary>
        public void ResetGrabOffset() {
            grabPositionOffset = transform.position - follow.transform.position;
            grabRotationOffset = Quaternion.Inverse(follow.transform.rotation) * transform.rotation;
        }

        /// <summary>Sets the hands grip 0 is open 1 is closed</summary>
        public void SetGrip(float grip, float squeeze) {
            gripAxis = grip;
            squeezeAxis = squeeze;
        }

        [ContextMenu("Set Pose - Relax Hand")]
        public void RelaxHand() {
            foreach(var finger in fingers)
                finger.SetFingerBend(gripOffset);
        }

        [ContextMenu("Set Pose - Open Hand")]
        public void OpenHand() {
            foreach(var finger in fingers)
                finger.SetFingerBend(0);
        }

        [ContextMenu("Set Pose - Close Hand")]
        public void CloseHand() {
            foreach(var finger in fingers)
                finger.SetFingerBend(1);
        }

        [ContextMenu("Set Pose - Pinch Hand")]
        public void PinchHand() {
            foreach(var finger in fingers)
                finger.SetFingerBend(1, FingerPoseEnum.Open, FingerPoseEnum.PinchClosed);
        }

        [ContextMenu("Set Pose - Open Pinch Hand")]
        public void OpenPinchHand() {
            foreach(var finger in fingers)
                finger.SetFingerBend(1, FingerPoseEnum.Open, FingerPoseEnum.PinchOpen);
        }

        [ContextMenu("Bend Fingers Until Hit")]
        /// <summary>Bends each finger until they hit</summary>
        public void ProceduralFingerBend() {
            ProceduralFingerBend(~LayerMask.GetMask(rightHandLayerName, leftHandLayerName));
        }

        /// <summary>Bends each finger until they hit</summary>
        public void ProceduralFingerBend(int layermask) {
            foreach(var finger in fingers) {
                finger.BendFingerUntilHit(fingerBendSteps, layermask);
            }
        }

        /// <summary>Bends each finger until they hit</summary>
        public void ProceduralFingerBend(RaycastHit hit) {
            foreach(var finger in fingers) {
                finger.BendFingerUntilHit(fingerBendSteps, hit.transform.gameObject.layer);
            }
        }

        /// <summary>Plays haptic vibration on the hand controller if supported by controller link</summary>
        public void PlayHapticVibration() {
            PlayHapticVibration(0.05f, 0.5f);
        }

        /// <summary>Plays haptic vibration on the hand controller if supported by controller link</summary>
        public void PlayHapticVibration(float duration) {
            PlayHapticVibration(duration, 0.5f);
        }

        /// <summary>Plays haptic vibration on the hand controller if supported by controller link</summary>
        public void PlayHapticVibration(float duration, float amp = 0.5f) {
            if(left)
                HandControllerLink.handLeft?.TryHapticImpulse(duration, amp);
            else
                HandControllerLink.handRight?.TryHapticImpulse(duration, amp);
        }


            

        #region INTERNAL FUNCTIONS

        //=================================================================
        //======================= INTERNAL FUNCTIONS ======================
        //=================================================================



        /// <summary>Takes a hit from a grabbable object and moves the hand towards that point, then calculates ideal hand shape</summary>
        protected IEnumerator GrabObject(RaycastHit hit, Grabbable grab, GrabType grabType) {
            /////////////////////////
            ////Initialize values////
            /////////////////////////
            if(!CanGrab(grab))
                yield break;


            grab.AddWaitingForGrab(this);

            bool waitingForGrab = false;
            while(grab.beingGrabbed) {
                waitingForGrab = true;
                yield return new WaitForFixedUpdate();
            }

            grab.RemoveWaitingForGrab(this);

            grab.beforeGrabFrame = true;
            var startHandPosition = transform.position;
            var startHandRotation = transform.rotation;
            var startGrabbablePosition = grab.transform.position;
            var startGrabbableRotation = grab.transform.rotation;
            if(grab.body != null) {
                startGrabbablePosition = grab.body.transform.position;
                startGrabbableRotation = grab.body.transform.rotation;
            }

            grabbing = true;
            grab.beforeGrabFrame = false;


            handAnimator.CancelPose();
            handAnimator.ClearPoseArea();

            currentHeldPose = null;
            holdingObj = grab;
            var startHoldingObj = holdingObj;

            body.linearVelocity = Vector3.zero;
            body.angularVelocity = Vector3.zero;

            grabbingHit = hit;

            OnBeforeGrabbed?.Invoke(this, holdingObj);
            holdingObj.OnBeforeGrab(this);

            if(waitingForGrab)
                RecalculateBeforeGrab(grab);

            handGrabPoint.parent = grab.rootTransform;
            handGrabPoint.position = grabbingHit.point;
            handGrabPoint.up = grabbingHit.normal;

            if(holdingObj == null || grabbingHit.collider == null) {
                CancelGrab();
                yield break;
            }

            var instantGrab = holdingObj.instantGrab || grabType == GrabType.InstantGrab;
            startGrabDist = Vector3.Distance(palmTransform.position, handGrabPoint.position);
            startHandLocalGrabPosition = holdingObj.transform.InverseTransformPoint(transform.position);


            if(holdingObj == null || grabbingHit.collider == null) {
                CancelGrab();
                yield break;
            }

            if(instantGrab)
                holdingObj.ActivateRigidbody();

            /////////////////
            ////Sets Pose////
            /////////////////
            
            HandPoseData startGrabPose;
            if(holdingObj.GetGrabPose(this, out var tempGrabPose)) {
                startGrabPose = new HandPoseData(this, tempGrabPose.transform);
                currentHeldPose = tempGrabPose;
                currentHeldPose.SetHandPose(this);
            }
            else {
                startGrabPose = new HandPoseData(this, holdingObj.transform);
                transform.position -= palmTransform.forward * 0.08f;
                body.position = transform.position;
                AutoPose(grabbingHit, holdingObj);
            }

            if(currentHeldPose != null)
                handAnimator.targetGrabPose.CopyFromData(ref currentHeldPose.GetHandPoseData(this));
            else
                handAnimator.targetGrabPose.SavePose(this, holdingObj.transform);

            localGrabbablePoint.position = grab.rootTransform.position;
            localGrabbablePoint.rotation = grab.rootTransform.rotation;


            //////////////////////////
            ////Grabbing Animation////
            //////////////////////////

            handAnimator.SetPose(ref handAnimator.targetGrabPose, 0f);

            //Instant Grabbing
            if(instantGrab) {
                if(currentHeldPose != null)
                    currentHeldPose.SetHandPose(this);

                //Hand Swap - One Handed Items
                if(holdingObj.singleHandOnly && holdingObj.HeldCount(false, false, false) > 0) {
                    holdingObj.ForceHandRelease(holdingObj.GetHeldBy()[0]);
                    if(holdingObj.body != null) {
                        holdingObj.body.linearVelocity = Vector3.zero;
                        holdingObj.body.angularVelocity = Vector3.zero;
                    }
                }
            }
            //Smooth Grabbing
            else {
                transform.position = startHandPosition;
                transform.rotation = startHandRotation;
                body.position = startHandPosition;
                body.rotation = startHandRotation;

                var adjustedGrabTime = GetGrabTime();
                instantGrab = instantGrab || adjustedGrabTime == 0;
                Transform grabTarget = currentHeldPose != null ? currentHeldPose.transform : holdingObj.transform;

                var targetOpenPose = new HandPoseData(this);
                targetOpenPose.CopyFromData(ref handAnimator.openHandPose);
                foreach(var finger in fingers) {
                    int fingerIndex = (int)finger.fingerType;
                    targetOpenPose.fingerPoses[fingerIndex].LerpDataTo(ref handAnimator.closeHandPose.fingerPoses[fingerIndex], finger.GetLastHitBend() / 2f);
                }

                /////////////////////////
                ////Hand To Grabbable////
                /////////////////////////
                if(grabType == GrabType.HandToGrabbable || (grabType == GrabType.GrabbableToHand && (holdingObj.HeldCount() > 0 || !holdingObj.parentOnGrab))) {
                    //Loop until the hand is at the object
                    for(float i = 0; i < adjustedGrabTime; i += Time.deltaTime) {
                        if(holdingObj != null) {
                            //Will move the hand faster if the controller or object is moving
                            var deltaDist = Vector3.Distance(follow.position, lastFollowPosition);
                            float maxDeltaTimeOffset = minGrabTime/adjustedGrabTime * Time.deltaTime * 5f;

                            float timeOffset = deltaDist * Time.deltaTime * velocityGrabHandAmplifier;
                            timeOffset += holdingObj.GetVelocity().magnitude * Time.deltaTime * velocityGrabObjectAmplifier * 3f;
                            i += Mathf.Clamp(timeOffset, 0, maxDeltaTimeOffset);

                            if(i < adjustedGrabTime) {
                                var point = Mathf.Clamp01(i / adjustedGrabTime);
                                var handTargetTime = 1.25f;

                                if(point < grabOpenHandPoint) {
                                    HandPoseData.LerpPose(ref handAnimator.handPoseDataNonAlloc, ref startGrabPose, ref targetOpenPose, grabCurve.Evaluate(point * 1f / grabOpenHandPoint));
                                    handAnimator.handPoseDataNonAlloc.SetFingerPose(this);
                                }
                                else {
                                    HandPoseData.LerpPose(ref handAnimator.handPoseDataNonAlloc, ref targetOpenPose, ref handAnimator.targetGrabPose, grabCurve.Evaluate((point - grabOpenHandPoint) * (1f / (1f - grabOpenHandPoint))));
                                    handAnimator.handPoseDataNonAlloc.SetFingerPose(this);
                                }

                                HandPoseData.LerpPose(ref handAnimator.handPoseDataNonAlloc, ref startGrabPose, ref handAnimator.targetGrabPose, point * handTargetTime);
                                handAnimator.handPoseDataNonAlloc.SetPosition(this, grabTarget);

                                body.position = transform.position;
                                body.rotation = transform.rotation;

                                if(holdingObj.body != null && !holdingObj.body.isKinematic) {
                                    holdingObj.body.angularVelocity *= 0.5f;
                                    if(point * handTargetTime >= 1f)
                                        holdingObj.body.linearVelocity *= 0.9f;
                                    else
                                        holdingObj.body.linearVelocity *= 0.98f;
                                }
                                yield return new WaitForEndOfFrame();
                            }
                        }
                    }

                    //Hand Swap - One Handed Items
                    if(holdingObj != null && holdingObj.singleHandOnly && holdingObj.GetHeldBy().Count > 0)
                        holdingObj.ForceHandRelease(holdingObj.GetHeldBy()[0]);
                }



                /////////////////////////
                ////Grabbable to Hand////
                /////////////////////////
                else if(grabType == GrabType.GrabbableToHand) {
                    holdingObj.ActivateRigidbody();


                    //Hand Swap - One Handed Items
                    if(holdingObj.singleHandOnly && holdingObj.HeldCount() > 0)
                        holdingObj.ForceHandRelease(holdingObj.GetHeldBy()[0]);

                    //Disable grabbable while item is moving towards hand
                    bool useGravity = holdingObj.body.useGravity;
                    holdingObj.body.useGravity = false;
                    
                    //Loop until the object is at the hand
                    for(float i = 0; i < adjustedGrabTime; i += Time.deltaTime) {
                        if(holdingObj != null) {
                            //Will move the hand faster if the controller or object is moving
                            var deltaDist = Vector3.Distance(follow.position, lastFollowPosition);
                            float minDeltaTime = minGrabTime/adjustedGrabTime * Time.deltaTime * 5f;

                            float timeOffset = deltaDist * Time.deltaTime * velocityGrabHandAmplifier;
                            i += Mathf.Clamp(timeOffset, 0, minDeltaTime);

                            var point = Mathf.Clamp01(i / adjustedGrabTime);

                            if(point < grabOpenHandPoint) {
                                HandPoseData.LerpPose(ref handAnimator.handPoseDataNonAlloc, ref startGrabPose, ref targetOpenPose, grabCurve.Evaluate(point / grabOpenHandPoint));
                                handAnimator.handPoseDataNonAlloc.SetFingerPose(this);
                            }
                            else {
                                HandPoseData.LerpPose(ref handAnimator.handPoseDataNonAlloc, ref targetOpenPose, ref handAnimator.targetGrabPose, grabCurve.Evaluate((point - grabOpenHandPoint) * (1f / (1f - grabOpenHandPoint))));
                                handAnimator.handPoseDataNonAlloc.SetFingerPose(this);
                            }

                            if(holdingObj.body != null && !holdingObj.body.isKinematic) {
                                holdingObj.body.transform.position = Vector3.Lerp(startGrabbablePosition, localGrabbablePoint.position, grabCurve.Evaluate(point / grabOpenHandPoint));
                                holdingObj.body.transform.rotation = Quaternion.Lerp(startGrabbableRotation, localGrabbablePoint.rotation, grabCurve.Evaluate(point / grabOpenHandPoint));
                                holdingObj.body.position = holdingObj.body.transform.position;
                                holdingObj.body.rotation = holdingObj.body.transform.rotation;
                                holdingObj.body.linearVelocity = Vector3.zero;
                                holdingObj.body.angularVelocity = Vector3.zero;
                            }
                            else {
                                holdingObj.transform.position = Vector3.Lerp(startGrabbablePosition, localGrabbablePoint.position, grabCurve.Evaluate(point / grabOpenHandPoint));
                                holdingObj.transform.rotation = Quaternion.Lerp(startGrabbableRotation, localGrabbablePoint.rotation, grabCurve.Evaluate(point / grabOpenHandPoint));
                            }

                            handFollow.SetMoveTo(true);
                            handFollow.MoveTo(Time.fixedDeltaTime);
                            handFollow.TorqueTo(Time.fixedDeltaTime);

                            yield return new WaitForEndOfFrame();

                        }
                    }

                    //Reset Gravity
                    if(holdingObj != null && holdingObj.body != null)
                        holdingObj.body.useGravity = useGravity;
                    else if(startHoldingObj.body != null)
                        startHoldingObj.body.useGravity = useGravity;
                }

                //Ensure final pose
                if(holdingObj != null)
                    handAnimator.targetGrabPose.SetPose(this, grabTarget);
            }

            if(holdingObj == null) {
                CancelGrab();
                yield break;
            }




            //////////////////////////////////
            ////Finalize Values and Events////
            //////////////////////////////////

            handGrabPoint.position = transform.position;
            handGrabPoint.rotation = transform.rotation;

            holdingObj.ActivateRigidbody();
            localGrabbablePoint.position = holdingObj.rootTransform.position;
            localGrabbablePoint.rotation = holdingObj.rootTransform.rotation;


            if(!instantGrab || !holdingObj.parentOnGrab) {
                ResetGrabOffset();
            }


            CreateJoint(holdingObj, holdingObj.jointBreakForce , float.PositiveInfinity);
            handFollow.SetMoveTo();
            holdingObj?.OnGrab(this);
            OnGrabbed?.Invoke(this, holdingObj);

            if(holdingObj == null) {
                CancelGrab();
                yield break;
            }

            void CancelGrab() {
                BreakGrabConnection();
                if(startHoldingObj)
                {
                    if (startHoldingObj.body != null)
                    {
                        startHoldingObj.body.linearVelocity = Vector3.zero;
                        startHoldingObj.body.angularVelocity = Vector3.zero;
                    }
                    startHoldingObj.beingGrabbed = false;
                }
                grabbing = false;
                grabRoutine = null;
            }

            grabbing = false;
            startHoldingObj.beingGrabbed = false;
            lastGrabTime = Time.time;

            grabRoutine = null;

            if(instantGrab && holdingObj.parentOnGrab) {
                handFollow.SetHandLocation(handFollow.moveTo.position, handFollow.moveTo.rotation);
            }
        }




        internal float GetGrabTime() {
            var distanceDivider = Mathf.Clamp01(startGrabDist / reachDistance);
            return Mathf.Clamp(minGrabTime*2 + ((maxGrabTime - minGrabTime) * distanceDivider), 0, maxGrabTime);
        }

        bool GetClosestGrabbableHit(Grabbable grab, out RaycastHit closestHit) {
            closestHit = new RaycastHit();
            closestHit.distance = float.MaxValue;
            Ray ray = new Ray();
            ray.origin = palmTransform.position;

            bool didHit = false;
            foreach(var collider in grab.grabColliders) {
                Vector3 closestPoint = collider.ClosestPoint(palmTransform.transform.position);
                ray.direction = closestPoint - palmTransform.position;
                ray.direction = ray.direction.normalized;
                if(ray.direction == Vector3.zero) {
                    ray.direction = collider.bounds.center - palmTransform.position;
                }
                if(collider.Raycast(ray, out var hit, 1000)) {
                    if(hit.distance < closestHit.distance) {
                        closestHit = hit;
                        didHit = true;
                    }
                }
                else {
                    ray.origin = Vector3.MoveTowards(ray.origin, collider.bounds.center, 0.002f);
                    if(collider.Raycast(ray, out hit, 1000) && hit.distance < closestHit.distance)
                        closestHit = hit;
                    else {
                        ray.origin = Vector3.MoveTowards(ray.origin, collider.bounds.center, 0.01f);
                        if(collider.Raycast(ray, out hit, 1000) && hit.distance < closestHit.distance)
                            closestHit = hit;
                    }
                }
            }

            return didHit;
        }


        #endregion


        protected virtual void OnCollisionFirstEnter(GameObject collision) {
            if(collision.CanGetComponent(out HandTouchEvent touchEvent)) {
                touchEvent.Touch(this);
            }
        }

        protected virtual void OnCollisionLastExit(GameObject collision) {
            if(collision.CanGetComponent(out HandTouchEvent touchEvent))
                touchEvent.Untouch(this);
        }

        protected virtual void OnTriggerFirstEnter(GameObject other) {
            if(other.CanGetComponent(out HandTriggerAreaEvents area)) {
                triggerEventAreas.Add(area);
                area.Enter(this);
            }
        }

        protected virtual void OnTriggerLastExit(GameObject other) {
            if(other.CanGetComponent(out HandTriggerAreaEvents area)) {
                triggerEventAreas.Remove(area);
                area.Exit(this);
            }
        }

        internal virtual void RemoveHandTriggerArea(HandTriggerAreaEvents handTrigger) {
            handTrigger.Exit(this);
            triggerEventAreas.Remove(handTrigger);
        }


        void OnCollisionFirstEnterEvent(GameObject collision) { OnHandCollisionStart?.Invoke(this, collision); }
        void OnCollisionLastExitEvent(GameObject collision) { OnHandCollisionStop?.Invoke(this, collision); }
        void OnTriggerFirstEnterEvent(GameObject collision) { OnHandTriggerStart?.Invoke(this, collision); }
        void OnTriggeLastExitEvent(GameObject collision) { OnHandTriggerStop?.Invoke(this, collision); }


        public void ResetGrabConnectionOffset() {
            if(heldJoint != null) {
                ResetGrabOffset();

                handGrabPoint.position = transform.position;
                handGrabPoint.rotation = transform.rotation;
                localGrabbablePoint.position = holdingObj.rootTransform.position;
                localGrabbablePoint.rotation = holdingObj.rootTransform.rotation;
                heldJoint.connectedAnchor = holdingObj.body.transform.InverseTransformPoint(handGrabPoint.position);

            }
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/Hand.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandAdvancedOptions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 55c79f4af9a18df40816e08e3399de97
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    [RequireComponent(typeof(Hand)), DefaultExecutionOrder(10000)]
    public class HandAdvancedOptions : MonoBehaviour{
        [Tooltip("Meant for things childed under the Hand. These transforms will not be set to the hand layer on start")]
        public List<Collider> ignoreHandCollider = new List<Collider>();


        Hand hand;

        void Awake(){
            hand = GetComponent<Hand>();
        }

        void Start() { 
            for (int i = 0; i < ignoreHandCollider.Count; i++)
                hand.HandIgnoreCollider(ignoreHandCollider[i], true);
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandAdvancedOptions.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandClippingGuard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e73b55722fce3ca44a89b26c9535ce88
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    public class HandClippingGuard : MonoBehaviour{
        //This script is designed to help prevent the hand from clipping through thin grabbables on release.
        //Also recommeneded that the grabbable has 0 `ignore release time`

        public Hand hand;
        [Tooltip("This should be a sphere collider that covers the hand (similar, but seperate from the recommended trigger sphere collider)")]
        public SphereCollider collisionGuard;
        public Transform body;
        public float guardTime = 0.02f;

        Vector3 grabPoint;
        bool runProtection = false;
        Coroutine guardRoutine;

        // Start is called before the first frame update
        void Start(){
            collisionGuard.enabled = false;
            hand.OnGrabJointBreak += OnRelease;
            hand.OnBeforeGrabbed += BeforeGrab;
        }

        void BeforeGrab(Hand hand, Grabbable grab) {
            if(body == null)
                body = hand.transform.parent;

            if (grab.ignoreReleaseTime == 0)
                runProtection = true;
            else
                runProtection = false;

            grabPoint = hand.transform.position;
            if(guardRoutine != null){
                StopCoroutine(guardRoutine);
                collisionGuard.enabled = false;
            }
        }

        void OnRelease(Hand hand, Grabbable grab) {
            if (runProtection) {
                guardRoutine = StartCoroutine(Guard(hand));
                runProtection = false;
            }
        }

        IEnumerator Guard(Hand hand) {
            hand.body.position = grabPoint;
            hand.transform.position = grabPoint;
            hand.transform.position = Vector3.MoveTowards(hand.transform.position, body.position, collisionGuard.radius);
            collisionGuard.enabled = true;
            yield return new WaitForSeconds(guardTime);
            collisionGuard.enabled = false;
        }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandClippingGuard.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandCollisionHaptics.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 102143406c4b41c46b4c86959873f5c6
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [RequireComponent(typeof(Hand))]
    public class HandCollisionHaptics : MonoBehaviour {

        [Tooltip("The layers that cause the sound to play")]
        public LayerMask collisionTriggers = ~0;
        public float hapticAmp = 0.8f;
        public float velocityAmp = 0.5f;
        public float repeatDelay = 0.2f;
        public float maxDuration = 0.5f;
        [Tooltip("Source to play sound from")]
        public AnimationCurve velocityAmpCurve = AnimationCurve.Linear(0, 0, 1, 1);
        [Tooltip("Source to play sound from")]
        public AnimationCurve velocityDurationCurve = AnimationCurve.Linear(0, 0, 1, 1);

        Hand hand;
        Rigidbody body;
        bool canPlay = true;
        Coroutine playRoutine;

        private void Start() {
            body = GetComponent<Rigidbody>();
            hand = GetComponent<Hand>();

            //So the sound doesn't play when falling in place on start
            StartCoroutine(HapticPlayBuffer(1f));
        }

        private void OnDisable() {
            if(playRoutine != null)
                StopCoroutine(playRoutine);
        }

        void OnCollisionEnter(Collision collision) {
            if(canPlay && collisionTriggers == (collisionTriggers | (1 << collision.gameObject.layer))) {
                if(body != null) {
                    if(collision.collider.attachedRigidbody == null || collision.collider.attachedRigidbody.mass > 0.0000001f) {
                        var magnitude = collision.relativeVelocity.magnitude;
                        hand.PlayHapticVibration(Mathf.Clamp(velocityDurationCurve.Evaluate(magnitude), 0, maxDuration), velocityAmpCurve.Evaluate(magnitude * velocityAmp) * hapticAmp);
                        if(playRoutine != null)
                            StopCoroutine(playRoutine);
                        playRoutine = StartCoroutine(PlayBuffer());
                    }
                }
            }
        }

        IEnumerator PlayBuffer() {
            canPlay = false;
            yield return new WaitForSeconds(repeatDelay);
            canPlay = true;
            playRoutine = null;
        }

        IEnumerator HapticPlayBuffer(float time) {
            canPlay = false;
            yield return new WaitForSeconds(time);
            canPlay = true;
            playRoutine = null;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandCollisionHaptics.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandControllerLink.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: efa024384f9092f4384f843022b1b5bf
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HandControllerLink : MonoBehaviour {
        public static HandControllerLink handLeft, handRight;

        public Hand hand;

        public virtual void TryHapticImpulse(float duration, float amp, float freq = 10f) {

        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandControllerLink.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandDistanceGrabber.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1827e9caa3a42174ea1ead7cf86e7b2f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using NaughtyAttributes;

namespace Autohand {
    [DefaultExecutionOrder(2)]
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/grabbable/distance-grabbing")]
    public class HandDistanceGrabber : MonoBehaviour {
        [Header("Hands")]
        [Tooltip("The primaryHand used to trigger pulling or flicking")]
        public Hand primaryHand;
        [Tooltip("This is important for catch assistance")]
        public Hand secondaryHand;

        [Header("Pointing Options")]
        public Transform forwardPointer;
        public bool useSmoothing = true;
        public float forwardSmoothingSpeed = 5f;
        public LineRenderer line;
        [Space]
        public float maxRange = 5;
        [Tooltip("Defaults to grabbable on start if none")]
        public LayerMask layers;
        [Space]
        public Material defaultTargetedMaterial;
        [Tooltip("The highlight material to use when pulling")]
        public Material defaultSelectedMaterial;

        [Header("Pull Options")]
        public bool useInstantPull = false;
        [Tooltip("If false will default to distance pull, set pullGrabDistance to 0 for instant pull on select")]
        public bool useFlickPull = false;


        [Tooltip("The magnitude of your hands angular velocity for \"flick\" to start")]
        [ShowIf("useFlickPull")]
        public float flickThreshold = 7f;


        [Tooltip("The amount you need to move your hand from the select position to trigger the grab")]
        [HideIf("useFlickPull")]
        public float pullGrabDistance = 0.1f;

        [Space]
        [Tooltip("If this is true the object will be grabbed when entering the radius")]
        public bool instantGrabAssist = true;
        [Tooltip("The radius around of thrown object")]
        public float catchAssistRadius = 0.2f;

        [AutoToggleHeader("Show Events")]
        public bool showEvents = true;

        [ShowIf("showEvents")]
        public UnityHandGrabEvent OnPull;
        [ShowIf("showEvents")]
        public UnityHandEvent StartPoint;
        [ShowIf("showEvents")]
        public UnityHandEvent StopPoint;
        [ShowIf("showEvents"), Tooltip("Targeting is started when object is highlighted")]
        public UnityHandGrabEvent StartTarget;
        [ShowIf("showEvents")]
        public UnityHandGrabEvent StopTarget;
        [ Tooltip("Selecting is started when grab is selected on highlight object")]
        [ShowIf("showEvents")]
        public UnityHandGrabEvent StartSelect;
        [ShowIf("showEvents")]
        public UnityHandGrabEvent StopSelect;


        List<CatchAssistData> catchAssisted;

        DistanceGrabbable targetingDistanceGrabbable;
        DistanceGrabbable selectingDistanceGrabbable;

        float catchAssistSeconds = 3f;
        bool pointing;
        bool pulling;
        Vector3 startPullPosition;
        RaycastHit hit;
        Quaternion lastRotation;
        private RaycastHit selectionHit;
        float selectedEstimatedRadius;
        float startLookAssist;
        bool lastInstantPull;

        GameObject _hitPoint;
        Coroutine catchAssistRoutine;
        private DistanceGrabbable catchAsistGrabbable;
        private CatchAssistData catchAssistData;

        Vector3 currentSmoothForward;

        GameObject hitPoint {
            get {
                if(!gameObject.activeInHierarchy)
                    return null;

                if(_hitPoint == null) {
                    _hitPoint = new GameObject();
                    _hitPoint.name = "Distance Hit Point";
                    return _hitPoint;
                }

                return _hitPoint;
            }
        }

        void Start() {
            catchAssisted = new List<CatchAssistData>();
            if(layers == 0)
                layers = LayerMask.GetMask(Hand.grabbableLayerNameDefault);

            if(useInstantPull)
                SetInstantPull();
        }

        private void OnEnable() {
            primaryHand.OnTriggerGrab += TryCatchAssist;
            if(secondaryHand != null)
                secondaryHand.OnTriggerGrab += TryCatchAssist;
            primaryHand.OnBeforeGrabbed += (hand, grabbable) => { StopPointing(); CancelSelect(); };

        }

        private void OnDisable() {
            primaryHand.OnTriggerGrab -= TryCatchAssist;
            if(secondaryHand != null)
                secondaryHand.OnTriggerGrab -= TryCatchAssist;
            primaryHand.OnBeforeGrabbed -= (hand, grabbable) => { StopPointing(); CancelSelect(); };

            if(catchAssistRoutine != null) {
                StopCoroutine(catchAssistRoutine);
                catchAssistRoutine = null;
                catchAsistGrabbable.grabbable.OnGrabEvent -= (hand, grabbable) => { if(catchAssisted.Contains(catchAssistData)) catchAssisted.Remove(catchAssistData); };
                catchAsistGrabbable.OnPullCanceled -= (hand, grabbable) => { if(catchAssisted.Contains(catchAssistData)) catchAssisted.Remove(catchAssistData); };
            }
        }

        void Update() {
            CheckDistanceGrabbable();
            if(lastInstantPull != useInstantPull) {
                if(useInstantPull) {
                    useFlickPull = false;
                    pullGrabDistance = 0;
                }
                lastInstantPull = useInstantPull;
            }
        }

        private void OnDestroy() {
            Destroy(hitPoint);
        }
        public void SetInstantPull() {
            useInstantPull = true;
        }

        public void SetPull(float distance) {
            useInstantPull = false;
            useFlickPull = false;
            pullGrabDistance = distance;
        }

        public void SetFlickPull(float threshold) {
            useInstantPull = false;
            useFlickPull = true;
            flickThreshold = threshold;
        }


        void CheckDistanceGrabbable() {

            if(useSmoothing) {
                var currentAngleDistance = Vector3.Angle(currentSmoothForward, forwardPointer.forward);
                currentSmoothForward = Vector3.RotateTowards(currentSmoothForward, forwardPointer.forward, Time.deltaTime * forwardSmoothingSpeed + Time.deltaTime * forwardSmoothingSpeed * currentAngleDistance, 1000f);
                currentSmoothForward.Normalize();
            }
            else
                currentSmoothForward = forwardPointer.forward;

            if(!pulling && pointing && primaryHand.holdingObj == null) {

                bool didHit = Physics.SphereCast(forwardPointer.position, 0.03f, currentSmoothForward, out hit, maxRange, layers);
                DistanceGrabbable hitGrabbable;
                GrabbableChild hitGrabbableChild;
                if(didHit) {
                    if(hit.transform.CanGetComponent(out hitGrabbable)) {
                        if(targetingDistanceGrabbable == null || hitGrabbable.GetInstanceID() != targetingDistanceGrabbable.GetInstanceID())
                        {
                            StartTargeting(hitGrabbable);
                        }
                    }
                    else if(hit.transform.CanGetComponent(out hitGrabbableChild)) {
                        if(hitGrabbableChild.grabParent.transform.CanGetComponent(out hitGrabbable)) {
                            if(targetingDistanceGrabbable == null || hitGrabbable.GetInstanceID() != targetingDistanceGrabbable.GetInstanceID())
                            {
                                StartTargeting(hitGrabbable);
                            }
                        }
                    }
                    else if(targetingDistanceGrabbable != null && hit.transform.gameObject.GetInstanceID() != targetingDistanceGrabbable.gameObject.GetInstanceID())
                    {
                        StopTargeting();
                    }
                }
                else {
                    StopTargeting();
                }

                if(line != null) {
                    if(didHit) {
                        line.positionCount = 2;
                        line.SetPositions(new Vector3[] { forwardPointer.position, hit.point });
                    }
                    else {
                        line.positionCount = 2;
                        line.SetPositions(new Vector3[] { forwardPointer.position, forwardPointer.position + currentSmoothForward * maxRange });
                    }
                }
            }
            else if(pulling && primaryHand.holdingObj == null) {
                if(useFlickPull) {
                    TryFlickPull();
                }
                else {
                    TryDistancePull();
                }
            }
            else if(targetingDistanceGrabbable != null) {
                StopTargeting();
            }
        }




        public virtual void StartPointing() {
            pointing = true;
            currentSmoothForward = forwardPointer.forward;
            StartPoint?.Invoke(primaryHand);
        }

        public virtual void StopPointing() {
            pointing = false;
            if(line != null) {
                line.positionCount = 0;
                line.SetPositions(new Vector3[0]);
            }
            StopPoint?.Invoke(primaryHand);
            StopTargeting();
        }



        public virtual void StartTargeting(DistanceGrabbable target) {
            if(target.enabled && primaryHand.CanGrab(target.grabbable)) {
                if(targetingDistanceGrabbable != null)
                    StopTargeting();
                targetingDistanceGrabbable = target;
                targetingDistanceGrabbable?.grabbable.Highlight(primaryHand, GetTargetedMaterial(targetingDistanceGrabbable));
                targetingDistanceGrabbable?.StartTargeting?.Invoke(primaryHand, target.grabbable);
                StartTarget?.Invoke(primaryHand, target.grabbable);
            }
        }

        public virtual void StopTargeting() {
            targetingDistanceGrabbable?.grabbable.Unhighlight(primaryHand, GetTargetedMaterial(targetingDistanceGrabbable));
            targetingDistanceGrabbable?.StopTargeting?.Invoke(primaryHand, targetingDistanceGrabbable.grabbable);
            if(targetingDistanceGrabbable != null)
                StopTarget?.Invoke(primaryHand, targetingDistanceGrabbable.grabbable);
            else if(selectingDistanceGrabbable != null)
                StopTarget?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
            targetingDistanceGrabbable = null;
        }

        public virtual void SelectTarget() {
            if(targetingDistanceGrabbable != null) {
                pulling = true;
                startPullPosition = primaryHand.transform.localPosition;
                lastRotation = transform.rotation;
                selectionHit = hit;
                if(catchAssistRoutine == null) {
                    hitPoint.transform.position = selectionHit.point;
                    hitPoint.transform.parent = selectionHit.transform;
                }
                selectingDistanceGrabbable = targetingDistanceGrabbable;
                selectedEstimatedRadius = Vector3.Distance(hitPoint.transform.position, selectingDistanceGrabbable.grabbable.body.transform.position);
                selectingDistanceGrabbable.grabbable.Unhighlight(primaryHand, GetTargetedMaterial(selectingDistanceGrabbable));
                selectingDistanceGrabbable.grabbable.Highlight(primaryHand, GetSelectedMaterial(selectingDistanceGrabbable));
                selectingDistanceGrabbable?.StartSelecting?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
                targetingDistanceGrabbable?.StopTargeting?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
                targetingDistanceGrabbable = null;
                StartSelect?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
                StopPointing();
            }
        }

        public virtual void CancelSelect() {
            StopTargeting();
            pulling = false;
            selectingDistanceGrabbable?.grabbable.Unhighlight(primaryHand, GetSelectedMaterial(selectingDistanceGrabbable));
            selectingDistanceGrabbable?.StopSelecting?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
            if(selectingDistanceGrabbable != null)
                StopSelect?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
            selectingDistanceGrabbable = null;
        }

        public virtual void ActivatePull() {
            if(selectingDistanceGrabbable) {
                OnPull?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
                selectingDistanceGrabbable.OnPull?.Invoke(primaryHand, selectingDistanceGrabbable.grabbable);
                if(selectingDistanceGrabbable.instantPull) {
                    selectingDistanceGrabbable.grabbable.body.linearVelocity = Vector3.zero;
                    selectingDistanceGrabbable.grabbable.body.angularVelocity = Vector3.zero;
                    selectionHit.point = hitPoint.transform.position;
                    if (selectingDistanceGrabbable.grabbable.placePoint != null)
                        selectingDistanceGrabbable.grabbable.placePoint.Remove();
                    primaryHand.Grab(selectionHit, selectingDistanceGrabbable.grabbable);
                    CancelSelect();
                    selectingDistanceGrabbable?.CancelTarget();
                }
                else if(selectingDistanceGrabbable.grabType == DistanceGrabType.Velocity) {
                    catchAssistRoutine = StartCoroutine(StartCatchAssist(selectingDistanceGrabbable, selectedEstimatedRadius));
                    catchAsistGrabbable = selectingDistanceGrabbable;
                    if (selectingDistanceGrabbable.grabbable.placePoint != null)
                    {
                        
                        selectingDistanceGrabbable.grabbable.placePoint.Remove();
                    }
                    selectingDistanceGrabbable.SetTarget(primaryHand.palmTransform);
                }
                else if(selectingDistanceGrabbable.grabType == DistanceGrabType.Linear) {
                    selectingDistanceGrabbable.grabbable.body.linearVelocity = Vector3.zero;
                    selectingDistanceGrabbable.grabbable.body.angularVelocity = Vector3.zero;
                    selectionHit.point = hitPoint.transform.position;
                    if (selectingDistanceGrabbable.grabbable.placePoint != null)
                        selectingDistanceGrabbable.grabbable.placePoint.Remove();
                    primaryHand.Grab(selectionHit, selectingDistanceGrabbable.grabbable, GrabType.GrabbableToHand);
                    CancelSelect();
                    selectingDistanceGrabbable?.CancelTarget();

                }

                    CancelSelect();
            }
        }


        void TryDistancePull() {
            if(Vector3.Distance(startPullPosition, primaryHand.transform.localPosition) > pullGrabDistance) {
                ActivatePull();
            }
        }

        void TryFlickPull() {
            Quaternion deltaRotation = transform.rotation * Quaternion.Inverse(lastRotation);
            lastRotation = transform.rotation;
            var getAngle = 0f;
            Vector3 getAxis = Vector3.zero;
            deltaRotation.ToAngleAxis(out getAngle, out getAxis);
            getAngle *= Mathf.Deg2Rad;
            float speed = (getAxis * getAngle * (1f / Time.deltaTime)).magnitude;

            if(speed > flickThreshold || useInstantPull) {
                if(selectingDistanceGrabbable) {
                    ActivatePull();
                }
            }
        }




        Material GetSelectedMaterial(DistanceGrabbable grabbable) {
            if(grabbable.ignoreHighlights)
                return null;
            return grabbable.selectedMaterial != null ? grabbable.selectedMaterial : defaultSelectedMaterial;
        }
        Material GetTargetedMaterial(DistanceGrabbable grabbable) {
            if(grabbable.ignoreHighlights)
                return null;
            return grabbable.selectedMaterial != null ? grabbable.targetedMaterial : defaultTargetedMaterial;
        }

        void TryCatchAssist(Hand hand, Grabbable grab) {
            for(int i = 0; i < catchAssisted.Count; i++) {
                var distance = Vector3.Distance(hand.palmTransform.position + hand.palmTransform.forward * catchAssistRadius, catchAssisted[i].grab.transform.position) - catchAssisted[i].estimatedRadius;
                if(distance < catchAssistRadius) {
                    Ray ray = new Ray(hand.palmTransform.position, hitPoint.transform.position - hand.palmTransform.position);
                    if(Physics.SphereCast(ray, 0.03f, out var catchHit, catchAssistRadius * 2, LayerMask.GetMask(Hand.grabbableLayerNameDefault, Hand.grabbingLayerName))) {
                        if(catchHit.transform.gameObject == catchAssisted[i].grab.gameObject) {
                            catchAssisted[i].grab.body.linearVelocity = Vector3.zero;
                            catchAssisted[i].grab.body.angularVelocity = Vector3.zero;
                            hand.Grab(catchHit, catchAssisted[i].grab);
                            CancelSelect();
                        }
                    }
                }
            }
        }


        IEnumerator StartCatchAssist(DistanceGrabbable grab, float estimatedRadius) {
            catchAssistData = new CatchAssistData(grab.grabbable, catchAssistRadius);
            catchAssisted.Add(catchAssistData);
            grab.grabbable.OnGrabEvent += (hand, grabbable) => { if(catchAssisted.Contains(catchAssistData)) catchAssisted.Remove(catchAssistData); };
            grab.OnPullCanceled += (hand, grabbable) => { if(catchAssisted.Contains(catchAssistData)) catchAssisted.Remove(catchAssistData); };

            if(instantGrabAssist) {
                bool cancelInstantGrab = false;
                var time = 0f;
                primaryHand.OnTriggerRelease += (hand, grabbable) => { cancelInstantGrab = true; };

                while(time < catchAssistSeconds && !cancelInstantGrab) {
                    time += Time.fixedDeltaTime;

                    if(TryCatch(primaryHand))
                        break;

                    bool TryCatch(Hand hand) {
                        var distance = Vector3.Distance(hand.palmTransform.position + hand.palmTransform.forward * catchAssistRadius, grab.transform.position) - estimatedRadius;
                        if(distance < catchAssistRadius) {
                            Ray ray = new Ray(hand.palmTransform.position, hitPoint.transform.position - hand.palmTransform.position);
                            var hits = Physics.SphereCastAll(ray, 0.03f, catchAssistRadius * 2, LayerMask.GetMask(Hand.grabbableLayerNameDefault, Hand.grabbingLayerName));
                            for(int i = 0; i < hits.Length; i++) {
                                if(hits[i].transform.gameObject == grab.gameObject) {
                                    grab.grabbable.body.linearVelocity = Vector3.zero;
                                    grab.grabbable.body.angularVelocity = Vector3.zero;
                                    hand.Grab(hits[i], grab.grabbable);
                                    grab.CancelTarget();
                                    CancelSelect();
                                    return true;
                                }
                            }
                        }
                        return false;
                    }

                    yield return new WaitForEndOfFrame();
                }

                primaryHand.OnTriggerRelease -= (hand, grabbable) => { cancelInstantGrab = true; };

            }

            else
                yield return new WaitForSeconds(catchAssistSeconds);

            grab.grabbable.OnGrabEvent -= (hand, grabbable) => { if(catchAssisted.Contains(catchAssistData)) catchAssisted.Remove(catchAssistData); };
            grab.OnPullCanceled -= (hand, grabbable) => { if(catchAssisted.Contains(catchAssistData)) catchAssisted.Remove(catchAssistData); };
            if(catchAssisted.Contains(catchAssistData))
                catchAssisted.Remove(catchAssistData);

            catchAssistRoutine = null;
        }

        private void OnDrawGizmosSelected() {
            if(primaryHand)
                Gizmos.DrawWireSphere(primaryHand.palmTransform.position + primaryHand.palmTransform.forward * catchAssistRadius * 4 / 5f + primaryHand.palmTransform.up * catchAssistRadius * 1 / 4f, catchAssistRadius);
        }
    }

    struct CatchAssistData {
        public Grabbable grab;
        public float estimatedRadius;

        public CatchAssistData(Grabbable grab, float estimatedRadius) {
            this.grab = grab;
            this.estimatedRadius = estimatedRadius;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandDistanceGrabber.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandExtensions.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1bb1227c08e7ffb4f8455e68370ae54f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public static class HandExtensions {

        


        public static void HandIgnoreCollider(this Hand hand, Collider collider, bool ignore) {
            for(int i = 0; i < hand.handColliders.Count; i++)
                Physics.IgnoreCollision(hand.handColliders[i], collider, ignore);
        }


        public static void SetLayerRecursive(this Hand hand, Transform obj, int newLayer) {
            obj.gameObject.layer = newLayer;
            for(int i = 0; i < obj.childCount; i++) {
                hand.SetLayerRecursive(obj.GetChild(i), newLayer);
            }
        }


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandExtensions.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandFingerTouch.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 9a1deccc66b15ad45982fd415dd879a2
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HandFingerTouch
        : MonoBehaviour {
        [Tooltip("Reference to the Hand component")]
        public Hand hand;

        [Tooltip("Reference to the Index Finger component")]
        public Finger index;
        [Tooltip("Reference to the Middle Finger component")]
        public Finger middle;
        [Tooltip("Reference to the Ring Finger component")]
        public Finger ring;
        [Tooltip("Reference to the Pinky Finger component")]
        public Finger pinky;
        [Tooltip("Reference to the Thumb component")]
        public Finger thumb;

        [Tooltip("Layer mask for determining what objects the fingers can interact with")]
        public LayerMask touchMask;

        [Tooltip("Speed at which finger offset adjusts - These default settings are tuned for the default hands physics settings and results might vary based on hands set follow speed and rigidbody settings\"")]
        public float offsetSpeed = 0.65f;

        [Tooltip("Maximum offset for the index finger")]
        public float maxIndexOffset = 0.5f;
        [Tooltip("Maximum offset for the middle finger")]
        public float maxMiddleOffset = 0.5f;
        [Tooltip("Maximum offset for the ring finger")]
        public float maxRingOffset = 0.5f;
        [Tooltip("Maximum offset for the pinky finger")]
        public float maxPinkyOffset = 0.5f;
        [Tooltip("Maximum offset for the thumb")]
        public float maxThumbOffset = 0.5f;

        [Tooltip("Minimum pressure required for interaction - These default settings are tuned for the default hands physics settings and results might vary based on hands set follow speed and rigidbody settings")]
        public float minPressure = 300;
        [Tooltip("Maximum pressure for interaction - These default settings are tuned for the default hands physics settings and results might vary based on hands set follow speed and rigidbody settings")]
        public float maxPressure = 1200;

        [Tooltip("Curve to represent the relationship between pressure applied and finger bend")]
        public AnimationCurve pressureBendCurve = AnimationCurve.Linear(0, 0, 1, 1);


        // Internal fields for handling finger touch and pressure
        private float fingerRadiusMultiplier = 4f;
        private float[] maxOffsets;
        private float[] currentPressure;
        private bool[] isTouching;
        private Vector3 largeSphereCheckerPoint;
        private float largeSphereCheckerRadius;
        private Collider[] collidersNonAlloc = new Collider[100];
        private Vector3[] fingerTips = new Vector3[5];
        private Finger[] fingers = new Finger[5];
        private Vector3 smoothAngularVelocity;



        /// <summary>
        /// Returns a value between 0 and 1 representing the current pressure applied to the finger
        /// </summary>
        public float GetCurrentFingerPressure(FingerEnum finger) {
            return currentPressure[(int)finger];
        }




        void Awake() {
            fingerTips[0] = (hand.transform.InverseTransformPoint(index.tip.position));
            fingerTips[1] =(hand.transform.InverseTransformPoint(middle.tip.position));
            fingerTips[2] =(hand.transform.InverseTransformPoint(ring.tip.position));
            fingerTips[3] =(hand.transform.InverseTransformPoint(pinky.tip.position));
            fingerTips[4] =(hand.transform.InverseTransformPoint(thumb.tip.position));

            fingers[0] = (index);
            fingers[1] =(middle);
            fingers[2] =(ring);
            fingers[3] =(pinky);
            fingers[4] =(thumb);

            maxOffsets = new float[] { maxIndexOffset, maxMiddleOffset, maxRingOffset, maxPinkyOffset, maxThumbOffset };
            currentPressure = new float[] { 0, 0, 0, 0, 0 };
            isTouching = new bool[] { false, false, false, false, false };

            CreateEncapsulatingSphere(fingerTips, out largeSphereCheckerPoint, out largeSphereCheckerRadius);
            largeSphereCheckerRadius += index.tipRadius;
            largeSphereCheckerRadius += middle.tipRadius;
        }


        void OnEnable() {
            StartCoroutine(SlowUpdateCoroutine());
        }


        void OnDisable() {
            StopAllCoroutines();
        }


        void LateUpdate() {
            MoveTowardsBendTarget();
        }


        IEnumerator SlowUpdateCoroutine() {
            while (true) {
                CheckFingerTouch();
                yield return new WaitForFixedUpdate();
            }
        }


        void MoveTowardsBendTarget() {
            for(int i = 0; i < fingers.Length; i++) {
                if(fingers[i].secondaryOffset == 0 && currentPressure[i] == 0)
                    continue;

                float currentTarget = currentPressure[i]*maxOffsets[i];
                float targetDistance = Mathf.Abs(currentTarget - fingers[i].secondaryOffset)/maxOffsets[i];
                targetDistance = Mathf.Pow(targetDistance, 2f);
                float distanceSpeed = Time.deltaTime * offsetSpeed * targetDistance;

                currentTarget = Mathf.Clamp(currentTarget, -maxOffsets[i], maxOffsets[i]);

                fingers[i].secondaryOffset = Mathf.MoveTowards(fingers[i].secondaryOffset, currentTarget, distanceSpeed + Time.deltaTime * offsetSpeed/2f);
                if(fingers[i].GetCurrentBend() < 0) {
                    fingers[i].secondaryOffset += -fingers[i].GetCurrentBend();
                }
            }
        }


        void CheckFingerTouch() {
            //var angularVelocity = CalculateCustomAngularVelocity(hand.transform.rotation, hand.moveTo.transform.rotation, 2000f);
            var targetAngularVelocity = !hand.holdingObj ? hand.handFollow.lastAngularVelocity : Vector3.zero;
            //var lerpDelta = Vector3.SqrMagnitude(targetAngularVelocity - smoothAngularVelocity) * Time.fixedDeltaTime * 1200f + Time.fixedDeltaTime * 360f;
            var lerpDelta =  Time.fixedDeltaTime * 1200f;
            //smoothAngularVelocity = Vector3.Lerp(smoothAngularVelocity, targetAngularVelocity, lerpDelta);
            smoothAngularVelocity = targetAngularVelocity;//Vector3.MoveTowards(smoothAngularVelocity, targetAngularVelocity, lerpDelta);

            //Check for overlap with large sphere
            int numColliders = Physics.OverlapSphereNonAlloc(hand.transform.TransformPoint(largeSphereCheckerPoint), largeSphereCheckerRadius, collidersNonAlloc, touchMask, QueryTriggerInteraction.Ignore);
            if (numColliders > 0) {
                //Check for overlap with each finger
                for(int i = 0; i < fingerTips.Length; i++) {

                    fingerTips[i] = hand.transform.InverseTransformPoint(fingers[i].tip.position);

                    Vector3 fingerTipWorld = hand.transform.TransformPoint(fingerTips[i]);
                    float radius = fingers[i].tipRadius*fingerRadiusMultiplier*Mathf.Abs(hand.transform.lossyScale.x) * (isTouching[i] ? 2f : 1f);
                    int numCollidersFinger = Physics.OverlapSphereNonAlloc(fingerTipWorld, radius, collidersNonAlloc, touchMask, QueryTriggerInteraction.Ignore);
                    if (numCollidersFinger > 0) {
                        var pressure = CalculateFingerTipPressure(fingerTipWorld, hand.transform.position, smoothAngularVelocity, hand.palmTransform.forward, out bool isForceTop, fingers[i].tipRadius);
                        var evaluatedPressure = pressureBendCurve.Evaluate((pressure-minPressure)/maxPressure);

                        isTouching[i] = true;
                        if(pressure < minPressure)
                            continue;

                        //Difference between currentPressure[i] and evaluatedPressure
                        float pressureDifference = Mathf.Abs(currentPressure[i] - evaluatedPressure);
                        pressureDifference = Mathf.Pow(pressureDifference, 2f);


                        currentPressure[i] = Mathf.MoveTowards(currentPressure[i], evaluatedPressure * (isForceTop ? -1 : 1), pressureDifference * Time.fixedDeltaTime * 30f + Time.fixedDeltaTime * 5f);

                    }
                    else {
                        currentPressure[i] =  Mathf.MoveTowards(currentPressure[i], 0, maxOffsets[i]*Time.fixedDeltaTime*30f);
                        isTouching[i] = false;
                    }
                }
            }
            else {
                for(int i = 0; i < fingers.Length; i++) {
                    isTouching[i] = false;
                    if(currentPressure[i] == 0)
                        continue;
                    currentPressure[i] = Mathf.MoveTowards(currentPressure[i], 0, maxOffsets[i]*Time.fixedDeltaTime*30f);
                }
            }
        }

       
        
        Vector3 CalculateCustomAngularVelocity(Quaternion currentRotation, Quaternion targetRotation, float maxAngularVelocity) {
            Quaternion rotationDifference = targetRotation * Quaternion.Inverse(currentRotation);
            var eularAngularVelocity = rotationDifference.eulerAngles;

            return eularAngularVelocity;
        }

        float CalculateFingerTipPressure(Vector3 fingertipPoint, Vector3 wristPoint, Vector3 angularVelocity, Vector3 palmDirection, out bool isForceOnTop, float fingertipArea) {
            Vector3 leverArm = fingertipPoint - wristPoint;
            Vector3 torque = Vector3.Cross(leverArm, angularVelocity);

            float forceMagnitude = torque.magnitude / leverArm.magnitude;
            float pressure = forceMagnitude / fingertipArea;

            Vector3 relativePoint;
            if(float.IsNaN(angularVelocity.x) || float.IsNaN(angularVelocity.y) || float.IsNaN(angularVelocity.z))
                relativePoint = fingertipPoint + hand.body.linearVelocity*Time.fixedDeltaTime;
            else 
                relativePoint = Quaternion.Euler(angularVelocity)*leverArm + hand.body.linearVelocity*Time.fixedDeltaTime;

            var plane = new Plane(palmDirection, Vector3.zero);
            isForceOnTop = plane.GetSide(relativePoint);

            return pressure;
        }



        void CreateEncapsulatingSphere(Vector3[] fingerTips, out Vector3 sphereCenter, out float sphereRadius) {
            sphereCenter = new Vector3();

            foreach(var point in fingerTips) {
                sphereCenter += point;
            }
            sphereCenter /= fingerTips.Length;

            sphereRadius = 0f;
            foreach(var point in fingerTips) {
                float distance = Vector3.Distance(sphereCenter, point);
                sphereRadius = Mathf.Max(sphereRadius, distance);
            }
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandFingerTouch.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPoseArea.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 860940885d4f04170a30987b127e5ff2
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections.Generic;
using UnityEngine;

namespace Autohand{
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/custom-poses#hand-pose-areas")]
    public class HandPoseArea : HandPoseDataContainer {
        public bool useDistancePose = false;
        public float transitionTime = 0.2f;

        [Header("Events")]
        public UnityHandEvent OnHandEnter = new UnityHandEvent();
        public UnityHandEvent OnHandExit = new UnityHandEvent();

        internal HandPoseArea[] poseAreas;
        List<Hand> posingHands = new List<Hand>();



        protected virtual void Start(){
            poseAreas = GetComponents<HandPoseArea>();
        }

        protected virtual void OnEnable() {
            OnHandEnter.AddListener(HandEnter);
            OnHandExit.AddListener(HandExit);
        }

        protected virtual void OnDisable() {
            for(int i = posingHands.Count - 1; i >= 0; i--) 
                posingHands[i].handAnimator.TryRemoveHandPoseArea(this);
            OnHandEnter.RemoveListener(HandEnter);
            OnHandExit.RemoveListener(HandExit);
        }

        protected virtual void HandEnter(Hand hand) {
            posingHands.Add(hand);
        }

        protected virtual void HandExit(Hand hand) {
            posingHands.Remove(hand);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPoseArea.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPoseDataContainer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 4537f3e5cda87b448b1ba36df1b100fd
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Autohand {
    public class HandPoseDataContainer : MonoBehaviour {
        [AutoHeader("Auto Hand Pose")]
        public bool ignoreMe;
        [HideInInspector, SerializeField]
        public HandPoseData rightPose;
        [HideInInspector]
        public bool rightPoseSet = false;
        [HideInInspector, SerializeField]
        public HandPoseData leftPose;
        [HideInInspector]
        public bool leftPoseSet = false;
        [Tooltip("Purely for organizational purposes in the editor")]
        public string poseName = "";
        public int poseIndex = 0;


#if UNITY_EDITOR
        [HideInInspector]
        public bool showEditorTools = true;
        [HideInInspector, Tooltip("Used to pose for the grabbable")]
        public Hand editorHand;
#endif

        [HideInInspector, Tooltip("Scriptable options NOT REQUIRED (will be saved locally instead if empty) -> Create scriptable throught [Auto Hand/Custom Pose]")]
        public HandPoseScriptable poseScriptable;


        //If the old data type is set but not the new data type
        public bool isDataDepricated {
            get {
                bool isOldRightPoseSet = rightPoseSet && rightPose.posePositions.Length > 0;
                bool isOldLeftPoseSet = leftPoseSet && leftPose.posePositions.Length > 0;
                bool isNewRightPoseSet = !rightPose.isDataDeprecated;
                bool isNewLeftPoseSet = !leftPose.isDataDeprecated;
                return (isOldRightPoseSet && !isNewRightPoseSet) || (isOldLeftPoseSet && !isNewLeftPoseSet);
            }
        }

        public void UpdateDepricatedData(Hand hand) {

            if(hand.left && leftPoseSet) {
                leftPose.UpdateDepricatedData(hand, transform);
            }
            else if(!hand.left && rightPoseSet) {
                rightPose.UpdateDepricatedData(hand, transform);
            }
#if UNITY_EDITOR
            EditorUtility.SetDirty(this);
#endif
        }


        /// <summary>Saves/Overwrites the pose data of this grabbable pose to be the given hand relative to this grabbable</summary>
        public virtual void SaveHandPose(Hand hand) {
            if(hand.left)
                leftPose = new HandPoseData(hand, transform);
            else if(!hand.left)
                rightPose = new HandPoseData(hand, transform);
        }

        public virtual ref HandPoseData GetHandPoseData(bool left) {
            if(poseScriptable != null) {
                if(left) 
                    return ref poseScriptable.leftPose;
                else
                    return ref poseScriptable.rightPose;
            }

            if(left) 
                return ref leftPose;
            else 
                return ref rightPose;
        }


        public void SetHandPose(Hand hand) {
            HandPoseData pose;
            if(hand.left) {
                if(leftPoseSet) pose = leftPose;
                else return;
            }
            else {
                if(rightPoseSet) pose = rightPose;
                else return;
            }

            pose.SetPose(hand, transform);
        }

#if UNITY_EDITOR
        [ContextMenu("SAVE RIGHT")]
        public void EditorSavePoseRight() {
            if(editorHand != null)
                EditorSaveGrabPose(editorHand);
            else
                Debug.Log("Editor Hand must be assigned");
        }

        [ContextMenu("SAVE LEFT")]
        public void EditorSavePoseLeft() {
            if(editorHand != null)
                EditorSaveGrabPose(editorHand);
            else
                Debug.Log("Editor Hand must be assigned");
        }

        [ContextMenu("OVERWRITE SCRIPTABLE")]
        public void SaveScriptable() {
            if(poseScriptable != null) {
                if(rightPoseSet)
                    poseScriptable.SaveRightPose(rightPose);
                if(leftPoseSet)
                    poseScriptable.SaveLeftPose(leftPose);
            }
        }

        [ContextMenu("LOAD SCRIPTABLE")]
        public void LoadScriptable() {
            if(poseScriptable != null) {
                if(poseScriptable.leftSaved) {
                    leftPose.CopyFromData(ref poseScriptable.leftPose);
                    leftPoseSet = true;
                }
                if(poseScriptable.rightSaved) {
                    rightPose.CopyFromData(ref poseScriptable.rightPose);
                    rightPoseSet = true;
                }
            }
        }

        public void EditorCreateHandCopyTool(Hand hand, Transform relativeTo) {
            Hand handCopy;
            if(hand.name != "HAND COPY DELETE")
                handCopy = Instantiate(hand, relativeTo.transform.position, hand.transform.rotation);
            else
                handCopy = hand;

            handCopy.name = "HAND COPY DELETE";
            var referenceHand = handCopy.gameObject.AddComponent<EditorHand>();
            referenceHand.handPoseDataContainer = this;

            editorHand = handCopy;

            Selection.activeGameObject = editorHand.gameObject;
            SceneView.lastActiveSceneView.FrameSelected();

            if(hand.left && leftPoseSet) {
                leftPose.SetPose(handCopy, transform);
            }
            else if(!hand.left && rightPoseSet) {
                rightPose.SetPose(handCopy, transform);
            }
            else {
                handCopy.transform.position = relativeTo.transform.position;
                editorHand.RelaxHand();
            }

            var contrainer = new GameObject();
            contrainer.name = "HAND COPY CONTAINER DELETE";
            contrainer.transform.position = relativeTo.transform.position;
            contrainer.transform.rotation = relativeTo.transform.rotation;
            handCopy.transform.parent = contrainer.transform;
            if(hand.poseIndex != poseIndex)
                handCopy.RelaxHand();

            if(handCopy.transform.parent.GetComponentInChildren<MeshRenderer>()  == null && handCopy.transform.parent.GetComponentInChildren<SkinnedMeshRenderer>()  == null) {

                foreach(Finger finger in handCopy.fingers) {
                    for(int i = -1; i < finger.FingerJoints.Length; i++) {
                        Transform fingerTransform = null;
                        Transform childFingerTranform = null;
                        if(i == -1) {

                            fingerTransform = finger.FingerJoints[i+1].parent;
                            childFingerTranform = finger.FingerJoints[i+1];
                        }
                        else if(i < finger.FingerJoints.Length-1) {
                            fingerTransform = finger.FingerJoints[i];
                            childFingerTranform = finger.FingerJoints[i+1];
                        }
                        else if(finger.FingerJoints[i].childCount > 0) {
                            fingerTransform = finger.FingerJoints[i];
                            childFingerTranform = finger.tip;
                        }

                        if(childFingerTranform == null || fingerTransform == null)
                            continue;

                        float distance = Vector3.Distance(fingerTransform.position, childFingerTranform.position);
                        Vector3 direction = (fingerTransform.position - childFingerTranform.position).normalized;

                        GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
                        cube.transform.position = childFingerTranform.position + direction * (distance / 2);  // Offset in direction of bone
                        cube.transform.localScale = new Vector3(finger.tipRadius*2, distance+finger.tipRadius, finger.tipRadius*2);  // Scale based on bone length
                        cube.transform.up = direction;  // Orient cube in direction of bone
                        cube.transform.parent = fingerTransform;
                    }
                }

            }

            Undo.RegisterCreatedObjectUndo(contrainer, "Create Hand Copy Container");

            EditorGUIUtility.PingObject(handCopy);
            SceneView.lastActiveSceneView.FrameSelected();
        }

        public void EditorSaveGrabPose(Hand hand) {
            var pose = new HandPoseData(hand, transform);

            if(hand.left) {
                leftPose = pose;
                leftPoseSet = true;
                Debug.Log("Pose Saved - Left");
                if(poseScriptable != null)
                    if(!poseScriptable.leftSaved)
                        poseScriptable.SaveLeftPose(leftPose);
            }
            else {
                rightPose = pose;
                rightPoseSet = true;
                Debug.Log("Pose Saved - Right");
                if(poseScriptable != null)
                    if(!poseScriptable.rightSaved)
                        poseScriptable.SaveRightPose(rightPose);
            }
        }

        public void EditorClearPoses() {
            leftPoseSet = false;
            leftPose = new HandPoseData();
            rightPoseSet = false;
            rightPose = new HandPoseData();
        }
#endif

        public bool HasPose(bool left) {
            if(poseScriptable != null && ((left) ? poseScriptable.leftSaved : poseScriptable.rightSaved))
                return (left) ? poseScriptable.leftSaved : poseScriptable.rightSaved;
            return left ? leftPoseSet : rightPoseSet;
        }

        protected virtual void OnDrawGizmosSelected() {
            Transform targetTransform = null;
            if(this is GrabbablePose)
                targetTransform = transform;
            if(rightPoseSet && poseIndex == 0)
                GrabbablePoseGizmo.DrawHandGizmo(rightPose, targetTransform, Color.blue/2f);
            if(leftPoseSet)
                GrabbablePoseGizmo.DrawHandGizmo(leftPose, targetTransform, Color.red/2f);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPoseDataContainer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandProjector.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 5a19d3478546e174ba4693f363a23073
# ASMDEF: AutoHandAssembly.dll
# ---

using NaughtyAttributes;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HandProjector : MonoBehaviour {
        [Header("References")]
        public Hand hand;
        [Tooltip("This should be a copy of the hand with the desired visual setup for your projection hand")]
        public Hand handProjection;
        [Tooltip("The Object(s) under your Hand that contain the MeshRenderer Component(s)")]
        public Transform[] handProjectionVisuals;

        [Tooltip("Smoothing speed, turning too high could cause jitters")]
        public float speed = 15f;

        [Tooltip("If true everything in the hand Vvisuals will be disabled/hidden when projection hand is showing")]
        public bool hideHand;
        [ShowIf("hideHand")]
        [Tooltip("The Object(s) under your main hand (not the projection hand) that contain the MeshRenderer Component(s)")]
        public Transform[] handVisuals;

        [Tooltip("Should the projection interpolate between the hand pose and the projected grab pose based on the grip input axis")]
        public bool useGrabTransition;
        [EnableIf("useGrabTransition")]
        [Tooltip("This offsets the grab transistion by this percent when active [0-1 range]")]
        public float grabTransitionOffset = 0;
        [EnableIf("useGrabTransition")]
        [Tooltip("This sets the position of the hand based on its [(gripAxis + grabTransitionOffset) * grabDistanceMultiplyer] -> gripAxis is set on the HandControllerLink component on the main hand")]
        public float grabDistanceMultiplyer = 2f;
        [Tooltip("This sets the pose of the hand based on its [(gripAxis + grabTransitionOffset) * grabDistanceMultiplyer] -> gripAxis is set on the HandControllerLink component on the main hand")]
        [EnableIf("useGrabTransition")]
        public float grabTransitionMultiplyer = 2f;
        [DisableIf("useGrabTransition")]
        [Tooltip("This offsets the highlight by this percent when active [0-1 range]")]
        public float grabPercent = 1f;


        [Header("Events")]
        public UnityHandGrabEvent OnStartProjection;
        public UnityHandGrabEvent OnEndProjection;




        HandPoseData lastProjectionPose;
        HandPoseData newProjectionPose;
        HandPoseData postGrabPose;

        Vector3 lastProjectionPosition;
        Quaternion lastProjectionRotation;

        Grabbable target;
        float startMass = 0;
        float minGrabTime = 0;
        float currAmount;
        bool tryingGrab = false;

        void OnEnable() {
            if(handProjection.body == null)
                handProjection.body = handProjection.GetComponent<Rigidbody>();
            if(hand.body == null)
                hand.body = hand.GetComponent<Rigidbody>();
            handProjection.body.detectCollisions = false;
            handProjection.body.mass = 0;

            handProjection.enableMovement = false;
            handProjection.usingHighlight = false;
            handProjection.enableIK = false;

            handProjection.handFollow.followPositionStrength = 0;
            handProjection.handFollow.followRotationStrength = 0;
            handProjection.swayStrength = 0;
            handProjection.usingHighlight = false;
            handProjection.usingPoseAreas = false;
            startMass = hand.body.mass;
            minGrabTime = hand.minGrabTime;

            lastProjectionPosition = hand.transform.position;
            lastProjectionRotation = hand.transform.rotation;
            lastProjectionPose = new HandPoseData(hand);
            newProjectionPose = new HandPoseData(hand);
            postGrabPose = new HandPoseData(hand);

            hand.OnBeforeGrabbed += OnBeforeGrab;
            hand.OnGrabbed += OnGrab;
            hand.OnBeforeReleased += OnRelease;
            hand.OnTriggerGrab += OnTriggerGrab;

            if(!hideHand)
                handProjection.transform.parent = null;
        }

        void OnDisable() {
            ShowProjection(false);
            hand.OnBeforeGrabbed -= OnBeforeGrab;
            hand.OnGrabbed -= OnGrab;
            hand.OnBeforeReleased -= OnRelease;
            hand.OnTriggerGrab -= OnTriggerGrab;
        }

        void OnTriggerGrab(Hand hand, Grabbable grab) {
            tryingGrab = true;
        }

        void OnBeforeGrab(Hand hand, Grabbable grab) {

            if(hideHand) {
                lastProjectionPose.SetFingerPose(hand);
                hand.transform.position = handProjection.transform.position;
                hand.transform.rotation = handProjection.transform.rotation;
                hand.body.position = hand.transform.position;
                hand.body.rotation = hand.transform.rotation;

                hand.minGrabTime = 0f;
            }

            ShowProjection(false);
        }

        void OnGrab(Hand hand, Grabbable grab) {

            if(useGrabTransition) {
                hand.minGrabTime = minGrabTime;
            }
        }

        void OnRelease(Hand hand, Grabbable grab) {
            lastProjectionPose.CopyFromData(ref hand.handAnimator.currentHandPose);
            lastProjectionPose.SetFingerPose(handProjection);
            lastProjectionPosition = hand.transform.position;
            lastProjectionRotation = hand.transform.rotation;
            handProjection.transform.position = hand.transform.position;
            handProjection.transform.rotation = hand.transform.rotation;
            handProjection.body.position = handProjection.transform.position;
            handProjection.body.rotation = handProjection.transform.rotation;
        }

        void LateUpdate() {
            if(tryingGrab && hand.GetTriggerAxis() < 0.35f)
                tryingGrab = false;


            SetTarget(hand.lookingAtObj);
            ShowProjection(IsProjectionActive());
        }


        void OnProjectionStart(Hand projectionHand, Grabbable target) {
            OnStartProjection?.Invoke(projectionHand, target);
        }


        void OnProjectionEnd(Hand projectionHand, Grabbable target) {
            OnEndProjection?.Invoke(projectionHand, target);
        }


        void ShowProjection(bool show) {
            for(int i = 0; i < handProjectionVisuals.Length; i++)
                handProjectionVisuals[i].gameObject.SetActive(show);

            if(hideHand) {
                for(int i = 0; i < handVisuals.Length; i++)
                    handVisuals[i].gameObject.SetActive(!show);
                if(show)
                    hand.body.mass = 0;
                else
                    hand.body.mass = startMass;
            }

            if(show) {
                var targetHit = hand.highlighter.GetHighlightHit();
                if(targetHit.collider != null) {

                    if(!hand.CanGrab(target)) {
                        ShowProjection(false);
                        return;
                    }

                    var amount = useGrabTransition ? hand.grabCurve.Evaluate(hand.GetTriggerAxis() * grabTransitionMultiplyer + grabTransitionOffset) : grabPercent;
                    currAmount = Mathf.MoveTowards(currAmount, amount, Time.deltaTime * speed);
                    var newSpeed = Mathf.Lerp(speed, speed / 4f, hand.GetTriggerAxis());
                    if(hideHand)
                        hand.body.mass = Mathf.Lerp(startMass, 0, Mathf.Pow(amount * 2, 2));

                    //Do new pose
                    GrabbablePose grabPose;
                    handProjection.transform.position = hand.transform.position;
                    handProjection.transform.rotation = hand.transform.rotation;
                    if(target.GetGrabPose(hand, out grabPose)) {
                        grabPose.SetHandPose(handProjection, true);
                    }
                    else {
                        handProjection.transform.position -= handProjection.palmTransform.forward * 0.08f;
                        handProjection.body.position = handProjection.transform.position;
                        handProjection.AutoPose(targetHit, target);
                    }
                    newProjectionPose.SavePose(handProjection);
                    Vector3 targetPos;
                    Quaternion targetRot;

                    if(useGrabTransition && (target.grabType == HandGrabType.GrabbableToHand || (target.grabType == HandGrabType.Default && hand.grabType == GrabType.GrabbableToHand))) {
                        targetPos = hand.transform.position;
                        targetRot = hand.transform.rotation;
                    }
                    else {
                        targetPos = Vector3.Lerp(hand.transform.position, handProjection.transform.position, currAmount * grabDistanceMultiplyer);
                        targetRot = Quaternion.Lerp(hand.transform.rotation, handProjection.transform.rotation, currAmount * grabDistanceMultiplyer);
                    }


                    //Visual Adjustments
                    if(grabPose == null)
                        foreach(var finger in handProjection.fingers)
                            finger.SetFingerBend(Mathf.Clamp01(finger.GetLastHitBend() - 0.1f));
                    else {
                        foreach(var finger in handProjection.fingers)
                            finger.SetFingerBend(handProjection.gripOffset);
                    }


                    //Interpolate Fingers
                    postGrabPose.LerpPose(ref hand.handAnimator.currentHandPose, ref newProjectionPose, Mathf.Clamp01(currAmount - 0.1f) * 1.25f);
                    lastProjectionPose.LerpPose(ref lastProjectionPose, ref postGrabPose, speed * Time.deltaTime);
                    lastProjectionPose.SetFingerPose(handProjection);

                    if(hand.GetTriggerAxis() > 0.05f || !hideHand) {
                        //Interpolate Position
                        var distance = Vector3.Distance(lastProjectionPosition, targetPos);
                        var angle = Quaternion.Angle(lastProjectionRotation, targetRot);
                        handProjection.transform.position = Vector3.MoveTowards(lastProjectionPosition, targetPos, distance * Time.deltaTime * newSpeed );
                        handProjection.transform.rotation = Quaternion.RotateTowards(lastProjectionRotation, targetRot, angle * newSpeed * Time.deltaTime );
                    }
                    else {
                        handProjection.transform.position = hand.transform.position;
                        handProjection.transform.rotation = hand.transform.rotation;
                        lastProjectionPose.CopyFromData(ref hand.handAnimator.currentHandPose);
                        lastProjectionPose.SetFingerPose(handProjection);
                    }
                    handProjection.body.position = handProjection.transform.position;
                    handProjection.body.rotation = handProjection.transform.rotation;

                    lastProjectionPosition = handProjection.transform.position;
                    lastProjectionRotation = handProjection.transform.rotation;
                }
                else if(!hand.IsGrabbing()) {
                    handProjection.transform.position = hand.transform.position;
                    handProjection.transform.rotation = hand.transform.rotation;
                    lastProjectionPosition = hand.transform.position;
                    lastProjectionRotation = hand.transform.rotation;
                    lastProjectionPose.CopyFromData(ref hand.handAnimator.currentHandPose);
                    lastProjectionPose.SetFingerPose(handProjection);
                }
            }
            else if(useGrabTransition) {
                handProjection.transform.position = hand.transform.position;
                handProjection.transform.rotation = hand.transform.rotation;
            }
        }

        void SetTarget(Grabbable newTarget) {
            if(newTarget != null && !hand.CanGrab(newTarget))
                newTarget = null;

            if(hand.holdingObj != null || newTarget == null) {
                if(target != null) {
                    OnProjectionEnd(handProjection, target);

                    lastProjectionPosition = hand.transform.position;
                    lastProjectionRotation = hand.transform.rotation;
                    handProjection.transform.position = hand.transform.position;
                    handProjection.transform.rotation = hand.transform.rotation;
                    handProjection.body.position = handProjection.transform.position;
                    handProjection.body.rotation = handProjection.transform.rotation;
                }

                target = null;
            }

            if(newTarget != target) {
                if(target != null)
                    OnProjectionEnd(handProjection, target);
                target = newTarget;
                OnProjectionStart(handProjection, target);
            }
        }



        bool IsProjectionActive() {
            return target != null && hand.holdingObj == null && !hand.IsGrabbing() && !tryingGrab;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandProjector.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPublicEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 92716075103c54d429004096c1d8b87a
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand {
    public class HandPublicEvents : MonoBehaviour {
        public Hand hand;
        public UnityHandGrabEvent OnBeforeGrab = new UnityHandGrabEvent();
        public UnityHandGrabEvent OnGrab = new UnityHandGrabEvent();
        public UnityHandGrabEvent OnRelease = new UnityHandGrabEvent();
        public UnityHandGrabEvent OnForceRelease = new UnityHandGrabEvent();
        public UnityHandGrabEvent OnSqueeze = new UnityHandGrabEvent();
        public UnityHandGrabEvent OnUnsqueeze = new UnityHandGrabEvent();
        public UnityHandGrabEvent OnHighlight = new UnityHandGrabEvent();
        public UnityHandGrabEvent OnStopHighlight = new UnityHandGrabEvent();


        void OnEnable() {
            hand.OnBeforeGrabbed += OnBeforeGrabEvent;
            hand.OnGrabbed += OnGrabEvent;
            hand.OnReleased += OnReleaseEvent;
            hand.OnSqueezed += OnSqueezeEvent;
            hand.OnUnsqueezed += OnUnsqueezeEvent;
            hand.highlighter.OnHighlight += OnHighlightEvent;
            hand.highlighter.OnStopHighlight += OnStopHighlightEvent;
        }

        void OnDisable() {
            hand.OnBeforeGrabbed -= OnBeforeGrabEvent;
            hand.OnGrabbed -= OnGrabEvent;
            hand.OnReleased -= OnReleaseEvent;
            hand.OnSqueezed -= OnSqueezeEvent;
            hand.OnUnsqueezed -= OnUnsqueezeEvent;
            hand.highlighter.OnHighlight -= OnHighlightEvent;
            hand.highlighter.OnStopHighlight -= OnStopHighlightEvent;
        }

        public void OnBeforeGrabEvent(Hand hand, Grabbable grab) {
            OnBeforeGrab?.Invoke(hand, grab);
        }

        public void OnGrabEvent(Hand hand, Grabbable grab) {
            OnGrab?.Invoke(hand, grab);
        }

        public void OnReleaseEvent(Hand hand, Grabbable grab) {
            OnRelease?.Invoke(hand, grab);
        }

        public void OnSqueezeEvent(Hand hand, Grabbable grab) {
            OnSqueeze?.Invoke(hand, grab);
        }

        public void OnUnsqueezeEvent(Hand hand, Grabbable grab) {
            OnUnsqueeze?.Invoke(hand, grab);
        }
        public void OnHighlightEvent(Hand hand, Grabbable grab) {
            OnHighlight?.Invoke(hand, grab);
        }

        public void OnStopHighlightEvent(Hand hand, Grabbable grab) {
            OnStopHighlight?.Invoke(hand, grab);
        }

        public void OnForceReleaseEvent(Hand hand, Grabbable grab) {
            OnForceRelease?.Invoke(hand, grab);
        }

        private void OnDrawGizmosSelected() {
            if(hand == null && GetComponent<Hand>())
                hand = GetComponent<Hand>();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandPublicEvents.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTeleportGuard.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6a1edd828a2bad242ae37583788fee8d
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

namespace Autohand{
    [DefaultExecutionOrder(1000)]
    public class HandTeleportGuard : MonoBehaviour{
        [Header("Helps prevent hand from passing through static collision boundries")]
        public Hand hand;

        [Header("Guard Settings")]
        [Tooltip("The mask of things the guarding will ignore, if left on default or empty, will default to ignoring recommended Auto Hand layers")]
        public LayerMask ignoreMask;
        [Tooltip("The amount of distance change required in one frame or fixed udpate to activate the teleport guard")]
        public float buffer = 0.1f;
        [Tooltip("Whether this should always run or only run when activated by the teleporter")]
        public bool alwaysRun = false;
        [Tooltip("If true hands wont teleport return when past the max distance if something is in the way"), FormerlySerializedAs("strict")]
        public bool ignoreMaxHandDistance = false;
        
        
        Vector3 deltaHandPos;
        Vector3 deltaHandFixedPos;

        void Awake(){
            if(hand == null && GetComponent<Hand>())
                hand = GetComponent<Hand>();
            
            if(ignoreMask == 0)
                ignoreMask = LayerMask.GetMask(Hand.grabbableLayerNameDefault, Hand.grabbingLayerName, Hand.rightHandLayerName, Hand.leftHandLayerName, AutoHandPlayer.HandPlayerLayer);
            else
                ignoreMask |= LayerMask.GetMask(Hand.rightHandLayerName, Hand.leftHandLayerName);
        }

        void Update() {
            if(hand == null || !hand.gameObject.activeInHierarchy)
                return;

            if(alwaysRun) {
                var distance = Vector3.Distance(hand.palmTransform.position, deltaHandPos);
                if(ignoreMaxHandDistance || (!ignoreMaxHandDistance && distance < hand.handFollow.maxFollowDistance)) {
                    if(distance > buffer)
                        TeleportProtection(deltaHandPos, hand.palmTransform.position);
                }
                deltaHandPos = hand.palmTransform.position;
            }
        }

        void FixedUpdate() {
            if(hand == null || !hand.gameObject.activeInHierarchy)
                return;

            if(alwaysRun) {
                var distance = Vector3.Distance(hand.palmTransform.position, deltaHandFixedPos);
                if(ignoreMaxHandDistance || (!ignoreMaxHandDistance && distance < hand.handFollow.maxFollowDistance)) {
                    if(distance > buffer)
                        TeleportProtection(deltaHandFixedPos, hand.palmTransform.position);
                }
                deltaHandFixedPos = hand.palmTransform.position;
            }
        }

        /// <summary>Should be called just after a teleportation</summary>
        public void TeleportProtection(Vector3 fromPos, Vector3 toPos) {
            if (hand == null || hand.transform == null)
                return;

            RaycastHit[] hits = Physics.RaycastAll(fromPos, toPos - fromPos, Vector3.Distance(fromPos, toPos), ~ignoreMask);
            Vector3 handPos = Vector3.zero;
            foreach(var hit in hits) {
                if(hit.transform != hand.transform) {
                    handPos = fromPos;
                    break;
                }
            }
            if(handPos != Vector3.zero)
                hand.handFollow.SetHandLocation(handPos, hand.transform.rotation);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTeleportGuard.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTouchEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8bd7f387aed6a494eb37bfca11e0b9cd
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    [HelpURL("https://app.gitbook.com/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/hand-touch-trigger")]
    public class HandTouchEvent : MonoBehaviour{
        [Header("For Solid Collision")]
        [Tooltip("Whether or not first hand to enter should take ownership and be the only one to call events")]
        public bool oneHanded = true;
        public HandType handType = HandType.both;

        [Header("Events")]
        public UnityHandEvent HandStartTouch;
        public UnityHandEvent HandStopTouch;
        
        public HandEvent HandStartTouchEvent;
        public HandEvent HandStopTouchEvent;

        protected List<Hand> hands = new List<Hand>();

        protected virtual void OnDisable() 
        {
            foreach (Hand hand in new List<Hand>(hands))
            {
                if (hand == null)
                {
                    continue;
                }
                
                Untouch(hand);
            }
               
            hands.Clear();
        }

        public virtual void Touch(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(!hands.Contains(hand)) {
                if(oneHanded && hands.Count == 0) {
                    HandStartTouch?.Invoke(hand);
                    HandStartTouchEvent?.Invoke(hand);
                }
                else {
                    HandStartTouch?.Invoke(hand);
                    HandStartTouchEvent?.Invoke(hand);
                }

                hands.Add(hand);
            }
        }
        
        public virtual void Untouch(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(hands.Contains(hand)) {
                if(oneHanded && hands[0] == hand){
                    HandStopTouch?.Invoke(hand);
                    HandStopTouchEvent?.Invoke(hand);
                }
                else if(!oneHanded){
                    HandStopTouch?.Invoke(hand);
                    HandStopTouchEvent?.Invoke(hand);
                }

                hands.Remove(hand);
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTouchEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTriggerAreaEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bf4e711b062ea3f4e9b98bb216629994
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace Autohand{
    public delegate void HandAreaEvent(Hand hand, HandTriggerAreaEvents area);
    public delegate void HandEvent(Hand hand);

    [HelpURL("https://app.gitbook.com/o/v43F1UfKchmlV5VQCpro/s/5zKO0EvOjzUDeT2aiFk3/auto-hand/extras/hand-touch-trigger")]
    public class HandTriggerAreaEvents : MonoBehaviour{
        [Header("Trigger Events Settings")]
        [Tooltip("Whether or not first hand to enter should take ownership and be the only one to call events")]
        public bool oneHanded = true;
        public HandType handType = HandType.both;
        [Tooltip("Whether or not to call the release event if exiting while grab event activated")]
        public bool exitTriggerRelease = true;
        [Tooltip("Whether or not to call the release event if exiting while grab event activated")]
        public bool exitTriggerUnsqueeze = true;

        [Header("Events")]
        public UnityHandEvent HandEnter;
        public UnityHandEvent HandExit;
        public UnityHandEvent HandGrab;
        public UnityHandEvent HandRelease;
        public UnityHandEvent HandSqueeze;
        public UnityHandEvent HandUnsqueeze;

        //For Programmers <3
        public HandAreaEvent HandEnterEvent;
        public HandAreaEvent HandExitEvent;
        public HandAreaEvent HandGrabEvent;
        public HandAreaEvent HandReleaseEvent;
        public HandAreaEvent HandSqueezeEvent;
        public HandAreaEvent HandUnsqueezeEvent;

        protected List<Hand> hands = new List<Hand>();
        protected bool grabbing;
        protected bool squeezing;

        protected virtual void OnDisable()
        {
            foreach (Hand hand in new List<Hand>(hands))
            {
                if (hand == null)
                {
                    continue;
                }

                hand.RemoveHandTriggerArea(this);
            }
        } 

        protected virtual void Update(){
            foreach (var hand in hands){
                if (!hand.enabled) {
                    Exit(hand);
                    Release(hand);
                }
            }
        }


        public virtual void Enter(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(!hands.Contains(hand)) {
                hands.Add(hand);
                if(oneHanded && hands.Count == 1) {
                    HandEnter?.Invoke(hand);
                    HandEnterEvent?.Invoke(hand, this);
                }
                else {
                    HandEnter?.Invoke(hand);
                    HandEnterEvent?.Invoke(hand, this);
                }
            }
        }

        public virtual void Exit(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(hands.Contains(hand)) {
                if(oneHanded && hands[0] == hand){
                    HandExit?.Invoke(hand);
                    HandExitEvent?.Invoke(hand, this);

                    if(grabbing && exitTriggerRelease){
                        HandRelease?.Invoke(hand);
                        HandReleaseEvent?.Invoke(hand, this);
                        grabbing = false;
                    }
                    if(squeezing && exitTriggerUnsqueeze){
                        HandUnsqueeze?.Invoke(hand);
                        HandUnsqueezeEvent?.Invoke(hand, this);
                        squeezing = false;
                    }

                    //If there is another hand, it enters
                    if(hands.Count > 1) {
                        HandEnter?.Invoke(hands[1]);
                        HandEnterEvent?.Invoke(hands[1], this);
                    }

                }
                else if(!oneHanded) {
                    HandExit?.Invoke(hand);
                    HandExitEvent?.Invoke(hand, this);

                    if(grabbing && exitTriggerRelease){
                        HandRelease?.Invoke(hand);
                        HandReleaseEvent?.Invoke(hand, this);
                        grabbing = false;
                    }
                    if(squeezing && exitTriggerUnsqueeze){
                        HandUnsqueeze?.Invoke(hand);
                        HandUnsqueezeEvent?.Invoke(hand, this);
                        squeezing = false;
                    }

                }

                hands.Remove(hand);
            }
        }


        public virtual void Grab(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(grabbing)
                return;

            if(oneHanded && hands[0] == hand){
                HandGrab?.Invoke(hand);
                HandGrabEvent?.Invoke(hand, this);
                grabbing = true;
            }
            else if(!oneHanded){
                HandGrab?.Invoke(hand);
                HandGrabEvent?.Invoke(hand, this);
                grabbing = true;
            }
        }

        public virtual void Release(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(!grabbing)
                return;

            if(oneHanded && hands[0] == hand){
                HandRelease?.Invoke(hand);
                HandReleaseEvent?.Invoke(hand, this);
                grabbing = false;
            }
            else if(!oneHanded){
                HandRelease?.Invoke(hand);
                HandReleaseEvent?.Invoke(hand, this);
                grabbing = false;
            }
        }


        public virtual void Squeeze(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(squeezing)
                return;

            if(oneHanded && hands[0] == hand){
                HandSqueeze?.Invoke(hand);
                HandSqueezeEvent?.Invoke(hand, this);
                squeezing = true;
            }
            else if(!oneHanded){
                squeezing = true;
                HandSqueeze?.Invoke(hand);
                HandSqueezeEvent?.Invoke(hand, this);
            }
        }

        public virtual void Unsqueeze(Hand hand) {
            if (enabled == false || handType == HandType.none || (hand.left && handType == HandType.right) || (!hand.left && handType == HandType.left))
                return;

            if(!squeezing)
                return;

            if(oneHanded && hands[0] == hand){
                HandUnsqueeze?.Invoke(hand);
                HandUnsqueezeEvent?.Invoke(hand, this);
                squeezing = false;
            }
            else if(!oneHanded){
                squeezing = false;
                HandUnsqueeze?.Invoke(hand);
                HandUnsqueezeEvent?.Invoke(hand, this);
            }
        }
}
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/HandTriggerAreaEvents.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/IgnoreHandLayer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 132145a7047493646ad4aaa119028c20
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>For the special use case of attaching something under the hand component and 
/// wanting to ignore the hand layer override operation</summary>
[DefaultExecutionOrder(-100000)]
public class IgnoreHandLayer : MonoBehaviour
{
    public bool includeChildren = true;
    int startLayer;

    void Awake(){
        startLayer = gameObject.layer;
        Invoke("LateStart", 0.1f);
    }

    void LateStart(){
        if(includeChildren)
            SetLayerRecursive(transform, startLayer);
        else
            transform.gameObject.layer = startLayer;
    }
    
    internal void SetLayerRecursive(Transform obj, int newLayer) {
        obj.gameObject.layer = newLayer;
        for (int i = 0; i < obj.childCount; i++)
            SetLayerRecursive(obj.GetChild(i), newLayer);
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/IgnoreHandLayer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/WristLookEvent.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6d164bbe93437d3429e93e40abc6aa56
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand.Demo{
    public class WristLookEvent : MonoBehaviour{
        public Hand hand;
        public Camera head;

        [Tooltip("The minimum head->wrist distance required to activate")]
        public float maxDistance = 0.75f;
        [Tooltip("The angle precisness required to activate; 0 is any angle, 1 is exactly pointed at the face")]
        [Range(0, 1)]
        public float anglePreciseness = 0.75f;
        public bool disableWhileHolding = true;

        [Header("Events")]
        public UnityHandEvent OnShow;
        public UnityHandEvent OnHide;


        bool showing = false;

        void Update(){
            if (hand == null || head == null)
                return;

            var handPos = hand.transform.position;
            var headPos = head.transform.position;

            float lookness = Vector3.Dot((headPos - handPos).normalized, -hand.palmTransform.forward);
            float distance = Vector3.Distance(headPos, hand.palmTransform.position);
            bool found = lookness >= anglePreciseness && distance < maxDistance && hand.holdingObj == null;

            if (!showing && found){
                OnShow?.Invoke(hand);
                showing = true;
            }
            else if(showing && !found){
                OnHide?.Invoke(hand);
                showing = false;
            }
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Hand/WristLookEvent.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Helpers/BoxColliderSerializationFixer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f628651c1a93e4f48909d4f9bf594f39
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BoxColliderSerializationFixer : MonoBehaviour
{
    //THIS SCRIPT SERVES TO FIX A SERIALIZATION BUG THAT OCCURS WHEN PACKAGING
    //A SCENE OR PREFAB WITH A BOX COLLIDER FROM 2023 OR HIGHER,
    //AND UNPACKING THAT SCENE ON A UNITY VERSION BEFORE 2022_2

    [System.Serializable]
    public struct ColliderData {
        public BoxCollider collider;
        public Vector3 size;
    }

    [SerializeField]
    private List<ColliderData> colliderSizes = new List<ColliderData>();

    [ContextMenu("Save Colliders")]
    public void SaveColliderSizes() {
        colliderSizes.Clear();
        SaveColliderSizesRecursive(transform);
    }

#if UNITY_2022_1_OR_NEWER
#else
    public void Start() {
        ApplyColliderSizesRecursive();
    }
#endif

    private void SaveColliderSizesRecursive(Transform currentTransform) {
        BoxCollider[] boxCollider = currentTransform.GetComponents<BoxCollider>();
        if(boxCollider != null && boxCollider.Length > 0) {
            for(int i = 0; i < boxCollider.Length; i++) {
                ColliderData data = new ColliderData {
                    size = boxCollider[i].size,
                    collider = boxCollider[i]
                };
                colliderSizes.Add(data);
            }
        }

        foreach(Transform child in currentTransform) {
            SaveColliderSizesRecursive(child);
        }
    }

    [ContextMenu("Apply Colliders")]
    public void ApplyColliderSizesRecursive() {
        //Debug.Log("Applying Collider  Resizes: This is a fix to a Unity Error where box collider sizes are not saved properly when downloading a scene from Unity 2022 or higher on a project from 2021 or lower. ");
        foreach(var collider in colliderSizes) {
            if(collider.collider != null)
                collider.collider.size = collider.size;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Helpers/BoxColliderSerializationFixer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Helpers/OnPlaceIgnoreHands.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 0edca2759cb852b4582e1c514cb91df8
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class OnPlaceIgnoreHands : MonoBehaviour {

        public PlacePoint placePoint;
        public Hand[] ignoreHands;

        void OnEnable() {
            placePoint.OnPlaceEvent += OnPlace;
            placePoint.OnRemoveEvent += OnRemove;
        }


        void OnDisable() {
            placePoint.OnPlaceEvent -= OnPlace;
            placePoint.OnRemoveEvent -= OnRemove;
        }

        void OnPlace(PlacePoint point, Grabbable grab) {
            foreach(var hand in ignoreHands)
                grab.IgnoreHand(hand, true, true);
        }

        void OnRemove(PlacePoint point, Grabbable grab) {
            foreach(var hand in ignoreHands) 
                grab.IgnoreHand(hand, false, true);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Helpers/OnPlaceIgnoreHands.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/DynamicTimestepSetter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 55b6f48a67da5af47997d327361ececb
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DynamicTimestepSetter : MonoBehaviour {

    public float slowestTimestep = 1 / 50f;
    public float fastestTimestep = 1 / 144f;

    float[] deltaTimeList = new float[10];
    Coroutine slowUpdateRounte = null;
    int id;

    private void OnEnable() {
        if(slowUpdateRounte != null)
            StopCoroutine(slowUpdateRounte);

        slowUpdateRounte = StartCoroutine(SlowUpdate());
        GameObject.DontDestroyOnLoad(gameObject);
    }

    private void OnDisable() {
        if(slowUpdateRounte != null)
            StopCoroutine(slowUpdateRounte);
    }

    IEnumerator SlowUpdate() {
        while(gameObject.activeInHierarchy) {

            deltaTimeList[id] = Time.deltaTime;
            id = (++id) % deltaTimeList.Length;
            Time.fixedDeltaTime = Mathf.Clamp(AverageDelta(), fastestTimestep, slowestTimestep);
            yield return new WaitForSecondsRealtime(0.02f);
        }

        slowUpdateRounte = null;
    }

    public float AverageDelta() {
        float averageVelocity = 0;
        if(deltaTimeList.Length > 0) {
            foreach(var deltaTime in deltaTimeList) {
                averageVelocity += deltaTime;
            }
            averageVelocity /= deltaTimeList.Length;
        }

        return averageVelocity;
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/DynamicTimestepSetter.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/EditorHand.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bf20b88b218211d4692fce1603f0cf60
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class EditorHand : MonoBehaviour {
        public bool useEditorGUI = true;
        public HandPoseDataContainer handPoseDataContainer;

        Hand _hand = null;
        public Hand hand {
            get {
                if(_hand == null)
                    _hand = GetComponent<Hand>();

                return _hand;
            }
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/EditorHand.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/GrabbableBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f3878a7d69c8ad44bbe220753bc94b7a
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;
using NaughtyAttributes;
using UnityEditor;
using UnityEngine.Serialization;

namespace Autohand {

    [DefaultExecutionOrder(-100)]
    public class GrabbableBase : MonoBehaviour {

        [AutoHeader("Grabbable")]
        public bool ignoreMe;

        [Tooltip("The physics body to connect this colliders grab to - if left empty will default to local body")]
        public Rigidbody body;

        [Tooltip("A copy of the mesh will be created and slighly scaled and this material will be applied to create a highlight effect with options")]
        public Material hightlightMaterial;

        [HideInInspector]
        public bool isGrabbable = true;


        private PlacePoint _placePoint = null;
        public PlacePoint placePoint { get { return _placePoint; } protected set { _placePoint = value; } }

        protected List<PlacePoint> _childPlacePoints = new List<PlacePoint>();
        public List<PlacePoint> childPlacePoints { get { return _childPlacePoints; } }


        internal List<Collider> _grabColliders = new List<Collider>();
        public List<Collider> grabColliders { get { return _grabColliders; } }


        internal Grabbable rootGrabbable;
        internal List<Grabbable> grabbableChildren = new List<Grabbable>();
        internal List<Grabbable> grabbableParents = new List<Grabbable>();
        internal List<Grabbable> jointedGrabbables = new List<Grabbable>();
        internal List<GrabbableChild> grabChildren = new List<GrabbableChild>();

        public float targetMass { get; protected set; }
        public float targetDrag { get; protected set; }
        public float targetAngularDrag { get; protected set; }



        protected Dictionary<Collider, PhysicsMaterial> grabColliderMaterials = new Dictionary<Collider, PhysicsMaterial>();
        protected Dictionary<Transform, int> originalLayers = new Dictionary<Transform, int>();

        private List<Hand> _heldBy = new List<Hand>();
        public List<Hand> heldBy {
            get { return _heldBy; }
        }

        private List<Hand> _beingGrabbedBy = new List<Hand>();
        public List<Hand> beingGrabbedBy {
            get { return _beingGrabbedBy; }
        }

        protected List<Hand> waitingToGrabHands = new List<Hand>();

        protected bool hightlighting;
        protected GameObject highlightObj;
        protected PlacePoint lastPlacePoint = null;

        public Transform originalParent { get; set; }
        protected Vector3 lastCenterOfMassPos;
        protected Quaternion lastCenterOfMassRot;
        protected CollisionDetectionMode detectionMode;
        protected RigidbodyInterpolation startInterpolation;

        public bool beingGrabbed { get; protected internal set; }
        internal bool beforeGrabFrame { get; set; }
        protected bool wasIsGrabbable = false;
        protected bool beingDestroyed = false;
        protected Dictionary<Hand, Coroutine> resetLayerRoutine = new Dictionary<Hand, Coroutine>();
        protected Dictionary<Hand, Coroutine> ignoreWhileGrabbingRoutine = new Dictionary<Hand, Coroutine>();
        protected List<Transform> jointedParents = new List<Transform>();
        protected Dictionary<Material, List<GameObject>> highlightObjs = new Dictionary<Material, List<GameObject>>();

        protected GrabbablePoseCombiner poseCombiner;
        protected float lastUpdateTime;

        protected bool rigidbodyDeactivated = false;
        protected SaveRigidbodyData rigidbodyData;

        /// <summary>This transform represents the root rigidbody gameobject. This is used in place a rigidbody call just in case the rigidbody is disabled</summary>
        public Transform rootTransform {
            get {
                if(body != null)
                    return body.transform;
                else if(rigidbodyData.IsSet())
                    return rigidbodyData.GetOrigin();
                else if(gameObject.CanGetComponent<Rigidbody>(out var rigidbody))
                    return rigidbody.transform;
                else if(gameObject.GetComponentInParent<Rigidbody>() != null)
                    return gameObject.GetComponentInParent<Rigidbody>().transform;
                else
                    return null;
            }
        }


        private CollisionTracker _collisionTracker;
        public CollisionTracker collisionTracker {
            get {
                if(_collisionTracker == null) {
                    if(!(_collisionTracker = GetComponent<CollisionTracker>())) {
                        _collisionTracker = gameObject.AddComponent<CollisionTracker>();
                        _collisionTracker.disableTriggersTracking = true;
                    }
                }
                return _collisionTracker;
            }
            protected set {
                if(_collisionTracker != null)
                    Destroy(_collisionTracker);

                _collisionTracker = value;
            }
        }

#if UNITY_EDITOR
        protected bool editorSelected = false;
#endif

        public virtual void Awake() {
            if(!gameObject.CanGetComponent(out poseCombiner))
                poseCombiner = gameObject.AddComponent<GrabbablePoseCombiner>();

            GetPoseSaves(transform);

            void GetPoseSaves(Transform obj) {
                if(obj.CanGetComponent(out Grabbable grab) && grab != this)
                    return;

                var poses = obj.GetComponents<GrabbablePose>();
                for(int i = 0; i < poses.Length; i++) {
                    poseCombiner.AddPose(poses[i]);
                    poses[i].grabbable = (this as Grabbable);
                }

                for(int i = 0; i < obj.childCount; i++)
                    GetPoseSaves(obj.GetChild(i));
            }

            if(body == null) {
                if(GetComponent<Rigidbody>())
                    body = GetComponent<Rigidbody>();
                else
                    Debug.LogError("RIGIDBODY MISSING FROM GRABBABLE: " + transform.name + " \nPlease add/attach a rigidbody", this);
            }

#if UNITY_EDITOR
            if(Selection.activeGameObject == gameObject) {
                Selection.activeGameObject = null;
                Debug.Log("Auto Hand (EDITOR ONLY): Selecting the grabbable in the inspector can cause lag and quality reduction at runtime. (Automatically deselecting at runtime) Remove this code at any time.", this);
                editorSelected = true;
            }

            Application.quitting += () => { if(editorSelected) Selection.activeGameObject = gameObject; };
#endif

            originalParent = body.transform.parent;
            detectionMode = body.collisionDetectionMode;
            startInterpolation = body.interpolation;
            UpdateGrabbableColliderSettings();
            UpdateGrabbableRigidbodySettings(body.linearDamping, body.angularDamping, body.mass);
        }


        private void OnDestroy() {
            beingDestroyed = true;
        }

        public virtual void HeldFixedUpdate() {
            if(heldBy.Count > 0) {
                lastCenterOfMassRot = body.transform.rotation;
                lastCenterOfMassPos = body.transform.position;
            }

        }

        protected virtual void OnDisable() {
            foreach(var routine in resetLayerRoutine) {
                IgnoreHand(routine.Key, false);
                if(routine.Value != null)
                    StopCoroutine(routine.Value);
            }
            resetLayerRoutine.Clear();

            foreach(var routine in ignoreGrabbableCollisions) {
                if(routine.Value != null)
                    StopCoroutine(routine.Value);
            }
            ignoreGrabbableCollisions.Clear();

            foreach(var routine in ignoreHandCollisions) {
                if(routine.Value != null)
                    StopCoroutine(routine.Value);
            }
            ignoreHandCollisions.Clear();

        }


        public void SetPlacePoint(PlacePoint point) {
            this.placePoint = point;

            foreach(var grabbable in grabbableChildren) {
                grabbable.placePoint = point;
            }
        }

        public void SetGrabbableChild(GrabbableChild child) {
            child.grabParent = this as Grabbable;
            if(!grabChildren.Contains(child))
                grabChildren.Add(child);
        }


        public void DeactivateRigidbody() {
            if(body != null) {
                if(body != null)
                    rigidbodyData = new SaveRigidbodyData(body);

                body = null;
                rigidbodyDeactivated = true;
            }

            foreach(var grabbable in grabbableChildren) {
                if(grabbable.body != null) {
                    grabbable.body = null;
                    grabbable.rigidbodyData = new SaveRigidbodyData(rigidbodyData);
                    grabbable.rigidbodyDeactivated = true;
                }
            }
        }


        public void ActivateRigidbody() {
            if(rigidbodyDeactivated && !beingDestroyed) {
                rigidbodyDeactivated = false;
                body = rigidbodyData.ReloadRigidbody();

                foreach(var grabbable in grabbableChildren) {
                    grabbable.rigidbodyDeactivated = false;
                    if(grabbable.body == null)
                        grabbable.body = body;
                }
            }
        }



        protected internal void SetLayerRecursive(int newLayer) {
            foreach(var transform in originalLayers) {
                transform.Key.gameObject.layer = newLayer;
            }
        }

        /// <summary>Sets the grabbable and children to the physics layers it had on Start()</summary>
        protected internal void ResetOriginalLayers() {
            foreach(var transform in originalLayers) {
                transform.Key.gameObject.layer = transform.Value;
            }
        }


        Dictionary<Grabbable, Coroutine> ignoreGrabbableCollisions = new Dictionary<Grabbable, Coroutine>();
        public void IgnoreGrabbableCollisionUntilNone(Grabbable other) {
            if(!beingDestroyed && !ignoreGrabbableCollisions.ContainsKey(other))
                ignoreGrabbableCollisions.Add(other, StartCoroutine(IgnoreGrabbableCollisionUntilNoneRoutine(other)));
        }

        protected IEnumerator IgnoreGrabbableCollisionUntilNoneRoutine(Grabbable other) {
            IgnoreGrabbableColliders(other, true);

            yield return new WaitForSeconds(0.05f);
            while(IsGrabbableOverlapping(other))
                yield return new WaitForSeconds(0.1f);

            IgnoreGrabbableColliders(other, false);
            ignoreGrabbableCollisions.Remove(other);

            if(ignoreGrabbableCollisions.ContainsKey(other))
                ignoreGrabbableCollisions.Remove(other);

        }

        public bool IsGrabbableOverlapping(Grabbable other) {
            foreach(var col1 in grabColliders) {
                foreach(var col2 in other.grabColliders) {
                    if(col1.enabled && !col1.isTrigger && !col1.isTrigger && col2.enabled && !col2.isTrigger && !col2.isTrigger &&
                        Physics.ComputePenetration(col1, col1.transform.position, col1.transform.rotation, col2, col2.transform.position, col2.transform.rotation, out _, out _)) {
                        return true;
                    }
                }
            }

            return false;
        }

        public void IgnoreGrabbableColliders(Grabbable other, bool ignore) {
            foreach(var col1 in grabColliders) {
                foreach(var col2 in other.grabColliders) {
                    Physics.IgnoreCollision(col1, col2, ignore);
                }
            }
        }




        Dictionary<Hand, Coroutine> ignoreHandCollisions = new Dictionary<Hand, Coroutine>();
        public void IgnoreHandCollisionUntilNone(Hand hand, float minIgnoreTime = 1) {
            if(gameObject.activeInHierarchy && !beingDestroyed && !ignoreHandCollisions.ContainsKey(hand))
                ignoreHandCollisions.Add(hand, StartCoroutine(IgnoreHandCollisionUntilNoneRoutine(hand, minIgnoreTime)));
        }

        protected IEnumerator IgnoreHandCollisionUntilNoneRoutine(Hand hand, float minIgnoreTime) {
            if(!ignoringHand.ContainsKey(hand) || !ignoringHand[hand]) {
                IgnoreHand(hand, true);

                yield return new WaitForSeconds(minIgnoreTime);
                if(minIgnoreTime != 0)
                    while(IsHandOverlapping(hand))
                        yield return new WaitForSeconds(0.1f);

                IgnoreHand(hand, false);
                if(resetLayerRoutine.ContainsKey(hand))
                    resetLayerRoutine.Remove(hand);
                if(ignoreHandCollisions.ContainsKey(hand))
                    ignoreHandCollisions.Remove(hand);
            }
        }


        protected IEnumerator IgnoreHandCollision(Hand hand, float time) {
            if(!ignoringHand.ContainsKey(hand) || !ignoringHand[hand]) {
                IgnoreHand(hand, true);

                yield return new WaitForSeconds(time);

                IgnoreHand(hand, false);
                resetLayerRoutine.Remove(hand);
            }
        }

        protected Dictionary<Hand, bool> ignoringHand = new Dictionary<Hand, bool>();
        public void IgnoreHand(Hand hand, bool ignore, bool overrideIgnoreRoutines = false) {
            if(overrideIgnoreRoutines && resetLayerRoutine.ContainsKey(hand) && resetLayerRoutine[hand] != null) {
                StopCoroutine(resetLayerRoutine[hand]);
                resetLayerRoutine[hand] = null;
            }

            foreach(var col in grabColliders)
                hand.HandIgnoreCollider(col, ignore);

            foreach(var grab in grabbableChildren)
                foreach(var col in grab.grabColliders)
                    hand.HandIgnoreCollider(col, ignore);

            foreach(var grab in grabbableParents)
                foreach(var col in grab.grabColliders)
                    hand.HandIgnoreCollider(col, ignore);

            if(!ignoringHand.ContainsKey(hand))
                ignoringHand.Add(hand, ignore);
            else
                ignoringHand[hand] = ignore;
        }


        public bool IsHandOverlapping(Hand hand) {
            float dist;
            Vector3 dir;
            foreach(var col2 in grabColliders) {
                foreach(var col1 in hand.handColliders) {
                    if(col1.enabled && !col1.isTrigger && !col1.isTrigger && col2.enabled && !col2.isTrigger && !col2.isTrigger &&
                    Physics.ComputePenetration(col1, col1.transform.position, col1.transform.rotation, col2, col2.transform.position, col2.transform.rotation, out dir, out dist)) {
                        return true;
                    }
                }
            }

            return false;
        }








        public bool GetSavedPose(out GrabbablePoseCombiner pose) {
            if(poseCombiner != null && poseCombiner.PoseCount() > 0) {
                pose = poseCombiner;
                return true;
            }
            else {
                pose = null;
                return false;
            }
        }

        public bool HasCustomPose() {
            return poseCombiner.PoseCount() > 0;
        }


        /// <summary>Resets the physics materials on all the colliders to the given physics material</summary>
        public void SetPhysicsMaterial(PhysicsMaterial physMat) {
            foreach(var collider in grabColliders) {
                collider.material = physMat;
            }
        }

        /// <summary>Resets the physics materials on all the colliders to how it was during last UpdateGrabbableColliderSettings()</summary>
        public void ResetPhysicsMateiral() {
            foreach(var col in grabColliderMaterials)
                col.Key.sharedMaterial = col.Value;
        }


        /// <summary> Saves the grabbables target collider settings to be whatever the current collider settings are. DO NOT CALL THIS WHILE THE GRABBABLE IS HELD </summary>
        public void UpdateGrabbableColliderSettings() {
            grabColliders.Clear();
            grabColliderMaterials.Clear();
            originalLayers.Clear();

            var colliders = body.GetComponentsInChildren<Collider>();
            foreach(var col in colliders) {
                if(col.isTrigger)
                    continue;

                grabColliders.Add(col);
                if(col.sharedMaterial == null)
                    grabColliderMaterials.Add(col, null);
                else
                    grabColliderMaterials.Add(col, col.sharedMaterial);

                if(!originalLayers.ContainsKey(col.transform)) {
                    if(col.gameObject.layer == LayerMask.NameToLayer("Default") || LayerMask.LayerToName(col.gameObject.layer) == "")
                        col.gameObject.layer = LayerMask.NameToLayer(Hand.grabbableLayerNameDefault);
                    originalLayers.Add(col.transform, col.gameObject.layer);
                }
            }
        }


        /// <summary>Sets the grabbables rigidbody settigns and target settings when not held</summary>
        public void UpdateGrabbableRigidbodySettings(float drag, float angularDrag, float mass) {
            targetAngularDrag = angularDrag;
            targetDrag = drag;
            targetMass = mass;

            if(body != null && (this as Grabbable).HeldCount() == 0) {
                body.linearDamping = drag;
                body.angularDamping = angularDrag;
                body.mass = mass;
            }
    }


        /// <summary>Adds a grabbables collider to this list of colliders on this grabbable, REMOVE_GRABBABLE_COLLIDERS() MUST BE CALLED</summary>
        public void AddGrabbableColliders(Grabbable other) {
            var ignoreHandKeys = new List<Hand>(ignoreHandCollisions.Keys);
            foreach(var col in other.grabColliders) {
                if(!grabColliders.Contains(col)) {
                    grabColliders.Add(col);
                    for(int i = 0; i < ignoreHandKeys.Count; i++)
                        ignoreHandKeys[i].HandIgnoreCollider(col, true);
                }
            }
        }

        public void RemoveGrabbableColliders(Grabbable other) {
            var ignoreHandKeys = new List<Hand>(ignoreHandCollisions.Keys);
            foreach(var col in other.grabColliders) {
                if(grabColliders.Contains(col)) {
                    grabColliders.Remove(col);
                    for(int i = 0; i < ignoreHandKeys.Count; i++)
                        ignoreHandKeys[i].HandIgnoreCollider(col, false);
                }
            }
        }




        public bool BeingDestroyed() {
            return beingDestroyed;
        }

        public void DebugBreak() {
#if UNITY_EDITOR
            Debug.Break();
#endif
        }


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/GrabbableBase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandAnimator.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 098d5f45d7e666742b7295b5ab142cee
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    [RequireComponent(typeof(Hand)), DefaultExecutionOrder(10000)]
    public class HandAnimator : MonoBehaviour {
        Hand hand;

        public float defaultPoseTransitionTime = 0.3f;
        public AnimationCurve defaultPoseTransitionCurve = AnimationCurve.Linear(0, 0, 1, 1);
        public HandPoseArea currentPoseArea { get; protected set; }



        HandPoseData _handPoseDataNonAlloc;
        internal ref HandPoseData handPoseDataNonAlloc {
            get {
                if(!_handPoseDataNonAlloc.isSet)
                    _handPoseDataNonAlloc = new HandPoseData(hand);

                return ref _handPoseDataNonAlloc;
            }
        }


        HandPoseData _openHandPose;
        public ref HandPoseData openHandPose {
            get {
                if(!_openHandPose.isSet)
                    _openHandPose = new HandPoseData(hand);

                return ref _openHandPose;
            }
        }


        HandPoseData _closeHandPose;
        public ref HandPoseData closeHandPose {
            get {
                if(!_closeHandPose.isSet)
                    _closeHandPose = new HandPoseData(hand);

                return ref _closeHandPose;
            }
        }

        HandPoseData _targetGrabPose;
        public ref HandPoseData targetGrabPose {
            get {
                if(!_targetGrabPose.isSet)
                    _targetGrabPose = new HandPoseData(hand);

                return ref _targetGrabPose;
            }
        }

        HandPoseData _currentInputPose;
        public ref HandPoseData currentInputPose {
            get {
                if(!_currentInputPose.isSet)
                    _currentInputPose = new HandPoseData(hand);

                return ref _currentInputPose;
            }
        }


        float targetPoseStartTransitionTime = 0;
        float targetPoseStopTransitionTime = 0;
        float targetPoseTotalTransitionTime = 0;
        AnimationCurve targetTransitionAnimationCurve = null;
        bool poseActive = false;
        HandPoseData _currentTargetPose;
        public ref HandPoseData currentTargetPose {
            get {
                if(!_currentTargetPose.isSet)
                    _currentTargetPose = new HandPoseData(hand);

                return ref _currentTargetPose;
            }
        }




        HandPoseData _currentHandPose;
        public ref HandPoseData currentHandPose {
            get {
                if(!_currentHandPose.isSet)
                    _currentHandPose = new HandPoseData(hand);

                return ref _currentHandPose;
            }
        }

        HandPoseData _currentHandSmoothPose;
        public ref HandPoseData currentHandSmoothPose {
            get {
                if(!_currentHandSmoothPose.isSet)
                    _currentHandSmoothPose = new HandPoseData(hand);

                return ref _currentHandSmoothPose;
            }
        }



        float fingerSwayVel;


        public void Start() {
            for(int i = 0; i < hand.fingers.Length; i++) {
                Finger finger = hand.fingers[i];
                int fingerIndex = (int)finger.fingerType;
                openHandPose.fingerPoses[fingerIndex].CopyFromData(ref finger.poseData[(int)FingerPoseEnum.Open]);
                closeHandPose.fingerPoses[fingerIndex].CopyFromData(ref finger.poseData[(int)FingerPoseEnum.Closed]);
            }

            if(defaultPoseTransitionCurve == null || defaultPoseTransitionCurve.keys.Length == 0)
                defaultPoseTransitionCurve = AnimationCurve.Linear(0, 0, 1, 1);

            targetTransitionAnimationCurve = defaultPoseTransitionCurve;
        }

        protected virtual void OnEnable() {
            hand = GetComponent<Hand>();
            hand.collisionTracker.OnTriggerFirstEnter += OnTriggerFirstEnter;
            hand.collisionTracker.OnTriggerLastExit += OnTriggerLastExit;
        }

        protected virtual void OnDisable() {
            hand.collisionTracker.OnTriggerFirstEnter -= OnTriggerFirstEnter;
            hand.collisionTracker.OnTriggerLastExit -= OnTriggerLastExit;
        }


        protected virtual void LateUpdate() {
            if(hand.enableIK) {
                UpdateInputPoseState();
                UpdateTargetPoseState();
            }
        }

        /// <summary>Determines how the hand should look/move based on its flags</summary>
        protected virtual void UpdateTargetPoseState() {
            float currentPoseState;
            if(poseActive)
                currentPoseState = targetTransitionAnimationCurve.Evaluate(Mathf.Clamp01((Time.time - targetPoseStartTransitionTime) / targetPoseTotalTransitionTime));
            else
                currentPoseState = targetTransitionAnimationCurve.Evaluate(1f - Mathf.Clamp01((Time.time - targetPoseStopTransitionTime) / targetPoseTotalTransitionTime));


            if(currentPoseState < 1f)
                currentHandPose.LerpPose(ref currentInputPose, ref currentTargetPose, currentPoseState);
            else if(poseActive)
                currentHandPose.CopyFromData(ref currentTargetPose);
            else
                currentHandPose.CopyFromData(ref currentInputPose);


            currentHandSmoothPose.LerpPose(ref currentHandSmoothPose, ref currentHandPose, 0.33f);
            if(!hand.IsGrabbing())
                currentHandSmoothPose.SetFingerPose(hand);
        }



        /// <summary>Determines how the hand should look/move based on its flags</summary>
        protected virtual void UpdateInputPoseState() {
            var averageVel = Vector3.zero;
            for(int i = 1; i < hand.handFollow.updatePositionTracked.Length; i++)
                averageVel += hand.handFollow.updatePositionTracked[i] - hand.handFollow.updatePositionTracked[i - 1];
            averageVel /= hand.handFollow.updatePositionTracked.Length;

            if(transform.parent != null)
                averageVel = (Quaternion.Inverse(hand.palmTransform.rotation) * transform.parent.rotation) * averageVel;


            //Responsable for movement finger sway
            float vel = (averageVel * 60).z;

            if(hand.CollisionCount() > 0) vel = 0;
            fingerSwayVel = Mathf.MoveTowards(fingerSwayVel, vel, Time.deltaTime * (Mathf.Abs((fingerSwayVel - vel) * 30f)));

            float grip = hand.gripOffset + hand.swayStrength * fingerSwayVel;
            foreach(var finger in hand.fingers) {
                int fingerIndex = (int)finger.fingerType;
                currentInputPose.fingerPoses[fingerIndex].LerpData(ref openHandPose.fingerPoses[fingerIndex], ref closeHandPose.fingerPoses[fingerIndex], grip + finger.GetCurrentBend());
            }
        }
        protected virtual void OnTriggerFirstEnter(GameObject other) {
            CheckEnterPoseArea(other);
        }

        protected virtual void OnTriggerLastExit(GameObject other) {
            CheckExitPoseArea(other);
        }



        /// <summary>Takes a new pose and an amount of time and poses the hand</summary>
        public virtual void SetTargetPose(ref HandPoseData poseData, float transitionTime, AnimationCurve animationCurve) {
            targetTransitionAnimationCurve = animationCurve;
            targetPoseTotalTransitionTime = transitionTime;
            targetPoseStartTransitionTime = Time.time;
            this.poseActive = true;
            currentTargetPose.CopyFromData(ref poseData);
            if(transitionTime == 0)
                currentHandPose.CopyFromData(ref poseData);
        }



        /// <summary>Takes a new pose and an amount of time and poses the hand</summary>
        public void SetPose(ref HandPoseData pose, float transitionTime, AnimationCurve animationCurve) => SetTargetPose(ref pose, transitionTime, animationCurve);
        public void SetPose(ref HandPoseData pose, float transitionTime) => SetTargetPose(ref pose, transitionTime, defaultPoseTransitionCurve);
        public void SetPose(ref HandPoseData pose) => SetTargetPose(ref pose, defaultPoseTransitionTime, defaultPoseTransitionCurve);


        /// <summary>Returns the current hand pose, ignoring what is being held - (IF SAVING A HELD POSE USE GetHeldPose())</summary>
        public ref HandPoseData GetCurrentHandPose() => ref currentHandPose;


        /// <summary>Copies the current hand pose to the given handPose, ignoring what is being held - (IF SAVING A HELD POSE USE GetHeldPose())</summary>
        public void CopyHandData(ref HandPoseData handPose) {
            if(!handPose.isSet)
                handPose = new HandPoseData(ref currentHandPose);
            else
                handPose.CopyFromData(ref currentHandPose);
        }


        /// <summary>Ensures any pose being made is canceled</summary>
        public void CancelPose(float cancelPoseTransitionTime) {
            targetPoseTotalTransitionTime = cancelPoseTransitionTime;
            targetPoseStopTransitionTime = Time.time;
            poseActive = false;
        }

        public void CancelPose() => CancelPose(defaultPoseTransitionTime);









        /// <summary>Checks and manages if any of the hands colliders enter a pose area</summary>
        protected virtual void CheckEnterPoseArea(GameObject other) {
            if(hand.holdingObj || !hand.usingPoseAreas || !other.activeInHierarchy)
                return;

            if(other && other.CanGetComponent(out HandPoseArea tempPose)) {
                for(int i = 0; i < tempPose.poseAreas.Length; i++) {
                    if(tempPose.poseIndex == hand.poseIndex) {
                        if(tempPose.HasPose(hand.left) && (currentPoseArea == null || currentPoseArea != tempPose)){
                            if(currentPoseArea != null)
                                TryRemoveHandPoseArea(currentPoseArea);

                            currentPoseArea = tempPose;
                            currentPoseArea?.OnHandEnter?.Invoke(hand);
                            if(hand.holdingObj == null)
                                SetPose(ref currentPoseArea.GetHandPoseData(hand.left), currentPoseArea.transitionTime);
                        }

                        break;
                    }
                }
            }
        }


        /// <summary>Checks if manages any of the hands colliders exit a pose area</summary>
        protected virtual void CheckExitPoseArea(GameObject other) {
            if(!hand.usingPoseAreas || !other.gameObject.activeInHierarchy)
                return;

            if(other.CanGetComponent(out HandPoseArea poseArea))
                TryRemoveHandPoseArea(poseArea);
        }

        public void TryRemoveHandPoseArea(HandPoseArea poseArea) {
            if(this.currentPoseArea != null && this.currentPoseArea.gameObject.Equals(poseArea.gameObject)) {
                if(hand.holdingObj == null) {
                    CancelPose();
                    this.currentPoseArea?.OnHandExit?.Invoke(hand);
                    this.currentPoseArea = null;
                }
                else if(hand.holdingObj != null) {
                    this.currentPoseArea?.OnHandExit?.Invoke(hand);
                    this.currentPoseArea = null;
                }
            }
        }

        public void ClearPoseArea() {
            if(currentPoseArea != null)
                currentPoseArea.OnHandExit?.Invoke(hand);
            currentPoseArea = null;
        }



        /// <returns>Returns true if that hand is currently locked into a pose</returns>
        public bool IsPosing() {
            return currentPoseArea != null || (hand.holdingObj != null && hand.holdingObj.HasCustomPose()) || (Time.time - targetPoseStartTransitionTime < targetPoseTotalTransitionTime) || poseActive;
        }
        


    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandAnimator.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandBase.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: e726604bfeafa1540ab696f8d739d797
# ASMDEF: AutoHandAssembly.dll
# ---
using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Serialization;
using UnityEngine.UIElements;

namespace Autohand {

    /// <summary>
    /// 
    /// </summary>
    public enum HandMovementType {
        /// <summary>Movement method for Auto Hand V2 and below</summary>
        Legacy,
        /// <summary>Uses physics forces</summary>
        Forces
    }

    public enum HandType {
        both,
        right,
        left,
        none
    }

    public enum GrabType {
        /// <summary>On grab, hand will move to the grabbable, create grab connection, then return to follow position</summary>
        HandToGrabbable,
        /// <summary>On grab, grabbable will move to the hand, then create grab connection</summary>
        GrabbableToHand,
        /// <summary>On grab, grabbable instantly travel to the hand</summary>
        InstantGrab
    }

    [Serializable]
    public struct VelocityTimePair {
        public float time;
        public Vector3 velocity;
    }

    public delegate void HandGrabEvent(Hand hand, Grabbable grabbable);
    public delegate void HandGameObjectEvent(Hand hand, GameObject other);

    [Serializable]  public class UnityHandGrabEvent : UnityEvent<Hand, Grabbable> { }
    [Serializable] public class UnityHandEvent : UnityEvent<Hand> { }



    [RequireComponent(typeof(Rigidbody)), RequireComponent(typeof(HandFollow)), RequireComponent(typeof(HandAnimator)), RequireComponent(typeof(HandGrabbableHighlighter)), DefaultExecutionOrder(10)]
    /// <summary>This is the base of the Auto Hand hand class, used for organizational purposes</summary>
    public class HandBase : MonoBehaviour {


        [AutoHeader("AUTO HAND")]
        public bool ignoreMe;

        public Finger[] fingers;

        [Tooltip("An empty GameObject that should be placed on the surface of the center of the palm")]
        public Transform palmTransform;
        [Tooltip("An empty GameObject that should be placed on the surface of the center of pinch point")]
        public Transform pinchPointTransform;

        [FormerlySerializedAs("isLeft")]
        [Tooltip("Whether this is the left (on) or right (off) hand")]
        public bool left = false;


        [Space]
        [Tooltip("Maximum distance for pickup"), Min(0.01f)]
        public float reachDistance = 0.2f;


        [AutoToggleHeader("Enable Movement", 0, 0, tooltip = "Whether or not to enable the hand's Rigidbody Physics movement")]
        public bool enableMovement = true;

        [EnableIf("enableMovement"), Tooltip("Follow target, the hand will always try to match this transforms position with rigidbody movements")]
        public Transform follow;

        [EnableIf("enableMovement"), Tooltip("Amplifier for applied velocity on released object"), Min(0)]
        public float throwPower = 1.25f;

        [Tooltip("Speed at which the gentle grab returns the grabbable"), Min(0)]
        [FormerlySerializedAs("smoothReturnSpeed")]
        public float gentleGrabSpeed = 1;

        [HideInInspector]
        public bool advancedFollowSettings = true;

        [AutoToggleHeader("Enable Auto Posing", 0, 0, tooltip = "Auto Posing will override Unity Animations -- This will disable all the Auto Hand IK, including animations from: finger sway, pose areas, finger bender scripts (runtime Auto Posing will still work)")]
        [Tooltip("Turn this on when you want to animate the hand or use other IK Drivers")]
        public bool enableIK = true;

        [EnableIf("enableIK"), Tooltip("How much the fingers sway from the velocity")]
        public float swayStrength = 0.4f;

        [EnableIf("enableIK"), Tooltip("This will offset each fingers bend (0 is no bend, 1 is full bend)")]
        public float gripOffset = 0.14f;



        [HideInInspector, NonSerialized, Tooltip("After this many seconds velocity data within a 'throw window' will be tossed out. (This allows you to get only use acceeleration data from the last 'x' seconds of the throw.)")]
        public float throwVelocityExpireTime = 0.125f;
        [HideInInspector, NonSerialized, Tooltip("After this many seconds velocity data within a 'throw window' will be tossed out. (This allows you to get only use acceeleration data from the last 'x' seconds of the throw.)")]
        public float throwAngularVelocityExpireTime = 0.25f;

        [HideInInspector, NonSerialized, Tooltip("Increase for closer finger tip results / Decrease for less physics checks - The number of steps the fingers take when bending to grab something")]
        public int fingerBendSteps = 40;

        [HideInInspector]
        public bool usingPoseAreas = true;

        [HideInInspector]
        public QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.Ignore;




        HandFollow _handFollow;
        public HandFollow handFollow {
            get {
                if(_handFollow == null)
                    _handFollow = GetComponent<HandFollow>();

                return _handFollow;
            }
        }


        HandAnimator _handAnimator;
        public HandAnimator handAnimator {
            get {
                if(_handAnimator == null)
                    _handAnimator = GetComponent<HandAnimator>();

                return _handAnimator;
            }
        }


        HandGrabbableHighlighter _highlighter;
        public HandGrabbableHighlighter highlighter {
            get {
                if(_highlighter == null)
                    _highlighter = GetComponent<HandGrabbableHighlighter>();

                return _highlighter;
            }
        }


        private CollisionTracker _collisionTracker;
        public CollisionTracker collisionTracker {
            get {
                if(_collisionTracker == null)
                    _collisionTracker = gameObject.AddComponent<CollisionTracker>();
                return _collisionTracker;
            }
            protected set {
                if(_collisionTracker != null)
                    Destroy(_collisionTracker);

                _collisionTracker = value;
            }
        }


        public HandVelocityTracker velocityTracker {
            get; protected set;
        }


        Rigidbody _body;
        public Rigidbody body { 
            get{
                if(_body == null)
                    _body = GetComponent<Rigidbody>();

                return _body;
            }
            internal set { _body = body; } 
        }

        public Transform moveTo {
            get {
                return handFollow.moveTo;
            }
        }


        Grabbable HoldingObj = null;
        public Grabbable holdingObj {
            get { return HoldingObj; }
            internal set { HoldingObj = value; }
        }


        protected GrabbablePose _currentHeldPose;
        public GrabbablePose currentHeldPose {
            get {
                return _currentHeldPose;
            }
    
            internal set {
                if(value == null && _currentHeldPose != null)
                    _currentHeldPose.CancelHandPose(this as Hand);

                _currentHeldPose = value;
            }
        }


        Transform _handGrabPoint;
        /// <summary>This is a transform the represents where the held hand is relative to the object in local space</summary>
        public Transform handGrabPoint {
            get {
                if(_handGrabPoint == null && gameObject.scene.isLoaded) {
                    _handGrabPoint = new GameObject().transform;
                    _handGrabPoint.name = "grabPoint";
                }
                return _handGrabPoint;
            }
        }


        Transform _localGrabbablePoint;
        /// <summary>This is a transform the represents where the held object should be relative to the hand in local space</summary>
        public Transform localGrabbablePoint {
            get {
                if(!gameObject.activeInHierarchy)
                    _localGrabbablePoint = null;
                else if(gameObject.activeInHierarchy && _localGrabbablePoint == null) {
                    _localGrabbablePoint = new GameObject().transform;
                    _localGrabbablePoint.name = "grabPosition";
                    _localGrabbablePoint.parent = transform;
                }


                return _localGrabbablePoint;
            }
        }



        Vector3 _grabPositionOffset = Vector3.zero;
        public Vector3 grabPositionOffset {
            get { return _grabPositionOffset; }
            set { _grabPositionOffset = value; }
        }

        Quaternion _grabRotationOffset = Quaternion.identity;
        public Quaternion grabRotationOffset {
            get { return _grabRotationOffset; }
            set { _grabRotationOffset = value; }
        }




        [HideInInspector, NonSerialized]
        public ConfigurableJoint heldJoint;

        public bool grabbing { get; protected set; }
        public bool squeezing { get; protected set; }

        protected float gripAxis;
        protected float squeezeAxis;
        
        internal List<Collider> handColliders = new List<Collider>();

        internal float lastGrabTime = 0;
        internal float lastReleaseTime = 0;


        BoxCollider _handEncapsulationCollider;
        internal BoxCollider handEncapsulationBox {
            get {
                if(!gameObject.activeInHierarchy)
                    _handEncapsulationCollider = null;
                else if(gameObject.activeInHierarchy && _handEncapsulationCollider == null) {
                    _handEncapsulationCollider = new GameObject().AddComponent<BoxCollider>();
                    _handEncapsulationCollider.name = "handEncapsulationBox";
                    _handEncapsulationCollider.transform.parent = transform;
                    _handEncapsulationCollider.transform.localPosition = Vector3.zero;
                    _handEncapsulationCollider.transform.localRotation = Quaternion.identity;
                    _handEncapsulationCollider.transform.localScale = Vector3.one;
                    _handEncapsulationCollider.isTrigger = true;
                    _handEncapsulationCollider.enabled = false;
                }

                return _handEncapsulationCollider;
            }
        }

        internal int handLayers;
        internal int handIgnoreCollisionLayers;

        protected Transform palmChild;
        protected Collider palmCollider;
        protected RaycastHit grabbingHit;

        protected int noCollisionFrames = 0;
        protected int collisionFrames = 0;

        protected bool prerendered = false;
        protected Vector3 preRenderPos;
        protected Quaternion preRenderRot;

        protected virtual void Awake() {
            body = GetComponent<Rigidbody>();
            body.interpolation = RigidbodyInterpolation.None;
            body.useGravity = false;

            body.solverIterations = 100;
            body.solverVelocityIterations = 100;

            if(palmCollider == null) {
                palmCollider = palmTransform.gameObject.AddComponent<BoxCollider>();
                (palmCollider as BoxCollider).size = new Vector3(0.2f, 0.15f, 0.05f);
                (palmCollider as BoxCollider).center = new Vector3(0f, 0f, -0.025f);
                palmCollider.enabled = false;
            }

            if(palmChild == null) {
                palmChild = new GameObject().transform;
                palmChild.parent = palmTransform;
            }

            var cams = AutoHandExtensions.CanFindObjectsOfType<Camera>(true);
            foreach(var cam in cams) {
                if(cam.targetDisplay == 0) {
                    bool found = false;
                    var handStabilizers = cam.gameObject.GetComponents<HandStabilizer>();
                    foreach(var handStabilizer in handStabilizers) {
                        if(handStabilizer.hand == this)
                            found = true;
                    }
                    if(!found)
                        cam.gameObject.AddComponent<HandStabilizer>().hand = this;
                }
            }
            
            if(velocityTracker == null)
                velocityTracker = new HandVelocityTracker(this);


            if(AutoHandSettings.UsingDynamicTimestep()) {
                if(AutoHandExtensions.CanFindObjectOfType<DynamicTimestepSetter>() == null) {
                    new GameObject() { name = "DynamicFixedTimeSetter" }.AddComponent<DynamicTimestepSetter>();
                    Debug.Log("AUTO HAND: Creating Dynamic Timestepper");
                }
            }


            //Update the hand encapsulation sphere
            var bounds = new Bounds(Vector3.zero, Vector3.zero);
            foreach(var finger in fingers) {
                var fingerJoints = finger.FingerJoints;
                for(int i = 0; i < fingerJoints.Length; i++)
                    bounds.Encapsulate(transform.InverseTransformPoint(fingerJoints[i].position));
                bounds.Encapsulate(transform.InverseTransformPoint(finger.tip.position + (finger.tip.position - transform.position)*finger.tipRadius));
            }

            bounds.Encapsulate(transform.InverseTransformPoint(palmTransform.position + palmTransform.forward*0.01f));
            bounds.Encapsulate(transform.InverseTransformPoint(palmTransform.position - palmTransform.forward*0.01f));

            handEncapsulationBox.center = bounds.center;
            handEncapsulationBox.size = bounds.size;
            handEncapsulationBox.gameObject.layer = LayerMask.NameToLayer(left ? Hand.leftHandLayerName : Hand.rightHandLayerName);
        }

        protected virtual void OnEnable() {
            SetHandCollidersRecursive(transform);
        }

        protected virtual void OnDisable() {
            handColliders.Clear();
        }

        protected virtual void OnDestroy() {
            if(_handGrabPoint != null)
                Destroy(_handGrabPoint.gameObject);
            if(_localGrabbablePoint != null)
                Destroy(_localGrabbablePoint.gameObject);
        }

        protected virtual void FixedUpdate(){
            velocityTracker.UpdateThrowing();

            if(CollisionCount() > 0) {
                noCollisionFrames = 0;
                collisionFrames++;
            }
            else {
                noCollisionFrames++;
                collisionFrames = 0;
            }

            if(holdingObj != null)
                holdingObj.HeldFixedUpdate();
        }


        //This is used to force the hand to always look like its where it should be even when physics is being weird
        //public virtual void OnPreRender() {
        //    if(!prerendered) {
        //        preRenderPos = transform.position;
        //        preRenderRot = transform.rotation;
        //    }

        //    //Hides fixed joint jitterings
        //    if(holdingObj != null && holdingObj.customGrabJoint == null && !IsGrabbing()) {
        //        //Debug.Log(name + ": PRERENDERED");
        //        transform.position = handGrabPoint.position;
        //        transform.rotation = handGrabPoint.rotation;
        //        prerendered = true;
        //    }
        //}

        //This is used to force the hand to always look like its where it should be even when physics is being weird
        public virtual void OnWillRenderObject(){
            if(!prerendered) {
                preRenderPos = transform.position;
                preRenderRot = transform.rotation;
            }

            //Hides fixed joint jitterings
            if(holdingObj != null && holdingObj.customGrabJoint == null && !IsGrabbing()) {
                //Debug.Log(name + ": PRERENDERED - " + Time.time);
                transform.position = handGrabPoint.position;
                transform.rotation = handGrabPoint.rotation;
                prerendered = true;
            }
        }

        //This puts everything where it should be for the physics update
        public virtual void OnPostRender(){
            //Returns position after hiding for camera
            if(prerendered && holdingObj != null && holdingObj.customGrabJoint == null && !IsGrabbing()) {
                //Debug.Log(name + ": POSTRENDERED - " + Time.time);
                transform.position = preRenderPos;
                transform.rotation = preRenderRot;
            }

            prerendered = false;
        }


        public float GetTriggerAxis() {
            return gripAxis;
        }



        protected void SetHandCollidersRecursive(Transform obj) {
            handColliders.Clear();
            AddHandCol(obj);

            void AddHandCol(Transform obj1) {
                foreach(var col in obj1.GetComponents<Collider>())
                    handColliders.Add(col);

                for(int i = 0; i < obj1.childCount; i++) {
                    AddHandCol(obj1.GetChild(i));
                }
            }
        }



        /// <summary>Returns the current throw velocity</summary>
        public Vector3 ThrowVelocity() { return velocityTracker.ThrowVelocity(); }

        /// <summary>Returns the current throw angular velocity</summary>
        public Vector3 ThrowAngularVelocity() { return velocityTracker.ThrowAngularVelocity(); }



        public  int CollisionCount() {
            if(holdingObj != null)
                return collisionTracker.collisionObjects.Count + holdingObj.CollisionCount();
            return collisionTracker.collisionObjects.Count;
        }


        /// <summary>Returns true during the time between when a grab starts and a hold begins</summary>
        public bool IsGrabbing() {
            return grabbing;
        }


        public bool IsHolding() {
            return holdingObj != null;
        }


        public static int GetHandsLayerMask() {
            return LayerMask.GetMask(Hand.rightHandLayerName, Hand.leftHandLayerName);
        }



        protected virtual void OnDrawGizmosSelected() {
            var radius = reachDistance;
            Gizmos.color = Color.yellow;
            Gizmos.DrawWireSphere(palmTransform.position + palmTransform.forward * radius, radius);
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandBase.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandFollow.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 1f45b4d990ab65e478cc05444d8e79a5
# ASMDEF: AutoHandAssembly.dll
# ---
using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace Autohand { 
    [RequireComponent(typeof(Hand)), DefaultExecutionOrder(0)]
    public class HandFollow : MonoBehaviour {

        Hand _hand;
        public Hand hand {
            get {
                if(_hand == null)
                    _hand = GetComponent<Hand>();
                return _hand;
            }
        }

        Transform follow;

        [Header("Move To Settings")]
        public float maxMoveToDistance = 0.1f;
        public float maxMoveToAngle = 45f;

        [Tooltip("Returns hand to the target after this distance [helps just in case it gets stuck]"), Min(0)]
        public float maxFollowDistance = 0.5f;
        [Tooltip("The maximum allowed velocity of the hand"), Min(0)]
        public float maxVelocity = 12f;

        [Header("Position Settings")]
        [Tooltip("Follow target speed (Can cause jittering if turned too high - recommend increasing drag with speed)"), Min(0)]
        public float followPositionStrength = 60;
        public float startDrag = 20f;
        [Tooltip("The drag multiplier the hand will lerp between the (start drag), and the (start drag * this) to when less than the dragDamperDistance from the follow target")]
        public float dragDamper = 3f;
        [Tooltip("The distance at which the drag damper starts to take effect")]
        public float dragDamperDistance = 0.025f;
        public float minVelocityChange = 1f;
        public float minVelocityDistanceMulti = 5f;

        [Header("Rotation Settings")]
        [Tooltip("Follow target rotation speed (Can cause jittering if turned too high - recommend increasing angular drag with speed)"), Min(0)]
        public float followRotationStrength = 100;
        public float startAngularDrag = 20;
        [Tooltip("The angular drag multiplier the hand will lerp between the (start angular drag), and the (start angular drag * this) to when less than the angleDragDamperDistance from the follow target")]
        public float angleDragDamper = 5f;
        [Tooltip("The distance at which the angular drag damper starts to take effect, in degrees")]
        public float angleDragDamperDistance = 3f;

        [Header("Mass Settings")]
        public float minMass = 0.25f;
        public float maxMass = 10f;
        public float heldMassDivider = 2f;
        public float distanceMassDifference = 10f;
        public float distanceMassMaxDistance = 0.5f;
        public float angleMassDifference = 10f;
        public float angleMassMaxAngle = 45f;

        [Header("Advanced Settings")]
        [Tooltip("If the hand is holding an unparented grabbable (see gabbable.parentOnGrab) and hits its max distance it will drop the object if it cannot returm within the max distance after this many frames - this is a safety to prevent the hand from getting stuck of grabbing something it isnt supposed to")]
        public int maxDistanceNoParentReleaseFrames = 1;

        [Tooltip("If the hand is holding a parented grabbable (see gabbable.parentOnGrab) and hits its max distance it will drop the object if it cannot returm within the max distance after this many frames - this is a safety to prevent the hand from getting stuck of grabbing something it isnt supposed to")]
        public int maxDistanceParentReleaseFrames = 5;


        public Vector3 lastAngularVelocity { get; protected set; }
        public Vector3 lastVelocity { get; protected set; }


        public Vector3 lastFollowDeltaPosition {
            get { return follow.position - lastFrameFollowPosition; }
        }
        public Quaternion lastFollowDeltaRotation {
            get { return follow.rotation * Quaternion.Inverse(lastFrameFollowRotation); }
        }


        internal Vector3 followVel;
        internal Vector3 followAngularVel;
        internal bool ignoreMoveFrame;

        internal Vector3 lastFrameFollowPosition;
        internal Quaternion lastFrameFollowRotation;
        internal Vector3 lastFollowPosition;
        internal Vector3 lastFollowRotation;

        internal Vector3[] updatePositionTracked = new Vector3[3];

        protected int tryMaxDistanceCount;

        protected float targetMass;
        protected float targetHeldMass;

        public Vector3 targetMoveToPosition { get; protected set; }
        public Quaternion targetMoveToRotation { get; protected set; }

        Vector3 lastSetMoveToFollowPosition;
        Quaternion lastSetMoveToFollowRotation;
        float lastSetMoveToTime;
        float lastSetVelocityTime;
        float lastSetAngularVelocityTime;
        float lastSetAverageMoveToTime;
        float lastSetMassTime;

        float currentFollowRotationStrength;
        float currentFollowPositionStrength;


        Transform _moveTo = null;
        public Transform moveTo {
            get {
                if(!gameObject.activeInHierarchy)
                    return null;

                if(_moveTo == null) {
                    _moveTo = new GameObject().transform;
                    _moveTo.parent = transform.parent;
                    _moveTo.name = "HAND FOLLOW POINT";
                }

                return _moveTo;
            }
        }

        List<Hand> currentHands {
            get{
                if(hand.holdingObj == null || hand.holdingObj.HeldCount() < 2)
                    return null;

                return hand.holdingObj.GetHeldBy(true, true);
            }
        }

        Rigidbody moveToBody;




        protected virtual void OnEnable() {
            currentFollowRotationStrength = followRotationStrength;
            currentFollowPositionStrength = followPositionStrength;
        }


        protected virtual void Awake() {
            hand.body.linearDamping = startDrag;
            hand.body.angularDamping = startAngularDrag;
            hand.body.useGravity = false;
        }

        protected virtual void OnDestroy() {
            if(_moveTo != null)
                Destroy(_moveTo.gameObject);
        }

        protected virtual void Update() {
            UpdateHandOffset();
        }

        protected virtual void FixedUpdate() {
            UpdateHandPhysicsMovement();
        }


        protected virtual void UpdateHandPhysicsMovement() {

            if(follow == null || follow != hand.follow)
                follow = hand.follow;

            if(follow != null && hand.enableMovement) {

                followVel = follow.position - lastFollowPosition;
                followAngularVel = follow.rotation.eulerAngles - lastFollowRotation;
                lastFollowPosition = follow.position;
                lastFollowRotation = follow.rotation.eulerAngles;


                if(!hand.IsGrabbing() && !hand.body.isKinematic) {
                    SetMoveTo();
                    AverageSetMoveTo();
                    SetMass();
                    MoveTo(Time.fixedDeltaTime);
                    TorqueTo(Time.fixedDeltaTime);
                }

                if(ignoreMoveFrame) {
                    hand.body.linearVelocity = Vector3.zero;
                    hand.body.angularVelocity = Vector3.zero;
                }
                ignoreMoveFrame = false;


                for(int i = 1; i < updatePositionTracked.Length; i++)
                    updatePositionTracked[i] = updatePositionTracked[i - 1];
                updatePositionTracked[0] = transform.localPosition;

                ignoreMoveFrame = false;
            }
        }



        float timeOffset;
        protected virtual void UpdateHandOffset() {
            if(follow == null || !hand.enableMovement)
                return;

            if(hand.enableMovement) {
                var deltaDist = Vector3.Distance(follow.position, lastFrameFollowPosition);
                var deltaRot = Quaternion.Angle(follow.rotation, lastFrameFollowRotation);

                if(hand.holdingObj && !hand.IsGrabbing() && !hand.holdingObj.maintainGrabOffset) {

                    //Returns the hand to the original position and rotation based on input movement
                    //A value of 1 gentle grab speed will return the hands position/rotation 1:1 with the controller movement
                    hand.grabPositionOffset = Vector3.MoveTowards(hand.grabPositionOffset, Vector3.zero, (deltaDist) * hand.gentleGrabSpeed * Time.deltaTime * 60f);
                    hand.grabRotationOffset = Quaternion.RotateTowards(hand.grabRotationOffset, Quaternion.identity, (deltaRot) * hand.gentleGrabSpeed * Time.deltaTime * 60f);
                    
                    if(!hand.holdingObj.useGentleGrab) {
                        UpdateOffset(true);
                    }
                }
                else if(!hand.holdingObj  && !hand.IsGrabbing()) {
                    UpdateOffset(false);
                }

                void UpdateOffset(bool isGrab) {

                    float grabTime = isGrab ? hand.lastGrabTime : hand.lastReleaseTime;
                    float grabReturnRotationDistance = Vector3.Angle(hand.grabRotationOffset.eulerAngles, Vector3.zero);
                    float grabReturnPositionDistance = hand.grabPositionOffset.magnitude;

                    var point = (Time.time - grabTime)/(hand.GetGrabTime()*2f);

                    timeOffset = ((timeOffset - 1f) + deltaDist * Time.deltaTime * hand.velocityGrabHandAmplifier)/2f + 1f;


                    var smoothTime = hand.GetGrabTime() * timeOffset;

                    hand.grabPositionOffset = Vector3.MoveTowards(hand.grabPositionOffset, Vector3.zero, grabReturnRotationDistance * smoothTime * Time.deltaTime);
                    hand.grabRotationOffset = Quaternion.RotateTowards(hand.grabRotationOffset, Quaternion.identity, grabReturnPositionDistance * smoothTime * Time.deltaTime);

                    hand.grabPositionOffset = Vector3.Lerp(hand.grabPositionOffset, Vector3.zero, point);
                    hand.grabRotationOffset = Quaternion.Lerp(hand.grabRotationOffset, Quaternion.identity, point);
                }
            }

            lastFrameFollowPosition = follow.position;
            lastFrameFollowRotation = follow.rotation;
        }








        internal virtual void MoveTo(float deltaTime) {

            if(followPositionStrength <= 0)
                return;

            if(Time.fixedTime - lastSetVelocityTime != 0)
                lastSetVelocityTime = Time.fixedTime;
            else
                return;

            if(currentHands != null) {
                foreach(var hand in currentHands) 
                    if(hand != null && hand != this.hand) 
                        hand.handFollow.MoveTo(deltaTime);
            }

            float minVelocityChange = this.minVelocityChange;
            var movePos = moveTo.position;
            var currentPos = hand.holdingObj != null && !hand.IsGrabbing() ? hand.handGrabPoint.position : hand.transform.position;
            var distance = Vector3.Distance(movePos, currentPos);

            var velocityClamp = hand.holdingObj != null ? hand.holdingObj.maxHeldVelocity : maxVelocity;
            Vector3 vel = (movePos - currentPos) * followPositionStrength;

            vel.x = Mathf.Clamp(vel.x, -velocityClamp, velocityClamp);
            vel.y = Mathf.Clamp(vel.y, -velocityClamp, velocityClamp);
            vel.z = Mathf.Clamp(vel.z, -velocityClamp, velocityClamp);

            float deltaOffset = Time.fixedDeltaTime / 0.011111f;
            float inverseDeltaOffset = 0.011111f / Time.fixedDeltaTime;
            Vector3 currentVelocity = hand.body.linearVelocity;
            minVelocityChange *= deltaOffset;
            minVelocityChange *= 1 + (distance)*minVelocityDistanceMulti;

            if(currentHands == null)
                hand.body.linearDamping = Mathf.Lerp((startDrag * dragDamper), startDrag, distance/dragDamperDistance) * inverseDeltaOffset;
            else 
                hand.body.linearDamping = startDrag * inverseDeltaOffset;

            Vector3 towardsVel;
            if(currentHands != null) {
                towardsVel = new Vector3(
                    Mathf.MoveTowards(currentVelocity.x, vel.x, minVelocityChange),
                    Mathf.MoveTowards(currentVelocity.y, vel.y, minVelocityChange),
                    Mathf.MoveTowards(currentVelocity.z, vel.z, minVelocityChange)
                );
            }
            else {
                towardsVel = new Vector3(
                    Mathf.MoveTowards(currentVelocity.x, vel.x, minVelocityChange/5f + Mathf.Abs(currentVelocity.x)/1.5f),
                    Mathf.MoveTowards(currentVelocity.y, vel.y, minVelocityChange/5f + Mathf.Abs(currentVelocity.y)/1.5f),
                    Mathf.MoveTowards(currentVelocity.z, vel.z, minVelocityChange/5f + Mathf.Abs(currentVelocity.z)/1.5f)
                );
            }

            hand.body.linearVelocity = towardsVel;
            lastVelocity = hand.body.linearVelocity;
        }





        /// <summary>Rotates the hand to the controller rotation using physics movement</summary>
        internal virtual void TorqueTo(float deltaTime) {

            if(currentFollowRotationStrength <= 0)
                return;

            if(Time.fixedTime - lastSetAngularVelocityTime != 0)
                lastSetAngularVelocityTime = Time.fixedTime;
            else
                return;

            var delta = (moveTo.rotation * Quaternion.Inverse(hand.body.rotation));
            delta.ToAngleAxis(out float angle, out Vector3 axis);
            if(float.IsInfinity(axis.x))
                return;


            if(currentHands != null) {
                foreach(var hand in currentHands)
                    if(hand != null && hand != this.hand)
                        hand.handFollow.TorqueTo(deltaTime);
            }

            if(angle > 180f)
                angle -= 360f;

            float multiLinear = Mathf.Deg2Rad * angle * currentFollowRotationStrength;
            Vector3 angular = multiLinear * axis.normalized;
            angle = Mathf.Abs(angle);


            float inverseDeltaOffset = 0.011111f / Time.fixedDeltaTime;

            if(currentHands == null)
                hand.body.angularDamping = Mathf.Lerp((startAngularDrag * angleDragDamper), startAngularDrag, angle/angleDragDamperDistance) * inverseDeltaOffset;
            else
                hand.body.angularDamping = startAngularDrag * inverseDeltaOffset;

            hand.body.angularVelocity = angular;
            lastAngularVelocity = hand.body.angularVelocity;
        }



        /// <summary>Sets the mass of the hands based on the follow target parameters </summary>
        protected virtual void SetMass() {
            if(Time.fixedTime - lastSetMassTime < 1/1000f)
                return;
            lastSetMassTime = Time.fixedTime;

            if(currentHands != null) {
                foreach(var hand in currentHands)
                    if(hand != null && hand != this.hand)
                        hand.handFollow.SetMass();
            }

            //Converts the distance to a mass value
            float lerpPoint = 0;
            float angleLerpPoint = 0;

            var currentPos = hand.holdingObj != null && !hand.IsGrabbing() ? hand.handGrabPoint.position : hand.transform.position;
            var currentRot = hand.holdingObj != null && !hand.IsGrabbing() ? hand.handGrabPoint.rotation : hand.transform.rotation;
            lerpPoint = Vector3.Distance(moveTo.position, currentPos)/distanceMassMaxDistance;
            angleLerpPoint = Mathf.Abs(Quaternion.Angle(moveTo.rotation, currentRot)) / angleMassMaxAngle;

            float distanceMass = Mathf.Lerp(minMass, maxMass, lerpPoint) * distanceMassDifference / (distanceMassDifference + angleMassDifference);
            float angleMass = Mathf.Lerp(minMass, maxMass, angleLerpPoint) * angleMassDifference / (distanceMassDifference + angleMassDifference);
            targetMass = (angleMass + distanceMass);
            hand.body.mass = targetMass;

            if(hand.holdingObj != null && !hand.IsGrabbing()) {
                float startHeldMass = hand.holdingObj.targetMass/heldMassDivider;
                var heldDistanceMass = Mathf.Lerp(startHeldMass * (minMass/maxMass), startHeldMass, lerpPoint)* distanceMassDifference / (distanceMassDifference + angleMassDifference);
                float heldAngleMass = Mathf.Lerp(startHeldMass * (minMass/maxMass), startHeldMass, angleLerpPoint) * angleMassDifference / (distanceMassDifference + angleMassDifference);
                targetHeldMass = heldAngleMass + heldDistanceMass;
                hand.holdingObj.body.mass = targetHeldMass;
            }

            AverageMass();
        }



        /// <summary>Averages the masses if there are multiple hands to stabilize the held state</summary>
        protected virtual void AverageMass() {

            if(currentHands == null)
                return;

            float averageMass = 0;
            float averageHeldMass = 0;
            foreach(var hand in currentHands) {
                averageMass += hand.handFollow.targetMass;
                averageHeldMass += hand.handFollow.targetHeldMass;
            }

            averageMass /= currentHands.Count;
            foreach(var hand in currentHands)
                hand.body.mass = averageMass;

            hand.holdingObj.body.mass = averageHeldMass/currentHands.Count;
        }




        protected virtual void CheckHandMaxDistance() {
            var currentHandPos = hand.holdingObj != null && !hand.IsGrabbing() ? hand.handGrabPoint.position : hand.transform.position;
            var distance = Vector3.Distance(currentHandPos, targetMoveToPosition);

            //Returns if out of distance, if you aren't holding anything
            if(distance > maxFollowDistance) {
                if(hand.holdingObj != null) {
                    if(((!hand.holdingObj.parentOnGrab && tryMaxDistanceCount < maxDistanceNoParentReleaseFrames) 
                        || (hand.holdingObj.parentOnGrab && tryMaxDistanceCount < maxDistanceParentReleaseFrames))) {
                        SetHandLocation(targetMoveToPosition, hand.transform.rotation);
                        //Adding two because we remove 1 at the end of the function
                        tryMaxDistanceCount += 2;
                    }
                    else {
                        hand.holdingObj.ForceHandRelease(hand);
                        SetHandLocation(targetMoveToPosition, hand.transform.rotation);
                    }
                }
                else {
                    SetHandLocation(targetMoveToPosition, hand.transform.rotation);
                }
            }

            if(tryMaxDistanceCount > 0)
                tryMaxDistanceCount--;
        }



        ///<summary>Moves the hand and whatever it might be holding (if teleport allowed) to given pos/rot</summary>
        public virtual void SetHandLocation(Vector3 targetPosition, Quaternion targetRotation) {
            var currentTransformPosition = hand.holdingObj != null && !hand.IsGrabbing() ? hand.handGrabPoint.position : hand.transform.position;
            var currentTransformRotation = hand.holdingObj != null && !hand.IsGrabbing() ? hand.handGrabPoint.rotation : hand.transform.rotation;
            var deltaPos = targetPosition - currentTransformPosition;
            var deltaRot = targetRotation * Quaternion.Inverse(currentTransformRotation);

            if(hand.holdingObj && hand.holdingObj.parentOnGrab) {
                if(!hand.IsGrabbing()) {
                    ignoreMoveFrame = true;

                    if(currentHands != null) {
                        targetPosition += currentTransformPosition - moveTo.position;
                        targetRotation *= (Quaternion.Inverse(moveTo.rotation)* currentTransformRotation);
                    }

                    var handRuler = AutoHandExtensions.transformRuler;
                    handRuler.position = currentTransformPosition;
                    handRuler.rotation = currentTransformRotation;

                    var grabRuler = AutoHandExtensions.transformRulerChild;
                    grabRuler.position = hand.holdingObj.body.transform.position;
                    grabRuler.rotation = hand.holdingObj.body.transform.rotation;

                    handRuler.position = targetPosition;
                    handRuler.rotation = targetRotation;

                    var deltaHandRot = targetRotation * Quaternion.Inverse(currentTransformRotation);
                    var deltaGrabPos = grabRuler.position - hand.holdingObj.body.transform.position;
                    var deltaGrabRot = Quaternion.Inverse(grabRuler.rotation) * hand.holdingObj.body.transform.rotation;

                    hand.transform.position = handRuler.position;
                    hand.transform.rotation = handRuler.rotation;
                    hand.body.position = handRuler.position;
                    hand.body.rotation = handRuler.rotation;

                    hand.holdingObj.body.transform.position = grabRuler.position;
                    hand.holdingObj.body.transform.rotation = grabRuler.rotation;
                    hand.holdingObj.body.position = grabRuler.position;
                    hand.holdingObj.body.rotation = grabRuler.rotation;

                    hand.body.linearVelocity = deltaHandRot * hand.body.linearVelocity;
                    hand.body.angularVelocity = deltaHandRot * hand.body.angularVelocity;
                    

                    hand.grabPositionOffset = deltaGrabRot * hand.grabPositionOffset;

                    foreach(var jointed in hand.holdingObj.jointedBodies) {
                        if(!(jointed.CanGetComponent(out Grabbable grab) && grab.HeldCount() > 0)) {
                            jointed.position += deltaGrabPos;
                            jointed.transform.RotateAround(hand.holdingObj.body.transform, deltaGrabRot);
                        }
                    }

                    hand.velocityTracker.ClearThrow();
                }
            }
            else {
                ignoreMoveFrame = true;
                hand.transform.position = targetPosition;
                hand.transform.rotation = targetRotation;
                hand.body.position = targetPosition;
                hand.body.rotation = targetRotation;
                hand.body.linearVelocity = Vector3.zero;
                hand.body.angularVelocity = Vector3.zero;
            }

            moveTo.position += deltaPos;
            moveTo.rotation *= deltaRot;
            SetMoveTo();
            //AverageSetMoveTo();

        }



        ///<summary>Moves the hand and keeps the local rotation</summary>
        public virtual void SetHandLocation(Vector3 targetPosition) {
            SetMoveTo();
            SetHandLocation(targetPosition, hand.transform.rotation);
        }



        /// <summary>Resets the hand location to the follow</summary>
        public void ResetHandLocation() {
            SetHandLocation(moveTo.position, moveTo.rotation);
        }



        /// <summary>Updates the target used to calculate velocity / movements towards follow</summary>
        public virtual void SetMoveTo(bool ignoreRedundancyCheck = false) {
            if(follow == null)
                return;

            if(ignoreRedundancyCheck || Time.fixedTime - lastSetMoveToTime > 0 || lastSetMoveToFollowPosition != (follow.position + hand.grabPositionOffset) || lastSetMoveToFollowRotation != (follow.rotation * hand.grabRotationOffset)) {
                lastSetMoveToFollowPosition = follow.position + hand.grabPositionOffset;
                lastSetMoveToFollowRotation = follow.rotation * hand.grabRotationOffset;
                lastSetMoveToTime = Time.fixedTime;
                lastSetVelocityTime = 0;
                lastSetAngularVelocityTime = 0;
                lastSetAverageMoveToTime = 0;
                lastSetMassTime = 0;
            }
            else {
                return;
            }

            if(currentHands != null) {
                foreach(var hand in currentHands)
                    if(hand != null && !hand.Equals(this.hand))
                        hand.handFollow.SetMoveTo();
            }


            var targetMoveToPosition = follow.position + hand.grabPositionOffset;
            var targetMoveToRotation = follow.rotation * hand.grabRotationOffset;

            if(hand.holdingObj != null) {
                if(hand.left) {
                    var moveLeft = hand.holdingObj.heldPositionOffset; moveLeft.x *= -1;
                    var leftRot = -hand.holdingObj.heldRotationOffset; leftRot.x *= -1;
                    targetMoveToPosition += transform.rotation * moveLeft;
                    targetMoveToRotation *= Quaternion.Euler(leftRot);
                }
                else {
                    targetMoveToPosition += transform.rotation * hand.holdingObj.heldPositionOffset;
                    targetMoveToRotation *= Quaternion.Euler(hand.holdingObj.heldRotationOffset);
                }
            }

            //Instead of just setting the moveto directly like in AutoHand V3,
            //I've found this method move using a moveTowards with a square root distance creates snappy forces
            //that get stronger the further away the hand is from the target, but in such a way that doesn't create sudden instabilities
            if(hand.holdingObj != null && !hand.IsGrabbing()) {
                var distance = Vector3.Distance(targetMoveToPosition, hand.handGrabPoint.position);
                var angleDistance = Quaternion.Angle(targetMoveToRotation, hand.handGrabPoint.rotation);
                moveTo.position = Vector3.MoveTowards(hand.handGrabPoint.position, targetMoveToPosition, maxMoveToDistance + (Mathf.Sqrt(distance+1f))-1f);
                moveTo.rotation = Quaternion.RotateTowards(hand.handGrabPoint.rotation, targetMoveToRotation, maxMoveToAngle + Mathf.Sqrt(angleDistance+1f)-1f);
            }
            else {
                var distance = Vector3.Distance(targetMoveToPosition, hand.transform.position);
                var angleDistance = Quaternion.Angle(targetMoveToRotation, hand.transform.rotation);
                moveTo.position = Vector3.MoveTowards(hand.transform.position, targetMoveToPosition, maxMoveToDistance + (Mathf.Sqrt(distance+1f)-1f));
                moveTo.rotation = Quaternion.RotateTowards(hand.transform.rotation, targetMoveToRotation, maxMoveToAngle + Mathf.Sqrt(angleDistance+1f)-1f);
            }

            //If you were using the old method of tracking the moveTo values, you can use these values to get the same results as V3.3 and older
            this.targetMoveToPosition = targetMoveToPosition;
            this.targetMoveToRotation = targetMoveToRotation;

            CheckHandMaxDistance();
        }




        public virtual void AverageSetMoveTo(bool ignoreRedundencyCheck = false) {

            if(Time.fixedTime - lastSetAverageMoveToTime != 0)
                lastSetAverageMoveToTime = Time.fixedTime;
            else if(!ignoreRedundencyCheck)
                return;

            //This line should stay between the fixed time return and the currentHands null check
            currentFollowRotationStrength = followRotationStrength;

            if(currentHands == null)
                return;

            var distance = Vector3.Distance(targetMoveToPosition, hand.handGrabPoint.position);
            var angleDistance = Quaternion.Angle(targetMoveToRotation, hand.handGrabPoint.rotation);

            var totalDistance = 0f;
            float totalAngleDistance = 0;
            foreach(var hand in currentHands) {
                if(hand != null) {
                    totalDistance += Vector3.Distance(hand.handFollow.targetMoveToPosition, hand.handGrabPoint.position);
                    totalAngleDistance +=  Quaternion.Angle(hand.handFollow.targetMoveToRotation, hand.handGrabPoint.rotation);
                }
            }

            if(currentHands != null) {
                foreach(var hand in currentHands)
                    if(hand != null && !hand.Equals(this.hand))
                        hand.handFollow.AverageSetMoveTo();
            }

            List<Hand> heldBy = currentHands;
            for(int i = 0; i < heldBy.Count; i++) {
                if(!heldBy[i].Equals(hand)) {
                    var otherHandFollow = heldBy[i].handFollow;
                    var otherMoveRotation = otherHandFollow.targetMoveToRotation;
                    var otherAngleDistance = Quaternion.Angle(otherMoveRotation, heldBy[i].handGrabPoint.rotation);

                    var massOffset = Mathf.Clamp01(heldBy[i].body.mass / hand.body.mass);
                    var deltaRotation = Quaternion.Inverse(heldBy[i].handGrabPoint.rotation) * heldBy[i].handFollow.targetMoveToRotation;

                    var totalDistanceDiff = Mathf.Clamp01(1-(totalDistance/maxFollowDistance));
                    moveTo.rotation = Quaternion.Lerp(moveTo.rotation, moveTo.rotation * deltaRotation, otherAngleDistance/totalAngleDistance * massOffset * 0.5f * totalDistanceDiff);

                }
            }

            currentFollowRotationStrength = Mathf.Lerp(followRotationStrength, followRotationStrength/4f, Mathf.Sqrt(distance/maxMoveToDistance));
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandFollow.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandGizmos.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 58e5d1d13a89f3b498d2152b5d799f28
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand
{
    [RequireComponent(typeof(Hand))]
    public class HandGizmos : MonoBehaviour
        {
    #if UNITY_EDITOR
        private float lastOffset;
        private Quaternion lastHandRot;
        private Vector3 lastHandPos;
        private float lastReachDistance;

        Hand hand;

        private void OnDrawGizmos() {
            if (hand == null)
                hand = GetComponent<Hand>();

            if(hand.palmTransform == null)
                return;
        }


        private void OnDrawGizmosSelected() {
            if(hand.palmTransform == null)
                return;
            Gizmos.color = Color.blue;
            Gizmos.DrawRay(hand.palmTransform.position, hand.palmTransform.forward* hand.reachDistance);

            if (lastOffset == 0)
                lastOffset = hand.gripOffset;
            if (hand.gripOffset != lastOffset){
                lastOffset = hand.gripOffset;
                hand.RelaxHand();
            }

            if (lastReachDistance == 0)
                lastReachDistance = hand.reachDistance;

            if (hand.reachDistance != lastReachDistance){
                var percent = hand.reachDistance / lastReachDistance;
                lastReachDistance = hand.reachDistance;
            }
        }
    #endif

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandGizmos.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandGrabbableHighlighter.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 62282a7c920d8134092c8af4e7d85f92
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HandGrabbableHighlighter : MonoBehaviour {
        Hand _hand;
        public Hand hand {
            get {
                if(_hand == null)
                    _hand = GetComponent<Hand>();
                return _hand;
            }
        }

        [Tooltip("When choosing between multiple targets to highlight, " +
            "the hand will favor objects in the palms local forward direction (0) " +
            "or the palms local right direction (1) or a blend between the two recommended (0.5-0.75). " +
            "The forward direction should be facing away from the palm and the right direction should be pointing to the finger tips")]
        public float palmForwardRightDirection = 0.65f;

        [Tooltip("Whether the highlighter should ignore or check for grabbabels that are using trigger colliders or just solid colliders - reocommend using collide for most cases.")]
        public QueryTriggerInteraction highlightQuery = QueryTriggerInteraction.Collide;


        /// <summary>Called when highlighting starts</summary>
        public event HandGrabEvent OnHighlight;
        /// <summary>Called when highlighting ends</summary>
        public event HandGrabEvent OnStopHighlight;



        //Highlighting doesn't need to be called every update, it can be called every 4th update without causing any noticable differrences 
        IEnumerator HighlightUpdate(float timestep) {
            yield return new WaitForEndOfFrame();
            yield return new WaitForFixedUpdate();

            //This will smooth out the highlight calls to help prevent lag spikes
            if(hand.left)
                yield return new WaitForSecondsRealtime(timestep / 2);

            while(true) {
                if(hand.usingHighlight) {
                    UpdateHighlight();
                }
                yield return new WaitForSecondsRealtime(timestep);
            }
        }

        RaycastHit _highlightHit = new RaycastHit();
        public RaycastHit highlightHit {
            get { return _highlightHit; }
            protected set { _highlightHit = value; }
        }

        [HideInInspector]
        public Collider[] highlightCollidersNonAlloc = new Collider[128];
        [HideInInspector]
        public int highlightColliderNonAllocCount = 0;
        [HideInInspector]
        public List<Grabbable> foundHighlightGrabbables = new List<Grabbable>();

        Coroutine highlightRoutine;
        protected List<RaycastHit> closestHits = new List<RaycastHit>();
        protected List<Grabbable> closestGrabs = new List<Grabbable>();

        public Grabbable currentHighlightTarget { get; protected set; }


        public virtual void OnEnable() {
            highlightRoutine = StartCoroutine(HighlightUpdate(1/30f));
        }

        public virtual void OnDisable() {
            if(highlightRoutine != null)
                StopCoroutine(highlightRoutine);

            if(currentHighlightTarget != null) {
                OnStopHighlight?.Invoke(hand, currentHighlightTarget);
                currentHighlightTarget.Unhighlight(hand);
            }
        }

        public virtual void Update() {
            if(hand.holdingObj != null || hand.IsGrabbing())
                currentHighlightTarget = null;
        }



        /// <summary>Manages the highlighting for grabbables</summary>
        public virtual void UpdateHighlight(bool overrideIgnoreHighlight = false, bool ignoreHighlightEvents = false) {

            if((overrideIgnoreHighlight || hand.usingHighlight) && hand.highlightLayers != 0 && (overrideIgnoreHighlight || hand.holdingObj == null && !hand.IsGrabbing())) {
                int grabbingLayer = LayerMask.NameToLayer(Hand.grabbingLayerName);
                int gabbingMask = LayerMask.GetMask(Hand.grabbingLayerName);
                highlightColliderNonAllocCount = Physics.OverlapSphereNonAlloc(hand.palmTransform.position + hand.palmTransform.forward * hand.reachDistance / 3f, hand.reachDistance, highlightCollidersNonAlloc, hand.highlightLayers & ~(hand.ignoreGrabCheckLayers.value), highlightQuery);
                foundHighlightGrabbables.Clear();

                for(int i = 0; i < highlightColliderNonAllocCount; i++) {
                    if(highlightCollidersNonAlloc[i].gameObject.HasGrabbable(out var grab)) {
                        grab.SetLayerRecursive(grabbingLayer);
                        foundHighlightGrabbables.Add(grab);
                    }
                }

                if(foundHighlightGrabbables.Count > 0) {
                    Vector3 dir = HandClosestHit(out _highlightHit, out IGrabbableEvents newLookingAtObjEvent, ~(hand.handLayers | hand.ignoreGrabCheckLayers.value));
                    Grabbable newLookingAtObj = null;
                    if(newLookingAtObjEvent != null && newLookingAtObjEvent.GetGrabbable() != null && newLookingAtObjEvent.GetGrabbable().enabled == true)
                        newLookingAtObj = newLookingAtObjEvent.GetGrabbable();

                    //Zero means it didn't hit
                    if(dir != Vector3.zero && (newLookingAtObj != null && newLookingAtObj.CanGrab(hand))) {
                        //Changes look target
                        if(newLookingAtObj != currentHighlightTarget) {
                            //Unhighlights current target if found
                            if(currentHighlightTarget != null) {
                                if(!ignoreHighlightEvents && OnStopHighlight != null)
                                    OnStopHighlight.Invoke(hand, currentHighlightTarget);

                                currentHighlightTarget.Unhighlight(hand, null, ignoreHighlightEvents);
                            }

                            currentHighlightTarget = newLookingAtObj;

                            //Highlights new target if found
                            if(!ignoreHighlightEvents && OnHighlight != null)
                                OnHighlight.Invoke(hand, currentHighlightTarget);
                            currentHighlightTarget.Highlight(hand, null, ignoreHighlightEvents);
                        }
                    }
                    //If it was looking at something but now it's not there anymore
                    else if(newLookingAtObj == null && currentHighlightTarget != null) {
                        //Just in case the object your hand is looking at is destroyed
                        if(!ignoreHighlightEvents && OnStopHighlight != null)
                            OnStopHighlight.Invoke(hand, currentHighlightTarget);
                        currentHighlightTarget.Unhighlight(hand, null, ignoreHighlightEvents);
                        currentHighlightTarget = null;
                    }

                    for(int i = 0; i < foundHighlightGrabbables.Count; i++) {
                        foundHighlightGrabbables[i].ResetOriginalLayers();
                    }
                }
                else if(currentHighlightTarget != null) {
                    //Just in case the object your hand is looking at is destroyed
                    if(!ignoreHighlightEvents && OnStopHighlight != null)
                        OnStopHighlight.Invoke(hand, currentHighlightTarget);

                    currentHighlightTarget.Unhighlight(hand, null, ignoreHighlightEvents);

                    currentHighlightTarget = null;
                }
            }
        }

        public void ClearHighlights() {
            if(currentHighlightTarget != null) {
                OnStopHighlight?.Invoke(hand, currentHighlightTarget);
                currentHighlightTarget.Unhighlight(hand);
                currentHighlightTarget = null;
            }
        }

        /// <summary>Returns the closest raycast hit from the hand's highlighting system, if no highlight, returns blank raycasthit</summary>
        public RaycastHit GetHighlightHit() {
            _highlightHit.point = hand.handGrabPoint.position;
            _highlightHit.normal = hand.handGrabPoint.up;
            return _highlightHit;
        }



        Collider[] handHighlightNonAlloc = new Collider[128];
        /// <summary>Finds the closest raycast from a cone of rays -> Returns average direction of all hits</summary>
        public virtual Vector3 HandClosestHit(out RaycastHit closestHit, out IGrabbableEvents grabbable, int layerMask, Grabbable target = null) {
            Grabbable grab;
            Vector3 palmForward = hand.palmTransform.forward;
            Vector3 palmRight = hand.palmTransform.right;
            Vector3 palmPosition = hand.palmTransform.position;
            GameObject rayHitObject;
            Grabbable lastRayHitGrabbable = null;
            Ray ray = new Ray();
            RaycastHit hit;
            Collider col;

            closestGrabs.Clear();
            closestHits.Clear();
            var checkSphereRadius = hand.reachDistance * 1.35f;
            int overlapCount = Physics.OverlapSphereNonAlloc(palmPosition + palmForward * (checkSphereRadius * 0.5f), checkSphereRadius, handHighlightNonAlloc, layerMask, highlightQuery);


            for(int i = 0; i < overlapCount; i++) {
                col = handHighlightNonAlloc[i];

                if(!(col is MeshCollider) || (col as MeshCollider).convex == true) {
                    Vector3 closestPoint = col.ClosestPoint(hand.palmTransform.transform.position);
                    ray.direction = closestPoint -hand.palmTransform.position;
                }
                else
                    ray.direction =hand.palmTransform.forward;

                ray.origin =hand.palmTransform.transform.position;
                ray.origin = Vector3.MoveTowards(ray.origin, col.bounds.center, 0.001f);
                
                if(ray.direction != Vector3.zero && Vector3.Angle(ray.direction,hand.palmTransform.forward) < 120 && Physics.Raycast(ray, out hit, checkSphereRadius*2, layerMask, highlightQuery)) {

                    rayHitObject = hit.collider.gameObject;
                    if(closestGrabs.Count > 0)
                        lastRayHitGrabbable = closestGrabs[closestGrabs.Count - 1];

                    if(closestGrabs.Count > 0 && rayHitObject == lastRayHitGrabbable.gameObject) {
                        if(target == null) {
                            closestGrabs.Add(lastRayHitGrabbable);
                            closestHits.Add(hit);
                        }
                    }
                    else if(rayHitObject.HasGrabbable(out grab) && hand.CanGrab(grab)) {
                        if(target == null || target == grab) {
                            closestGrabs.Add(grab);
                            closestHits.Add(hit);
                        }
                    }
                }
            }

            int closestHitCount = closestHits.Count;

            if(closestHitCount > 0) {
                closestHit = closestHits[0];
                grabbable = closestGrabs[0];
                Vector3 dir = Vector3.zero;
                float grabPriorityWeight = (grabbable is Grabbable) ? (grabbable as Grabbable).grabPriorityWeight : 1f;
                var targetDirection = Vector3.Lerp(palmForward, palmRight, palmForwardRightDirection);

                for(int i = 0; i < closestHitCount; i++) {
                    var newDistance = closestHits[i].distance / closestGrabs[i].grabPriorityWeight;
                    var newDot = Vector3.Dot(targetDirection, closestHits[i].point -hand.palmTransform.position)/2f * hand.reachDistance;
                    var currentDistance = closestHit.distance / grabPriorityWeight;
                    var currentDot = Vector3.Dot(targetDirection, closestHit.point -hand.palmTransform.position)/2f * hand.reachDistance;

                    if(newDistance-newDot < currentDistance-currentDot) {
                        closestHit = closestHits[i];
                        grabbable = closestGrabs[i];
                    }

                    dir += closestHits[i].point - hand.palmTransform.position;
                }

                if(hand.holdingObj == null && !hand.IsGrabbing()) {
                    if(hand.handGrabPoint.parent != closestHit.transform)
                        hand.handGrabPoint.parent = closestHit.collider.transform;
                    hand.handGrabPoint.position = closestHit.point;
                    hand.handGrabPoint.up = closestHit.normal;
                }

                return dir / closestHitCount;
            }

            closestHit = new RaycastHit();
            grabbable = null;
            return Vector3.zero;
        }

    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandGrabbableHighlighter.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandPoseData.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: dbb03ea4c2f094a53b02416e0c2fc1ac
# ASMDEF: AutoHandAssembly.dll
# ---
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {

    [System.Serializable]
    public struct FingerPoseData {
        public Matrix4x4[] poseRelativeMatrix;

        //Local rotations are calculated once when the matrix array is created, this prevents wasted calculations from calling matrix.extractrotation multiple times
        //These arent the same transform.localRotation, they represent the difference in rotation between the joints, ignoring any joints between them. Useful for quickly calulating blended poses
        public Quaternion[] localRotations;

        public bool isLocalSet => localRotations != null && localRotations.Length > 0;

        public bool isSet => poseRelativeMatrix != null && poseRelativeMatrix.Length > 0;


        public FingerPoseData(Hand hand, Finger finger) {
            poseRelativeMatrix = new Matrix4x4[4];
            poseRelativeMatrix[(int)FingerJointEnum.knuckle] = hand.transform.worldToLocalMatrix * finger.knuckleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.middle] =  finger.knuckleJoint.worldToLocalMatrix * finger.middleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.distal] =  finger.middleJoint.worldToLocalMatrix * finger.distalJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.tip] =  finger.distalJoint.worldToLocalMatrix * finger.tip.localToWorldMatrix;
            localRotations = new Quaternion[4];
            CalculateAdditionalValues(hand.transform.lossyScale);

        }

        public FingerPoseData(Transform hand, Transform knuckleJoint, Transform middleJoint, Transform distalJoint, Transform tip) {
            poseRelativeMatrix = new Matrix4x4[4];
            poseRelativeMatrix[(int)FingerJointEnum.knuckle] = hand.worldToLocalMatrix * knuckleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.middle] =  knuckleJoint.worldToLocalMatrix * middleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.distal] =  middleJoint.worldToLocalMatrix * distalJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.tip] =  distalJoint.worldToLocalMatrix * tip.localToWorldMatrix;
            localRotations = new Quaternion[4];
            CalculateAdditionalValues(hand.lossyScale);
        }

        public FingerPoseData(ref FingerPoseData data) {
            poseRelativeMatrix = new Matrix4x4[data.poseRelativeMatrix.Length];
            data.poseRelativeMatrix.CopyTo(poseRelativeMatrix, 0);
            localRotations = new Quaternion[4];
            data.localRotations.CopyTo(localRotations, 0);
        }

        public FingerPoseData(FingerPoseData data) {
            poseRelativeMatrix = new Matrix4x4[data.poseRelativeMatrix.Length];
            data.poseRelativeMatrix.CopyTo(poseRelativeMatrix, 0);
            localRotations = new Quaternion[4];
            data.localRotations.CopyTo(localRotations, 0);
        }


        public void SetPoseData(ref FingerPoseData data, FingerJointEnum[] fingerJoints) {
            if(data.poseRelativeMatrix == null || data.poseRelativeMatrix.Length == 0)
                poseRelativeMatrix = new Matrix4x4[4];

            for(int i = 0; i < fingerJoints.Length; i++) {
                int fingerJointIndex = (int)fingerJoints[i];
                poseRelativeMatrix[fingerJointIndex] = data.poseRelativeMatrix[fingerJointIndex];
                localRotations[fingerJointIndex] = data.localRotations[fingerJointIndex];
            }
        }


        public void SetPoseData(Hand hand, Finger finger) {
            if(poseRelativeMatrix == null || poseRelativeMatrix.Length == 0)
                poseRelativeMatrix = new Matrix4x4[4];
            poseRelativeMatrix[(int)FingerJointEnum.knuckle] = hand.transform.worldToLocalMatrix * finger.knuckleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.middle] =  finger.knuckleJoint.worldToLocalMatrix * finger.middleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.distal] =  finger.middleJoint.worldToLocalMatrix * finger.distalJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.tip] =  finger.distalJoint.worldToLocalMatrix * finger.tip.localToWorldMatrix;
            CalculateAdditionalValues(hand.transform.lossyScale);
        }

        public void SetPoseData(Transform hand, Transform knuckleJoint, Transform middleJoint, Transform distalJoint, Transform tip) {
            poseRelativeMatrix[(int)FingerJointEnum.knuckle] = hand.worldToLocalMatrix * knuckleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.middle] =  knuckleJoint.worldToLocalMatrix * middleJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.distal] =  middleJoint.worldToLocalMatrix * distalJoint.localToWorldMatrix;
            poseRelativeMatrix[(int)FingerJointEnum.tip] =  distalJoint.worldToLocalMatrix * tip.localToWorldMatrix;
            CalculateAdditionalValues(hand.transform.lossyScale);
        }

        public void CopyFromData(ref FingerPoseData fingerPoseData) {
            fingerPoseData.poseRelativeMatrix.CopyTo(poseRelativeMatrix, 0);
            fingerPoseData.localRotations.CopyTo(localRotations, 0);
        }

        public void CopyFromData(FingerPoseData fingerPoseData) {
            fingerPoseData.poseRelativeMatrix.CopyTo(poseRelativeMatrix, 0);
            fingerPoseData.localRotations.CopyTo(localRotations, 0);
        }

        /// <summary>Interpolates this pose data to the given pose data by the given point 0.0 - 1.0</summary>
        /// <param name="updateMatrixData">If you know that you aren't going to use the matrix data for this PoseData</param>
        public void LerpDataTo(ref FingerPoseData otherPose, float point, bool updateMatrixData = false) {
            var length = poseRelativeMatrix.Length;
            for(int i = 0; i < length; i++) {
                var interpolatedRotation = Quaternion.Lerp(localRotations[i], otherPose.localRotations[i], point);
                localRotations[i] = interpolatedRotation;

                if(updateMatrixData)
                    poseRelativeMatrix[i].SetTRS(AutoHandExtensions.ExtractPosition(ref poseRelativeMatrix[i]), interpolatedRotation, AutoHandExtensions.ExtractScale(ref poseRelativeMatrix[i]));
            }
        }
        
        /// <summary>Interpolates this pose data to the given pose data by the given point 0.0 - 1.0</summary>
         /// <param name="updateMatrixData">If you know that you aren't going to use the matrix data for this PoseData</param>
        public void LerpData(ref FingerPoseData fromPose, ref FingerPoseData toPose, float point, bool updateMatrixData = false) {
            var length = poseRelativeMatrix.Length;
            for(int i = 0; i < length; i++) {
                var fromRotation = fromPose.localRotations[i];
                var toRotation = toPose.localRotations[i];
                var interpolatedRotation = Quaternion.Lerp(fromRotation, toRotation, point);

                localRotations[i] = interpolatedRotation;

                if(updateMatrixData)
                    poseRelativeMatrix[i].SetTRS(AutoHandExtensions.ExtractPosition(ref poseRelativeMatrix[i]), interpolatedRotation, AutoHandExtensions.ExtractScale(ref poseRelativeMatrix[i]));
            }
        }

        /// <summary>Sets the finger to match this poses data</summary>
        public void SetFingerPose(Finger finger) {
            var handToWorldRotation = finger.hand.transform.rotation;
            var knuckleRotation = handToWorldRotation * localRotations[(int)FingerJointEnum.knuckle];
            var middleRotation = knuckleRotation * localRotations[(int)FingerJointEnum.middle];
            var distalRotation = middleRotation * localRotations[(int)FingerJointEnum.distal];

            finger.knuckleJoint.rotation = knuckleRotation;
            finger.middleJoint.rotation = middleRotation;
            finger.distalJoint.rotation = distalRotation;
        }

        /// <summary>Sets the finger to match this poses data, faster than the simpler SetFingerPose(Finger finger) method because it doesn't call the transform getters when blending through two poses</summary>
        public void SetFingerPose(Finger finger, Quaternion handRotation, Transform knuckleJoint, Transform middleJoint, Transform distalJoint) {
            var handToWorldRotation = handRotation;
            var knuckleRotation = handToWorldRotation * localRotations[(int)FingerJointEnum.knuckle];
            var middleRotation = knuckleRotation * localRotations[(int)FingerJointEnum.middle];
            var distalRotation = middleRotation * localRotations[(int)FingerJointEnum.distal];

            knuckleJoint.rotation = knuckleRotation;
            middleJoint.rotation = middleRotation;
            distalJoint.rotation = distalRotation;
        }



        /// <summary>Returns Rotation Difference</summary>
        public float GetPoseDifferenceByAngle(ref FingerPoseData otherPose) {
            float angleDifference = 0;
            var length = poseRelativeMatrix.Length;
            for(int i = 0; i < length; i++) {
                Quaternion rotation = localRotations[i];
                Quaternion otherRotation = otherPose.localRotations[i];
                angleDifference += Quaternion.Angle(rotation, otherRotation);
            }

            return angleDifference;
        }

        public void CalculateAdditionalValues(Vector3 handLossyScale) {
            if(localRotations == null || localRotations.Length != 4)
                localRotations = new Quaternion[4];

            Matrix4x4 handGlobalMatrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, handLossyScale);
            Matrix4x4 knuckleGlobalMatrix = handGlobalMatrix * poseRelativeMatrix[(int)FingerJointEnum.knuckle];
            Matrix4x4 middleGlobalMatrix = knuckleGlobalMatrix * poseRelativeMatrix[(int)FingerJointEnum.middle];
            Matrix4x4 distalGlobalMatrix = middleGlobalMatrix * poseRelativeMatrix[(int)FingerJointEnum.distal];
            Matrix4x4 tipGlobalMatrix = distalGlobalMatrix * poseRelativeMatrix[(int)FingerJointEnum.tip];

            Quaternion knuckleRotation = AutoHandExtensions.ExtractRotation(ref knuckleGlobalMatrix);
            Quaternion middleRotation = AutoHandExtensions.ExtractRotation(ref middleGlobalMatrix);
            Quaternion distalRotation = AutoHandExtensions.ExtractRotation(ref distalGlobalMatrix);
            Quaternion tipRotation = AutoHandExtensions.ExtractRotation(ref tipGlobalMatrix);

            localRotations[(int)FingerJointEnum.knuckle] = knuckleRotation;
            localRotations[(int)FingerJointEnum.middle] = Quaternion.Inverse(knuckleRotation) * middleRotation;
            localRotations[(int)FingerJointEnum.distal] = Quaternion.Inverse(middleRotation) * distalRotation;
            localRotations[(int)FingerJointEnum.tip] = Quaternion.Inverse(distalRotation) * tipRotation;
        }

    }


    [System.Serializable]
    public struct PoseIdentifier {
        public float[] fingerLengths;
        
        public PoseIdentifier(Hand hand) {
            fingerLengths = new float[5];
            for(int i = 0; i < 5; i++) {
                var finger = hand.fingers[i];
                if(finger.tip != null && finger.fingerType != FingerEnum.none)
                    fingerLengths[(int)finger.fingerType] = finger.tip.localPosition.sqrMagnitude;
            }
        }

        public static bool operator == (PoseIdentifier a, PoseIdentifier b) {
            for(int i = 0; i < 5; i++) {
                if(a.fingerLengths[i] != b.fingerLengths[i]) {
                    return false;
                }
            }
            return true;
        }

        public static bool operator != (PoseIdentifier a, PoseIdentifier b) {
            return !(a == b);
        }

        public override bool Equals(object obj) {
            if(obj is PoseIdentifier) {
                return this == (PoseIdentifier)obj;
            }
            return false;
        }

        public override int GetHashCode() {
            return base.GetHashCode();
        }
    }


    [System.Serializable]
    public struct HandPoseData {

        //DEPRECATED POSE DATA
        public Vector3 rotationOffset;
        public Vector3[] posePositions;
        public Quaternion[] poseRotations;

        //NEWER POSE DATA VALUES
        public Vector3 handOffset;
        public Quaternion localQuaternionOffset;
        public Vector3 globalHandScale;
        public FingerPoseData[] fingerPoses;
        public PoseIdentifier poseID;

        public bool isSet {
            get {
                return fingerPoses != null && fingerPoses.Length > 0;
            }
        }

        public bool isDataDeprecated {
            get {
                if(posePositions != null && posePositions.Length > 0) {
                    if(fingerPoses == null || fingerPoses.Length == 0) {
                        return true;
                    }

                    foreach(var fingerPose in fingerPoses) {
                        if(fingerPose.isSet && !fingerPose.isLocalSet) {
                            return true;
                        }
                    }
                }

                return false;
            }
        }

        /// <summary>Creates a new pose using the current hand relative to a given grabbable</summary>
        public HandPoseData(Hand hand, Grabbable grabbable) {
            //OLD POSE DATA
            posePositions = new Vector3[0];
            poseRotations = new Quaternion[0];
            rotationOffset = Vector3.zero;

            //NEW POSE DATA
            handOffset = new Vector3();
            localQuaternionOffset = Quaternion.identity;
            globalHandScale = hand.transform.lossyScale;
            fingerPoses = new FingerPoseData[5];

            poseID = new PoseIdentifier(hand);
            SavePose(hand, grabbable.transform);
        }

        /// <summary>Creates a new pose using the current hand relative to a given grabbable</summary>
        public HandPoseData(Hand hand, Transform point) {
            //OLD POSE DATA
            posePositions = new Vector3[0];
            poseRotations = new Quaternion[0];
            rotationOffset = Vector3.zero;

            //NEW POSE DATA
            handOffset = new Vector3();
            localQuaternionOffset = Quaternion.identity;
            globalHandScale = hand.transform.lossyScale;
            fingerPoses = new FingerPoseData[5];
            poseID = new PoseIdentifier(hand);

            SavePose(hand, point);
        }

        /// <summary>Creates a new pose using the current hand shape</summary>
        public HandPoseData(Hand hand) {
            //OLD POSE DATA
            posePositions = new Vector3[0];
            poseRotations = new Quaternion[0];
            rotationOffset = Vector3.zero;

            //NEW POSE DATA
            handOffset = new Vector3();
            localQuaternionOffset = Quaternion.identity;
            globalHandScale = hand.transform.lossyScale;
            fingerPoses = new FingerPoseData[5];
            poseID = new PoseIdentifier(hand);

            SavePose(hand, null);
        }

        /// <summary>Creates a new pose using the current hand shape</summary>
        public HandPoseData(ref HandPoseData data) {
            //OLD POSE DATA;
            posePositions = new Vector3[0];
            poseRotations = new Quaternion[0];
            rotationOffset = Vector3.zero;

            //NEW POSE DATA
            handOffset = data.handOffset;
            localQuaternionOffset = data.localQuaternionOffset;
            globalHandScale = data.globalHandScale;
            fingerPoses = new FingerPoseData[5];
            poseID = data.poseID;

            for(int i = 0; i < data.fingerPoses.Length; i++)
                fingerPoses[i] = new FingerPoseData(ref data.fingerPoses[i]);
        }

        /// <summary>Creates a new pose using the current hand shape</summary>
        public void CopyFromData(ref HandPoseData data) {
            //OLD POSE DATA;
            posePositions = new Vector3[0];
            poseRotations = new Quaternion[0];
            rotationOffset = Vector3.zero;

            //NEW POSE DATA
            handOffset = data.handOffset;
            localQuaternionOffset = data.localQuaternionOffset;
            globalHandScale = data.globalHandScale;
            if(fingerPoses == null || fingerPoses.Length == 0) {
                fingerPoses = new FingerPoseData[5];
                for(int i = 0; i < data.fingerPoses.Length; i++)
                    fingerPoses[i] = new FingerPoseData(ref data.fingerPoses[i]);
            }
            else {
                for(int i = 0; i < data.fingerPoses.Length; i++)
                    fingerPoses[i].CopyFromData(ref data.fingerPoses[i]);
            }

            poseID = data.poseID;

        }


        /// <summary> Saves the pose data to the match the current shape of the given hand, relative to is the grabbable transform the hand is posing to hold, or null if empty hand pose </summary>
        public void SavePose(Hand hand, Transform relativeTo = null) {
            foreach(var finger in hand.fingers) {
                if(finger.fingerType == FingerEnum.none)
                    Debug.LogError("AUTO HAND: Finger type is not set, finger type needs to be set on finger component", finger);

                int fingerIndex = (int)finger.fingerType;
                if(!fingerPoses[fingerIndex].isSet)
                    fingerPoses[fingerIndex] = new FingerPoseData(hand, finger);
                else
                    fingerPoses[fingerIndex].SetPoseData(hand, finger);
            }

            if(relativeTo != null) {
                handOffset = relativeTo.InverseTransformPoint(hand.transform.position);
                localQuaternionOffset = Quaternion.Inverse(relativeTo.rotation) * hand.transform.rotation;
                globalHandScale = hand.transform.lossyScale;
            }
            else { 
                handOffset = Vector3.zero;
                localQuaternionOffset = Quaternion.identity;
                globalHandScale = hand.transform.lossyScale;
            }
        }



        /// <summary>Sets the hand pose to match the given hand, relative to the given transform </summary>
        public void SetPose(Hand hand, Transform relativeTo = null) {
            SetPosition(hand, relativeTo);
            SetFingerPose(hand);
        }


        /// <summary>Sets the finger pose without changing the hands position</summary>
        public void SetFingerPose(Hand hand) {
            foreach(var finger in hand.fingers)
                fingerPoses[(int)finger.fingerType].SetFingerPose(finger);
        }


        /// <summary>Sets the position without setting the finger pose</summary>
        public void SetPosition(Hand hand, Transform relativeTo = null) {
            if(relativeTo != null && relativeTo != hand.transform) {
                Matrix4x4 relativeToWorldMatrix = GetHandToWorldMatrix(relativeTo);

                Vector3 newPosition = AutoHandExtensions.ExtractPosition(ref relativeToWorldMatrix);
                Quaternion newRotation = AutoHandExtensions.ExtractRotation(ref relativeToWorldMatrix);

                hand.transform.SetPositionAndRotation(newPosition, newRotation);
                if(hand.body != null) {
                    hand.body.position = newPosition;
                    hand.body.rotation = newRotation;
                }
            }
        }

        public Matrix4x4 GetHandToWorldMatrix(Transform relativeTo) {
            if(relativeTo == null)
                return Matrix4x4.TRS(handOffset, localQuaternionOffset, globalHandScale);

            var globalHandPosition = relativeTo.TransformPoint(handOffset);
            var globalHandRotation = relativeTo.rotation * localQuaternionOffset;
            return Matrix4x4.TRS(globalHandPosition, globalHandRotation, globalHandScale);
        }



        public void LerpPose(ref HandPoseData from, ref HandPoseData to, float point) {
            handOffset = Vector3.Lerp(from.handOffset, to.handOffset, point);
            globalHandScale = Vector3.Lerp(from.globalHandScale, to.globalHandScale, point);
            localQuaternionOffset = Quaternion.Lerp(from.localQuaternionOffset, to.localQuaternionOffset, point);

            for(int i = 0; i < 5; i++) {
                fingerPoses[i].CopyFromData(ref from.fingerPoses[i]);
                fingerPoses[i].LerpDataTo(ref to.fingerPoses[i], point);
            }
        }


        public static void LerpPose(ref HandPoseData lerpPose, ref HandPoseData from, ref HandPoseData to, float point) {
            lerpPose.handOffset = Vector3.Lerp(from.handOffset, to.handOffset, point);
            lerpPose.globalHandScale = Vector3.Lerp(from.globalHandScale, to.globalHandScale, point);
            lerpPose.localQuaternionOffset = Quaternion.Lerp(from.localQuaternionOffset, to.localQuaternionOffset, point);

            for(int i = 0; i < 5; i++) {
                lerpPose.fingerPoses[i].CopyFromData(ref from.fingerPoses[i]);
                lerpPose.fingerPoses[i].LerpDataTo(ref to.fingerPoses[i], point);
            }
        }

        public void GetPoseDifference(ref HandPoseData otherPose, out float[] fingerDistances) {
            fingerDistances = new float[5];
            for(int i = 0; i < 5; i++) {
                fingerDistances[i] = fingerPoses[i].GetPoseDifferenceByAngle(ref otherPose.fingerPoses[i]);
            }
        }

        public void GetPoseDifference(ref HandPoseData otherPose, out float indexDifference, out float middleDifference, out float ringDifference, out float pinkyDifference, out float thumbDifference) {
            GetPoseDifference(ref otherPose, out var fingerDistances);
            indexDifference = fingerDistances[(int)FingerEnum.index];
            middleDifference = fingerDistances[(int)FingerEnum.middle];
            ringDifference = fingerDistances[(int)FingerEnum.ring];
            pinkyDifference = fingerDistances[(int)FingerEnum.pinky];
            thumbDifference = fingerDistances[(int)FingerEnum.thumb];
        }

        public void UpdateDepricatedData(Hand hand, Transform relativeTo) {

            List<Transform> poseTransformsList = new List<Transform>();

            foreach(var finger in hand.fingers)
                AssignChildrenPose(finger.transform);

            void AssignChildrenPose(Transform obj) {
                poseTransformsList.Add(obj);

                for(int j = 0; j < obj.childCount; j++)
                    AssignChildrenPose(obj.GetChild(j));
            }

            if(poseRotations.Length == 0 || posePositions.Length == 0 || posePositions.Length != poseTransformsList.Count) {
                Debug.LogWarning("AUTO HAND: Pose data is not set, skipping updating this pose data", relativeTo);
                return;
            }

            fingerPoses = new FingerPoseData[5];


            var newFingerPose = new FingerPoseData[5];
            foreach(var finger in hand.fingers) {
                newFingerPose[(int)finger.fingerType].poseRelativeMatrix = new Matrix4x4[3];
            }

            for(int i = 0; i < poseTransformsList.Count; i++) {
                var transformJoint = poseTransformsList[i];

                foreach(var finger in hand.fingers) {
                    if(finger.isDataDepricated) {
                        Debug.LogError("AUTO HAND: Finger data is depricated - please try manually updating the finger references on your hand and try again", finger);
                        return;
                    }

                    var knuckleJointIndex = poseTransformsList.IndexOf(finger.knuckleJoint);
                    var middleJointIndex = poseTransformsList.IndexOf(finger.middleJoint);
                    var distalJointIndex = poseTransformsList.IndexOf(finger.distalJoint);

                    var knuckleJointPosition = posePositions[knuckleJointIndex];
                    var middleJointPosition = posePositions[middleJointIndex];
                    var distalJointPosition = posePositions[distalJointIndex];

                    var knuckleJointRotation = poseRotations[knuckleJointIndex];
                    var middleJointRotation = poseRotations[middleJointIndex];
                    var distalJointRotation = poseRotations[distalJointIndex];

                    var knuckleStartPosition = finger.knuckleJoint.localPosition;
                    var middleStartPosition = finger.middleJoint.localPosition;
                    var distalStartPosition = finger.distalJoint.localPosition;

                    var knuckleStartRotation = finger.knuckleJoint.localRotation;
                    var middleStartRotation = finger.middleJoint.localRotation;
                    var distalStartRotation = finger.distalJoint.localRotation;

                    finger.knuckleJoint.localPosition = knuckleJointPosition;
                    finger.middleJoint.localPosition = middleJointPosition;
                    finger.distalJoint.localPosition = distalJointPosition;

                    finger.knuckleJoint.localRotation = knuckleJointRotation;
                    finger.middleJoint.localRotation = middleJointRotation;
                    finger.distalJoint.localRotation = distalJointRotation;

                    newFingerPose[(int)finger.fingerType] = new FingerPoseData(hand, finger);

                    finger.knuckleJoint.localPosition = knuckleStartPosition;
                    finger.middleJoint.localPosition = middleStartPosition;
                    finger.distalJoint.localPosition = distalStartPosition;

                    finger.knuckleJoint.localRotation = knuckleStartRotation;
                    finger.middleJoint.localRotation = middleStartRotation;
                    finger.distalJoint.localRotation = distalStartRotation;
                }
            }

            globalHandScale = hand.transform.lossyScale;



            newFingerPose.CopyTo(fingerPoses, 0);
        }

        internal void SetPositionData(Transform handPoint, Transform relativeTo) {
            if(relativeTo != null) {
                handOffset = relativeTo.InverseTransformPoint(handPoint.position);
                localQuaternionOffset = Quaternion.Inverse(relativeTo.rotation) * handPoint.rotation;
                globalHandScale = handPoint.lossyScale;
            }
            else {
                handOffset = Vector3.zero;
                localQuaternionOffset = Quaternion.identity;
                globalHandScale = Vector3.one;
            }
        }
    }






    public static class HandPoseExtentions {
        public static HandPoseData GetApproximateHandPose(this HandPoseData approximatePose, Hand hand, HandPoseData matchPose, Matrix4x4 offset) {

            approximatePose.handOffset = hand.transform.position;
            approximatePose.localQuaternionOffset = hand.transform.rotation;
            matchPose.localQuaternionOffset = hand.transform.rotation;
            matchPose.handOffset = hand.transform.position;

            Matrix4x4 handToWorld = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, approximatePose.globalHandScale);
            Matrix4x4 otherHandToWorld = Matrix4x4.TRS(AutoHandExtensions.ExtractPosition(ref offset), AutoHandExtensions.ExtractRotation(ref offset), matchPose.globalHandScale);

            FingerPoseData highPose = new FingerPoseData(hand, hand.fingers[0]);
            FingerPoseData lowPose = new FingerPoseData(ref highPose);

            FingerPoseData highLerpPose = new FingerPoseData(ref highPose);
            FingerPoseData lowLerpPose = new FingerPoseData(ref highPose);
            FingerPoseData targetPose = new FingerPoseData(ref highPose);

            //Initial Open Hand Pose
            foreach(var finger in hand.fingers) {
                targetPose.CopyFromData(ref matchPose.fingerPoses[(int)finger.fingerType]);
                FingerPoseData[] fingerPoses = { finger.poseData[(int)FingerPoseEnum.Open], finger.poseData[(int)FingerPoseEnum.PinchOpen] };

                int closestPoseIndex1 = -1;
                int closestPoseIndex2 = -1;
                float closestBlendValue = float.MaxValue;
                float closestPoseValue = float.MaxValue;

                for(int i = 0; i < fingerPoses.Length; i++) { 
                    var pose1 = fingerPoses[i];
                    highPose.CopyFromData(ref pose1);
                    lowPose.CopyFromData(ref pose1);

                    for(int j = i; j < fingerPoses.Length; j++) {
                        if(i == j)
                            continue;

                        var pose2 = fingerPoses[j];
                        float low = 0f;
                        float high = 1f;

                        for(int k = 0; k < 8; k++) {
                            float mid = (low + high) / 2f;

                            highLerpPose.CopyFromData(ref pose2);
                            highLerpPose.LerpDataTo(ref highPose, high);
                            float highValue = GetFingerPoseDistanceDifferenceValue(targetPose, highLerpPose, otherHandToWorld, handToWorld);

                            lowLerpPose.CopyFromData(ref pose2);
                            lowLerpPose.LerpDataTo(ref lowPose, low);
                            float lowValue = GetFingerPoseDistanceDifferenceValue(targetPose, lowLerpPose, otherHandToWorld, handToWorld);

                            if(highValue < lowValue) {
                                low = mid;
                                if(highValue < closestPoseValue) {
                                    closestBlendValue = high;
                                    closestPoseValue = highValue;
                                    closestPoseIndex1 = i;
                                    closestPoseIndex2 = j;
                                }
                            }
                            else {
                                high = mid;
                                if(lowValue < closestPoseValue) {
                                    closestBlendValue = low;
                                    closestPoseValue = lowValue;
                                    closestPoseIndex1 = i;
                                    closestPoseIndex2 = j;
                                }
                            }
                        }
                    }
                }

                highPose.CopyFromData(ref fingerPoses[closestPoseIndex2]);
                lowPose.CopyFromData(ref fingerPoses[closestPoseIndex1]);
                highPose.LerpDataTo(ref lowPose, closestBlendValue);
                approximatePose.fingerPoses[(int)finger.fingerType].CopyFromData(ref highPose);
            }


            return approximatePose;



            float GetFingerPoseDistanceDifferenceValue(FingerPoseData currentPose, FingerPoseData targetPose, Matrix4x4 currentLocalToWorld, Matrix4x4 targetOffset) {
                float value = 0;


                Matrix4x4 kuckleToHandMatrix = currentPose.poseRelativeMatrix[(int)FingerJointEnum.knuckle];
                Matrix4x4 middleToKnuckleMatrix = currentPose.poseRelativeMatrix[(int)FingerJointEnum.middle];

                Matrix4x4 knuckleGlobalMatrix = currentLocalToWorld * kuckleToHandMatrix;
                Matrix4x4 middleGlobalMatrix = knuckleGlobalMatrix * middleToKnuckleMatrix;

                Vector3 knuckleCurrentPosition = AutoHandExtensions.ExtractPosition(ref knuckleGlobalMatrix);
                Vector3 middleCurrentPosition = AutoHandExtensions.ExtractPosition(ref middleGlobalMatrix);

                kuckleToHandMatrix = targetPose.poseRelativeMatrix[(int)FingerJointEnum.knuckle];
                middleToKnuckleMatrix = targetPose.poseRelativeMatrix[(int)FingerJointEnum.middle];

                knuckleGlobalMatrix = targetOffset * kuckleToHandMatrix;
                middleGlobalMatrix = knuckleGlobalMatrix * middleToKnuckleMatrix;

                Vector3 knuckleTargetPosition = AutoHandExtensions.ExtractPosition(ref knuckleGlobalMatrix);
                Vector3 middleTargetPosition = AutoHandExtensions.ExtractPosition(ref middleGlobalMatrix);

                value += Vector3.Distance(middleCurrentPosition, middleTargetPosition);

                return value;
            }
        }

        public static Matrix4x4 ApproximateOffsetMatrix(this HandPoseData fromPose, HandPoseData poseData) {

            Vector3[] localKnucklePositions = new Vector3[5];
            localKnucklePositions[0] = AutoHandExtensions.ExtractPosition(ref fromPose.fingerPoses[(int)FingerEnum.thumb].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            localKnucklePositions[1] = AutoHandExtensions.ExtractPosition(ref fromPose.fingerPoses[(int)FingerEnum.index].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            localKnucklePositions[2] = AutoHandExtensions.ExtractPosition(ref fromPose.fingerPoses[(int)FingerEnum.middle].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            localKnucklePositions[3] = AutoHandExtensions.ExtractPosition(ref fromPose.fingerPoses[(int)FingerEnum.ring].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            localKnucklePositions[4] = AutoHandExtensions.ExtractPosition(ref fromPose.fingerPoses[(int)FingerEnum.pinky].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);

            Vector3[] globalKnucklePositions = new Vector3[5];
            var handToWorld = fromPose.GetHandToWorldMatrix(null);
            globalKnucklePositions[0] = handToWorld*localKnucklePositions[0];
            globalKnucklePositions[1] = handToWorld*localKnucklePositions[1];
            globalKnucklePositions[2] = handToWorld*localKnucklePositions[2];
            globalKnucklePositions[3] = handToWorld*localKnucklePositions[3];
            globalKnucklePositions[4] = handToWorld*localKnucklePositions[4];

            Vector3[] otherLocalKnucklePositions = new Vector3[5];
            otherLocalKnucklePositions[0] = AutoHandExtensions.ExtractPosition(ref poseData.fingerPoses[(int)FingerEnum.thumb].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            otherLocalKnucklePositions[1] = AutoHandExtensions.ExtractPosition(ref poseData.fingerPoses[(int)FingerEnum.index].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            otherLocalKnucklePositions[2] = AutoHandExtensions.ExtractPosition(ref poseData.fingerPoses[(int)FingerEnum.middle].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            otherLocalKnucklePositions[3] = AutoHandExtensions.ExtractPosition(ref poseData.fingerPoses[(int)FingerEnum.ring].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);
            otherLocalKnucklePositions[4] = AutoHandExtensions.ExtractPosition(ref poseData.fingerPoses[(int)FingerEnum.pinky].poseRelativeMatrix[(int)FingerJointEnum.knuckle]);


            Vector3[] otherGlobalKnucklePositions = new Vector3[5];
            handToWorld = poseData.GetHandToWorldMatrix(null);
            otherGlobalKnucklePositions[0] = handToWorld*otherLocalKnucklePositions[0];
            otherGlobalKnucklePositions[1] = handToWorld*otherLocalKnucklePositions[1];
            otherGlobalKnucklePositions[2] = handToWorld*otherLocalKnucklePositions[2];
            otherGlobalKnucklePositions[3] = handToWorld*otherLocalKnucklePositions[3];
            otherGlobalKnucklePositions[4] = handToWorld*otherLocalKnucklePositions[4];

            Vector3[] array1 = new Vector3[4];
            Vector3[] array2 = new Vector3[4];
            array1[0] = globalKnucklePositions[1] - globalKnucklePositions[0];
            array1[1] = globalKnucklePositions[2] - globalKnucklePositions[1];
            array1[2] = globalKnucklePositions[3] - globalKnucklePositions[2];
            array1[3] = globalKnucklePositions[4] - globalKnucklePositions[3];
            array2[0] = otherGlobalKnucklePositions[1] - otherGlobalKnucklePositions[0];
            array2[1] = otherGlobalKnucklePositions[2] - otherGlobalKnucklePositions[1];
            array2[2] = otherGlobalKnucklePositions[3] - otherGlobalKnucklePositions[2];
            array2[3] = otherGlobalKnucklePositions[4] - otherGlobalKnucklePositions[3];

            Plane fromHandPlane = new Plane(globalKnucklePositions[0], globalKnucklePositions[1], globalKnucklePositions[2]);
            Plane otherHandPlane = new Plane(otherGlobalKnucklePositions[0], otherGlobalKnucklePositions[1], otherGlobalKnucklePositions[2]);

            Vector3 normal1 = fromHandPlane.normal;
            Vector3 normal2 = otherHandPlane.normal;

            var rotationOffset = Quaternion.FromToRotation(normal1, normal2);
            var localToWorld = Matrix4x4.TRS(Vector3.zero, rotationOffset, Vector3.one);

            //This will rotate the hand around the normal of the plane until the localToWorld matrix is as close as possible to the other hand
            //We will use binary search principle along that normal axis to find the best rotation with as few iterations as possible

            Quaternion[] quaternionOffset = new Quaternion[3];
            quaternionOffset[0] = Quaternion.Euler(90, 0, 0);
            quaternionOffset[1] = Quaternion.Euler(0, 90, 0);
            quaternionOffset[2] = Quaternion.Euler(0, 0, 90);

            for(int q = 0; q < quaternionOffset.Length; q++) {
                float closestDistance = CompareVector3ArrayCross(array1, array2, localToWorld);
                float closestAngle = -1;
                var rotation = quaternionOffset[q];
                var normal = rotation * normal1;
                var high = 359;
                var low = 0;

                for(int i = 0; i < 9; i++) {
                    var mid = (high + low) / 2;
                    var highRotation = Quaternion.AngleAxis(high, normal);
                    var lowRotation = Quaternion.AngleAxis(low, normal);

                    var lowDistance = CompareVector3ArrayCross(array1, array2, localToWorld * Matrix4x4.Rotate(lowRotation));
                    var highDistance = CompareVector3ArrayCross(array1, array2, localToWorld * Matrix4x4.Rotate(highRotation));

                    if(lowDistance < closestDistance) {
                        closestDistance = lowDistance;
                        closestAngle = low;
                        high = mid;
                    }

                    if(highDistance < closestDistance) {
                        closestDistance = highDistance;
                        closestAngle = high;
                        low = mid;
                    }
                }


                if(closestAngle != -1) {
                    var rotationAdjustment = Quaternion.AngleAxis(closestAngle, normal);
                    localToWorld = localToWorld * Matrix4x4.Rotate(rotationAdjustment);
                    normal1 = rotationAdjustment * normal1;
                }
            }


            Vector3[] directions = new Vector3[] { Vector3.right, Vector3.up, Vector3.forward, Vector3.right, Vector3.up, Vector3.forward };

            var directionMagnitude = 0f;
            for(int i = 0; i < globalKnucklePositions.Length; i++) {
                var newDirectionMagnitude = Vector3.Distance(globalKnucklePositions[i], otherGlobalKnucklePositions[i]);
                if(directionMagnitude < newDirectionMagnitude) {
                    directionMagnitude = newDirectionMagnitude;
                }
            }


            foreach(var direction in directions) {
                float minDistance = -1;
                float maxDistance = 1;
                float midDistance = 0f;
                float closestDistance = float.MaxValue;

                for(int i = 0; i < 10; i++){
                    midDistance = (minDistance + maxDistance) / 2f;
                    Vector3 minDirection = minDistance * direction;
                    Vector3 maxDirection = maxDistance * direction;

                    float minDistanceResult = CompareVector3ArrayDistance(globalKnucklePositions, otherGlobalKnucklePositions, localToWorld * Matrix4x4.Translate(minDirection));
                    float maxDistanceResult = CompareVector3ArrayDistance(globalKnucklePositions, otherGlobalKnucklePositions, localToWorld * Matrix4x4.Translate(maxDirection));

                    if(minDistanceResult < maxDistanceResult) {
                        if(minDistanceResult < closestDistance) {
                            closestDistance = minDistanceResult;
                        }
                        maxDistance = midDistance;
                    }
                    else {
                        if(maxDistanceResult < closestDistance) {
                            closestDistance = maxDistanceResult;
                        }
                        minDistance = midDistance;
                    }
                }

                localToWorld = localToWorld*Matrix4x4.Translate(midDistance * direction);
            }




            for(int q = 0; q < quaternionOffset.Length; q++) {
                float closestDistance = CompareVector3ArrayCross(array1, array2, localToWorld);
                float closestAngle = -1;
                var rotation = quaternionOffset[q];
                var normal = rotation * normal1;
                var high = 359;
                var low = 0;

                for(int i = 0; i < 9; i++) {
                    var mid = (high + low) / 2;
                    var highRotation = Quaternion.AngleAxis(high, normal);
                    var lowRotation = Quaternion.AngleAxis(low, normal);

                    var lowDistance = CompareVector3ArrayCross(array1, array2, localToWorld * Matrix4x4.Rotate(lowRotation));
                    var highDistance = CompareVector3ArrayCross(array1, array2, localToWorld * Matrix4x4.Rotate(highRotation));

                    if(lowDistance < closestDistance) {
                        closestDistance = lowDistance;
                        closestAngle = low;
                        high = mid;
                    }

                    if(highDistance < closestDistance) {
                        closestDistance = highDistance;
                        closestAngle = high;
                        low = mid;
                    }
                }


                if(closestAngle != -1) {
                    var rotationAdjustment = Quaternion.AngleAxis(closestAngle, normal);
                    localToWorld = localToWorld * Matrix4x4.Rotate(rotationAdjustment);
                    normal1 = rotationAdjustment * normal1;
                }
            }


            return localToWorld;
        }

        public static float CompareVector3ArrayCross(Vector3[] target, Vector3[] offset, Matrix4x4 localToWorld) {
            float value = 0;

            for(int i = 0; i < target.Length; i++) {
                var targetPosition = target[i];
                var offsetPosition = offset[i];

                var localPosition = localToWorld.MultiplyPoint3x4(offsetPosition);
                float dotProduct = Vector3.Dot(targetPosition, localPosition);
                value += (1 - dotProduct) / 2f;
            }

            return value;
        }

        public static float CompareVector3ArrayDistance(Vector3[] target, Vector3[] offset, Matrix4x4 localToWorld) {
            float value = 0;

            for(int i = 0; i < target.Length; i++) {
                var targetPosition = target[i];
                var offsetPosition = offset[i];

                var localPosition = localToWorld.MultiplyPoint3x4(offsetPosition);
                float distance = Vector3.Distance(targetPosition, localPosition);
                value += distance;
            }

            return value;
        }
    }


}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandPoseData.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandPoseScriptable.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 6f9629acaf41af8408d8406e0816e2c0
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand
{
    [CreateAssetMenu(fileName = "AutoHand Pose", menuName = "Auto Hand/Custom Pose", order = 1)]
    public class HandPoseScriptable : ScriptableObject{
        [HideInInspector]
        public bool rightSaved;
        [HideInInspector]
        public bool leftSaved;
        public HandPoseData rightPose;
        public HandPoseData leftPose;

        public void SavePoses(HandPoseData right, HandPoseData left)
        {
            SaveRightPose(right);
            SaveLeftPose(left);
        }

        public void SaveRightPose(HandPoseData right)
        {
            rightPose = new HandPoseData(ref right);
            rightSaved = true;
#if UNITY_EDITOR
            UnityEditor.EditorUtility.SetDirty(this);
#endif
        }

        public void SaveLeftPose(HandPoseData left)
        {
            leftPose = new HandPoseData(ref left);
            leftSaved = true;
#if UNITY_EDITOR
            UnityEditor.EditorUtility.SetDirty(this);
#endif
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandPoseScriptable.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandStabilizer.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: f820a3019d6fa6d49a0813bc55bba9c0
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

namespace Autohand{
    //This script is used to hide rigidbody physics instabilitites by
    //putting the hand where it visually should be on prerender
    //and putting it where it physically should be on post render
    [DefaultExecutionOrder(int.MaxValue)]
    public class HandStabilizer : MonoBehaviour{
        public HandBase hand = null;

        void Start(){
            if (!GetComponent<Camera>().enabled || hand == null)
                enabled = false;
        }

        void OnEnable(){
            if(GraphicsSettings.defaultRenderPipeline != null){
                RenderPipelineManager.beginContextRendering += OnPreRenderEvent;
                RenderPipelineManager.endContextRendering += OnPostRenderEvent;
                RenderPipelineManager.beginCameraRendering += OnPreRenderEvent;
                RenderPipelineManager.endCameraRendering += OnPostRenderEvent;
            }
        }

        void OnDisable(){
            if(GraphicsSettings.defaultRenderPipeline != null){
                RenderPipelineManager.beginContextRendering -= OnPreRenderEvent;
                RenderPipelineManager.endContextRendering -= OnPostRenderEvent;
                RenderPipelineManager.beginCameraRendering -= OnPreRenderEvent;
                RenderPipelineManager.endCameraRendering -= OnPostRenderEvent;
            }
        }

        private void Update() {
            if(hand == null)
                Destroy(this);
        }

        private void OnWillRenderObject() {
            if(hand != null && hand.gameObject.activeInHierarchy)
                hand.OnWillRenderObject();
        }

        private void OnPreRender() {
            if(hand != null && hand.gameObject.activeInHierarchy)
                hand.OnWillRenderObject();
        }

        private void OnPostRender() {
            if(hand != null && hand.gameObject.activeInHierarchy)
                hand.OnPostRender();
        }



        private void OnPreRenderEvent(ScriptableRenderContext context, List<Camera> cameras) {
            if(hand != null && hand.gameObject.activeInHierarchy)
                hand.OnWillRenderObject();
        }
        private void OnPreRenderEvent(ScriptableRenderContext context, Camera cam) {
            if(hand != null && hand.gameObject.activeInHierarchy)
                hand.OnWillRenderObject();
        }
        private void OnPostRenderEvent(ScriptableRenderContext context, Camera cam) {
            if(hand != null && hand.gameObject.activeInHierarchy)
                hand.OnPostRender();
        }

        private void OnPostRenderEvent(ScriptableRenderContext context, List<Camera> cameras) {
            if(hand != null && hand.gameObject.activeInHierarchy)
                hand.OnPostRender();
        }
        
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandStabilizer.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandVelocityTracker.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: bc13386119009a34bb92919fb31f8f9f
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public class HandVelocityTracker {
        HandBase hand = null;
        float minThrowVelocity = 0f;

        ///<summary> A list of all acceleration values from the time the throwing motion was detected til now.</summary>
        protected List<VelocityTimePair> m_ThrowVelocityList = new List<VelocityTimePair>();
        protected List<VelocityTimePair> m_ThrowAngleVelocityList = new List<VelocityTimePair>();

        public void ClearThrow() {
            m_ThrowVelocityList.Clear();
            m_ThrowAngleVelocityList.Clear();
        }

        float disableTime;
        float disableSeconds;
        public void Disable(float seconds) {
            disableTime = Time.realtimeSinceStartup;
            disableSeconds = seconds;
            ClearThrow();
        }

        public HandVelocityTracker(HandBase hand) {
            this.hand = hand;
        }


        public void UpdateThrowing() {
            if(disableTime + disableSeconds > Time.realtimeSinceStartup) {
                if(m_ThrowVelocityList.Count > 0) {
                    m_ThrowVelocityList.Clear();
                    m_ThrowAngleVelocityList.Clear();
                }
                return;
            }

            if(hand.holdingObj == null || hand.IsGrabbing()) {
                if(m_ThrowVelocityList.Count > 0) {
                    m_ThrowVelocityList.Clear();
                    m_ThrowAngleVelocityList.Clear();
                }

                return;
            }

            // Add current hand velocity to throw velocity list.
            m_ThrowVelocityList.Add(new VelocityTimePair() { time = Time.realtimeSinceStartup, velocity = hand.holdingObj.body == null ? Vector3.zero : hand.holdingObj.body.linearVelocity });

            // Remove old entries from m_ThrowVelocityList.
            for(int i = m_ThrowVelocityList.Count - 1; i >= 0; --i) {
                if(Time.realtimeSinceStartup - m_ThrowVelocityList[i].time >= hand.throwVelocityExpireTime) {
                    // Remove expired entry.
                    m_ThrowVelocityList.RemoveAt(i);
                }
            }

            // Add current hand velocity to throw velocity list.
            m_ThrowAngleVelocityList.Add(new VelocityTimePair() { time = Time.realtimeSinceStartup, velocity = hand.holdingObj.body == null ? Vector3.zero : hand.holdingObj.body.angularVelocity });

            // Remove old entries from m_ThrowVelocityList.
            for(int i = m_ThrowAngleVelocityList.Count - 1; i >= 0; --i) {
                if(Time.realtimeSinceStartup - m_ThrowAngleVelocityList[i].time >= hand.throwAngularVelocityExpireTime) {
                    // Remove expired entry.
                    m_ThrowAngleVelocityList.RemoveAt(i);
                }
            }
        }

        /// <summary>Returns the hands velocity times its strength</summary>
        public Vector3 ThrowVelocity() {
            if(hand.IsGrabbing() || hand.holdingObj == null)
                return Vector3.zero;

            // Calculate the average hand velocity over the course of the throw.
            Vector3 averageVelocity = Vector3.zero;
            if(m_ThrowVelocityList.Count > 0) {
                foreach(VelocityTimePair pair in m_ThrowVelocityList) {
                    averageVelocity += pair.velocity;
                }
                averageVelocity /= m_ThrowVelocityList.Count;
            }

            var vel = averageVelocity * hand.holdingObj.throwPower;

            return vel.magnitude > minThrowVelocity ? vel : Vector3.zero;
        }

        /// <summary>Returns the hands velocity times its strength</summary>
        public Vector3 ThrowAngularVelocity() {
            if(hand.IsGrabbing() || hand.holdingObj == null)
                return Vector3.zero;

            // Calculate the average hand velocity over the course of the throw.
            Vector3 averageVelocity = Vector3.zero;
            if(m_ThrowAngleVelocityList.Count > 0) {
                foreach(VelocityTimePair pair in m_ThrowAngleVelocityList) {
                    averageVelocity += pair.velocity;
                }
                averageVelocity /= m_ThrowAngleVelocityList.Count;
            }

            averageVelocity *= Mathf.Sqrt(hand.throwPower) / 2f;

            return averageVelocity.magnitude > minThrowVelocity ? averageVelocity : Vector3.zero; ;
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/HandVelocityTracker.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/IGrabbableEvents.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: 8591546fd0fd6ca468c64a608b092140
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand {
    public interface IGrabbableEvents {


        void OnHighlight(Hand hand);

        void OnUnhighlight(Hand hand);

        void OnGrab(Hand hand);

        void OnRelease(Hand hand);

        public bool CanGrab(Hand hand);

        Grabbable GetGrabbable();
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/IGrabbableEvents.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/KeyboardHand.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: ade8508f9cb7c1d439cf94e9cada134b
# ASMDEF: AutoHandAssembly.dll
# ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Autohand
{
    public class KeyboardHand : MonoBehaviour
    {
        public Hand hand;
        public float speed = 1;
        public float flySpeed = 1;
        public bool useLocal = true;

        void Update() {
            float yMove = 0;

            if(Input.GetKey(KeyCode.Space))
                yMove = 1;

            if(Input.GetKey(KeyCode.LeftShift))
                yMove = -1;

            if(Input.GetKey(KeyCode.E))
                transform.Rotate(new Vector3(speed * 90 * Time.deltaTime, 0, 0));

            if(Input.GetKey(KeyCode.Q))
                transform.Rotate(new Vector3(-speed * 90 * Time.deltaTime, 0, 0));


            if(useLocal) {
                Vector3 move = new Vector3(yMove * flySpeed, -Input.GetAxis("Horizontal") * speed, Input.GetAxis("Vertical") * speed);
                transform.position += transform.rotation * move * Time.deltaTime;
            }
            else {
                Vector3 move = new Vector3(Input.GetAxis("Horizontal") * speed, yMove * flySpeed, Input.GetAxis("Vertical") * speed);
                transform.position += move * Time.deltaTime;
            }
            if(Input.GetKeyDown(KeyCode.Mouse0))
                hand.Grab();

            if(Input.GetKeyUp(KeyCode.Mouse0))
                hand.Release();
        }
    }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/KeyboardHand.cs

# FILE: Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedJointDrive.cs
# SYSTEM: com_ldx_frameworkSystem
# TYPE: Framework.Runtime
# GUID: b71188a7ea1430a4189ce11c2e783d7e
# ASMDEF: AutoHandAssembly.dll
# ---
using UnityEngine;

[System.Serializable]
public class SerializedJointDrive {
    private JointDrive struc = new JointDrive();

    public static implicit operator JointDrive(SerializedJointDrive c) {
        return new JointDrive() { positionSpring = c._spring, positionDamper = c._damper, maximumForce = c._maxForce };
    }
    public static explicit operator SerializedJointDrive(JointDrive c) {
        return new SerializedJointDrive(c);
    }

    public SerializedJointDrive() { }
    private SerializedJointDrive(JointDrive _data) {
        this.damper = _data.positionDamper;
        this.spring = _data.positionSpring;
        this._maxForce = _data.maximumForce;
    }

    [SerializeField]
    private float _spring = 0;
    [SerializeField]
    private float _damper = 0;
    [SerializeField]
    private float _maxForce = 1000;

    public float damper { get { return struc.positionDamper; } set { _damper = struc.positionDamper = value; } }
    public float spring { get { return struc.positionSpring; } set { _spring = struc.positionSpring = value; } }
    public float maxForce { get { return struc.positionSpring; } set { _spring = struc.positionSpring = value; } }
}
# --- end Packages/com_ldx_framework/ThirdParty/AutoHand/Scripts/Internal/SerializedJointDrive.cs

